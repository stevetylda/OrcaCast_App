{"version":3,"file":"@deck__gl_mapbox.js","names":["VERSION","isBrowser","parseImageNode","VERSION","jsonLoader","webgl2Adapter","uniformBlock","DEFAULT_SHADOW_COLOR","project","geometry","DEFAULT_LIGHT_COLOR","DEFAULT_LIGHT_INTENSITY","idCount","shadow","viewport","Viewport","Controller","noop","DEGREES_TO_RADIANS","unitsPerMeter","Viewport","scale","vec3.sqrLen","vec3.sub","vec3.lerp","vec3.len","vec4.transformMat4","GlobeViewport","scale","scale","WebMercatorViewport","log","MapView","scale","WebMercatorViewport","GlobeViewport","Deck","GlobeView","MapView","scale","UNDEFINED_BEFORE_ID","Deck"],"sources":["../../@loaders.gl/images/dist/lib/utils/version.js","../../@loaders.gl/images/dist/lib/category-api/image-type.js","../../@loaders.gl/images/dist/lib/category-api/parsed-image-api.js","../../@loaders.gl/images/dist/lib/parsers/svg-utils.js","../../@loaders.gl/images/dist/lib/parsers/parse-to-image.js","../../@loaders.gl/images/dist/lib/parsers/parse-to-image-bitmap.js","../../@loaders.gl/images/dist/lib/category-api/parse-isobmff-binary.js","../../@loaders.gl/images/dist/lib/category-api/binary-image-api.js","../../@loaders.gl/images/dist/lib/parsers/parse-to-node-image.js","../../@loaders.gl/images/dist/lib/parsers/parse-image.js","../../@loaders.gl/images/dist/image-loader.js","../../@deck.gl/core/dist/utils/json-loader.js","../../@deck.gl/core/dist/lib/init.js","../../@luma.gl/core/dist/adapter/luma.js","../../@luma.gl/core/dist/adapter/adapter.js","../../@deck.gl/core/dist/shaderlib/misc/layer-uniforms.js","../../@deck.gl/core/dist/shaderlib/shadow/shadow.js","../../@deck.gl/core/dist/shaderlib/index.js","../../@deck.gl/core/dist/effects/lighting/ambient-light.js","../../@deck.gl/core/dist/effects/lighting/directional-light.js","../../@deck.gl/core/dist/passes/pass.js","../../@deck.gl/core/dist/passes/layers-pass.js","../../@deck.gl/core/dist/passes/shadow-pass.js","../../@deck.gl/core/dist/effects/lighting/lighting-effect.js","../../@luma.gl/engine/dist/animation/timeline.js","../../@luma.gl/engine/dist/animation-loop/request-animation-frame.js","../../@luma.gl/engine/dist/animation-loop/animation-loop.js","../../@deck.gl/core/dist/passes/pick-layers-pass.js","../../@deck.gl/core/dist/lib/resource/resource.js","../../@deck.gl/core/dist/lib/resource/resource-manager.js","../../@deck.gl/core/dist/lib/layer-manager.js","../../@deck.gl/core/dist/lib/view-manager.js","../../@deck.gl/core/dist/utils/positions.js","../../@deck.gl/core/dist/views/view.js","../../@deck.gl/core/dist/controllers/transition-manager.js","../../@deck.gl/core/dist/transitions/transition-interpolator.js","../../@deck.gl/core/dist/viewports/globe-viewport.js","../../@deck.gl/core/dist/transitions/linear-interpolator.js","../../@deck.gl/core/dist/controllers/controller.js","../../@deck.gl/core/dist/controllers/view-state.js","../../@deck.gl/core/dist/controllers/map-controller.js","../../@deck.gl/core/dist/views/map-view.js","../../@deck.gl/core/dist/lib/effect-manager.js","../../@deck.gl/core/dist/passes/draw-layers-pass.js","../../@deck.gl/core/dist/lib/deck-renderer.js","../../@deck.gl/core/dist/lib/picking/query-object.js","../../@deck.gl/core/dist/lib/picking/pick-info.js","../../@deck.gl/core/dist/lib/deck-picker.js","../../@deck.gl/core/dist/lib/widget-manager.js","../../@deck.gl/core/dist/utils/apply-styles.js","../../@deck.gl/core/dist/lib/widget.js","../../@deck.gl/core/dist/lib/tooltip-widget.js","../../@luma.gl/webgl/dist/context/polyfills/polyfill-webgl1-extensions.js","../../@luma.gl/webgl/dist/adapter/webgl-adapter.js","../../@deck.gl/core/dist/lib/deck.js","../../@deck.gl/core/dist/controllers/globe-controller.js","../../@deck.gl/core/dist/views/globe-view.js","../../@deck.gl/mapbox/dist/deck-utils.js","../../@deck.gl/mapbox/dist/mapbox-layer.js","../../@deck.gl/mapbox/dist/resolve-layers.js","../../@deck.gl/mapbox/dist/mapbox-layer-group.js","../../@deck.gl/mapbox/dist/resolve-layer-groups.js","../../@deck.gl/mapbox/dist/mapbox-overlay.js"],"sourcesContent":["// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof \"4.3.3\" !== 'undefined' ? \"4.3.3\" : 'latest';\n","import { isBrowser } from '@loaders.gl/loader-utils';\n// @ts-ignore TS2339: Property does not exist on type\nconst parseImageNode = globalThis.loaders?.parseImageNode;\nconst IMAGE_SUPPORTED = typeof Image !== 'undefined'; // NOTE: \"false\" positives if jsdom is installed\nconst IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== 'undefined';\nconst NODE_IMAGE_SUPPORTED = Boolean(parseImageNode);\nconst DATA_SUPPORTED = isBrowser ? true : NODE_IMAGE_SUPPORTED;\n/**\n * Checks if a loaders.gl image type is supported\n * @param type image type string\n */\nexport function isImageTypeSupported(type) {\n    switch (type) {\n        case 'auto':\n            // Should only ever be false in Node.js, if polyfills have not been installed...\n            return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;\n        case 'imagebitmap':\n            return IMAGE_BITMAP_SUPPORTED;\n        case 'image':\n            return IMAGE_SUPPORTED;\n        case 'data':\n            return DATA_SUPPORTED;\n        default:\n            throw new Error(`@loaders.gl/images: image ${type} not supported in this environment`);\n    }\n}\n/**\n * Returns the \"most performant\" supported image type on this platform\n * @returns image type string\n */\nexport function getDefaultImageType() {\n    if (IMAGE_BITMAP_SUPPORTED) {\n        return 'imagebitmap';\n    }\n    if (IMAGE_SUPPORTED) {\n        return 'image';\n    }\n    if (DATA_SUPPORTED) {\n        return 'data';\n    }\n    // This should only happen in Node.js\n    throw new Error('Install \\'@loaders.gl/polyfills\\' to parse images under Node.js');\n}\n","export function isImage(image) {\n    return Boolean(getImageTypeOrNull(image));\n}\nexport function deleteImage(image) {\n    switch (getImageType(image)) {\n        case 'imagebitmap':\n            image.close();\n            break;\n        default:\n        // Nothing to do for images and image data objects\n    }\n}\nexport function getImageType(image) {\n    const format = getImageTypeOrNull(image);\n    if (!format) {\n        throw new Error('Not an image');\n    }\n    return format;\n}\nexport function getImageSize(image) {\n    return getImageData(image);\n}\nexport function getImageData(image) {\n    switch (getImageType(image)) {\n        case 'data':\n            return image;\n        case 'image':\n        case 'imagebitmap':\n            // Extract the image data from the image via a canvas\n            const canvas = document.createElement('canvas');\n            // TODO - reuse the canvas?\n            const context = canvas.getContext('2d');\n            if (!context) {\n                throw new Error('getImageData');\n            }\n            // @ts-ignore\n            canvas.width = image.width;\n            // @ts-ignore\n            canvas.height = image.height;\n            // @ts-ignore\n            context.drawImage(image, 0, 0);\n            // @ts-ignore\n            return context.getImageData(0, 0, image.width, image.height);\n        default:\n            throw new Error('getImageData');\n    }\n}\n// PRIVATE\n// eslint-disable-next-line complexity\nfunction getImageTypeOrNull(image) {\n    if (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n        return 'imagebitmap';\n    }\n    if (typeof Image !== 'undefined' && image instanceof Image) {\n        return 'image';\n    }\n    if (image && typeof image === 'object' && image.data && image.width && image.height) {\n        return 'data';\n    }\n    return null;\n}\n","// SVG parsing has limitations, e.g:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=606319\nconst SVG_DATA_URL_PATTERN = /^data:image\\/svg\\+xml/;\nconst SVG_URL_PATTERN = /\\.svg((\\?|#).*)?$/;\nexport function isSVG(url) {\n    return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));\n}\nexport function getBlobOrSVGDataUrl(arrayBuffer, url) {\n    if (isSVG(url)) {\n        // Prepare a properly tagged data URL, and load using normal mechanism\n        const textDecoder = new TextDecoder();\n        let xmlText = textDecoder.decode(arrayBuffer);\n        // TODO Escape in browser to support e.g. Chinese characters\n        try {\n            if (typeof unescape === 'function' && typeof encodeURIComponent === 'function') {\n                xmlText = unescape(encodeURIComponent(xmlText));\n            }\n        }\n        catch (error) {\n            throw new Error(error.message);\n        }\n        // base64 encoding is safer. utf-8 fails in some browsers\n        const src = `data:image/svg+xml;base64,${btoa(xmlText)}`;\n        return src;\n    }\n    return getBlob(arrayBuffer, url);\n}\nexport function getBlob(arrayBuffer, url) {\n    if (isSVG(url)) {\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=606319\n        // return new Blob([new Uint8Array(arrayBuffer)], {type: 'image/svg+xml'});\n        throw new Error('SVG cannot be parsed directly to imagebitmap');\n    }\n    // TODO - how to determine mime type? Param? Sniff here?\n    return new Blob([new Uint8Array(arrayBuffer)]); // MIME type not needed?\n}\n","import { getBlobOrSVGDataUrl } from \"./svg-utils.js\";\n// Parses html image from array buffer\nexport async function parseToImage(arrayBuffer, options, url) {\n    // Note: image parsing requires conversion to Blob (for createObjectURL).\n    // Potentially inefficient for not using `response.blob()` (and for File / Blob inputs)...\n    // But presumably not worth adding 'blob' flag to loader objects?\n    const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n    const URL = self.URL || self.webkitURL;\n    const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n    try {\n        return await loadToImage(objectUrl || blobOrDataUrl, options);\n    }\n    finally {\n        if (objectUrl) {\n            URL.revokeObjectURL(objectUrl);\n        }\n    }\n}\nexport async function loadToImage(url, options) {\n    const image = new Image();\n    image.src = url;\n    // The `image.onload()` callback does not guarantee that the image has been decoded\n    // so a main thread \"freeze\" can be incurred when using the image for the first time.\n    // `Image.decode()` returns a promise that completes when image is decoded.\n    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode\n    // Note: When calling `img.decode()`, we do not need to wait for `img.onload()`\n    // Note: `HTMLImageElement.decode()` is not available in Edge and IE11\n    if (options.image && options.image.decode && image.decode) {\n        await image.decode();\n        return image;\n    }\n    // Create a promise that tracks onload/onerror callbacks\n    return await new Promise((resolve, reject) => {\n        try {\n            image.onload = () => resolve(image);\n            image.onerror = (error) => {\n                const message = error instanceof Error ? error.message : 'error';\n                reject(new Error(message));\n            };\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n}\n","import { isSVG, getBlob } from \"./svg-utils.js\";\nimport { parseToImage } from \"./parse-to-image.js\";\nconst EMPTY_OBJECT = {};\nlet imagebitmapOptionsSupported = true;\n/**\n * Asynchronously parses an array buffer into an ImageBitmap - this contains the decoded data\n * ImageBitmaps are supported on worker threads, but not supported on Edge, IE11 and Safari\n * https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap#Browser_compatibility\n *\n * TODO - createImageBitmap supports source rect (5 param overload), pass through?\n */\nexport async function parseToImageBitmap(arrayBuffer, options, url) {\n    let blob;\n    // Cannot parse SVG directly to ImageBitmap, parse to Image first\n    if (isSVG(url)) {\n        // Note: this only works on main thread\n        const image = await parseToImage(arrayBuffer, options, url);\n        blob = image;\n    }\n    else {\n        // Create blob from the array buffer\n        blob = getBlob(arrayBuffer, url);\n    }\n    const imagebitmapOptions = options && options.imagebitmap;\n    return await safeCreateImageBitmap(blob, imagebitmapOptions);\n}\n/**\n * Safely creates an imageBitmap with options\n * *\n * Firefox crashes if imagebitmapOptions is supplied\n * Avoid supplying if not provided or supported, remember if not supported\n */\nasync function safeCreateImageBitmap(blob, imagebitmapOptions = null) {\n    if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {\n        imagebitmapOptions = null;\n    }\n    if (imagebitmapOptions) {\n        try {\n            // @ts-ignore Options\n            return await createImageBitmap(blob, imagebitmapOptions);\n        }\n        catch (error) {\n            console.warn(error); // eslint-disable-line\n            imagebitmapOptionsSupported = false;\n        }\n    }\n    return await createImageBitmap(blob);\n}\nfunction isEmptyObject(object) {\n    // @ts-ignore\n    for (const key in object || EMPTY_OBJECT) {\n        return false;\n    }\n    return true;\n}\n","// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// code adapted from https://github.com/sindresorhus/file-type under MIT license\n/**\n * Tests if a buffer is in ISO base media file format (ISOBMFF) @see https://en.wikipedia.org/wiki/ISO_base_media_file_format\n * (ISOBMFF is a media container standard based on the Apple QuickTime container format)\n */\nexport function getISOBMFFMediaType(buffer) {\n    // Almost all ISO base media files start with `ftyp` box. (It's not required to be first, but it's recommended to be.)\n    if (!checkString(buffer, 'ftyp', 4)) {\n        return null;\n    }\n    // Extra check: test for 8859-1 printable characters (for simplicity, it's a mask which also catches one non-printable character).\n    if ((buffer[8] & 0x60) === 0x00) {\n        return null;\n    }\n    // `ftyp` box must contain a brand major identifier, which must consist of ISO 8859-1 printable characters.\n    return decodeMajorBrand(buffer);\n}\n/**\n * brands explained @see https://github.com/strukturag/libheif/issues/83\n * code adapted from @see https://github.com/sindresorhus/file-type/blob/main/core.js#L489-L492\n */\nexport function decodeMajorBrand(buffer) {\n    const brandMajor = getUTF8String(buffer, 8, 12).replace('\\0', ' ').trim();\n    switch (brandMajor) {\n        case 'avif':\n        case 'avis':\n            return { extension: 'avif', mimeType: 'image/avif' };\n        default:\n            return null;\n    }\n    // We don't need these now, but they are easy to add\n    // case 'mif1':\n    //   return {extension: 'heic', mimeType: 'image/heif'};\n    // case 'msf1':\n    //   return {extension: 'heic', mimeType: 'image/heif-sequence'};\n    // case 'heic':\n    // case 'heix':\n    //   return {extension: 'heic', mimeType: 'image/heic'};\n    // case 'hevc':\n    // case 'hevx':\n    //   return {extension: 'heic', mimeType: 'image/heic-sequence'};\n    // case 'qt':\n    //   return {ext: 'mov', mime: 'video/quicktime'};\n    // case 'M4V':\n    // case 'M4VH':\n    // case 'M4VP':\n    //   return {ext: 'm4v', mime: 'video/x-m4v'};\n    // case 'M4P':\n    //   return {ext: 'm4p', mime: 'video/mp4'};\n    // case 'M4B':\n    //   return {ext: 'm4b', mime: 'audio/mp4'};\n    // case 'M4A':\n    //   return {ext: 'm4a', mime: 'audio/x-m4a'};\n    // case 'F4V':\n    //   return {ext: 'f4v', mime: 'video/mp4'};\n    // case 'F4P':\n    //   return {ext: 'f4p', mime: 'video/mp4'};\n    // case 'F4A':\n    //   return {ext: 'f4a', mime: 'audio/mp4'};\n    // case 'F4B':\n    //   return {ext: 'f4b', mime: 'audio/mp4'};\n    // case 'crx':\n    //   return {ext: 'cr3', mime: 'image/x-canon-cr3'};\n    // default:\n    // if (brandMajor.startsWith('3g')) {\n    //   if (brandMajor.startsWith('3g2')) {\n    //     return {ext: '3g2', mime: 'video/3gpp2'};\n    //   }\n    //   return {ext: '3gp', mime: 'video/3gpp'};\n    // }\n    // return {ext: 'mp4', mime: 'video/mp4'};\n}\n/** Interpret a chunk of bytes as a UTF8 string */\nfunction getUTF8String(array, start, end) {\n    return String.fromCharCode(...array.slice(start, end));\n}\nfunction stringToBytes(string) {\n    return [...string].map((character) => character.charCodeAt(0));\n}\nfunction checkString(buffer, header, offset = 0) {\n    const headerBytes = stringToBytes(header);\n    for (let i = 0; i < headerBytes.length; ++i) {\n        if (headerBytes[i] !== buffer[i + offset]) {\n            return false;\n        }\n    }\n    return true;\n}\n","// Attributions\n// * Based on binary-gltf-utils under MIT license: Copyright (c) 2016-17 Karl Cheng\nimport { getISOBMFFMediaType } from \"./parse-isobmff-binary.js\";\nconst BIG_ENDIAN = false;\nconst LITTLE_ENDIAN = true;\n/**\n * Extracts `{mimeType, width and height}` from a memory buffer containing a known image format\n * Currently supports `image/png`, `image/jpeg`, `image/bmp` and `image/gif`.\n * @param binaryData: DataView | ArrayBuffer image file memory to parse\n * @returns metadata or null if memory is not a valid image file format layout.\n */\nexport function getBinaryImageMetadata(binaryData) {\n    const dataView = toDataView(binaryData);\n    return (getPngMetadata(dataView) ||\n        getJpegMetadata(dataView) ||\n        getGifMetadata(dataView) ||\n        getBmpMetadata(dataView) ||\n        getISOBMFFMetadata(dataView));\n}\n// ISOBMFF\nfunction getISOBMFFMetadata(binaryData) {\n    const buffer = new Uint8Array(binaryData instanceof DataView ? binaryData.buffer : binaryData);\n    const mediaType = getISOBMFFMediaType(buffer);\n    if (!mediaType) {\n        return null;\n    }\n    return {\n        mimeType: mediaType.mimeType,\n        // TODO - decode width and height\n        width: 0,\n        height: 0\n    };\n}\n// PNG\nfunction getPngMetadata(binaryData) {\n    const dataView = toDataView(binaryData);\n    // Check file contains the first 4 bytes of the PNG signature.\n    const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 0x89504e47;\n    if (!isPng) {\n        return null;\n    }\n    // Extract size from a binary PNG file\n    return {\n        mimeType: 'image/png',\n        width: dataView.getUint32(16, BIG_ENDIAN),\n        height: dataView.getUint32(20, BIG_ENDIAN)\n    };\n}\n// GIF\n// Extract size from a binary GIF file\n// TODO: GIF is not this simple\nfunction getGifMetadata(binaryData) {\n    const dataView = toDataView(binaryData);\n    // Check first 4 bytes of the GIF signature (\"GIF8\").\n    const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 0x47494638;\n    if (!isGif) {\n        return null;\n    }\n    // GIF is little endian.\n    return {\n        mimeType: 'image/gif',\n        width: dataView.getUint16(6, LITTLE_ENDIAN),\n        height: dataView.getUint16(8, LITTLE_ENDIAN)\n    };\n}\n// BMP\n// TODO: BMP is not this simple\nexport function getBmpMetadata(binaryData) {\n    const dataView = toDataView(binaryData);\n    // Check magic number is valid (first 2 characters should be \"BM\").\n    // The mandatory bitmap file header is 14 bytes long.\n    const isBmp = dataView.byteLength >= 14 &&\n        dataView.getUint16(0, BIG_ENDIAN) === 0x424d &&\n        dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;\n    if (!isBmp) {\n        return null;\n    }\n    // BMP is little endian.\n    return {\n        mimeType: 'image/bmp',\n        width: dataView.getUint32(18, LITTLE_ENDIAN),\n        height: dataView.getUint32(22, LITTLE_ENDIAN)\n    };\n}\n// JPEG\n// Extract width and height from a binary JPEG file\nfunction getJpegMetadata(binaryData) {\n    const dataView = toDataView(binaryData);\n    // Check file contains the JPEG \"start of image\" (SOI) marker\n    // followed by another marker.\n    const isJpeg = dataView.byteLength >= 3 &&\n        dataView.getUint16(0, BIG_ENDIAN) === 0xffd8 &&\n        dataView.getUint8(2) === 0xff;\n    if (!isJpeg) {\n        return null;\n    }\n    const { tableMarkers, sofMarkers } = getJpegMarkers();\n    // Exclude the two byte SOI marker.\n    let i = 2;\n    while (i + 9 < dataView.byteLength) {\n        const marker = dataView.getUint16(i, BIG_ENDIAN);\n        // The frame that contains the width and height of the JPEG image.\n        if (sofMarkers.has(marker)) {\n            return {\n                mimeType: 'image/jpeg',\n                height: dataView.getUint16(i + 5, BIG_ENDIAN), // Number of lines\n                width: dataView.getUint16(i + 7, BIG_ENDIAN) // Number of pixels per line\n            };\n        }\n        // Miscellaneous tables/data preceding the frame header.\n        if (!tableMarkers.has(marker)) {\n            return null;\n        }\n        // Length includes size of length parameter but not the two byte header.\n        i += 2;\n        i += dataView.getUint16(i, BIG_ENDIAN);\n    }\n    return null;\n}\nfunction getJpegMarkers() {\n    // Tables/misc header markers.\n    // DQT, DHT, DAC, DRI, COM, APP_n\n    const tableMarkers = new Set([0xffdb, 0xffc4, 0xffcc, 0xffdd, 0xfffe]);\n    for (let i = 0xffe0; i < 0xfff0; ++i) {\n        tableMarkers.add(i);\n    }\n    // SOF markers and DHP marker.\n    // These markers are after tables/misc data.\n    const sofMarkers = new Set([\n        0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc9, 0xffca, 0xffcb, 0xffcd, 0xffce,\n        0xffcf, 0xffde\n    ]);\n    return { tableMarkers, sofMarkers };\n}\n// TODO - move into image module?\nfunction toDataView(data) {\n    if (data instanceof DataView) {\n        return data;\n    }\n    if (ArrayBuffer.isView(data)) {\n        return new DataView(data.buffer);\n    }\n    // TODO: make these functions work for Node.js buffers?\n    // if (bufferToArrayBuffer) {\n    //   data = bufferToArrayBuffer(data);\n    // }\n    // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)\n    if (data instanceof ArrayBuffer) {\n        return new DataView(data);\n    }\n    throw new Error('toDataView');\n}\n","import { assert } from '@loaders.gl/loader-utils';\nimport { getBinaryImageMetadata } from \"../category-api/binary-image-api.js\";\n// Use polyfills if installed to parsed image using get-pixels\nexport async function parseToNodeImage(arrayBuffer, options) {\n    const { mimeType } = getBinaryImageMetadata(arrayBuffer) || {};\n    // @ts-ignore\n    const parseImageNode = globalThis.loaders?.parseImageNode;\n    assert(parseImageNode); // '@loaders.gl/polyfills not installed'\n    // @ts-expect-error TODO should we throw error in this case?\n    return await parseImageNode(arrayBuffer, mimeType);\n}\n","import { assert } from '@loaders.gl/loader-utils';\nimport { isImageTypeSupported, getDefaultImageType } from \"../category-api/image-type.js\";\nimport { getImageData } from \"../category-api/parsed-image-api.js\";\nimport { parseToImage } from \"./parse-to-image.js\";\nimport { parseToImageBitmap } from \"./parse-to-image-bitmap.js\";\nimport { parseToNodeImage } from \"./parse-to-node-image.js\";\n// Parse to platform defined image type (data on node, ImageBitmap or HTMLImage on browser)\n// eslint-disable-next-line complexity\nexport async function parseImage(arrayBuffer, options, context) {\n    options = options || {};\n    const imageOptions = options.image || {};\n    // The user can request a specific output format via `options.image.type`\n    const imageType = imageOptions.type || 'auto';\n    const { url } = context || {};\n    // Note: For options.image.type === `data`, we may still need to load as `image` or `imagebitmap`\n    const loadType = getLoadableImageType(imageType);\n    let image;\n    switch (loadType) {\n        case 'imagebitmap':\n            image = await parseToImageBitmap(arrayBuffer, options, url);\n            break;\n        case 'image':\n            image = await parseToImage(arrayBuffer, options, url);\n            break;\n        case 'data':\n            // Node.js loads imagedata directly\n            image = await parseToNodeImage(arrayBuffer, options);\n            break;\n        default:\n            assert(false);\n    }\n    // Browser: if options.image.type === 'data', we can now extract data from the loaded image\n    if (imageType === 'data') {\n        image = getImageData(image);\n    }\n    return image;\n}\n// Get a loadable image type from image type\nfunction getLoadableImageType(type) {\n    switch (type) {\n        case 'auto':\n        case 'data':\n            // Browser: For image data we need still need to load using an image format\n            // Node: the default image type is `data`.\n            return getDefaultImageType();\n        default:\n            // Throw an error if not supported\n            isImageTypeSupported(type);\n            return type;\n    }\n}\n","// import type { ImageType } from '@loaders.gl/schema';\nimport { VERSION } from \"./lib/utils/version.js\";\nimport { parseImage } from \"./lib/parsers/parse-image.js\";\nimport { getBinaryImageMetadata } from \"./lib/category-api/binary-image-api.js\";\nconst EXTENSIONS = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'ico', 'svg', 'avif'];\nconst MIME_TYPES = [\n    'image/png',\n    'image/jpeg',\n    'image/gif',\n    'image/webp',\n    'image/avif',\n    'image/bmp',\n    'image/vnd.microsoft.icon',\n    'image/svg+xml'\n];\nconst DEFAULT_IMAGE_LOADER_OPTIONS = {\n    image: {\n        type: 'auto',\n        decode: true // if format is HTML\n    }\n    // imagebitmap: {} - passes (platform dependent) parameters to ImageBitmap constructor\n};\n/**\n * Loads a platform-specific image type\n * Note: This type can be used as input data to WebGL texture creation\n */\nexport const ImageLoader = {\n    dataType: null,\n    batchType: null,\n    id: 'image',\n    module: 'images',\n    name: 'Images',\n    version: VERSION,\n    mimeTypes: MIME_TYPES,\n    extensions: EXTENSIONS,\n    parse: parseImage,\n    // TODO: byteOffset, byteLength;\n    tests: [(arrayBuffer) => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer)))],\n    options: DEFAULT_IMAGE_LOADER_OPTIONS\n};\n","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nfunction isJSON(text) {\n    const firstChar = text[0];\n    const lastChar = text[text.length - 1];\n    return (firstChar === '{' && lastChar === '}') || (firstChar === '[' && lastChar === ']');\n}\n// A light weight version instead of @loaders.gl/json (stream processing etc.)\nexport default {\n    dataType: null,\n    batchType: null,\n    id: 'JSON',\n    name: 'JSON',\n    module: '',\n    version: '',\n    options: {},\n    extensions: ['json', 'geojson'],\n    mimeTypes: ['application/json', 'application/geo+json'],\n    testText: isJSON,\n    parseTextSync: JSON.parse\n};\n//# sourceMappingURL=json-loader.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { registerLoaders } from '@loaders.gl/core';\nimport { ImageLoader } from '@loaders.gl/images';\nimport log from \"../utils/log.js\";\nimport { register } from \"../debug/index.js\";\nimport jsonLoader from \"../utils/json-loader.js\";\nfunction checkVersion() {\n    // Version detection using typescript plugin.\n    // Fallback for tests and SSR since global variable is defined by esbuild.\n    const version = typeof \"9.2.6\" !== 'undefined'\n        ? \"9.2.6\" : globalThis.DECK_VERSION || 'untranspiled source';\n    // Note: a `deck` object not created by deck.gl may exist in the global scope\n    const existingVersion = globalThis.deck && globalThis.deck.VERSION;\n    if (existingVersion && existingVersion !== version) {\n        throw new Error(`deck.gl - multiple versions detected: ${existingVersion} vs ${version}`);\n    }\n    if (!existingVersion) {\n        log.log(1, `deck.gl ${version}`)();\n        globalThis.deck = {\n            ...globalThis.deck,\n            VERSION: version,\n            version,\n            log,\n            // experimental\n            _registerLoggers: register\n        };\n        registerLoaders([\n            jsonLoader,\n            // @ts-expect-error non-standard Loader format\n            [ImageLoader, { imagebitmap: { premultiplyAlpha: 'none' } }]\n        ]);\n    }\n    return version;\n}\nexport const VERSION = checkVersion();\n//# sourceMappingURL=init.js.map","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Device } from \"./device.js\";\nimport { lumaStats } from \"../utils/stats-manager.js\";\nimport { log } from \"../utils/log.js\";\nconst STARTUP_MESSAGE = 'set luma.log.level=1 (or higher) to trace rendering';\nconst ERROR_MESSAGE = 'No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.';\n/**\n * Entry point to the luma.gl GPU abstraction\n * Register WebGPU and/or WebGL adapters (controls application bundle size)\n * Run-time selection of the first available Device\n */\nexport class Luma {\n    static defaultProps = {\n        ...Device.defaultProps,\n        type: 'best-available',\n        adapters: undefined,\n        waitForPageLoad: true\n    };\n    /** Global stats for all devices */\n    stats = lumaStats;\n    /**\n     * Global log\n     *\n     * Assign luma.log.level in console to control logging: \\\n     * 0: none, 1: minimal, 2: verbose, 3: attribute/uniforms, 4: gl logs\n     * luma.log.break[], set to gl funcs, luma.log.profile[] set to model names`;\n     */\n    log = log;\n    /** Version of luma.gl */\n    VERSION = \n    // Version detection using build plugin\n    // @ts-expect-error no-undef\n    typeof \"9.2.6\" !== 'undefined' ? \"9.2.6\" : 'running from source';\n    spector;\n    preregisteredAdapters = new Map();\n    constructor() {\n        if (globalThis.luma) {\n            if (globalThis.luma.VERSION !== this.VERSION) {\n                log.error(`Found luma.gl ${globalThis.luma.VERSION} while initialzing ${this.VERSION}`)();\n                log.error(`'yarn why @luma.gl/core' can help identify the source of the conflict`)();\n                throw new Error(`luma.gl - multiple versions detected: see console log`);\n            }\n            log.error('This version of luma.gl has already been initialized')();\n        }\n        log.log(1, `${this.VERSION} - ${STARTUP_MESSAGE}`)();\n        globalThis.luma = this;\n    }\n    /** Creates a device. Asynchronously. */\n    async createDevice(props_ = {}) {\n        const props = { ...Luma.defaultProps, ...props_ };\n        const adapter = this.selectAdapter(props.type, props.adapters);\n        if (!adapter) {\n            throw new Error(ERROR_MESSAGE);\n        }\n        // Wait for page to load so that CanvasContext's can access the DOM.\n        if (props.waitForPageLoad) {\n            await adapter.pageLoaded;\n        }\n        return await adapter.create(props);\n    }\n    /**\n     * Attach to an existing GPU API handle (WebGL2RenderingContext or GPUDevice).\n     * @param handle Externally created WebGL context or WebGPU device\n     */\n    async attachDevice(handle, props) {\n        const type = this._getTypeFromHandle(handle, props.adapters);\n        const adapter = type && this.selectAdapter(type, props.adapters);\n        if (!adapter) {\n            throw new Error(ERROR_MESSAGE);\n        }\n        return await adapter?.attach?.(handle, props);\n    }\n    /**\n     * Global adapter registration.\n     * @deprecated Use props.adapters instead\n     */\n    registerAdapters(adapters) {\n        for (const deviceClass of adapters) {\n            this.preregisteredAdapters.set(deviceClass.type, deviceClass);\n        }\n    }\n    /** Get type strings for supported Devices */\n    getSupportedAdapters(adapters = []) {\n        const adapterMap = this._getAdapterMap(adapters);\n        return Array.from(adapterMap)\n            .map(([, adapter]) => adapter)\n            .filter(adapter => adapter.isSupported?.())\n            .map(adapter => adapter.type);\n    }\n    /** Get type strings for best available Device */\n    getBestAvailableAdapterType(adapters = []) {\n        const KNOWN_ADAPTERS = ['webgpu', 'webgl', 'null'];\n        const adapterMap = this._getAdapterMap(adapters);\n        for (const type of KNOWN_ADAPTERS) {\n            if (adapterMap.get(type)?.isSupported?.()) {\n                return type;\n            }\n        }\n        return null;\n    }\n    /** Select adapter of type from registered adapters */\n    selectAdapter(type, adapters = []) {\n        let selectedType = type;\n        if (type === 'best-available') {\n            selectedType = this.getBestAvailableAdapterType(adapters);\n        }\n        const adapterMap = this._getAdapterMap(adapters);\n        return (selectedType && adapterMap.get(selectedType)) || null;\n    }\n    /**\n     * Override `HTMLCanvasContext.getCanvas()` to always create WebGL2 contexts with additional WebGL1 compatibility.\n     * Useful when attaching luma to a context from an external library does not support creating WebGL2 contexts.\n     */\n    enforceWebGL2(enforce = true, adapters = []) {\n        const adapterMap = this._getAdapterMap(adapters);\n        const webgl2Adapter = adapterMap.get('webgl');\n        if (!webgl2Adapter) {\n            log.warn('enforceWebGL2: webgl adapter not found')();\n        }\n        webgl2Adapter?.enforceWebGL2?.(enforce);\n    }\n    // DEPRECATED\n    /** @deprecated */\n    setDefaultDeviceProps(props) {\n        Object.assign(Luma.defaultProps, props);\n    }\n    // HELPERS\n    /** Convert a list of adapters to a map */\n    _getAdapterMap(adapters = []) {\n        const map = new Map(this.preregisteredAdapters);\n        for (const adapter of adapters) {\n            map.set(adapter.type, adapter);\n        }\n        return map;\n    }\n    /** Get type of a handle (for attachDevice) */\n    _getTypeFromHandle(handle, adapters = []) {\n        // TODO - delegate handle identification to adapters\n        // WebGL\n        if (handle instanceof WebGL2RenderingContext) {\n            return 'webgl';\n        }\n        if (typeof GPUDevice !== 'undefined' && handle instanceof GPUDevice) {\n            return 'webgpu';\n        }\n        // TODO - WebGPU does not yet seem to have a stable in-browser API, so we \"sniff\" for members instead\n        if (handle?.queue) {\n            return 'webgpu';\n        }\n        // null\n        if (handle === null) {\n            return 'null';\n        }\n        if (handle instanceof WebGLRenderingContext) {\n            log.warn('WebGL1 is not supported', handle)();\n        }\n        else {\n            log.warn('Unknown handle type', handle)();\n        }\n        return null;\n    }\n}\n/**\n * Entry point to the luma.gl GPU abstraction\n * Register WebGPU and/or WebGL adapters (controls application bundle size)\n * Run-time selection of the first available Device\n */\nexport const luma = new Luma();\n//# sourceMappingURL=luma.js.map","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isBrowser } from '@probe.gl/env';\n/**\n * Create and attach devices for a specific backend.\n */\nexport class Adapter {\n    /**\n     * Page load promise\n     * Resolves when the DOM is loaded.\n     * @note Since are be limitations on number of `load` event listeners,\n     * it is recommended avoid calling this accessor until actually needed.\n     * I.e. we don't call it unless you know that you will be looking up a string in the DOM.\n     */\n    get pageLoaded() {\n        return getPageLoadPromise();\n    }\n}\n// HELPER FUNCTIONS\nconst isPage = isBrowser() && typeof document !== 'undefined';\nconst isPageLoaded = () => isPage && document.readyState === 'complete';\nlet pageLoadPromise = null;\n/** Returns a promise that resolves when the page is loaded */\nfunction getPageLoadPromise() {\n    if (!pageLoadPromise) {\n        if (isPageLoaded() || typeof window === 'undefined') {\n            pageLoadPromise = Promise.resolve();\n        }\n        else {\n            pageLoadPromise = new Promise(resolve => window.addEventListener('load', () => resolve()));\n        }\n    }\n    return pageLoadPromise;\n}\n//# sourceMappingURL=adapter.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst uniformBlock = `\\\nuniform layerUniforms {\n  uniform float opacity;\n} layer;\n`;\nexport const layerUniforms = {\n    name: 'layer',\n    vs: uniformBlock,\n    fs: uniformBlock,\n    getUniforms: (props) => {\n        return {\n            // apply gamma to opacity to make it visually \"linear\"\n            // TODO - v10: use raw opacity?\n            opacity: Math.pow(props.opacity, 1 / 2.2)\n        };\n    },\n    uniformTypes: {\n        opacity: 'f32'\n    }\n};\n//# sourceMappingURL=layer-uniforms.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { COORDINATE_SYSTEM, PROJECTION_MODE } from \"../../lib/constants.js\";\nimport project from \"../project/project.js\";\nimport { Vector3, Matrix4 } from '@math.gl/core';\nimport memoize from \"../../utils/memoize.js\";\nimport { pixelsToWorld } from '@math.gl/web-mercator';\nconst uniformBlock = /* glsl */ `\nuniform shadowUniforms {\n  bool drawShadowMap;\n  bool useShadowMap;\n  vec4 color;\n  highp int lightId;\n  float lightCount;\n  mat4 viewProjectionMatrix0;\n  mat4 viewProjectionMatrix1;\n  vec4 projectCenter0;\n  vec4 projectCenter1;\n} shadow;\n`;\nconst vertex = /* glsl */ `\nconst int max_lights = 2;\n\nout vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  mat4 viewProjectionMatrices[max_lights];\n  viewProjectionMatrices[0] = shadow.viewProjectionMatrix0;\n  viewProjectionMatrices[1] = shadow.viewProjectionMatrix1;\n  vec4 projectCenters[max_lights];\n  projectCenters[0] = shadow.projectCenter0;\n  projectCenters[1] = shadow.projectCenter1;\n\n  if (shadow.drawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[shadow.lightId], projectCenters[shadow.lightId]);\n  }\n  if (shadow.useShadowMap) {\n    for (int i = 0; i < max_lights; i++) {\n      if(i < int(shadow.lightCount)) {\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[i], projectCenters[i]);\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n`;\nconst vs = `\n${uniformBlock}\n${vertex}\n`;\nconst fragment = /* glsl */ `\nconst int max_lights = 2;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\n\nin vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth = texture(shadowMap, position.xy);\n\n  float z = dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow.drawShadowMap) {\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow.useShadowMap) {\n    float shadowAlpha = 0.0;\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow.lightCount > 1.0) {\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *= shadow.color.a / shadow.lightCount;\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow.color.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n`;\nconst fs = `\n${uniformBlock}\n${fragment}\n`;\nconst getMemoizedViewportCenterPosition = memoize(getViewportCenterPosition);\nconst getMemoizedViewProjectionMatrices = memoize(getViewProjectionMatrices);\nconst DEFAULT_SHADOW_COLOR = [0, 0, 0, 1.0];\nconst VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];\nfunction screenToCommonSpace(xyz, pixelUnprojectionMatrix) {\n    const [x, y, z] = xyz;\n    const coord = pixelsToWorld([x, y, z], pixelUnprojectionMatrix);\n    if (Number.isFinite(z)) {\n        return coord;\n    }\n    return [coord[0], coord[1], 0];\n}\nfunction getViewportCenterPosition({ viewport, center }) {\n    return new Matrix4(viewport.viewProjectionMatrix).invert().transform(center);\n}\nfunction getViewProjectionMatrices({ viewport, shadowMatrices }) {\n    const projectionMatrices = [];\n    const pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;\n    const farZ = viewport.isGeospatial ? undefined : 1;\n    const corners = [\n        [0, 0, farZ], // top left ground\n        [viewport.width, 0, farZ], // top right ground\n        [0, viewport.height, farZ], // bottom left ground\n        [viewport.width, viewport.height, farZ], // bottom right ground\n        [0, 0, -1], // top left near\n        [viewport.width, 0, -1], // top right near\n        [0, viewport.height, -1], // bottom left near\n        [viewport.width, viewport.height, -1] // bottom right near\n    ].map(pixel => \n    // @ts-expect-error z may be undefined\n    screenToCommonSpace(pixel, pixelUnprojectionMatrix));\n    for (const shadowMatrix of shadowMatrices) {\n        const viewMatrix = shadowMatrix.clone().translate(new Vector3(viewport.center).negate());\n        const positions = corners.map(corner => viewMatrix.transform(corner));\n        const projectionMatrix = new Matrix4().ortho({\n            left: Math.min(...positions.map(position => position[0])),\n            right: Math.max(...positions.map(position => position[0])),\n            bottom: Math.min(...positions.map(position => position[1])),\n            top: Math.max(...positions.map(position => position[1])),\n            near: Math.min(...positions.map(position => -position[2])),\n            far: Math.max(...positions.map(position => -position[2]))\n        });\n        projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));\n    }\n    return projectionMatrices;\n}\n/* eslint-disable camelcase */\n// eslint-disable-next-line complexity\nfunction createShadowUniforms(opts) {\n    const { shadowEnabled = true, project: projectProps } = opts;\n    if (!shadowEnabled || !projectProps || !opts.shadowMatrices || !opts.shadowMatrices.length) {\n        return {\n            drawShadowMap: false,\n            useShadowMap: false,\n            shadow_uShadowMap0: opts.dummyShadowMap,\n            shadow_uShadowMap1: opts.dummyShadowMap\n        };\n    }\n    const projectUniforms = project.getUniforms(projectProps);\n    const center = getMemoizedViewportCenterPosition({\n        viewport: projectProps.viewport,\n        center: projectUniforms.center\n    });\n    const projectCenters = [];\n    const viewProjectionMatrices = getMemoizedViewProjectionMatrices({\n        shadowMatrices: opts.shadowMatrices,\n        viewport: projectProps.viewport\n    }).slice();\n    for (let i = 0; i < opts.shadowMatrices.length; i++) {\n        const viewProjectionMatrix = viewProjectionMatrices[i];\n        const viewProjectionMatrixCentered = viewProjectionMatrix\n            .clone()\n            .translate(new Vector3(projectProps.viewport.center).negate());\n        if (projectUniforms.coordinateSystem === COORDINATE_SYSTEM.LNGLAT &&\n            projectUniforms.projectionMode === PROJECTION_MODE.WEB_MERCATOR) {\n            viewProjectionMatrices[i] = viewProjectionMatrixCentered;\n            projectCenters[i] = center;\n        }\n        else {\n            viewProjectionMatrices[i] = viewProjectionMatrix\n                .clone()\n                .multiplyRight(VECTOR_TO_POINT_MATRIX);\n            projectCenters[i] = viewProjectionMatrixCentered.transform(center);\n        }\n    }\n    const uniforms = {\n        drawShadowMap: Boolean(opts.drawToShadowMap),\n        useShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,\n        color: opts.shadowColor || DEFAULT_SHADOW_COLOR,\n        lightId: opts.shadowLightId || 0,\n        lightCount: opts.shadowMatrices.length,\n        shadow_uShadowMap0: opts.dummyShadowMap,\n        shadow_uShadowMap1: opts.dummyShadowMap\n    };\n    for (let i = 0; i < viewProjectionMatrices.length; i++) {\n        uniforms[`viewProjectionMatrix${i}`] = viewProjectionMatrices[i];\n        uniforms[`projectCenter${i}`] = projectCenters[i];\n    }\n    for (let i = 0; i < 2; i++) {\n        uniforms[`shadow_uShadowMap${i}`] =\n            (opts.shadowMaps && opts.shadowMaps[i]) || opts.dummyShadowMap;\n    }\n    return uniforms;\n}\nexport default {\n    name: 'shadow',\n    dependencies: [project],\n    vs,\n    fs,\n    inject: {\n        'vs:DECKGL_FILTER_GL_POSITION': `\n    position = shadow_setVertexPosition(geometry.position);\n    `,\n        'fs:DECKGL_FILTER_COLOR': `\n    color = shadow_filterShadowColor(color);\n    `\n    },\n    getUniforms: createShadowUniforms,\n    uniformTypes: {\n        drawShadowMap: 'f32',\n        useShadowMap: 'f32',\n        color: 'vec4<f32>',\n        lightId: 'i32',\n        lightCount: 'f32',\n        viewProjectionMatrix0: 'mat4x4<f32>',\n        viewProjectionMatrix1: 'mat4x4<f32>',\n        projectCenter0: 'vec4<f32>',\n        projectCenter1: 'vec4<f32>'\n    }\n};\n//# sourceMappingURL=shadow.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { ShaderAssembler } from '@luma.gl/shadertools';\nimport { gouraudMaterial, phongMaterial } from '@luma.gl/shadertools';\nimport { layerUniforms } from \"./misc/layer-uniforms.js\";\nimport color from \"./color/color.js\";\nimport geometry from \"./misc/geometry.js\";\nimport project from \"./project/project.js\";\nimport project32 from \"./project32/project32.js\";\nimport shadow from \"./shadow/shadow.js\";\nimport picking from \"./picking/picking.js\";\nconst DEFAULT_MODULES = [geometry];\nconst SHADER_HOOKS_GLSL = [\n    'vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)',\n    'vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)',\n    'vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)',\n    'fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)'\n];\nconst SHADER_HOOKS_WGSL = [\n// Not yet supported\n];\nexport function getShaderAssembler(language) {\n    const shaderAssembler = ShaderAssembler.getDefaultShaderAssembler();\n    for (const shaderModule of DEFAULT_MODULES) {\n        shaderAssembler.addDefaultModule(shaderModule);\n    }\n    // if we're recreating the device we may have changed language\n    // and must not inject hooks for the wrong language\n    // shaderAssembler.resetShaderHooks();\n    shaderAssembler._hookFunctions.length = 0;\n    // Add shader hooks based on language\n    // TODO(ibgreen) - should the luma shader assembler support both sets of hooks?\n    const shaderHooks = language === 'glsl' ? SHADER_HOOKS_GLSL : SHADER_HOOKS_WGSL;\n    for (const shaderHook of shaderHooks) {\n        shaderAssembler.addShaderHook(shaderHook);\n    }\n    return shaderAssembler;\n}\nexport { layerUniforms, color, picking, project, project32, gouraudMaterial, phongMaterial, shadow };\n//# sourceMappingURL=index.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst DEFAULT_LIGHT_COLOR = [255, 255, 255];\nconst DEFAULT_LIGHT_INTENSITY = 1.0;\nlet idCount = 0;\nexport class AmbientLight {\n    constructor(props = {}) {\n        this.type = 'ambient';\n        const { color = DEFAULT_LIGHT_COLOR } = props;\n        const { intensity = DEFAULT_LIGHT_INTENSITY } = props;\n        this.id = props.id || `ambient-${idCount++}`;\n        this.color = color;\n        this.intensity = intensity;\n    }\n}\n//# sourceMappingURL=ambient-light.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Vector3 } from '@math.gl/core';\nconst DEFAULT_LIGHT_COLOR = [255, 255, 255];\nconst DEFAULT_LIGHT_INTENSITY = 1.0;\nconst DEFAULT_LIGHT_DIRECTION = [0.0, 0.0, -1.0];\nlet idCount = 0;\nexport class DirectionalLight {\n    constructor(props = {}) {\n        this.type = 'directional';\n        const { color = DEFAULT_LIGHT_COLOR } = props;\n        const { intensity = DEFAULT_LIGHT_INTENSITY } = props;\n        const { direction = DEFAULT_LIGHT_DIRECTION } = props;\n        const { _shadow = false } = props;\n        this.id = props.id || `directional-${idCount++}`;\n        this.color = color;\n        this.intensity = intensity;\n        this.type = 'directional';\n        this.direction = new Vector3(direction).normalize().toArray();\n        this.shadow = _shadow;\n    }\n    getProjectedLight(opts) {\n        return this;\n    }\n}\n//# sourceMappingURL=directional-light.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n * Base class for passes\n * @todo v9 - should the luma.gl RenderPass be owned by this class?\n * Currently owned by subclasses\n */\nexport default class Pass {\n    /** Create a new Pass instance */\n    constructor(device, props = { id: 'pass' }) {\n        const { id } = props;\n        this.id = id; // id of this pass\n        this.device = device;\n        this.props = { ...props };\n    }\n    setProps(props) {\n        Object.assign(this.props, props);\n    }\n    render(params) { } // eslint-disable-line @typescript-eslint/no-empty-function\n    cleanup() { } // eslint-disable-line @typescript-eslint/no-empty-function\n}\n//# sourceMappingURL=pass.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport Pass from \"./pass.js\";\n/** A Pass that renders all layers */\nexport default class LayersPass extends Pass {\n    constructor() {\n        super(...arguments);\n        this._lastRenderIndex = -1;\n    }\n    render(options) {\n        // @ts-expect-error TODO - assuming WebGL context\n        const [width, height] = this.device.canvasContext.getDrawingBufferSize();\n        // Explicitly specify clearColor and clearDepth, overriding render pass defaults.\n        const clearCanvas = options.clearCanvas ?? true;\n        const clearColor = options.clearColor ?? (clearCanvas ? [0, 0, 0, 0] : false);\n        const clearDepth = clearCanvas ? 1 : false;\n        const clearStencil = clearCanvas ? 0 : false;\n        const colorMask = options.colorMask ?? 0xf;\n        const parameters = { viewport: [0, 0, width, height] };\n        if (options.colorMask) {\n            parameters.colorMask = colorMask;\n        }\n        if (options.scissorRect) {\n            parameters.scissorRect = options.scissorRect;\n        }\n        const renderPass = this.device.beginRenderPass({\n            framebuffer: options.target,\n            parameters,\n            clearColor: clearColor,\n            clearDepth,\n            clearStencil\n        });\n        try {\n            return this._drawLayers(renderPass, options);\n        }\n        finally {\n            renderPass.end();\n            // TODO(ibgreen): WebGPU - submit may not be needed here but initial port had issues with out of render loop rendering\n            this.device.submit();\n        }\n    }\n    /** Draw a list of layers in a list of viewports */\n    _drawLayers(renderPass, options) {\n        const { target, shaderModuleProps, viewports, views, onViewportActive, clearStack = true } = options;\n        options.pass = options.pass || 'unknown';\n        if (clearStack) {\n            this._lastRenderIndex = -1;\n        }\n        const renderStats = [];\n        for (const viewport of viewports) {\n            const view = views && views[viewport.id];\n            // Update context to point to this viewport\n            onViewportActive?.(viewport);\n            const drawLayerParams = this._getDrawLayerParams(viewport, options);\n            // render this viewport\n            const subViewports = viewport.subViewports || [viewport];\n            for (const subViewport of subViewports) {\n                const stats = this._drawLayersInViewport(renderPass, {\n                    target,\n                    shaderModuleProps,\n                    viewport: subViewport,\n                    view,\n                    pass: options.pass,\n                    layers: options.layers\n                }, drawLayerParams);\n                renderStats.push(stats);\n            }\n        }\n        return renderStats;\n    }\n    // When a viewport contains multiple subviewports (e.g. repeated web mercator map),\n    // this is only done once for the parent viewport\n    /* Resolve the parameters needed to draw each layer */\n    _getDrawLayerParams(viewport, { layers, pass, isPicking = false, layerFilter, cullRect, effects, shaderModuleProps }, \n    /** Internal flag, true if only used to determine whether each layer should be drawn */\n    evaluateShouldDrawOnly = false) {\n        const drawLayerParams = [];\n        const indexResolver = layerIndexResolver(this._lastRenderIndex + 1);\n        const drawContext = {\n            layer: layers[0],\n            viewport,\n            isPicking,\n            renderPass: pass,\n            cullRect\n        };\n        const layerFilterCache = {};\n        for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n            const layer = layers[layerIndex];\n            // Check if we should draw layer\n            const shouldDrawLayer = this._shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache);\n            const layerParam = { shouldDrawLayer };\n            if (shouldDrawLayer && !evaluateShouldDrawOnly) {\n                layerParam.shouldDrawLayer = true;\n                // This is the \"logical\" index for ordering this layer in the stack\n                // used to calculate polygon offsets\n                // It can be the same as another layer\n                layerParam.layerRenderIndex = indexResolver(layer, shouldDrawLayer);\n                layerParam.shaderModuleProps = this._getShaderModuleProps(layer, effects, pass, shaderModuleProps);\n                layerParam.layerParameters = {\n                    ...layer.context.deck?.props.parameters,\n                    ...this.getLayerParameters(layer, layerIndex, viewport)\n                };\n            }\n            drawLayerParams[layerIndex] = layerParam;\n        }\n        return drawLayerParams;\n    }\n    // Draws a list of layers in one viewport\n    // TODO - when picking we could completely skip rendering viewports that dont\n    // intersect with the picking rect\n    /* eslint-disable max-depth, max-statements, complexity */\n    _drawLayersInViewport(renderPass, { layers, shaderModuleProps: globalModuleParameters, pass, target, viewport, view }, drawLayerParams) {\n        const glViewport = getGLViewport(this.device, {\n            shaderModuleProps: globalModuleParameters,\n            target,\n            viewport\n        });\n        if (view) {\n            const { clear, clearColor, clearDepth, clearStencil } = view.props;\n            if (clear) {\n                // If clear option is set, clear all buffers by default.\n                let colorToUse = [0, 0, 0, 0];\n                let depthToUse = 1.0;\n                let stencilToUse = 0;\n                if (Array.isArray(clearColor)) {\n                    colorToUse = [...clearColor.slice(0, 3), clearColor[3] || 255].map(c => c / 255);\n                }\n                else if (clearColor === false) {\n                    colorToUse = false;\n                }\n                if (clearDepth !== undefined) {\n                    depthToUse = clearDepth;\n                }\n                if (clearStencil !== undefined) {\n                    stencilToUse = clearStencil;\n                }\n                const clearRenderPass = this.device.beginRenderPass({\n                    framebuffer: target,\n                    parameters: {\n                        viewport: glViewport,\n                        scissorRect: glViewport\n                    },\n                    clearColor: colorToUse,\n                    clearDepth: depthToUse,\n                    clearStencil: stencilToUse\n                });\n                clearRenderPass.end();\n            }\n        }\n        // render layers in normal colors\n        const renderStatus = {\n            totalCount: layers.length,\n            visibleCount: 0,\n            compositeCount: 0,\n            pickableCount: 0\n        };\n        renderPass.setParameters({ viewport: glViewport });\n        // render layers in normal colors\n        for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n            const layer = layers[layerIndex];\n            const drawLayerParameters = drawLayerParams[layerIndex];\n            const { shouldDrawLayer } = drawLayerParameters;\n            // Calculate stats\n            if (shouldDrawLayer && layer.props.pickable) {\n                renderStatus.pickableCount++;\n            }\n            if (layer.isComposite) {\n                renderStatus.compositeCount++;\n            }\n            if (layer.isDrawable && drawLayerParameters.shouldDrawLayer) {\n                const { layerRenderIndex, shaderModuleProps, layerParameters } = drawLayerParameters;\n                // Draw the layer\n                renderStatus.visibleCount++;\n                this._lastRenderIndex = Math.max(this._lastRenderIndex, layerRenderIndex);\n                // overwrite layer.context.viewport with the sub viewport\n                if (shaderModuleProps.project) {\n                    shaderModuleProps.project.viewport = viewport;\n                }\n                // TODO v9 - we are sending renderPass both as a parameter and through the context.\n                // Long-term, it is likely better not to have user defined layer methods have to access\n                // the \"global\" layer context.\n                layer.context.renderPass = renderPass;\n                try {\n                    layer._drawLayer({\n                        renderPass,\n                        shaderModuleProps,\n                        uniforms: { layerIndex: layerRenderIndex },\n                        parameters: layerParameters\n                    });\n                }\n                catch (err) {\n                    layer.raiseError(err, `drawing ${layer} to ${pass}`);\n                }\n            }\n        }\n        return renderStatus;\n    }\n    /* eslint-enable max-depth, max-statements */\n    /* Methods for subclass overrides */\n    shouldDrawLayer(layer) {\n        return true;\n    }\n    getShaderModuleProps(layer, effects, otherShaderModuleProps) {\n        return null;\n    }\n    getLayerParameters(layer, layerIndex, viewport) {\n        return layer.props.parameters;\n    }\n    /* Private */\n    _shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache) {\n        const shouldDrawLayer = layer.props.visible && this.shouldDrawLayer(layer);\n        if (!shouldDrawLayer) {\n            return false;\n        }\n        drawContext.layer = layer;\n        let parent = layer.parent;\n        while (parent) {\n            // @ts-ignore\n            if (!parent.props.visible || !parent.filterSubLayer(drawContext)) {\n                return false;\n            }\n            drawContext.layer = parent;\n            parent = parent.parent;\n        }\n        if (layerFilter) {\n            const rootLayerId = drawContext.layer.id;\n            if (!(rootLayerId in layerFilterCache)) {\n                layerFilterCache[rootLayerId] = layerFilter(drawContext);\n            }\n            if (!layerFilterCache[rootLayerId]) {\n                return false;\n            }\n        }\n        // If a layer is drawn, update its viewportChanged flag\n        layer.activateViewport(drawContext.viewport);\n        return true;\n    }\n    _getShaderModuleProps(layer, effects, pass, overrides) {\n        // @ts-expect-error TODO - assuming WebGL context\n        const devicePixelRatio = this.device.canvasContext.cssToDeviceRatio();\n        const layerProps = layer.internalState?.propsInTransition || layer.props;\n        const shaderModuleProps = {\n            layer: layerProps,\n            picking: {\n                isActive: false\n            },\n            project: {\n                viewport: layer.context.viewport,\n                devicePixelRatio,\n                modelMatrix: layerProps.modelMatrix,\n                coordinateSystem: layerProps.coordinateSystem,\n                coordinateOrigin: layerProps.coordinateOrigin,\n                autoWrapLongitude: layer.wrapLongitude\n            }\n        };\n        if (effects) {\n            for (const effect of effects) {\n                mergeModuleParameters(shaderModuleProps, effect.getShaderModuleProps?.(layer, shaderModuleProps));\n            }\n        }\n        return mergeModuleParameters(shaderModuleProps, this.getShaderModuleProps(layer, effects, shaderModuleProps), overrides);\n    }\n}\n// If the _index prop is defined, return a layer index that's relative to its parent\n// Otherwise return the index of the layer among all rendered layers\n// This is done recursively, i.e. if the user overrides a layer's default index,\n// all its descendants will be resolved relative to that index.\n// This implementation assumes that parent layers always appear before its children\n// which is true if the layer array comes from the LayerManager\nexport function layerIndexResolver(startIndex = 0, layerIndices = {}) {\n    const resolvers = {};\n    const resolveLayerIndex = (layer, isDrawn) => {\n        const indexOverride = layer.props._offset;\n        const layerId = layer.id;\n        const parentId = layer.parent && layer.parent.id;\n        let index;\n        if (parentId && !(parentId in layerIndices)) {\n            // Populate layerIndices with the parent layer's index\n            resolveLayerIndex(layer.parent, false);\n        }\n        if (parentId in resolvers) {\n            const resolver = (resolvers[parentId] =\n                resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices));\n            index = resolver(layer, isDrawn);\n            resolvers[layerId] = resolver;\n        }\n        else if (Number.isFinite(indexOverride)) {\n            index = indexOverride + (layerIndices[parentId] || 0);\n            // Mark layer as needing its own resolver\n            // We don't actually create it until it's used for the first time\n            resolvers[layerId] = null;\n        }\n        else {\n            index = startIndex;\n        }\n        if (isDrawn && index >= startIndex) {\n            startIndex = index + 1;\n        }\n        layerIndices[layerId] = index;\n        return index;\n    };\n    return resolveLayerIndex;\n}\n// Convert viewport top-left CSS coordinates to bottom up WebGL coordinates\nfunction getGLViewport(device, { shaderModuleProps, target, viewport }) {\n    const pixelRatio = shaderModuleProps?.project?.devicePixelRatio ??\n        // @ts-expect-error TODO - assuming WebGL context\n        device.canvasContext.cssToDeviceRatio();\n    // Default framebuffer is used when writing to canvas\n    // @ts-expect-error TODO - assuming WebGL context\n    const [, drawingBufferHeight] = device.canvasContext.getDrawingBufferSize();\n    const height = target ? target.height : drawingBufferHeight;\n    // Convert viewport top-left CSS coordinates to bottom up WebGL coordinates\n    const dimensions = viewport;\n    return [\n        dimensions.x * pixelRatio,\n        height - (dimensions.y + dimensions.height) * pixelRatio,\n        dimensions.width * pixelRatio,\n        dimensions.height * pixelRatio\n    ];\n}\nfunction mergeModuleParameters(target, ...sources) {\n    for (const source of sources) {\n        if (source) {\n            for (const key in source) {\n                if (target[key]) {\n                    Object.assign(target[key], source[key]);\n                }\n                else {\n                    target[key] = source[key];\n                }\n            }\n        }\n    }\n    return target;\n}\n//# sourceMappingURL=layers-pass.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport LayersPass from \"./layers-pass.js\";\nexport default class ShadowPass extends LayersPass {\n    constructor(device, props) {\n        super(device, props);\n        // The shadowMap texture\n        const shadowMap = device.createTexture({\n            format: 'rgba8unorm',\n            width: 1,\n            height: 1,\n            sampler: {\n                minFilter: 'linear',\n                magFilter: 'linear',\n                addressModeU: 'clamp-to-edge',\n                addressModeV: 'clamp-to-edge'\n            }\n            // TODO - texture API change in luma.gl v9.2\n            // mipmaps: true\n        });\n        const depthBuffer = device.createTexture({ format: 'depth16unorm', width: 1, height: 1 });\n        this.fbo = device.createFramebuffer({\n            id: 'shadowmap',\n            width: 1,\n            height: 1,\n            colorAttachments: [shadowMap],\n            // Depth attachment has to be specified for depth test to work\n            depthStencilAttachment: depthBuffer\n        });\n    }\n    delete() {\n        if (this.fbo) {\n            this.fbo.destroy();\n            this.fbo = null;\n        }\n    }\n    getShadowMap() {\n        return this.fbo.colorAttachments[0].texture;\n    }\n    render(params) {\n        const target = this.fbo;\n        // @ts-expect-error TODO - assuming WebGL context\n        const pixelRatio = this.device.canvasContext.cssToDeviceRatio();\n        const viewport = params.viewports[0];\n        const width = viewport.width * pixelRatio;\n        const height = viewport.height * pixelRatio;\n        const clearColor = [1, 1, 1, 1];\n        if (width !== target.width || height !== target.height) {\n            target.resize({ width, height });\n        }\n        super.render({ ...params, clearColor, target, pass: 'shadow' });\n    }\n    getLayerParameters(layer, layerIndex, viewport) {\n        return {\n            ...layer.props.parameters,\n            blend: false,\n            depthWriteEnabled: true,\n            depthCompare: 'less-equal'\n        };\n    }\n    shouldDrawLayer(layer) {\n        return layer.props.shadowEnabled !== false;\n    }\n    getShaderModuleProps(layer, effects, otherShaderModuleProps) {\n        return {\n            shadow: {\n                project: otherShaderModuleProps.project,\n                drawToShadowMap: true\n            }\n        };\n    }\n}\n//# sourceMappingURL=shadow-pass.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { AmbientLight } from \"./ambient-light.js\";\nimport { DirectionalLight } from \"./directional-light.js\";\nimport { Matrix4, Vector3 } from '@math.gl/core';\nimport ShadowPass from \"../../passes/shadow-pass.js\";\nimport shadow from \"../../shaderlib/shadow/shadow.js\";\nconst DEFAULT_AMBIENT_LIGHT_PROPS = {\n    color: [255, 255, 255],\n    intensity: 1.0\n};\nconst DEFAULT_DIRECTIONAL_LIGHT_PROPS = [\n    {\n        color: [255, 255, 255],\n        intensity: 1.0,\n        direction: [-1, 3, -1]\n    },\n    {\n        color: [255, 255, 255],\n        intensity: 0.9,\n        direction: [1, -8, -2.5]\n    }\n];\nconst DEFAULT_SHADOW_COLOR = [0, 0, 0, 200 / 255];\n// Class to manage ambient, point and directional light sources in deck\nexport default class LightingEffect {\n    constructor(props = {}) {\n        this.id = 'lighting-effect';\n        this.shadowColor = DEFAULT_SHADOW_COLOR;\n        this.shadow = false;\n        this.directionalLights = [];\n        this.pointLights = [];\n        this.shadowPasses = [];\n        this.dummyShadowMap = null;\n        this.setProps(props);\n    }\n    setup(context) {\n        this.context = context;\n        const { device, deck } = context;\n        if (this.shadow && !this.dummyShadowMap) {\n            this._createShadowPasses(device);\n            deck._addDefaultShaderModule(shadow);\n            this.dummyShadowMap = device.createTexture({\n                width: 1,\n                height: 1\n            });\n        }\n    }\n    setProps(props) {\n        this.ambientLight = undefined;\n        this.directionalLights = [];\n        this.pointLights = [];\n        for (const key in props) {\n            const lightSource = props[key];\n            switch (lightSource.type) {\n                case 'ambient':\n                    this.ambientLight = lightSource;\n                    break;\n                case 'directional':\n                    this.directionalLights.push(lightSource);\n                    break;\n                case 'point':\n                    this.pointLights.push(lightSource);\n                    break;\n                default:\n            }\n        }\n        this._applyDefaultLights();\n        this.shadow = this.directionalLights.some(light => light.shadow);\n        if (this.context) {\n            // Create resources if necessary\n            this.setup(this.context);\n        }\n        this.props = props;\n    }\n    preRender({ layers, layerFilter, viewports, onViewportActive, views }) {\n        if (!this.shadow)\n            return;\n        // create light matrix every frame to make sure always updated from light source\n        this.shadowMatrices = this._calculateMatrices();\n        for (let i = 0; i < this.shadowPasses.length; i++) {\n            const shadowPass = this.shadowPasses[i];\n            shadowPass.render({\n                layers,\n                layerFilter,\n                viewports,\n                onViewportActive,\n                views,\n                shaderModuleProps: {\n                    shadow: {\n                        shadowLightId: i,\n                        dummyShadowMap: this.dummyShadowMap,\n                        shadowMatrices: this.shadowMatrices\n                    }\n                }\n            });\n        }\n    }\n    getShaderModuleProps(layer, otherShaderModuleProps) {\n        const shadowProps = this.shadow\n            ? {\n                project: otherShaderModuleProps.project,\n                shadowMaps: this.shadowPasses.map(shadowPass => shadowPass.getShadowMap()),\n                dummyShadowMap: this.dummyShadowMap,\n                shadowColor: this.shadowColor,\n                shadowMatrices: this.shadowMatrices\n            }\n            : {};\n        // when not rendering to screen, turn off lighting by adding empty light source object\n        // lights shader module relies on the `lightSources` to turn on/off lighting\n        const lightingProps = {\n            enabled: true,\n            ambientLight: this.ambientLight,\n            directionalLights: this.directionalLights.map(directionalLight => directionalLight.getProjectedLight({ layer })),\n            pointLights: this.pointLights.map(pointLight => pointLight.getProjectedLight({ layer }))\n        };\n        // @ts-expect-error material is not a Layer prop\n        const materialProps = layer.props.material;\n        return {\n            shadow: shadowProps,\n            lighting: lightingProps,\n            phongMaterial: materialProps,\n            gouraudMaterial: materialProps\n        };\n    }\n    cleanup(context) {\n        for (const shadowPass of this.shadowPasses) {\n            shadowPass.delete();\n        }\n        this.shadowPasses.length = 0;\n        if (this.dummyShadowMap) {\n            this.dummyShadowMap.destroy();\n            this.dummyShadowMap = null;\n            context.deck._removeDefaultShaderModule(shadow);\n        }\n    }\n    _calculateMatrices() {\n        const lightMatrices = [];\n        for (const light of this.directionalLights) {\n            const viewMatrix = new Matrix4().lookAt({\n                eye: new Vector3(light.direction).negate()\n            });\n            lightMatrices.push(viewMatrix);\n        }\n        return lightMatrices;\n    }\n    _createShadowPasses(device) {\n        for (let i = 0; i < this.directionalLights.length; i++) {\n            const shadowPass = new ShadowPass(device);\n            this.shadowPasses[i] = shadowPass;\n        }\n    }\n    _applyDefaultLights() {\n        const { ambientLight, pointLights, directionalLights } = this;\n        if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {\n            this.ambientLight = new AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);\n            this.directionalLights.push(new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]), new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1]));\n        }\n    }\n}\n//# sourceMappingURL=lighting-effect.js.map","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nlet channelHandles = 1;\nlet animationHandles = 1;\nexport class Timeline {\n    time = 0;\n    channels = new Map();\n    animations = new Map();\n    playing = false;\n    lastEngineTime = -1;\n    constructor() { }\n    addChannel(props) {\n        const { delay = 0, duration = Number.POSITIVE_INFINITY, rate = 1, repeat = 1 } = props;\n        const channelId = channelHandles++;\n        const channel = {\n            time: 0,\n            delay,\n            duration,\n            rate,\n            repeat\n        };\n        this._setChannelTime(channel, this.time);\n        this.channels.set(channelId, channel);\n        return channelId;\n    }\n    removeChannel(channelId) {\n        this.channels.delete(channelId);\n        for (const [animationHandle, animation] of this.animations) {\n            if (animation.channel === channelId) {\n                this.detachAnimation(animationHandle);\n            }\n        }\n    }\n    isFinished(channelId) {\n        const channel = this.channels.get(channelId);\n        if (channel === undefined) {\n            return false;\n        }\n        return this.time >= channel.delay + channel.duration * channel.repeat;\n    }\n    getTime(channelId) {\n        if (channelId === undefined) {\n            return this.time;\n        }\n        const channel = this.channels.get(channelId);\n        if (channel === undefined) {\n            return -1;\n        }\n        return channel.time;\n    }\n    setTime(time) {\n        this.time = Math.max(0, time);\n        const channels = this.channels.values();\n        for (const channel of channels) {\n            this._setChannelTime(channel, this.time);\n        }\n        const animations = this.animations.values();\n        for (const animationData of animations) {\n            const { animation, channel } = animationData;\n            animation.setTime(this.getTime(channel));\n        }\n    }\n    play() {\n        this.playing = true;\n    }\n    pause() {\n        this.playing = false;\n        this.lastEngineTime = -1;\n    }\n    reset() {\n        this.setTime(0);\n    }\n    attachAnimation(animation, channelHandle) {\n        const animationHandle = animationHandles++;\n        this.animations.set(animationHandle, {\n            animation,\n            channel: channelHandle\n        });\n        animation.setTime(this.getTime(channelHandle));\n        return animationHandle;\n    }\n    detachAnimation(channelId) {\n        this.animations.delete(channelId);\n    }\n    update(engineTime) {\n        if (this.playing) {\n            if (this.lastEngineTime === -1) {\n                this.lastEngineTime = engineTime;\n            }\n            this.setTime(this.time + (engineTime - this.lastEngineTime));\n            this.lastEngineTime = engineTime;\n        }\n    }\n    _setChannelTime(channel, time) {\n        const offsetTime = time - channel.delay;\n        const totalDuration = channel.duration * channel.repeat;\n        // Note(Tarek): Don't loop on final repeat.\n        if (offsetTime >= totalDuration) {\n            channel.time = channel.duration * channel.rate;\n        }\n        else {\n            channel.time = Math.max(0, offsetTime) % channel.duration;\n            channel.time *= channel.rate;\n        }\n    }\n}\n//# sourceMappingURL=timeline.js.map","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/* global window, setTimeout, clearTimeout */\n/** Node.js polyfill for requestAnimationFrame */\n// / <reference types=\"@types/node\" />\nexport function requestAnimationFramePolyfill(callback) {\n    return typeof window !== 'undefined' && window.requestAnimationFrame\n        ? window.requestAnimationFrame(callback)\n        : setTimeout(callback, 1000 / 60);\n}\n/** Node.js polyfill for cancelAnimationFrame */\nexport function cancelAnimationFramePolyfill(timerId) {\n    return typeof window !== 'undefined' && window.cancelAnimationFrame\n        ? window.cancelAnimationFrame(timerId)\n        : clearTimeout(timerId);\n}\n//# sourceMappingURL=request-animation-frame.js.map","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { luma } from '@luma.gl/core';\nimport { requestAnimationFramePolyfill, cancelAnimationFramePolyfill } from \"./request-animation-frame.js\";\nimport { Stats } from '@probe.gl/stats';\nlet statIdCounter = 0;\n/** Convenient animation loop */\nexport class AnimationLoop {\n    static defaultAnimationLoopProps = {\n        device: null,\n        onAddHTML: () => '',\n        onInitialize: async () => null,\n        onRender: () => { },\n        onFinalize: () => { },\n        onError: error => console.error(error), // eslint-disable-line no-console\n        stats: luma.stats.get(`animation-loop-${statIdCounter++}`),\n        // view parameters\n        autoResizeViewport: false\n    };\n    device = null;\n    canvas = null;\n    props;\n    animationProps = null;\n    timeline = null;\n    stats;\n    cpuTime;\n    gpuTime;\n    frameRate;\n    display;\n    needsRedraw = 'initialized';\n    _initialized = false;\n    _running = false;\n    _animationFrameId = null;\n    _nextFramePromise = null;\n    _resolveNextFrame = null;\n    _cpuStartTime = 0;\n    _error = null;\n    // _gpuTimeQuery: Query | null = null;\n    /*\n     * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context\n     */\n    constructor(props) {\n        this.props = { ...AnimationLoop.defaultAnimationLoopProps, ...props };\n        props = this.props;\n        if (!props.device) {\n            throw new Error('No device provided');\n        }\n        // state\n        this.stats = props.stats || new Stats({ id: 'animation-loop-stats' });\n        this.cpuTime = this.stats.get('CPU Time');\n        this.gpuTime = this.stats.get('GPU Time');\n        this.frameRate = this.stats.get('Frame Rate');\n        this.setProps({ autoResizeViewport: props.autoResizeViewport });\n        // Bind methods\n        this.start = this.start.bind(this);\n        this.stop = this.stop.bind(this);\n        this._onMousemove = this._onMousemove.bind(this);\n        this._onMouseleave = this._onMouseleave.bind(this);\n    }\n    destroy() {\n        this.stop();\n        this._setDisplay(null);\n    }\n    /** @deprecated Use .destroy() */\n    delete() {\n        this.destroy();\n    }\n    reportError(error) {\n        this.props.onError(error);\n        this._error = error;\n    }\n    /** Flags this animation loop as needing redraw */\n    setNeedsRedraw(reason) {\n        this.needsRedraw = this.needsRedraw || reason;\n        return this;\n    }\n    setProps(props) {\n        if ('autoResizeViewport' in props) {\n            this.props.autoResizeViewport = props.autoResizeViewport || false;\n        }\n        return this;\n    }\n    /** Starts a render loop if not already running */\n    async start() {\n        if (this._running) {\n            return this;\n        }\n        this._running = true;\n        try {\n            let appContext;\n            if (!this._initialized) {\n                this._initialized = true;\n                // Create the WebGL context\n                await this._initDevice();\n                this._initialize();\n                // Note: onIntialize can return a promise (e.g. in case app needs to load resources)\n                await this.props.onInitialize(this._getAnimationProps());\n            }\n            // check that we haven't been stopped\n            if (!this._running) {\n                return null;\n            }\n            // Start the loop\n            if (appContext !== false) {\n                // cancel any pending renders to ensure only one loop can ever run\n                this._cancelAnimationFrame();\n                this._requestAnimationFrame();\n            }\n            return this;\n        }\n        catch (err) {\n            const error = err instanceof Error ? err : new Error('Unknown error');\n            this.props.onError(error);\n            // this._running = false; // TODO\n            throw error;\n        }\n    }\n    /** Stops a render loop if already running, finalizing */\n    stop() {\n        // console.debug(`Stopping ${this.constructor.name}`);\n        if (this._running) {\n            // call callback\n            // If stop is called immediately, we can end up in a state where props haven't been initialized...\n            if (this.animationProps && !this._error) {\n                this.props.onFinalize(this.animationProps);\n            }\n            this._cancelAnimationFrame();\n            this._nextFramePromise = null;\n            this._resolveNextFrame = null;\n            this._running = false;\n        }\n        return this;\n    }\n    /** Explicitly draw a frame */\n    redraw() {\n        if (this.device?.isLost || this._error) {\n            return this;\n        }\n        this._beginFrameTimers();\n        this._setupFrame();\n        this._updateAnimationProps();\n        this._renderFrame(this._getAnimationProps());\n        // clear needsRedraw flag\n        this._clearNeedsRedraw();\n        if (this._resolveNextFrame) {\n            this._resolveNextFrame(this);\n            this._nextFramePromise = null;\n            this._resolveNextFrame = null;\n        }\n        this._endFrameTimers();\n        return this;\n    }\n    /** Add a timeline, it will be automatically updated by the animation loop. */\n    attachTimeline(timeline) {\n        this.timeline = timeline;\n        return this.timeline;\n    }\n    /** Remove a timeline */\n    detachTimeline() {\n        this.timeline = null;\n    }\n    /** Wait until a render completes */\n    waitForRender() {\n        this.setNeedsRedraw('waitForRender');\n        if (!this._nextFramePromise) {\n            this._nextFramePromise = new Promise(resolve => {\n                this._resolveNextFrame = resolve;\n            });\n        }\n        return this._nextFramePromise;\n    }\n    /** TODO - should use device.deviceContext */\n    async toDataURL() {\n        this.setNeedsRedraw('toDataURL');\n        await this.waitForRender();\n        if (this.canvas instanceof HTMLCanvasElement) {\n            return this.canvas.toDataURL();\n        }\n        throw new Error('OffscreenCanvas');\n    }\n    // PRIVATE METHODS\n    _initialize() {\n        this._startEventHandling();\n        // Initialize the callback data\n        this._initializeAnimationProps();\n        this._updateAnimationProps();\n        // Default viewport setup, in case onInitialize wants to render\n        this._resizeViewport();\n        // this._gpuTimeQuery = Query.isSupported(this.gl, ['timers']) ? new Query(this.gl) : null;\n    }\n    _setDisplay(display) {\n        if (this.display) {\n            this.display.destroy();\n            this.display.animationLoop = null;\n        }\n        // store animation loop on the display\n        if (display) {\n            display.animationLoop = this;\n        }\n        this.display = display;\n    }\n    _requestAnimationFrame() {\n        if (!this._running) {\n            return;\n        }\n        // VR display has a separate animation frame to sync with headset\n        // TODO WebVR API discontinued, replaced by WebXR: https://immersive-web.github.io/webxr/\n        // See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/requestAnimationFrame\n        // if (this.display && this.display.requestAnimationFrame) {\n        //   this._animationFrameId = this.display.requestAnimationFrame(this._animationFrame.bind(this));\n        // }\n        this._animationFrameId = requestAnimationFramePolyfill(this._animationFrame.bind(this));\n    }\n    _cancelAnimationFrame() {\n        if (this._animationFrameId === null) {\n            return;\n        }\n        // VR display has a separate animation frame to sync with headset\n        // TODO WebVR API discontinued, replaced by WebXR: https://immersive-web.github.io/webxr/\n        // See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/requestAnimationFrame\n        // if (this.display && this.display.cancelAnimationFramePolyfill) {\n        //   this.display.cancelAnimationFrame(this._animationFrameId);\n        // }\n        cancelAnimationFramePolyfill(this._animationFrameId);\n        this._animationFrameId = null;\n    }\n    _animationFrame() {\n        if (!this._running) {\n            return;\n        }\n        this.redraw();\n        this._requestAnimationFrame();\n    }\n    // Called on each frame, can be overridden to call onRender multiple times\n    // to support e.g. stereoscopic rendering\n    _renderFrame(animationProps) {\n        // Allow e.g. VR display to render multiple frames.\n        if (this.display) {\n            this.display._renderFrame(animationProps);\n            return;\n        }\n        // call callback\n        this.props.onRender(this._getAnimationProps());\n        // end callback\n        // Submit commands (necessary on WebGPU)\n        this.device?.submit();\n    }\n    _clearNeedsRedraw() {\n        this.needsRedraw = false;\n    }\n    _setupFrame() {\n        this._resizeViewport();\n    }\n    // Initialize the  object that will be passed to app callbacks\n    _initializeAnimationProps() {\n        const canvasContext = this.device?.getDefaultCanvasContext();\n        if (!this.device || !canvasContext) {\n            throw new Error('loop');\n        }\n        const canvas = canvasContext?.canvas;\n        const useDevicePixels = canvasContext.props.useDevicePixels;\n        this.animationProps = {\n            animationLoop: this,\n            device: this.device,\n            canvasContext,\n            canvas,\n            // @ts-expect-error Deprecated\n            useDevicePixels,\n            timeline: this.timeline,\n            needsRedraw: false,\n            // Placeholders\n            width: 1,\n            height: 1,\n            aspect: 1,\n            // Animation props\n            time: 0,\n            startTime: Date.now(),\n            engineTime: 0,\n            tick: 0,\n            tock: 0,\n            // Experimental\n            _mousePosition: null // Event props\n        };\n    }\n    _getAnimationProps() {\n        if (!this.animationProps) {\n            throw new Error('animationProps');\n        }\n        return this.animationProps;\n    }\n    // Update the context object that will be passed to app callbacks\n    _updateAnimationProps() {\n        if (!this.animationProps) {\n            return;\n        }\n        // Can this be replaced with canvas context?\n        const { width, height, aspect } = this._getSizeAndAspect();\n        if (width !== this.animationProps.width || height !== this.animationProps.height) {\n            this.setNeedsRedraw('drawing buffer resized');\n        }\n        if (aspect !== this.animationProps.aspect) {\n            this.setNeedsRedraw('drawing buffer aspect changed');\n        }\n        this.animationProps.width = width;\n        this.animationProps.height = height;\n        this.animationProps.aspect = aspect;\n        this.animationProps.needsRedraw = this.needsRedraw;\n        // Update time properties\n        this.animationProps.engineTime = Date.now() - this.animationProps.startTime;\n        if (this.timeline) {\n            this.timeline.update(this.animationProps.engineTime);\n        }\n        this.animationProps.tick = Math.floor((this.animationProps.time / 1000) * 60);\n        this.animationProps.tock++;\n        // For back compatibility\n        this.animationProps.time = this.timeline\n            ? this.timeline.getTime()\n            : this.animationProps.engineTime;\n    }\n    /** Wait for supplied device */\n    async _initDevice() {\n        this.device = await this.props.device;\n        if (!this.device) {\n            throw new Error('No device provided');\n        }\n        this.canvas = this.device.getDefaultCanvasContext().canvas || null;\n        // this._createInfoDiv();\n    }\n    _createInfoDiv() {\n        if (this.canvas && this.props.onAddHTML) {\n            const wrapperDiv = document.createElement('div');\n            document.body.appendChild(wrapperDiv);\n            wrapperDiv.style.position = 'relative';\n            const div = document.createElement('div');\n            div.style.position = 'absolute';\n            div.style.left = '10px';\n            div.style.bottom = '10px';\n            div.style.width = '300px';\n            div.style.background = 'white';\n            if (this.canvas instanceof HTMLCanvasElement) {\n                wrapperDiv.appendChild(this.canvas);\n            }\n            wrapperDiv.appendChild(div);\n            const html = this.props.onAddHTML(div);\n            if (html) {\n                div.innerHTML = html;\n            }\n        }\n    }\n    _getSizeAndAspect() {\n        if (!this.device) {\n            return { width: 1, height: 1, aspect: 1 };\n        }\n        // https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html\n        const [width, height] = this.device?.getDefaultCanvasContext().getDevicePixelSize() || [1, 1];\n        // https://webglfundamentals.org/webgl/lessons/webgl-anti-patterns.html\n        let aspect = 1;\n        const canvas = this.device?.getDefaultCanvasContext().canvas;\n        // @ts-expect-error\n        if (canvas && canvas.clientHeight) {\n            // @ts-expect-error\n            aspect = canvas.clientWidth / canvas.clientHeight;\n        }\n        else if (width > 0 && height > 0) {\n            aspect = width / height;\n        }\n        return { width, height, aspect };\n    }\n    /** @deprecated Default viewport setup */\n    _resizeViewport() {\n        // TODO can we use canvas context to code this in a portable way?\n        // @ts-expect-error Expose on canvasContext\n        if (this.props.autoResizeViewport && this.device.gl) {\n            // @ts-expect-error Expose canvasContext\n            this.device.gl.viewport(0, 0, \n            // @ts-expect-error Expose canvasContext\n            this.device.gl.drawingBufferWidth, \n            // @ts-expect-error Expose canvasContext\n            this.device.gl.drawingBufferHeight);\n        }\n    }\n    _beginFrameTimers() {\n        this.frameRate.timeEnd();\n        this.frameRate.timeStart();\n        // Check if timer for last frame has completed.\n        // GPU timer results are never available in the same\n        // frame they are captured.\n        // if (\n        //   this._gpuTimeQuery &&\n        //   this._gpuTimeQuery.isResultAvailable() &&\n        //   !this._gpuTimeQuery.isTimerDisjoint()\n        // ) {\n        //   this.stats.get('GPU Time').addTime(this._gpuTimeQuery.getTimerMilliseconds());\n        // }\n        // if (this._gpuTimeQuery) {\n        //   // GPU time query start\n        //   this._gpuTimeQuery.beginTimeElapsedQuery();\n        // }\n        this.cpuTime.timeStart();\n    }\n    _endFrameTimers() {\n        this.cpuTime.timeEnd();\n        // if (this._gpuTimeQuery) {\n        //   // GPU time query end. Results will be available on next frame.\n        //   this._gpuTimeQuery.end();\n        // }\n    }\n    // Event handling\n    _startEventHandling() {\n        if (this.canvas) {\n            this.canvas.addEventListener('mousemove', this._onMousemove.bind(this));\n            this.canvas.addEventListener('mouseleave', this._onMouseleave.bind(this));\n        }\n    }\n    _onMousemove(event) {\n        if (event instanceof MouseEvent) {\n            this._getAnimationProps()._mousePosition = [event.offsetX, event.offsetY];\n        }\n    }\n    _onMouseleave(event) {\n        this._getAnimationProps()._mousePosition = null;\n    }\n}\n//# sourceMappingURL=animation-loop.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport LayersPass from \"./layers-pass.js\";\nimport log from \"../utils/log.js\";\nconst PICKING_BLENDING = {\n    blendColorOperation: 'add',\n    blendColorSrcFactor: 'one',\n    blendColorDstFactor: 'zero',\n    blendAlphaOperation: 'add',\n    blendAlphaSrcFactor: 'constant',\n    blendAlphaDstFactor: 'zero'\n};\nexport default class PickLayersPass extends LayersPass {\n    constructor() {\n        super(...arguments);\n        this._colorEncoderState = null;\n    }\n    render(props) {\n        if ('pickingFBO' in props) {\n            // When drawing into an off-screen buffer, use the alpha channel to encode layer index\n            return this._drawPickingBuffer(props);\n        }\n        // When drawing to screen (debug mode), do not use the alpha channel so that result is always visible\n        return super.render(props);\n    }\n    // Private\n    // Draws list of layers and viewports into the picking buffer\n    // Note: does not sample the buffer, that has to be done by the caller\n    _drawPickingBuffer({ layers, layerFilter, views, viewports, onViewportActive, pickingFBO, deviceRect: { x, y, width, height }, cullRect, effects, pass = 'picking', pickZ, shaderModuleProps }) {\n        this.pickZ = pickZ;\n        const colorEncoderState = this._resetColorEncoder(pickZ);\n        const scissorRect = [x, y, width, height];\n        // Make sure we clear scissor test and fbo bindings in case of exceptions\n        // We are only interested in one pixel, no need to render anything else\n        // Note that the callback here is called synchronously.\n        // Set blend mode for picking\n        // always overwrite existing pixel with [r,g,b,layerIndex]\n        const renderStatus = super.render({\n            target: pickingFBO,\n            layers,\n            layerFilter,\n            views,\n            viewports,\n            onViewportActive,\n            cullRect,\n            effects: effects?.filter(e => e.useInPicking),\n            pass,\n            isPicking: true,\n            shaderModuleProps,\n            clearColor: [0, 0, 0, 0],\n            colorMask: 0xf,\n            scissorRect\n        });\n        // Clear the temp field\n        this._colorEncoderState = null;\n        const decodePickingColor = colorEncoderState && decodeColor.bind(null, colorEncoderState);\n        return { decodePickingColor, stats: renderStatus };\n    }\n    shouldDrawLayer(layer) {\n        const { pickable, operation } = layer.props;\n        return ((pickable && operation.includes('draw')) ||\n            operation.includes('terrain') ||\n            operation.includes('mask'));\n    }\n    getShaderModuleProps(layer, effects, otherShaderModuleProps) {\n        return {\n            picking: {\n                isActive: 1,\n                isAttribute: this.pickZ\n            },\n            lighting: { enabled: false }\n        };\n    }\n    getLayerParameters(layer, layerIndex, viewport) {\n        // TODO use Parameters type\n        const pickParameters = {\n            ...layer.props.parameters\n        };\n        const { pickable, operation } = layer.props;\n        if (!this._colorEncoderState || operation.includes('terrain')) {\n            pickParameters.blend = false;\n        }\n        else if (pickable && operation.includes('draw')) {\n            Object.assign(pickParameters, PICKING_BLENDING);\n            pickParameters.blend = true;\n            // TODO: blendColor no longer part of luma.gl API\n            pickParameters.blendColor = encodeColor(this._colorEncoderState, layer, viewport);\n        }\n        return pickParameters;\n    }\n    _resetColorEncoder(pickZ) {\n        // Track encoded layer indices\n        this._colorEncoderState = pickZ\n            ? null\n            : {\n                byLayer: new Map(),\n                byAlpha: []\n            };\n        // Temporarily store it on the instance so that it can be accessed by this.getLayerParameters\n        return this._colorEncoderState;\n    }\n}\n// Assign an unique alpha value for each pickable layer and track the encoding in the cache object\n// Returns normalized blend color\nfunction encodeColor(encoded, layer, viewport) {\n    const { byLayer, byAlpha } = encoded;\n    let a;\n    // Encode layerIndex in the alpha channel\n    // TODO - combine small layers to better utilize the picking color space\n    let entry = byLayer.get(layer);\n    if (entry) {\n        entry.viewports.push(viewport);\n        a = entry.a;\n    }\n    else {\n        a = byLayer.size + 1;\n        if (a <= 255) {\n            entry = { a, layer, viewports: [viewport] };\n            byLayer.set(layer, entry);\n            byAlpha[a] = entry;\n        }\n        else {\n            log.warn('Too many pickable layers, only picking the first 255')();\n            a = 0;\n        }\n    }\n    return [0, 0, 0, a / 255];\n}\n// Given a picked color, retrieve the corresponding layer and viewports from cache\nfunction decodeColor(encoded, pickedColor) {\n    const entry = encoded.byAlpha[pickedColor[3]];\n    return (entry && {\n        pickedLayer: entry.layer,\n        pickedViewports: entry.viewports,\n        pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)\n    });\n}\n//# sourceMappingURL=pick-layers-pass.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { load } from '@loaders.gl/core';\nexport default class Resource {\n    constructor(id, data, context) {\n        this._loadCount = 0;\n        this._subscribers = new Set();\n        this.id = id;\n        this.context = context;\n        this.setData(data);\n    }\n    // consumer: {onChange: Function}\n    subscribe(consumer) {\n        this._subscribers.add(consumer);\n    }\n    unsubscribe(consumer) {\n        this._subscribers.delete(consumer);\n    }\n    inUse() {\n        return this._subscribers.size > 0;\n    }\n    delete() {\n        // Remove any resources created\n    }\n    getData() {\n        return this.isLoaded\n            ? this._error\n                ? Promise.reject(this._error)\n                : this._content\n            : this._loader.then(() => this.getData());\n    }\n    setData(data, forceUpdate) {\n        if (data === this._data && !forceUpdate) {\n            return;\n        }\n        this._data = data;\n        const loadCount = ++this._loadCount;\n        let loader = data;\n        if (typeof data === 'string') {\n            loader = load(data);\n        }\n        if (loader instanceof Promise) {\n            this.isLoaded = false;\n            this._loader = loader\n                .then(result => {\n                // check if source has changed\n                if (this._loadCount === loadCount) {\n                    this.isLoaded = true;\n                    this._error = undefined;\n                    this._content = result;\n                }\n            })\n                .catch(error => {\n                if (this._loadCount === loadCount) {\n                    this.isLoaded = true;\n                    this._error = error || true;\n                }\n            });\n        }\n        else {\n            this.isLoaded = true;\n            this._error = undefined;\n            this._content = data;\n        }\n        for (const subscriber of this._subscribers) {\n            subscriber.onChange(this.getData());\n        }\n    }\n}\n//# sourceMappingURL=resource.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport Resource from \"./resource.js\";\nexport default class ResourceManager {\n    constructor(props) {\n        this.protocol = props.protocol || 'resource://';\n        this._context = {\n            device: props.device,\n            // @ts-expect-error\n            gl: props.device?.gl,\n            resourceManager: this\n        };\n        this._resources = {};\n        this._consumers = {};\n        this._pruneRequest = null;\n    }\n    contains(resourceId) {\n        if (resourceId.startsWith(this.protocol)) {\n            return true;\n        }\n        return resourceId in this._resources;\n    }\n    add({ resourceId, data, forceUpdate = false, persistent = true }) {\n        let res = this._resources[resourceId];\n        if (res) {\n            res.setData(data, forceUpdate);\n        }\n        else {\n            res = new Resource(resourceId, data, this._context);\n            this._resources[resourceId] = res;\n        }\n        // persistent resources can only be removed by calling `remove`\n        // non-persistent resources may be released when there are no more consumers\n        res.persistent = persistent;\n    }\n    remove(resourceId) {\n        const res = this._resources[resourceId];\n        if (res) {\n            res.delete();\n            delete this._resources[resourceId];\n        }\n    }\n    unsubscribe({ consumerId }) {\n        const consumer = this._consumers[consumerId];\n        if (consumer) {\n            for (const requestId in consumer) {\n                const request = consumer[requestId];\n                const resource = this._resources[request.resourceId];\n                if (resource) {\n                    resource.unsubscribe(request);\n                }\n            }\n            delete this._consumers[consumerId];\n            this.prune();\n        }\n    }\n    subscribe({ resourceId, onChange, consumerId, requestId = 'default' }) {\n        const { _resources: resources, protocol } = this;\n        if (resourceId.startsWith(protocol)) {\n            resourceId = resourceId.replace(protocol, '');\n            if (!resources[resourceId]) {\n                // Add placeholder. When this resource becomes available, the consumer will be notified.\n                this.add({ resourceId, data: null, persistent: false });\n            }\n        }\n        const res = resources[resourceId];\n        this._track(consumerId, requestId, res, onChange);\n        if (res) {\n            return res.getData();\n        }\n        return undefined;\n    }\n    prune() {\n        if (!this._pruneRequest) {\n            // prune() may be called multiple times in the same animation frame.\n            // Batch multiple requests together\n            // @ts-ignore setTimeout returns NodeJS.Timeout in node\n            this._pruneRequest = setTimeout(() => this._prune(), 0);\n        }\n    }\n    finalize() {\n        for (const key in this._resources) {\n            this._resources[key].delete();\n        }\n    }\n    _track(consumerId, requestId, resource, onChange) {\n        const consumers = this._consumers;\n        const consumer = (consumers[consumerId] = consumers[consumerId] || {});\n        let request = consumer[requestId];\n        const oldResource = request && request.resourceId && this._resources[request.resourceId];\n        if (oldResource) {\n            oldResource.unsubscribe(request);\n            this.prune();\n        }\n        if (resource) {\n            if (request) {\n                request.onChange = onChange;\n                request.resourceId = resource.id;\n            }\n            else {\n                request = {\n                    onChange,\n                    resourceId: resource.id\n                };\n            }\n            consumer[requestId] = request;\n            resource.subscribe(request);\n        }\n    }\n    _prune() {\n        this._pruneRequest = null;\n        for (const key of Object.keys(this._resources)) {\n            const res = this._resources[key];\n            if (!res.persistent && !res.inUse()) {\n                res.delete();\n                delete this._resources[key];\n            }\n        }\n    }\n}\n//# sourceMappingURL=resource-manager.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Timeline } from '@luma.gl/engine';\nimport { getShaderAssembler, layerUniforms } from \"../shaderlib/index.js\";\nimport { LIFECYCLE } from \"../lifecycle/constants.js\";\nimport log from \"../utils/log.js\";\nimport debug from \"../debug/index.js\";\nimport { flatten } from \"../utils/flatten.js\";\nimport { Stats } from '@probe.gl/stats';\nimport ResourceManager from \"./resource/resource-manager.js\";\nimport Viewport from \"../viewports/viewport.js\";\nconst TRACE_SET_LAYERS = 'layerManager.setLayers';\nconst TRACE_ACTIVATE_VIEWPORT = 'layerManager.activateViewport';\nexport default class LayerManager {\n    /**\n     * @param device\n     * @param param1\n     */\n    // eslint-disable-next-line\n    constructor(device, props) {\n        this._lastRenderedLayers = [];\n        this._needsRedraw = false;\n        this._needsUpdate = false;\n        this._nextLayers = null;\n        this._debug = false;\n        // This flag is separate from _needsUpdate because it can be set during an update and should trigger another full update\n        this._defaultShaderModulesChanged = false;\n        //\n        // INTERNAL METHODS\n        //\n        /** Make a viewport \"current\" in layer context, updating viewportChanged flags */\n        this.activateViewport = (viewport) => {\n            debug(TRACE_ACTIVATE_VIEWPORT, this, viewport);\n            if (viewport) {\n                this.context.viewport = viewport;\n            }\n        };\n        const { deck, stats, viewport, timeline } = props || {};\n        // Currently deck.gl expects the DeckGL.layers array to be different\n        // whenever React rerenders. If the same layers array is used, the\n        // LayerManager's diffing algorithm will generate a fatal error and\n        // break the rendering.\n        // `this._lastRenderedLayers` stores the UNFILTERED layers sent\n        // down to LayerManager, so that `layers` reference can be compared.\n        // If it's the same across two React render calls, the diffing logic\n        // will be skipped.\n        this.layers = [];\n        this.resourceManager = new ResourceManager({ device, protocol: 'deck://' });\n        this.context = {\n            mousePosition: null,\n            userData: {},\n            layerManager: this,\n            device,\n            // @ts-expect-error\n            gl: device?.gl,\n            deck,\n            shaderAssembler: getShaderAssembler(device?.info?.shadingLanguage || 'glsl'),\n            defaultShaderModules: [layerUniforms],\n            renderPass: undefined,\n            stats: stats || new Stats({ id: 'deck.gl' }),\n            // Make sure context.viewport is not empty on the first layer initialization\n            viewport: viewport || new Viewport({ id: 'DEFAULT-INITIAL-VIEWPORT' }), // Current viewport, exposed to layers for project* function\n            timeline: timeline || new Timeline(),\n            resourceManager: this.resourceManager,\n            onError: undefined\n        };\n        Object.seal(this);\n    }\n    /** Method to call when the layer manager is not needed anymore. */\n    finalize() {\n        this.resourceManager.finalize();\n        // Finalize all layers\n        for (const layer of this.layers) {\n            this._finalizeLayer(layer);\n        }\n    }\n    /** Check if a redraw is needed */\n    needsRedraw(opts = { clearRedrawFlags: false }) {\n        let redraw = this._needsRedraw;\n        if (opts.clearRedrawFlags) {\n            this._needsRedraw = false;\n        }\n        // This layers list doesn't include sublayers, relying on composite layers\n        for (const layer of this.layers) {\n            // Call every layer to clear their flags\n            const layerNeedsRedraw = layer.getNeedsRedraw(opts);\n            redraw = redraw || layerNeedsRedraw;\n        }\n        return redraw;\n    }\n    /** Check if a deep update of all layers is needed */\n    needsUpdate() {\n        if (this._nextLayers && this._nextLayers !== this._lastRenderedLayers) {\n            // New layers array may be the same as the old one if `setProps` is called by React\n            return 'layers changed';\n        }\n        if (this._defaultShaderModulesChanged) {\n            return 'shader modules changed';\n        }\n        return this._needsUpdate;\n    }\n    /** Layers will be redrawn (in next animation frame) */\n    setNeedsRedraw(reason) {\n        this._needsRedraw = this._needsRedraw || reason;\n    }\n    /** Layers will be updated deeply (in next animation frame)\n      Potentially regenerating attributes and sub layers */\n    setNeedsUpdate(reason) {\n        this._needsUpdate = this._needsUpdate || reason;\n    }\n    /** Gets a list of currently rendered layers. Optionally filter by id. */\n    getLayers({ layerIds } = {}) {\n        // Filtering by layerId compares beginning of strings, so that sublayers will be included\n        // Dependes on the convention of adding suffixes to the parent's layer name\n        return layerIds\n            ? this.layers.filter(layer => layerIds.find(layerId => layer.id.indexOf(layerId) === 0))\n            : this.layers;\n    }\n    /** Set props needed for layer rendering and picking. */\n    setProps(props) {\n        if ('debug' in props) {\n            this._debug = props.debug;\n        }\n        // A way for apps to add data to context that can be accessed in layers\n        if ('userData' in props) {\n            this.context.userData = props.userData;\n        }\n        // New layers will be processed in `updateLayers` in the next update cycle\n        if ('layers' in props) {\n            this._nextLayers = props.layers;\n        }\n        if ('onError' in props) {\n            this.context.onError = props.onError;\n        }\n    }\n    /** Supply a new layer list, initiating sublayer generation and layer matching */\n    setLayers(newLayers, reason) {\n        debug(TRACE_SET_LAYERS, this, reason, newLayers);\n        this._lastRenderedLayers = newLayers;\n        const flatLayers = flatten(newLayers, Boolean);\n        for (const layer of flatLayers) {\n            layer.context = this.context;\n        }\n        this._updateLayers(this.layers, flatLayers);\n    }\n    /** Update layers from last cycle if `setNeedsUpdate()` has been called */\n    updateLayers() {\n        // NOTE: For now, even if only some layer has changed, we update all layers\n        // to ensure that layer id maps etc remain consistent even if different\n        // sublayers are rendered\n        const reason = this.needsUpdate();\n        if (reason) {\n            this.setNeedsRedraw(`updating layers: ${reason}`);\n            // Force a full update\n            this.setLayers(this._nextLayers || this._lastRenderedLayers, reason);\n        }\n        // Updated, clear the backlog\n        this._nextLayers = null;\n    }\n    /** Register a default shader module */\n    addDefaultShaderModule(module) {\n        const { defaultShaderModules } = this.context;\n        if (!defaultShaderModules.find(m => m.name === module.name)) {\n            defaultShaderModules.push(module);\n            this._defaultShaderModulesChanged = true;\n        }\n    }\n    /** Deregister a default shader module */\n    removeDefaultShaderModule(module) {\n        const { defaultShaderModules } = this.context;\n        const i = defaultShaderModules.findIndex(m => m.name === module.name);\n        if (i >= 0) {\n            defaultShaderModules.splice(i, 1);\n            this._defaultShaderModulesChanged = true;\n        }\n    }\n    _handleError(stage, error, layer) {\n        layer.raiseError(error, `${stage} of ${layer}`);\n    }\n    // TODO - mark layers with exceptions as bad and remove from rendering cycle?\n    /** Match all layers, checking for caught errors\n      to avoid having an exception in one layer disrupt other layers */\n    _updateLayers(oldLayers, newLayers) {\n        // Create old layer map\n        const oldLayerMap = {};\n        for (const oldLayer of oldLayers) {\n            if (oldLayerMap[oldLayer.id]) {\n                log.warn(`Multiple old layers with same id ${oldLayer.id}`)();\n            }\n            else {\n                oldLayerMap[oldLayer.id] = oldLayer;\n            }\n        }\n        if (this._defaultShaderModulesChanged) {\n            for (const layer of oldLayers) {\n                layer.setNeedsUpdate();\n                layer.setChangeFlags({ extensionsChanged: true });\n            }\n            this._defaultShaderModulesChanged = false;\n        }\n        // Allocate array for generated layers\n        const generatedLayers = [];\n        // Match sublayers\n        this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);\n        // Finalize unmatched layers\n        this._finalizeOldLayers(oldLayerMap);\n        let needsUpdate = false;\n        for (const layer of generatedLayers) {\n            if (layer.hasUniformTransition()) {\n                needsUpdate = `Uniform transition in ${layer}`;\n                break;\n            }\n        }\n        this._needsUpdate = needsUpdate;\n        this.layers = generatedLayers;\n    }\n    /* eslint-disable complexity,max-statements */\n    // Note: adds generated layers to `generatedLayers` array parameter\n    _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {\n        for (const newLayer of newLayers) {\n            newLayer.context = this.context;\n            // Given a new coming layer, find its matching old layer (if any)\n            const oldLayer = oldLayerMap[newLayer.id];\n            if (oldLayer === null) {\n                // null, rather than undefined, means this id was originally there\n                log.warn(`Multiple new layers with same id ${newLayer.id}`)();\n            }\n            // Remove the old layer from candidates, as it has been matched with this layer\n            oldLayerMap[newLayer.id] = null;\n            let sublayers = null;\n            // We must not generate exceptions until after layer matching is complete\n            try {\n                if (this._debug && oldLayer !== newLayer) {\n                    newLayer.validateProps();\n                }\n                if (!oldLayer) {\n                    this._initializeLayer(newLayer);\n                }\n                else {\n                    this._transferLayerState(oldLayer, newLayer);\n                    this._updateLayer(newLayer);\n                }\n                generatedLayers.push(newLayer);\n                // Call layer lifecycle method: render sublayers\n                sublayers = newLayer.isComposite ? newLayer.getSubLayers() : null;\n                // End layer lifecycle method: render sublayers\n            }\n            catch (err) {\n                this._handleError('matching', err, newLayer); // Record first exception\n            }\n            if (sublayers) {\n                this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);\n            }\n        }\n    }\n    /* eslint-enable complexity,max-statements */\n    // Finalize any old layers that were not matched\n    _finalizeOldLayers(oldLayerMap) {\n        for (const layerId in oldLayerMap) {\n            const layer = oldLayerMap[layerId];\n            if (layer) {\n                this._finalizeLayer(layer);\n            }\n        }\n    }\n    // / EXCEPTION SAFE LAYER ACCESS\n    /** Safely initializes a single layer, calling layer methods */\n    _initializeLayer(layer) {\n        try {\n            layer._initialize();\n            layer.lifecycle = LIFECYCLE.INITIALIZED;\n        }\n        catch (err) {\n            this._handleError('initialization', err, layer);\n            // TODO - what should the lifecycle state be here? LIFECYCLE.INITIALIZATION_FAILED?\n        }\n    }\n    /** Transfer state from one layer to a newer version */\n    _transferLayerState(oldLayer, newLayer) {\n        newLayer._transferState(oldLayer);\n        newLayer.lifecycle = LIFECYCLE.MATCHED;\n        if (newLayer !== oldLayer) {\n            oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;\n        }\n    }\n    /** Safely updates a single layer, cleaning all flags */\n    _updateLayer(layer) {\n        try {\n            layer._update();\n        }\n        catch (err) {\n            this._handleError('update', err, layer);\n        }\n    }\n    /** Safely finalizes a single layer, removing all resources */\n    _finalizeLayer(layer) {\n        this._needsRedraw = this._needsRedraw || `finalized ${layer}`;\n        layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;\n        try {\n            layer._finalize();\n            layer.lifecycle = LIFECYCLE.FINALIZED;\n        }\n        catch (err) {\n            this._handleError('finalization', err, layer);\n        }\n    }\n}\n//# sourceMappingURL=layer-manager.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { deepEqual } from \"../utils/deep-equal.js\";\nimport log from \"../utils/log.js\";\nimport { flatten } from \"../utils/flatten.js\";\nexport default class ViewManager {\n    constructor(props) {\n        // List of view descriptors, gets re-evaluated when width/height changes\n        this.views = [];\n        this.width = 100;\n        this.height = 100;\n        this.viewState = {};\n        this.controllers = {};\n        this.timeline = props.timeline;\n        this._viewports = []; // Generated viewports\n        this._viewportMap = {};\n        this._isUpdating = false;\n        this._needsRedraw = 'First render';\n        this._needsUpdate = 'Initialize';\n        this._eventManager = props.eventManager;\n        this._eventCallbacks = {\n            onViewStateChange: props.onViewStateChange,\n            onInteractionStateChange: props.onInteractionStateChange\n        };\n        Object.seal(this);\n        // Init with default map viewport\n        this.setProps(props);\n    }\n    /** Remove all resources and event listeners */\n    finalize() {\n        for (const key in this.controllers) {\n            const controller = this.controllers[key];\n            if (controller) {\n                controller.finalize();\n            }\n        }\n        this.controllers = {};\n    }\n    /** Check if a redraw is needed */\n    needsRedraw(opts = { clearRedrawFlags: false }) {\n        const redraw = this._needsRedraw;\n        if (opts.clearRedrawFlags) {\n            this._needsRedraw = false;\n        }\n        return redraw;\n    }\n    /** Mark the manager as dirty. Will rebuild all viewports and update controllers. */\n    setNeedsUpdate(reason) {\n        this._needsUpdate = this._needsUpdate || reason;\n        this._needsRedraw = this._needsRedraw || reason;\n    }\n    /** Checks each viewport for transition updates */\n    updateViewStates() {\n        for (const viewId in this.controllers) {\n            const controller = this.controllers[viewId];\n            if (controller) {\n                controller.updateTransition();\n            }\n        }\n    }\n    /** Get a set of viewports for a given width and height\n     * TODO - Intention is for deck.gl to autodeduce width and height and drop the need for props\n     * @param rect (object, optional) - filter the viewports\n     *   + not provided - return all viewports\n     *   + {x, y} - only return viewports that contain this pixel\n     *   + {x, y, width, height} - only return viewports that overlap with this rectangle\n     */\n    getViewports(rect) {\n        if (rect) {\n            return this._viewports.filter(viewport => viewport.containsPixel(rect));\n        }\n        return this._viewports;\n    }\n    /** Get a map of all views */\n    getViews() {\n        const viewMap = {};\n        this.views.forEach(view => {\n            viewMap[view.id] = view;\n        });\n        return viewMap;\n    }\n    /** Resolves a viewId string to a View */\n    getView(viewId) {\n        return this.views.find(view => view.id === viewId);\n    }\n    /** Returns the viewState for a specific viewId. Matches the viewState by\n      1. view.viewStateId\n      2. view.id\n      3. root viewState\n      then applies the view's filter if any */\n    getViewState(viewOrViewId) {\n        const view = typeof viewOrViewId === 'string' ? this.getView(viewOrViewId) : viewOrViewId;\n        // Backward compatibility: view state for single view\n        const viewState = (view && this.viewState[view.getViewStateId()]) || this.viewState;\n        return view ? view.filterViewState(viewState) : viewState;\n    }\n    getViewport(viewId) {\n        return this._viewportMap[viewId];\n    }\n    /**\n     * Unproject pixel coordinates on screen onto world coordinates,\n     * (possibly [lon, lat]) on map.\n     * - [x, y] => [lng, lat]\n     * - [x, y, z] => [lng, lat, Z]\n     * @param {Array} xyz -\n     * @param {Object} opts - options\n     * @param {Object} opts.topLeft=true - Whether origin is top left\n     * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]\n     */\n    unproject(xyz, opts) {\n        const viewports = this.getViewports();\n        const pixel = { x: xyz[0], y: xyz[1] };\n        for (let i = viewports.length - 1; i >= 0; --i) {\n            const viewport = viewports[i];\n            if (viewport.containsPixel(pixel)) {\n                const p = xyz.slice();\n                p[0] -= viewport.x;\n                p[1] -= viewport.y;\n                return viewport.unproject(p, opts);\n            }\n        }\n        return null;\n    }\n    /** Update the manager with new Deck props */\n    setProps(props) {\n        if (props.views) {\n            this._setViews(props.views);\n        }\n        if (props.viewState) {\n            this._setViewState(props.viewState);\n        }\n        if ('width' in props || 'height' in props) {\n            this._setSize(props.width, props.height);\n        }\n        // Important: avoid invoking _update() inside itself\n        // Nested updates result in unexpected side effects inside _rebuildViewports()\n        // when using auto control in pure-js\n        if (!this._isUpdating) {\n            this._update();\n        }\n    }\n    //\n    // PRIVATE METHODS\n    //\n    _update() {\n        this._isUpdating = true;\n        // Only rebuild viewports if the update flag is set\n        if (this._needsUpdate) {\n            this._needsUpdate = false;\n            this._rebuildViewports();\n        }\n        // If viewport transition(s) are triggered during viewports update, controller(s)\n        // will immediately call `onViewStateChange` which calls `viewManager.setProps` again.\n        if (this._needsUpdate) {\n            this._needsUpdate = false;\n            this._rebuildViewports();\n        }\n        this._isUpdating = false;\n    }\n    _setSize(width, height) {\n        if (width !== this.width || height !== this.height) {\n            this.width = width;\n            this.height = height;\n            this.setNeedsUpdate('Size changed');\n        }\n    }\n    // Update the view descriptor list and set change flag if needed\n    // Does not actually rebuild the `Viewport`s until `getViewports` is called\n    _setViews(views) {\n        views = flatten(views, Boolean);\n        const viewsChanged = this._diffViews(views, this.views);\n        if (viewsChanged) {\n            this.setNeedsUpdate('views changed');\n        }\n        this.views = views;\n    }\n    _setViewState(viewState) {\n        if (viewState) {\n            // depth = 3 when comparing viewStates: viewId.position.0\n            const viewStateChanged = !deepEqual(viewState, this.viewState, 3);\n            if (viewStateChanged) {\n                this.setNeedsUpdate('viewState changed');\n            }\n            this.viewState = viewState;\n        }\n        else {\n            log.warn('missing `viewState` or `initialViewState`')();\n        }\n    }\n    _createController(view, props) {\n        const Controller = props.type;\n        const controller = new Controller({\n            timeline: this.timeline,\n            eventManager: this._eventManager,\n            // Set an internal callback that calls the prop callback if provided\n            onViewStateChange: this._eventCallbacks.onViewStateChange,\n            onStateChange: this._eventCallbacks.onInteractionStateChange,\n            makeViewport: viewState => this.getView(view.id)?.makeViewport({\n                viewState,\n                width: this.width,\n                height: this.height\n            })\n        });\n        return controller;\n    }\n    _updateController(view, viewState, viewport, controller) {\n        const controllerProps = view.controller;\n        if (controllerProps && viewport) {\n            const resolvedProps = {\n                ...viewState,\n                ...controllerProps,\n                id: view.id,\n                x: viewport.x,\n                y: viewport.y,\n                width: viewport.width,\n                height: viewport.height\n            };\n            // Create controller if not already existing or if the type of the\n            // controller has changed.\n            if (!controller || controller.constructor !== controllerProps.type) {\n                controller = this._createController(view, resolvedProps);\n            }\n            if (controller) {\n                controller.setProps(resolvedProps);\n            }\n            return controller;\n        }\n        return null;\n    }\n    // Rebuilds viewports from descriptors towards a certain window size\n    _rebuildViewports() {\n        const { views } = this;\n        const oldControllers = this.controllers;\n        this._viewports = [];\n        this.controllers = {};\n        let invalidateControllers = false;\n        // Create controllers in reverse order, so that views on top receive events first\n        for (let i = views.length; i--;) {\n            const view = views[i];\n            const viewState = this.getViewState(view);\n            const viewport = view.makeViewport({ viewState, width: this.width, height: this.height });\n            let oldController = oldControllers[view.id];\n            const hasController = Boolean(view.controller);\n            if (hasController && !oldController) {\n                // When a new controller is added, invalidate all controllers below it so that\n                // events are registered in the correct order\n                invalidateControllers = true;\n            }\n            if ((invalidateControllers || !hasController) && oldController) {\n                // Remove and reattach invalidated controller\n                oldController.finalize();\n                oldController = null;\n            }\n            // Update the controller\n            this.controllers[view.id] = this._updateController(view, viewState, viewport, oldController);\n            if (viewport) {\n                this._viewports.unshift(viewport);\n            }\n        }\n        // Remove unused controllers\n        for (const id in oldControllers) {\n            const oldController = oldControllers[id];\n            if (oldController && !this.controllers[id]) {\n                oldController.finalize();\n            }\n        }\n        this._buildViewportMap();\n    }\n    _buildViewportMap() {\n        // Build a view id to view index\n        this._viewportMap = {};\n        this._viewports.forEach(viewport => {\n            if (viewport.id) {\n                // TODO - issue warning if multiple viewports use same id\n                this._viewportMap[viewport.id] = this._viewportMap[viewport.id] || viewport;\n            }\n        });\n    }\n    // Check if viewport array has changed, returns true if any change\n    // Note that descriptors can be the same\n    _diffViews(newViews, oldViews) {\n        if (newViews.length !== oldViews.length) {\n            return true;\n        }\n        return newViews.some((_, i) => !newViews[i].equals(oldViews[i]));\n    }\n}\n//# sourceMappingURL=view-manager.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst PERCENT_OR_PIXELS_REGEX = /([0-9]+\\.?[0-9]*)(%|px)/;\n// Takes a number or a string of formats `50%`, `33.3%` or `200px`\nexport function parsePosition(value) {\n    switch (typeof value) {\n        case 'number':\n            return {\n                position: value,\n                relative: false\n            };\n        case 'string':\n            const match = PERCENT_OR_PIXELS_REGEX.exec(value);\n            if (match && match.length >= 3) {\n                const relative = match[2] === '%';\n                const position = parseFloat(match[1]);\n                return {\n                    position: relative ? position / 100 : position,\n                    relative\n                };\n            }\n        // fallthrough\n        default:\n            // eslint-disable-line\n            throw new Error(`Could not parse position string ${value}`);\n    }\n}\nexport function getPosition(position, extent) {\n    return position.relative ? Math.round(position.position * extent) : position.position;\n}\n//# sourceMappingURL=positions.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { parsePosition, getPosition } from \"../utils/positions.js\";\nimport { deepEqual } from \"../utils/deep-equal.js\";\nexport default class View {\n    constructor(props) {\n        const { id, x = 0, y = 0, width = '100%', height = '100%', padding = null } = props;\n        // @ts-ignore\n        this.id = id || this.constructor.displayName || 'view';\n        this.props = { ...props, id: this.id };\n        // Extents\n        this._x = parsePosition(x);\n        this._y = parsePosition(y);\n        this._width = parsePosition(width);\n        this._height = parsePosition(height);\n        this._padding = padding && {\n            left: parsePosition(padding.left || 0),\n            right: parsePosition(padding.right || 0),\n            top: parsePosition(padding.top || 0),\n            bottom: parsePosition(padding.bottom || 0)\n        };\n        // Bind methods for easy access\n        this.equals = this.equals.bind(this);\n        Object.seal(this);\n    }\n    equals(view) {\n        if (this === view) {\n            return true;\n        }\n        // To correctly compare padding use depth=2\n        return this.constructor === view.constructor && deepEqual(this.props, view.props, 2);\n    }\n    /** Clone this view with modified props */\n    clone(newProps) {\n        const ViewConstructor = this.constructor;\n        return new ViewConstructor({ ...this.props, ...newProps });\n    }\n    /** Make viewport from canvas dimensions and view state */\n    makeViewport({ width, height, viewState }) {\n        viewState = this.filterViewState(viewState);\n        // Resolve relative viewport dimensions\n        const viewportDimensions = this.getDimensions({ width, height });\n        if (!viewportDimensions.height || !viewportDimensions.width) {\n            return null;\n        }\n        const ViewportType = this.getViewportType(viewState);\n        return new ViewportType({ ...viewState, ...this.props, ...viewportDimensions });\n    }\n    getViewStateId() {\n        const { viewState } = this.props;\n        if (typeof viewState === 'string') {\n            // if View.viewState is a string, return it\n            return viewState;\n        }\n        return viewState?.id || this.id;\n    }\n    // Allows view to override (or completely define) viewState\n    filterViewState(viewState) {\n        if (this.props.viewState && typeof this.props.viewState === 'object') {\n            // If we have specified an id, then intent is to override,\n            // If not, completely specify the view state\n            if (!this.props.viewState.id) {\n                return this.props.viewState;\n            }\n            // Merge in all props from View's viewState, except id\n            const newViewState = { ...viewState };\n            for (const key in this.props.viewState) {\n                if (key !== 'id') {\n                    newViewState[key] = this.props.viewState[key];\n                }\n            }\n            return newViewState;\n        }\n        return viewState;\n    }\n    /** Resolve the dimensions of the view from overall canvas dimensions */\n    getDimensions({ width, height }) {\n        const dimensions = {\n            x: getPosition(this._x, width),\n            y: getPosition(this._y, height),\n            width: getPosition(this._width, width),\n            height: getPosition(this._height, height)\n        };\n        if (this._padding) {\n            dimensions.padding = {\n                left: getPosition(this._padding.left, width),\n                top: getPosition(this._padding.top, height),\n                right: getPosition(this._padding.right, width),\n                bottom: getPosition(this._padding.bottom, height)\n            };\n        }\n        return dimensions;\n    }\n    // Used by sub classes to resolve controller props\n    get controller() {\n        const opts = this.props.controller;\n        if (!opts) {\n            return null;\n        }\n        if (opts === true) {\n            return { type: this.ControllerType };\n        }\n        if (typeof opts === 'function') {\n            return { type: opts };\n        }\n        return { type: this.ControllerType, ...opts };\n    }\n}\n//# sourceMappingURL=view.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport Transition from \"../transitions/transition.js\";\nconst noop = () => { };\n// Enums cannot be directly exported as they are not transpiled correctly into ES5, see https://github.com/visgl/deck.gl/issues/7130\nexport const TRANSITION_EVENTS = {\n    BREAK: 1,\n    SNAP_TO_END: 2,\n    IGNORE: 3\n};\nconst DEFAULT_EASING = t => t;\nconst DEFAULT_INTERRUPTION = TRANSITION_EVENTS.BREAK;\nexport default class TransitionManager {\n    constructor(opts) {\n        this._onTransitionUpdate = transition => {\n            // NOTE: Be cautious re-ordering statements in this function.\n            const { time, settings: { interpolator, startProps, endProps, duration, easing } } = transition;\n            const t = easing(time / duration);\n            const viewport = interpolator.interpolateProps(startProps, endProps, t);\n            // This gurantees all props (e.g. bearing, longitude) are normalized\n            // So when viewports are compared they are in same range.\n            this.propsInTransition = this.getControllerState({\n                ...this.props,\n                ...viewport\n            }).getViewportProps();\n            this.onViewStateChange({\n                viewState: this.propsInTransition,\n                oldViewState: this.props\n            });\n        };\n        this.getControllerState = opts.getControllerState;\n        this.propsInTransition = null;\n        this.transition = new Transition(opts.timeline);\n        this.onViewStateChange = opts.onViewStateChange || noop;\n        this.onStateChange = opts.onStateChange || noop;\n    }\n    finalize() {\n        this.transition.cancel();\n    }\n    // Returns current transitioned viewport.\n    getViewportInTransition() {\n        return this.propsInTransition;\n    }\n    // Process the vewiport change, either ignore or trigger a new transition.\n    // Return true if a new transition is triggered, false otherwise.\n    processViewStateChange(nextProps) {\n        let transitionTriggered = false;\n        const currentProps = this.props;\n        // Set this.props here as '_triggerTransition' calls '_updateViewport' that uses this.props.\n        this.props = nextProps;\n        // NOTE: Be cautious re-ordering statements in this function.\n        if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) {\n            return false;\n        }\n        if (this._isTransitionEnabled(nextProps)) {\n            let startProps = currentProps;\n            if (this.transition.inProgress) {\n                // @ts-expect-error\n                const { interruption, endProps } = this.transition.settings;\n                startProps = {\n                    ...currentProps,\n                    ...(interruption === TRANSITION_EVENTS.SNAP_TO_END\n                        ? endProps\n                        : this.propsInTransition || currentProps)\n                };\n            }\n            this._triggerTransition(startProps, nextProps);\n            transitionTriggered = true;\n        }\n        else {\n            this.transition.cancel();\n        }\n        return transitionTriggered;\n    }\n    updateTransition() {\n        this.transition.update();\n    }\n    // Helper methods\n    _isTransitionEnabled(props) {\n        const { transitionDuration, transitionInterpolator } = props;\n        return ((transitionDuration > 0 || transitionDuration === 'auto') &&\n            Boolean(transitionInterpolator));\n    }\n    _isUpdateDueToCurrentTransition(props) {\n        if (this.transition.inProgress && this.propsInTransition) {\n            // @ts-expect-error\n            return this.transition.settings.interpolator.arePropsEqual(props, this.propsInTransition);\n        }\n        return false;\n    }\n    _shouldIgnoreViewportChange(currentProps, nextProps) {\n        if (this.transition.inProgress) {\n            // @ts-expect-error\n            const transitionSettings = this.transition.settings;\n            // Ignore update if it is requested to be ignored\n            return (transitionSettings.interruption === TRANSITION_EVENTS.IGNORE ||\n                // Ignore update if it is due to current active transition.\n                this._isUpdateDueToCurrentTransition(nextProps));\n        }\n        if (this._isTransitionEnabled(nextProps)) {\n            // Ignore if none of the viewport props changed.\n            return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);\n        }\n        return true;\n    }\n    _triggerTransition(startProps, endProps) {\n        const startViewstate = this.getControllerState(startProps);\n        const endViewStateProps = this.getControllerState(endProps).shortestPathFrom(startViewstate);\n        // update transitionDuration for 'auto' mode\n        const transitionInterpolator = endProps.transitionInterpolator;\n        const duration = transitionInterpolator.getDuration\n            ? transitionInterpolator.getDuration(startProps, endProps)\n            : endProps.transitionDuration;\n        if (duration === 0) {\n            return;\n        }\n        const initialProps = transitionInterpolator.initializeProps(startProps, endViewStateProps);\n        this.propsInTransition = {};\n        const transitionSettings = {\n            duration,\n            easing: endProps.transitionEasing || DEFAULT_EASING,\n            interpolator: transitionInterpolator,\n            interruption: endProps.transitionInterruption || DEFAULT_INTERRUPTION,\n            startProps: initialProps.start,\n            endProps: initialProps.end,\n            onStart: endProps.onTransitionStart,\n            onUpdate: this._onTransitionUpdate,\n            onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),\n            onEnd: this._onTransitionEnd(endProps.onTransitionEnd)\n        };\n        this.transition.start(transitionSettings);\n        this.onStateChange({ inTransition: true });\n        this.updateTransition();\n    }\n    _onTransitionEnd(callback) {\n        return transition => {\n            this.propsInTransition = null;\n            this.onStateChange({\n                inTransition: false,\n                isZooming: false,\n                isPanning: false,\n                isRotating: false\n            });\n            callback?.(transition);\n        };\n    }\n}\n//# sourceMappingURL=transition-manager.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { equals } from '@math.gl/core';\nimport assert from \"../utils/assert.js\";\nexport default class TransitionInterpolator {\n    /**\n     * @param opts {array|object}\n     * @param opts.compare {array} - prop names used in equality check\n     * @param opts.extract {array} - prop names needed for interpolation\n     * @param opts.required {array} - prop names that must be supplied\n     * alternatively, supply one list of prop names as `opts` if all of the above are the same.\n     */\n    constructor(opts) {\n        const { compare, extract, required } = opts;\n        this._propsToCompare = compare;\n        this._propsToExtract = extract || compare;\n        this._requiredProps = required;\n    }\n    /**\n     * Checks if two sets of props need transition in between\n     * @param currentProps {object} - a list of viewport props\n     * @param nextProps {object} - a list of viewport props\n     * @returns {bool} - true if two props are equivalent\n     */\n    arePropsEqual(currentProps, nextProps) {\n        for (const key of this._propsToCompare) {\n            if (!(key in currentProps) ||\n                !(key in nextProps) ||\n                !equals(currentProps[key], nextProps[key])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Called before transition starts to validate/pre-process start and end props\n     * @param startProps {object} - a list of starting viewport props\n     * @param endProps {object} - a list of target viewport props\n     * @returns {Object} {start, end} - start and end props to be passed\n     *   to `interpolateProps`\n     */\n    initializeProps(startProps, endProps) {\n        const startViewStateProps = {};\n        const endViewStateProps = {};\n        for (const key of this._propsToExtract) {\n            if (key in startProps || key in endProps) {\n                startViewStateProps[key] = startProps[key];\n                endViewStateProps[key] = endProps[key];\n            }\n        }\n        this._checkRequiredProps(startViewStateProps);\n        this._checkRequiredProps(endViewStateProps);\n        return { start: startViewStateProps, end: endViewStateProps };\n    }\n    /**\n     * Returns transition duration\n     * @param startProps {object} - a list of starting viewport props\n     * @param endProps {object} - a list of target viewport props\n     * @returns {Number} - transition duration in milliseconds\n     */\n    getDuration(startProps, endProps) {\n        return endProps.transitionDuration;\n    }\n    _checkRequiredProps(props) {\n        if (!this._requiredProps) {\n            return;\n        }\n        this._requiredProps.forEach(propName => {\n            const value = props[propName];\n            assert(Number.isFinite(value) || Array.isArray(value), `${propName} is required for transition`);\n        });\n    }\n}\n//# sourceMappingURL=transition-interpolator.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Matrix4 } from '@math.gl/core';\nimport Viewport from \"./viewport.js\";\nimport { PROJECTION_MODE } from \"../lib/constants.js\";\nimport { altitudeToFovy, fovyToAltitude } from '@math.gl/web-mercator';\nimport { MAX_LATITUDE } from '@math.gl/web-mercator';\nimport { vec3, vec4 } from '@math.gl/core';\nconst DEGREES_TO_RADIANS = Math.PI / 180;\nconst RADIANS_TO_DEGREES = 180 / Math.PI;\nconst EARTH_RADIUS = 6370972;\nconst GLOBE_RADIUS = 256;\nfunction getDistanceScales() {\n    const unitsPerMeter = GLOBE_RADIUS / EARTH_RADIUS;\n    const unitsPerDegree = (Math.PI / 180) * GLOBE_RADIUS;\n    return {\n        unitsPerMeter: [unitsPerMeter, unitsPerMeter, unitsPerMeter],\n        unitsPerMeter2: [0, 0, 0],\n        metersPerUnit: [1 / unitsPerMeter, 1 / unitsPerMeter, 1 / unitsPerMeter],\n        unitsPerDegree: [unitsPerDegree, unitsPerDegree, unitsPerMeter],\n        unitsPerDegree2: [0, 0, 0],\n        degreesPerUnit: [1 / unitsPerDegree, 1 / unitsPerDegree, 1 / unitsPerMeter]\n    };\n}\nclass GlobeViewport extends Viewport {\n    constructor(opts = {}) {\n        const { longitude = 0, zoom = 0, \n        // Matches Maplibre defaults\n        // https://github.com/maplibre/maplibre-gl-js/blob/f8ab4b48d59ab8fe7b068b102538793bbdd4c848/src/geo/projection/globe_transform.ts#L632-L633\n        nearZMultiplier = 0.5, farZMultiplier = 1, resolution = 10 } = opts;\n        let { latitude = 0, height, altitude = 1.5, fovy } = opts;\n        // Clamp to web mercator limit to prevent bad inputs\n        latitude = Math.max(Math.min(latitude, MAX_LATITUDE), -MAX_LATITUDE);\n        height = height || 1;\n        if (fovy) {\n            altitude = fovyToAltitude(fovy);\n        }\n        else {\n            fovy = altitudeToFovy(altitude);\n        }\n        // Exagerate distance by latitude to match the Web Mercator distortion\n        // The goal is that globe and web mercator projection results converge at high zoom\n        // https://github.com/maplibre/maplibre-gl-js/blob/f8ab4b48d59ab8fe7b068b102538793bbdd4c848/src/geo/projection/globe_transform.ts#L575-L577\n        const scale = Math.pow(2, zoom - zoomAdjust(latitude));\n        const nearZ = opts.nearZ ?? nearZMultiplier;\n        const farZ = opts.farZ ?? (altitude + (GLOBE_RADIUS * 2 * scale) / height) * farZMultiplier;\n        // Calculate view matrix\n        const viewMatrix = new Matrix4().lookAt({ eye: [0, -altitude, 0], up: [0, 0, 1] });\n        viewMatrix.rotateX(latitude * DEGREES_TO_RADIANS);\n        viewMatrix.rotateZ(-longitude * DEGREES_TO_RADIANS);\n        viewMatrix.scale(scale / height);\n        super({\n            ...opts,\n            // x, y, width,\n            height,\n            // view matrix\n            viewMatrix,\n            longitude,\n            latitude,\n            zoom,\n            // projection matrix parameters\n            distanceScales: getDistanceScales(),\n            fovy,\n            focalDistance: altitude,\n            near: nearZ,\n            far: farZ\n        });\n        this.scale = scale;\n        this.latitude = latitude;\n        this.longitude = longitude;\n        this.fovy = fovy;\n        this.resolution = resolution;\n    }\n    get projectionMode() {\n        return PROJECTION_MODE.GLOBE;\n    }\n    getDistanceScales() {\n        return this.distanceScales;\n    }\n    getBounds(options = {}) {\n        const unprojectOption = { targetZ: options.z || 0 };\n        const left = this.unproject([0, this.height / 2], unprojectOption);\n        const top = this.unproject([this.width / 2, 0], unprojectOption);\n        const right = this.unproject([this.width, this.height / 2], unprojectOption);\n        const bottom = this.unproject([this.width / 2, this.height], unprojectOption);\n        if (right[0] < this.longitude)\n            right[0] += 360;\n        if (left[0] > this.longitude)\n            left[0] -= 360;\n        return [\n            Math.min(left[0], right[0], top[0], bottom[0]),\n            Math.min(left[1], right[1], top[1], bottom[1]),\n            Math.max(left[0], right[0], top[0], bottom[0]),\n            Math.max(left[1], right[1], top[1], bottom[1])\n        ];\n    }\n    unproject(xyz, { topLeft = true, targetZ } = {}) {\n        const [x, y, z] = xyz;\n        const y2 = topLeft ? y : this.height - y;\n        const { pixelUnprojectionMatrix } = this;\n        let coord;\n        if (Number.isFinite(z)) {\n            // Has depth component\n            coord = transformVector(pixelUnprojectionMatrix, [x, y2, z, 1]);\n        }\n        else {\n            // since we don't know the correct projected z value for the point,\n            // unproject two points to get a line and then find the point on that line that intersects with the sphere\n            const coord0 = transformVector(pixelUnprojectionMatrix, [x, y2, -1, 1]);\n            const coord1 = transformVector(pixelUnprojectionMatrix, [x, y2, 1, 1]);\n            const lt = ((targetZ || 0) / EARTH_RADIUS + 1) * GLOBE_RADIUS;\n            const lSqr = vec3.sqrLen(vec3.sub([], coord0, coord1));\n            const l0Sqr = vec3.sqrLen(coord0);\n            const l1Sqr = vec3.sqrLen(coord1);\n            const sSqr = (4 * l0Sqr * l1Sqr - (lSqr - l0Sqr - l1Sqr) ** 2) / 16;\n            const dSqr = (4 * sSqr) / lSqr;\n            const r0 = Math.sqrt(l0Sqr - dSqr);\n            const dr = Math.sqrt(Math.max(0, lt * lt - dSqr));\n            const t = (r0 - dr) / Math.sqrt(lSqr);\n            coord = vec3.lerp([], coord0, coord1, t);\n        }\n        const [X, Y, Z] = this.unprojectPosition(coord);\n        if (Number.isFinite(z)) {\n            return [X, Y, Z];\n        }\n        return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n    }\n    projectPosition(xyz) {\n        const [lng, lat, Z = 0] = xyz;\n        const lambda = lng * DEGREES_TO_RADIANS;\n        const phi = lat * DEGREES_TO_RADIANS;\n        const cosPhi = Math.cos(phi);\n        const D = (Z / EARTH_RADIUS + 1) * GLOBE_RADIUS;\n        return [Math.sin(lambda) * cosPhi * D, -Math.cos(lambda) * cosPhi * D, Math.sin(phi) * D];\n    }\n    unprojectPosition(xyz) {\n        const [x, y, z] = xyz;\n        const D = vec3.len(xyz);\n        const phi = Math.asin(z / D);\n        const lambda = Math.atan2(x, -y);\n        const lng = lambda * RADIANS_TO_DEGREES;\n        const lat = phi * RADIANS_TO_DEGREES;\n        const Z = (D / GLOBE_RADIUS - 1) * EARTH_RADIUS;\n        return [lng, lat, Z];\n    }\n    projectFlat(xyz) {\n        return xyz;\n    }\n    unprojectFlat(xyz) {\n        return xyz;\n    }\n    /**\n     * Pan the globe using delta-based movement\n     * @param coords - the geographic coordinates where the pan started\n     * @param pixel - the current screen position\n     * @param startPixel - the screen position where the pan started\n     * @returns updated viewport options with new longitude/latitude\n     */\n    panByPosition([startLng, startLat, startZoom], pixel, startPixel) {\n        // Scale rotation speed inversely with zoom, to approximate constant panning speed\n        const scale = Math.pow(2, this.zoom - zoomAdjust(this.latitude));\n        const rotationSpeed = 0.25 / scale;\n        const longitude = startLng + rotationSpeed * (startPixel[0] - pixel[0]);\n        let latitude = startLat - rotationSpeed * (startPixel[1] - pixel[1]);\n        latitude = Math.max(Math.min(latitude, MAX_LATITUDE), -MAX_LATITUDE);\n        const out = { longitude, latitude, zoom: startZoom - zoomAdjust(startLat) };\n        out.zoom += zoomAdjust(out.latitude);\n        return out;\n    }\n}\nGlobeViewport.displayName = 'GlobeViewport';\nexport default GlobeViewport;\nexport function zoomAdjust(latitude) {\n    const scaleAdjust = Math.PI * Math.cos((latitude * Math.PI) / 180);\n    return Math.log2(scaleAdjust);\n}\nfunction transformVector(matrix, vector) {\n    const result = vec4.transformMat4([], vector, matrix);\n    vec4.scale(result, result, 1 / result[3]);\n    return result;\n}\n//# sourceMappingURL=globe-viewport.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport TransitionInterpolator from \"./transition-interpolator.js\";\nimport { lerp } from '@math.gl/core';\nimport log from \"../utils/log.js\";\nimport GlobeViewport from \"../viewports/globe-viewport.js\";\nconst DEFAULT_PROPS = ['longitude', 'latitude', 'zoom', 'bearing', 'pitch'];\nconst DEFAULT_REQUIRED_PROPS = ['longitude', 'latitude', 'zoom'];\n/**\n * Performs linear interpolation of two view states.\n */\nexport default class LinearInterpolator extends TransitionInterpolator {\n    /**\n     * @param {Object} opts\n     * @param {Array} opts.transitionProps - list of props to apply linear transition to.\n     * @param {Array} opts.around - a screen point to zoom/rotate around.\n     * @param {Function} opts.makeViewport - construct a viewport instance with given props.\n     */\n    constructor(opts = {}) {\n        // Backward compatibility\n        const transitionProps = Array.isArray(opts) ? opts : opts.transitionProps;\n        const normalizedOpts = Array.isArray(opts) ? {} : opts;\n        normalizedOpts.transitionProps = Array.isArray(transitionProps)\n            ? {\n                compare: transitionProps,\n                required: transitionProps\n            }\n            : transitionProps || {\n                compare: DEFAULT_PROPS,\n                required: DEFAULT_REQUIRED_PROPS\n            };\n        super(normalizedOpts.transitionProps);\n        this.opts = normalizedOpts;\n    }\n    initializeProps(startProps, endProps) {\n        const result = super.initializeProps(startProps, endProps);\n        const { makeViewport, around } = this.opts;\n        if (makeViewport && around) {\n            const TestViewport = makeViewport(startProps);\n            if (TestViewport instanceof GlobeViewport) {\n                log.warn('around not supported in GlobeView')();\n            }\n            else {\n                const startViewport = makeViewport(startProps);\n                const endViewport = makeViewport(endProps);\n                const aroundPosition = startViewport.unproject(around);\n                result.start.around = around;\n                Object.assign(result.end, {\n                    around: endViewport.project(aroundPosition),\n                    aroundPosition,\n                    width: endProps.width,\n                    height: endProps.height\n                });\n            }\n        }\n        return result;\n    }\n    interpolateProps(startProps, endProps, t) {\n        const propsInTransition = {};\n        for (const key of this._propsToExtract) {\n            propsInTransition[key] = lerp(startProps[key] || 0, endProps[key] || 0, t);\n        }\n        if (endProps.aroundPosition && this.opts.makeViewport) {\n            // Linear transition should be performed in common space\n            const viewport = this.opts.makeViewport({ ...endProps, ...propsInTransition });\n            Object.assign(propsInTransition, viewport.panByPosition(endProps.aroundPosition, \n            // anchor point in current screen coordinates\n            lerp(startProps.around, endProps.around, t)));\n        }\n        return propsInTransition;\n    }\n}\n//# sourceMappingURL=linear-interpolator.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/* eslint-disable max-statements, complexity */\nimport TransitionManager from \"./transition-manager.js\";\nimport LinearInterpolator from \"../transitions/linear-interpolator.js\";\nconst NO_TRANSITION_PROPS = {\n    transitionDuration: 0\n};\nconst DEFAULT_INERTIA = 300;\nconst INERTIA_EASING = t => 1 - (1 - t) * (1 - t);\nconst EVENT_TYPES = {\n    WHEEL: ['wheel'],\n    PAN: ['panstart', 'panmove', 'panend'],\n    PINCH: ['pinchstart', 'pinchmove', 'pinchend'],\n    MULTI_PAN: ['multipanstart', 'multipanmove', 'multipanend'],\n    DOUBLE_CLICK: ['dblclick'],\n    KEYBOARD: ['keydown']\n};\nconst pinchEventWorkaround = {};\nexport default class Controller {\n    constructor(opts) {\n        this.state = {};\n        this._events = {};\n        this._interactionState = {\n            isDragging: false\n        };\n        this._customEvents = [];\n        this._eventStartBlocked = null;\n        this._panMove = false;\n        this.invertPan = false;\n        this.dragMode = 'rotate';\n        this.inertia = 0;\n        this.scrollZoom = true;\n        this.dragPan = true;\n        this.dragRotate = true;\n        this.doubleClickZoom = true;\n        this.touchZoom = true;\n        this.touchRotate = false;\n        this.keyboard = true;\n        this.transitionManager = new TransitionManager({\n            ...opts,\n            getControllerState: props => new this.ControllerState(props),\n            onViewStateChange: this._onTransition.bind(this),\n            onStateChange: this._setInteractionState.bind(this)\n        });\n        this.handleEvent = this.handleEvent.bind(this);\n        this.eventManager = opts.eventManager;\n        this.onViewStateChange = opts.onViewStateChange || (() => { });\n        this.onStateChange = opts.onStateChange || (() => { });\n        this.makeViewport = opts.makeViewport;\n    }\n    set events(customEvents) {\n        this.toggleEvents(this._customEvents, false);\n        this.toggleEvents(customEvents, true);\n        this._customEvents = customEvents;\n        // Make sure default events are not overwritten\n        if (this.props) {\n            this.setProps(this.props);\n        }\n    }\n    finalize() {\n        for (const eventName in this._events) {\n            if (this._events[eventName]) {\n                // @ts-ignore (2345) event type string cannot be assifned to enum\n                // eslint-disable-next-line @typescript-eslint/unbound-method\n                this.eventManager?.off(eventName, this.handleEvent);\n            }\n        }\n        this.transitionManager.finalize();\n    }\n    /**\n     * Callback for events\n     */\n    handleEvent(event) {\n        // Force recalculate controller state\n        this._controllerState = undefined;\n        const eventStartBlocked = this._eventStartBlocked;\n        switch (event.type) {\n            case 'panstart':\n                return eventStartBlocked ? false : this._onPanStart(event);\n            case 'panmove':\n                return this._onPan(event);\n            case 'panend':\n                return this._onPanEnd(event);\n            case 'pinchstart':\n                return eventStartBlocked ? false : this._onPinchStart(event);\n            case 'pinchmove':\n                return this._onPinch(event);\n            case 'pinchend':\n                return this._onPinchEnd(event);\n            case 'multipanstart':\n                return eventStartBlocked ? false : this._onMultiPanStart(event);\n            case 'multipanmove':\n                return this._onMultiPan(event);\n            case 'multipanend':\n                return this._onMultiPanEnd(event);\n            case 'dblclick':\n                return this._onDoubleClick(event);\n            case 'wheel':\n                return this._onWheel(event);\n            case 'keydown':\n                return this._onKeyDown(event);\n            default:\n                return false;\n        }\n    }\n    /* Event utils */\n    // Event object: http://hammerjs.github.io/api/#event-object\n    get controllerState() {\n        this._controllerState = this._controllerState || new this.ControllerState({\n            makeViewport: this.makeViewport,\n            ...this.props,\n            ...this.state\n        });\n        return this._controllerState;\n    }\n    getCenter(event) {\n        const { x, y } = this.props;\n        const { offsetCenter } = event;\n        return [offsetCenter.x - x, offsetCenter.y - y];\n    }\n    isPointInBounds(pos, event) {\n        const { width, height } = this.props;\n        if (event && event.handled) {\n            return false;\n        }\n        const inside = pos[0] >= 0 && pos[0] <= width && pos[1] >= 0 && pos[1] <= height;\n        if (inside && event) {\n            event.stopPropagation();\n        }\n        return inside;\n    }\n    isFunctionKeyPressed(event) {\n        const { srcEvent } = event;\n        return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);\n    }\n    isDragging() {\n        return this._interactionState.isDragging || false;\n    }\n    // When a multi-touch event ends, e.g. pinch, not all pointers are lifted at the same time.\n    // This triggers a brief `pan` event.\n    // Calling this method will temporarily disable *start events to avoid conflicting transitions.\n    blockEvents(timeout) {\n        /* global setTimeout */\n        const timer = setTimeout(() => {\n            if (this._eventStartBlocked === timer) {\n                this._eventStartBlocked = null;\n            }\n        }, timeout);\n        this._eventStartBlocked = timer;\n    }\n    /**\n     * Extract interactivity options\n     */\n    setProps(props) {\n        if (props.dragMode) {\n            this.dragMode = props.dragMode;\n        }\n        this.props = props;\n        if (!('transitionInterpolator' in props)) {\n            // Add default transition interpolator\n            props.transitionInterpolator = this._getTransitionProps().transitionInterpolator;\n        }\n        this.transitionManager.processViewStateChange(props);\n        const { inertia } = props;\n        this.inertia = Number.isFinite(inertia) ? inertia : (inertia === true ? DEFAULT_INERTIA : 0);\n        // TODO - make sure these are not reset on every setProps\n        const { scrollZoom = true, dragPan = true, dragRotate = true, doubleClickZoom = true, touchZoom = true, touchRotate = false, keyboard = true } = props;\n        // Register/unregister events\n        const isInteractive = Boolean(this.onViewStateChange);\n        this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);\n        // We always need the pan events to set the correct isDragging state, even if dragPan & dragRotate are both false\n        this.toggleEvents(EVENT_TYPES.PAN, isInteractive);\n        this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && (touchZoom || touchRotate));\n        this.toggleEvents(EVENT_TYPES.MULTI_PAN, isInteractive && touchRotate);\n        this.toggleEvents(EVENT_TYPES.DOUBLE_CLICK, isInteractive && doubleClickZoom);\n        this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && keyboard);\n        // Interaction toggles\n        this.scrollZoom = scrollZoom;\n        this.dragPan = dragPan;\n        this.dragRotate = dragRotate;\n        this.doubleClickZoom = doubleClickZoom;\n        this.touchZoom = touchZoom;\n        this.touchRotate = touchRotate;\n        this.keyboard = keyboard;\n    }\n    updateTransition() {\n        this.transitionManager.updateTransition();\n    }\n    toggleEvents(eventNames, enabled) {\n        if (this.eventManager) {\n            eventNames.forEach(eventName => {\n                if (this._events[eventName] !== enabled) {\n                    this._events[eventName] = enabled;\n                    if (enabled) {\n                        // eslint-disable-next-line @typescript-eslint/unbound-method\n                        this.eventManager.on(eventName, this.handleEvent);\n                    }\n                    else {\n                        // eslint-disable-next-line @typescript-eslint/unbound-method\n                        this.eventManager.off(eventName, this.handleEvent);\n                    }\n                }\n            });\n        }\n    }\n    // Private Methods\n    /* Callback util */\n    // formats map state and invokes callback function\n    updateViewport(newControllerState, extraProps = null, interactionState = {}) {\n        const viewState = { ...newControllerState.getViewportProps(), ...extraProps };\n        // TODO - to restore diffing, we need to include interactionState\n        const changed = this.controllerState !== newControllerState;\n        // const oldViewState = this.controllerState.getViewportProps();\n        // const changed = Object.keys(viewState).some(key => oldViewState[key] !== viewState[key]);\n        this.state = newControllerState.getState();\n        this._setInteractionState(interactionState);\n        if (changed) {\n            const oldViewState = this.controllerState && this.controllerState.getViewportProps();\n            if (this.onViewStateChange) {\n                this.onViewStateChange({ viewState, interactionState: this._interactionState, oldViewState, viewId: this.props.id });\n            }\n        }\n    }\n    _onTransition(params) {\n        this.onViewStateChange({ ...params, interactionState: this._interactionState, viewId: this.props.id });\n    }\n    _setInteractionState(newStates) {\n        Object.assign(this._interactionState, newStates);\n        this.onStateChange(this._interactionState);\n    }\n    /* Event handlers */\n    // Default handler for the `panstart` event.\n    _onPanStart(event) {\n        const pos = this.getCenter(event);\n        if (!this.isPointInBounds(pos, event)) {\n            return false;\n        }\n        let alternateMode = this.isFunctionKeyPressed(event) || event.rightButton || false;\n        if (this.invertPan || this.dragMode === 'pan') {\n            // invertPan is replaced by props.dragMode, keeping for backward compatibility\n            alternateMode = !alternateMode;\n        }\n        const newControllerState = this.controllerState[alternateMode ? 'panStart' : 'rotateStart']({\n            pos\n        });\n        this._panMove = alternateMode;\n        this.updateViewport(newControllerState, NO_TRANSITION_PROPS, { isDragging: true });\n        return true;\n    }\n    // Default handler for the `panmove` and `panend` event.\n    _onPan(event) {\n        if (!this.isDragging()) {\n            return false;\n        }\n        return this._panMove ? this._onPanMove(event) : this._onPanRotate(event);\n    }\n    _onPanEnd(event) {\n        if (!this.isDragging()) {\n            return false;\n        }\n        return this._panMove ? this._onPanMoveEnd(event) : this._onPanRotateEnd(event);\n    }\n    // Default handler for panning to move.\n    // Called by `_onPan` when panning without function key pressed.\n    _onPanMove(event) {\n        if (!this.dragPan) {\n            return false;\n        }\n        const pos = this.getCenter(event);\n        const newControllerState = this.controllerState.pan({ pos });\n        this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {\n            isDragging: true,\n            isPanning: true\n        });\n        return true;\n    }\n    _onPanMoveEnd(event) {\n        const { inertia } = this;\n        if (this.dragPan && inertia && event.velocity) {\n            const pos = this.getCenter(event);\n            const endPos = [\n                pos[0] + (event.velocityX * inertia) / 2,\n                pos[1] + (event.velocityY * inertia) / 2\n            ];\n            const newControllerState = this.controllerState.pan({ pos: endPos }).panEnd();\n            this.updateViewport(newControllerState, {\n                ...this._getTransitionProps(),\n                transitionDuration: inertia,\n                transitionEasing: INERTIA_EASING\n            }, {\n                isDragging: false,\n                isPanning: true\n            });\n        }\n        else {\n            const newControllerState = this.controllerState.panEnd();\n            this.updateViewport(newControllerState, null, {\n                isDragging: false,\n                isPanning: false\n            });\n        }\n        return true;\n    }\n    // Default handler for panning to rotate.\n    // Called by `_onPan` when panning with function key pressed.\n    _onPanRotate(event) {\n        if (!this.dragRotate) {\n            return false;\n        }\n        const pos = this.getCenter(event);\n        const newControllerState = this.controllerState.rotate({ pos });\n        this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {\n            isDragging: true,\n            isRotating: true\n        });\n        return true;\n    }\n    _onPanRotateEnd(event) {\n        const { inertia } = this;\n        if (this.dragRotate && inertia && event.velocity) {\n            const pos = this.getCenter(event);\n            const endPos = [\n                pos[0] + (event.velocityX * inertia) / 2,\n                pos[1] + (event.velocityY * inertia) / 2\n            ];\n            const newControllerState = this.controllerState.rotate({ pos: endPos }).rotateEnd();\n            this.updateViewport(newControllerState, {\n                ...this._getTransitionProps(),\n                transitionDuration: inertia,\n                transitionEasing: INERTIA_EASING\n            }, {\n                isDragging: false,\n                isRotating: true\n            });\n        }\n        else {\n            const newControllerState = this.controllerState.rotateEnd();\n            this.updateViewport(newControllerState, null, {\n                isDragging: false,\n                isRotating: false\n            });\n        }\n        return true;\n    }\n    // Default handler for the `wheel` event.\n    _onWheel(event) {\n        if (!this.scrollZoom) {\n            return false;\n        }\n        const pos = this.getCenter(event);\n        if (!this.isPointInBounds(pos, event)) {\n            return false;\n        }\n        event.srcEvent.preventDefault();\n        const { speed = 0.01, smooth = false } = this.scrollZoom === true ? {} : this.scrollZoom;\n        const { delta } = event;\n        // Map wheel delta to relative scale\n        let scale = 2 / (1 + Math.exp(-Math.abs(delta * speed)));\n        if (delta < 0 && scale !== 0) {\n            scale = 1 / scale;\n        }\n        const transitionProps = smooth\n            ? { ...this._getTransitionProps({ around: pos }), transitionDuration: 250 }\n            : NO_TRANSITION_PROPS;\n        const newControllerState = this.controllerState.zoom({ pos, scale });\n        this.updateViewport(newControllerState, transitionProps, {\n            isZooming: true,\n            isPanning: true\n        });\n        // When there's no transition (duration = 0), immediately reset interaction state\n        // since _onTransitionEnd callback won't fire\n        if (!smooth) {\n            this._setInteractionState({ isZooming: false, isPanning: false });\n        }\n        return true;\n    }\n    _onMultiPanStart(event) {\n        const pos = this.getCenter(event);\n        if (!this.isPointInBounds(pos, event)) {\n            return false;\n        }\n        const newControllerState = this.controllerState.rotateStart({ pos });\n        this.updateViewport(newControllerState, NO_TRANSITION_PROPS, { isDragging: true });\n        return true;\n    }\n    _onMultiPan(event) {\n        if (!this.touchRotate) {\n            return false;\n        }\n        if (!this.isDragging()) {\n            return false;\n        }\n        const pos = this.getCenter(event);\n        pos[0] -= event.deltaX;\n        const newControllerState = this.controllerState.rotate({ pos });\n        this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {\n            isDragging: true,\n            isRotating: true\n        });\n        return true;\n    }\n    _onMultiPanEnd(event) {\n        if (!this.isDragging()) {\n            return false;\n        }\n        const { inertia } = this;\n        if (this.touchRotate && inertia && event.velocityY) {\n            const pos = this.getCenter(event);\n            const endPos = [pos[0], (pos[1] += (event.velocityY * inertia) / 2)];\n            const newControllerState = this.controllerState.rotate({ pos: endPos });\n            this.updateViewport(newControllerState, {\n                ...this._getTransitionProps(),\n                transitionDuration: inertia,\n                transitionEasing: INERTIA_EASING\n            }, {\n                isDragging: false,\n                isRotating: true\n            });\n            this.blockEvents(inertia);\n        }\n        else {\n            const newControllerState = this.controllerState.rotateEnd();\n            this.updateViewport(newControllerState, null, {\n                isDragging: false,\n                isRotating: false\n            });\n        }\n        return true;\n    }\n    // Default handler for the `pinchstart` event.\n    _onPinchStart(event) {\n        const pos = this.getCenter(event);\n        if (!this.isPointInBounds(pos, event)) {\n            return false;\n        }\n        const newControllerState = this.controllerState.zoomStart({ pos }).rotateStart({ pos });\n        // hack - hammer's `rotation` field doesn't seem to produce the correct angle\n        pinchEventWorkaround._startPinchRotation = event.rotation;\n        pinchEventWorkaround._lastPinchEvent = event;\n        this.updateViewport(newControllerState, NO_TRANSITION_PROPS, { isDragging: true });\n        return true;\n    }\n    // Default handler for the `pinchmove` and `pinchend` events.\n    _onPinch(event) {\n        if (!this.touchZoom && !this.touchRotate) {\n            return false;\n        }\n        if (!this.isDragging()) {\n            return false;\n        }\n        let newControllerState = this.controllerState;\n        if (this.touchZoom) {\n            const { scale } = event;\n            const pos = this.getCenter(event);\n            newControllerState = newControllerState.zoom({ pos, scale });\n        }\n        if (this.touchRotate) {\n            const { rotation } = event;\n            newControllerState = newControllerState.rotate({\n                deltaAngleX: pinchEventWorkaround._startPinchRotation - rotation\n            });\n        }\n        this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {\n            isDragging: true,\n            isPanning: this.touchZoom,\n            isZooming: this.touchZoom,\n            isRotating: this.touchRotate\n        });\n        pinchEventWorkaround._lastPinchEvent = event;\n        return true;\n    }\n    _onPinchEnd(event) {\n        if (!this.isDragging()) {\n            return false;\n        }\n        const { inertia } = this;\n        const { _lastPinchEvent } = pinchEventWorkaround;\n        if (this.touchZoom && inertia && _lastPinchEvent && event.scale !== _lastPinchEvent.scale) {\n            const pos = this.getCenter(event);\n            let newControllerState = this.controllerState.rotateEnd();\n            const z = Math.log2(event.scale);\n            const velocityZ = (z - Math.log2(_lastPinchEvent.scale)) / (event.deltaTime - _lastPinchEvent.deltaTime);\n            const endScale = Math.pow(2, z + (velocityZ * inertia) / 2);\n            newControllerState = newControllerState.zoom({ pos, scale: endScale }).zoomEnd();\n            this.updateViewport(newControllerState, {\n                ...this._getTransitionProps({ around: pos }),\n                transitionDuration: inertia,\n                transitionEasing: INERTIA_EASING\n            }, {\n                isDragging: false,\n                isPanning: this.touchZoom,\n                isZooming: this.touchZoom,\n                isRotating: false\n            });\n            this.blockEvents(inertia);\n        }\n        else {\n            const newControllerState = this.controllerState.zoomEnd().rotateEnd();\n            this.updateViewport(newControllerState, null, {\n                isDragging: false,\n                isPanning: false,\n                isZooming: false,\n                isRotating: false\n            });\n        }\n        pinchEventWorkaround._startPinchRotation = null;\n        pinchEventWorkaround._lastPinchEvent = null;\n        return true;\n    }\n    // Default handler for the `dblclick` event.\n    _onDoubleClick(event) {\n        if (!this.doubleClickZoom) {\n            return false;\n        }\n        const pos = this.getCenter(event);\n        if (!this.isPointInBounds(pos, event)) {\n            return false;\n        }\n        const isZoomOut = this.isFunctionKeyPressed(event);\n        const newControllerState = this.controllerState.zoom({ pos, scale: isZoomOut ? 0.5 : 2 });\n        this.updateViewport(newControllerState, this._getTransitionProps({ around: pos }), {\n            isZooming: true,\n            isPanning: true\n        });\n        this.blockEvents(100);\n        return true;\n    }\n    // Default handler for the `keydown` event\n    _onKeyDown(event) {\n        if (!this.keyboard) {\n            return false;\n        }\n        const funcKey = this.isFunctionKeyPressed(event);\n        // @ts-ignore\n        const { zoomSpeed, moveSpeed, rotateSpeedX, rotateSpeedY } = this.keyboard === true ? {} : this.keyboard;\n        const { controllerState } = this;\n        let newControllerState;\n        const interactionState = {};\n        switch (event.srcEvent.code) {\n            case 'Minus':\n                newControllerState = funcKey\n                    ? controllerState.zoomOut(zoomSpeed).zoomOut(zoomSpeed)\n                    : controllerState.zoomOut(zoomSpeed);\n                interactionState.isZooming = true;\n                break;\n            case 'Equal':\n                newControllerState = funcKey\n                    ? controllerState.zoomIn(zoomSpeed).zoomIn(zoomSpeed)\n                    : controllerState.zoomIn(zoomSpeed);\n                interactionState.isZooming = true;\n                break;\n            case 'ArrowLeft':\n                if (funcKey) {\n                    newControllerState = controllerState.rotateLeft(rotateSpeedX);\n                    interactionState.isRotating = true;\n                }\n                else {\n                    newControllerState = controllerState.moveLeft(moveSpeed);\n                    interactionState.isPanning = true;\n                }\n                break;\n            case 'ArrowRight':\n                if (funcKey) {\n                    newControllerState = controllerState.rotateRight(rotateSpeedX);\n                    interactionState.isRotating = true;\n                }\n                else {\n                    newControllerState = controllerState.moveRight(moveSpeed);\n                    interactionState.isPanning = true;\n                }\n                break;\n            case 'ArrowUp':\n                if (funcKey) {\n                    newControllerState = controllerState.rotateUp(rotateSpeedY);\n                    interactionState.isRotating = true;\n                }\n                else {\n                    newControllerState = controllerState.moveUp(moveSpeed);\n                    interactionState.isPanning = true;\n                }\n                break;\n            case 'ArrowDown':\n                if (funcKey) {\n                    newControllerState = controllerState.rotateDown(rotateSpeedY);\n                    interactionState.isRotating = true;\n                }\n                else {\n                    newControllerState = controllerState.moveDown(moveSpeed);\n                    interactionState.isPanning = true;\n                }\n                break;\n            default:\n                return false;\n        }\n        this.updateViewport(newControllerState, this._getTransitionProps(), interactionState);\n        return true;\n    }\n    _getTransitionProps(opts) {\n        const { transition } = this;\n        if (!transition || !transition.transitionInterpolator) {\n            return NO_TRANSITION_PROPS;\n        }\n        // Enables Transitions on double-tap and key-down events.\n        return opts\n            ? {\n                ...transition,\n                transitionInterpolator: new LinearInterpolator({\n                    ...opts,\n                    ...transition.transitionInterpolator.opts,\n                    makeViewport: this.controllerState.makeViewport\n                })\n            }\n            : transition;\n    }\n}\n//# sourceMappingURL=controller.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport default class ViewState {\n    constructor(props, state) {\n        this._viewportProps = this.applyConstraints(props);\n        this._state = state;\n    }\n    getViewportProps() {\n        return this._viewportProps;\n    }\n    getState() {\n        return this._state;\n    }\n}\n//# sourceMappingURL=view-state.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { clamp } from '@math.gl/core';\nimport Controller from \"./controller.js\";\nimport ViewState from \"./view-state.js\";\nimport { normalizeViewportProps } from '@math.gl/web-mercator';\nimport assert from \"../utils/assert.js\";\nimport LinearInterpolator from \"../transitions/linear-interpolator.js\";\nconst PITCH_MOUSE_THRESHOLD = 5;\nconst PITCH_ACCEL = 1.2;\n/* Utils */\nexport class MapState extends ViewState {\n    constructor(options) {\n        const { \n        /** Mapbox viewport properties */\n        /** The width of the viewport */\n        width, \n        /** The height of the viewport */\n        height, \n        /** The latitude at the center of the viewport */\n        latitude, \n        /** The longitude at the center of the viewport */\n        longitude, \n        /** The tile zoom level of the map. */\n        zoom, \n        /** The bearing of the viewport in degrees */\n        bearing = 0, \n        /** The pitch of the viewport in degrees */\n        pitch = 0, \n        /**\n         * Specify the altitude of the viewport camera\n         * Unit: map heights, default 1.5\n         * Non-public API, see https://github.com/mapbox/mapbox-gl-js/issues/1137\n         */\n        altitude = 1.5, \n        /** Viewport position */\n        position = [0, 0, 0], \n        /** Viewport constraints */\n        maxZoom = 20, minZoom = 0, maxPitch = 60, minPitch = 0, \n        /** Interaction states, required to calculate change during transform */\n        /* The point on map being grabbed when the operation first started */\n        startPanLngLat, \n        /* Center of the zoom when the operation first started */\n        startZoomLngLat, \n        /* Pointer position when rotation started */\n        startRotatePos, \n        /** Bearing when current perspective rotate operation started */\n        startBearing, \n        /** Pitch when current perspective rotate operation started */\n        startPitch, \n        /** Zoom when current zoom operation started */\n        startZoom, \n        /** Normalize viewport props to fit map height into viewport */\n        normalize = true } = options;\n        assert(Number.isFinite(longitude)); // `longitude` must be supplied\n        assert(Number.isFinite(latitude)); // `latitude` must be supplied\n        assert(Number.isFinite(zoom)); // `zoom` must be supplied\n        super({\n            width,\n            height,\n            latitude,\n            longitude,\n            zoom,\n            bearing,\n            pitch,\n            altitude,\n            maxZoom,\n            minZoom,\n            maxPitch,\n            minPitch,\n            normalize,\n            position\n        }, {\n            startPanLngLat,\n            startZoomLngLat,\n            startRotatePos,\n            startBearing,\n            startPitch,\n            startZoom\n        });\n        this.makeViewport = options.makeViewport;\n    }\n    /**\n     * Start panning\n     * @param {[Number, Number]} pos - position on screen where the pointer grabs\n     */\n    panStart({ pos }) {\n        return this._getUpdatedState({\n            startPanLngLat: this._unproject(pos)\n        });\n    }\n    /**\n     * Pan\n     * @param {[Number, Number]} pos - position on screen where the pointer is\n     * @param {[Number, Number], optional} startPos - where the pointer grabbed at\n     *   the start of the operation. Must be supplied of `panStart()` was not called\n     */\n    pan({ pos, startPos }) {\n        const startPanLngLat = this.getState().startPanLngLat || this._unproject(startPos);\n        if (!startPanLngLat) {\n            return this;\n        }\n        const viewport = this.makeViewport(this.getViewportProps());\n        const newProps = viewport.panByPosition(startPanLngLat, pos);\n        return this._getUpdatedState(newProps);\n    }\n    /**\n     * End panning\n     * Must call if `panStart()` was called\n     */\n    panEnd() {\n        return this._getUpdatedState({\n            startPanLngLat: null\n        });\n    }\n    /**\n     * Start rotating\n     * @param {[Number, Number]} pos - position on screen where the center is\n     */\n    rotateStart({ pos }) {\n        return this._getUpdatedState({\n            startRotatePos: pos,\n            startBearing: this.getViewportProps().bearing,\n            startPitch: this.getViewportProps().pitch\n        });\n    }\n    /**\n     * Rotate\n     * @param {[Number, Number]} pos - position on screen where the center is\n     */\n    rotate({ pos, deltaAngleX = 0, deltaAngleY = 0 }) {\n        const { startRotatePos, startBearing, startPitch } = this.getState();\n        if (!startRotatePos || startBearing === undefined || startPitch === undefined) {\n            return this;\n        }\n        let newRotation;\n        if (pos) {\n            newRotation = this._getNewRotation(pos, startRotatePos, startPitch, startBearing);\n        }\n        else {\n            newRotation = {\n                bearing: startBearing + deltaAngleX,\n                pitch: startPitch + deltaAngleY\n            };\n        }\n        return this._getUpdatedState(newRotation);\n    }\n    /**\n     * End rotating\n     * Must call if `rotateStart()` was called\n     */\n    rotateEnd() {\n        return this._getUpdatedState({\n            startBearing: null,\n            startPitch: null\n        });\n    }\n    /**\n     * Start zooming\n     * @param {[Number, Number]} pos - position on screen where the center is\n     */\n    zoomStart({ pos }) {\n        return this._getUpdatedState({\n            startZoomLngLat: this._unproject(pos),\n            startZoom: this.getViewportProps().zoom\n        });\n    }\n    /**\n     * Zoom\n     * @param {[Number, Number]} pos - position on screen where the current center is\n     * @param {[Number, Number]} startPos - the center position at\n     *   the start of the operation. Must be supplied of `zoomStart()` was not called\n     * @param {Number} scale - a number between [0, 1] specifying the accumulated\n     *   relative scale.\n     */\n    zoom({ pos, startPos, scale }) {\n        // Make sure we zoom around the current mouse position rather than map center\n        let { startZoom, startZoomLngLat } = this.getState();\n        if (!startZoomLngLat) {\n            // We have two modes of zoom:\n            // scroll zoom that are discrete events (transform from the current zoom level),\n            // and pinch zoom that are continuous events (transform from the zoom level when\n            // pinch started).\n            // If startZoom state is defined, then use the startZoom state;\n            // otherwise assume discrete zooming\n            startZoom = this.getViewportProps().zoom;\n            startZoomLngLat = this._unproject(startPos) || this._unproject(pos);\n        }\n        if (!startZoomLngLat) {\n            return this;\n        }\n        const { maxZoom, minZoom } = this.getViewportProps();\n        let zoom = startZoom + Math.log2(scale);\n        zoom = clamp(zoom, minZoom, maxZoom);\n        const zoomedViewport = this.makeViewport({ ...this.getViewportProps(), zoom });\n        return this._getUpdatedState({\n            zoom,\n            ...zoomedViewport.panByPosition(startZoomLngLat, pos)\n        });\n    }\n    /**\n     * End zooming\n     * Must call if `zoomStart()` was called\n     */\n    zoomEnd() {\n        return this._getUpdatedState({\n            startZoomLngLat: null,\n            startZoom: null\n        });\n    }\n    zoomIn(speed = 2) {\n        return this._zoomFromCenter(speed);\n    }\n    zoomOut(speed = 2) {\n        return this._zoomFromCenter(1 / speed);\n    }\n    moveLeft(speed = 100) {\n        return this._panFromCenter([speed, 0]);\n    }\n    moveRight(speed = 100) {\n        return this._panFromCenter([-speed, 0]);\n    }\n    moveUp(speed = 100) {\n        return this._panFromCenter([0, speed]);\n    }\n    moveDown(speed = 100) {\n        return this._panFromCenter([0, -speed]);\n    }\n    rotateLeft(speed = 15) {\n        return this._getUpdatedState({\n            bearing: this.getViewportProps().bearing - speed\n        });\n    }\n    rotateRight(speed = 15) {\n        return this._getUpdatedState({\n            bearing: this.getViewportProps().bearing + speed\n        });\n    }\n    rotateUp(speed = 10) {\n        return this._getUpdatedState({\n            pitch: this.getViewportProps().pitch + speed\n        });\n    }\n    rotateDown(speed = 10) {\n        return this._getUpdatedState({\n            pitch: this.getViewportProps().pitch - speed\n        });\n    }\n    shortestPathFrom(viewState) {\n        // const endViewStateProps = new this.ControllerState(endProps).shortestPathFrom(startViewstate);\n        const fromProps = viewState.getViewportProps();\n        const props = { ...this.getViewportProps() };\n        const { bearing, longitude } = props;\n        if (Math.abs(bearing - fromProps.bearing) > 180) {\n            props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;\n        }\n        if (Math.abs(longitude - fromProps.longitude) > 180) {\n            props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;\n        }\n        return props;\n    }\n    // Apply any constraints (mathematical or defined by _viewportProps) to map state\n    applyConstraints(props) {\n        // Ensure zoom is within specified range\n        const { maxZoom, minZoom, zoom } = props;\n        props.zoom = clamp(zoom, minZoom, maxZoom);\n        // Ensure pitch is within specified range\n        const { maxPitch, minPitch, pitch } = props;\n        props.pitch = clamp(pitch, minPitch, maxPitch);\n        // Normalize viewport props to fit map height into viewport\n        const { normalize = true } = props;\n        if (normalize) {\n            Object.assign(props, normalizeViewportProps(props));\n        }\n        return props;\n    }\n    /* Private methods */\n    _zoomFromCenter(scale) {\n        const { width, height } = this.getViewportProps();\n        return this.zoom({\n            pos: [width / 2, height / 2],\n            scale\n        });\n    }\n    _panFromCenter(offset) {\n        const { width, height } = this.getViewportProps();\n        return this.pan({\n            startPos: [width / 2, height / 2],\n            pos: [width / 2 + offset[0], height / 2 + offset[1]]\n        });\n    }\n    _getUpdatedState(newProps) {\n        // @ts-ignore\n        return new this.constructor({\n            makeViewport: this.makeViewport,\n            ...this.getViewportProps(),\n            ...this.getState(),\n            ...newProps\n        });\n    }\n    _unproject(pos) {\n        const viewport = this.makeViewport(this.getViewportProps());\n        // @ts-ignore\n        return pos && viewport.unproject(pos);\n    }\n    _getNewRotation(pos, startPos, startPitch, startBearing) {\n        const deltaX = pos[0] - startPos[0];\n        const deltaY = pos[1] - startPos[1];\n        const centerY = pos[1];\n        const startY = startPos[1];\n        const { width, height } = this.getViewportProps();\n        const deltaScaleX = deltaX / width;\n        let deltaScaleY = 0;\n        if (deltaY > 0) {\n            if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {\n                // Move from 0 to -1 as we drag upwards\n                deltaScaleY = (deltaY / (startY - height)) * PITCH_ACCEL;\n            }\n        }\n        else if (deltaY < 0) {\n            if (startY > PITCH_MOUSE_THRESHOLD) {\n                // Move from 0 to 1 as we drag upwards\n                deltaScaleY = 1 - centerY / startY;\n            }\n        }\n        // clamp deltaScaleY to [-1, 1] so that rotation is constrained between minPitch and maxPitch.\n        // deltaScaleX does not need to be clamped as bearing does not have constraints.\n        deltaScaleY = clamp(deltaScaleY, -1, 1);\n        const { minPitch, maxPitch } = this.getViewportProps();\n        const bearing = startBearing + 180 * deltaScaleX;\n        let pitch = startPitch;\n        if (deltaScaleY > 0) {\n            // Gradually increase pitch\n            pitch = startPitch + deltaScaleY * (maxPitch - startPitch);\n        }\n        else if (deltaScaleY < 0) {\n            // Gradually decrease pitch\n            pitch = startPitch - deltaScaleY * (minPitch - startPitch);\n        }\n        return {\n            pitch,\n            bearing\n        };\n    }\n}\nexport default class MapController extends Controller {\n    constructor() {\n        super(...arguments);\n        this.ControllerState = MapState;\n        this.transition = {\n            transitionDuration: 300,\n            transitionInterpolator: new LinearInterpolator({\n                transitionProps: {\n                    compare: ['longitude', 'latitude', 'zoom', 'bearing', 'pitch', 'position'],\n                    required: ['longitude', 'latitude', 'zoom']\n                }\n            })\n        };\n        this.dragMode = 'pan';\n    }\n    setProps(props) {\n        props.position = props.position || [0, 0, 0];\n        const oldProps = this.props;\n        super.setProps(props);\n        const dimensionChanged = !oldProps || oldProps.height !== props.height;\n        if (dimensionChanged) {\n            // Dimensions changed, normalize the props\n            this.updateViewport(new this.ControllerState({\n                makeViewport: this.makeViewport,\n                ...props,\n                ...this.state\n            }));\n        }\n    }\n}\n//# sourceMappingURL=map-controller.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport View from \"./view.js\";\nimport WebMercatorViewport from \"../viewports/web-mercator-viewport.js\";\nimport MapController from \"../controllers/map-controller.js\";\nclass MapView extends View {\n    constructor(props = {}) {\n        super(props);\n    }\n    getViewportType() {\n        return WebMercatorViewport;\n    }\n    get ControllerType() {\n        return MapController;\n    }\n}\nMapView.displayName = 'MapView';\nexport default MapView;\n//# sourceMappingURL=map-view.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { deepEqual } from \"../utils/deep-equal.js\";\nimport LightingEffect from \"../effects/lighting/lighting-effect.js\";\nconst DEFAULT_LIGHTING_EFFECT = new LightingEffect();\n/** Sort two effects. Returns 0 if equal, negative if e1 < e2, positive if e1 > e2 */\nfunction compareEffects(e1, e2) {\n    const o1 = e1.order ?? Infinity;\n    const o2 = e2.order ?? Infinity;\n    return o1 - o2;\n}\nexport default class EffectManager {\n    constructor(context) {\n        this._resolvedEffects = [];\n        /** Effect instances and order preference pairs, sorted by order */\n        this._defaultEffects = [];\n        this.effects = [];\n        this._context = context;\n        this._needsRedraw = 'Initial render';\n        this._setEffects([]);\n    }\n    /**\n     * Register a new default effect, i.e. an effect presents regardless of user supplied props.effects\n     */\n    addDefaultEffect(effect) {\n        const defaultEffects = this._defaultEffects;\n        if (!defaultEffects.find(e => e.id === effect.id)) {\n            const index = defaultEffects.findIndex(e => compareEffects(e, effect) > 0);\n            if (index < 0) {\n                defaultEffects.push(effect);\n            }\n            else {\n                defaultEffects.splice(index, 0, effect);\n            }\n            effect.setup(this._context);\n            this._setEffects(this.effects);\n        }\n    }\n    setProps(props) {\n        if ('effects' in props) {\n            // Compare effects against each other shallowly\n            if (!deepEqual(props.effects, this.effects, 1)) {\n                this._setEffects(props.effects);\n            }\n        }\n    }\n    needsRedraw(opts = { clearRedrawFlags: false }) {\n        const redraw = this._needsRedraw;\n        if (opts.clearRedrawFlags) {\n            this._needsRedraw = false;\n        }\n        return redraw;\n    }\n    getEffects() {\n        return this._resolvedEffects;\n    }\n    _setEffects(effects) {\n        const oldEffectsMap = {};\n        for (const effect of this.effects) {\n            oldEffectsMap[effect.id] = effect;\n        }\n        const nextEffects = [];\n        for (const effect of effects) {\n            const oldEffect = oldEffectsMap[effect.id];\n            let effectToAdd = effect;\n            if (oldEffect && oldEffect !== effect) {\n                if (oldEffect.setProps) {\n                    oldEffect.setProps(effect.props);\n                    effectToAdd = oldEffect;\n                }\n                else {\n                    oldEffect.cleanup(this._context);\n                }\n            }\n            else if (!oldEffect) {\n                effect.setup(this._context);\n            }\n            nextEffects.push(effectToAdd);\n            delete oldEffectsMap[effect.id];\n        }\n        for (const removedEffectId in oldEffectsMap) {\n            oldEffectsMap[removedEffectId].cleanup(this._context);\n        }\n        this.effects = nextEffects;\n        this._resolvedEffects = nextEffects.concat(this._defaultEffects);\n        // Special case for lighting: only add default instance if no LightingEffect is specified\n        if (!effects.some(effect => effect instanceof LightingEffect)) {\n            this._resolvedEffects.push(DEFAULT_LIGHTING_EFFECT);\n        }\n        this._needsRedraw = 'effects changed';\n    }\n    finalize() {\n        for (const effect of this._resolvedEffects) {\n            effect.cleanup(this._context);\n        }\n        this.effects.length = 0;\n        this._resolvedEffects.length = 0;\n        this._defaultEffects.length = 0;\n    }\n}\n//# sourceMappingURL=effect-manager.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport LayersPass from \"./layers-pass.js\";\nexport default class DrawLayersPass extends LayersPass {\n    shouldDrawLayer(layer) {\n        const { operation } = layer.props;\n        return operation.includes('draw') || operation.includes('terrain');\n    }\n}\n//# sourceMappingURL=draw-layers-pass.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport debug from \"../debug/index.js\";\nimport DrawLayersPass from \"../passes/draw-layers-pass.js\";\nimport PickLayersPass from \"../passes/pick-layers-pass.js\";\nconst TRACE_RENDER_LAYERS = 'deckRenderer.renderLayers';\nexport default class DeckRenderer {\n    constructor(device) {\n        this.device = device;\n        this.layerFilter = null;\n        this.drawPickingColors = false;\n        this.drawLayersPass = new DrawLayersPass(device);\n        this.pickLayersPass = new PickLayersPass(device);\n        this.renderCount = 0;\n        this._needsRedraw = 'Initial render';\n        this.renderBuffers = [];\n        this.lastPostProcessEffect = null;\n    }\n    setProps(props) {\n        if (this.layerFilter !== props.layerFilter) {\n            this.layerFilter = props.layerFilter;\n            this._needsRedraw = 'layerFilter changed';\n        }\n        if (this.drawPickingColors !== props.drawPickingColors) {\n            this.drawPickingColors = props.drawPickingColors;\n            this._needsRedraw = 'drawPickingColors changed';\n        }\n    }\n    renderLayers(opts) {\n        if (!opts.viewports.length) {\n            return;\n        }\n        const layerPass = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;\n        const renderOpts = {\n            layerFilter: this.layerFilter,\n            isPicking: this.drawPickingColors,\n            ...opts\n        };\n        if (renderOpts.effects) {\n            this._preRender(renderOpts.effects, renderOpts);\n        }\n        const outputBuffer = this.lastPostProcessEffect ? this.renderBuffers[0] : renderOpts.target;\n        if (this.lastPostProcessEffect) {\n            renderOpts.clearColor = [0, 0, 0, 0];\n            renderOpts.clearCanvas = true;\n        }\n        const renderStats = layerPass.render({ ...renderOpts, target: outputBuffer });\n        if (renderOpts.effects) {\n            if (this.lastPostProcessEffect) {\n                // Interleaved basemap rendering requires clearCanvas to be false\n                renderOpts.clearCanvas = opts.clearCanvas === undefined ? true : opts.clearCanvas;\n            }\n            this._postRender(renderOpts.effects, renderOpts);\n        }\n        this.renderCount++;\n        debug(TRACE_RENDER_LAYERS, this, renderStats, opts);\n    }\n    needsRedraw(opts = { clearRedrawFlags: false }) {\n        const redraw = this._needsRedraw;\n        if (opts.clearRedrawFlags) {\n            this._needsRedraw = false;\n        }\n        return redraw;\n    }\n    finalize() {\n        const { renderBuffers } = this;\n        for (const buffer of renderBuffers) {\n            buffer.delete();\n        }\n        renderBuffers.length = 0;\n    }\n    _preRender(effects, opts) {\n        this.lastPostProcessEffect = null;\n        opts.preRenderStats = opts.preRenderStats || {};\n        for (const effect of effects) {\n            opts.preRenderStats[effect.id] = effect.preRender(opts);\n            if (effect.postRender) {\n                this.lastPostProcessEffect = effect.id;\n            }\n        }\n        if (this.lastPostProcessEffect) {\n            this._resizeRenderBuffers();\n        }\n    }\n    _resizeRenderBuffers() {\n        const { renderBuffers } = this;\n        const size = this.device.canvasContext.getDrawingBufferSize();\n        const [width, height] = size;\n        if (renderBuffers.length === 0) {\n            [0, 1].map(i => {\n                const texture = this.device.createTexture({\n                    sampler: { minFilter: 'linear', magFilter: 'linear' },\n                    width,\n                    height\n                });\n                renderBuffers.push(this.device.createFramebuffer({\n                    id: `deck-renderbuffer-${i}`,\n                    colorAttachments: [texture]\n                }));\n            });\n        }\n        for (const buffer of renderBuffers) {\n            buffer.resize(size);\n        }\n    }\n    _postRender(effects, opts) {\n        const { renderBuffers } = this;\n        const params = {\n            ...opts,\n            inputBuffer: renderBuffers[0],\n            swapBuffer: renderBuffers[1]\n        };\n        for (const effect of effects) {\n            if (effect.postRender) {\n                // If not the last post processing effect, unset the target so that\n                // it only renders between the swap buffers\n                params.target = effect.id === this.lastPostProcessEffect ? opts.target : undefined;\n                const buffer = effect.postRender(params);\n                // Buffer cannot be null if target is unset\n                params.inputBuffer = buffer;\n                params.swapBuffer = buffer === renderBuffers[0] ? renderBuffers[1] : renderBuffers[0];\n            }\n        }\n    }\n}\n//# sourceMappingURL=deck-renderer.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport log from \"../../utils/log.js\";\nconst NO_PICKED_OBJECT = {\n    pickedColor: null,\n    pickedObjectIndex: -1\n};\n/* eslint-disable max-depth, max-statements */\n/**\n * Pick at a specified pixel with a tolerance radius\n * Returns the closest object to the pixel in shape `{pickedColor, pickedLayer, pickedObjectIndex}`\n */\nexport function getClosestObject({ pickedColors, decodePickingColor, deviceX, deviceY, deviceRadius, deviceRect }) {\n    // Traverse all pixels in picking results and find the one closest to the supplied\n    // [deviceX, deviceY]\n    const { x, y, width, height } = deviceRect;\n    let minSquareDistanceToCenter = deviceRadius * deviceRadius;\n    let closestPixelIndex = -1;\n    let i = 0;\n    for (let row = 0; row < height; row++) {\n        const dy = row + y - deviceY;\n        const dy2 = dy * dy;\n        if (dy2 > minSquareDistanceToCenter) {\n            // skip this row\n            i += 4 * width;\n        }\n        else {\n            for (let col = 0; col < width; col++) {\n                // Decode picked layer from color\n                const pickedLayerIndex = pickedColors[i + 3] - 1;\n                if (pickedLayerIndex >= 0) {\n                    const dx = col + x - deviceX;\n                    const d2 = dx * dx + dy2;\n                    if (d2 <= minSquareDistanceToCenter) {\n                        minSquareDistanceToCenter = d2;\n                        closestPixelIndex = i;\n                    }\n                }\n                i += 4;\n            }\n        }\n    }\n    if (closestPixelIndex >= 0) {\n        // Decode picked object index from color\n        const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);\n        const pickedObject = decodePickingColor(pickedColor);\n        if (pickedObject) {\n            const dy = Math.floor(closestPixelIndex / 4 / width);\n            const dx = closestPixelIndex / 4 - dy * width;\n            return {\n                ...pickedObject,\n                pickedColor,\n                pickedX: x + dx,\n                pickedY: y + dy\n            };\n        }\n        log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n    }\n    return NO_PICKED_OBJECT;\n}\n/**\n * Examines a picking buffer for unique colors\n * Returns array of unique objects in shape `{x, y, pickedColor, pickedLayer, pickedObjectIndex}`\n */\nexport function getUniqueObjects({ pickedColors, decodePickingColor }) {\n    const uniqueColors = new Map();\n    // Traverse all pixels in picking results and get unique colors\n    if (pickedColors) {\n        for (let i = 0; i < pickedColors.length; i += 4) {\n            // Decode picked layer from color\n            const pickedLayerIndex = pickedColors[i + 3] - 1;\n            if (pickedLayerIndex >= 0) {\n                const pickedColor = pickedColors.slice(i, i + 4);\n                const colorKey = pickedColor.join(',');\n                // eslint-disable-next-line\n                if (!uniqueColors.has(colorKey)) {\n                    const pickedObject = decodePickingColor(pickedColor);\n                    // eslint-disable-next-line\n                    if (pickedObject) {\n                        uniqueColors.set(colorKey, {\n                            ...pickedObject,\n                            color: pickedColor\n                        });\n                    }\n                    else {\n                        log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n                    }\n                }\n            }\n        }\n    }\n    return Array.from(uniqueColors.values());\n}\n//# sourceMappingURL=query-object.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/** Generates some basic information of the picking action: x, y, coordinates etc.\n * Regardless if anything is picked\n */\nexport function getEmptyPickingInfo({ pickInfo, viewports, pixelRatio, x, y, z }) {\n    // If more than one viewports are used in the picking pass, locate the viewport that\n    // drew the picked pixel\n    let pickedViewport = viewports[0];\n    if (viewports.length > 1) {\n        // Find the viewport that contain the picked pixel\n        pickedViewport = getViewportFromCoordinates(pickInfo?.pickedViewports || viewports, { x, y });\n    }\n    let coordinate;\n    if (pickedViewport) {\n        const point = [x - pickedViewport.x, y - pickedViewport.y];\n        if (z !== undefined) {\n            point[2] = z;\n        }\n        coordinate = pickedViewport.unproject(point);\n    }\n    return {\n        color: null,\n        layer: null,\n        viewport: pickedViewport,\n        index: -1,\n        picked: false,\n        x,\n        y,\n        pixel: [x, y],\n        coordinate,\n        devicePixel: pickInfo && 'pickedX' in pickInfo\n            ? [pickInfo.pickedX, pickInfo.pickedY]\n            : undefined,\n        pixelRatio\n    };\n}\n/* eslint-disable max-depth */\n/** Generates the picking info of a picking operation */\nexport function processPickInfo(opts) {\n    const { pickInfo, lastPickedInfo, mode, layers } = opts;\n    const { pickedColor, pickedLayer, pickedObjectIndex } = pickInfo;\n    const affectedLayers = pickedLayer ? [pickedLayer] : [];\n    if (mode === 'hover') {\n        // only invoke onHover events if picked object has changed\n        const lastPickedPixelIndex = lastPickedInfo.index;\n        const lastPickedLayerId = lastPickedInfo.layerId;\n        const pickedLayerId = pickedLayer ? pickedLayer.props.id : null;\n        // proceed only if picked object changed\n        if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedPixelIndex) {\n            if (pickedLayerId !== lastPickedLayerId) {\n                // We cannot store a ref to lastPickedLayer in the context because\n                // the state of an outdated layer is no longer valid\n                // and the props may have changed\n                const lastPickedLayer = layers.find(layer => layer.props.id === lastPickedLayerId);\n                if (lastPickedLayer) {\n                    // Let leave event fire before enter event\n                    affectedLayers.unshift(lastPickedLayer);\n                }\n            }\n            // Update layer manager context\n            lastPickedInfo.layerId = pickedLayerId;\n            lastPickedInfo.index = pickedObjectIndex;\n            lastPickedInfo.info = null;\n        }\n    }\n    const baseInfo = getEmptyPickingInfo(opts);\n    // Use a Map to store all picking infos.\n    // The following two forEach loops are the result of\n    // https://github.com/visgl/deck.gl/issues/443\n    // Please be very careful when changing this pattern\n    const infos = new Map();\n    // Make sure infos always contain something even if no layer is affected\n    infos.set(null, baseInfo);\n    affectedLayers.forEach(layer => {\n        let info = { ...baseInfo };\n        if (layer === pickedLayer) {\n            info.color = pickedColor;\n            info.index = pickedObjectIndex;\n            info.picked = true;\n        }\n        info = getLayerPickingInfo({ layer, info, mode });\n        const rootLayer = info.layer;\n        if (layer === pickedLayer && mode === 'hover') {\n            lastPickedInfo.info = info;\n        }\n        // This guarantees that there will be only one copy of info for\n        // one composite layer\n        infos.set(rootLayer.id, info);\n        if (mode === 'hover') {\n            rootLayer.updateAutoHighlight(info);\n        }\n    });\n    return infos;\n}\n/** Walk up the layer composite chain to populate the info object */\nexport function getLayerPickingInfo({ layer, info, mode }) {\n    while (layer && info) {\n        // For a composite layer, sourceLayer will point to the sublayer\n        // where the event originates from.\n        // It provides additional context for the composite layer's\n        // getPickingInfo() method to populate the info object\n        const sourceLayer = info.layer || null;\n        info.sourceLayer = sourceLayer;\n        info.layer = layer;\n        // layer.pickLayer() function requires a non-null ```layer.state```\n        // object to function properly. So the layer referenced here\n        // must be the \"current\" layer, not an \"out-dated\" / \"invalidated\" layer\n        info = layer.getPickingInfo({ info, mode, sourceLayer });\n        layer = layer.parent;\n    }\n    return info;\n}\n/** Indentifies which viewport, if any corresponds to x and y\n   If multiple viewports contain the target pixel, last viewport drawn is returend\n   Returns first viewport if no match */\nfunction getViewportFromCoordinates(viewports, pixel) {\n    // find the last viewport that contains the pixel\n    for (let i = viewports.length - 1; i >= 0; i--) {\n        const viewport = viewports[i];\n        if (viewport.containsPixel(pixel)) {\n            return viewport;\n        }\n    }\n    return viewports[0];\n}\n//# sourceMappingURL=pick-info.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport PickLayersPass from \"../passes/pick-layers-pass.js\";\nimport { getClosestObject, getUniqueObjects } from \"./picking/query-object.js\";\nimport { processPickInfo, getLayerPickingInfo, getEmptyPickingInfo } from \"./picking/pick-info.js\";\n/** Manages picking in a Deck context */\nexport default class DeckPicker {\n    constructor(device) {\n        this._pickable = true;\n        this.device = device;\n        this.pickLayersPass = new PickLayersPass(device);\n        this.lastPickedInfo = {\n            index: -1,\n            layerId: null,\n            info: null\n        };\n    }\n    setProps(props) {\n        if ('layerFilter' in props) {\n            this.layerFilter = props.layerFilter;\n        }\n        if ('_pickable' in props) {\n            this._pickable = props._pickable;\n        }\n    }\n    finalize() {\n        if (this.pickingFBO) {\n            this.pickingFBO.destroy();\n        }\n        if (this.depthFBO) {\n            this.depthFBO.destroy();\n        }\n    }\n    /**\n     * Pick the closest info at given coordinate\n     * @returns Promise that resolves with picking info\n     */\n    pickObjectAsync(opts) {\n        return this._pickClosestObjectAsync(opts);\n    }\n    /**\n     * Picks a list of unique infos within a bounding box\n     * @returns Promise that resolves to all unique infos within a bounding box\n     */\n    pickObjectsAsync(opts) {\n        return this._pickVisibleObjectsAsync(opts);\n    }\n    /**\n     * Pick the closest info at given coordinate\n     * @returns picking info\n     * @deprecated WebGL only - use pickObjectAsync instead\n     */\n    pickObject(opts) {\n        return this._pickClosestObject(opts);\n    }\n    /**\n     * Get all unique infos within a bounding box\n     * @returns all unique infos within a bounding box\n     * @deprecated WebGL only - use pickObjectAsync instead\n     */\n    pickObjects(opts) {\n        return this._pickVisibleObjects(opts);\n    }\n    // Returns a new picking info object by assuming the last picked object is still picked\n    getLastPickedObject({ x, y, layers, viewports }, lastPickedInfo = this.lastPickedInfo.info) {\n        const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;\n        const lastPickedViewportId = lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;\n        const layer = lastPickedLayerId ? layers.find(l => l.id === lastPickedLayerId) : null;\n        const viewport = (lastPickedViewportId && viewports.find(v => v.id === lastPickedViewportId)) || viewports[0];\n        const coordinate = viewport && viewport.unproject([x - viewport.x, y - viewport.y]);\n        const info = {\n            x,\n            y,\n            viewport,\n            coordinate,\n            layer\n        };\n        return { ...lastPickedInfo, ...info };\n    }\n    // Private\n    /** Ensures that picking framebuffer exists and matches the canvas size */\n    _resizeBuffer() {\n        // Create a frame buffer if not already available\n        if (!this.pickingFBO) {\n            this.pickingFBO = this.device.createFramebuffer({\n                colorAttachments: ['rgba8unorm'],\n                depthStencilAttachment: 'depth16unorm'\n            });\n            if (this.device.isTextureFormatRenderable('rgba32float')) {\n                const depthFBO = this.device.createFramebuffer({\n                    colorAttachments: ['rgba32float'],\n                    depthStencilAttachment: 'depth16unorm'\n                });\n                this.depthFBO = depthFBO;\n            }\n        }\n        // Resize it to current canvas size (this is a noop if size hasn't changed)\n        const { canvas } = this.device.getDefaultCanvasContext();\n        this.pickingFBO?.resize({ width: canvas.width, height: canvas.height });\n        this.depthFBO?.resize({ width: canvas.width, height: canvas.height });\n    }\n    /** Preliminary filtering of the layers list. Skid picking pass if no layer is pickable. */\n    _getPickable(layers) {\n        if (this._pickable === false) {\n            return null;\n        }\n        const pickableLayers = layers.filter(layer => this.pickLayersPass.shouldDrawLayer(layer) && !layer.isComposite);\n        return pickableLayers.length ? pickableLayers : null;\n    }\n    /**\n     * Pick the closest object at the given coordinate\n     */\n    // eslint-disable-next-line max-statements,complexity\n    async _pickClosestObjectAsync({ layers, views, viewports, x, y, radius = 0, depth = 1, mode = 'query', unproject3D, onViewportActive, effects }) {\n        // @ts-expect-error TODO - assuming WebGL context\n        const pixelRatio = this.device.canvasContext.cssToDeviceRatio();\n        const pickableLayers = this._getPickable(layers);\n        if (!pickableLayers || viewports.length === 0) {\n            return {\n                result: [],\n                emptyInfo: getEmptyPickingInfo({ viewports, x, y, pixelRatio })\n            };\n        }\n        this._resizeBuffer();\n        // Convert from canvas top-left to WebGL bottom-left coordinates\n        // Top-left coordinates [x, y] to bottom-left coordinates [deviceX, deviceY]\n        // And compensate for pixelRatio\n        // @ts-expect-error TODO - assuming WebGL context\n        const devicePixelRange = this.device.canvasContext.cssToDevicePixels([x, y], true);\n        const devicePixel = [\n            devicePixelRange.x + Math.floor(devicePixelRange.width / 2),\n            devicePixelRange.y + Math.floor(devicePixelRange.height / 2)\n        ];\n        const deviceRadius = Math.round(radius * pixelRatio);\n        const { width, height } = this.pickingFBO;\n        const deviceRect = this._getPickingRect({\n            deviceX: devicePixel[0],\n            deviceY: devicePixel[1],\n            deviceRadius,\n            deviceWidth: width,\n            deviceHeight: height\n        });\n        const cullRect = {\n            x: x - radius,\n            y: y - radius,\n            width: radius * 2 + 1,\n            height: radius * 2 + 1\n        };\n        let infos;\n        const result = [];\n        const affectedLayers = new Set();\n        for (let i = 0; i < depth; i++) {\n            let pickInfo;\n            if (deviceRect) {\n                const pickedResult = this._drawAndSample({\n                    layers: pickableLayers,\n                    views,\n                    viewports,\n                    onViewportActive,\n                    deviceRect,\n                    cullRect,\n                    effects,\n                    pass: `picking:${mode}`\n                });\n                pickInfo = getClosestObject({\n                    ...pickedResult,\n                    deviceX: devicePixel[0],\n                    deviceY: devicePixel[1],\n                    deviceRadius,\n                    deviceRect\n                });\n            }\n            else {\n                pickInfo = {\n                    pickedColor: null,\n                    pickedObjectIndex: -1\n                };\n            }\n            let z;\n            if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {\n                const { pickedColors: pickedColors2 } = this._drawAndSample({\n                    layers: [pickInfo.pickedLayer],\n                    views,\n                    viewports,\n                    onViewportActive,\n                    deviceRect: {\n                        x: pickInfo.pickedX,\n                        y: pickInfo.pickedY,\n                        width: 1,\n                        height: 1\n                    },\n                    cullRect,\n                    effects,\n                    pass: `picking:${mode}:z`\n                }, true);\n                // picked value is in common space (pixels) from the camera target (viewport.position)\n                // convert it to meters from the ground\n                if (pickedColors2[3]) {\n                    z = pickedColors2[0];\n                }\n            }\n            // Only exclude if we need to run picking again.\n            // We need to run picking again if an object is detected AND\n            // we have not exhausted the requested depth.\n            if (pickInfo.pickedLayer && i + 1 < depth) {\n                affectedLayers.add(pickInfo.pickedLayer);\n                pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);\n            }\n            // This logic needs to run even if no object is picked.\n            infos = processPickInfo({\n                pickInfo,\n                lastPickedInfo: this.lastPickedInfo,\n                mode,\n                layers: pickableLayers,\n                viewports,\n                x,\n                y,\n                z,\n                pixelRatio\n            });\n            for (const info of infos.values()) {\n                if (info.layer) {\n                    result.push(info);\n                }\n            }\n            // If no object is picked stop.\n            if (!pickInfo.pickedColor) {\n                break;\n            }\n        }\n        // reset only affected buffers\n        for (const layer of affectedLayers) {\n            layer.restorePickingColors();\n        }\n        return { result, emptyInfo: infos.get(null) };\n    }\n    /**\n     * Pick the closest object at the given coordinate\n     * @deprecated WebGL only\n     */\n    // eslint-disable-next-line max-statements,complexity\n    _pickClosestObject({ layers, views, viewports, x, y, radius = 0, depth = 1, mode = 'query', unproject3D, onViewportActive, effects }) {\n        // @ts-expect-error TODO - assuming WebGL context\n        const pixelRatio = this.device.canvasContext.cssToDeviceRatio();\n        const pickableLayers = this._getPickable(layers);\n        if (!pickableLayers || viewports.length === 0) {\n            return {\n                result: [],\n                emptyInfo: getEmptyPickingInfo({ viewports, x, y, pixelRatio })\n            };\n        }\n        this._resizeBuffer();\n        // Convert from canvas top-left to WebGL bottom-left coordinates\n        // Top-left coordinates [x, y] to bottom-left coordinates [deviceX, deviceY]\n        // And compensate for pixelRatio\n        // @ts-expect-error TODO - assuming WebGL context\n        const devicePixelRange = this.device.canvasContext.cssToDevicePixels([x, y], true);\n        const devicePixel = [\n            devicePixelRange.x + Math.floor(devicePixelRange.width / 2),\n            devicePixelRange.y + Math.floor(devicePixelRange.height / 2)\n        ];\n        const deviceRadius = Math.round(radius * pixelRatio);\n        const { width, height } = this.pickingFBO;\n        const deviceRect = this._getPickingRect({\n            deviceX: devicePixel[0],\n            deviceY: devicePixel[1],\n            deviceRadius,\n            deviceWidth: width,\n            deviceHeight: height\n        });\n        const cullRect = {\n            x: x - radius,\n            y: y - radius,\n            width: radius * 2 + 1,\n            height: radius * 2 + 1\n        };\n        let infos;\n        const result = [];\n        const affectedLayers = new Set();\n        for (let i = 0; i < depth; i++) {\n            let pickInfo;\n            if (deviceRect) {\n                const pickedResult = this._drawAndSample({\n                    layers: pickableLayers,\n                    views,\n                    viewports,\n                    onViewportActive,\n                    deviceRect,\n                    cullRect,\n                    effects,\n                    pass: `picking:${mode}`\n                });\n                pickInfo = getClosestObject({\n                    ...pickedResult,\n                    deviceX: devicePixel[0],\n                    deviceY: devicePixel[1],\n                    deviceRadius,\n                    deviceRect\n                });\n            }\n            else {\n                pickInfo = {\n                    pickedColor: null,\n                    pickedObjectIndex: -1\n                };\n            }\n            let z;\n            if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {\n                const { pickedColors: pickedColors2 } = this._drawAndSample({\n                    layers: [pickInfo.pickedLayer],\n                    views,\n                    viewports,\n                    onViewportActive,\n                    deviceRect: {\n                        x: pickInfo.pickedX,\n                        y: pickInfo.pickedY,\n                        width: 1,\n                        height: 1\n                    },\n                    cullRect,\n                    effects,\n                    pass: `picking:${mode}:z`\n                }, true);\n                // picked value is in common space (pixels) from the camera target (viewport.position)\n                // convert it to meters from the ground\n                if (pickedColors2[3]) {\n                    z = pickedColors2[0];\n                }\n            }\n            // Only exclude if we need to run picking again.\n            // We need to run picking again if an object is detected AND\n            // we have not exhausted the requested depth.\n            if (pickInfo.pickedLayer && i + 1 < depth) {\n                affectedLayers.add(pickInfo.pickedLayer);\n                pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);\n            }\n            // This logic needs to run even if no object is picked.\n            infos = processPickInfo({\n                pickInfo,\n                lastPickedInfo: this.lastPickedInfo,\n                mode,\n                layers: pickableLayers,\n                viewports,\n                x,\n                y,\n                z,\n                pixelRatio\n            });\n            for (const info of infos.values()) {\n                if (info.layer) {\n                    result.push(info);\n                }\n            }\n            // If no object is picked stop.\n            if (!pickInfo.pickedColor) {\n                break;\n            }\n        }\n        // reset only affected buffers\n        for (const layer of affectedLayers) {\n            layer.restorePickingColors();\n        }\n        return { result, emptyInfo: infos.get(null) };\n    }\n    /**\n     * Pick all objects within the given bounding box\n     */\n    // eslint-disable-next-line max-statements\n    async _pickVisibleObjectsAsync({ layers, views, viewports, x, y, width = 1, height = 1, mode = 'query', maxObjects = null, onViewportActive, effects }) {\n        const pickableLayers = this._getPickable(layers);\n        if (!pickableLayers || viewports.length === 0) {\n            return [];\n        }\n        this._resizeBuffer();\n        // Convert from canvas top-left to WebGL bottom-left coordinates\n        // And compensate for pixelRatio\n        // @ts-expect-error TODO - assuming WebGL context\n        const pixelRatio = this.device.canvasContext.cssToDeviceRatio();\n        // @ts-expect-error TODO - assuming WebGL context\n        const leftTop = this.device.canvasContext.cssToDevicePixels([x, y], true);\n        // take left and top (y inverted in device pixels) from start location\n        const deviceLeft = leftTop.x;\n        const deviceTop = leftTop.y + leftTop.height;\n        // take right and bottom (y inverted in device pixels) from end location\n        // @ts-expect-error TODO - assuming WebGL context\n        const rightBottom = this.device.canvasContext.cssToDevicePixels([x + width, y + height], true);\n        const deviceRight = rightBottom.x + rightBottom.width;\n        const deviceBottom = rightBottom.y;\n        const deviceRect = {\n            x: deviceLeft,\n            y: deviceBottom,\n            // deviceTop and deviceRight represent the first pixel outside the desired rect\n            width: deviceRight - deviceLeft,\n            height: deviceTop - deviceBottom\n        };\n        const pickedResult = this._drawAndSample({\n            layers: pickableLayers,\n            views,\n            viewports,\n            onViewportActive,\n            deviceRect,\n            cullRect: { x, y, width, height },\n            effects,\n            pass: `picking:${mode}`\n        });\n        const pickInfos = getUniqueObjects(pickedResult);\n        // `getUniqueObjects` dedup by picked color\n        // However different picked color may be linked to the same picked object, e.g. stroke and fill of the same polygon\n        // picked from different sub layers of a GeoJsonLayer\n        // Here after resolving the picked index with `layer.getPickingInfo`, we need to dedup again by unique picked objects\n        const uniquePickedObjects = new Map();\n        const uniqueInfos = [];\n        const limitMaxObjects = Number.isFinite(maxObjects);\n        for (let i = 0; i < pickInfos.length; i++) {\n            if (limitMaxObjects && uniqueInfos.length >= maxObjects) {\n                break;\n            }\n            const pickInfo = pickInfos[i];\n            let info = {\n                color: pickInfo.pickedColor,\n                layer: null,\n                index: pickInfo.pickedObjectIndex,\n                picked: true,\n                x,\n                y,\n                pixelRatio\n            };\n            info = getLayerPickingInfo({ layer: pickInfo.pickedLayer, info, mode });\n            // info.layer is always populated because it's a picked pixel\n            const pickedLayerId = info.layer.id;\n            if (!uniquePickedObjects.has(pickedLayerId)) {\n                uniquePickedObjects.set(pickedLayerId, new Set());\n            }\n            const uniqueObjectsInLayer = uniquePickedObjects.get(pickedLayerId);\n            // info.object may be null if the layer is using non-iterable data.\n            // Fall back to using index as identifier.\n            const pickedObjectKey = info.object ?? info.index;\n            if (!uniqueObjectsInLayer.has(pickedObjectKey)) {\n                uniqueObjectsInLayer.add(pickedObjectKey);\n                uniqueInfos.push(info);\n            }\n        }\n        return uniqueInfos;\n    }\n    /**\n     * Pick all objects within the given bounding box\n     * @deprecated WebGL only\n     */\n    // eslint-disable-next-line max-statements\n    _pickVisibleObjects({ layers, views, viewports, x, y, width = 1, height = 1, mode = 'query', maxObjects = null, onViewportActive, effects }) {\n        const pickableLayers = this._getPickable(layers);\n        if (!pickableLayers || viewports.length === 0) {\n            return [];\n        }\n        this._resizeBuffer();\n        // Convert from canvas top-left to WebGL bottom-left coordinates\n        // And compensate for pixelRatio\n        // @ts-expect-error TODO - assuming WebGL context\n        const pixelRatio = this.device.canvasContext.cssToDeviceRatio();\n        // @ts-expect-error TODO - assuming WebGL context\n        const leftTop = this.device.canvasContext.cssToDevicePixels([x, y], true);\n        // take left and top (y inverted in device pixels) from start location\n        const deviceLeft = leftTop.x;\n        const deviceTop = leftTop.y + leftTop.height;\n        // take right and bottom (y inverted in device pixels) from end location\n        // @ts-expect-error TODO - assuming WebGL context\n        const rightBottom = this.device.canvasContext.cssToDevicePixels([x + width, y + height], true);\n        const deviceRight = rightBottom.x + rightBottom.width;\n        const deviceBottom = rightBottom.y;\n        const deviceRect = {\n            x: deviceLeft,\n            y: deviceBottom,\n            // deviceTop and deviceRight represent the first pixel outside the desired rect\n            width: deviceRight - deviceLeft,\n            height: deviceTop - deviceBottom\n        };\n        const pickedResult = this._drawAndSample({\n            layers: pickableLayers,\n            views,\n            viewports,\n            onViewportActive,\n            deviceRect,\n            cullRect: { x, y, width, height },\n            effects,\n            pass: `picking:${mode}`\n        });\n        const pickInfos = getUniqueObjects(pickedResult);\n        // `getUniqueObjects` dedup by picked color\n        // However different picked color may be linked to the same picked object, e.g. stroke and fill of the same polygon\n        // picked from different sub layers of a GeoJsonLayer\n        // Here after resolving the picked index with `layer.getPickingInfo`, we need to dedup again by unique picked objects\n        const uniquePickedObjects = new Map();\n        const uniqueInfos = [];\n        const limitMaxObjects = Number.isFinite(maxObjects);\n        for (let i = 0; i < pickInfos.length; i++) {\n            if (limitMaxObjects && uniqueInfos.length >= maxObjects) {\n                break;\n            }\n            const pickInfo = pickInfos[i];\n            let info = {\n                color: pickInfo.pickedColor,\n                layer: null,\n                index: pickInfo.pickedObjectIndex,\n                picked: true,\n                x,\n                y,\n                pixelRatio\n            };\n            info = getLayerPickingInfo({ layer: pickInfo.pickedLayer, info, mode });\n            // info.layer is always populated because it's a picked pixel\n            const pickedLayerId = info.layer.id;\n            if (!uniquePickedObjects.has(pickedLayerId)) {\n                uniquePickedObjects.set(pickedLayerId, new Set());\n            }\n            const uniqueObjectsInLayer = uniquePickedObjects.get(pickedLayerId);\n            // info.object may be null if the layer is using non-iterable data.\n            // Fall back to using index as identifier.\n            const pickedObjectKey = info.object ?? info.index;\n            if (!uniqueObjectsInLayer.has(pickedObjectKey)) {\n                uniqueObjectsInLayer.add(pickedObjectKey);\n                uniqueInfos.push(info);\n            }\n        }\n        return uniqueInfos;\n    }\n    // Note: Implementation of the overloaded signatures above, TSDoc is on the signatures\n    async _drawAndSampleAsync({ layers, views, viewports, onViewportActive, deviceRect, cullRect, effects, pass }, pickZ = false) {\n        const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;\n        const opts = {\n            layers,\n            layerFilter: this.layerFilter,\n            views,\n            viewports,\n            onViewportActive,\n            pickingFBO,\n            deviceRect,\n            cullRect,\n            effects,\n            pass,\n            pickZ,\n            preRenderStats: {},\n            isPicking: true\n        };\n        for (const effect of effects) {\n            if (effect.useInPicking) {\n                opts.preRenderStats[effect.id] = effect.preRender(opts);\n            }\n        }\n        const { decodePickingColor } = this.pickLayersPass.render(opts);\n        // Read from an already rendered picking buffer\n        // Returns an Uint8ClampedArray of picked pixels\n        const { x, y, width, height } = deviceRect;\n        const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);\n        this.device.readPixelsToArrayWebGL(pickingFBO, {\n            sourceX: x,\n            sourceY: y,\n            sourceWidth: width,\n            sourceHeight: height,\n            target: pickedColors\n        });\n        return { pickedColors, decodePickingColor };\n    }\n    // Note: Implementation of the overloaded signatures above, TSDoc is on the signatures\n    _drawAndSample({ layers, views, viewports, onViewportActive, deviceRect, cullRect, effects, pass }, pickZ = false) {\n        const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;\n        const opts = {\n            layers,\n            layerFilter: this.layerFilter,\n            views,\n            viewports,\n            onViewportActive,\n            pickingFBO,\n            deviceRect,\n            cullRect,\n            effects,\n            pass,\n            pickZ,\n            preRenderStats: {},\n            isPicking: true\n        };\n        for (const effect of effects) {\n            if (effect.useInPicking) {\n                opts.preRenderStats[effect.id] = effect.preRender(opts);\n            }\n        }\n        const { decodePickingColor } = this.pickLayersPass.render(opts);\n        // Read from an already rendered picking buffer\n        // Returns an Uint8ClampedArray of picked pixels\n        const { x, y, width, height } = deviceRect;\n        const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);\n        this.device.readPixelsToArrayWebGL(pickingFBO, {\n            sourceX: x,\n            sourceY: y,\n            sourceWidth: width,\n            sourceHeight: height,\n            target: pickedColors\n        });\n        return { pickedColors, decodePickingColor };\n    }\n    /**\n     * Calculate a picking rect centered on deviceX and deviceY and clipped to device\n     * @returns null if pixel is outside of device\n     */\n    _getPickingRect({ deviceX, deviceY, deviceRadius, deviceWidth, deviceHeight }) {\n        // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]\n        const x = Math.max(0, deviceX - deviceRadius);\n        const y = Math.max(0, deviceY - deviceRadius);\n        const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;\n        const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;\n        // x, y out of bounds.\n        if (width <= 0 || height <= 0) {\n            return null;\n        }\n        return { x, y, width, height };\n    }\n}\n//# sourceMappingURL=deck-picker.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { EVENT_HANDLERS } from \"./constants.js\";\nimport { deepEqual } from \"../utils/deep-equal.js\";\nconst PLACEMENTS = {\n    'top-left': { top: 0, left: 0 },\n    'top-right': { top: 0, right: 0 },\n    'bottom-left': { bottom: 0, left: 0 },\n    'bottom-right': { bottom: 0, right: 0 },\n    fill: { top: 0, left: 0, bottom: 0, right: 0 }\n};\nconst DEFAULT_PLACEMENT = 'top-left';\nconst ROOT_CONTAINER_ID = 'root';\nexport class WidgetManager {\n    constructor({ deck, parentElement }) {\n        /** Widgets added via the imperative API */\n        this.defaultWidgets = [];\n        /** Widgets received from the declarative API */\n        this.widgets = [];\n        /** Resolved widgets from both imperative and declarative APIs */\n        this.resolvedWidgets = [];\n        /** Mounted HTML containers */\n        this.containers = {};\n        /** Viewport provided to widget on redraw */\n        this.lastViewports = {};\n        this.deck = deck;\n        parentElement?.classList.add('deck-widget-container');\n        this.parentElement = parentElement;\n    }\n    getWidgets() {\n        return this.resolvedWidgets;\n    }\n    /** Declarative API to configure widgets */\n    setProps(props) {\n        if (props.widgets && !deepEqual(props.widgets, this.widgets, 1)) {\n            // Allow application to supply null widgets\n            const nextWidgets = props.widgets.filter(Boolean);\n            this._setWidgets(nextWidgets);\n        }\n    }\n    finalize() {\n        for (const widget of this.getWidgets()) {\n            this._removeWidget(widget);\n        }\n        this.defaultWidgets.length = 0;\n        this.resolvedWidgets.length = 0;\n        for (const id in this.containers) {\n            this.containers[id].remove();\n        }\n    }\n    /** Imperative API. Widgets added this way are not affected by the declarative prop. */\n    addDefault(widget) {\n        if (!this.defaultWidgets.find(w => w.id === widget.id)) {\n            this._addWidget(widget);\n            this.defaultWidgets.push(widget);\n            // Update widget list\n            this._setWidgets(this.widgets);\n        }\n    }\n    onRedraw({ viewports, layers }) {\n        const viewportsById = viewports.reduce((acc, v) => {\n            acc[v.id] = v;\n            return acc;\n        }, {});\n        for (const widget of this.getWidgets()) {\n            const { viewId } = widget;\n            if (viewId) {\n                // Attached to a specific view\n                const viewport = viewportsById[viewId];\n                if (viewport) {\n                    if (widget.onViewportChange) {\n                        widget.onViewportChange(viewport);\n                    }\n                    widget.onRedraw?.({ viewports: [viewport], layers });\n                }\n            }\n            else {\n                // Not attached to a specific view\n                if (widget.onViewportChange) {\n                    for (const viewport of viewports) {\n                        widget.onViewportChange(viewport);\n                    }\n                }\n                widget.onRedraw?.({ viewports, layers });\n            }\n        }\n        this.lastViewports = viewportsById;\n        this._updateContainers();\n    }\n    onHover(info, event) {\n        for (const widget of this.getWidgets()) {\n            const { viewId } = widget;\n            if (!viewId || viewId === info.viewport?.id) {\n                widget.onHover?.(info, event);\n            }\n        }\n    }\n    onEvent(info, event) {\n        const eventHandlerProp = EVENT_HANDLERS[event.type];\n        if (!eventHandlerProp) {\n            return;\n        }\n        for (const widget of this.getWidgets()) {\n            const { viewId } = widget;\n            if (!viewId || viewId === info.viewport?.id) {\n                widget[eventHandlerProp]?.(info, event);\n            }\n        }\n    }\n    // INTERNAL METHODS\n    /**\n     * Resolve widgets from the declarative prop\n     * Initialize new widgets and remove old ones\n     * Update props of existing widgets\n     */\n    _setWidgets(nextWidgets) {\n        const oldWidgetMap = {};\n        for (const widget of this.resolvedWidgets) {\n            oldWidgetMap[widget.id] = widget;\n        }\n        // Clear and rebuild the list\n        this.resolvedWidgets.length = 0;\n        // Add all default widgets\n        for (const widget of this.defaultWidgets) {\n            oldWidgetMap[widget.id] = null;\n            this.resolvedWidgets.push(widget);\n        }\n        for (let widget of nextWidgets) {\n            const oldWidget = oldWidgetMap[widget.id];\n            if (!oldWidget) {\n                // Widget is new\n                this._addWidget(widget);\n            }\n            else if (\n            // Widget placement changed\n            oldWidget.viewId !== widget.viewId ||\n                oldWidget.placement !== widget.placement) {\n                this._removeWidget(oldWidget);\n                this._addWidget(widget);\n            }\n            else if (widget !== oldWidget) {\n                // Widget props changed\n                oldWidget.setProps(widget.props);\n                widget = oldWidget;\n            }\n            // mark as matched\n            oldWidgetMap[widget.id] = null;\n            this.resolvedWidgets.push(widget);\n        }\n        for (const id in oldWidgetMap) {\n            const oldWidget = oldWidgetMap[id];\n            if (oldWidget) {\n                // No longer exists\n                this._removeWidget(oldWidget);\n            }\n        }\n        this.widgets = nextWidgets;\n    }\n    /** Initialize new widget */\n    _addWidget(widget) {\n        const { viewId = null, placement = DEFAULT_PLACEMENT } = widget;\n        const container = widget.props._container ?? viewId;\n        widget.widgetManager = this;\n        widget.deck = this.deck;\n        // Create an attach the HTML root element\n        widget.rootElement = widget._onAdd({ deck: this.deck, viewId });\n        if (widget.rootElement) {\n            this._getContainer(container, placement).append(widget.rootElement);\n        }\n        widget.updateHTML();\n    }\n    /** Destroy an old widget */\n    _removeWidget(widget) {\n        widget.onRemove?.();\n        if (widget.rootElement) {\n            widget.rootElement.remove();\n        }\n        widget.rootElement = undefined;\n        widget.deck = undefined;\n        widget.widgetManager = undefined;\n    }\n    /** Get a container element based on view and placement */\n    _getContainer(viewIdOrContainer, placement) {\n        if (viewIdOrContainer && typeof viewIdOrContainer !== 'string') {\n            return viewIdOrContainer;\n        }\n        const containerId = viewIdOrContainer || ROOT_CONTAINER_ID;\n        let viewContainer = this.containers[containerId];\n        if (!viewContainer) {\n            viewContainer = document.createElement('div');\n            viewContainer.style.pointerEvents = 'none';\n            viewContainer.style.position = 'absolute';\n            viewContainer.style.overflow = 'hidden';\n            this.parentElement?.append(viewContainer);\n            this.containers[containerId] = viewContainer;\n        }\n        let container = viewContainer.querySelector(`.${placement}`);\n        if (!container) {\n            container = globalThis.document.createElement('div');\n            container.className = placement;\n            container.style.position = 'absolute';\n            container.style.zIndex = '2';\n            Object.assign(container.style, PLACEMENTS[placement]);\n            viewContainer.append(container);\n        }\n        return container;\n    }\n    _updateContainers() {\n        const canvasWidth = this.deck.width;\n        const canvasHeight = this.deck.height;\n        for (const id in this.containers) {\n            const viewport = this.lastViewports[id] || null;\n            const visible = id === ROOT_CONTAINER_ID || viewport;\n            const container = this.containers[id];\n            if (visible) {\n                container.style.display = 'block';\n                // Align the container with the view\n                container.style.left = `${viewport ? viewport.x : 0}px`;\n                container.style.top = `${viewport ? viewport.y : 0}px`;\n                container.style.width = `${viewport ? viewport.width : canvasWidth}px`;\n                container.style.height = `${viewport ? viewport.height : canvasHeight}px`;\n            }\n            else {\n                container.style.display = 'none';\n            }\n        }\n    }\n}\n//# sourceMappingURL=widget-manager.js.map","export function applyStyles(element, style) {\n    if (style) {\n        Object.entries(style).map(([key, value]) => {\n            if (key.startsWith('--')) {\n                // Assume CSS variable\n                element.style.setProperty(key, value);\n            }\n            else {\n                // Assume camelCase\n                element.style[key] = value;\n            }\n        });\n    }\n}\nexport function removeStyles(element, style) {\n    if (style) {\n        Object.keys(style).map(key => {\n            if (key.startsWith('--')) {\n                // Assume CSS variable\n                element.style.removeProperty(key);\n            }\n            else {\n                // Assume camelCase\n                element.style[key] = '';\n            }\n        });\n    }\n}\n//# sourceMappingURL=apply-styles.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { deepEqual } from \"../utils/deep-equal.js\";\nimport { applyStyles, removeStyles } from \"../utils/apply-styles.js\";\nexport class Widget {\n    constructor(props) {\n        /**\n         * The view id that this widget controls. Default `null`.\n         * If assigned, this widget will only respond to events occurred inside the specific view that matches this id.\n         */\n        this.viewId = null;\n        this.props = {\n            // @ts-expect-error `defaultProps` may not exist on constructor\n            ...this.constructor.defaultProps,\n            ...props\n        };\n        // @ts-expect-error TODO(ib) - why is id considered optional even though we use Required<>\n        this.id = this.props.id;\n    }\n    /** Called to update widget options */\n    setProps(props) {\n        const oldProps = this.props;\n        const el = this.rootElement;\n        // Update className and style\n        if (el && oldProps.className !== props.className) {\n            if (oldProps.className)\n                el.classList.remove(oldProps.className);\n            if (props.className)\n                el.classList.add(props.className);\n        }\n        // Update style\n        if (el && !deepEqual(oldProps.style, props.style, 1)) {\n            removeStyles(el, oldProps.style);\n            applyStyles(el, props.style);\n        }\n        Object.assign(this.props, props);\n        // Update the HTML to match the new props\n        this.updateHTML();\n    }\n    /** Update the HTML to reflect latest props and state */\n    updateHTML() {\n        if (this.rootElement) {\n            this.onRenderHTML(this.rootElement);\n        }\n    }\n    // @note empty method calls have an overhead in V8 but it is very low, ~1ns\n    /**\n     * Common utility to create the root DOM element for this widget\n     * Configures the top-level styles and adds basic class names for theming\n     * @returns an UI element that should be appended to the Deck container\n     */\n    onCreateRootElement() {\n        const CLASS_NAMES = [\n            // Add class names for theming\n            'deck-widget',\n            this.className,\n            // plus any app-supplied class name\n            this.props.className\n        ];\n        const element = document.createElement('div');\n        CLASS_NAMES.filter((cls) => typeof cls === 'string' && cls.length > 0).forEach(className => element.classList.add(className));\n        applyStyles(element, this.props.style);\n        return element;\n    }\n    /** Internal API called by Deck when the widget is first added to a Deck instance */\n    _onAdd(params) {\n        return this.onAdd(params) ?? this.onCreateRootElement();\n    }\n    /** Overridable by subclass - called when the widget is first added to a Deck instance\n     * @returns an optional UI element that should be appended to the Deck container\n     */\n    onAdd(params) { }\n    /** Called when the widget is removed */\n    onRemove() { }\n    // deck integration - Event hooks\n    /** Called when the containing view is changed */\n    onViewportChange(viewport) { }\n    /** Called when the containing view is redrawn */\n    onRedraw(params) { }\n    /** Called when a hover event occurs */\n    onHover(info, event) { }\n    /** Called when a click event occurs */\n    onClick(info, event) { }\n    /** Called when a drag event occurs */\n    onDrag(info, event) { }\n    /** Called when a dragstart event occurs */\n    onDragStart(info, event) { }\n    /** Called when a dragend event occurs */\n    onDragEnd(info, event) { }\n}\nWidget.defaultProps = {\n    id: 'widget',\n    style: {},\n    _container: null,\n    className: ''\n};\n//# sourceMappingURL=widget.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Widget } from \"./widget.js\";\n/* global document */\nconst defaultStyle = {\n    zIndex: '1',\n    position: 'absolute',\n    pointerEvents: 'none',\n    color: '#a0a7b4',\n    backgroundColor: '#29323c',\n    padding: '10px',\n    top: '0',\n    left: '0',\n    display: 'none'\n};\nexport class TooltipWidget extends Widget {\n    constructor(props = {}) {\n        super(props);\n        this.id = 'default-tooltip';\n        this.placement = 'fill';\n        this.className = 'deck-tooltip';\n        this.isVisible = false;\n        this.setProps(props);\n    }\n    // TODO(ib) - does this really need to be overridden?\n    onCreateRootElement() {\n        const el = document.createElement('div');\n        el.className = this.className;\n        Object.assign(el.style, defaultStyle);\n        return el;\n    }\n    onRenderHTML(rootElement) { }\n    onViewportChange(viewport) {\n        if (this.isVisible &&\n            viewport.id === this.lastViewport?.id &&\n            !viewport.equals(this.lastViewport)) {\n            // Camera has moved, clear tooltip\n            this.setTooltip(null);\n        }\n        // Always update lastViewport from the render loop to ensure consistent\n        // viewport source for comparisons (avoids mismatches with picking viewports)\n        this.lastViewport = viewport;\n    }\n    onHover(info) {\n        const { deck } = this;\n        const getTooltip = deck && deck.props.getTooltip;\n        if (!getTooltip) {\n            return;\n        }\n        const displayInfo = getTooltip(info);\n        this.setTooltip(displayInfo, info.x, info.y);\n    }\n    setTooltip(displayInfo, x, y) {\n        const el = this.rootElement;\n        if (!el) {\n            return;\n        }\n        if (typeof displayInfo === 'string') {\n            el.innerText = displayInfo;\n        }\n        else if (!displayInfo) {\n            this.isVisible = false;\n            el.style.display = 'none';\n            return;\n        }\n        else {\n            if (displayInfo.text) {\n                el.innerText = displayInfo.text;\n            }\n            if (displayInfo.html) {\n                el.innerHTML = displayInfo.html;\n            }\n            if (displayInfo.className) {\n                el.className = displayInfo.className;\n            }\n        }\n        this.isVisible = true;\n        el.style.display = 'block';\n        el.style.transform = `translate(${x}px, ${y}px)`;\n        if (displayInfo && typeof displayInfo === 'object' && 'style' in displayInfo) {\n            Object.assign(el.style, displayInfo.style);\n        }\n    }\n}\nTooltipWidget.defaultProps = {\n    ...Widget.defaultProps\n};\n//# sourceMappingURL=tooltip-widget.js.map","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Goal is to make WebGL2 contexts look like WebGL1\n// @note Partly inspired by with some older code from the `regl` library\n/* eslint-disable camelcase */\nimport { GL } from '@luma.gl/constants';\n// webgl1 extensions natively supported by webgl2\nconst WEBGL1_STATIC_EXTENSIONS = {\n    WEBGL_depth_texture: {\n        UNSIGNED_INT_24_8_WEBGL: 34042\n    },\n    OES_element_index_uint: {},\n    OES_texture_float: {},\n    OES_texture_half_float: {\n        // @ts-expect-error different numbers?\n        HALF_FLOAT_OES: 5131\n    },\n    EXT_color_buffer_float: {},\n    OES_standard_derivatives: {\n        FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 35723\n    },\n    EXT_frag_depth: {},\n    EXT_blend_minmax: {\n        MIN_EXT: 32775,\n        MAX_EXT: 32776\n    },\n    EXT_shader_texture_lod: {}\n};\nconst getWEBGL_draw_buffers = (gl) => ({\n    drawBuffersWEBGL(buffers) {\n        return gl.drawBuffers(buffers);\n    },\n    COLOR_ATTACHMENT0_WEBGL: 36064,\n    COLOR_ATTACHMENT1_WEBGL: 36065,\n    COLOR_ATTACHMENT2_WEBGL: 36066,\n    COLOR_ATTACHMENT3_WEBGL: 36067\n}); // - too many fields\nconst getOES_vertex_array_object = (gl) => ({\n    VERTEX_ARRAY_BINDING_OES: 34229,\n    createVertexArrayOES() {\n        return gl.createVertexArray();\n    },\n    deleteVertexArrayOES(vertexArray) {\n        return gl.deleteVertexArray(vertexArray);\n    },\n    isVertexArrayOES(vertexArray) {\n        return gl.isVertexArray(vertexArray);\n    },\n    bindVertexArrayOES(vertexArray) {\n        return gl.bindVertexArray(vertexArray);\n    }\n});\nconst getANGLE_instanced_arrays = (gl) => ({\n    VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 0x88fe,\n    drawArraysInstancedANGLE(...args) {\n        return gl.drawArraysInstanced(...args);\n    },\n    drawElementsInstancedANGLE(...args) {\n        return gl.drawElementsInstanced(...args);\n    },\n    vertexAttribDivisorANGLE(...args) {\n        return gl.vertexAttribDivisor(...args);\n    }\n});\n/**\n * Make browser return WebGL2 contexts even if WebGL1 contexts are requested\n * @param enforce\n * @returns\n */\nexport function enforceWebGL2(enforce = true) {\n    const prototype = HTMLCanvasElement.prototype;\n    if (!enforce && prototype.originalGetContext) {\n        // Reset the original getContext function\n        prototype.getContext = prototype.originalGetContext;\n        prototype.originalGetContext = undefined;\n        return;\n    }\n    // Store the original getContext function\n    prototype.originalGetContext = prototype.getContext;\n    // Override the getContext function\n    prototype.getContext = function (contextId, options) {\n        // Attempt to force WebGL2 for all WebGL1 contexts\n        if (contextId === 'webgl' || contextId === 'experimental-webgl') {\n            const context = this.originalGetContext('webgl2', options);\n            // Work around test mocking\n            if (context instanceof HTMLElement) {\n                polyfillWebGL1Extensions(context);\n            }\n            return context;\n        }\n        // For any other type, return the original context\n        return this.originalGetContext(contextId, options);\n    };\n}\n/** Install WebGL1-only extensions on WebGL2 contexts */\nexport function polyfillWebGL1Extensions(gl) {\n    // Enable, to support float and half-float textures\n    gl.getExtension('EXT_color_buffer_float');\n    // WebGL1 extensions implemented using WebGL2 APIs\n    const boundExtensions = {\n        ...WEBGL1_STATIC_EXTENSIONS,\n        WEBGL_disjoint_timer_query: gl.getExtension('EXT_disjoint_timer_query_webgl2'),\n        WEBGL_draw_buffers: getWEBGL_draw_buffers(gl),\n        OES_vertex_array_object: getOES_vertex_array_object(gl),\n        ANGLE_instanced_arrays: getANGLE_instanced_arrays(gl)\n    };\n    // Override gl.getExtension\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const originalGetExtension = gl.getExtension;\n    gl.getExtension = function (extensionName) {\n        const ext = originalGetExtension.call(gl, extensionName);\n        if (ext) {\n            return ext;\n        }\n        // Injected extensions\n        if (extensionName in boundExtensions) {\n            // @ts-ignore TODO string index\n            return boundExtensions[extensionName];\n        }\n        return null;\n    };\n    // Override gl.getSupportedExtensions\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const originalGetSupportedExtensions = gl.getSupportedExtensions;\n    gl.getSupportedExtensions = function () {\n        const extensions = originalGetSupportedExtensions.apply(gl) || [];\n        return extensions?.concat(Object.keys(boundExtensions));\n    };\n}\n// Update unsized WebGL1 formats to sized WebGL2 formats\n// todo move to texture format file\n// export function getInternalFormat(gl: WebGL2RenderingContext, format: GL, type: GL): GL {\n//   // webgl2 texture formats\n//   // https://webgl2fundamentals.org/webgl/lessons/webgl-data-textures.html\n//   switch (format) {\n//     case GL.DEPTH_COMPONENT:\n//       return GL.DEPTH_COMPONENT24;\n//     case GL.DEPTH_STENCIL:\n//       return GL.DEPTH24_STENCIL8;\n//     case GL.RGBA:\n//       return type === GL.HALF_FLOAT ? GL.RGBA16F : GL.RGBA32F;\n//     case GL.RGB:\n//       return type === GL.HALF_FLOAT ? GL.RGB16F : GL.RGB32F;\n//     default:\n//       return format;\n//   }\n// }\n/*\n// texture type to update on the fly\nexport function getTextureType(gl: WebGL2RenderingContext, type: GL): GL {\n  if (type === HALF_FLOAT_OES) {\n    return GL.HALF_FLOAT;\n  }\n  return type;\n}\n\n  // And texImage2D to convert the internalFormat to webgl2.\n  const webgl2 = this;\n  const origTexImage = gl.texImage2D;\n  gl.texImage2D = function (target, miplevel, iformat, a, typeFor6, c, d, typeFor9, f) {\n    if (arguments.length == 6) {\n      var ifmt = webgl2.getInternalFormat(gl, iformat, typeFor6);\n      origTexImage.apply(gl, [target, miplevel, ifmt, a, webgl.getTextureType(gl, typeFor6), c]);\n    } else {\n      // arguments.length == 9\n      var ifmt = webgl2.getInternalFormat(gl, iformat, typeFor9);\n      origTexImage.apply(gl, [\n        target,\n        miplevel,\n        ifmt,\n        a,\n        typeFor6,\n        c,\n        d,\n        webgl2.getTextureType(gl, typeFor9),\n        f\n      ]);\n    }\n  };\n};\n*/\n//# sourceMappingURL=polyfill-webgl1-extensions.js.map","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Adapter, Device, log } from '@luma.gl/core';\nimport { enforceWebGL2 } from \"../context/polyfills/polyfill-webgl1-extensions.js\";\nimport { loadSpectorJS, DEFAULT_SPECTOR_PROPS } from \"../context/debug/spector.js\";\nimport { loadWebGLDeveloperTools } from \"../context/debug/webgl-developer-tools.js\";\nconst LOG_LEVEL = 1;\nexport class WebGLAdapter extends Adapter {\n    /** type of device's created by this adapter */\n    type = 'webgl';\n    constructor() {\n        super();\n        // Add spector default props to device default props, so that runtime settings are observed\n        Device.defaultProps = { ...Device.defaultProps, ...DEFAULT_SPECTOR_PROPS };\n    }\n    /** Force any created WebGL contexts to be WebGL2 contexts, polyfilled with WebGL1 extensions */\n    enforceWebGL2(enable) {\n        enforceWebGL2(enable);\n    }\n    /** Check if WebGL 2 is available */\n    isSupported() {\n        return typeof WebGL2RenderingContext !== 'undefined';\n    }\n    isDeviceHandle(handle) {\n        // WebGL\n        if (typeof WebGL2RenderingContext !== 'undefined' && handle instanceof WebGL2RenderingContext) {\n            return true;\n        }\n        if (typeof WebGLRenderingContext !== 'undefined' && handle instanceof WebGLRenderingContext) {\n            log.warn('WebGL1 is not supported', handle)();\n        }\n        return false;\n    }\n    /**\n     * Get a device instance from a GL context\n     * Creates a WebGLCanvasContext against the contexts canvas\n     * @note autoResize will be disabled, assuming that whoever created the external context will be handling resizes.\n     * @param gl\n     * @returns\n     */\n    async attach(gl, props = {}) {\n        const { WebGLDevice } = await import(\"./webgl-device.js\");\n        if (gl instanceof WebGLDevice) {\n            return gl;\n        }\n        // @ts-expect-error\n        if (gl?.device instanceof WebGLDevice) {\n            // @ts-expect-error\n            return gl.device;\n        }\n        if (!isWebGL(gl)) {\n            throw new Error('Invalid WebGL2RenderingContext');\n        }\n        const createCanvasContext = props.createCanvasContext === true ? {} : props.createCanvasContext;\n        // We create a new device using the provided WebGL context and its canvas\n        // Assume that whoever created the external context will be handling resizes.\n        return new WebGLDevice({\n            ...props,\n            _handle: gl,\n            createCanvasContext: { canvas: gl.canvas, autoResize: false, ...createCanvasContext }\n        });\n    }\n    async create(props = {}) {\n        const { WebGLDevice } = await import(\"./webgl-device.js\");\n        log.groupCollapsed(LOG_LEVEL, 'WebGLDevice created')();\n        try {\n            const promises = [];\n            // Load webgl and spector debug scripts from CDN if requested\n            if (props.debugWebGL || props.debug) {\n                promises.push(loadWebGLDeveloperTools());\n            }\n            if (props.debugSpectorJS) {\n                promises.push(loadSpectorJS(props));\n            }\n            // Wait for all the loads to settle before creating the context.\n            // The Device.create() functions are async, so in contrast to the constructor, we can `await` here.\n            const results = await Promise.allSettled(promises);\n            for (const result of results) {\n                if (result.status === 'rejected') {\n                    log.error(`Failed to initialize debug libraries ${result.reason}`)();\n                }\n            }\n            const device = new WebGLDevice(props);\n            // Log some debug info about the newly created context\n            const message = `\\\n${device._reused ? 'Reusing' : 'Created'} device with WebGL2 ${device.props.debug ? 'debug ' : ''}context: \\\n${device.info.vendor}, ${device.info.renderer} for canvas: ${device.canvasContext.id}`;\n            log.probe(LOG_LEVEL, message)();\n            log.table(LOG_LEVEL, device.info)();\n            return device;\n        }\n        finally {\n            log.groupEnd(LOG_LEVEL)();\n        }\n    }\n}\n/** Check if supplied parameter is a WebGL2RenderingContext */\nfunction isWebGL(gl) {\n    if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {\n        return true;\n    }\n    // Look for debug contexts, headless gl etc\n    return Boolean(gl && Number.isFinite(gl._version));\n}\nexport const webgl2Adapter = new WebGLAdapter();\n//# sourceMappingURL=webgl-adapter.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport LayerManager from \"./layer-manager.js\";\nimport ViewManager from \"./view-manager.js\";\nimport MapView from \"../views/map-view.js\";\nimport EffectManager from \"./effect-manager.js\";\nimport DeckRenderer from \"./deck-renderer.js\";\nimport DeckPicker from \"./deck-picker.js\";\nimport { WidgetManager } from \"./widget-manager.js\";\nimport { TooltipWidget } from \"./tooltip-widget.js\";\nimport log from \"../utils/log.js\";\nimport { deepEqual } from \"../utils/deep-equal.js\";\nimport typedArrayManager from \"../utils/typed-array-manager.js\";\nimport { VERSION } from \"./init.js\";\nimport { luma } from '@luma.gl/core';\nimport { webgl2Adapter } from '@luma.gl/webgl';\nimport { Timeline } from '@luma.gl/engine';\nimport { AnimationLoop } from '@luma.gl/engine';\nimport { GL } from '@luma.gl/constants';\nimport { Stats } from '@probe.gl/stats';\nimport { EventManager } from 'mjolnir.js';\nimport assert from \"../utils/assert.js\";\nimport { EVENT_HANDLERS, RECOGNIZERS } from \"./constants.js\";\n/* global document */\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() { }\nconst getCursor = ({ isDragging }) => (isDragging ? 'grabbing' : 'grab');\nconst defaultProps = {\n    id: '',\n    width: '100%',\n    height: '100%',\n    style: null,\n    viewState: null,\n    initialViewState: null,\n    pickingRadius: 0,\n    layerFilter: null,\n    parameters: {},\n    parent: null,\n    device: null,\n    deviceProps: {},\n    gl: null,\n    canvas: null,\n    layers: [],\n    effects: [],\n    views: null,\n    controller: null, // Rely on external controller, e.g. react-map-gl\n    useDevicePixels: true,\n    touchAction: 'none',\n    eventRecognizerOptions: {},\n    _framebuffer: null,\n    _animate: false,\n    _pickable: true,\n    _typedArrayManagerProps: {},\n    _customRender: null,\n    widgets: [],\n    onDeviceInitialized: noop,\n    onWebGLInitialized: noop,\n    onResize: noop,\n    onViewStateChange: noop,\n    onInteractionStateChange: noop,\n    onBeforeRender: noop,\n    onAfterRender: noop,\n    onLoad: noop,\n    onError: (error) => log.error(error.message, error.cause)(),\n    onHover: null,\n    onClick: null,\n    onDragStart: null,\n    onDrag: null,\n    onDragEnd: null,\n    _onMetrics: null,\n    getCursor,\n    getTooltip: null,\n    debug: false,\n    drawPickingColors: false\n};\n/* eslint-disable max-statements */\nclass Deck {\n    constructor(props) {\n        this.width = 0;\n        this.height = 0;\n        // Allows attaching arbitrary data to the instance\n        this.userData = {};\n        this.device = null;\n        this.canvas = null;\n        this.viewManager = null;\n        this.layerManager = null;\n        this.effectManager = null;\n        this.deckRenderer = null;\n        this.deckPicker = null;\n        this.eventManager = null;\n        this.widgetManager = null;\n        this.tooltip = null;\n        this.animationLoop = null;\n        this.cursorState = {\n            isHovering: false,\n            isDragging: false\n        };\n        this.stats = new Stats({ id: 'deck.gl' });\n        this.metrics = {\n            fps: 0,\n            setPropsTime: 0,\n            updateAttributesTime: 0,\n            framesRedrawn: 0,\n            pickTime: 0,\n            pickCount: 0,\n            gpuTime: 0,\n            gpuTimePerFrame: 0,\n            cpuTime: 0,\n            cpuTimePerFrame: 0,\n            bufferMemory: 0,\n            textureMemory: 0,\n            renderbufferMemory: 0,\n            gpuMemory: 0\n        };\n        this._metricsCounter = 0;\n        this._needsRedraw = 'Initial render';\n        this._pickRequest = {\n            mode: 'hover',\n            x: -1,\n            y: -1,\n            radius: 0,\n            event: null\n        };\n        /**\n         * Pick and store the object under the pointer on `pointerdown`.\n         * This object is reused for subsequent `onClick` and `onDrag*` callbacks.\n         */\n        this._lastPointerDownInfo = null;\n        // The `pointermove` event may fire multiple times in between two animation frames,\n        // it's a waste of time to run picking without rerender. Instead we save the last pick\n        // request and only do it once on the next animation frame.\n        /** Internal use only: event handler for pointerdown */\n        this._onPointerMove = (event) => {\n            const { _pickRequest } = this;\n            if (event.type === 'pointerleave') {\n                _pickRequest.x = -1;\n                _pickRequest.y = -1;\n                _pickRequest.radius = 0;\n            }\n            else if (event.leftButton || event.rightButton) {\n                // Do not trigger onHover callbacks if mouse button is down.\n                return;\n            }\n            else {\n                const pos = event.offsetCenter;\n                // Do not trigger callbacks when click/hover position is invalid. Doing so will cause a\n                // assertion error when attempting to unproject the position.\n                if (!pos) {\n                    return;\n                }\n                _pickRequest.x = pos.x;\n                _pickRequest.y = pos.y;\n                _pickRequest.radius = this.props.pickingRadius;\n            }\n            if (this.layerManager) {\n                this.layerManager.context.mousePosition = { x: _pickRequest.x, y: _pickRequest.y };\n            }\n            _pickRequest.event = event;\n        };\n        /** Internal use only: event handler for click & drag */\n        this._onEvent = (event) => {\n            const eventHandlerProp = EVENT_HANDLERS[event.type];\n            const pos = event.offsetCenter;\n            if (!eventHandlerProp || !pos || !this.layerManager) {\n                return;\n            }\n            // Reuse last picked object\n            const layers = this.layerManager.getLayers();\n            const info = this.deckPicker.getLastPickedObject({\n                x: pos.x,\n                y: pos.y,\n                layers,\n                viewports: this.getViewports(pos)\n            }, this._lastPointerDownInfo);\n            const { layer } = info;\n            const layerHandler = layer && (layer[eventHandlerProp] || layer.props[eventHandlerProp]);\n            const rootHandler = this.props[eventHandlerProp];\n            let handled = false;\n            if (layerHandler) {\n                handled = layerHandler.call(layer, info, event);\n            }\n            if (!handled) {\n                rootHandler?.(info, event);\n                this.widgetManager.onEvent(info, event);\n            }\n        };\n        /** Internal use only: evnet handler for pointerdown */\n        this._onPointerDown = (event) => {\n            // TODO(ibgreen) Picking not yet supported on WebGPU\n            if (this.device?.type === 'webgpu') {\n                return;\n            }\n            const pos = event.offsetCenter;\n            const pickedInfo = this._pick('pickObject', 'pickObject Time', {\n                x: pos.x,\n                y: pos.y,\n                radius: this.props.pickingRadius\n            });\n            this._lastPointerDownInfo = pickedInfo.result[0] || pickedInfo.emptyInfo;\n        };\n        // @ts-ignore views\n        this.props = { ...defaultProps, ...props };\n        props = this.props;\n        if (props.viewState && props.initialViewState) {\n            log.warn('View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.')();\n        }\n        this.viewState = this.props.initialViewState;\n        // See if we already have a device\n        if (props.device) {\n            this.device = props.device;\n        }\n        let deviceOrPromise = this.device;\n        // Attach a new luma.gl device to a WebGL2 context if supplied\n        if (!deviceOrPromise && props.gl) {\n            if (props.gl instanceof WebGLRenderingContext) {\n                log.error('WebGL1 context not supported.')();\n            }\n            // Preserve user's callbacks and add resize handling\n            const userOnResize = this.props.deviceProps?.onResize;\n            deviceOrPromise = webgl2Adapter.attach(props.gl, {\n                ...this.props.deviceProps,\n                onResize: (canvasContext, info) => {\n                    // Manually sync drawing buffer dimensions (canvas is externally managed)\n                    // TODO(v9.3): Use canvasContext.setDrawingBufferSize(width, height) when upgrading to luma 9.3+\n                    const { width, height } = canvasContext.canvas;\n                    // @ts-ignore - accessing public properties to sync state\n                    canvasContext.drawingBufferWidth = width;\n                    // @ts-ignore\n                    canvasContext.drawingBufferHeight = height;\n                    this._needsRedraw = 'Canvas resized';\n                    userOnResize?.(canvasContext, info);\n                }\n            });\n        }\n        // Create a new device\n        if (!deviceOrPromise) {\n            deviceOrPromise = this._createDevice(props);\n        }\n        this.animationLoop = this._createAnimationLoop(deviceOrPromise, props);\n        this.setProps(props);\n        // UNSAFE/experimental prop: only set at initialization to avoid performance hit\n        if (props._typedArrayManagerProps) {\n            typedArrayManager.setOptions(props._typedArrayManagerProps);\n        }\n        this.animationLoop.start();\n    }\n    /** Stop rendering and dispose all resources */\n    finalize() {\n        this.animationLoop?.stop();\n        this.animationLoop?.destroy();\n        this.animationLoop = null;\n        this._lastPointerDownInfo = null;\n        this.layerManager?.finalize();\n        this.layerManager = null;\n        this.viewManager?.finalize();\n        this.viewManager = null;\n        this.effectManager?.finalize();\n        this.effectManager = null;\n        this.deckRenderer?.finalize();\n        this.deckRenderer = null;\n        this.deckPicker?.finalize();\n        this.deckPicker = null;\n        this.eventManager?.destroy();\n        this.eventManager = null;\n        this.widgetManager?.finalize();\n        this.widgetManager = null;\n        if (!this.props.canvas && !this.props.device && !this.props.gl && this.canvas) {\n            // remove internally created canvas\n            this.canvas.parentElement?.removeChild(this.canvas);\n            this.canvas = null;\n        }\n    }\n    /** Partially update props */\n    setProps(props) {\n        this.stats.get('setProps Time').timeStart();\n        if ('onLayerHover' in props) {\n            log.removed('onLayerHover', 'onHover')();\n        }\n        if ('onLayerClick' in props) {\n            log.removed('onLayerClick', 'onClick')();\n        }\n        if (props.initialViewState &&\n            // depth = 3 when comparing viewStates: viewId.position.0\n            !deepEqual(this.props.initialViewState, props.initialViewState, 3)) {\n            // Overwrite internal view state\n            this.viewState = props.initialViewState;\n        }\n        // Merge with existing props\n        Object.assign(this.props, props);\n        // Update CSS size of canvas\n        this._setCanvasSize(this.props);\n        // We need to overwrite CSS style width and height with actual, numeric values\n        const resolvedProps = Object.create(this.props);\n        Object.assign(resolvedProps, {\n            views: this._getViews(),\n            width: this.width,\n            height: this.height,\n            viewState: this._getViewState()\n        });\n        if (props.device && props.device.id !== this.device?.id) {\n            this.animationLoop?.stop();\n            if (this.canvas !== props.device.canvasContext?.canvas) {\n                // remove old canvas if new one being used and de-register events\n                // TODO (ck): We might not own this canvas depending it's source, so removing it from the\n                // DOM here might be a bit unexpected but it should be ok for most users.\n                this.canvas?.remove();\n                this.eventManager?.destroy();\n                // ensure we will re-attach ourselves after createDevice callbacks\n                this.canvas = null;\n            }\n            log.log(`recreating animation loop for new device! id=${props.device.id}`)();\n            this.animationLoop = this._createAnimationLoop(props.device, props);\n            this.animationLoop.start();\n        }\n        // Update the animation loop\n        this.animationLoop?.setProps(resolvedProps);\n        if (props.useDevicePixels !== undefined && this.device?.canvasContext) {\n            this.device.canvasContext.setProps({ useDevicePixels: props.useDevicePixels });\n        }\n        // If initialized, update sub manager props\n        if (this.layerManager) {\n            this.viewManager.setProps(resolvedProps);\n            // Make sure that any new layer gets initialized with the current viewport\n            this.layerManager.activateViewport(this.getViewports()[0]);\n            this.layerManager.setProps(resolvedProps);\n            this.effectManager.setProps(resolvedProps);\n            this.deckRenderer.setProps(resolvedProps);\n            this.deckPicker.setProps(resolvedProps);\n            this.widgetManager.setProps(resolvedProps);\n        }\n        this.stats.get('setProps Time').timeEnd();\n    }\n    // Public API\n    /**\n     * Check if a redraw is needed\n     * @returns `false` or a string summarizing the redraw reason\n     */\n    needsRedraw(opts = { clearRedrawFlags: false }) {\n        if (!this.layerManager) {\n            // Not initialized or already finalized\n            return false;\n        }\n        if (this.props._animate) {\n            return 'Deck._animate';\n        }\n        let redraw = this._needsRedraw;\n        if (opts.clearRedrawFlags) {\n            this._needsRedraw = false;\n        }\n        const viewManagerNeedsRedraw = this.viewManager.needsRedraw(opts);\n        const layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);\n        const effectManagerNeedsRedraw = this.effectManager.needsRedraw(opts);\n        const deckRendererNeedsRedraw = this.deckRenderer.needsRedraw(opts);\n        redraw =\n            redraw ||\n                viewManagerNeedsRedraw ||\n                layerManagerNeedsRedraw ||\n                effectManagerNeedsRedraw ||\n                deckRendererNeedsRedraw;\n        return redraw;\n    }\n    /**\n     * Redraw the GL context\n     * @param reason If not provided, only redraw if deemed necessary. Otherwise redraw regardless of internal states.\n     * @returns\n     */\n    redraw(reason) {\n        if (!this.layerManager) {\n            // Not yet initialized\n            return;\n        }\n        // Check if we need to redraw\n        let redrawReason = this.needsRedraw({ clearRedrawFlags: true });\n        // User-supplied should take precedent, however the redraw flags get cleared regardless\n        redrawReason = reason || redrawReason;\n        if (!redrawReason) {\n            return;\n        }\n        this.stats.get('Redraw Count').incrementCount();\n        if (this.props._customRender) {\n            this.props._customRender(redrawReason);\n        }\n        else {\n            this._drawLayers(redrawReason);\n        }\n    }\n    /** Flag indicating that the Deck instance has initialized its resources and it's safe to call public methods. */\n    get isInitialized() {\n        return this.viewManager !== null;\n    }\n    /** Get a list of views that are currently rendered */\n    getViews() {\n        assert(this.viewManager);\n        return this.viewManager.views;\n    }\n    /** Get a list of viewports that are currently rendered.\n     * @param rect If provided, only returns viewports within the given bounding box.\n     */\n    getViewports(rect) {\n        assert(this.viewManager);\n        return this.viewManager.getViewports(rect);\n    }\n    /** Get the current canvas element. */\n    getCanvas() {\n        return this.canvas;\n    }\n    /** Query the object rendered on top at a given point */\n    pickObject(opts) {\n        const infos = this._pick('pickObject', 'pickObject Time', opts).result;\n        return infos.length ? infos[0] : null;\n    }\n    /* Query all rendered objects at a given point */\n    pickMultipleObjects(opts) {\n        opts.depth = opts.depth || 10;\n        return this._pick('pickObject', 'pickMultipleObjects Time', opts).result;\n    }\n    /* Query all objects rendered on top within a bounding box */\n    pickObjects(opts) {\n        return this._pick('pickObjects', 'pickObjects Time', opts);\n    }\n    /** Experimental\n     * Add a global resource for sharing among layers\n     */\n    _addResources(resources, forceUpdate = false) {\n        for (const id in resources) {\n            this.layerManager.resourceManager.add({ resourceId: id, data: resources[id], forceUpdate });\n        }\n    }\n    /** Experimental\n     * Remove a global resource\n     */\n    _removeResources(resourceIds) {\n        for (const id of resourceIds) {\n            this.layerManager.resourceManager.remove(id);\n        }\n    }\n    /** Experimental\n     * Register a default effect. Effects will be sorted by order, those with a low order will be rendered first\n     */\n    _addDefaultEffect(effect) {\n        this.effectManager.addDefaultEffect(effect);\n    }\n    _addDefaultShaderModule(module) {\n        this.layerManager.addDefaultShaderModule(module);\n    }\n    _removeDefaultShaderModule(module) {\n        this.layerManager?.removeDefaultShaderModule(module);\n    }\n    _pick(method, statKey, opts) {\n        assert(this.deckPicker);\n        const { stats } = this;\n        stats.get('Pick Count').incrementCount();\n        stats.get(statKey).timeStart();\n        const infos = this.deckPicker[method]({\n            // layerManager, viewManager and effectManager are always defined if deckPicker is\n            layers: this.layerManager.getLayers(opts),\n            views: this.viewManager.getViews(),\n            viewports: this.getViewports(opts),\n            onViewportActive: this.layerManager.activateViewport,\n            effects: this.effectManager.getEffects(),\n            ...opts\n        });\n        stats.get(statKey).timeEnd();\n        return infos;\n    }\n    /** Resolve props.canvas to element */\n    _createCanvas(props) {\n        let canvas = props.canvas;\n        // TODO EventManager should accept element id\n        if (typeof canvas === 'string') {\n            canvas = document.getElementById(canvas);\n            assert(canvas);\n        }\n        if (!canvas) {\n            canvas = document.createElement('canvas');\n            canvas.id = props.id || 'deckgl-overlay';\n            // TODO this is a hack, investigate why these are not set for the picking\n            // tests\n            if (props.width && typeof props.width === 'number') {\n                canvas.width = props.width;\n            }\n            if (props.height && typeof props.height === 'number') {\n                canvas.height = props.height;\n            }\n            const parent = props.parent || document.body;\n            parent.appendChild(canvas);\n        }\n        Object.assign(canvas.style, props.style);\n        return canvas;\n    }\n    /** Updates canvas width and/or height, if provided as props */\n    _setCanvasSize(props) {\n        if (!this.canvas) {\n            return;\n        }\n        const { width, height } = props;\n        // Set size ONLY if props are being provided, otherwise let canvas be layouted freely\n        if (width || width === 0) {\n            const cssWidth = Number.isFinite(width) ? `${width}px` : width;\n            this.canvas.style.width = cssWidth;\n        }\n        if (height || height === 0) {\n            const cssHeight = Number.isFinite(height) ? `${height}px` : height;\n            // Note: position==='absolute' required for height 100% to work\n            this.canvas.style.position = props.style?.position || 'absolute';\n            this.canvas.style.height = cssHeight;\n        }\n    }\n    /** If canvas size has changed, reads out the new size and update */\n    _updateCanvasSize() {\n        const { canvas } = this;\n        if (!canvas) {\n            return;\n        }\n        // Fallback to width/height when clientWidth/clientHeight are undefined (OffscreenCanvas).\n        const newWidth = canvas.clientWidth ?? canvas.width;\n        const newHeight = canvas.clientHeight ?? canvas.height;\n        if (newWidth !== this.width || newHeight !== this.height) {\n            // @ts-expect-error private assign to read-only property\n            this.width = newWidth;\n            // @ts-expect-error private assign to read-only property\n            this.height = newHeight;\n            this.viewManager?.setProps({ width: newWidth, height: newHeight });\n            // Make sure that any new layer gets initialized with the current viewport\n            this.layerManager?.activateViewport(this.getViewports()[0]);\n            this.props.onResize({ width: newWidth, height: newHeight });\n        }\n    }\n    _createAnimationLoop(deviceOrPromise, props) {\n        const { \n        // width,\n        // height,\n        gl, \n        // debug,\n        onError\n        // onBeforeRender,\n        // onAfterRender,\n         } = props;\n        return new AnimationLoop({\n            device: deviceOrPromise,\n            // TODO v9\n            autoResizeDrawingBuffer: !gl, // do not auto resize external context\n            autoResizeViewport: false,\n            // @ts-expect-error luma.gl needs to accept Promise<void> return value\n            onInitialize: context => this._setDevice(context.device),\n            onRender: this._onRenderFrame.bind(this),\n            // @ts-expect-error typing mismatch: AnimationLoop does not accept onError:null\n            onError\n            // onBeforeRender,\n            // onAfterRender,\n        });\n    }\n    // Create a device from the deviceProps, assigning required defaults\n    _createDevice(props) {\n        const canvasContextUserProps = this.props.deviceProps?.createCanvasContext;\n        const canvasContextProps = typeof canvasContextUserProps === 'object' ? canvasContextUserProps : undefined;\n        // In deck.gl v9, Deck always bundles and adds a webgl2Adapter.\n        // This behavior is expected to change in deck.gl v10 to support WebGPU only builds.\n        const deviceProps = {\n            adapters: [],\n            _cacheShaders: true,\n            _cachePipelines: true,\n            ...props.deviceProps\n        };\n        if (!deviceProps.adapters.includes(webgl2Adapter)) {\n            deviceProps.adapters.push(webgl2Adapter);\n        }\n        const defaultCanvasProps = {\n            // we must use 'premultiplied' canvas for webgpu to enable transparency and match shaders\n            alphaMode: this.props.deviceProps?.type === 'webgpu' ? 'premultiplied' : undefined\n        };\n        // Preserve user's onResize callback\n        const userOnResize = this.props.deviceProps?.onResize;\n        // Create the \"best\" device supported from the registered adapters\n        return luma.createDevice({\n            // luma by default throws if a device is already attached\n            // asynchronous device creation could happen after finalize() is called\n            // TODO - createDevice should support AbortController?\n            _reuseDevices: true,\n            // tests can't handle WebGPU devices yet so we force WebGL2 unless overridden\n            type: 'webgl',\n            ...deviceProps,\n            // In deck.gl v10 we may emphasize multi canvas support and unwind this prop wrapping\n            createCanvasContext: {\n                ...defaultCanvasProps,\n                ...canvasContextProps,\n                canvas: this._createCanvas(props),\n                useDevicePixels: this.props.useDevicePixels,\n                autoResize: true\n            },\n            onResize: (canvasContext, info) => {\n                // Set redraw flag when luma.gl's CanvasContext detects a resize\n                // This restores pre-9.2 behavior where resize automatically triggered redraws\n                this._needsRedraw = 'Canvas resized';\n                // Call user's onResize if provided\n                userOnResize?.(canvasContext, info);\n            }\n        });\n    }\n    // Get the most relevant view state: props.viewState, if supplied, shadows internal viewState\n    // TODO: For backwards compatibility ensure numeric width and height is added to the viewState\n    _getViewState() {\n        return this.props.viewState || this.viewState;\n    }\n    // Get the view descriptor list\n    _getViews() {\n        const { views } = this.props;\n        const normalizedViews = Array.isArray(views)\n            ? views\n            : // If null, default to a full screen map view port\n                views\n                    ? [views]\n                    : [new MapView({ id: 'default-view' })];\n        if (normalizedViews.length && this.props.controller) {\n            // Backward compatibility: support controller prop\n            normalizedViews[0].props.controller = this.props.controller;\n        }\n        return normalizedViews;\n    }\n    _onContextLost() {\n        const { onError } = this.props;\n        if (this.animationLoop && onError) {\n            onError(new Error('WebGL context is lost'));\n        }\n    }\n    /** Actually run picking */\n    _pickAndCallback() {\n        if (this.device?.type === 'webgpu') {\n            return;\n        }\n        const { _pickRequest } = this;\n        if (_pickRequest.event) {\n            // Perform picking\n            const { result, emptyInfo } = this._pick('pickObject', 'pickObject Time', _pickRequest);\n            this.cursorState.isHovering = result.length > 0;\n            // There are 4 possible scenarios:\n            // result is [outInfo, pickedInfo] (moved from one pickable layer to another)\n            // result is [outInfo] (moved outside of a pickable layer)\n            // result is [pickedInfo] (moved into or over a pickable layer)\n            // result is [] (nothing is or was picked)\n            //\n            // `layer.props.onHover` should be called on all affected layers (out/over)\n            // `deck.props.onHover` should be called with the picked info if any, or empty info otherwise\n            // `deck.props.getTooltip` should be called with the picked info if any, or empty info otherwise\n            // Execute callbacks\n            let pickedInfo = emptyInfo;\n            let handled = false;\n            for (const info of result) {\n                pickedInfo = info;\n                handled = info.layer?.onHover(info, _pickRequest.event) || handled;\n            }\n            if (!handled) {\n                this.props.onHover?.(pickedInfo, _pickRequest.event);\n                this.widgetManager.onHover(pickedInfo, _pickRequest.event);\n            }\n            // Clear pending pickRequest\n            _pickRequest.event = null;\n        }\n    }\n    _updateCursor() {\n        const container = this.props.parent || this.canvas;\n        if (container) {\n            container.style.cursor = this.props.getCursor(this.cursorState);\n        }\n    }\n    _setDevice(device) {\n        this.device = device;\n        if (!this.animationLoop) {\n            // finalize() has been called\n            return;\n        }\n        // if external context...\n        if (!this.canvas) {\n            this.canvas = this.device.canvasContext?.canvas;\n            // external canvas may not be in DOM\n            if (!this.canvas.isConnected && this.props.parent) {\n                this.props.parent.insertBefore(this.canvas, this.props.parent.firstChild);\n            }\n            // TODO v9\n            // ts-expect-error - Currently luma.gl v9 does not expose these options\n            // All WebGLDevice contexts are instrumented, but it seems the device\n            // should have a method to start state tracking even if not enabled?\n            // instrumentGLContext(this.device.gl, {enable: true, copyState: true});\n        }\n        if (this.device.type === 'webgl') {\n            this.device.setParametersWebGL({\n                blend: true,\n                blendFunc: [770, 771, 1, 771],\n                polygonOffsetFill: true,\n                depthTest: true,\n                depthFunc: 515\n            });\n        }\n        this.props.onDeviceInitialized(this.device);\n        if (this.device.type === 'webgl') {\n            // Legacy callback - warn?\n            // @ts-expect-error gl is not visible on Device base class\n            this.props.onWebGLInitialized(this.device.gl);\n        }\n        // timeline for transitions\n        const timeline = new Timeline();\n        timeline.play();\n        this.animationLoop.attachTimeline(timeline);\n        this.eventManager = new EventManager(this.props.parent || this.canvas, {\n            touchAction: this.props.touchAction,\n            recognizers: Object.keys(RECOGNIZERS).map((eventName) => {\n                // Resolve recognizer settings\n                const [RecognizerConstructor, defaultOptions, recognizeWith, requestFailure] = RECOGNIZERS[eventName];\n                const optionsOverride = this.props.eventRecognizerOptions?.[eventName];\n                const options = { ...defaultOptions, ...optionsOverride, event: eventName };\n                return {\n                    recognizer: new RecognizerConstructor(options),\n                    recognizeWith,\n                    requestFailure\n                };\n            }),\n            events: {\n                pointerdown: this._onPointerDown,\n                pointermove: this._onPointerMove,\n                pointerleave: this._onPointerMove\n            }\n        });\n        for (const eventType in EVENT_HANDLERS) {\n            this.eventManager.on(eventType, this._onEvent);\n        }\n        this.viewManager = new ViewManager({\n            timeline,\n            eventManager: this.eventManager,\n            onViewStateChange: this._onViewStateChange.bind(this),\n            onInteractionStateChange: this._onInteractionStateChange.bind(this),\n            views: this._getViews(),\n            viewState: this._getViewState(),\n            width: this.width,\n            height: this.height\n        });\n        // viewManager must be initialized before layerManager\n        // layerManager depends on viewport created by viewManager.\n        const viewport = this.viewManager.getViewports()[0];\n        // Note: avoid React setState due GL animation loop / setState timing issue\n        this.layerManager = new LayerManager(this.device, {\n            deck: this,\n            stats: this.stats,\n            viewport,\n            timeline\n        });\n        this.effectManager = new EffectManager({\n            deck: this,\n            device: this.device\n        });\n        this.deckRenderer = new DeckRenderer(this.device);\n        this.deckPicker = new DeckPicker(this.device);\n        this.widgetManager = new WidgetManager({\n            deck: this,\n            parentElement: this.canvas?.parentElement\n        });\n        this.widgetManager.addDefault(new TooltipWidget());\n        this.setProps(this.props);\n        this._updateCanvasSize();\n        this.props.onLoad();\n    }\n    /** Internal only: default render function (redraw all layers and views) */\n    _drawLayers(redrawReason, renderOptions) {\n        const { device, gl } = this.layerManager.context;\n        this.props.onBeforeRender({ device, gl });\n        const opts = {\n            target: this.props._framebuffer,\n            layers: this.layerManager.getLayers(),\n            viewports: this.viewManager.getViewports(),\n            onViewportActive: this.layerManager.activateViewport,\n            views: this.viewManager.getViews(),\n            pass: 'screen',\n            effects: this.effectManager.getEffects(),\n            ...renderOptions\n        };\n        this.deckRenderer?.renderLayers(opts);\n        if (opts.pass === 'screen') {\n            // This method could be called when drawing to picking buffer, texture etc.\n            // Only when drawing to screen, update all widgets (UI components)\n            this.widgetManager.onRedraw({\n                viewports: opts.viewports,\n                layers: opts.layers\n            });\n        }\n        this.props.onAfterRender({ device, gl });\n    }\n    // Callbacks\n    _onRenderFrame() {\n        this._getFrameStats();\n        // Log perf stats every second\n        if (this._metricsCounter++ % 60 === 0) {\n            this._getMetrics();\n            this.stats.reset();\n            log.table(4, this.metrics)();\n            // Experimental: report metrics\n            if (this.props._onMetrics) {\n                this.props._onMetrics(this.metrics);\n            }\n        }\n        this._updateCanvasSize();\n        this._updateCursor();\n        // Update layers if needed (e.g. some async prop has loaded)\n        // Note: This can trigger a redraw\n        this.layerManager.updateLayers();\n        // Perform picking request if any\n        // TODO(ibgreen): Picking not yet supported on WebGPU\n        if (this.device?.type !== 'webgpu') {\n            this._pickAndCallback();\n        }\n        // Redraw if necessary\n        this.redraw();\n        // Update viewport transition if needed\n        // Note: this can trigger `onViewStateChange`, and affect layers\n        // We want to defer these changes to the next frame\n        if (this.viewManager) {\n            this.viewManager.updateViewStates();\n        }\n    }\n    // Callbacks\n    _onViewStateChange(params) {\n        // Let app know that view state is changing, and give it a chance to change it\n        const viewState = this.props.onViewStateChange(params) || params.viewState;\n        // If initialViewState was set on creation, auto track position\n        if (this.viewState) {\n            this.viewState = { ...this.viewState, [params.viewId]: viewState };\n            if (!this.props.viewState) {\n                // Apply internal view state\n                if (this.viewManager) {\n                    this.viewManager.setProps({ viewState: this.viewState });\n                }\n            }\n        }\n    }\n    _onInteractionStateChange(interactionState) {\n        this.cursorState.isDragging = interactionState.isDragging || false;\n        this.props.onInteractionStateChange(interactionState);\n    }\n    _getFrameStats() {\n        const { stats } = this;\n        stats.get('frameRate').timeEnd();\n        stats.get('frameRate').timeStart();\n        // Get individual stats from luma.gl so reset works\n        const animationLoopStats = this.animationLoop.stats;\n        stats.get('GPU Time').addTime(animationLoopStats.get('GPU Time').lastTiming);\n        stats.get('CPU Time').addTime(animationLoopStats.get('CPU Time').lastTiming);\n    }\n    _getMetrics() {\n        const { metrics, stats } = this;\n        metrics.fps = stats.get('frameRate').getHz();\n        metrics.setPropsTime = stats.get('setProps Time').time;\n        metrics.updateAttributesTime = stats.get('Update Attributes').time;\n        metrics.framesRedrawn = stats.get('Redraw Count').count;\n        metrics.pickTime =\n            stats.get('pickObject Time').time +\n                stats.get('pickMultipleObjects Time').time +\n                stats.get('pickObjects Time').time;\n        metrics.pickCount = stats.get('Pick Count').count;\n        // Luma stats\n        metrics.gpuTime = stats.get('GPU Time').time;\n        metrics.cpuTime = stats.get('CPU Time').time;\n        metrics.gpuTimePerFrame = stats.get('GPU Time').getAverageTime();\n        metrics.cpuTimePerFrame = stats.get('CPU Time').getAverageTime();\n        const memoryStats = luma.stats.get('Memory Usage');\n        metrics.bufferMemory = memoryStats.get('Buffer Memory').count;\n        metrics.textureMemory = memoryStats.get('Texture Memory').count;\n        metrics.renderbufferMemory = memoryStats.get('Renderbuffer Memory').count;\n        metrics.gpuMemory = memoryStats.get('GPU Memory').count;\n    }\n}\nDeck.defaultProps = defaultProps;\n// This is used to defeat tree shaking of init.js\n// https://github.com/visgl/deck.gl/issues/3213\nDeck.VERSION = VERSION;\nexport default Deck;\n//# sourceMappingURL=deck.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { clamp } from '@math.gl/core';\nimport Controller from \"./controller.js\";\nimport { MapState } from \"./map-controller.js\";\nimport { mod } from \"../utils/math-utils.js\";\nimport LinearInterpolator from \"../transitions/linear-interpolator.js\";\nimport { zoomAdjust } from \"../viewports/globe-viewport.js\";\nimport { MAX_LATITUDE } from '@math.gl/web-mercator';\nclass GlobeState extends MapState {\n    constructor(options) {\n        const { startPanPos, ...mapStateOptions } = options;\n        super(mapStateOptions);\n        if (startPanPos !== undefined) {\n            this._state.startPanPos = startPanPos;\n        }\n    }\n    panStart({ pos }) {\n        const { latitude, longitude, zoom } = this.getViewportProps();\n        return this._getUpdatedState({\n            startPanLngLat: [longitude, latitude],\n            startPanPos: pos,\n            startZoom: zoom\n        });\n    }\n    pan({ pos, startPos }) {\n        const state = this.getState();\n        const startPanLngLat = state.startPanLngLat || this._unproject(startPos);\n        if (!startPanLngLat)\n            return this;\n        const startZoom = state.startZoom ?? this.getViewportProps().zoom;\n        const startPanPos = state.startPanPos || startPos;\n        const coords = [startPanLngLat[0], startPanLngLat[1], startZoom];\n        const viewport = this.makeViewport(this.getViewportProps());\n        const newProps = viewport.panByPosition(coords, pos, startPanPos);\n        return this._getUpdatedState(newProps);\n    }\n    panEnd() {\n        return this._getUpdatedState({\n            startPanLngLat: null,\n            startPanPos: null,\n            startZoom: null\n        });\n    }\n    zoom({ scale }) {\n        // In Globe view zoom does not take into account the mouse position\n        const startZoom = this.getState().startZoom || this.getViewportProps().zoom;\n        const zoom = startZoom + Math.log2(scale);\n        return this._getUpdatedState({ zoom });\n    }\n    applyConstraints(props) {\n        // Ensure zoom is within specified range\n        const { longitude, latitude, maxZoom, minZoom, zoom } = props;\n        const ZOOM0 = zoomAdjust(0);\n        const zoomAdjustment = zoomAdjust(latitude) - ZOOM0;\n        props.zoom = clamp(zoom, minZoom + zoomAdjustment, maxZoom + zoomAdjustment);\n        if (longitude < -180 || longitude > 180) {\n            props.longitude = mod(longitude + 180, 360) - 180;\n        }\n        props.latitude = clamp(latitude, -MAX_LATITUDE, MAX_LATITUDE);\n        return props;\n    }\n}\nexport default class GlobeController extends Controller {\n    constructor() {\n        super(...arguments);\n        this.ControllerState = GlobeState;\n        this.transition = {\n            transitionDuration: 300,\n            transitionInterpolator: new LinearInterpolator(['longitude', 'latitude', 'zoom'])\n        };\n        this.dragMode = 'pan';\n    }\n    setProps(props) {\n        super.setProps(props);\n        // TODO - support pitching?\n        this.dragRotate = false;\n        this.touchRotate = false;\n    }\n}\n//# sourceMappingURL=globe-controller.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport View from \"./view.js\";\nimport GlobeViewport from \"../viewports/globe-viewport.js\";\nimport WebMercatorViewport from \"../viewports/web-mercator-viewport.js\";\nimport GlobeController from \"../controllers/globe-controller.js\";\nclass GlobeView extends View {\n    constructor(props = {}) {\n        super(props);\n    }\n    getViewportType(viewState) {\n        return viewState.zoom > 12 ? WebMercatorViewport : GlobeViewport;\n    }\n    get ControllerType() {\n        return GlobeController;\n    }\n}\nGlobeView.displayName = 'GlobeView';\nexport default GlobeView;\n//# sourceMappingURL=globe-view.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Deck, MapView, _GlobeView as GlobeView, _flatten as flatten } from '@deck.gl/core';\nimport { lngLatToWorld, unitsPerMeter } from '@math.gl/web-mercator';\nconst MAPBOX_VIEW_ID = 'mapbox';\n// Mercator constants\nconst TILE_SIZE = 512;\nconst DEGREES_TO_RADIANS = Math.PI / 180;\n// Create an interleaved deck instance.\nexport function getDeckInstance({ map, gl, deck }) {\n    // Only create one deck instance per context\n    if (map.__deck) {\n        return map.__deck;\n    }\n    // Only initialize certain props once per context\n    const customRender = deck?.props._customRender;\n    const onLoad = deck?.props.onLoad;\n    const deckProps = {\n        ...deck?.props,\n        _customRender: () => {\n            map.triggerRepaint();\n            // customRender may be subscribed by DeckGL React component to update child props\n            // make sure it is still called\n            // Hack - do not pass a redraw reason here to prevent the React component from clearing the context\n            // Rerender will be triggered by MapboxLayer's render()\n            customRender?.('');\n        }\n    };\n    deckProps.parameters = { ...getDefaultParameters(map, true), ...deckProps.parameters };\n    deckProps.views || (deckProps.views = getDefaultView(map));\n    let deckInstance;\n    if (!deck || deck.props.gl === gl) {\n        // If deck isn't defined (Internal MapboxLayer use case),\n        // or if deck is defined and is using the WebGLContext created by mapbox (MapboxOverlay and External MapboxLayer use case),\n        // block deck from setting the canvas size, and use the map's viewState to drive deck.\n        // Otherwise, we use deck's viewState to drive the map.\n        Object.assign(deckProps, {\n            gl,\n            width: null,\n            height: null,\n            touchAction: 'unset',\n            viewState: getViewState(map)\n        });\n        if (deck?.isInitialized) {\n            watchMapMove(deck, map);\n        }\n        else {\n            deckProps.onLoad = () => {\n                onLoad?.();\n                watchMapMove(deckInstance, map);\n            };\n        }\n    }\n    if (deck) {\n        deckInstance = deck;\n        deck.setProps(deckProps);\n        deck.userData.isExternal = true;\n    }\n    else {\n        deckInstance = new Deck(deckProps);\n        map.on('remove', () => {\n            removeDeckInstance(map);\n        });\n    }\n    deckInstance.userData.mapboxLayers = new Set();\n    // (deckInstance.userData as UserData).mapboxVersion = getMapboxVersion(map);\n    map.__deck = deckInstance;\n    map.on('render', () => {\n        if (deckInstance.isInitialized)\n            afterRender(deckInstance, map);\n    });\n    return deckInstance;\n}\nfunction watchMapMove(deck, map) {\n    const _handleMapMove = () => {\n        if (deck.isInitialized) {\n            // call view state methods\n            onMapMove(deck, map);\n        }\n        else {\n            // deregister itself when deck is finalized\n            map.off('move', _handleMapMove);\n        }\n    };\n    map.on('move', _handleMapMove);\n}\nexport function removeDeckInstance(map) {\n    map.__deck?.finalize();\n    map.__deck = null;\n}\nexport function getDefaultParameters(map, interleaved) {\n    const result = interleaved\n        ? {\n            depthWriteEnabled: true,\n            depthCompare: 'less-equal',\n            depthBias: 0,\n            blend: true,\n            blendColorSrcFactor: 'src-alpha',\n            blendColorDstFactor: 'one-minus-src-alpha',\n            blendAlphaSrcFactor: 'one',\n            blendAlphaDstFactor: 'one-minus-src-alpha',\n            blendColorOperation: 'add',\n            blendAlphaOperation: 'add'\n        }\n        : {};\n    if (getProjection(map) === 'globe') {\n        result.cullMode = 'back';\n    }\n    return result;\n}\nexport function addLayer(deck, layer) {\n    deck.userData.mapboxLayers.add(layer);\n    updateLayers(deck);\n}\nexport function removeLayer(deck, layer) {\n    deck.userData.mapboxLayers.delete(layer);\n    updateLayers(deck);\n}\nexport function updateLayer(deck, layer) {\n    updateLayers(deck);\n}\nexport function drawLayer(deck, map, layer, renderParameters) {\n    let { currentViewport } = deck.userData;\n    let clearStack = false;\n    if (!currentViewport) {\n        // This is the first layer drawn in this render cycle.\n        // Generate viewport from the current map state.\n        currentViewport = getViewport(deck, map, renderParameters);\n        deck.userData.currentViewport = currentViewport;\n        clearStack = true;\n    }\n    if (!deck.isInitialized) {\n        return;\n    }\n    deck._drawLayers('mapbox-repaint', {\n        viewports: [currentViewport],\n        layerFilter: params => (!deck.props.layerFilter || deck.props.layerFilter(params)) &&\n            (layer.id === params.layer.id || params.layer.props.operation.includes('terrain')),\n        clearStack,\n        clearCanvas: false\n    });\n}\nexport function drawLayerGroup(deck, map, group, renderParameters) {\n    let { currentViewport } = deck.userData;\n    let clearStack = false;\n    if (!currentViewport) {\n        // This is the first layer drawn in this render cycle.\n        // Generate viewport from the current map state.\n        currentViewport = getViewport(deck, map, renderParameters);\n        deck.userData.currentViewport = currentViewport;\n        clearStack = true;\n    }\n    if (!deck.isInitialized) {\n        return;\n    }\n    deck._drawLayers('mapbox-repaint', {\n        viewports: [currentViewport],\n        layerFilter: params => {\n            if (deck.props.layerFilter && !deck.props.layerFilter(params)) {\n                return false;\n            }\n            const layer = params.layer;\n            if (layer.props.beforeId === group.beforeId && layer.props.slot === group.slot) {\n                return true;\n            }\n            return false;\n        },\n        clearStack,\n        clearCanvas: false\n    });\n}\nexport function getProjection(map) {\n    const projection = map.getProjection?.();\n    const type = \n    // maplibre projection spec\n    projection?.type ||\n        // mapbox projection spec\n        projection?.name;\n    if (type === 'globe') {\n        return 'globe';\n    }\n    if (type && type !== 'mercator') {\n        throw new Error('Unsupported projection');\n    }\n    return 'mercator';\n}\nexport function getDefaultView(map) {\n    if (getProjection(map) === 'globe') {\n        return new GlobeView({ id: MAPBOX_VIEW_ID });\n    }\n    return new MapView({ id: MAPBOX_VIEW_ID });\n}\nexport function getViewState(map) {\n    const { lng, lat } = map.getCenter();\n    const viewState = {\n        // Longitude returned by getCenter can be outside of [-180, 180] when zooming near the anti meridian\n        // https://github.com/visgl/deck.gl/issues/6894\n        longitude: ((lng + 540) % 360) - 180,\n        latitude: lat,\n        zoom: map.getZoom(),\n        bearing: map.getBearing(),\n        pitch: map.getPitch(),\n        padding: map.getPadding(),\n        repeat: map.getRenderWorldCopies()\n    };\n    if (map.getTerrain?.()) {\n        // When the base map has terrain, we need to target the camera at the terrain surface\n        centerCameraOnTerrain(map, viewState);\n    }\n    return viewState;\n}\nfunction centerCameraOnTerrain(map, viewState) {\n    if (map.getFreeCameraOptions) {\n        // mapbox-gl v2\n        const { position } = map.getFreeCameraOptions();\n        if (!position || position.z === undefined) {\n            return;\n        }\n        // @ts-ignore transform is not typed\n        const height = map.transform.height;\n        const { longitude, latitude, pitch } = viewState;\n        // Convert mapbox mercator coordinate to deck common space\n        const cameraX = position.x * TILE_SIZE;\n        const cameraY = (1 - position.y) * TILE_SIZE;\n        const cameraZ = position.z * TILE_SIZE;\n        // Mapbox manipulates zoom in terrain mode, see discussion here: https://github.com/mapbox/mapbox-gl-js/issues/12040\n        const center = lngLatToWorld([longitude, latitude]);\n        const dx = cameraX - center[0];\n        const dy = cameraY - center[1];\n        const cameraToCenterDistanceGround = Math.sqrt(dx * dx + dy * dy);\n        const pitchRadians = pitch * DEGREES_TO_RADIANS;\n        const altitudePixels = 1.5 * height;\n        const scale = pitchRadians < 0.001\n            ? // Pitch angle too small to deduce the look at point, assume elevation is 0\n                (altitudePixels * Math.cos(pitchRadians)) / cameraZ\n            : (altitudePixels * Math.sin(pitchRadians)) / cameraToCenterDistanceGround;\n        viewState.zoom = Math.log2(scale);\n        const cameraZFromSurface = (altitudePixels * Math.cos(pitchRadians)) / scale;\n        const surfaceElevation = cameraZ - cameraZFromSurface;\n        viewState.position = [0, 0, surfaceElevation / unitsPerMeter(latitude)];\n    }\n    // @ts-ignore transform is not typed\n    else if (typeof map.transform.elevation === 'number') {\n        // maplibre-gl\n        // @ts-ignore transform is not typed\n        viewState.position = [0, 0, map.transform.elevation];\n    }\n}\nfunction getViewport(deck, map, renderParameters) {\n    const viewState = getViewState(map);\n    const { views } = deck.props;\n    const view = (views && flatten(views).find((v) => v.id === MAPBOX_VIEW_ID)) ||\n        getDefaultView(map);\n    if (renderParameters) {\n        // Called from MapboxLayer.render\n        // Magic number, matches mapbox-gl@>=1.3.0's projection matrix\n        view.props.nearZMultiplier = 0.2;\n    }\n    // Get the base map near/far plane\n    // renderParameters is maplibre API but not mapbox\n    // Transform is not an official API, properties could be undefined for older versions\n    const nearZ = renderParameters?.nearZ ?? map.transform._nearZ;\n    const farZ = renderParameters?.farZ ?? map.transform._farZ;\n    if (Number.isFinite(nearZ)) {\n        viewState.nearZ = nearZ / map.transform.height;\n        viewState.farZ = farZ / map.transform.height;\n    }\n    // Otherwise fallback to default calculation using nearZMultiplier/farZMultiplier\n    return view.makeViewport({\n        width: deck.width,\n        height: deck.height,\n        viewState\n    });\n}\nfunction afterRender(deck, map) {\n    const { mapboxLayers, isExternal } = deck.userData;\n    if (isExternal) {\n        // Draw non-Mapbox layers\n        const mapboxLayerIds = Array.from(mapboxLayers, layer => layer.id);\n        const deckLayers = flatten(deck.props.layers, Boolean);\n        const hasNonMapboxLayers = deckLayers.some(layer => layer && !mapboxLayerIds.includes(layer.id));\n        let viewports = deck.getViewports();\n        const mapboxViewportIdx = viewports.findIndex(vp => vp.id === MAPBOX_VIEW_ID);\n        const hasNonMapboxViews = viewports.length > 1 || mapboxViewportIdx < 0;\n        if (hasNonMapboxLayers || hasNonMapboxViews) {\n            if (mapboxViewportIdx >= 0) {\n                viewports = viewports.slice();\n                viewports[mapboxViewportIdx] = getViewport(deck, map);\n            }\n            deck._drawLayers('mapbox-repaint', {\n                viewports,\n                layerFilter: params => (!deck.props.layerFilter || deck.props.layerFilter(params)) &&\n                    (params.viewport.id !== MAPBOX_VIEW_ID || !mapboxLayerIds.includes(params.layer.id)),\n                clearCanvas: false\n            });\n        }\n    }\n    // End of render cycle, clear generated viewport\n    deck.userData.currentViewport = null;\n}\nfunction onMapMove(deck, map) {\n    deck.setProps({\n        viewState: getViewState(map)\n    });\n    // Camera changed, will trigger a map repaint right after this\n    // Clear any change flag triggered by setting viewState so that deck does not request\n    // a second repaint\n    deck.needsRedraw({ clearRedrawFlags: true });\n}\nfunction updateLayers(deck) {\n    if (deck.userData.isExternal) {\n        return;\n    }\n    const layers = [];\n    deck.userData.mapboxLayers.forEach(deckLayer => {\n        const LayerType = deckLayer.props.type;\n        const layer = new LayerType(deckLayer.props);\n        layers.push(layer);\n    });\n    deck.setProps({ layers });\n}\n//# sourceMappingURL=deck-utils.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getDeckInstance, addLayer, removeLayer, updateLayer, drawLayer } from \"./deck-utils.js\";\nexport default class MapboxLayer {\n    /* eslint-disable no-this-before-super */\n    constructor(props) {\n        if (!props.id) {\n            throw new Error('Layer must have an unique id');\n        }\n        this.id = props.id;\n        this.type = 'custom';\n        this.renderingMode = props.renderingMode || '3d';\n        this.slot = props.slot;\n        this.map = null;\n        this.deck = null;\n        this.props = props;\n    }\n    /* Mapbox custom layer methods */\n    onAdd(map, gl) {\n        this.map = map;\n        this.deck = getDeckInstance({ map, gl, deck: this.props.deck });\n        addLayer(this.deck, this);\n    }\n    onRemove() {\n        if (this.deck) {\n            removeLayer(this.deck, this);\n        }\n    }\n    setProps(props) {\n        // id cannot be changed\n        Object.assign(this.props, props, { id: this.id });\n        // safe guard in case setProps is called before onAdd\n        if (this.deck) {\n            updateLayer(this.deck, this);\n        }\n    }\n    render(gl, renderParameters) {\n        drawLayer(this.deck, this.map, this, renderParameters);\n    }\n}\n//# sourceMappingURL=mapbox-layer.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { _flatten as flatten } from '@deck.gl/core';\nimport MapboxLayer from \"./mapbox-layer.js\";\nconst UNDEFINED_BEFORE_ID = '__UNDEFINED__';\n/** Insert Deck layers into the mapbox Map according to the user-defined order */\n// eslint-disable-next-line complexity, max-statements\nexport function resolveLayers(map, deck, oldLayers, newLayers) {\n    // Wait until map style is loaded\n    // @ts-ignore non-public map property\n    if (!map || !deck || !map.style || !map.style._loaded) {\n        return;\n    }\n    const layers = flatten(newLayers, Boolean);\n    if (oldLayers !== newLayers) {\n        // Step 1: remove layers that no longer exist\n        const prevLayers = flatten(oldLayers, Boolean);\n        const prevLayerIds = new Set(prevLayers.map(l => l.id));\n        for (const layer of layers) {\n            prevLayerIds.delete(layer.id);\n        }\n        for (const id of prevLayerIds) {\n            if (map.getLayer(id)) {\n                map.removeLayer(id);\n            }\n        }\n    }\n    // Step 2: add missing layers\n    for (const layer of layers) {\n        const mapboxLayer = map.getLayer(layer.id);\n        if (mapboxLayer) {\n            // Mapbox's map.getLayer() had a breaking change in v3.6.0, see https://github.com/visgl/deck.gl/issues/9086\n            // @ts-expect-error not typed\n            const layerInstance = mapboxLayer.implementation || mapboxLayer;\n            layerInstance.setProps(layer.props);\n        }\n        else {\n            map.addLayer(new MapboxLayer({\n                id: layer.id,\n                deck,\n                // @ts-expect-error slot is not defined in LayerProps\n                slot: layer.props.slot\n            }), \n            // @ts-expect-error beforeId is not defined in LayerProps\n            layer.props.beforeId);\n        }\n    }\n    // Step 3: check the order of layers\n    // If beforeId is defined, the deck layer should always render before the mapbox layer [beforeId]\n    // If beforeId is not defined, the deck layer should appear after all mapbox layers\n    // When two deck layers share the same beforeId, they are rendered in the order that is passed into Deck props.layers\n    // @ts-ignore non-public map property\n    const mapLayers = map.style._order;\n    // Group deck layers by beforeId\n    const layerGroups = {};\n    for (const layer of layers) {\n        // @ts-expect-error beforeId is not defined in LayerProps\n        let { beforeId } = layer.props;\n        if (!beforeId || !mapLayers.includes(beforeId)) {\n            beforeId = UNDEFINED_BEFORE_ID;\n        }\n        layerGroups[beforeId] = layerGroups[beforeId] || [];\n        layerGroups[beforeId].push(layer.id);\n    }\n    for (const beforeId in layerGroups) {\n        const layerGroup = layerGroups[beforeId];\n        let lastLayerIndex = beforeId === UNDEFINED_BEFORE_ID ? mapLayers.length : mapLayers.indexOf(beforeId);\n        let lastLayerId = beforeId === UNDEFINED_BEFORE_ID ? undefined : beforeId;\n        for (let i = layerGroup.length - 1; i >= 0; i--) {\n            const layerId = layerGroup[i];\n            const layerIndex = mapLayers.indexOf(layerId);\n            if (layerIndex !== lastLayerIndex - 1) {\n                map.moveLayer(layerId, lastLayerId);\n                if (layerIndex > lastLayerIndex) {\n                    // The last layer's index have changed\n                    lastLayerIndex++;\n                }\n            }\n            lastLayerIndex--;\n            lastLayerId = layerId;\n        }\n    }\n}\n//# sourceMappingURL=resolve-layers.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getDeckInstance, drawLayerGroup } from \"./deck-utils.js\";\nimport { assert } from '@deck.gl/core';\nexport default class MapboxLayerGroup {\n    /* eslint-disable no-this-before-super */\n    constructor(props) {\n        assert(props.id, 'id is required');\n        this.id = props.id;\n        this.type = 'custom';\n        this.renderingMode = props.renderingMode || '3d';\n        this.slot = props.slot;\n        this.beforeId = props.beforeId;\n        this.map = null;\n        this.deck = null;\n    }\n    /* Mapbox custom layer methods */\n    onAdd(map, gl) {\n        this.map = map;\n        this.deck = getDeckInstance({ map, gl });\n    }\n    render(gl, renderParameters) {\n        if (!this.deck || !this.map)\n            return;\n        drawLayerGroup(this.deck, this.map, this, renderParameters);\n    }\n}\n//# sourceMappingURL=mapbox-layer-group.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { _flatten as flatten } from '@deck.gl/core';\nimport MapboxLayerGroup from \"./mapbox-layer-group.js\";\nconst UNDEFINED_BEFORE_ID = '__UNDEFINED__';\nfunction getLayerGroupId(layer) {\n    if (layer.props.beforeId) {\n        return `deck-layer-group-before:${layer.props.beforeId}`;\n    }\n    else if (layer.props.slot) {\n        return `deck-layer-group-slot:${layer.props.slot}`;\n    }\n    return 'deck-layer-group-last';\n}\n/** Group Deck layers into buckets (by beforeId or slot) and insert them\n *  into the mapbox Map according to the user-defined order\n **/\n// eslint-disable-next-line complexity, max-statements\nexport function resolveLayerGroups(map, oldLayers, newLayers) {\n    // Wait until map style is loaded\n    // @ts-ignore non-public map property\n    if (!map || !map.style || !map.style._loaded) {\n        return;\n    }\n    const layers = flatten(newLayers, Boolean);\n    if (oldLayers !== newLayers) {\n        // Step 1: remove \"group\" layers that no longer exist\n        const prevLayers = flatten(oldLayers, Boolean);\n        const prevLayerGroupIds = new Set(prevLayers.map(l => getLayerGroupId(l)));\n        const newLayerGroupIds = new Set(layers.map(l => getLayerGroupId(l)));\n        for (const groupId of prevLayerGroupIds) {\n            if (!newLayerGroupIds.has(groupId)) {\n                if (map.getLayer(groupId)) {\n                    map.removeLayer(groupId);\n                }\n            }\n        }\n    }\n    // Step 2: add missing \"group\" layers\n    const layerGroups = {};\n    for (const layer of layers) {\n        const groupId = getLayerGroupId(layer);\n        const mapboxGroup = map.getLayer(groupId);\n        if (mapboxGroup) {\n            // Mapbox's map.getLayer() had a breaking change in v3.6.0, see https://github.com/visgl/deck.gl/issues/9086\n            // @ts-expect-error not typed\n            const groupInstance = mapboxGroup.implementation || mapboxGroup;\n            layerGroups[groupId] = groupInstance;\n        }\n        else {\n            const newGroup = new MapboxLayerGroup({\n                id: groupId,\n                slot: layer.props.slot,\n                beforeId: layer.props.beforeId\n            });\n            layerGroups[groupId] = newGroup;\n            map.addLayer(newGroup, layer.props.beforeId);\n        }\n    }\n    // Step 3: check the order of layers\n    // If beforeId move \"group\" layers to proper position in the mapbox layer order\n    // @ts-ignore non-public map property\n    const mapLayers = map.style._order;\n    for (const [groupId, group] of Object.entries(layerGroups)) {\n        const beforeId = group.beforeId || UNDEFINED_BEFORE_ID;\n        const expectedGroupIndex = beforeId === UNDEFINED_BEFORE_ID ? mapLayers.length : mapLayers.indexOf(beforeId);\n        const currentGropupIndex = mapLayers.indexOf(groupId);\n        if (currentGropupIndex !== expectedGroupIndex - 1) {\n            const moveBeforeId = beforeId === UNDEFINED_BEFORE_ID ? undefined : beforeId;\n            map.moveLayer(groupId, moveBeforeId);\n        }\n    }\n}\n//# sourceMappingURL=resolve-layer-groups.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Deck, assert } from '@deck.gl/core';\nimport { getViewState, getDefaultView, getDeckInstance, removeDeckInstance, getDefaultParameters, getProjection } from \"./deck-utils.js\";\nimport { log } from '@deck.gl/core';\nimport { resolveLayers } from \"./resolve-layers.js\";\nimport { resolveLayerGroups } from \"./resolve-layer-groups.js\";\n/**\n * Implements Mapbox [IControl](https://docs.mapbox.com/mapbox-gl-js/api/markers/#icontrol) interface\n * Renders deck.gl layers over the base map and automatically synchronizes with the map's camera\n */\nexport default class MapboxOverlay {\n    constructor(props) {\n        this._handleStyleChange = () => {\n            this._resolveLayers(this._map, this._deck, this._props.layers, this._props.layers);\n            if (!this._map)\n                return;\n            // getProjection() returns undefined before style is loaded\n            const projection = getProjection(this._map);\n            if (projection && !this._props.views) {\n                this._deck?.setProps({ views: getDefaultView(this._map) });\n            }\n        };\n        this._updateContainerSize = () => {\n            if (this._map && this._container) {\n                const { clientWidth, clientHeight } = this._map.getContainer();\n                Object.assign(this._container.style, {\n                    width: `${clientWidth}px`,\n                    height: `${clientHeight}px`\n                });\n            }\n        };\n        this._updateViewState = () => {\n            const deck = this._deck;\n            const map = this._map;\n            if (deck && map) {\n                deck.setProps({\n                    views: this._props.views || getDefaultView(map),\n                    viewState: getViewState(map)\n                });\n                // Redraw immediately if view state has changed\n                if (deck.isInitialized) {\n                    deck.redraw();\n                }\n            }\n        };\n        // eslint-disable-next-line complexity\n        this._handleMouseEvent = (event) => {\n            const deck = this._deck;\n            if (!deck || !deck.isInitialized) {\n                return;\n            }\n            const mockEvent = {\n                type: event.type,\n                offsetCenter: event.point,\n                srcEvent: event\n            };\n            const lastDown = this._lastMouseDownPoint;\n            if (!event.point && lastDown) {\n                // drag* events do not contain a `point` field\n                mockEvent.deltaX = event.originalEvent.clientX - lastDown.clientX;\n                mockEvent.deltaY = event.originalEvent.clientY - lastDown.clientY;\n                mockEvent.offsetCenter = {\n                    x: lastDown.x + mockEvent.deltaX,\n                    y: lastDown.y + mockEvent.deltaY\n                };\n            }\n            switch (mockEvent.type) {\n                case 'mousedown':\n                    deck._onPointerDown(mockEvent);\n                    this._lastMouseDownPoint = {\n                        ...event.point,\n                        clientX: event.originalEvent.clientX,\n                        clientY: event.originalEvent.clientY\n                    };\n                    break;\n                case 'dragstart':\n                    mockEvent.type = 'panstart';\n                    deck._onEvent(mockEvent);\n                    break;\n                case 'drag':\n                    mockEvent.type = 'panmove';\n                    deck._onEvent(mockEvent);\n                    break;\n                case 'dragend':\n                    mockEvent.type = 'panend';\n                    deck._onEvent(mockEvent);\n                    break;\n                case 'click':\n                    mockEvent.tapCount = 1;\n                    deck._onEvent(mockEvent);\n                    break;\n                case 'dblclick':\n                    mockEvent.type = 'click';\n                    mockEvent.tapCount = 2;\n                    deck._onEvent(mockEvent);\n                    break;\n                case 'mousemove':\n                    mockEvent.type = 'pointermove';\n                    deck._onPointerMove(mockEvent);\n                    break;\n                case 'mouseout':\n                    mockEvent.type = 'pointerleave';\n                    deck._onPointerMove(mockEvent);\n                    break;\n                default:\n                    return;\n            }\n        };\n        const { interleaved = false } = props;\n        this._interleaved = interleaved;\n        this._renderLayersInGroups = props._renderLayersInGroups || false;\n        this._props = this.filterProps(props);\n    }\n    /** Filter out props to pass to Deck **/\n    filterProps(props) {\n        const { interleaved = false, useDevicePixels, ...deckProps } = props;\n        if (!interleaved && useDevicePixels !== undefined) {\n            // useDevicePixels cannot be used in interleaved mode\n            deckProps.useDevicePixels = useDevicePixels;\n        }\n        return deckProps;\n    }\n    /** Update (partial) props of the underlying Deck instance. */\n    setProps(props) {\n        if (this._interleaved && props.layers) {\n            this._resolveLayers(this._map, this._deck, this._props.layers, props.layers);\n        }\n        Object.assign(this._props, this.filterProps(props));\n        if (this._deck && this._map) {\n            this._deck.setProps({\n                ...this._props,\n                parameters: {\n                    ...getDefaultParameters(this._map, this._interleaved),\n                    ...this._props.parameters\n                }\n            });\n        }\n    }\n    // The local Map type is for internal typecheck only. It does not necesarily satisefy mapbox/maplibre types at runtime.\n    // Do not restrict the argument type here to avoid type conflict.\n    /** Called when the control is added to a map */\n    onAdd(map) {\n        this._map = map;\n        return this._interleaved ? this._onAddInterleaved(map) : this._onAddOverlaid(map);\n    }\n    _onAddOverlaid(map) {\n        /* global document */\n        const container = document.createElement('div');\n        Object.assign(container.style, {\n            position: 'absolute',\n            left: 0,\n            top: 0,\n            textAlign: 'initial',\n            pointerEvents: 'none'\n        });\n        this._container = container;\n        this._deck = new Deck({\n            ...this._props,\n            parent: container,\n            parameters: { ...getDefaultParameters(map, false), ...this._props.parameters },\n            views: this._props.views || getDefaultView(map),\n            viewState: getViewState(map)\n        });\n        map.on('resize', this._updateContainerSize);\n        map.on('render', this._updateViewState);\n        map.on('mousedown', this._handleMouseEvent);\n        map.on('dragstart', this._handleMouseEvent);\n        map.on('drag', this._handleMouseEvent);\n        map.on('dragend', this._handleMouseEvent);\n        map.on('mousemove', this._handleMouseEvent);\n        map.on('mouseout', this._handleMouseEvent);\n        map.on('click', this._handleMouseEvent);\n        map.on('dblclick', this._handleMouseEvent);\n        this._updateContainerSize();\n        return container;\n    }\n    _onAddInterleaved(map) {\n        // @ts-ignore non-public map property\n        const gl = map.painter.context.gl;\n        if (gl instanceof WebGLRenderingContext) {\n            log.warn('Incompatible basemap library. See: https://deck.gl/docs/api-reference/mapbox/overview#compatibility')();\n        }\n        this._deck = getDeckInstance({\n            map,\n            gl,\n            deck: new Deck({\n                ...this._props,\n                gl,\n                parameters: { ...getDefaultParameters(map, true), ...this._props.parameters }\n            })\n        });\n        map.on('styledata', this._handleStyleChange);\n        this._resolveLayers(map, this._deck, [], this._props.layers);\n        return document.createElement('div');\n    }\n    _resolveLayers(map, deck, prevLayers, newLayers) {\n        if (this._renderLayersInGroups) {\n            resolveLayerGroups(map, prevLayers, newLayers);\n        }\n        else {\n            resolveLayers(map, deck, prevLayers, newLayers);\n        }\n    }\n    /** Called when the control is removed from a map */\n    onRemove() {\n        const map = this._map;\n        if (map) {\n            if (this._interleaved) {\n                this._onRemoveInterleaved(map);\n            }\n            else {\n                this._onRemoveOverlaid(map);\n            }\n        }\n        this._deck = undefined;\n        this._map = undefined;\n        this._container = undefined;\n    }\n    _onRemoveOverlaid(map) {\n        map.off('resize', this._updateContainerSize);\n        map.off('render', this._updateViewState);\n        map.off('mousedown', this._handleMouseEvent);\n        map.off('dragstart', this._handleMouseEvent);\n        map.off('drag', this._handleMouseEvent);\n        map.off('dragend', this._handleMouseEvent);\n        map.off('mousemove', this._handleMouseEvent);\n        map.off('mouseout', this._handleMouseEvent);\n        map.off('click', this._handleMouseEvent);\n        map.off('dblclick', this._handleMouseEvent);\n        this._deck?.finalize();\n    }\n    _onRemoveInterleaved(map) {\n        map.off('styledata', this._handleStyleChange);\n        this._resolveLayers(map, this._deck, this._props.layers, []);\n        removeDeckInstance(map);\n    }\n    getDefaultPosition() {\n        return 'top-left';\n    }\n    /** Forwards the Deck.pickObject method */\n    pickObject(params) {\n        assert(this._deck);\n        return this._deck.pickObject(params);\n    }\n    /** Forwards the Deck.pickMultipleObjects method */\n    pickMultipleObjects(params) {\n        assert(this._deck);\n        return this._deck.pickMultipleObjects(params);\n    }\n    /** Forwards the Deck.pickObjects method */\n    pickObjects(params) {\n        assert(this._deck);\n        return this._deck.pickObjects(params);\n    }\n    /** Remove from map and releases all resources */\n    finalize() {\n        if (this._map) {\n            this._map.removeControl(this);\n        }\n    }\n    /** If interleaved: true, returns base map's canvas, otherwise forwards the Deck.getCanvas method. */\n    getCanvas() {\n        if (!this._map) {\n            return null;\n        }\n        return this._interleaved ? this._map.getCanvas() : this._deck.getCanvas();\n    }\n}\n//# sourceMappingURL=mapbox-overlay.js.map"],"mappings":";;;;AAGA,MAAaA,YAA2C;;;;ACDxD,IAAM,iBAAiB,WAAW,SAAS;AAC3C,IAAM,kBAAkB,OAAO,UAAU;AACzC,IAAM,yBAAyB,OAAO,gBAAgB;AAEtD,IAAM,iBAAiBC,cAAY,OADN,QAAQ,eAAe;;;;;AAMpD,SAAgB,qBAAqB,MAAM;AACvC,SAAQ,MAAR;EACI,KAAK,OAED,QAAO,0BAA0B,mBAAmB;EACxD,KAAK,cACD,QAAO;EACX,KAAK,QACD,QAAO;EACX,KAAK,OACD,QAAO;EACX,QACI,OAAM,IAAI,MAAM,6BAA6B,KAAK,oCAAoC;;;;;;;AAOlG,SAAgB,sBAAsB;AAClC,KAAI,uBACA,QAAO;AAEX,KAAI,gBACA,QAAO;AAEX,KAAI,eACA,QAAO;AAGX,OAAM,IAAI,MAAM,gEAAkE;;;;;AC7BtF,SAAgB,aAAa,OAAO;CAChC,MAAM,SAAS,mBAAmB,MAAM;AACxC,KAAI,CAAC,OACD,OAAM,IAAI,MAAM,eAAe;AAEnC,QAAO;;AAKX,SAAgB,aAAa,OAAO;AAChC,SAAQ,aAAa,MAAM,EAA3B;EACI,KAAK,OACD,QAAO;EACX,KAAK;EACL,KAAK;GAED,MAAM,SAAS,SAAS,cAAc,SAAS;GAE/C,MAAM,UAAU,OAAO,WAAW,KAAK;AACvC,OAAI,CAAC,QACD,OAAM,IAAI,MAAM,eAAe;AAGnC,UAAO,QAAQ,MAAM;AAErB,UAAO,SAAS,MAAM;AAEtB,WAAQ,UAAU,OAAO,GAAG,EAAE;AAE9B,UAAO,QAAQ,aAAa,GAAG,GAAG,MAAM,OAAO,MAAM,OAAO;EAChE,QACI,OAAM,IAAI,MAAM,eAAe;;;AAK3C,SAAS,mBAAmB,OAAO;AAC/B,KAAI,OAAO,gBAAgB,eAAe,iBAAiB,YACvD,QAAO;AAEX,KAAI,OAAO,UAAU,eAAe,iBAAiB,MACjD,QAAO;AAEX,KAAI,SAAS,OAAO,UAAU,YAAY,MAAM,QAAQ,MAAM,SAAS,MAAM,OACzE,QAAO;AAEX,QAAO;;;;;ACzDX,IAAM,uBAAuB;AAC7B,IAAM,kBAAkB;AACxB,SAAgB,MAAM,KAAK;AACvB,QAAO,QAAQ,qBAAqB,KAAK,IAAI,IAAI,gBAAgB,KAAK,IAAI;;AAE9E,SAAgB,oBAAoB,aAAa,KAAK;AAClD,KAAI,MAAM,IAAI,EAAE;EAGZ,IAAI,UADgB,IAAI,aAAa,CACX,OAAO,YAAY;AAE7C,MAAI;AACA,OAAI,OAAO,aAAa,cAAc,OAAO,uBAAuB,WAChE,WAAU,SAAS,mBAAmB,QAAQ,CAAC;WAGhD,OAAO;AACV,SAAM,IAAI,MAAM,MAAM,QAAQ;;AAIlC,SADY,6BAA6B,KAAK,QAAQ;;AAG1D,QAAO,QAAQ,aAAa,IAAI;;AAEpC,SAAgB,QAAQ,aAAa,KAAK;AACtC,KAAI,MAAM,IAAI,CAGV,OAAM,IAAI,MAAM,+CAA+C;AAGnE,QAAO,IAAI,KAAK,CAAC,IAAI,WAAW,YAAY,CAAC,CAAC;;;;;AChClD,eAAsB,aAAa,aAAa,SAAS,KAAK;CAI1D,MAAM,gBAAgB,oBAAoB,aAAa,IAAI;CAC3D,MAAM,MAAM,KAAK,OAAO,KAAK;CAC7B,MAAM,YAAY,OAAO,kBAAkB,YAAY,IAAI,gBAAgB,cAAc;AACzF,KAAI;AACA,SAAO,MAAM,YAAY,aAAa,eAAe,QAAQ;WAEzD;AACJ,MAAI,UACA,KAAI,gBAAgB,UAAU;;;AAI1C,eAAsB,YAAY,KAAK,SAAS;CAC5C,MAAM,QAAQ,IAAI,OAAO;AACzB,OAAM,MAAM;AAOZ,KAAI,QAAQ,SAAS,QAAQ,MAAM,UAAU,MAAM,QAAQ;AACvD,QAAM,MAAM,QAAQ;AACpB,SAAO;;AAGX,QAAO,MAAM,IAAI,SAAS,SAAS,WAAW;AAC1C,MAAI;AACA,SAAM,eAAe,QAAQ,MAAM;AACnC,SAAM,WAAW,UAAU;IACvB,MAAM,UAAU,iBAAiB,QAAQ,MAAM,UAAU;AACzD,WAAO,IAAI,MAAM,QAAQ,CAAC;;WAG3B,OAAO;AACV,UAAO,MAAM;;GAEnB;;;;;ACzCN,IAAM,eAAe,EAAE;AACvB,IAAI,8BAA8B;;;;;;;;AAQlC,eAAsB,mBAAmB,aAAa,SAAS,KAAK;CAChE,IAAI;AAEJ,KAAI,MAAM,IAAI,CAGV,QADc,MAAM,aAAa,aAAa,SAAS,IAAI;KAK3D,QAAO,QAAQ,aAAa,IAAI;CAEpC,MAAM,qBAAqB,WAAW,QAAQ;AAC9C,QAAO,MAAM,sBAAsB,MAAM,mBAAmB;;;;;;;;AAQhE,eAAe,sBAAsB,MAAM,qBAAqB,MAAM;AAClE,KAAI,cAAc,mBAAmB,IAAI,CAAC,4BACtC,sBAAqB;AAEzB,KAAI,mBACA,KAAI;AAEA,SAAO,MAAM,kBAAkB,MAAM,mBAAmB;UAErD,OAAO;AACV,UAAQ,KAAK,MAAM;AACnB,gCAA8B;;AAGtC,QAAO,MAAM,kBAAkB,KAAK;;AAExC,SAAS,cAAc,QAAQ;AAE3B,MAAK,MAAM,OAAO,UAAU,aACxB,QAAO;AAEX,QAAO;;;;;;;;;AC7CX,SAAgB,oBAAoB,QAAQ;AAExC,KAAI,CAAC,YAAY,QAAQ,QAAQ,EAAE,CAC/B,QAAO;AAGX,MAAK,OAAO,KAAK,QAAU,EACvB,QAAO;AAGX,QAAO,iBAAiB,OAAO;;;;;;AAMnC,SAAgB,iBAAiB,QAAQ;AAErC,SADmB,cAAc,QAAQ,GAAG,GAAG,CAAC,QAAQ,MAAM,IAAI,CAAC,MAAM,EACzE;EACI,KAAK;EACL,KAAK,OACD,QAAO;GAAE,WAAW;GAAQ,UAAU;GAAc;EACxD,QACI,QAAO;;;;AA6CnB,SAAS,cAAc,OAAO,OAAO,KAAK;AACtC,QAAO,OAAO,aAAa,GAAG,MAAM,MAAM,OAAO,IAAI,CAAC;;AAE1D,SAAS,cAAc,QAAQ;AAC3B,QAAO,CAAC,GAAG,OAAO,CAAC,KAAK,cAAc,UAAU,WAAW,EAAE,CAAC;;AAElE,SAAS,YAAY,QAAQ,QAAQ,SAAS,GAAG;CAC7C,MAAM,cAAc,cAAc,OAAO;AACzC,MAAK,IAAI,IAAI,GAAG,IAAI,YAAY,QAAQ,EAAE,EACtC,KAAI,YAAY,OAAO,OAAO,IAAI,QAC9B,QAAO;AAGf,QAAO;;;;;ACtFX,IAAM,aAAa;AACnB,IAAM,gBAAgB;;;;;;;AAOtB,SAAgB,uBAAuB,YAAY;CAC/C,MAAM,WAAW,WAAW,WAAW;AACvC,QAAQ,eAAe,SAAS,IAC5B,gBAAgB,SAAS,IACzB,eAAe,SAAS,IACxB,eAAe,SAAS,IACxB,mBAAmB,SAAS;;AAGpC,SAAS,mBAAmB,YAAY;CAEpC,MAAM,YAAY,oBADH,IAAI,WAAW,sBAAsB,WAAW,WAAW,SAAS,WAAW,CACjD;AAC7C,KAAI,CAAC,UACD,QAAO;AAEX,QAAO;EACH,UAAU,UAAU;EAEpB,OAAO;EACP,QAAQ;EACX;;AAGL,SAAS,eAAe,YAAY;CAChC,MAAM,WAAW,WAAW,WAAW;AAGvC,KAAI,EADU,SAAS,cAAc,MAAM,SAAS,UAAU,GAAG,WAAW,KAAK,YAE7E,QAAO;AAGX,QAAO;EACH,UAAU;EACV,OAAO,SAAS,UAAU,IAAI,WAAW;EACzC,QAAQ,SAAS,UAAU,IAAI,WAAW;EAC7C;;AAKL,SAAS,eAAe,YAAY;CAChC,MAAM,WAAW,WAAW,WAAW;AAGvC,KAAI,EADU,SAAS,cAAc,MAAM,SAAS,UAAU,GAAG,WAAW,KAAK,YAE7E,QAAO;AAGX,QAAO;EACH,UAAU;EACV,OAAO,SAAS,UAAU,GAAG,cAAc;EAC3C,QAAQ,SAAS,UAAU,GAAG,cAAc;EAC/C;;AAIL,SAAgB,eAAe,YAAY;CACvC,MAAM,WAAW,WAAW,WAAW;AAMvC,KAAI,EAHU,SAAS,cAAc,MACjC,SAAS,UAAU,GAAG,WAAW,KAAK,SACtC,SAAS,UAAU,GAAG,cAAc,KAAK,SAAS,YAElD,QAAO;AAGX,QAAO;EACH,UAAU;EACV,OAAO,SAAS,UAAU,IAAI,cAAc;EAC5C,QAAQ,SAAS,UAAU,IAAI,cAAc;EAChD;;AAIL,SAAS,gBAAgB,YAAY;CACjC,MAAM,WAAW,WAAW,WAAW;AAMvC,KAAI,EAHW,SAAS,cAAc,KAClC,SAAS,UAAU,GAAG,WAAW,KAAK,SACtC,SAAS,SAAS,EAAE,KAAK,KAEzB,QAAO;CAEX,MAAM,EAAE,cAAc,eAAe,gBAAgB;CAErD,IAAI,IAAI;AACR,QAAO,IAAI,IAAI,SAAS,YAAY;EAChC,MAAM,SAAS,SAAS,UAAU,GAAG,WAAW;AAEhD,MAAI,WAAW,IAAI,OAAO,CACtB,QAAO;GACH,UAAU;GACV,QAAQ,SAAS,UAAU,IAAI,GAAG,WAAW;GAC7C,OAAO,SAAS,UAAU,IAAI,GAAG,WAAW;GAC/C;AAGL,MAAI,CAAC,aAAa,IAAI,OAAO,CACzB,QAAO;AAGX,OAAK;AACL,OAAK,SAAS,UAAU,GAAG,WAAW;;AAE1C,QAAO;;AAEX,SAAS,iBAAiB;CAGtB,MAAM,eAAe,IAAI,IAAI;EAAC;EAAQ;EAAQ;EAAQ;EAAQ;EAAO,CAAC;AACtE,MAAK,IAAI,IAAI,OAAQ,IAAI,OAAQ,EAAE,EAC/B,cAAa,IAAI,EAAE;AAQvB,QAAO;EAAE;EAAc,YAJJ,IAAI,IAAI;GACvB;GAAQ;GAAQ;GAAQ;GAAQ;GAAQ;GAAQ;GAAQ;GAAQ;GAAQ;GAAQ;GAAQ;GACxF;GAAQ;GACX,CAAC;EACiC;;AAGvC,SAAS,WAAW,MAAM;AACtB,KAAI,gBAAgB,SAChB,QAAO;AAEX,KAAI,YAAY,OAAO,KAAK,CACxB,QAAO,IAAI,SAAS,KAAK,OAAO;AAOpC,KAAI,gBAAgB,YAChB,QAAO,IAAI,SAAS,KAAK;AAE7B,OAAM,IAAI,MAAM,aAAa;;;;;ACnJjC,eAAsB,iBAAiB,aAAa,SAAS;CACzD,MAAM,EAAE,aAAa,uBAAuB,YAAY,IAAI,EAAE;CAE9D,MAAMC,mBAAiB,WAAW,SAAS;AAC3C,UAAOA,iBAAe;AAEtB,QAAO,MAAMA,iBAAe,aAAa,SAAS;;;;;ACDtD,eAAsB,WAAW,aAAa,SAAS,SAAS;AAC5D,WAAU,WAAW,EAAE;CAGvB,MAAM,aAFe,QAAQ,SAAS,EAAE,EAET,QAAQ;CACvC,MAAM,EAAE,QAAQ,WAAW,EAAE;CAE7B,MAAM,WAAW,qBAAqB,UAAU;CAChD,IAAI;AACJ,SAAQ,UAAR;EACI,KAAK;AACD,WAAQ,MAAM,mBAAmB,aAAa,SAAS,IAAI;AAC3D;EACJ,KAAK;AACD,WAAQ,MAAM,aAAa,aAAa,SAAS,IAAI;AACrD;EACJ,KAAK;AAED,WAAQ,MAAM,iBAAiB,aAAa,QAAQ;AACpD;EACJ,QACI,UAAO,MAAM;;AAGrB,KAAI,cAAc,OACd,SAAQ,aAAa,MAAM;AAE/B,QAAO;;AAGX,SAAS,qBAAqB,MAAM;AAChC,SAAQ,MAAR;EACI,KAAK;EACL,KAAK,OAGD,QAAO,qBAAqB;EAChC;AAEI,wBAAqB,KAAK;AAC1B,UAAO;;;;;;AC5CnB,IAAM,aAAa;CAAC;CAAO;CAAO;CAAQ;CAAO;CAAQ;CAAO;CAAO;CAAO;CAAO;AACrF,IAAM,aAAa;CACf;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACH;AACD,IAAM,+BAA+B,EACjC,OAAO;CACH,MAAM;CACN,QAAQ;CACX,EAEJ;;;;;AAKD,MAAa,cAAc;CACvB,UAAU;CACV,WAAW;CACX,IAAI;CACJ,QAAQ;CACR,MAAM;CACN,SAASC;CACT,WAAW;CACX,YAAY;CACZ,OAAO;CAEP,OAAO,EAAE,gBAAgB,QAAQ,uBAAuB,IAAI,SAAS,YAAY,CAAC,CAAC,CAAC;CACpF,SAAS;CACZ;;;;ACpCD,SAAS,OAAO,MAAM;CAClB,MAAM,YAAY,KAAK;CACvB,MAAM,WAAW,KAAK,KAAK,SAAS;AACpC,QAAQ,cAAc,OAAO,aAAa,OAAS,cAAc,OAAO,aAAa;;AAGzF,0BAAe;CACX,UAAU;CACV,WAAW;CACX,IAAI;CACJ,MAAM;CACN,QAAQ;CACR,SAAS;CACT,SAAS,EAAE;CACX,YAAY,CAAC,QAAQ,UAAU;CAC/B,WAAW,CAAC,oBAAoB,uBAAuB;CACvD,UAAU;CACV,eAAe,KAAK;CACvB;;;;ACbD,SAAS,eAAe;CAGpB,MAAM,UACA;CAEN,MAAM,kBAAkB,WAAW,QAAQ,WAAW,KAAK;AAC3D,KAAI,mBAAmB,oBAAoB,QACvC,OAAM,IAAI,MAAM,yCAAyC,gBAAgB,MAAM,UAAU;AAE7F,KAAI,CAAC,iBAAiB;AAClB,cAAI,IAAI,GAAG,WAAW,UAAU,EAAE;AAClC,aAAW,OAAO;GACd,GAAG,WAAW;GACd,SAAS;GACT;GACA;GAEA,kBAAkB;GACrB;AACD,kBAAgB,CACZC,qBAEA,CAAC,aAAa,EAAE,aAAa,EAAE,kBAAkB,QAAQ,EAAE,CAAC,CAC/D,CAAC;;AAEN,QAAO;;AAEX,MAAa,UAAU,cAAc;;;;AC9BrC,IAAM,kBAAkB;AACxB,IAAM,gBAAgB;;;;;;AAMtB,IAAa,OAAb,MAAa,KAAK;CACd,OAAO,eAAe;EAClB,GAAG,OAAO;EACV,MAAM;EACN,UAAU;EACV,iBAAiB;EACpB;;CAED,QAAQ;;;;;;;;CAQR,MAAM;;CAEN,UAGiC;CACjC;CACA,wCAAwB,IAAI,KAAK;CACjC,cAAc;AACV,MAAI,WAAW,MAAM;AACjB,OAAI,WAAW,KAAK,YAAY,KAAK,SAAS;AAC1C,QAAI,MAAM,iBAAiB,WAAW,KAAK,QAAQ,qBAAqB,KAAK,UAAU,EAAE;AACzF,QAAI,MAAM,wEAAwE,EAAE;AACpF,UAAM,IAAI,MAAM,wDAAwD;;AAE5E,OAAI,MAAM,uDAAuD,EAAE;;AAEvE,MAAI,IAAI,GAAG,GAAG,KAAK,QAAQ,KAAK,kBAAkB,EAAE;AACpD,aAAW,OAAO;;;CAGtB,MAAM,aAAa,SAAS,EAAE,EAAE;EAC5B,MAAM,QAAQ;GAAE,GAAG,KAAK;GAAc,GAAG;GAAQ;EACjD,MAAM,UAAU,KAAK,cAAc,MAAM,MAAM,MAAM,SAAS;AAC9D,MAAI,CAAC,QACD,OAAM,IAAI,MAAM,cAAc;AAGlC,MAAI,MAAM,gBACN,OAAM,QAAQ;AAElB,SAAO,MAAM,QAAQ,OAAO,MAAM;;;;;;CAMtC,MAAM,aAAa,QAAQ,OAAO;EAC9B,MAAM,OAAO,KAAK,mBAAmB,QAAQ,MAAM,SAAS;EAC5D,MAAM,UAAU,QAAQ,KAAK,cAAc,MAAM,MAAM,SAAS;AAChE,MAAI,CAAC,QACD,OAAM,IAAI,MAAM,cAAc;AAElC,SAAO,MAAM,SAAS,SAAS,QAAQ,MAAM;;;;;;CAMjD,iBAAiB,UAAU;AACvB,OAAK,MAAM,eAAe,SACtB,MAAK,sBAAsB,IAAI,YAAY,MAAM,YAAY;;;CAIrE,qBAAqB,WAAW,EAAE,EAAE;EAChC,MAAM,aAAa,KAAK,eAAe,SAAS;AAChD,SAAO,MAAM,KAAK,WAAW,CACxB,KAAK,GAAG,aAAa,QAAQ,CAC7B,QAAO,YAAW,QAAQ,eAAe,CAAC,CAC1C,KAAI,YAAW,QAAQ,KAAK;;;CAGrC,4BAA4B,WAAW,EAAE,EAAE;EACvC,MAAM,iBAAiB;GAAC;GAAU;GAAS;GAAO;EAClD,MAAM,aAAa,KAAK,eAAe,SAAS;AAChD,OAAK,MAAM,QAAQ,eACf,KAAI,WAAW,IAAI,KAAK,EAAE,eAAe,CACrC,QAAO;AAGf,SAAO;;;CAGX,cAAc,MAAM,WAAW,EAAE,EAAE;EAC/B,IAAI,eAAe;AACnB,MAAI,SAAS,iBACT,gBAAe,KAAK,4BAA4B,SAAS;EAE7D,MAAM,aAAa,KAAK,eAAe,SAAS;AAChD,SAAQ,gBAAgB,WAAW,IAAI,aAAa,IAAK;;;;;;CAM7D,cAAc,UAAU,MAAM,WAAW,EAAE,EAAE;EAEzC,MAAMC,kBADa,KAAK,eAAe,SAAS,CACf,IAAI,QAAQ;AAC7C,MAAI,CAACA,gBACD,KAAI,KAAK,yCAAyC,EAAE;AAExD,mBAAe,gBAAgB,QAAQ;;;CAI3C,sBAAsB,OAAO;AACzB,SAAO,OAAO,KAAK,cAAc,MAAM;;;CAI3C,eAAe,WAAW,EAAE,EAAE;EAC1B,MAAM,MAAM,IAAI,IAAI,KAAK,sBAAsB;AAC/C,OAAK,MAAM,WAAW,SAClB,KAAI,IAAI,QAAQ,MAAM,QAAQ;AAElC,SAAO;;;CAGX,mBAAmB,QAAQ,WAAW,EAAE,EAAE;AAGtC,MAAI,kBAAkB,uBAClB,QAAO;AAEX,MAAI,OAAO,cAAc,eAAe,kBAAkB,UACtD,QAAO;AAGX,MAAI,QAAQ,MACR,QAAO;AAGX,MAAI,WAAW,KACX,QAAO;AAEX,MAAI,kBAAkB,sBAClB,KAAI,KAAK,2BAA2B,OAAO,EAAE;MAG7C,KAAI,KAAK,uBAAuB,OAAO,EAAE;AAE7C,SAAO;;;;;;;;AAQf,MAAa,OAAO,IAAI,MAAM;;;;;;;AClK9B,IAAa,UAAb,MAAqB;;;;;;;;CAQjB,IAAI,aAAa;AACb,SAAO,oBAAoB;;;AAInC,IAAM,SAAS,WAAW,IAAI,OAAO,aAAa;AAClD,IAAM,qBAAqB,UAAU,SAAS,eAAe;AAC7D,IAAI,kBAAkB;;AAEtB,SAAS,qBAAqB;AAC1B,KAAI,CAAC,gBACD,KAAI,cAAc,IAAI,OAAO,WAAW,YACpC,mBAAkB,QAAQ,SAAS;KAGnC,mBAAkB,IAAI,SAAQ,YAAW,OAAO,iBAAiB,cAAc,SAAS,CAAC,CAAC;AAGlG,QAAO;;;;;AC9BX,IAAMC,iBAAe;;;;;AAKrB,MAAa,gBAAgB;CACzB,MAAM;CACN,IAAIA;CACJ,IAAIA;CACJ,cAAc,UAAU;AACpB,SAAO,EAGH,SAAS,KAAK,IAAI,MAAM,SAAS,IAAI,IAAI,EAC5C;;CAEL,cAAc,EACV,SAAS,OACZ;CACJ;;;;ACdD,IAAM,eAA0B;;;;;;;;;;;;;AAwChC,IAAM,KAAK;EACT,aAAa;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4Cf,IAAM,KAAK;EACT,aAAa;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGf,IAAM,oCAAoC,QAAQ,0BAA0B;AAC5E,IAAM,oCAAoC,QAAQ,0BAA0B;AAC5E,IAAMC,yBAAuB;CAAC;CAAG;CAAG;CAAG;CAAI;AAC3C,IAAM,yBAAyB;CAAC;CAAG;CAAG;CAAG;CAAG;CAAG;CAAG;CAAG;CAAG;CAAG;CAAG;CAAG;CAAG;CAAG;CAAG;CAAG;CAAE;AAC/E,SAAS,oBAAoB,KAAK,yBAAyB;CACvD,MAAM,CAAC,GAAG,GAAG,KAAK;CAClB,MAAM,QAAQ,cAAc;EAAC;EAAG;EAAG;EAAE,EAAE,wBAAwB;AAC/D,KAAI,OAAO,SAAS,EAAE,CAClB,QAAO;AAEX,QAAO;EAAC,MAAM;EAAI,MAAM;EAAI;EAAE;;AAElC,SAAS,0BAA0B,EAAE,UAAU,UAAU;AACrD,QAAO,IAAI,QAAQ,SAAS,qBAAqB,CAAC,QAAQ,CAAC,UAAU,OAAO;;AAEhF,SAAS,0BAA0B,EAAE,UAAU,kBAAkB;CAC7D,MAAM,qBAAqB,EAAE;CAC7B,MAAM,0BAA0B,SAAS;CACzC,MAAM,OAAO,SAAS,eAAe,SAAY;CACjD,MAAM,UAAU;EACZ;GAAC;GAAG;GAAG;GAAK;EACZ;GAAC,SAAS;GAAO;GAAG;GAAK;EACzB;GAAC;GAAG,SAAS;GAAQ;GAAK;EAC1B;GAAC,SAAS;GAAO,SAAS;GAAQ;GAAK;EACvC;GAAC;GAAG;GAAG;GAAG;EACV;GAAC,SAAS;GAAO;GAAG;GAAG;EACvB;GAAC;GAAG,SAAS;GAAQ;GAAG;EACxB;GAAC,SAAS;GAAO,SAAS;GAAQ;GAAG;EACxC,CAAC,KAAI,UAEN,oBAAoB,OAAO,wBAAwB,CAAC;AACpD,MAAK,MAAM,gBAAgB,gBAAgB;EACvC,MAAM,aAAa,aAAa,OAAO,CAAC,UAAU,IAAI,QAAQ,SAAS,OAAO,CAAC,QAAQ,CAAC;EACxF,MAAM,YAAY,QAAQ,KAAI,WAAU,WAAW,UAAU,OAAO,CAAC;EACrE,MAAM,mBAAmB,IAAI,SAAS,CAAC,MAAM;GACzC,MAAM,KAAK,IAAI,GAAG,UAAU,KAAI,aAAY,SAAS,GAAG,CAAC;GACzD,OAAO,KAAK,IAAI,GAAG,UAAU,KAAI,aAAY,SAAS,GAAG,CAAC;GAC1D,QAAQ,KAAK,IAAI,GAAG,UAAU,KAAI,aAAY,SAAS,GAAG,CAAC;GAC3D,KAAK,KAAK,IAAI,GAAG,UAAU,KAAI,aAAY,SAAS,GAAG,CAAC;GACxD,MAAM,KAAK,IAAI,GAAG,UAAU,KAAI,aAAY,CAAC,SAAS,GAAG,CAAC;GAC1D,KAAK,KAAK,IAAI,GAAG,UAAU,KAAI,aAAY,CAAC,SAAS,GAAG,CAAC;GAC5D,CAAC;AACF,qBAAmB,KAAK,iBAAiB,cAAc,aAAa,CAAC;;AAEzE,QAAO;;AAIX,SAAS,qBAAqB,MAAM;CAChC,MAAM,EAAE,gBAAgB,MAAM,SAAS,iBAAiB;AACxD,KAAI,CAAC,iBAAiB,CAAC,gBAAgB,CAAC,KAAK,kBAAkB,CAAC,KAAK,eAAe,OAChF,QAAO;EACH,eAAe;EACf,cAAc;EACd,oBAAoB,KAAK;EACzB,oBAAoB,KAAK;EAC5B;CAEL,MAAM,kBAAkBC,gBAAQ,YAAY,aAAa;CACzD,MAAM,SAAS,kCAAkC;EAC7C,UAAU,aAAa;EACvB,QAAQ,gBAAgB;EAC3B,CAAC;CACF,MAAM,iBAAiB,EAAE;CACzB,MAAM,yBAAyB,kCAAkC;EAC7D,gBAAgB,KAAK;EACrB,UAAU,aAAa;EAC1B,CAAC,CAAC,OAAO;AACV,MAAK,IAAI,IAAI,GAAG,IAAI,KAAK,eAAe,QAAQ,KAAK;EACjD,MAAM,uBAAuB,uBAAuB;EACpD,MAAM,+BAA+B,qBAChC,OAAO,CACP,UAAU,IAAI,QAAQ,aAAa,SAAS,OAAO,CAAC,QAAQ,CAAC;AAClE,MAAI,gBAAgB,qBAAqB,kBAAkB,UACvD,gBAAgB,mBAAmB,gBAAgB,cAAc;AACjE,0BAAuB,KAAK;AAC5B,kBAAe,KAAK;SAEnB;AACD,0BAAuB,KAAK,qBACvB,OAAO,CACP,cAAc,uBAAuB;AAC1C,kBAAe,KAAK,6BAA6B,UAAU,OAAO;;;CAG1E,MAAM,WAAW;EACb,eAAe,QAAQ,KAAK,gBAAgB;EAC5C,cAAc,KAAK,aAAa,KAAK,WAAW,SAAS,IAAI;EAC7D,OAAO,KAAK,eAAeD;EAC3B,SAAS,KAAK,iBAAiB;EAC/B,YAAY,KAAK,eAAe;EAChC,oBAAoB,KAAK;EACzB,oBAAoB,KAAK;EAC5B;AACD,MAAK,IAAI,IAAI,GAAG,IAAI,uBAAuB,QAAQ,KAAK;AACpD,WAAS,uBAAuB,OAAO,uBAAuB;AAC9D,WAAS,gBAAgB,OAAO,eAAe;;AAEnD,MAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IACnB,UAAS,oBAAoB,OACxB,KAAK,cAAc,KAAK,WAAW,MAAO,KAAK;AAExD,QAAO;;AAEX,qBAAe;CACX,MAAM;CACN,cAAc,CAACC,gBAAQ;CACvB;CACA;CACA,QAAQ;EACJ,gCAAgC;;;EAGhC,0BAA0B;;;EAG7B;CACD,aAAa;CACb,cAAc;EACV,eAAe;EACf,cAAc;EACd,OAAO;EACP,SAAS;EACT,YAAY;EACZ,uBAAuB;EACvB,uBAAuB;EACvB,gBAAgB;EAChB,gBAAgB;EACnB;CACJ;;;;ACtND,IAAM,kBAAkB,CAACC,iBAAS;AAClC,IAAM,oBAAoB;CACtB;CACA;CACA;CACA;CACH;AACD,IAAM,oBAAoB,EAEzB;AACD,SAAgB,mBAAmB,UAAU;CACzC,MAAM,kBAAkB,gBAAgB,2BAA2B;AACnE,MAAK,MAAM,gBAAgB,gBACvB,iBAAgB,iBAAiB,aAAa;AAKlD,iBAAgB,eAAe,SAAS;CAGxC,MAAM,cAAc,aAAa,SAAS,oBAAoB;AAC9D,MAAK,MAAM,cAAc,YACrB,iBAAgB,cAAc,WAAW;AAE7C,QAAO;;;;;AClCX,IAAMC,wBAAsB;CAAC;CAAK;CAAK;CAAI;AAC3C,IAAMC,4BAA0B;AAChC,IAAIC,YAAU;AACd,IAAa,eAAb,MAA0B;CACtB,YAAY,QAAQ,EAAE,EAAE;AACpB,OAAK,OAAO;EACZ,MAAM,EAAE,QAAQF,0BAAwB;EACxC,MAAM,EAAE,YAAYC,8BAA4B;AAChD,OAAK,KAAK,MAAM,MAAM,WAAW;AACjC,OAAK,QAAQ;AACb,OAAK,YAAY;;;;;;ACTzB,IAAM,sBAAsB;CAAC;CAAK;CAAK;CAAI;AAC3C,IAAM,0BAA0B;AAChC,IAAM,0BAA0B;CAAC;CAAK;CAAK;CAAK;AAChD,IAAI,UAAU;AACd,IAAa,mBAAb,MAA8B;CAC1B,YAAY,QAAQ,EAAE,EAAE;AACpB,OAAK,OAAO;EACZ,MAAM,EAAE,QAAQ,wBAAwB;EACxC,MAAM,EAAE,YAAY,4BAA4B;EAChD,MAAM,EAAE,YAAY,4BAA4B;EAChD,MAAM,EAAE,UAAU,UAAU;AAC5B,OAAK,KAAK,MAAM,MAAM,eAAe;AACrC,OAAK,QAAQ;AACb,OAAK,YAAY;AACjB,OAAK,OAAO;AACZ,OAAK,YAAY,IAAI,QAAQ,UAAU,CAAC,WAAW,CAAC,SAAS;AAC7D,OAAK,SAAS;;CAElB,kBAAkB,MAAM;AACpB,SAAO;;;;;;;;;;;ACff,IAAqB,OAArB,MAA0B;;CAEtB,YAAY,QAAQ,QAAQ,EAAE,IAAI,QAAQ,EAAE;EACxC,MAAM,EAAE,OAAO;AACf,OAAK,KAAK;AACV,OAAK,SAAS;AACd,OAAK,QAAQ,EAAE,GAAG,OAAO;;CAE7B,SAAS,OAAO;AACZ,SAAO,OAAO,KAAK,OAAO,MAAM;;CAEpC,OAAO,QAAQ;CACf,UAAU;;;;;;ACfd,IAAqB,aAArB,cAAwC,KAAK;CACzC,cAAc;AACV,QAAM,GAAG,UAAU;AACnB,OAAK,mBAAmB;;CAE5B,OAAO,SAAS;EAEZ,MAAM,CAAC,OAAO,UAAU,KAAK,OAAO,cAAc,sBAAsB;EAExE,MAAM,cAAc,QAAQ,eAAe;EAC3C,MAAM,aAAa,QAAQ,eAAe,cAAc;GAAC;GAAG;GAAG;GAAG;GAAE,GAAG;EACvE,MAAM,aAAa,cAAc,IAAI;EACrC,MAAM,eAAe,cAAc,IAAI;EACvC,MAAM,YAAY,QAAQ,aAAa;EACvC,MAAM,aAAa,EAAE,UAAU;GAAC;GAAG;GAAG;GAAO;GAAO,EAAE;AACtD,MAAI,QAAQ,UACR,YAAW,YAAY;AAE3B,MAAI,QAAQ,YACR,YAAW,cAAc,QAAQ;EAErC,MAAM,aAAa,KAAK,OAAO,gBAAgB;GAC3C,aAAa,QAAQ;GACrB;GACY;GACZ;GACA;GACH,CAAC;AACF,MAAI;AACA,UAAO,KAAK,YAAY,YAAY,QAAQ;YAExC;AACJ,cAAW,KAAK;AAEhB,QAAK,OAAO,QAAQ;;;;CAI5B,YAAY,YAAY,SAAS;EAC7B,MAAM,EAAE,QAAQ,mBAAmB,WAAW,OAAO,kBAAkB,aAAa,SAAS;AAC7F,UAAQ,OAAO,QAAQ,QAAQ;AAC/B,MAAI,WACA,MAAK,mBAAmB;EAE5B,MAAM,cAAc,EAAE;AACtB,OAAK,MAAM,YAAY,WAAW;GAC9B,MAAM,OAAO,SAAS,MAAM,SAAS;AAErC,sBAAmB,SAAS;GAC5B,MAAM,kBAAkB,KAAK,oBAAoB,UAAU,QAAQ;GAEnE,MAAM,eAAe,SAAS,gBAAgB,CAAC,SAAS;AACxD,QAAK,MAAM,eAAe,cAAc;IACpC,MAAM,QAAQ,KAAK,sBAAsB,YAAY;KACjD;KACA;KACA,UAAU;KACV;KACA,MAAM,QAAQ;KACd,QAAQ,QAAQ;KACnB,EAAE,gBAAgB;AACnB,gBAAY,KAAK,MAAM;;;AAG/B,SAAO;;CAKX,oBAAoB,UAAU,EAAE,QAAQ,MAAM,YAAY,OAAO,aAAa,UAAU,SAAS,qBAEjG,yBAAyB,OAAO;EAC5B,MAAM,kBAAkB,EAAE;EAC1B,MAAM,gBAAgB,mBAAmB,KAAK,mBAAmB,EAAE;EACnE,MAAM,cAAc;GAChB,OAAO,OAAO;GACd;GACA;GACA,YAAY;GACZ;GACH;EACD,MAAM,mBAAmB,EAAE;AAC3B,OAAK,IAAI,aAAa,GAAG,aAAa,OAAO,QAAQ,cAAc;GAC/D,MAAM,QAAQ,OAAO;GAErB,MAAM,kBAAkB,KAAK,iBAAiB,OAAO,aAAa,aAAa,iBAAiB;GAChG,MAAM,aAAa,EAAE,iBAAiB;AACtC,OAAI,mBAAmB,CAAC,wBAAwB;AAC5C,eAAW,kBAAkB;AAI7B,eAAW,mBAAmB,cAAc,OAAO,gBAAgB;AACnE,eAAW,oBAAoB,KAAK,sBAAsB,OAAO,SAAS,MAAM,kBAAkB;AAClG,eAAW,kBAAkB;KACzB,GAAG,MAAM,QAAQ,MAAM,MAAM;KAC7B,GAAG,KAAK,mBAAmB,OAAO,YAAY,SAAS;KAC1D;;AAEL,mBAAgB,cAAc;;AAElC,SAAO;;CAMX,sBAAsB,YAAY,EAAE,QAAQ,mBAAmB,wBAAwB,MAAM,QAAQ,UAAU,QAAQ,iBAAiB;EACpI,MAAM,aAAa,cAAc,KAAK,QAAQ;GAC1C,mBAAmB;GACnB;GACA;GACH,CAAC;AACF,MAAI,MAAM;GACN,MAAM,EAAE,OAAO,YAAY,YAAY,iBAAiB,KAAK;AAC7D,OAAI,OAAO;IAEP,IAAI,aAAa;KAAC;KAAG;KAAG;KAAG;KAAE;IAC7B,IAAI,aAAa;IACjB,IAAI,eAAe;AACnB,QAAI,MAAM,QAAQ,WAAW,CACzB,cAAa,CAAC,GAAG,WAAW,MAAM,GAAG,EAAE,EAAE,WAAW,MAAM,IAAI,CAAC,KAAI,MAAK,IAAI,IAAI;aAE3E,eAAe,MACpB,cAAa;AAEjB,QAAI,eAAe,OACf,cAAa;AAEjB,QAAI,iBAAiB,OACjB,gBAAe;AAYnB,IAVwB,KAAK,OAAO,gBAAgB;KAChD,aAAa;KACb,YAAY;MACR,UAAU;MACV,aAAa;MAChB;KACD,YAAY;KACZ,YAAY;KACZ,cAAc;KACjB,CAAC,CACc,KAAK;;;EAI7B,MAAM,eAAe;GACjB,YAAY,OAAO;GACnB,cAAc;GACd,gBAAgB;GAChB,eAAe;GAClB;AACD,aAAW,cAAc,EAAE,UAAU,YAAY,CAAC;AAElD,OAAK,IAAI,aAAa,GAAG,aAAa,OAAO,QAAQ,cAAc;GAC/D,MAAM,QAAQ,OAAO;GACrB,MAAM,sBAAsB,gBAAgB;GAC5C,MAAM,EAAE,oBAAoB;AAE5B,OAAI,mBAAmB,MAAM,MAAM,SAC/B,cAAa;AAEjB,OAAI,MAAM,YACN,cAAa;AAEjB,OAAI,MAAM,cAAc,oBAAoB,iBAAiB;IACzD,MAAM,EAAE,kBAAkB,mBAAmB,oBAAoB;AAEjE,iBAAa;AACb,SAAK,mBAAmB,KAAK,IAAI,KAAK,kBAAkB,iBAAiB;AAEzE,QAAI,kBAAkB,QAClB,mBAAkB,QAAQ,WAAW;AAKzC,UAAM,QAAQ,aAAa;AAC3B,QAAI;AACA,WAAM,WAAW;MACb;MACA;MACA,UAAU,EAAE,YAAY,kBAAkB;MAC1C,YAAY;MACf,CAAC;aAEC,KAAK;AACR,WAAM,WAAW,KAAK,WAAW,MAAM,MAAM,OAAO;;;;AAIhE,SAAO;;CAIX,gBAAgB,OAAO;AACnB,SAAO;;CAEX,qBAAqB,OAAO,SAAS,wBAAwB;AACzD,SAAO;;CAEX,mBAAmB,OAAO,YAAY,UAAU;AAC5C,SAAO,MAAM,MAAM;;CAGvB,iBAAiB,OAAO,aAAa,aAAa,kBAAkB;AAEhE,MAAI,EADoB,MAAM,MAAM,WAAW,KAAK,gBAAgB,MAAM,EAEtE,QAAO;AAEX,cAAY,QAAQ;EACpB,IAAI,SAAS,MAAM;AACnB,SAAO,QAAQ;AAEX,OAAI,CAAC,OAAO,MAAM,WAAW,CAAC,OAAO,eAAe,YAAY,CAC5D,QAAO;AAEX,eAAY,QAAQ;AACpB,YAAS,OAAO;;AAEpB,MAAI,aAAa;GACb,MAAM,cAAc,YAAY,MAAM;AACtC,OAAI,EAAE,eAAe,kBACjB,kBAAiB,eAAe,YAAY,YAAY;AAE5D,OAAI,CAAC,iBAAiB,aAClB,QAAO;;AAIf,QAAM,iBAAiB,YAAY,SAAS;AAC5C,SAAO;;CAEX,sBAAsB,OAAO,SAAS,MAAM,WAAW;EAEnD,MAAM,mBAAmB,KAAK,OAAO,cAAc,kBAAkB;EACrE,MAAM,aAAa,MAAM,eAAe,qBAAqB,MAAM;EACnE,MAAM,oBAAoB;GACtB,OAAO;GACP,SAAS,EACL,UAAU,OACb;GACD,SAAS;IACL,UAAU,MAAM,QAAQ;IACxB;IACA,aAAa,WAAW;IACxB,kBAAkB,WAAW;IAC7B,kBAAkB,WAAW;IAC7B,mBAAmB,MAAM;IAC5B;GACJ;AACD,MAAI,QACA,MAAK,MAAM,UAAU,QACjB,uBAAsB,mBAAmB,OAAO,uBAAuB,OAAO,kBAAkB,CAAC;AAGzG,SAAO,sBAAsB,mBAAmB,KAAK,qBAAqB,OAAO,SAAS,kBAAkB,EAAE,UAAU;;;AAShI,SAAgB,mBAAmB,aAAa,GAAG,eAAe,EAAE,EAAE;CAClE,MAAM,YAAY,EAAE;CACpB,MAAM,qBAAqB,OAAO,YAAY;EAC1C,MAAM,gBAAgB,MAAM,MAAM;EAClC,MAAM,UAAU,MAAM;EACtB,MAAM,WAAW,MAAM,UAAU,MAAM,OAAO;EAC9C,IAAI;AACJ,MAAI,YAAY,EAAE,YAAY,cAE1B,mBAAkB,MAAM,QAAQ,MAAM;AAE1C,MAAI,YAAY,WAAW;GACvB,MAAM,WAAY,UAAU,YACxB,UAAU,aAAa,mBAAmB,aAAa,WAAW,aAAa;AACnF,WAAQ,SAAS,OAAO,QAAQ;AAChC,aAAU,WAAW;aAEhB,OAAO,SAAS,cAAc,EAAE;AACrC,WAAQ,iBAAiB,aAAa,aAAa;AAGnD,aAAU,WAAW;QAGrB,SAAQ;AAEZ,MAAI,WAAW,SAAS,WACpB,cAAa,QAAQ;AAEzB,eAAa,WAAW;AACxB,SAAO;;AAEX,QAAO;;AAGX,SAAS,cAAc,QAAQ,EAAE,mBAAmB,QAAQ,YAAY;CACpE,MAAM,aAAa,mBAAmB,SAAS,oBAE3C,OAAO,cAAc,kBAAkB;CAG3C,MAAM,GAAG,uBAAuB,OAAO,cAAc,sBAAsB;CAC3E,MAAM,SAAS,SAAS,OAAO,SAAS;CAExC,MAAM,aAAa;AACnB,QAAO;EACH,WAAW,IAAI;EACf,UAAU,WAAW,IAAI,WAAW,UAAU;EAC9C,WAAW,QAAQ;EACnB,WAAW,SAAS;EACvB;;AAEL,SAAS,sBAAsB,QAAQ,GAAG,SAAS;AAC/C,MAAK,MAAM,UAAU,QACjB,KAAI,OACA,MAAK,MAAM,OAAO,OACd,KAAI,OAAO,KACP,QAAO,OAAO,OAAO,MAAM,OAAO,KAAK;KAGvC,QAAO,OAAO,OAAO;AAKrC,QAAO;;;;;AC3UX,IAAqB,aAArB,cAAwC,WAAW;CAC/C,YAAY,QAAQ,OAAO;AACvB,QAAM,QAAQ,MAAM;EAEpB,MAAM,YAAY,OAAO,cAAc;GACnC,QAAQ;GACR,OAAO;GACP,QAAQ;GACR,SAAS;IACL,WAAW;IACX,WAAW;IACX,cAAc;IACd,cAAc;IACjB;GAGJ,CAAC;EACF,MAAM,cAAc,OAAO,cAAc;GAAE,QAAQ;GAAgB,OAAO;GAAG,QAAQ;GAAG,CAAC;AACzF,OAAK,MAAM,OAAO,kBAAkB;GAChC,IAAI;GACJ,OAAO;GACP,QAAQ;GACR,kBAAkB,CAAC,UAAU;GAE7B,wBAAwB;GAC3B,CAAC;;CAEN,SAAS;AACL,MAAI,KAAK,KAAK;AACV,QAAK,IAAI,SAAS;AAClB,QAAK,MAAM;;;CAGnB,eAAe;AACX,SAAO,KAAK,IAAI,iBAAiB,GAAG;;CAExC,OAAO,QAAQ;EACX,MAAM,SAAS,KAAK;EAEpB,MAAM,aAAa,KAAK,OAAO,cAAc,kBAAkB;EAC/D,MAAM,WAAW,OAAO,UAAU;EAClC,MAAM,QAAQ,SAAS,QAAQ;EAC/B,MAAM,SAAS,SAAS,SAAS;EACjC,MAAM,aAAa;GAAC;GAAG;GAAG;GAAG;GAAE;AAC/B,MAAI,UAAU,OAAO,SAAS,WAAW,OAAO,OAC5C,QAAO,OAAO;GAAE;GAAO;GAAQ,CAAC;AAEpC,QAAM,OAAO;GAAE,GAAG;GAAQ;GAAY;GAAQ,MAAM;GAAU,CAAC;;CAEnE,mBAAmB,OAAO,YAAY,UAAU;AAC5C,SAAO;GACH,GAAG,MAAM,MAAM;GACf,OAAO;GACP,mBAAmB;GACnB,cAAc;GACjB;;CAEL,gBAAgB,OAAO;AACnB,SAAO,MAAM,MAAM,kBAAkB;;CAEzC,qBAAqB,OAAO,SAAS,wBAAwB;AACzD,SAAO,EACH,QAAQ;GACJ,SAAS,uBAAuB;GAChC,iBAAiB;GACpB,EACJ;;;;;;AC9DT,IAAM,8BAA8B;CAChC,OAAO;EAAC;EAAK;EAAK;EAAI;CACtB,WAAW;CACd;AACD,IAAM,kCAAkC,CACpC;CACI,OAAO;EAAC;EAAK;EAAK;EAAI;CACtB,WAAW;CACX,WAAW;EAAC;EAAI;EAAG;EAAG;CACzB,EACD;CACI,OAAO;EAAC;EAAK;EAAK;EAAI;CACtB,WAAW;CACX,WAAW;EAAC;EAAG;EAAI;EAAK;CAC3B,CACJ;AACD,IAAM,uBAAuB;CAAC;CAAG;CAAG;CAAG,MAAM;CAAI;AAEjD,IAAqB,iBAArB,MAAoC;CAChC,YAAY,QAAQ,EAAE,EAAE;AACpB,OAAK,KAAK;AACV,OAAK,cAAc;AACnB,OAAK,SAAS;AACd,OAAK,oBAAoB,EAAE;AAC3B,OAAK,cAAc,EAAE;AACrB,OAAK,eAAe,EAAE;AACtB,OAAK,iBAAiB;AACtB,OAAK,SAAS,MAAM;;CAExB,MAAM,SAAS;AACX,OAAK,UAAU;EACf,MAAM,EAAE,QAAQ,SAAS;AACzB,MAAI,KAAK,UAAU,CAAC,KAAK,gBAAgB;AACrC,QAAK,oBAAoB,OAAO;AAChC,QAAK,wBAAwBE,eAAO;AACpC,QAAK,iBAAiB,OAAO,cAAc;IACvC,OAAO;IACP,QAAQ;IACX,CAAC;;;CAGV,SAAS,OAAO;AACZ,OAAK,eAAe;AACpB,OAAK,oBAAoB,EAAE;AAC3B,OAAK,cAAc,EAAE;AACrB,OAAK,MAAM,OAAO,OAAO;GACrB,MAAM,cAAc,MAAM;AAC1B,WAAQ,YAAY,MAApB;IACI,KAAK;AACD,UAAK,eAAe;AACpB;IACJ,KAAK;AACD,UAAK,kBAAkB,KAAK,YAAY;AACxC;IACJ,KAAK;AACD,UAAK,YAAY,KAAK,YAAY;AAClC;IACJ;;;AAGR,OAAK,qBAAqB;AAC1B,OAAK,SAAS,KAAK,kBAAkB,MAAK,UAAS,MAAM,OAAO;AAChE,MAAI,KAAK,QAEL,MAAK,MAAM,KAAK,QAAQ;AAE5B,OAAK,QAAQ;;CAEjB,UAAU,EAAE,QAAQ,aAAa,WAAW,kBAAkB,SAAS;AACnE,MAAI,CAAC,KAAK,OACN;AAEJ,OAAK,iBAAiB,KAAK,oBAAoB;AAC/C,OAAK,IAAI,IAAI,GAAG,IAAI,KAAK,aAAa,QAAQ,IAE1C,CADmB,KAAK,aAAa,GAC1B,OAAO;GACd;GACA;GACA;GACA;GACA;GACA,mBAAmB,EACf,QAAQ;IACJ,eAAe;IACf,gBAAgB,KAAK;IACrB,gBAAgB,KAAK;IACxB,EACJ;GACJ,CAAC;;CAGV,qBAAqB,OAAO,wBAAwB;EAChD,MAAM,cAAc,KAAK,SACnB;GACE,SAAS,uBAAuB;GAChC,YAAY,KAAK,aAAa,KAAI,eAAc,WAAW,cAAc,CAAC;GAC1E,gBAAgB,KAAK;GACrB,aAAa,KAAK;GAClB,gBAAgB,KAAK;GACxB,GACC,EAAE;EAGR,MAAM,gBAAgB;GAClB,SAAS;GACT,cAAc,KAAK;GACnB,mBAAmB,KAAK,kBAAkB,KAAI,qBAAoB,iBAAiB,kBAAkB,EAAE,OAAO,CAAC,CAAC;GAChH,aAAa,KAAK,YAAY,KAAI,eAAc,WAAW,kBAAkB,EAAE,OAAO,CAAC,CAAC;GAC3F;EAED,MAAM,gBAAgB,MAAM,MAAM;AAClC,SAAO;GACH,QAAQ;GACR,UAAU;GACV,eAAe;GACf,iBAAiB;GACpB;;CAEL,QAAQ,SAAS;AACb,OAAK,MAAM,cAAc,KAAK,aAC1B,YAAW,QAAQ;AAEvB,OAAK,aAAa,SAAS;AAC3B,MAAI,KAAK,gBAAgB;AACrB,QAAK,eAAe,SAAS;AAC7B,QAAK,iBAAiB;AACtB,WAAQ,KAAK,2BAA2BA,eAAO;;;CAGvD,qBAAqB;EACjB,MAAM,gBAAgB,EAAE;AACxB,OAAK,MAAM,SAAS,KAAK,mBAAmB;GACxC,MAAM,aAAa,IAAI,SAAS,CAAC,OAAO,EACpC,KAAK,IAAI,QAAQ,MAAM,UAAU,CAAC,QAAQ,EAC7C,CAAC;AACF,iBAAc,KAAK,WAAW;;AAElC,SAAO;;CAEX,oBAAoB,QAAQ;AACxB,OAAK,IAAI,IAAI,GAAG,IAAI,KAAK,kBAAkB,QAAQ,KAAK;GACpD,MAAM,aAAa,IAAI,WAAW,OAAO;AACzC,QAAK,aAAa,KAAK;;;CAG/B,sBAAsB;EAClB,MAAM,EAAE,cAAc,aAAa,sBAAsB;AACzD,MAAI,CAAC,gBAAgB,YAAY,WAAW,KAAK,kBAAkB,WAAW,GAAG;AAC7E,QAAK,eAAe,IAAI,aAAa,4BAA4B;AACjE,QAAK,kBAAkB,KAAK,IAAI,iBAAiB,gCAAgC,GAAG,EAAE,IAAI,iBAAiB,gCAAgC,GAAG,CAAC;;;;;;;AC1J3J,IAAI,iBAAiB;AACrB,IAAI,mBAAmB;AACvB,IAAa,WAAb,MAAsB;CAClB,OAAO;CACP,2BAAW,IAAI,KAAK;CACpB,6BAAa,IAAI,KAAK;CACtB,UAAU;CACV,iBAAiB;CACjB,cAAc;CACd,WAAW,OAAO;EACd,MAAM,EAAE,QAAQ,GAAG,WAAW,OAAO,mBAAmB,OAAO,GAAG,SAAS,MAAM;EACjF,MAAM,YAAY;EAClB,MAAM,UAAU;GACZ,MAAM;GACN;GACA;GACA;GACA;GACH;AACD,OAAK,gBAAgB,SAAS,KAAK,KAAK;AACxC,OAAK,SAAS,IAAI,WAAW,QAAQ;AACrC,SAAO;;CAEX,cAAc,WAAW;AACrB,OAAK,SAAS,OAAO,UAAU;AAC/B,OAAK,MAAM,CAAC,iBAAiB,cAAc,KAAK,WAC5C,KAAI,UAAU,YAAY,UACtB,MAAK,gBAAgB,gBAAgB;;CAIjD,WAAW,WAAW;EAClB,MAAM,UAAU,KAAK,SAAS,IAAI,UAAU;AAC5C,MAAI,YAAY,OACZ,QAAO;AAEX,SAAO,KAAK,QAAQ,QAAQ,QAAQ,QAAQ,WAAW,QAAQ;;CAEnE,QAAQ,WAAW;AACf,MAAI,cAAc,OACd,QAAO,KAAK;EAEhB,MAAM,UAAU,KAAK,SAAS,IAAI,UAAU;AAC5C,MAAI,YAAY,OACZ,QAAO;AAEX,SAAO,QAAQ;;CAEnB,QAAQ,MAAM;AACV,OAAK,OAAO,KAAK,IAAI,GAAG,KAAK;EAC7B,MAAM,WAAW,KAAK,SAAS,QAAQ;AACvC,OAAK,MAAM,WAAW,SAClB,MAAK,gBAAgB,SAAS,KAAK,KAAK;EAE5C,MAAM,aAAa,KAAK,WAAW,QAAQ;AAC3C,OAAK,MAAM,iBAAiB,YAAY;GACpC,MAAM,EAAE,WAAW,YAAY;AAC/B,aAAU,QAAQ,KAAK,QAAQ,QAAQ,CAAC;;;CAGhD,OAAO;AACH,OAAK,UAAU;;CAEnB,QAAQ;AACJ,OAAK,UAAU;AACf,OAAK,iBAAiB;;CAE1B,QAAQ;AACJ,OAAK,QAAQ,EAAE;;CAEnB,gBAAgB,WAAW,eAAe;EACtC,MAAM,kBAAkB;AACxB,OAAK,WAAW,IAAI,iBAAiB;GACjC;GACA,SAAS;GACZ,CAAC;AACF,YAAU,QAAQ,KAAK,QAAQ,cAAc,CAAC;AAC9C,SAAO;;CAEX,gBAAgB,WAAW;AACvB,OAAK,WAAW,OAAO,UAAU;;CAErC,OAAO,YAAY;AACf,MAAI,KAAK,SAAS;AACd,OAAI,KAAK,mBAAmB,GACxB,MAAK,iBAAiB;AAE1B,QAAK,QAAQ,KAAK,QAAQ,aAAa,KAAK,gBAAgB;AAC5D,QAAK,iBAAiB;;;CAG9B,gBAAgB,SAAS,MAAM;EAC3B,MAAM,aAAa,OAAO,QAAQ;AAGlC,MAAI,cAFkB,QAAQ,WAAW,QAAQ,OAG7C,SAAQ,OAAO,QAAQ,WAAW,QAAQ;OAEzC;AACD,WAAQ,OAAO,KAAK,IAAI,GAAG,WAAW,GAAG,QAAQ;AACjD,WAAQ,QAAQ,QAAQ;;;;;;;;ACjGpC,SAAgB,8BAA8B,UAAU;AACpD,QAAO,OAAO,WAAW,eAAe,OAAO,wBACzC,OAAO,sBAAsB,SAAS,GACtC,WAAW,UAAU,MAAO,GAAG;;;AAGzC,SAAgB,6BAA6B,SAAS;AAClD,QAAO,OAAO,WAAW,eAAe,OAAO,uBACzC,OAAO,qBAAqB,QAAQ,GACpC,aAAa,QAAQ;;;;;ACT/B,IAAI,gBAAgB;;AAEpB,IAAa,gBAAb,MAAa,cAAc;CACvB,OAAO,4BAA4B;EAC/B,QAAQ;EACR,iBAAiB;EACjB,cAAc,YAAY;EAC1B,gBAAgB;EAChB,kBAAkB;EAClB,UAAS,UAAS,QAAQ,MAAM,MAAM;EACtC,OAAO,KAAK,MAAM,IAAI,kBAAkB,kBAAkB;EAE1D,oBAAoB;EACvB;CACD,SAAS;CACT,SAAS;CACT;CACA,iBAAiB;CACjB,WAAW;CACX;CACA;CACA;CACA;CACA;CACA,cAAc;CACd,eAAe;CACf,WAAW;CACX,oBAAoB;CACpB,oBAAoB;CACpB,oBAAoB;CACpB,gBAAgB;CAChB,SAAS;CAKT,YAAY,OAAO;AACf,OAAK,QAAQ;GAAE,GAAG,cAAc;GAA2B,GAAG;GAAO;AACrE,UAAQ,KAAK;AACb,MAAI,CAAC,MAAM,OACP,OAAM,IAAI,MAAM,qBAAqB;AAGzC,OAAK,QAAQ,MAAM,SAAS,IAAI,MAAM,EAAE,IAAI,wBAAwB,CAAC;AACrE,OAAK,UAAU,KAAK,MAAM,IAAI,WAAW;AACzC,OAAK,UAAU,KAAK,MAAM,IAAI,WAAW;AACzC,OAAK,YAAY,KAAK,MAAM,IAAI,aAAa;AAC7C,OAAK,SAAS,EAAE,oBAAoB,MAAM,oBAAoB,CAAC;AAE/D,OAAK,QAAQ,KAAK,MAAM,KAAK,KAAK;AAClC,OAAK,OAAO,KAAK,KAAK,KAAK,KAAK;AAChC,OAAK,eAAe,KAAK,aAAa,KAAK,KAAK;AAChD,OAAK,gBAAgB,KAAK,cAAc,KAAK,KAAK;;CAEtD,UAAU;AACN,OAAK,MAAM;AACX,OAAK,YAAY,KAAK;;;CAG1B,SAAS;AACL,OAAK,SAAS;;CAElB,YAAY,OAAO;AACf,OAAK,MAAM,QAAQ,MAAM;AACzB,OAAK,SAAS;;;CAGlB,eAAe,QAAQ;AACnB,OAAK,cAAc,KAAK,eAAe;AACvC,SAAO;;CAEX,SAAS,OAAO;AACZ,MAAI,wBAAwB,MACxB,MAAK,MAAM,qBAAqB,MAAM,sBAAsB;AAEhE,SAAO;;;CAGX,MAAM,QAAQ;AACV,MAAI,KAAK,SACL,QAAO;AAEX,OAAK,WAAW;AAChB,MAAI;GACA,IAAI;AACJ,OAAI,CAAC,KAAK,cAAc;AACpB,SAAK,eAAe;AAEpB,UAAM,KAAK,aAAa;AACxB,SAAK,aAAa;AAElB,UAAM,KAAK,MAAM,aAAa,KAAK,oBAAoB,CAAC;;AAG5D,OAAI,CAAC,KAAK,SACN,QAAO;AAGX,OAAI,eAAe,OAAO;AAEtB,SAAK,uBAAuB;AAC5B,SAAK,wBAAwB;;AAEjC,UAAO;WAEJ,KAAK;GACR,MAAM,QAAQ,eAAe,QAAQ,sBAAM,IAAI,MAAM,gBAAgB;AACrE,QAAK,MAAM,QAAQ,MAAM;AAEzB,SAAM;;;;CAId,OAAO;AAEH,MAAI,KAAK,UAAU;AAGf,OAAI,KAAK,kBAAkB,CAAC,KAAK,OAC7B,MAAK,MAAM,WAAW,KAAK,eAAe;AAE9C,QAAK,uBAAuB;AAC5B,QAAK,oBAAoB;AACzB,QAAK,oBAAoB;AACzB,QAAK,WAAW;;AAEpB,SAAO;;;CAGX,SAAS;AACL,MAAI,KAAK,QAAQ,UAAU,KAAK,OAC5B,QAAO;AAEX,OAAK,mBAAmB;AACxB,OAAK,aAAa;AAClB,OAAK,uBAAuB;AAC5B,OAAK,aAAa,KAAK,oBAAoB,CAAC;AAE5C,OAAK,mBAAmB;AACxB,MAAI,KAAK,mBAAmB;AACxB,QAAK,kBAAkB,KAAK;AAC5B,QAAK,oBAAoB;AACzB,QAAK,oBAAoB;;AAE7B,OAAK,iBAAiB;AACtB,SAAO;;;CAGX,eAAe,UAAU;AACrB,OAAK,WAAW;AAChB,SAAO,KAAK;;;CAGhB,iBAAiB;AACb,OAAK,WAAW;;;CAGpB,gBAAgB;AACZ,OAAK,eAAe,gBAAgB;AACpC,MAAI,CAAC,KAAK,kBACN,MAAK,oBAAoB,IAAI,SAAQ,YAAW;AAC5C,QAAK,oBAAoB;IAC3B;AAEN,SAAO,KAAK;;;CAGhB,MAAM,YAAY;AACd,OAAK,eAAe,YAAY;AAChC,QAAM,KAAK,eAAe;AAC1B,MAAI,KAAK,kBAAkB,kBACvB,QAAO,KAAK,OAAO,WAAW;AAElC,QAAM,IAAI,MAAM,kBAAkB;;CAGtC,cAAc;AACV,OAAK,qBAAqB;AAE1B,OAAK,2BAA2B;AAChC,OAAK,uBAAuB;AAE5B,OAAK,iBAAiB;;CAG1B,YAAY,SAAS;AACjB,MAAI,KAAK,SAAS;AACd,QAAK,QAAQ,SAAS;AACtB,QAAK,QAAQ,gBAAgB;;AAGjC,MAAI,QACA,SAAQ,gBAAgB;AAE5B,OAAK,UAAU;;CAEnB,yBAAyB;AACrB,MAAI,CAAC,KAAK,SACN;AAQJ,OAAK,oBAAoB,8BAA8B,KAAK,gBAAgB,KAAK,KAAK,CAAC;;CAE3F,wBAAwB;AACpB,MAAI,KAAK,sBAAsB,KAC3B;AAQJ,+BAA6B,KAAK,kBAAkB;AACpD,OAAK,oBAAoB;;CAE7B,kBAAkB;AACd,MAAI,CAAC,KAAK,SACN;AAEJ,OAAK,QAAQ;AACb,OAAK,wBAAwB;;CAIjC,aAAa,gBAAgB;AAEzB,MAAI,KAAK,SAAS;AACd,QAAK,QAAQ,aAAa,eAAe;AACzC;;AAGJ,OAAK,MAAM,SAAS,KAAK,oBAAoB,CAAC;AAG9C,OAAK,QAAQ,QAAQ;;CAEzB,oBAAoB;AAChB,OAAK,cAAc;;CAEvB,cAAc;AACV,OAAK,iBAAiB;;CAG1B,4BAA4B;EACxB,MAAM,gBAAgB,KAAK,QAAQ,yBAAyB;AAC5D,MAAI,CAAC,KAAK,UAAU,CAAC,cACjB,OAAM,IAAI,MAAM,OAAO;EAE3B,MAAM,SAAS,eAAe;EAC9B,MAAM,kBAAkB,cAAc,MAAM;AAC5C,OAAK,iBAAiB;GAClB,eAAe;GACf,QAAQ,KAAK;GACb;GACA;GAEA;GACA,UAAU,KAAK;GACf,aAAa;GAEb,OAAO;GACP,QAAQ;GACR,QAAQ;GAER,MAAM;GACN,WAAW,KAAK,KAAK;GACrB,YAAY;GACZ,MAAM;GACN,MAAM;GAEN,gBAAgB;GACnB;;CAEL,qBAAqB;AACjB,MAAI,CAAC,KAAK,eACN,OAAM,IAAI,MAAM,iBAAiB;AAErC,SAAO,KAAK;;CAGhB,wBAAwB;AACpB,MAAI,CAAC,KAAK,eACN;EAGJ,MAAM,EAAE,OAAO,QAAQ,WAAW,KAAK,mBAAmB;AAC1D,MAAI,UAAU,KAAK,eAAe,SAAS,WAAW,KAAK,eAAe,OACtE,MAAK,eAAe,yBAAyB;AAEjD,MAAI,WAAW,KAAK,eAAe,OAC/B,MAAK,eAAe,gCAAgC;AAExD,OAAK,eAAe,QAAQ;AAC5B,OAAK,eAAe,SAAS;AAC7B,OAAK,eAAe,SAAS;AAC7B,OAAK,eAAe,cAAc,KAAK;AAEvC,OAAK,eAAe,aAAa,KAAK,KAAK,GAAG,KAAK,eAAe;AAClE,MAAI,KAAK,SACL,MAAK,SAAS,OAAO,KAAK,eAAe,WAAW;AAExD,OAAK,eAAe,OAAO,KAAK,MAAO,KAAK,eAAe,OAAO,MAAQ,GAAG;AAC7E,OAAK,eAAe;AAEpB,OAAK,eAAe,OAAO,KAAK,WAC1B,KAAK,SAAS,SAAS,GACvB,KAAK,eAAe;;;CAG9B,MAAM,cAAc;AAChB,OAAK,SAAS,MAAM,KAAK,MAAM;AAC/B,MAAI,CAAC,KAAK,OACN,OAAM,IAAI,MAAM,qBAAqB;AAEzC,OAAK,SAAS,KAAK,OAAO,yBAAyB,CAAC,UAAU;;CAGlE,iBAAiB;AACb,MAAI,KAAK,UAAU,KAAK,MAAM,WAAW;GACrC,MAAM,aAAa,SAAS,cAAc,MAAM;AAChD,YAAS,KAAK,YAAY,WAAW;AACrC,cAAW,MAAM,WAAW;GAC5B,MAAM,MAAM,SAAS,cAAc,MAAM;AACzC,OAAI,MAAM,WAAW;AACrB,OAAI,MAAM,OAAO;AACjB,OAAI,MAAM,SAAS;AACnB,OAAI,MAAM,QAAQ;AAClB,OAAI,MAAM,aAAa;AACvB,OAAI,KAAK,kBAAkB,kBACvB,YAAW,YAAY,KAAK,OAAO;AAEvC,cAAW,YAAY,IAAI;GAC3B,MAAM,OAAO,KAAK,MAAM,UAAU,IAAI;AACtC,OAAI,KACA,KAAI,YAAY;;;CAI5B,oBAAoB;AAChB,MAAI,CAAC,KAAK,OACN,QAAO;GAAE,OAAO;GAAG,QAAQ;GAAG,QAAQ;GAAG;EAG7C,MAAM,CAAC,OAAO,UAAU,KAAK,QAAQ,yBAAyB,CAAC,oBAAoB,IAAI,CAAC,GAAG,EAAE;EAE7F,IAAI,SAAS;EACb,MAAM,SAAS,KAAK,QAAQ,yBAAyB,CAAC;AAEtD,MAAI,UAAU,OAAO,aAEjB,UAAS,OAAO,cAAc,OAAO;WAEhC,QAAQ,KAAK,SAAS,EAC3B,UAAS,QAAQ;AAErB,SAAO;GAAE;GAAO;GAAQ;GAAQ;;;CAGpC,kBAAkB;AAGd,MAAI,KAAK,MAAM,sBAAsB,KAAK,OAAO,GAE7C,MAAK,OAAO,GAAG,SAAS,GAAG,GAE3B,KAAK,OAAO,GAAG,oBAEf,KAAK,OAAO,GAAG,oBAAoB;;CAG3C,oBAAoB;AAChB,OAAK,UAAU,SAAS;AACxB,OAAK,UAAU,WAAW;AAe1B,OAAK,QAAQ,WAAW;;CAE5B,kBAAkB;AACd,OAAK,QAAQ,SAAS;;CAO1B,sBAAsB;AAClB,MAAI,KAAK,QAAQ;AACb,QAAK,OAAO,iBAAiB,aAAa,KAAK,aAAa,KAAK,KAAK,CAAC;AACvE,QAAK,OAAO,iBAAiB,cAAc,KAAK,cAAc,KAAK,KAAK,CAAC;;;CAGjF,aAAa,OAAO;AAChB,MAAI,iBAAiB,WACjB,MAAK,oBAAoB,CAAC,iBAAiB,CAAC,MAAM,SAAS,MAAM,QAAQ;;CAGjF,cAAc,OAAO;AACjB,OAAK,oBAAoB,CAAC,iBAAiB;;;;;;AChanD,IAAM,mBAAmB;CACrB,qBAAqB;CACrB,qBAAqB;CACrB,qBAAqB;CACrB,qBAAqB;CACrB,qBAAqB;CACrB,qBAAqB;CACxB;AACD,IAAqB,iBAArB,cAA4C,WAAW;CACnD,cAAc;AACV,QAAM,GAAG,UAAU;AACnB,OAAK,qBAAqB;;CAE9B,OAAO,OAAO;AACV,MAAI,gBAAgB,MAEhB,QAAO,KAAK,mBAAmB,MAAM;AAGzC,SAAO,MAAM,OAAO,MAAM;;CAK9B,mBAAmB,EAAE,QAAQ,aAAa,OAAO,WAAW,kBAAkB,YAAY,YAAY,EAAE,GAAG,GAAG,OAAO,UAAU,UAAU,SAAS,OAAO,WAAW,OAAO,qBAAqB;AAC5L,OAAK,QAAQ;EACb,MAAM,oBAAoB,KAAK,mBAAmB,MAAM;EACxD,MAAM,cAAc;GAAC;GAAG;GAAG;GAAO;GAAO;EAMzC,MAAM,eAAe,MAAM,OAAO;GAC9B,QAAQ;GACR;GACA;GACA;GACA;GACA;GACA;GACA,SAAS,SAAS,QAAO,MAAK,EAAE,aAAa;GAC7C;GACA,WAAW;GACX;GACA,YAAY;IAAC;IAAG;IAAG;IAAG;IAAE;GACxB,WAAW;GACX;GACH,CAAC;AAEF,OAAK,qBAAqB;AAE1B,SAAO;GAAE,oBADkB,qBAAqB,YAAY,KAAK,MAAM,kBAAkB;GAC5D,OAAO;GAAc;;CAEtD,gBAAgB,OAAO;EACnB,MAAM,EAAE,UAAU,cAAc,MAAM;AACtC,SAAS,YAAY,UAAU,SAAS,OAAO,IAC3C,UAAU,SAAS,UAAU,IAC7B,UAAU,SAAS,OAAO;;CAElC,qBAAqB,OAAO,SAAS,wBAAwB;AACzD,SAAO;GACH,SAAS;IACL,UAAU;IACV,aAAa,KAAK;IACrB;GACD,UAAU,EAAE,SAAS,OAAO;GAC/B;;CAEL,mBAAmB,OAAO,YAAY,UAAU;EAE5C,MAAM,iBAAiB,EACnB,GAAG,MAAM,MAAM,YAClB;EACD,MAAM,EAAE,UAAU,cAAc,MAAM;AACtC,MAAI,CAAC,KAAK,sBAAsB,UAAU,SAAS,UAAU,CACzD,gBAAe,QAAQ;WAElB,YAAY,UAAU,SAAS,OAAO,EAAE;AAC7C,UAAO,OAAO,gBAAgB,iBAAiB;AAC/C,kBAAe,QAAQ;AAEvB,kBAAe,aAAa,YAAY,KAAK,oBAAoB,OAAO,SAAS;;AAErF,SAAO;;CAEX,mBAAmB,OAAO;AAEtB,OAAK,qBAAqB,QACpB,OACA;GACE,yBAAS,IAAI,KAAK;GAClB,SAAS,EAAE;GACd;AAEL,SAAO,KAAK;;;AAKpB,SAAS,YAAY,SAAS,OAAO,UAAU;CAC3C,MAAM,EAAE,SAAS,YAAY;CAC7B,IAAI;CAGJ,IAAI,QAAQ,QAAQ,IAAI,MAAM;AAC9B,KAAI,OAAO;AACP,QAAM,UAAU,KAAK,SAAS;AAC9B,MAAI,MAAM;QAET;AACD,MAAI,QAAQ,OAAO;AACnB,MAAI,KAAK,KAAK;AACV,WAAQ;IAAE;IAAG;IAAO,WAAW,CAAC,SAAS;IAAE;AAC3C,WAAQ,IAAI,OAAO,MAAM;AACzB,WAAQ,KAAK;SAEZ;AACD,eAAI,KAAK,uDAAuD,EAAE;AAClE,OAAI;;;AAGZ,QAAO;EAAC;EAAG;EAAG;EAAG,IAAI;EAAI;;AAG7B,SAAS,YAAY,SAAS,aAAa;CACvC,MAAM,QAAQ,QAAQ,QAAQ,YAAY;AAC1C,QAAQ,SAAS;EACb,aAAa,MAAM;EACnB,iBAAiB,MAAM;EACvB,mBAAmB,MAAM,MAAM,mBAAmB,YAAY;EACjE;;;;;ACpIL,IAAqB,WAArB,MAA8B;CAC1B,YAAY,IAAI,MAAM,SAAS;AAC3B,OAAK,aAAa;AAClB,OAAK,+BAAe,IAAI,KAAK;AAC7B,OAAK,KAAK;AACV,OAAK,UAAU;AACf,OAAK,QAAQ,KAAK;;CAGtB,UAAU,UAAU;AAChB,OAAK,aAAa,IAAI,SAAS;;CAEnC,YAAY,UAAU;AAClB,OAAK,aAAa,OAAO,SAAS;;CAEtC,QAAQ;AACJ,SAAO,KAAK,aAAa,OAAO;;CAEpC,SAAS;CAGT,UAAU;AACN,SAAO,KAAK,WACN,KAAK,SACD,QAAQ,OAAO,KAAK,OAAO,GAC3B,KAAK,WACT,KAAK,QAAQ,WAAW,KAAK,SAAS,CAAC;;CAEjD,QAAQ,MAAM,aAAa;AACvB,MAAI,SAAS,KAAK,SAAS,CAAC,YACxB;AAEJ,OAAK,QAAQ;EACb,MAAM,YAAY,EAAE,KAAK;EACzB,IAAI,SAAS;AACb,MAAI,OAAO,SAAS,SAChB,UAAS,KAAK,KAAK;AAEvB,MAAI,kBAAkB,SAAS;AAC3B,QAAK,WAAW;AAChB,QAAK,UAAU,OACV,MAAK,WAAU;AAEhB,QAAI,KAAK,eAAe,WAAW;AAC/B,UAAK,WAAW;AAChB,UAAK,SAAS;AACd,UAAK,WAAW;;KAEtB,CACG,OAAM,UAAS;AAChB,QAAI,KAAK,eAAe,WAAW;AAC/B,UAAK,WAAW;AAChB,UAAK,SAAS,SAAS;;KAE7B;SAED;AACD,QAAK,WAAW;AAChB,QAAK,SAAS;AACd,QAAK,WAAW;;AAEpB,OAAK,MAAM,cAAc,KAAK,aAC1B,YAAW,SAAS,KAAK,SAAS,CAAC;;;;;;AC9D/C,IAAqB,kBAArB,MAAqC;CACjC,YAAY,OAAO;AACf,OAAK,WAAW,MAAM,YAAY;AAClC,OAAK,WAAW;GACZ,QAAQ,MAAM;GAEd,IAAI,MAAM,QAAQ;GAClB,iBAAiB;GACpB;AACD,OAAK,aAAa,EAAE;AACpB,OAAK,aAAa,EAAE;AACpB,OAAK,gBAAgB;;CAEzB,SAAS,YAAY;AACjB,MAAI,WAAW,WAAW,KAAK,SAAS,CACpC,QAAO;AAEX,SAAO,cAAc,KAAK;;CAE9B,IAAI,EAAE,YAAY,MAAM,cAAc,OAAO,aAAa,QAAQ;EAC9D,IAAI,MAAM,KAAK,WAAW;AAC1B,MAAI,IACA,KAAI,QAAQ,MAAM,YAAY;OAE7B;AACD,SAAM,IAAI,SAAS,YAAY,MAAM,KAAK,SAAS;AACnD,QAAK,WAAW,cAAc;;AAIlC,MAAI,aAAa;;CAErB,OAAO,YAAY;EACf,MAAM,MAAM,KAAK,WAAW;AAC5B,MAAI,KAAK;AACL,OAAI,QAAQ;AACZ,UAAO,KAAK,WAAW;;;CAG/B,YAAY,EAAE,cAAc;EACxB,MAAM,WAAW,KAAK,WAAW;AACjC,MAAI,UAAU;AACV,QAAK,MAAM,aAAa,UAAU;IAC9B,MAAM,UAAU,SAAS;IACzB,MAAM,WAAW,KAAK,WAAW,QAAQ;AACzC,QAAI,SACA,UAAS,YAAY,QAAQ;;AAGrC,UAAO,KAAK,WAAW;AACvB,QAAK,OAAO;;;CAGpB,UAAU,EAAE,YAAY,UAAU,YAAY,YAAY,aAAa;EACnE,MAAM,EAAE,YAAY,WAAW,aAAa;AAC5C,MAAI,WAAW,WAAW,SAAS,EAAE;AACjC,gBAAa,WAAW,QAAQ,UAAU,GAAG;AAC7C,OAAI,CAAC,UAAU,YAEX,MAAK,IAAI;IAAE;IAAY,MAAM;IAAM,YAAY;IAAO,CAAC;;EAG/D,MAAM,MAAM,UAAU;AACtB,OAAK,OAAO,YAAY,WAAW,KAAK,SAAS;AACjD,MAAI,IACA,QAAO,IAAI,SAAS;;CAI5B,QAAQ;AACJ,MAAI,CAAC,KAAK,cAIN,MAAK,gBAAgB,iBAAiB,KAAK,QAAQ,EAAE,EAAE;;CAG/D,WAAW;AACP,OAAK,MAAM,OAAO,KAAK,WACnB,MAAK,WAAW,KAAK,QAAQ;;CAGrC,OAAO,YAAY,WAAW,UAAU,UAAU;EAC9C,MAAM,YAAY,KAAK;EACvB,MAAM,WAAY,UAAU,cAAc,UAAU,eAAe,EAAE;EACrE,IAAI,UAAU,SAAS;EACvB,MAAM,cAAc,WAAW,QAAQ,cAAc,KAAK,WAAW,QAAQ;AAC7E,MAAI,aAAa;AACb,eAAY,YAAY,QAAQ;AAChC,QAAK,OAAO;;AAEhB,MAAI,UAAU;AACV,OAAI,SAAS;AACT,YAAQ,WAAW;AACnB,YAAQ,aAAa,SAAS;SAG9B,WAAU;IACN;IACA,YAAY,SAAS;IACxB;AAEL,YAAS,aAAa;AACtB,YAAS,UAAU,QAAQ;;;CAGnC,SAAS;AACL,OAAK,gBAAgB;AACrB,OAAK,MAAM,OAAO,OAAO,KAAK,KAAK,WAAW,EAAE;GAC5C,MAAM,MAAM,KAAK,WAAW;AAC5B,OAAI,CAAC,IAAI,cAAc,CAAC,IAAI,OAAO,EAAE;AACjC,QAAI,QAAQ;AACZ,WAAO,KAAK,WAAW;;;;;;;;ACxGvC,IAAM,mBAAmB;AACzB,IAAM,0BAA0B;AAChC,IAAqB,eAArB,MAAkC;;;;;CAM9B,YAAY,QAAQ,OAAO;AACvB,OAAK,sBAAsB,EAAE;AAC7B,OAAK,eAAe;AACpB,OAAK,eAAe;AACpB,OAAK,cAAc;AACnB,OAAK,SAAS;AAEd,OAAK,+BAA+B;;AAKpC,OAAK,oBAAoB,eAAa;AAClC,SAAM,yBAAyB,MAAMC,WAAS;AAC9C,OAAIA,WACA,MAAK,QAAQ,WAAWA;;EAGhC,MAAM,EAAE,MAAM,OAAO,UAAU,aAAa,SAAS,EAAE;AASvD,OAAK,SAAS,EAAE;AAChB,OAAK,kBAAkB,IAAI,gBAAgB;GAAE;GAAQ,UAAU;GAAW,CAAC;AAC3E,OAAK,UAAU;GACX,eAAe;GACf,UAAU,EAAE;GACZ,cAAc;GACd;GAEA,IAAI,QAAQ;GACZ;GACA,iBAAiB,mBAAmB,QAAQ,MAAM,mBAAmB,OAAO;GAC5E,sBAAsB,CAAC,cAAc;GACrC,YAAY;GACZ,OAAO,SAAS,IAAI,MAAM,EAAE,IAAI,WAAW,CAAC;GAE5C,UAAU,YAAY,IAAIC,iBAAS,EAAE,IAAI,4BAA4B,CAAC;GACtE,UAAU,YAAY,IAAI,UAAU;GACpC,iBAAiB,KAAK;GACtB,SAAS;GACZ;AACD,SAAO,KAAK,KAAK;;;CAGrB,WAAW;AACP,OAAK,gBAAgB,UAAU;AAE/B,OAAK,MAAM,SAAS,KAAK,OACrB,MAAK,eAAe,MAAM;;;CAIlC,YAAY,OAAO,EAAE,kBAAkB,OAAO,EAAE;EAC5C,IAAI,SAAS,KAAK;AAClB,MAAI,KAAK,iBACL,MAAK,eAAe;AAGxB,OAAK,MAAM,SAAS,KAAK,QAAQ;GAE7B,MAAM,mBAAmB,MAAM,eAAe,KAAK;AACnD,YAAS,UAAU;;AAEvB,SAAO;;;CAGX,cAAc;AACV,MAAI,KAAK,eAAe,KAAK,gBAAgB,KAAK,oBAE9C,QAAO;AAEX,MAAI,KAAK,6BACL,QAAO;AAEX,SAAO,KAAK;;;CAGhB,eAAe,QAAQ;AACnB,OAAK,eAAe,KAAK,gBAAgB;;;;CAI7C,eAAe,QAAQ;AACnB,OAAK,eAAe,KAAK,gBAAgB;;;CAG7C,UAAU,EAAE,aAAa,EAAE,EAAE;AAGzB,SAAO,WACD,KAAK,OAAO,QAAO,UAAS,SAAS,MAAK,YAAW,MAAM,GAAG,QAAQ,QAAQ,KAAK,EAAE,CAAC,GACtF,KAAK;;;CAGf,SAAS,OAAO;AACZ,MAAI,WAAW,MACX,MAAK,SAAS,MAAM;AAGxB,MAAI,cAAc,MACd,MAAK,QAAQ,WAAW,MAAM;AAGlC,MAAI,YAAY,MACZ,MAAK,cAAc,MAAM;AAE7B,MAAI,aAAa,MACb,MAAK,QAAQ,UAAU,MAAM;;;CAIrC,UAAU,WAAW,QAAQ;AACzB,QAAM,kBAAkB,MAAM,QAAQ,UAAU;AAChD,OAAK,sBAAsB;EAC3B,MAAM,aAAa,QAAQ,WAAW,QAAQ;AAC9C,OAAK,MAAM,SAAS,WAChB,OAAM,UAAU,KAAK;AAEzB,OAAK,cAAc,KAAK,QAAQ,WAAW;;;CAG/C,eAAe;EAIX,MAAM,SAAS,KAAK,aAAa;AACjC,MAAI,QAAQ;AACR,QAAK,eAAe,oBAAoB,SAAS;AAEjD,QAAK,UAAU,KAAK,eAAe,KAAK,qBAAqB,OAAO;;AAGxE,OAAK,cAAc;;;CAGvB,uBAAuB,QAAQ;EAC3B,MAAM,EAAE,yBAAyB,KAAK;AACtC,MAAI,CAAC,qBAAqB,MAAK,MAAK,EAAE,SAAS,OAAO,KAAK,EAAE;AACzD,wBAAqB,KAAK,OAAO;AACjC,QAAK,+BAA+B;;;;CAI5C,0BAA0B,QAAQ;EAC9B,MAAM,EAAE,yBAAyB,KAAK;EACtC,MAAM,IAAI,qBAAqB,WAAU,MAAK,EAAE,SAAS,OAAO,KAAK;AACrE,MAAI,KAAK,GAAG;AACR,wBAAqB,OAAO,GAAG,EAAE;AACjC,QAAK,+BAA+B;;;CAG5C,aAAa,OAAO,OAAO,OAAO;AAC9B,QAAM,WAAW,OAAO,GAAG,MAAM,MAAM,QAAQ;;;;CAKnD,cAAc,WAAW,WAAW;EAEhC,MAAM,cAAc,EAAE;AACtB,OAAK,MAAM,YAAY,UACnB,KAAI,YAAY,SAAS,IACrB,aAAI,KAAK,oCAAoC,SAAS,KAAK,EAAE;MAG7D,aAAY,SAAS,MAAM;AAGnC,MAAI,KAAK,8BAA8B;AACnC,QAAK,MAAM,SAAS,WAAW;AAC3B,UAAM,gBAAgB;AACtB,UAAM,eAAe,EAAE,mBAAmB,MAAM,CAAC;;AAErD,QAAK,+BAA+B;;EAGxC,MAAM,kBAAkB,EAAE;AAE1B,OAAK,4BAA4B,WAAW,aAAa,gBAAgB;AAEzE,OAAK,mBAAmB,YAAY;EACpC,IAAI,cAAc;AAClB,OAAK,MAAM,SAAS,gBAChB,KAAI,MAAM,sBAAsB,EAAE;AAC9B,iBAAc,yBAAyB;AACvC;;AAGR,OAAK,eAAe;AACpB,OAAK,SAAS;;CAIlB,4BAA4B,WAAW,aAAa,iBAAiB;AACjE,OAAK,MAAM,YAAY,WAAW;AAC9B,YAAS,UAAU,KAAK;GAExB,MAAM,WAAW,YAAY,SAAS;AACtC,OAAI,aAAa,KAEb,aAAI,KAAK,oCAAoC,SAAS,KAAK,EAAE;AAGjE,eAAY,SAAS,MAAM;GAC3B,IAAI,YAAY;AAEhB,OAAI;AACA,QAAI,KAAK,UAAU,aAAa,SAC5B,UAAS,eAAe;AAE5B,QAAI,CAAC,SACD,MAAK,iBAAiB,SAAS;SAE9B;AACD,UAAK,oBAAoB,UAAU,SAAS;AAC5C,UAAK,aAAa,SAAS;;AAE/B,oBAAgB,KAAK,SAAS;AAE9B,gBAAY,SAAS,cAAc,SAAS,cAAc,GAAG;YAG1D,KAAK;AACR,SAAK,aAAa,YAAY,KAAK,SAAS;;AAEhD,OAAI,UACA,MAAK,4BAA4B,WAAW,aAAa,gBAAgB;;;CAMrF,mBAAmB,aAAa;AAC5B,OAAK,MAAM,WAAW,aAAa;GAC/B,MAAM,QAAQ,YAAY;AAC1B,OAAI,MACA,MAAK,eAAe,MAAM;;;;CAMtC,iBAAiB,OAAO;AACpB,MAAI;AACA,SAAM,aAAa;AACnB,SAAM,YAAY,UAAU;WAEzB,KAAK;AACR,QAAK,aAAa,kBAAkB,KAAK,MAAM;;;;CAKvD,oBAAoB,UAAU,UAAU;AACpC,WAAS,eAAe,SAAS;AACjC,WAAS,YAAY,UAAU;AAC/B,MAAI,aAAa,SACb,UAAS,YAAY,UAAU;;;CAIvC,aAAa,OAAO;AAChB,MAAI;AACA,SAAM,SAAS;WAEZ,KAAK;AACR,QAAK,aAAa,UAAU,KAAK,MAAM;;;;CAI/C,eAAe,OAAO;AAClB,OAAK,eAAe,KAAK,gBAAgB,aAAa;AACtD,QAAM,YAAY,UAAU;AAC5B,MAAI;AACA,SAAM,WAAW;AACjB,SAAM,YAAY,UAAU;WAEzB,KAAK;AACR,QAAK,aAAa,gBAAgB,KAAK,MAAM;;;;;;;AC1SzD,IAAqB,cAArB,MAAiC;CAC7B,YAAY,OAAO;AAEf,OAAK,QAAQ,EAAE;AACf,OAAK,QAAQ;AACb,OAAK,SAAS;AACd,OAAK,YAAY,EAAE;AACnB,OAAK,cAAc,EAAE;AACrB,OAAK,WAAW,MAAM;AACtB,OAAK,aAAa,EAAE;AACpB,OAAK,eAAe,EAAE;AACtB,OAAK,cAAc;AACnB,OAAK,eAAe;AACpB,OAAK,eAAe;AACpB,OAAK,gBAAgB,MAAM;AAC3B,OAAK,kBAAkB;GACnB,mBAAmB,MAAM;GACzB,0BAA0B,MAAM;GACnC;AACD,SAAO,KAAK,KAAK;AAEjB,OAAK,SAAS,MAAM;;;CAGxB,WAAW;AACP,OAAK,MAAM,OAAO,KAAK,aAAa;GAChC,MAAM,aAAa,KAAK,YAAY;AACpC,OAAI,WACA,YAAW,UAAU;;AAG7B,OAAK,cAAc,EAAE;;;CAGzB,YAAY,OAAO,EAAE,kBAAkB,OAAO,EAAE;EAC5C,MAAM,SAAS,KAAK;AACpB,MAAI,KAAK,iBACL,MAAK,eAAe;AAExB,SAAO;;;CAGX,eAAe,QAAQ;AACnB,OAAK,eAAe,KAAK,gBAAgB;AACzC,OAAK,eAAe,KAAK,gBAAgB;;;CAG7C,mBAAmB;AACf,OAAK,MAAM,UAAU,KAAK,aAAa;GACnC,MAAM,aAAa,KAAK,YAAY;AACpC,OAAI,WACA,YAAW,kBAAkB;;;;;;;;;;CAWzC,aAAa,MAAM;AACf,MAAI,KACA,QAAO,KAAK,WAAW,QAAO,aAAY,SAAS,cAAc,KAAK,CAAC;AAE3E,SAAO,KAAK;;;CAGhB,WAAW;EACP,MAAM,UAAU,EAAE;AAClB,OAAK,MAAM,SAAQ,SAAQ;AACvB,WAAQ,KAAK,MAAM;IACrB;AACF,SAAO;;;CAGX,QAAQ,QAAQ;AACZ,SAAO,KAAK,MAAM,MAAK,SAAQ,KAAK,OAAO,OAAO;;;;;;;CAOtD,aAAa,cAAc;EACvB,MAAM,OAAO,OAAO,iBAAiB,WAAW,KAAK,QAAQ,aAAa,GAAG;EAE7E,MAAM,YAAa,QAAQ,KAAK,UAAU,KAAK,gBAAgB,KAAM,KAAK;AAC1E,SAAO,OAAO,KAAK,gBAAgB,UAAU,GAAG;;CAEpD,YAAY,QAAQ;AAChB,SAAO,KAAK,aAAa;;;;;;;;;;;;CAY7B,UAAU,KAAK,MAAM;EACjB,MAAM,YAAY,KAAK,cAAc;EACrC,MAAM,QAAQ;GAAE,GAAG,IAAI;GAAI,GAAG,IAAI;GAAI;AACtC,OAAK,IAAI,IAAI,UAAU,SAAS,GAAG,KAAK,GAAG,EAAE,GAAG;GAC5C,MAAM,WAAW,UAAU;AAC3B,OAAI,SAAS,cAAc,MAAM,EAAE;IAC/B,MAAM,IAAI,IAAI,OAAO;AACrB,MAAE,MAAM,SAAS;AACjB,MAAE,MAAM,SAAS;AACjB,WAAO,SAAS,UAAU,GAAG,KAAK;;;AAG1C,SAAO;;;CAGX,SAAS,OAAO;AACZ,MAAI,MAAM,MACN,MAAK,UAAU,MAAM,MAAM;AAE/B,MAAI,MAAM,UACN,MAAK,cAAc,MAAM,UAAU;AAEvC,MAAI,WAAW,SAAS,YAAY,MAChC,MAAK,SAAS,MAAM,OAAO,MAAM,OAAO;AAK5C,MAAI,CAAC,KAAK,YACN,MAAK,SAAS;;CAMtB,UAAU;AACN,OAAK,cAAc;AAEnB,MAAI,KAAK,cAAc;AACnB,QAAK,eAAe;AACpB,QAAK,mBAAmB;;AAI5B,MAAI,KAAK,cAAc;AACnB,QAAK,eAAe;AACpB,QAAK,mBAAmB;;AAE5B,OAAK,cAAc;;CAEvB,SAAS,OAAO,QAAQ;AACpB,MAAI,UAAU,KAAK,SAAS,WAAW,KAAK,QAAQ;AAChD,QAAK,QAAQ;AACb,QAAK,SAAS;AACd,QAAK,eAAe,eAAe;;;CAK3C,UAAU,OAAO;AACb,UAAQ,QAAQ,OAAO,QAAQ;AAE/B,MADqB,KAAK,WAAW,OAAO,KAAK,MAAM,CAEnD,MAAK,eAAe,gBAAgB;AAExC,OAAK,QAAQ;;CAEjB,cAAc,WAAW;AACrB,MAAI,WAAW;AAGX,OADyB,CAAC,UAAU,WAAW,KAAK,WAAW,EAAE,CAE7D,MAAK,eAAe,oBAAoB;AAE5C,QAAK,YAAY;QAGjB,aAAI,KAAK,4CAA4C,EAAE;;CAG/D,kBAAkB,MAAM,OAAO;EAC3B,MAAMC,eAAa,MAAM;AAazB,SAZmB,IAAIA,aAAW;GAC9B,UAAU,KAAK;GACf,cAAc,KAAK;GAEnB,mBAAmB,KAAK,gBAAgB;GACxC,eAAe,KAAK,gBAAgB;GACpC,eAAc,cAAa,KAAK,QAAQ,KAAK,GAAG,EAAE,aAAa;IAC3D;IACA,OAAO,KAAK;IACZ,QAAQ,KAAK;IAChB,CAAC;GACL,CAAC;;CAGN,kBAAkB,MAAM,WAAW,UAAU,YAAY;EACrD,MAAM,kBAAkB,KAAK;AAC7B,MAAI,mBAAmB,UAAU;GAC7B,MAAM,gBAAgB;IAClB,GAAG;IACH,GAAG;IACH,IAAI,KAAK;IACT,GAAG,SAAS;IACZ,GAAG,SAAS;IACZ,OAAO,SAAS;IAChB,QAAQ,SAAS;IACpB;AAGD,OAAI,CAAC,cAAc,WAAW,gBAAgB,gBAAgB,KAC1D,cAAa,KAAK,kBAAkB,MAAM,cAAc;AAE5D,OAAI,WACA,YAAW,SAAS,cAAc;AAEtC,UAAO;;AAEX,SAAO;;CAGX,oBAAoB;EAChB,MAAM,EAAE,UAAU;EAClB,MAAM,iBAAiB,KAAK;AAC5B,OAAK,aAAa,EAAE;AACpB,OAAK,cAAc,EAAE;EACrB,IAAI,wBAAwB;AAE5B,OAAK,IAAI,IAAI,MAAM,QAAQ,MAAM;GAC7B,MAAM,OAAO,MAAM;GACnB,MAAM,YAAY,KAAK,aAAa,KAAK;GACzC,MAAM,WAAW,KAAK,aAAa;IAAE;IAAW,OAAO,KAAK;IAAO,QAAQ,KAAK;IAAQ,CAAC;GACzF,IAAI,gBAAgB,eAAe,KAAK;GACxC,MAAM,gBAAgB,QAAQ,KAAK,WAAW;AAC9C,OAAI,iBAAiB,CAAC,cAGlB,yBAAwB;AAE5B,QAAK,yBAAyB,CAAC,kBAAkB,eAAe;AAE5D,kBAAc,UAAU;AACxB,oBAAgB;;AAGpB,QAAK,YAAY,KAAK,MAAM,KAAK,kBAAkB,MAAM,WAAW,UAAU,cAAc;AAC5F,OAAI,SACA,MAAK,WAAW,QAAQ,SAAS;;AAIzC,OAAK,MAAM,MAAM,gBAAgB;GAC7B,MAAM,gBAAgB,eAAe;AACrC,OAAI,iBAAiB,CAAC,KAAK,YAAY,IACnC,eAAc,UAAU;;AAGhC,OAAK,mBAAmB;;CAE5B,oBAAoB;AAEhB,OAAK,eAAe,EAAE;AACtB,OAAK,WAAW,SAAQ,aAAY;AAChC,OAAI,SAAS,GAET,MAAK,aAAa,SAAS,MAAM,KAAK,aAAa,SAAS,OAAO;IAEzE;;CAIN,WAAW,UAAU,UAAU;AAC3B,MAAI,SAAS,WAAW,SAAS,OAC7B,QAAO;AAEX,SAAO,SAAS,MAAM,GAAG,MAAM,CAAC,SAAS,GAAG,OAAO,SAAS,GAAG,CAAC;;;;;;AC1RxE,IAAM,0BAA0B;AAEhC,SAAgB,cAAc,OAAO;AACjC,SAAQ,OAAO,OAAf;EACI,KAAK,SACD,QAAO;GACH,UAAU;GACV,UAAU;GACb;EACL,KAAK;GACD,MAAM,QAAQ,wBAAwB,KAAK,MAAM;AACjD,OAAI,SAAS,MAAM,UAAU,GAAG;IAC5B,MAAM,WAAW,MAAM,OAAO;IAC9B,MAAM,WAAW,WAAW,MAAM,GAAG;AACrC,WAAO;KACH,UAAU,WAAW,WAAW,MAAM;KACtC;KACH;;EAGT,QAEI,OAAM,IAAI,MAAM,mCAAmC,QAAQ;;;AAGvE,SAAgB,YAAY,UAAU,QAAQ;AAC1C,QAAO,SAAS,WAAW,KAAK,MAAM,SAAS,WAAW,OAAO,GAAG,SAAS;;;;;ACxBjF,IAAqB,OAArB,MAA0B;CACtB,YAAY,OAAO;EACf,MAAM,EAAE,IAAI,IAAI,GAAG,IAAI,GAAG,QAAQ,QAAQ,SAAS,QAAQ,UAAU,SAAS;AAE9E,OAAK,KAAK,MAAM,KAAK,YAAY,eAAe;AAChD,OAAK,QAAQ;GAAE,GAAG;GAAO,IAAI,KAAK;GAAI;AAEtC,OAAK,KAAK,cAAc,EAAE;AAC1B,OAAK,KAAK,cAAc,EAAE;AAC1B,OAAK,SAAS,cAAc,MAAM;AAClC,OAAK,UAAU,cAAc,OAAO;AACpC,OAAK,WAAW,WAAW;GACvB,MAAM,cAAc,QAAQ,QAAQ,EAAE;GACtC,OAAO,cAAc,QAAQ,SAAS,EAAE;GACxC,KAAK,cAAc,QAAQ,OAAO,EAAE;GACpC,QAAQ,cAAc,QAAQ,UAAU,EAAE;GAC7C;AAED,OAAK,SAAS,KAAK,OAAO,KAAK,KAAK;AACpC,SAAO,KAAK,KAAK;;CAErB,OAAO,MAAM;AACT,MAAI,SAAS,KACT,QAAO;AAGX,SAAO,KAAK,gBAAgB,KAAK,eAAe,UAAU,KAAK,OAAO,KAAK,OAAO,EAAE;;;CAGxF,MAAM,UAAU;EACZ,MAAM,kBAAkB,KAAK;AAC7B,SAAO,IAAI,gBAAgB;GAAE,GAAG,KAAK;GAAO,GAAG;GAAU,CAAC;;;CAG9D,aAAa,EAAE,OAAO,QAAQ,aAAa;AACvC,cAAY,KAAK,gBAAgB,UAAU;EAE3C,MAAM,qBAAqB,KAAK,cAAc;GAAE;GAAO;GAAQ,CAAC;AAChE,MAAI,CAAC,mBAAmB,UAAU,CAAC,mBAAmB,MAClD,QAAO;AAGX,SAAO,KADc,KAAK,gBAAgB,UAAU,EAC5B;GAAE,GAAG;GAAW,GAAG,KAAK;GAAO,GAAG;GAAoB,CAAC;;CAEnF,iBAAiB;EACb,MAAM,EAAE,cAAc,KAAK;AAC3B,MAAI,OAAO,cAAc,SAErB,QAAO;AAEX,SAAO,WAAW,MAAM,KAAK;;CAGjC,gBAAgB,WAAW;AACvB,MAAI,KAAK,MAAM,aAAa,OAAO,KAAK,MAAM,cAAc,UAAU;AAGlE,OAAI,CAAC,KAAK,MAAM,UAAU,GACtB,QAAO,KAAK,MAAM;GAGtB,MAAM,eAAe,EAAE,GAAG,WAAW;AACrC,QAAK,MAAM,OAAO,KAAK,MAAM,UACzB,KAAI,QAAQ,KACR,cAAa,OAAO,KAAK,MAAM,UAAU;AAGjD,UAAO;;AAEX,SAAO;;;CAGX,cAAc,EAAE,OAAO,UAAU;EAC7B,MAAM,aAAa;GACf,GAAG,YAAY,KAAK,IAAI,MAAM;GAC9B,GAAG,YAAY,KAAK,IAAI,OAAO;GAC/B,OAAO,YAAY,KAAK,QAAQ,MAAM;GACtC,QAAQ,YAAY,KAAK,SAAS,OAAO;GAC5C;AACD,MAAI,KAAK,SACL,YAAW,UAAU;GACjB,MAAM,YAAY,KAAK,SAAS,MAAM,MAAM;GAC5C,KAAK,YAAY,KAAK,SAAS,KAAK,OAAO;GAC3C,OAAO,YAAY,KAAK,SAAS,OAAO,MAAM;GAC9C,QAAQ,YAAY,KAAK,SAAS,QAAQ,OAAO;GACpD;AAEL,SAAO;;CAGX,IAAI,aAAa;EACb,MAAM,OAAO,KAAK,MAAM;AACxB,MAAI,CAAC,KACD,QAAO;AAEX,MAAI,SAAS,KACT,QAAO,EAAE,MAAM,KAAK,gBAAgB;AAExC,MAAI,OAAO,SAAS,WAChB,QAAO,EAAE,MAAM,MAAM;AAEzB,SAAO;GAAE,MAAM,KAAK;GAAgB,GAAG;GAAM;;;;;;ACtGrD,IAAMC,eAAa;AAEnB,MAAa,oBAAoB;CAC7B,OAAO;CACP,aAAa;CACb,QAAQ;CACX;AACD,IAAM,kBAAiB,MAAK;AAC5B,IAAM,uBAAuB,kBAAkB;AAC/C,IAAqB,oBAArB,MAAuC;CACnC,YAAY,MAAM;AACd,OAAK,uBAAsB,eAAc;GAErC,MAAM,EAAE,MAAM,UAAU,EAAE,cAAc,YAAY,UAAU,UAAU,aAAa;GACrF,MAAM,IAAI,OAAO,OAAO,SAAS;GACjC,MAAM,WAAW,aAAa,iBAAiB,YAAY,UAAU,EAAE;AAGvE,QAAK,oBAAoB,KAAK,mBAAmB;IAC7C,GAAG,KAAK;IACR,GAAG;IACN,CAAC,CAAC,kBAAkB;AACrB,QAAK,kBAAkB;IACnB,WAAW,KAAK;IAChB,cAAc,KAAK;IACtB,CAAC;;AAEN,OAAK,qBAAqB,KAAK;AAC/B,OAAK,oBAAoB;AACzB,OAAK,aAAa,IAAI,WAAW,KAAK,SAAS;AAC/C,OAAK,oBAAoB,KAAK,qBAAqBA;AACnD,OAAK,gBAAgB,KAAK,iBAAiBA;;CAE/C,WAAW;AACP,OAAK,WAAW,QAAQ;;CAG5B,0BAA0B;AACtB,SAAO,KAAK;;CAIhB,uBAAuB,WAAW;EAC9B,IAAI,sBAAsB;EAC1B,MAAM,eAAe,KAAK;AAE1B,OAAK,QAAQ;AAEb,MAAI,CAAC,gBAAgB,KAAK,4BAA4B,cAAc,UAAU,CAC1E,QAAO;AAEX,MAAI,KAAK,qBAAqB,UAAU,EAAE;GACtC,IAAI,aAAa;AACjB,OAAI,KAAK,WAAW,YAAY;IAE5B,MAAM,EAAE,cAAc,aAAa,KAAK,WAAW;AACnD,iBAAa;KACT,GAAG;KACH,GAAI,iBAAiB,kBAAkB,cACjC,WACA,KAAK,qBAAqB;KACnC;;AAEL,QAAK,mBAAmB,YAAY,UAAU;AAC9C,yBAAsB;QAGtB,MAAK,WAAW,QAAQ;AAE5B,SAAO;;CAEX,mBAAmB;AACf,OAAK,WAAW,QAAQ;;CAG5B,qBAAqB,OAAO;EACxB,MAAM,EAAE,oBAAoB,2BAA2B;AACvD,UAAS,qBAAqB,KAAK,uBAAuB,WACtD,QAAQ,uBAAuB;;CAEvC,gCAAgC,OAAO;AACnC,MAAI,KAAK,WAAW,cAAc,KAAK,kBAEnC,QAAO,KAAK,WAAW,SAAS,aAAa,cAAc,OAAO,KAAK,kBAAkB;AAE7F,SAAO;;CAEX,4BAA4B,cAAc,WAAW;AACjD,MAAI,KAAK,WAAW,WAIhB,QAF2B,KAAK,WAAW,SAEhB,iBAAiB,kBAAkB,UAE1D,KAAK,gCAAgC,UAAU;AAEvD,MAAI,KAAK,qBAAqB,UAAU,CAEpC,QAAO,UAAU,uBAAuB,cAAc,cAAc,UAAU;AAElF,SAAO;;CAEX,mBAAmB,YAAY,UAAU;EACrC,MAAM,iBAAiB,KAAK,mBAAmB,WAAW;EAC1D,MAAM,oBAAoB,KAAK,mBAAmB,SAAS,CAAC,iBAAiB,eAAe;EAE5F,MAAM,yBAAyB,SAAS;EACxC,MAAM,WAAW,uBAAuB,cAClC,uBAAuB,YAAY,YAAY,SAAS,GACxD,SAAS;AACf,MAAI,aAAa,EACb;EAEJ,MAAM,eAAe,uBAAuB,gBAAgB,YAAY,kBAAkB;AAC1F,OAAK,oBAAoB,EAAE;EAC3B,MAAM,qBAAqB;GACvB;GACA,QAAQ,SAAS,oBAAoB;GACrC,cAAc;GACd,cAAc,SAAS,0BAA0B;GACjD,YAAY,aAAa;GACzB,UAAU,aAAa;GACvB,SAAS,SAAS;GAClB,UAAU,KAAK;GACf,aAAa,KAAK,iBAAiB,SAAS,sBAAsB;GAClE,OAAO,KAAK,iBAAiB,SAAS,gBAAgB;GACzD;AACD,OAAK,WAAW,MAAM,mBAAmB;AACzC,OAAK,cAAc,EAAE,cAAc,MAAM,CAAC;AAC1C,OAAK,kBAAkB;;CAE3B,iBAAiB,UAAU;AACvB,UAAO,eAAc;AACjB,QAAK,oBAAoB;AACzB,QAAK,cAAc;IACf,cAAc;IACd,WAAW;IACX,WAAW;IACX,YAAY;IACf,CAAC;AACF,cAAW,WAAW;;;;;;;AC3IlC,IAAqB,yBAArB,MAA4C;;;;;;;;CAQxC,YAAY,MAAM;EACd,MAAM,EAAE,SAAS,SAAS,aAAa;AACvC,OAAK,kBAAkB;AACvB,OAAK,kBAAkB,WAAW;AAClC,OAAK,iBAAiB;;;;;;;;CAQ1B,cAAc,cAAc,WAAW;AACnC,OAAK,MAAM,OAAO,KAAK,gBACnB,KAAI,EAAE,OAAO,iBACT,EAAE,OAAO,cACT,CAAC,OAAO,aAAa,MAAM,UAAU,KAAK,CAC1C,QAAO;AAGf,SAAO;;;;;;;;;CASX,gBAAgB,YAAY,UAAU;EAClC,MAAM,sBAAsB,EAAE;EAC9B,MAAM,oBAAoB,EAAE;AAC5B,OAAK,MAAM,OAAO,KAAK,gBACnB,KAAI,OAAO,cAAc,OAAO,UAAU;AACtC,uBAAoB,OAAO,WAAW;AACtC,qBAAkB,OAAO,SAAS;;AAG1C,OAAK,oBAAoB,oBAAoB;AAC7C,OAAK,oBAAoB,kBAAkB;AAC3C,SAAO;GAAE,OAAO;GAAqB,KAAK;GAAmB;;;;;;;;CAQjE,YAAY,YAAY,UAAU;AAC9B,SAAO,SAAS;;CAEpB,oBAAoB,OAAO;AACvB,MAAI,CAAC,KAAK,eACN;AAEJ,OAAK,eAAe,SAAQ,aAAY;GACpC,MAAM,QAAQ,MAAM;AACpB,UAAO,OAAO,SAAS,MAAM,IAAI,MAAM,QAAQ,MAAM,EAAE,GAAG,SAAS,6BAA6B;IAClG;;;;;;AC9DV,IAAMC,uBAAqB,KAAK,KAAK;AACrC,IAAM,qBAAqB,MAAM,KAAK;AACtC,IAAM,eAAe;AACrB,IAAM,eAAe;AACrB,SAAS,oBAAoB;CACzB,MAAMC,kBAAgB,eAAe;CACrC,MAAM,iBAAkB,KAAK,KAAK,MAAO;AACzC,QAAO;EACH,eAAe;GAACA;GAAeA;GAAeA;GAAc;EAC5D,gBAAgB;GAAC;GAAG;GAAG;GAAE;EACzB,eAAe;GAAC,IAAIA;GAAe,IAAIA;GAAe,IAAIA;GAAc;EACxE,gBAAgB;GAAC;GAAgB;GAAgBA;GAAc;EAC/D,iBAAiB;GAAC;GAAG;GAAG;GAAE;EAC1B,gBAAgB;GAAC,IAAI;GAAgB,IAAI;GAAgB,IAAIA;GAAc;EAC9E;;AAEL,IAAM,gBAAN,cAA4BC,iBAAS;CACjC,YAAY,OAAO,EAAE,EAAE;EACnB,MAAM,EAAE,YAAY,GAAG,OAAO,GAG9B,kBAAkB,IAAK,iBAAiB,GAAG,aAAa,OAAO;EAC/D,IAAI,EAAE,WAAW,GAAG,QAAQ,WAAW,KAAK,SAAS;AAErD,aAAW,KAAK,IAAI,KAAK,IAAI,UAAU,aAAa,EAAE,CAAC,aAAa;AACpE,WAAS,UAAU;AACnB,MAAI,KACA,YAAW,eAAe,KAAK;MAG/B,QAAO,eAAe,SAAS;EAKnC,MAAMC,UAAQ,KAAK,IAAI,GAAG,OAAO,WAAW,SAAS,CAAC;EACtD,MAAM,QAAQ,KAAK,SAAS;EAC5B,MAAM,OAAO,KAAK,SAAS,WAAY,eAAe,IAAIA,UAAS,UAAU;EAE7E,MAAM,aAAa,IAAI,SAAS,CAAC,OAAO;GAAE,KAAK;IAAC;IAAG,CAAC;IAAU;IAAE;GAAE,IAAI;IAAC;IAAG;IAAG;IAAE;GAAE,CAAC;AAClF,aAAW,QAAQ,WAAWH,qBAAmB;AACjD,aAAW,QAAQ,CAAC,YAAYA,qBAAmB;AACnD,aAAW,MAAMG,UAAQ,OAAO;AAChC,QAAM;GACF,GAAG;GAEH;GAEA;GACA;GACA;GACA;GAEA,gBAAgB,mBAAmB;GACnC;GACA,eAAe;GACf,MAAM;GACN,KAAK;GACR,CAAC;AACF,OAAK,QAAQA;AACb,OAAK,WAAW;AAChB,OAAK,YAAY;AACjB,OAAK,OAAO;AACZ,OAAK,aAAa;;CAEtB,IAAI,iBAAiB;AACjB,SAAO,gBAAgB;;CAE3B,oBAAoB;AAChB,SAAO,KAAK;;CAEhB,UAAU,UAAU,EAAE,EAAE;EACpB,MAAM,kBAAkB,EAAE,SAAS,QAAQ,KAAK,GAAG;EACnD,MAAM,OAAO,KAAK,UAAU,CAAC,GAAG,KAAK,SAAS,EAAE,EAAE,gBAAgB;EAClE,MAAM,MAAM,KAAK,UAAU,CAAC,KAAK,QAAQ,GAAG,EAAE,EAAE,gBAAgB;EAChE,MAAM,QAAQ,KAAK,UAAU,CAAC,KAAK,OAAO,KAAK,SAAS,EAAE,EAAE,gBAAgB;EAC5E,MAAM,SAAS,KAAK,UAAU,CAAC,KAAK,QAAQ,GAAG,KAAK,OAAO,EAAE,gBAAgB;AAC7E,MAAI,MAAM,KAAK,KAAK,UAChB,OAAM,MAAM;AAChB,MAAI,KAAK,KAAK,KAAK,UACf,MAAK,MAAM;AACf,SAAO;GACH,KAAK,IAAI,KAAK,IAAI,MAAM,IAAI,IAAI,IAAI,OAAO,GAAG;GAC9C,KAAK,IAAI,KAAK,IAAI,MAAM,IAAI,IAAI,IAAI,OAAO,GAAG;GAC9C,KAAK,IAAI,KAAK,IAAI,MAAM,IAAI,IAAI,IAAI,OAAO,GAAG;GAC9C,KAAK,IAAI,KAAK,IAAI,MAAM,IAAI,IAAI,IAAI,OAAO,GAAG;GACjD;;CAEL,UAAU,KAAK,EAAE,UAAU,MAAM,YAAY,EAAE,EAAE;EAC7C,MAAM,CAAC,GAAG,GAAG,KAAK;EAClB,MAAM,KAAK,UAAU,IAAI,KAAK,SAAS;EACvC,MAAM,EAAE,4BAA4B;EACpC,IAAI;AACJ,MAAI,OAAO,SAAS,EAAE,CAElB,SAAQ,gBAAgB,yBAAyB;GAAC;GAAG;GAAI;GAAG;GAAE,CAAC;OAE9D;GAGD,MAAM,SAAS,gBAAgB,yBAAyB;IAAC;IAAG;IAAI;IAAI;IAAE,CAAC;GACvE,MAAM,SAAS,gBAAgB,yBAAyB;IAAC;IAAG;IAAI;IAAG;IAAE,CAAC;GACtE,MAAM,OAAO,WAAW,KAAK,eAAe,KAAK;GACjD,MAAM,OAAOC,OAAYC,IAAS,EAAE,EAAE,QAAQ,OAAO,CAAC;GACtD,MAAM,QAAQD,OAAY,OAAO;GACjC,MAAM,QAAQA,OAAY,OAAO;GAEjC,MAAM,OAAQ,MADA,IAAI,QAAQ,SAAS,OAAO,QAAQ,UAAU,KAAK,MACvC;GAG1B,MAAM,KAFK,KAAK,KAAK,QAAQ,KAAK,GACvB,KAAK,KAAK,KAAK,IAAI,GAAG,KAAK,KAAK,KAAK,CAAC,IAC3B,KAAK,KAAK,KAAK;AACrC,WAAQE,OAAU,EAAE,EAAE,QAAQ,QAAQ,EAAE;;EAE5C,MAAM,CAAC,GAAG,GAAG,KAAK,KAAK,kBAAkB,MAAM;AAC/C,MAAI,OAAO,SAAS,EAAE,CAClB,QAAO;GAAC;GAAG;GAAG;GAAE;AAEpB,SAAO,OAAO,SAAS,QAAQ,GAAG;GAAC;GAAG;GAAG;GAAQ,GAAG,CAAC,GAAG,EAAE;;CAE9D,gBAAgB,KAAK;EACjB,MAAM,CAAC,KAAK,KAAK,IAAI,KAAK;EAC1B,MAAM,SAAS,MAAMN;EACrB,MAAM,MAAM,MAAMA;EAClB,MAAM,SAAS,KAAK,IAAI,IAAI;EAC5B,MAAM,KAAK,IAAI,eAAe,KAAK;AACnC,SAAO;GAAC,KAAK,IAAI,OAAO,GAAG,SAAS;GAAG,CAAC,KAAK,IAAI,OAAO,GAAG,SAAS;GAAG,KAAK,IAAI,IAAI,GAAG;GAAE;;CAE7F,kBAAkB,KAAK;EACnB,MAAM,CAAC,GAAG,GAAG,KAAK;EAClB,MAAM,IAAIO,IAAS,IAAI;EACvB,MAAM,MAAM,KAAK,KAAK,IAAI,EAAE;AAK5B,SAAO;GAJQ,KAAK,MAAM,GAAG,CAAC,EAAE,GACX;GACT,MAAM;IACP,IAAI,eAAe,KAAK;GACf;;CAExB,YAAY,KAAK;AACb,SAAO;;CAEX,cAAc,KAAK;AACf,SAAO;;;;;;;;;CASX,cAAc,CAAC,UAAU,UAAU,YAAY,OAAO,YAAY;EAG9D,MAAM,gBAAgB,MADR,KAAK,IAAI,GAAG,KAAK,OAAO,WAAW,KAAK,SAAS,CAAC;EAEhE,MAAM,YAAY,WAAW,iBAAiB,WAAW,KAAK,MAAM;EACpE,IAAI,WAAW,WAAW,iBAAiB,WAAW,KAAK,MAAM;AACjE,aAAW,KAAK,IAAI,KAAK,IAAI,UAAU,aAAa,EAAE,CAAC,aAAa;EACpE,MAAM,MAAM;GAAE;GAAW;GAAU,MAAM,YAAY,WAAW,SAAS;GAAE;AAC3E,MAAI,QAAQ,WAAW,IAAI,SAAS;AACpC,SAAO;;;AAGf,cAAc,cAAc;AAC5B,6BAAe;AACf,SAAgB,WAAW,UAAU;CACjC,MAAM,cAAc,KAAK,KAAK,KAAK,IAAK,WAAW,KAAK,KAAM,IAAI;AAClE,QAAO,KAAK,KAAK,YAAY;;AAEjC,SAAS,gBAAgB,QAAQ,QAAQ;CACrC,MAAM,SAASC,cAAmB,EAAE,EAAE,QAAQ,OAAO;AACrD,OAAW,QAAQ,QAAQ,IAAI,OAAO,GAAG;AACzC,QAAO;;;;;AC7KX,IAAM,gBAAgB;CAAC;CAAa;CAAY;CAAQ;CAAW;CAAQ;AAC3E,IAAM,yBAAyB;CAAC;CAAa;CAAY;CAAO;;;;AAIhE,IAAqB,qBAArB,cAAgD,uBAAuB;;;;;;;CAOnE,YAAY,OAAO,EAAE,EAAE;EAEnB,MAAM,kBAAkB,MAAM,QAAQ,KAAK,GAAG,OAAO,KAAK;EAC1D,MAAM,iBAAiB,MAAM,QAAQ,KAAK,GAAG,EAAE,GAAG;AAClD,iBAAe,kBAAkB,MAAM,QAAQ,gBAAgB,GACzD;GACE,SAAS;GACT,UAAU;GACb,GACC,mBAAmB;GACjB,SAAS;GACT,UAAU;GACb;AACL,QAAM,eAAe,gBAAgB;AACrC,OAAK,OAAO;;CAEhB,gBAAgB,YAAY,UAAU;EAClC,MAAM,SAAS,MAAM,gBAAgB,YAAY,SAAS;EAC1D,MAAM,EAAE,cAAc,WAAW,KAAK;AACtC,MAAI,gBAAgB,OAEhB,KADqB,aAAa,WAAW,YACjBC,uBACxB,aAAI,KAAK,oCAAoC,EAAE;OAE9C;GACD,MAAM,gBAAgB,aAAa,WAAW;GAC9C,MAAM,cAAc,aAAa,SAAS;GAC1C,MAAM,iBAAiB,cAAc,UAAU,OAAO;AACtD,UAAO,MAAM,SAAS;AACtB,UAAO,OAAO,OAAO,KAAK;IACtB,QAAQ,YAAY,QAAQ,eAAe;IAC3C;IACA,OAAO,SAAS;IAChB,QAAQ,SAAS;IACpB,CAAC;;AAGV,SAAO;;CAEX,iBAAiB,YAAY,UAAU,GAAG;EACtC,MAAM,oBAAoB,EAAE;AAC5B,OAAK,MAAM,OAAO,KAAK,gBACnB,mBAAkB,OAAO,KAAK,WAAW,QAAQ,GAAG,SAAS,QAAQ,GAAG,EAAE;AAE9E,MAAI,SAAS,kBAAkB,KAAK,KAAK,cAAc;GAEnD,MAAM,WAAW,KAAK,KAAK,aAAa;IAAE,GAAG;IAAU,GAAG;IAAmB,CAAC;AAC9E,UAAO,OAAO,mBAAmB,SAAS,cAAc,SAAS,gBAEjE,KAAK,WAAW,QAAQ,SAAS,QAAQ,EAAE,CAAC,CAAC;;AAEjD,SAAO;;;;;;AChEf,IAAM,sBAAsB,EACxB,oBAAoB,GACvB;AACD,IAAM,kBAAkB;AACxB,IAAM,kBAAiB,MAAK,KAAK,IAAI,MAAM,IAAI;AAC/C,IAAM,cAAc;CAChB,OAAO,CAAC,QAAQ;CAChB,KAAK;EAAC;EAAY;EAAW;EAAS;CACtC,OAAO;EAAC;EAAc;EAAa;EAAW;CAC9C,WAAW;EAAC;EAAiB;EAAgB;EAAc;CAC3D,cAAc,CAAC,WAAW;CAC1B,UAAU,CAAC,UAAU;CACxB;AACD,IAAM,uBAAuB,EAAE;AAC/B,IAAqB,aAArB,MAAgC;CAC5B,YAAY,MAAM;AACd,OAAK,QAAQ,EAAE;AACf,OAAK,UAAU,EAAE;AACjB,OAAK,oBAAoB,EACrB,YAAY,OACf;AACD,OAAK,gBAAgB,EAAE;AACvB,OAAK,qBAAqB;AAC1B,OAAK,WAAW;AAChB,OAAK,YAAY;AACjB,OAAK,WAAW;AAChB,OAAK,UAAU;AACf,OAAK,aAAa;AAClB,OAAK,UAAU;AACf,OAAK,aAAa;AAClB,OAAK,kBAAkB;AACvB,OAAK,YAAY;AACjB,OAAK,cAAc;AACnB,OAAK,WAAW;AAChB,OAAK,oBAAoB,IAAI,kBAAkB;GAC3C,GAAG;GACH,qBAAoB,UAAS,IAAI,KAAK,gBAAgB,MAAM;GAC5D,mBAAmB,KAAK,cAAc,KAAK,KAAK;GAChD,eAAe,KAAK,qBAAqB,KAAK,KAAK;GACtD,CAAC;AACF,OAAK,cAAc,KAAK,YAAY,KAAK,KAAK;AAC9C,OAAK,eAAe,KAAK;AACzB,OAAK,oBAAoB,KAAK,4BAA4B;AAC1D,OAAK,gBAAgB,KAAK,wBAAwB;AAClD,OAAK,eAAe,KAAK;;CAE7B,IAAI,OAAO,cAAc;AACrB,OAAK,aAAa,KAAK,eAAe,MAAM;AAC5C,OAAK,aAAa,cAAc,KAAK;AACrC,OAAK,gBAAgB;AAErB,MAAI,KAAK,MACL,MAAK,SAAS,KAAK,MAAM;;CAGjC,WAAW;AACP,OAAK,MAAM,aAAa,KAAK,QACzB,KAAI,KAAK,QAAQ,WAGb,MAAK,cAAc,IAAI,WAAW,KAAK,YAAY;AAG3D,OAAK,kBAAkB,UAAU;;;;;CAKrC,YAAY,OAAO;AAEf,OAAK,mBAAmB;EACxB,MAAM,oBAAoB,KAAK;AAC/B,UAAQ,MAAM,MAAd;GACI,KAAK,WACD,QAAO,oBAAoB,QAAQ,KAAK,YAAY,MAAM;GAC9D,KAAK,UACD,QAAO,KAAK,OAAO,MAAM;GAC7B,KAAK,SACD,QAAO,KAAK,UAAU,MAAM;GAChC,KAAK,aACD,QAAO,oBAAoB,QAAQ,KAAK,cAAc,MAAM;GAChE,KAAK,YACD,QAAO,KAAK,SAAS,MAAM;GAC/B,KAAK,WACD,QAAO,KAAK,YAAY,MAAM;GAClC,KAAK,gBACD,QAAO,oBAAoB,QAAQ,KAAK,iBAAiB,MAAM;GACnE,KAAK,eACD,QAAO,KAAK,YAAY,MAAM;GAClC,KAAK,cACD,QAAO,KAAK,eAAe,MAAM;GACrC,KAAK,WACD,QAAO,KAAK,eAAe,MAAM;GACrC,KAAK,QACD,QAAO,KAAK,SAAS,MAAM;GAC/B,KAAK,UACD,QAAO,KAAK,WAAW,MAAM;GACjC,QACI,QAAO;;;CAKnB,IAAI,kBAAkB;AAClB,OAAK,mBAAmB,KAAK,oBAAoB,IAAI,KAAK,gBAAgB;GACtE,cAAc,KAAK;GACnB,GAAG,KAAK;GACR,GAAG,KAAK;GACX,CAAC;AACF,SAAO,KAAK;;CAEhB,UAAU,OAAO;EACb,MAAM,EAAE,GAAG,MAAM,KAAK;EACtB,MAAM,EAAE,iBAAiB;AACzB,SAAO,CAAC,aAAa,IAAI,GAAG,aAAa,IAAI,EAAE;;CAEnD,gBAAgB,KAAK,OAAO;EACxB,MAAM,EAAE,OAAO,WAAW,KAAK;AAC/B,MAAI,SAAS,MAAM,QACf,QAAO;EAEX,MAAM,SAAS,IAAI,MAAM,KAAK,IAAI,MAAM,SAAS,IAAI,MAAM,KAAK,IAAI,MAAM;AAC1E,MAAI,UAAU,MACV,OAAM,iBAAiB;AAE3B,SAAO;;CAEX,qBAAqB,OAAO;EACxB,MAAM,EAAE,aAAa;AACrB,SAAO,QAAQ,SAAS,WAAW,SAAS,UAAU,SAAS,WAAW,SAAS,SAAS;;CAEhG,aAAa;AACT,SAAO,KAAK,kBAAkB,cAAc;;CAKhD,YAAY,SAAS;EAEjB,MAAM,QAAQ,iBAAiB;AAC3B,OAAI,KAAK,uBAAuB,MAC5B,MAAK,qBAAqB;KAE/B,QAAQ;AACX,OAAK,qBAAqB;;;;;CAK9B,SAAS,OAAO;AACZ,MAAI,MAAM,SACN,MAAK,WAAW,MAAM;AAE1B,OAAK,QAAQ;AACb,MAAI,EAAE,4BAA4B,OAE9B,OAAM,yBAAyB,KAAK,qBAAqB,CAAC;AAE9D,OAAK,kBAAkB,uBAAuB,MAAM;EACpD,MAAM,EAAE,YAAY;AACpB,OAAK,UAAU,OAAO,SAAS,QAAQ,GAAG,UAAW,YAAY,OAAO,kBAAkB;EAE1F,MAAM,EAAE,aAAa,MAAM,UAAU,MAAM,aAAa,MAAM,kBAAkB,MAAM,YAAY,MAAM,cAAc,OAAO,WAAW,SAAS;EAEjJ,MAAM,gBAAgB,QAAQ,KAAK,kBAAkB;AACrD,OAAK,aAAa,YAAY,OAAO,iBAAiB,WAAW;AAEjE,OAAK,aAAa,YAAY,KAAK,cAAc;AACjD,OAAK,aAAa,YAAY,OAAO,kBAAkB,aAAa,aAAa;AACjF,OAAK,aAAa,YAAY,WAAW,iBAAiB,YAAY;AACtE,OAAK,aAAa,YAAY,cAAc,iBAAiB,gBAAgB;AAC7E,OAAK,aAAa,YAAY,UAAU,iBAAiB,SAAS;AAElE,OAAK,aAAa;AAClB,OAAK,UAAU;AACf,OAAK,aAAa;AAClB,OAAK,kBAAkB;AACvB,OAAK,YAAY;AACjB,OAAK,cAAc;AACnB,OAAK,WAAW;;CAEpB,mBAAmB;AACf,OAAK,kBAAkB,kBAAkB;;CAE7C,aAAa,YAAY,SAAS;AAC9B,MAAI,KAAK,aACL,YAAW,SAAQ,cAAa;AAC5B,OAAI,KAAK,QAAQ,eAAe,SAAS;AACrC,SAAK,QAAQ,aAAa;AAC1B,QAAI,QAEA,MAAK,aAAa,GAAG,WAAW,KAAK,YAAY;QAIjD,MAAK,aAAa,IAAI,WAAW,KAAK,YAAY;;IAG5D;;CAMV,eAAe,oBAAoB,aAAa,MAAM,mBAAmB,EAAE,EAAE;EACzE,MAAM,YAAY;GAAE,GAAG,mBAAmB,kBAAkB;GAAE,GAAG;GAAY;EAE7E,MAAM,UAAU,KAAK,oBAAoB;AAGzC,OAAK,QAAQ,mBAAmB,UAAU;AAC1C,OAAK,qBAAqB,iBAAiB;AAC3C,MAAI,SAAS;GACT,MAAM,eAAe,KAAK,mBAAmB,KAAK,gBAAgB,kBAAkB;AACpF,OAAI,KAAK,kBACL,MAAK,kBAAkB;IAAE;IAAW,kBAAkB,KAAK;IAAmB;IAAc,QAAQ,KAAK,MAAM;IAAI,CAAC;;;CAIhI,cAAc,QAAQ;AAClB,OAAK,kBAAkB;GAAE,GAAG;GAAQ,kBAAkB,KAAK;GAAmB,QAAQ,KAAK,MAAM;GAAI,CAAC;;CAE1G,qBAAqB,WAAW;AAC5B,SAAO,OAAO,KAAK,mBAAmB,UAAU;AAChD,OAAK,cAAc,KAAK,kBAAkB;;CAI9C,YAAY,OAAO;EACf,MAAM,MAAM,KAAK,UAAU,MAAM;AACjC,MAAI,CAAC,KAAK,gBAAgB,KAAK,MAAM,CACjC,QAAO;EAEX,IAAI,gBAAgB,KAAK,qBAAqB,MAAM,IAAI,MAAM,eAAe;AAC7E,MAAI,KAAK,aAAa,KAAK,aAAa,MAEpC,iBAAgB,CAAC;EAErB,MAAM,qBAAqB,KAAK,gBAAgB,gBAAgB,aAAa,eAAe,EACxF,KACH,CAAC;AACF,OAAK,WAAW;AAChB,OAAK,eAAe,oBAAoB,qBAAqB,EAAE,YAAY,MAAM,CAAC;AAClF,SAAO;;CAGX,OAAO,OAAO;AACV,MAAI,CAAC,KAAK,YAAY,CAClB,QAAO;AAEX,SAAO,KAAK,WAAW,KAAK,WAAW,MAAM,GAAG,KAAK,aAAa,MAAM;;CAE5E,UAAU,OAAO;AACb,MAAI,CAAC,KAAK,YAAY,CAClB,QAAO;AAEX,SAAO,KAAK,WAAW,KAAK,cAAc,MAAM,GAAG,KAAK,gBAAgB,MAAM;;CAIlF,WAAW,OAAO;AACd,MAAI,CAAC,KAAK,QACN,QAAO;EAEX,MAAM,MAAM,KAAK,UAAU,MAAM;EACjC,MAAM,qBAAqB,KAAK,gBAAgB,IAAI,EAAE,KAAK,CAAC;AAC5D,OAAK,eAAe,oBAAoB,qBAAqB;GACzD,YAAY;GACZ,WAAW;GACd,CAAC;AACF,SAAO;;CAEX,cAAc,OAAO;EACjB,MAAM,EAAE,YAAY;AACpB,MAAI,KAAK,WAAW,WAAW,MAAM,UAAU;GAC3C,MAAM,MAAM,KAAK,UAAU,MAAM;GACjC,MAAM,SAAS,CACX,IAAI,KAAM,MAAM,YAAY,UAAW,GACvC,IAAI,KAAM,MAAM,YAAY,UAAW,EAC1C;GACD,MAAM,qBAAqB,KAAK,gBAAgB,IAAI,EAAE,KAAK,QAAQ,CAAC,CAAC,QAAQ;AAC7E,QAAK,eAAe,oBAAoB;IACpC,GAAG,KAAK,qBAAqB;IAC7B,oBAAoB;IACpB,kBAAkB;IACrB,EAAE;IACC,YAAY;IACZ,WAAW;IACd,CAAC;SAED;GACD,MAAM,qBAAqB,KAAK,gBAAgB,QAAQ;AACxD,QAAK,eAAe,oBAAoB,MAAM;IAC1C,YAAY;IACZ,WAAW;IACd,CAAC;;AAEN,SAAO;;CAIX,aAAa,OAAO;AAChB,MAAI,CAAC,KAAK,WACN,QAAO;EAEX,MAAM,MAAM,KAAK,UAAU,MAAM;EACjC,MAAM,qBAAqB,KAAK,gBAAgB,OAAO,EAAE,KAAK,CAAC;AAC/D,OAAK,eAAe,oBAAoB,qBAAqB;GACzD,YAAY;GACZ,YAAY;GACf,CAAC;AACF,SAAO;;CAEX,gBAAgB,OAAO;EACnB,MAAM,EAAE,YAAY;AACpB,MAAI,KAAK,cAAc,WAAW,MAAM,UAAU;GAC9C,MAAM,MAAM,KAAK,UAAU,MAAM;GACjC,MAAM,SAAS,CACX,IAAI,KAAM,MAAM,YAAY,UAAW,GACvC,IAAI,KAAM,MAAM,YAAY,UAAW,EAC1C;GACD,MAAM,qBAAqB,KAAK,gBAAgB,OAAO,EAAE,KAAK,QAAQ,CAAC,CAAC,WAAW;AACnF,QAAK,eAAe,oBAAoB;IACpC,GAAG,KAAK,qBAAqB;IAC7B,oBAAoB;IACpB,kBAAkB;IACrB,EAAE;IACC,YAAY;IACZ,YAAY;IACf,CAAC;SAED;GACD,MAAM,qBAAqB,KAAK,gBAAgB,WAAW;AAC3D,QAAK,eAAe,oBAAoB,MAAM;IAC1C,YAAY;IACZ,YAAY;IACf,CAAC;;AAEN,SAAO;;CAGX,SAAS,OAAO;AACZ,MAAI,CAAC,KAAK,WACN,QAAO;EAEX,MAAM,MAAM,KAAK,UAAU,MAAM;AACjC,MAAI,CAAC,KAAK,gBAAgB,KAAK,MAAM,CACjC,QAAO;AAEX,QAAM,SAAS,gBAAgB;EAC/B,MAAM,EAAE,QAAQ,KAAM,SAAS,UAAU,KAAK,eAAe,OAAO,EAAE,GAAG,KAAK;EAC9E,MAAM,EAAE,UAAU;EAElB,IAAIC,UAAQ,KAAK,IAAI,KAAK,IAAI,CAAC,KAAK,IAAI,QAAQ,MAAM,CAAC;AACvD,MAAI,QAAQ,KAAKA,YAAU,EACvB,WAAQ,IAAIA;EAEhB,MAAM,kBAAkB,SAClB;GAAE,GAAG,KAAK,oBAAoB,EAAE,QAAQ,KAAK,CAAC;GAAE,oBAAoB;GAAK,GACzE;EACN,MAAM,qBAAqB,KAAK,gBAAgB,KAAK;GAAE;GAAK;GAAO,CAAC;AACpE,OAAK,eAAe,oBAAoB,iBAAiB;GACrD,WAAW;GACX,WAAW;GACd,CAAC;AAGF,MAAI,CAAC,OACD,MAAK,qBAAqB;GAAE,WAAW;GAAO,WAAW;GAAO,CAAC;AAErE,SAAO;;CAEX,iBAAiB,OAAO;EACpB,MAAM,MAAM,KAAK,UAAU,MAAM;AACjC,MAAI,CAAC,KAAK,gBAAgB,KAAK,MAAM,CACjC,QAAO;EAEX,MAAM,qBAAqB,KAAK,gBAAgB,YAAY,EAAE,KAAK,CAAC;AACpE,OAAK,eAAe,oBAAoB,qBAAqB,EAAE,YAAY,MAAM,CAAC;AAClF,SAAO;;CAEX,YAAY,OAAO;AACf,MAAI,CAAC,KAAK,YACN,QAAO;AAEX,MAAI,CAAC,KAAK,YAAY,CAClB,QAAO;EAEX,MAAM,MAAM,KAAK,UAAU,MAAM;AACjC,MAAI,MAAM,MAAM;EAChB,MAAM,qBAAqB,KAAK,gBAAgB,OAAO,EAAE,KAAK,CAAC;AAC/D,OAAK,eAAe,oBAAoB,qBAAqB;GACzD,YAAY;GACZ,YAAY;GACf,CAAC;AACF,SAAO;;CAEX,eAAe,OAAO;AAClB,MAAI,CAAC,KAAK,YAAY,CAClB,QAAO;EAEX,MAAM,EAAE,YAAY;AACpB,MAAI,KAAK,eAAe,WAAW,MAAM,WAAW;GAChD,MAAM,MAAM,KAAK,UAAU,MAAM;GACjC,MAAM,SAAS,CAAC,IAAI,IAAK,IAAI,MAAO,MAAM,YAAY,UAAW,EAAG;GACpE,MAAM,qBAAqB,KAAK,gBAAgB,OAAO,EAAE,KAAK,QAAQ,CAAC;AACvE,QAAK,eAAe,oBAAoB;IACpC,GAAG,KAAK,qBAAqB;IAC7B,oBAAoB;IACpB,kBAAkB;IACrB,EAAE;IACC,YAAY;IACZ,YAAY;IACf,CAAC;AACF,QAAK,YAAY,QAAQ;SAExB;GACD,MAAM,qBAAqB,KAAK,gBAAgB,WAAW;AAC3D,QAAK,eAAe,oBAAoB,MAAM;IAC1C,YAAY;IACZ,YAAY;IACf,CAAC;;AAEN,SAAO;;CAGX,cAAc,OAAO;EACjB,MAAM,MAAM,KAAK,UAAU,MAAM;AACjC,MAAI,CAAC,KAAK,gBAAgB,KAAK,MAAM,CACjC,QAAO;EAEX,MAAM,qBAAqB,KAAK,gBAAgB,UAAU,EAAE,KAAK,CAAC,CAAC,YAAY,EAAE,KAAK,CAAC;AAEvF,uBAAqB,sBAAsB,MAAM;AACjD,uBAAqB,kBAAkB;AACvC,OAAK,eAAe,oBAAoB,qBAAqB,EAAE,YAAY,MAAM,CAAC;AAClF,SAAO;;CAGX,SAAS,OAAO;AACZ,MAAI,CAAC,KAAK,aAAa,CAAC,KAAK,YACzB,QAAO;AAEX,MAAI,CAAC,KAAK,YAAY,CAClB,QAAO;EAEX,IAAI,qBAAqB,KAAK;AAC9B,MAAI,KAAK,WAAW;GAChB,MAAM,EAAE,mBAAU;GAClB,MAAM,MAAM,KAAK,UAAU,MAAM;AACjC,wBAAqB,mBAAmB,KAAK;IAAE;IAAK;IAAO,CAAC;;AAEhE,MAAI,KAAK,aAAa;GAClB,MAAM,EAAE,aAAa;AACrB,wBAAqB,mBAAmB,OAAO,EAC3C,aAAa,qBAAqB,sBAAsB,UAC3D,CAAC;;AAEN,OAAK,eAAe,oBAAoB,qBAAqB;GACzD,YAAY;GACZ,WAAW,KAAK;GAChB,WAAW,KAAK;GAChB,YAAY,KAAK;GACpB,CAAC;AACF,uBAAqB,kBAAkB;AACvC,SAAO;;CAEX,YAAY,OAAO;AACf,MAAI,CAAC,KAAK,YAAY,CAClB,QAAO;EAEX,MAAM,EAAE,YAAY;EACpB,MAAM,EAAE,oBAAoB;AAC5B,MAAI,KAAK,aAAa,WAAW,mBAAmB,MAAM,UAAU,gBAAgB,OAAO;GACvF,MAAM,MAAM,KAAK,UAAU,MAAM;GACjC,IAAI,qBAAqB,KAAK,gBAAgB,WAAW;GACzD,MAAM,IAAI,KAAK,KAAK,MAAM,MAAM;GAChC,MAAM,aAAa,IAAI,KAAK,KAAK,gBAAgB,MAAM,KAAK,MAAM,YAAY,gBAAgB;GAC9F,MAAM,WAAW,KAAK,IAAI,GAAG,IAAK,YAAY,UAAW,EAAE;AAC3D,wBAAqB,mBAAmB,KAAK;IAAE;IAAK,OAAO;IAAU,CAAC,CAAC,SAAS;AAChF,QAAK,eAAe,oBAAoB;IACpC,GAAG,KAAK,oBAAoB,EAAE,QAAQ,KAAK,CAAC;IAC5C,oBAAoB;IACpB,kBAAkB;IACrB,EAAE;IACC,YAAY;IACZ,WAAW,KAAK;IAChB,WAAW,KAAK;IAChB,YAAY;IACf,CAAC;AACF,QAAK,YAAY,QAAQ;SAExB;GACD,MAAM,qBAAqB,KAAK,gBAAgB,SAAS,CAAC,WAAW;AACrE,QAAK,eAAe,oBAAoB,MAAM;IAC1C,YAAY;IACZ,WAAW;IACX,WAAW;IACX,YAAY;IACf,CAAC;;AAEN,uBAAqB,sBAAsB;AAC3C,uBAAqB,kBAAkB;AACvC,SAAO;;CAGX,eAAe,OAAO;AAClB,MAAI,CAAC,KAAK,gBACN,QAAO;EAEX,MAAM,MAAM,KAAK,UAAU,MAAM;AACjC,MAAI,CAAC,KAAK,gBAAgB,KAAK,MAAM,CACjC,QAAO;EAEX,MAAM,YAAY,KAAK,qBAAqB,MAAM;EAClD,MAAM,qBAAqB,KAAK,gBAAgB,KAAK;GAAE;GAAK,OAAO,YAAY,KAAM;GAAG,CAAC;AACzF,OAAK,eAAe,oBAAoB,KAAK,oBAAoB,EAAE,QAAQ,KAAK,CAAC,EAAE;GAC/E,WAAW;GACX,WAAW;GACd,CAAC;AACF,OAAK,YAAY,IAAI;AACrB,SAAO;;CAGX,WAAW,OAAO;AACd,MAAI,CAAC,KAAK,SACN,QAAO;EAEX,MAAM,UAAU,KAAK,qBAAqB,MAAM;EAEhD,MAAM,EAAE,WAAW,WAAW,cAAc,iBAAiB,KAAK,aAAa,OAAO,EAAE,GAAG,KAAK;EAChG,MAAM,EAAE,oBAAoB;EAC5B,IAAI;EACJ,MAAM,mBAAmB,EAAE;AAC3B,UAAQ,MAAM,SAAS,MAAvB;GACI,KAAK;AACD,yBAAqB,UACf,gBAAgB,QAAQ,UAAU,CAAC,QAAQ,UAAU,GACrD,gBAAgB,QAAQ,UAAU;AACxC,qBAAiB,YAAY;AAC7B;GACJ,KAAK;AACD,yBAAqB,UACf,gBAAgB,OAAO,UAAU,CAAC,OAAO,UAAU,GACnD,gBAAgB,OAAO,UAAU;AACvC,qBAAiB,YAAY;AAC7B;GACJ,KAAK;AACD,QAAI,SAAS;AACT,0BAAqB,gBAAgB,WAAW,aAAa;AAC7D,sBAAiB,aAAa;WAE7B;AACD,0BAAqB,gBAAgB,SAAS,UAAU;AACxD,sBAAiB,YAAY;;AAEjC;GACJ,KAAK;AACD,QAAI,SAAS;AACT,0BAAqB,gBAAgB,YAAY,aAAa;AAC9D,sBAAiB,aAAa;WAE7B;AACD,0BAAqB,gBAAgB,UAAU,UAAU;AACzD,sBAAiB,YAAY;;AAEjC;GACJ,KAAK;AACD,QAAI,SAAS;AACT,0BAAqB,gBAAgB,SAAS,aAAa;AAC3D,sBAAiB,aAAa;WAE7B;AACD,0BAAqB,gBAAgB,OAAO,UAAU;AACtD,sBAAiB,YAAY;;AAEjC;GACJ,KAAK;AACD,QAAI,SAAS;AACT,0BAAqB,gBAAgB,WAAW,aAAa;AAC7D,sBAAiB,aAAa;WAE7B;AACD,0BAAqB,gBAAgB,SAAS,UAAU;AACxD,sBAAiB,YAAY;;AAEjC;GACJ,QACI,QAAO;;AAEf,OAAK,eAAe,oBAAoB,KAAK,qBAAqB,EAAE,iBAAiB;AACrF,SAAO;;CAEX,oBAAoB,MAAM;EACtB,MAAM,EAAE,eAAe;AACvB,MAAI,CAAC,cAAc,CAAC,WAAW,uBAC3B,QAAO;AAGX,SAAO,OACD;GACE,GAAG;GACH,wBAAwB,IAAI,mBAAmB;IAC3C,GAAG;IACH,GAAG,WAAW,uBAAuB;IACrC,cAAc,KAAK,gBAAgB;IACtC,CAAC;GACL,GACC;;;;;;ACnmBd,IAAqB,YAArB,MAA+B;CAC3B,YAAY,OAAO,OAAO;AACtB,OAAK,iBAAiB,KAAK,iBAAiB,MAAM;AAClD,OAAK,SAAS;;CAElB,mBAAmB;AACf,SAAO,KAAK;;CAEhB,WAAW;AACP,SAAO,KAAK;;;;;;ACHpB,IAAM,wBAAwB;AAC9B,IAAM,cAAc;AAEpB,IAAa,WAAb,cAA8B,UAAU;CACpC,YAAY,SAAS;EACjB,MAAM,EAGN,OAEA,QAEA,UAEA,WAEA,MAEA,UAAU,GAEV,QAAQ,GAMR,WAAW,KAEX,WAAW;GAAC;GAAG;GAAG;GAAE,EAEpB,UAAU,IAAI,UAAU,GAAG,WAAW,IAAI,WAAW,GAGrD,gBAEA,iBAEA,gBAEA,cAEA,YAEA,WAEA,YAAY,SAAS;AACrB,SAAO,OAAO,SAAS,UAAU,CAAC;AAClC,SAAO,OAAO,SAAS,SAAS,CAAC;AACjC,SAAO,OAAO,SAAS,KAAK,CAAC;AAC7B,QAAM;GACF;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACH,EAAE;GACC;GACA;GACA;GACA;GACA;GACA;GACH,CAAC;AACF,OAAK,eAAe,QAAQ;;;;;;CAMhC,SAAS,EAAE,OAAO;AACd,SAAO,KAAK,iBAAiB,EACzB,gBAAgB,KAAK,WAAW,IAAI,EACvC,CAAC;;;;;;;;CAQN,IAAI,EAAE,KAAK,YAAY;EACnB,MAAM,iBAAiB,KAAK,UAAU,CAAC,kBAAkB,KAAK,WAAW,SAAS;AAClF,MAAI,CAAC,eACD,QAAO;EAGX,MAAM,WADW,KAAK,aAAa,KAAK,kBAAkB,CAAC,CACjC,cAAc,gBAAgB,IAAI;AAC5D,SAAO,KAAK,iBAAiB,SAAS;;;;;;CAM1C,SAAS;AACL,SAAO,KAAK,iBAAiB,EACzB,gBAAgB,MACnB,CAAC;;;;;;CAMN,YAAY,EAAE,OAAO;AACjB,SAAO,KAAK,iBAAiB;GACzB,gBAAgB;GAChB,cAAc,KAAK,kBAAkB,CAAC;GACtC,YAAY,KAAK,kBAAkB,CAAC;GACvC,CAAC;;;;;;CAMN,OAAO,EAAE,KAAK,cAAc,GAAG,cAAc,KAAK;EAC9C,MAAM,EAAE,gBAAgB,cAAc,eAAe,KAAK,UAAU;AACpE,MAAI,CAAC,kBAAkB,iBAAiB,UAAa,eAAe,OAChE,QAAO;EAEX,IAAI;AACJ,MAAI,IACA,eAAc,KAAK,gBAAgB,KAAK,gBAAgB,YAAY,aAAa;MAGjF,eAAc;GACV,SAAS,eAAe;GACxB,OAAO,aAAa;GACvB;AAEL,SAAO,KAAK,iBAAiB,YAAY;;;;;;CAM7C,YAAY;AACR,SAAO,KAAK,iBAAiB;GACzB,cAAc;GACd,YAAY;GACf,CAAC;;;;;;CAMN,UAAU,EAAE,OAAO;AACf,SAAO,KAAK,iBAAiB;GACzB,iBAAiB,KAAK,WAAW,IAAI;GACrC,WAAW,KAAK,kBAAkB,CAAC;GACtC,CAAC;;;;;;;;;;CAUN,KAAK,EAAE,KAAK,UAAU,kBAAS;EAE3B,IAAI,EAAE,WAAW,oBAAoB,KAAK,UAAU;AACpD,MAAI,CAAC,iBAAiB;AAOlB,eAAY,KAAK,kBAAkB,CAAC;AACpC,qBAAkB,KAAK,WAAW,SAAS,IAAI,KAAK,WAAW,IAAI;;AAEvE,MAAI,CAAC,gBACD,QAAO;EAEX,MAAM,EAAE,SAAS,YAAY,KAAK,kBAAkB;EACpD,IAAI,OAAO,YAAY,KAAK,KAAKC,QAAM;AACvC,SAAO,MAAM,MAAM,SAAS,QAAQ;EACpC,MAAM,iBAAiB,KAAK,aAAa;GAAE,GAAG,KAAK,kBAAkB;GAAE;GAAM,CAAC;AAC9E,SAAO,KAAK,iBAAiB;GACzB;GACA,GAAG,eAAe,cAAc,iBAAiB,IAAI;GACxD,CAAC;;;;;;CAMN,UAAU;AACN,SAAO,KAAK,iBAAiB;GACzB,iBAAiB;GACjB,WAAW;GACd,CAAC;;CAEN,OAAO,QAAQ,GAAG;AACd,SAAO,KAAK,gBAAgB,MAAM;;CAEtC,QAAQ,QAAQ,GAAG;AACf,SAAO,KAAK,gBAAgB,IAAI,MAAM;;CAE1C,SAAS,QAAQ,KAAK;AAClB,SAAO,KAAK,eAAe,CAAC,OAAO,EAAE,CAAC;;CAE1C,UAAU,QAAQ,KAAK;AACnB,SAAO,KAAK,eAAe,CAAC,CAAC,OAAO,EAAE,CAAC;;CAE3C,OAAO,QAAQ,KAAK;AAChB,SAAO,KAAK,eAAe,CAAC,GAAG,MAAM,CAAC;;CAE1C,SAAS,QAAQ,KAAK;AAClB,SAAO,KAAK,eAAe,CAAC,GAAG,CAAC,MAAM,CAAC;;CAE3C,WAAW,QAAQ,IAAI;AACnB,SAAO,KAAK,iBAAiB,EACzB,SAAS,KAAK,kBAAkB,CAAC,UAAU,OAC9C,CAAC;;CAEN,YAAY,QAAQ,IAAI;AACpB,SAAO,KAAK,iBAAiB,EACzB,SAAS,KAAK,kBAAkB,CAAC,UAAU,OAC9C,CAAC;;CAEN,SAAS,QAAQ,IAAI;AACjB,SAAO,KAAK,iBAAiB,EACzB,OAAO,KAAK,kBAAkB,CAAC,QAAQ,OAC1C,CAAC;;CAEN,WAAW,QAAQ,IAAI;AACnB,SAAO,KAAK,iBAAiB,EACzB,OAAO,KAAK,kBAAkB,CAAC,QAAQ,OAC1C,CAAC;;CAEN,iBAAiB,WAAW;EAExB,MAAM,YAAY,UAAU,kBAAkB;EAC9C,MAAM,QAAQ,EAAE,GAAG,KAAK,kBAAkB,EAAE;EAC5C,MAAM,EAAE,SAAS,cAAc;AAC/B,MAAI,KAAK,IAAI,UAAU,UAAU,QAAQ,GAAG,IACxC,OAAM,UAAU,UAAU,IAAI,UAAU,MAAM,UAAU;AAE5D,MAAI,KAAK,IAAI,YAAY,UAAU,UAAU,GAAG,IAC5C,OAAM,YAAY,YAAY,IAAI,YAAY,MAAM,YAAY;AAEpE,SAAO;;CAGX,iBAAiB,OAAO;EAEpB,MAAM,EAAE,SAAS,SAAS,SAAS;AACnC,QAAM,OAAO,MAAM,MAAM,SAAS,QAAQ;EAE1C,MAAM,EAAE,UAAU,UAAU,UAAU;AACtC,QAAM,QAAQ,MAAM,OAAO,UAAU,SAAS;EAE9C,MAAM,EAAE,YAAY,SAAS;AAC7B,MAAI,UACA,QAAO,OAAO,OAAO,uBAAuB,MAAM,CAAC;AAEvD,SAAO;;CAGX,gBAAgB,SAAO;EACnB,MAAM,EAAE,OAAO,WAAW,KAAK,kBAAkB;AACjD,SAAO,KAAK,KAAK;GACb,KAAK,CAAC,QAAQ,GAAG,SAAS,EAAE;GAC5B;GACH,CAAC;;CAEN,eAAe,QAAQ;EACnB,MAAM,EAAE,OAAO,WAAW,KAAK,kBAAkB;AACjD,SAAO,KAAK,IAAI;GACZ,UAAU,CAAC,QAAQ,GAAG,SAAS,EAAE;GACjC,KAAK,CAAC,QAAQ,IAAI,OAAO,IAAI,SAAS,IAAI,OAAO,GAAG;GACvD,CAAC;;CAEN,iBAAiB,UAAU;AAEvB,SAAO,IAAI,KAAK,YAAY;GACxB,cAAc,KAAK;GACnB,GAAG,KAAK,kBAAkB;GAC1B,GAAG,KAAK,UAAU;GAClB,GAAG;GACN,CAAC;;CAEN,WAAW,KAAK;EACZ,MAAM,WAAW,KAAK,aAAa,KAAK,kBAAkB,CAAC;AAE3D,SAAO,OAAO,SAAS,UAAU,IAAI;;CAEzC,gBAAgB,KAAK,UAAU,YAAY,cAAc;EACrD,MAAM,SAAS,IAAI,KAAK,SAAS;EACjC,MAAM,SAAS,IAAI,KAAK,SAAS;EACjC,MAAM,UAAU,IAAI;EACpB,MAAM,SAAS,SAAS;EACxB,MAAM,EAAE,OAAO,WAAW,KAAK,kBAAkB;EACjD,MAAM,cAAc,SAAS;EAC7B,IAAI,cAAc;AAClB,MAAI,SAAS,GACT;OAAI,KAAK,IAAI,SAAS,OAAO,GAAG,sBAE5B,eAAe,UAAU,SAAS,UAAW;aAG5C,SAAS,GACd;OAAI,SAAS,sBAET,eAAc,IAAI,UAAU;;AAKpC,gBAAc,MAAM,aAAa,IAAI,EAAE;EACvC,MAAM,EAAE,UAAU,aAAa,KAAK,kBAAkB;EACtD,MAAM,UAAU,eAAe,MAAM;EACrC,IAAI,QAAQ;AACZ,MAAI,cAAc,EAEd,SAAQ,aAAa,eAAe,WAAW;WAE1C,cAAc,EAEnB,SAAQ,aAAa,eAAe,WAAW;AAEnD,SAAO;GACH;GACA;GACH;;;AAGT,IAAqB,gBAArB,cAA2C,WAAW;CAClD,cAAc;AACV,QAAM,GAAG,UAAU;AACnB,OAAK,kBAAkB;AACvB,OAAK,aAAa;GACd,oBAAoB;GACpB,wBAAwB,IAAI,mBAAmB,EAC3C,iBAAiB;IACb,SAAS;KAAC;KAAa;KAAY;KAAQ;KAAW;KAAS;KAAW;IAC1E,UAAU;KAAC;KAAa;KAAY;KAAO;IAC9C,EACJ,CAAC;GACL;AACD,OAAK,WAAW;;CAEpB,SAAS,OAAO;AACZ,QAAM,WAAW,MAAM,YAAY;GAAC;GAAG;GAAG;GAAE;EAC5C,MAAM,WAAW,KAAK;AACtB,QAAM,SAAS,MAAM;AAErB,MADyB,CAAC,YAAY,SAAS,WAAW,MAAM,OAG5D,MAAK,eAAe,IAAI,KAAK,gBAAgB;GACzC,cAAc,KAAK;GACnB,GAAG;GACH,GAAG,KAAK;GACX,CAAC,CAAC;;;;;;AC9Wf,IAAM,UAAN,cAAsB,KAAK;CACvB,YAAY,QAAQ,EAAE,EAAE;AACpB,QAAM,MAAM;;CAEhB,kBAAkB;AACd,SAAOC;;CAEX,IAAI,iBAAiB;AACjB,SAAO;;;AAGf,QAAQ,cAAc;AACtB,uBAAe;;;;ACbf,IAAM,0BAA0B,IAAI,gBAAgB;;AAEpD,SAAS,eAAe,IAAI,IAAI;AAG5B,SAFW,GAAG,SAAS,aACZ,GAAG,SAAS;;AAG3B,IAAqB,gBAArB,MAAmC;CAC/B,YAAY,SAAS;AACjB,OAAK,mBAAmB,EAAE;;AAE1B,OAAK,kBAAkB,EAAE;AACzB,OAAK,UAAU,EAAE;AACjB,OAAK,WAAW;AAChB,OAAK,eAAe;AACpB,OAAK,YAAY,EAAE,CAAC;;;;;CAKxB,iBAAiB,QAAQ;EACrB,MAAM,iBAAiB,KAAK;AAC5B,MAAI,CAAC,eAAe,MAAK,MAAK,EAAE,OAAO,OAAO,GAAG,EAAE;GAC/C,MAAM,QAAQ,eAAe,WAAU,MAAK,eAAe,GAAG,OAAO,GAAG,EAAE;AAC1E,OAAI,QAAQ,EACR,gBAAe,KAAK,OAAO;OAG3B,gBAAe,OAAO,OAAO,GAAG,OAAO;AAE3C,UAAO,MAAM,KAAK,SAAS;AAC3B,QAAK,YAAY,KAAK,QAAQ;;;CAGtC,SAAS,OAAO;AACZ,MAAI,aAAa,OAEb;OAAI,CAAC,UAAU,MAAM,SAAS,KAAK,SAAS,EAAE,CAC1C,MAAK,YAAY,MAAM,QAAQ;;;CAI3C,YAAY,OAAO,EAAE,kBAAkB,OAAO,EAAE;EAC5C,MAAM,SAAS,KAAK;AACpB,MAAI,KAAK,iBACL,MAAK,eAAe;AAExB,SAAO;;CAEX,aAAa;AACT,SAAO,KAAK;;CAEhB,YAAY,SAAS;EACjB,MAAM,gBAAgB,EAAE;AACxB,OAAK,MAAM,UAAU,KAAK,QACtB,eAAc,OAAO,MAAM;EAE/B,MAAM,cAAc,EAAE;AACtB,OAAK,MAAM,UAAU,SAAS;GAC1B,MAAM,YAAY,cAAc,OAAO;GACvC,IAAI,cAAc;AAClB,OAAI,aAAa,cAAc,OAC3B,KAAI,UAAU,UAAU;AACpB,cAAU,SAAS,OAAO,MAAM;AAChC,kBAAc;SAGd,WAAU,QAAQ,KAAK,SAAS;YAG/B,CAAC,UACN,QAAO,MAAM,KAAK,SAAS;AAE/B,eAAY,KAAK,YAAY;AAC7B,UAAO,cAAc,OAAO;;AAEhC,OAAK,MAAM,mBAAmB,cAC1B,eAAc,iBAAiB,QAAQ,KAAK,SAAS;AAEzD,OAAK,UAAU;AACf,OAAK,mBAAmB,YAAY,OAAO,KAAK,gBAAgB;AAEhE,MAAI,CAAC,QAAQ,MAAK,WAAU,kBAAkB,eAAe,CACzD,MAAK,iBAAiB,KAAK,wBAAwB;AAEvD,OAAK,eAAe;;CAExB,WAAW;AACP,OAAK,MAAM,UAAU,KAAK,iBACtB,QAAO,QAAQ,KAAK,SAAS;AAEjC,OAAK,QAAQ,SAAS;AACtB,OAAK,iBAAiB,SAAS;AAC/B,OAAK,gBAAgB,SAAS;;;;;;AC9FtC,IAAqB,iBAArB,cAA4C,WAAW;CACnD,gBAAgB,OAAO;EACnB,MAAM,EAAE,cAAc,MAAM;AAC5B,SAAO,UAAU,SAAS,OAAO,IAAI,UAAU,SAAS,UAAU;;;;;;ACD1E,IAAM,sBAAsB;AAC5B,IAAqB,eAArB,MAAkC;CAC9B,YAAY,QAAQ;AAChB,OAAK,SAAS;AACd,OAAK,cAAc;AACnB,OAAK,oBAAoB;AACzB,OAAK,iBAAiB,IAAI,eAAe,OAAO;AAChD,OAAK,iBAAiB,IAAI,eAAe,OAAO;AAChD,OAAK,cAAc;AACnB,OAAK,eAAe;AACpB,OAAK,gBAAgB,EAAE;AACvB,OAAK,wBAAwB;;CAEjC,SAAS,OAAO;AACZ,MAAI,KAAK,gBAAgB,MAAM,aAAa;AACxC,QAAK,cAAc,MAAM;AACzB,QAAK,eAAe;;AAExB,MAAI,KAAK,sBAAsB,MAAM,mBAAmB;AACpD,QAAK,oBAAoB,MAAM;AAC/B,QAAK,eAAe;;;CAG5B,aAAa,MAAM;AACf,MAAI,CAAC,KAAK,UAAU,OAChB;EAEJ,MAAM,YAAY,KAAK,oBAAoB,KAAK,iBAAiB,KAAK;EACtE,MAAM,aAAa;GACf,aAAa,KAAK;GAClB,WAAW,KAAK;GAChB,GAAG;GACN;AACD,MAAI,WAAW,QACX,MAAK,WAAW,WAAW,SAAS,WAAW;EAEnD,MAAM,eAAe,KAAK,wBAAwB,KAAK,cAAc,KAAK,WAAW;AACrF,MAAI,KAAK,uBAAuB;AAC5B,cAAW,aAAa;IAAC;IAAG;IAAG;IAAG;IAAE;AACpC,cAAW,cAAc;;EAE7B,MAAM,cAAc,UAAU,OAAO;GAAE,GAAG;GAAY,QAAQ;GAAc,CAAC;AAC7E,MAAI,WAAW,SAAS;AACpB,OAAI,KAAK,sBAEL,YAAW,cAAc,KAAK,gBAAgB,SAAY,OAAO,KAAK;AAE1E,QAAK,YAAY,WAAW,SAAS,WAAW;;AAEpD,OAAK;AACL,QAAM,qBAAqB,MAAM,aAAa,KAAK;;CAEvD,YAAY,OAAO,EAAE,kBAAkB,OAAO,EAAE;EAC5C,MAAM,SAAS,KAAK;AACpB,MAAI,KAAK,iBACL,MAAK,eAAe;AAExB,SAAO;;CAEX,WAAW;EACP,MAAM,EAAE,kBAAkB;AAC1B,OAAK,MAAM,UAAU,cACjB,QAAO,QAAQ;AAEnB,gBAAc,SAAS;;CAE3B,WAAW,SAAS,MAAM;AACtB,OAAK,wBAAwB;AAC7B,OAAK,iBAAiB,KAAK,kBAAkB,EAAE;AAC/C,OAAK,MAAM,UAAU,SAAS;AAC1B,QAAK,eAAe,OAAO,MAAM,OAAO,UAAU,KAAK;AACvD,OAAI,OAAO,WACP,MAAK,wBAAwB,OAAO;;AAG5C,MAAI,KAAK,sBACL,MAAK,sBAAsB;;CAGnC,uBAAuB;EACnB,MAAM,EAAE,kBAAkB;EAC1B,MAAM,OAAO,KAAK,OAAO,cAAc,sBAAsB;EAC7D,MAAM,CAAC,OAAO,UAAU;AACxB,MAAI,cAAc,WAAW,EACzB,EAAC,GAAG,EAAE,CAAC,KAAI,MAAK;GACZ,MAAM,UAAU,KAAK,OAAO,cAAc;IACtC,SAAS;KAAE,WAAW;KAAU,WAAW;KAAU;IACrD;IACA;IACH,CAAC;AACF,iBAAc,KAAK,KAAK,OAAO,kBAAkB;IAC7C,IAAI,qBAAqB;IACzB,kBAAkB,CAAC,QAAQ;IAC9B,CAAC,CAAC;IACL;AAEN,OAAK,MAAM,UAAU,cACjB,QAAO,OAAO,KAAK;;CAG3B,YAAY,SAAS,MAAM;EACvB,MAAM,EAAE,kBAAkB;EAC1B,MAAM,SAAS;GACX,GAAG;GACH,aAAa,cAAc;GAC3B,YAAY,cAAc;GAC7B;AACD,OAAK,MAAM,UAAU,QACjB,KAAI,OAAO,YAAY;AAGnB,UAAO,SAAS,OAAO,OAAO,KAAK,wBAAwB,KAAK,SAAS;GACzE,MAAM,SAAS,OAAO,WAAW,OAAO;AAExC,UAAO,cAAc;AACrB,UAAO,aAAa,WAAW,cAAc,KAAK,cAAc,KAAK,cAAc;;;;;;;ACrHnG,IAAM,mBAAmB;CACrB,aAAa;CACb,mBAAmB;CACtB;;;;;AAMD,SAAgB,iBAAiB,EAAE,cAAc,oBAAoB,SAAS,SAAS,cAAc,cAAc;CAG/G,MAAM,EAAE,GAAG,GAAG,OAAO,WAAW;CAChC,IAAI,4BAA4B,eAAe;CAC/C,IAAI,oBAAoB;CACxB,IAAI,IAAI;AACR,MAAK,IAAI,MAAM,GAAG,MAAM,QAAQ,OAAO;EACnC,MAAM,KAAK,MAAM,IAAI;EACrB,MAAM,MAAM,KAAK;AACjB,MAAI,MAAM,0BAEN,MAAK,IAAI;MAGT,MAAK,IAAI,MAAM,GAAG,MAAM,OAAO,OAAO;AAGlC,OADyB,aAAa,IAAI,KAAK,KACvB,GAAG;IACvB,MAAM,KAAK,MAAM,IAAI;IACrB,MAAM,KAAK,KAAK,KAAK;AACrB,QAAI,MAAM,2BAA2B;AACjC,iCAA4B;AAC5B,yBAAoB;;;AAG5B,QAAK;;;AAIjB,KAAI,qBAAqB,GAAG;EAExB,MAAM,cAAc,aAAa,MAAM,mBAAmB,oBAAoB,EAAE;EAChF,MAAM,eAAe,mBAAmB,YAAY;AACpD,MAAI,cAAc;GACd,MAAM,KAAK,KAAK,MAAM,oBAAoB,IAAI,MAAM;GACpD,MAAM,KAAK,oBAAoB,IAAI,KAAK;AACxC,UAAO;IACH,GAAG;IACH;IACA,SAAS,IAAI;IACb,SAAS,IAAI;IAChB;;AAEL,cAAI,MAAM,wDAAwD,EAAE;;AAExE,QAAO;;;;;;AAMX,SAAgB,iBAAiB,EAAE,cAAc,sBAAsB;CACnE,MAAM,+BAAe,IAAI,KAAK;AAE9B,KAAI,cACA;OAAK,IAAI,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK,EAG1C,KADyB,aAAa,IAAI,KAAK,KACvB,GAAG;GACvB,MAAM,cAAc,aAAa,MAAM,GAAG,IAAI,EAAE;GAChD,MAAM,WAAW,YAAY,KAAK,IAAI;AAEtC,OAAI,CAAC,aAAa,IAAI,SAAS,EAAE;IAC7B,MAAM,eAAe,mBAAmB,YAAY;AAEpD,QAAI,aACA,cAAa,IAAI,UAAU;KACvB,GAAG;KACH,OAAO;KACV,CAAC;QAGF,aAAI,MAAM,wDAAwD,EAAE;;;;AAMxF,QAAO,MAAM,KAAK,aAAa,QAAQ,CAAC;;;;;;;;ACtF5C,SAAgB,oBAAoB,EAAE,UAAU,WAAW,YAAY,GAAG,GAAG,KAAK;CAG9E,IAAI,iBAAiB,UAAU;AAC/B,KAAI,UAAU,SAAS,EAEnB,kBAAiB,2BAA2B,UAAU,mBAAmB,WAAW;EAAE;EAAG;EAAG,CAAC;CAEjG,IAAI;AACJ,KAAI,gBAAgB;EAChB,MAAM,QAAQ,CAAC,IAAI,eAAe,GAAG,IAAI,eAAe,EAAE;AAC1D,MAAI,MAAM,OACN,OAAM,KAAK;AAEf,eAAa,eAAe,UAAU,MAAM;;AAEhD,QAAO;EACH,OAAO;EACP,OAAO;EACP,UAAU;EACV,OAAO;EACP,QAAQ;EACR;EACA;EACA,OAAO,CAAC,GAAG,EAAE;EACb;EACA,aAAa,YAAY,aAAa,WAChC,CAAC,SAAS,SAAS,SAAS,QAAQ,GACpC;EACN;EACH;;;AAIL,SAAgB,gBAAgB,MAAM;CAClC,MAAM,EAAE,UAAU,gBAAgB,MAAM,WAAW;CACnD,MAAM,EAAE,aAAa,aAAa,sBAAsB;CACxD,MAAM,iBAAiB,cAAc,CAAC,YAAY,GAAG,EAAE;AACvD,KAAI,SAAS,SAAS;EAElB,MAAM,uBAAuB,eAAe;EAC5C,MAAM,oBAAoB,eAAe;EACzC,MAAM,gBAAgB,cAAc,YAAY,MAAM,KAAK;AAE3D,MAAI,kBAAkB,qBAAqB,sBAAsB,sBAAsB;AACnF,OAAI,kBAAkB,mBAAmB;IAIrC,MAAM,kBAAkB,OAAO,MAAK,UAAS,MAAM,MAAM,OAAO,kBAAkB;AAClF,QAAI,gBAEA,gBAAe,QAAQ,gBAAgB;;AAI/C,kBAAe,UAAU;AACzB,kBAAe,QAAQ;AACvB,kBAAe,OAAO;;;CAG9B,MAAM,WAAW,oBAAoB,KAAK;CAK1C,MAAM,wBAAQ,IAAI,KAAK;AAEvB,OAAM,IAAI,MAAM,SAAS;AACzB,gBAAe,SAAQ,UAAS;EAC5B,IAAI,OAAO,EAAE,GAAG,UAAU;AAC1B,MAAI,UAAU,aAAa;AACvB,QAAK,QAAQ;AACb,QAAK,QAAQ;AACb,QAAK,SAAS;;AAElB,SAAO,oBAAoB;GAAE;GAAO;GAAM;GAAM,CAAC;EACjD,MAAM,YAAY,KAAK;AACvB,MAAI,UAAU,eAAe,SAAS,QAClC,gBAAe,OAAO;AAI1B,QAAM,IAAI,UAAU,IAAI,KAAK;AAC7B,MAAI,SAAS,QACT,WAAU,oBAAoB,KAAK;GAEzC;AACF,QAAO;;;AAGX,SAAgB,oBAAoB,EAAE,OAAO,MAAM,QAAQ;AACvD,QAAO,SAAS,MAAM;EAKlB,MAAM,cAAc,KAAK,SAAS;AAClC,OAAK,cAAc;AACnB,OAAK,QAAQ;AAIb,SAAO,MAAM,eAAe;GAAE;GAAM;GAAM;GAAa,CAAC;AACxD,UAAQ,MAAM;;AAElB,QAAO;;;;;AAKX,SAAS,2BAA2B,WAAW,OAAO;AAElD,MAAK,IAAI,IAAI,UAAU,SAAS,GAAG,KAAK,GAAG,KAAK;EAC5C,MAAM,WAAW,UAAU;AAC3B,MAAI,SAAS,cAAc,MAAM,CAC7B,QAAO;;AAGf,QAAO,UAAU;;;;;;ACtHrB,IAAqB,aAArB,MAAgC;CAC5B,YAAY,QAAQ;AAChB,OAAK,YAAY;AACjB,OAAK,SAAS;AACd,OAAK,iBAAiB,IAAI,eAAe,OAAO;AAChD,OAAK,iBAAiB;GAClB,OAAO;GACP,SAAS;GACT,MAAM;GACT;;CAEL,SAAS,OAAO;AACZ,MAAI,iBAAiB,MACjB,MAAK,cAAc,MAAM;AAE7B,MAAI,eAAe,MACf,MAAK,YAAY,MAAM;;CAG/B,WAAW;AACP,MAAI,KAAK,WACL,MAAK,WAAW,SAAS;AAE7B,MAAI,KAAK,SACL,MAAK,SAAS,SAAS;;;;;;CAO/B,gBAAgB,MAAM;AAClB,SAAO,KAAK,wBAAwB,KAAK;;;;;;CAM7C,iBAAiB,MAAM;AACnB,SAAO,KAAK,yBAAyB,KAAK;;;;;;;CAO9C,WAAW,MAAM;AACb,SAAO,KAAK,mBAAmB,KAAK;;;;;;;CAOxC,YAAY,MAAM;AACd,SAAO,KAAK,oBAAoB,KAAK;;CAGzC,oBAAoB,EAAE,GAAG,GAAG,QAAQ,aAAa,iBAAiB,KAAK,eAAe,MAAM;EACxF,MAAM,oBAAoB,kBAAkB,eAAe,SAAS,eAAe,MAAM;EACzF,MAAM,uBAAuB,kBAAkB,eAAe,YAAY,eAAe,SAAS;EAClG,MAAM,QAAQ,oBAAoB,OAAO,MAAK,MAAK,EAAE,OAAO,kBAAkB,GAAG;EACjF,MAAM,WAAY,wBAAwB,UAAU,MAAK,MAAK,EAAE,OAAO,qBAAqB,IAAK,UAAU;EAE3G,MAAM,OAAO;GACT;GACA;GACA;GACA,YALe,YAAY,SAAS,UAAU,CAAC,IAAI,SAAS,GAAG,IAAI,SAAS,EAAE,CAAC;GAM/E;GACH;AACD,SAAO;GAAE,GAAG;GAAgB,GAAG;GAAM;;;CAIzC,gBAAgB;AAEZ,MAAI,CAAC,KAAK,YAAY;AAClB,QAAK,aAAa,KAAK,OAAO,kBAAkB;IAC5C,kBAAkB,CAAC,aAAa;IAChC,wBAAwB;IAC3B,CAAC;AACF,OAAI,KAAK,OAAO,0BAA0B,cAAc,CAKpD,MAAK,WAJY,KAAK,OAAO,kBAAkB;IAC3C,kBAAkB,CAAC,cAAc;IACjC,wBAAwB;IAC3B,CAAC;;EAKV,MAAM,EAAE,WAAW,KAAK,OAAO,yBAAyB;AACxD,OAAK,YAAY,OAAO;GAAE,OAAO,OAAO;GAAO,QAAQ,OAAO;GAAQ,CAAC;AACvE,OAAK,UAAU,OAAO;GAAE,OAAO,OAAO;GAAO,QAAQ,OAAO;GAAQ,CAAC;;;CAGzE,aAAa,QAAQ;AACjB,MAAI,KAAK,cAAc,MACnB,QAAO;EAEX,MAAM,iBAAiB,OAAO,QAAO,UAAS,KAAK,eAAe,gBAAgB,MAAM,IAAI,CAAC,MAAM,YAAY;AAC/G,SAAO,eAAe,SAAS,iBAAiB;;;;;CAMpD,MAAM,wBAAwB,EAAE,QAAQ,OAAO,WAAW,GAAG,GAAG,SAAS,GAAG,QAAQ,GAAG,OAAO,SAAS,aAAa,kBAAkB,WAAW;EAE7I,MAAM,aAAa,KAAK,OAAO,cAAc,kBAAkB;EAC/D,MAAM,iBAAiB,KAAK,aAAa,OAAO;AAChD,MAAI,CAAC,kBAAkB,UAAU,WAAW,EACxC,QAAO;GACH,QAAQ,EAAE;GACV,WAAW,oBAAoB;IAAE;IAAW;IAAG;IAAG;IAAY,CAAC;GAClE;AAEL,OAAK,eAAe;EAKpB,MAAM,mBAAmB,KAAK,OAAO,cAAc,kBAAkB,CAAC,GAAG,EAAE,EAAE,KAAK;EAClF,MAAM,cAAc,CAChB,iBAAiB,IAAI,KAAK,MAAM,iBAAiB,QAAQ,EAAE,EAC3D,iBAAiB,IAAI,KAAK,MAAM,iBAAiB,SAAS,EAAE,CAC/D;EACD,MAAM,eAAe,KAAK,MAAM,SAAS,WAAW;EACpD,MAAM,EAAE,OAAO,WAAW,KAAK;EAC/B,MAAM,aAAa,KAAK,gBAAgB;GACpC,SAAS,YAAY;GACrB,SAAS,YAAY;GACrB;GACA,aAAa;GACb,cAAc;GACjB,CAAC;EACF,MAAM,WAAW;GACb,GAAG,IAAI;GACP,GAAG,IAAI;GACP,OAAO,SAAS,IAAI;GACpB,QAAQ,SAAS,IAAI;GACxB;EACD,IAAI;EACJ,MAAM,SAAS,EAAE;EACjB,MAAM,iCAAiB,IAAI,KAAK;AAChC,OAAK,IAAI,IAAI,GAAG,IAAI,OAAO,KAAK;GAC5B,IAAI;AACJ,OAAI,WAWA,YAAW,iBAAiB;IACxB,GAXiB,KAAK,eAAe;KACrC,QAAQ;KACR;KACA;KACA;KACA;KACA;KACA;KACA,MAAM,WAAW;KACpB,CAAC;IAGE,SAAS,YAAY;IACrB,SAAS,YAAY;IACrB;IACA;IACH,CAAC;OAGF,YAAW;IACP,aAAa;IACb,mBAAmB;IACtB;GAEL,IAAI;AACJ,OAAI,SAAS,eAAe,eAAe,KAAK,UAAU;IACtD,MAAM,EAAE,cAAc,kBAAkB,KAAK,eAAe;KACxD,QAAQ,CAAC,SAAS,YAAY;KAC9B;KACA;KACA;KACA,YAAY;MACR,GAAG,SAAS;MACZ,GAAG,SAAS;MACZ,OAAO;MACP,QAAQ;MACX;KACD;KACA;KACA,MAAM,WAAW,KAAK;KACzB,EAAE,KAAK;AAGR,QAAI,cAAc,GACd,KAAI,cAAc;;AAM1B,OAAI,SAAS,eAAe,IAAI,IAAI,OAAO;AACvC,mBAAe,IAAI,SAAS,YAAY;AACxC,aAAS,YAAY,oBAAoB,SAAS,kBAAkB;;AAGxE,WAAQ,gBAAgB;IACpB;IACA,gBAAgB,KAAK;IACrB;IACA,QAAQ;IACR;IACA;IACA;IACA;IACA;IACH,CAAC;AACF,QAAK,MAAM,QAAQ,MAAM,QAAQ,CAC7B,KAAI,KAAK,MACL,QAAO,KAAK,KAAK;AAIzB,OAAI,CAAC,SAAS,YACV;;AAIR,OAAK,MAAM,SAAS,eAChB,OAAM,sBAAsB;AAEhC,SAAO;GAAE;GAAQ,WAAW,MAAM,IAAI,KAAK;GAAE;;;;;;CAOjD,mBAAmB,EAAE,QAAQ,OAAO,WAAW,GAAG,GAAG,SAAS,GAAG,QAAQ,GAAG,OAAO,SAAS,aAAa,kBAAkB,WAAW;EAElI,MAAM,aAAa,KAAK,OAAO,cAAc,kBAAkB;EAC/D,MAAM,iBAAiB,KAAK,aAAa,OAAO;AAChD,MAAI,CAAC,kBAAkB,UAAU,WAAW,EACxC,QAAO;GACH,QAAQ,EAAE;GACV,WAAW,oBAAoB;IAAE;IAAW;IAAG;IAAG;IAAY,CAAC;GAClE;AAEL,OAAK,eAAe;EAKpB,MAAM,mBAAmB,KAAK,OAAO,cAAc,kBAAkB,CAAC,GAAG,EAAE,EAAE,KAAK;EAClF,MAAM,cAAc,CAChB,iBAAiB,IAAI,KAAK,MAAM,iBAAiB,QAAQ,EAAE,EAC3D,iBAAiB,IAAI,KAAK,MAAM,iBAAiB,SAAS,EAAE,CAC/D;EACD,MAAM,eAAe,KAAK,MAAM,SAAS,WAAW;EACpD,MAAM,EAAE,OAAO,WAAW,KAAK;EAC/B,MAAM,aAAa,KAAK,gBAAgB;GACpC,SAAS,YAAY;GACrB,SAAS,YAAY;GACrB;GACA,aAAa;GACb,cAAc;GACjB,CAAC;EACF,MAAM,WAAW;GACb,GAAG,IAAI;GACP,GAAG,IAAI;GACP,OAAO,SAAS,IAAI;GACpB,QAAQ,SAAS,IAAI;GACxB;EACD,IAAI;EACJ,MAAM,SAAS,EAAE;EACjB,MAAM,iCAAiB,IAAI,KAAK;AAChC,OAAK,IAAI,IAAI,GAAG,IAAI,OAAO,KAAK;GAC5B,IAAI;AACJ,OAAI,WAWA,YAAW,iBAAiB;IACxB,GAXiB,KAAK,eAAe;KACrC,QAAQ;KACR;KACA;KACA;KACA;KACA;KACA;KACA,MAAM,WAAW;KACpB,CAAC;IAGE,SAAS,YAAY;IACrB,SAAS,YAAY;IACrB;IACA;IACH,CAAC;OAGF,YAAW;IACP,aAAa;IACb,mBAAmB;IACtB;GAEL,IAAI;AACJ,OAAI,SAAS,eAAe,eAAe,KAAK,UAAU;IACtD,MAAM,EAAE,cAAc,kBAAkB,KAAK,eAAe;KACxD,QAAQ,CAAC,SAAS,YAAY;KAC9B;KACA;KACA;KACA,YAAY;MACR,GAAG,SAAS;MACZ,GAAG,SAAS;MACZ,OAAO;MACP,QAAQ;MACX;KACD;KACA;KACA,MAAM,WAAW,KAAK;KACzB,EAAE,KAAK;AAGR,QAAI,cAAc,GACd,KAAI,cAAc;;AAM1B,OAAI,SAAS,eAAe,IAAI,IAAI,OAAO;AACvC,mBAAe,IAAI,SAAS,YAAY;AACxC,aAAS,YAAY,oBAAoB,SAAS,kBAAkB;;AAGxE,WAAQ,gBAAgB;IACpB;IACA,gBAAgB,KAAK;IACrB;IACA,QAAQ;IACR;IACA;IACA;IACA;IACA;IACH,CAAC;AACF,QAAK,MAAM,QAAQ,MAAM,QAAQ,CAC7B,KAAI,KAAK,MACL,QAAO,KAAK,KAAK;AAIzB,OAAI,CAAC,SAAS,YACV;;AAIR,OAAK,MAAM,SAAS,eAChB,OAAM,sBAAsB;AAEhC,SAAO;GAAE;GAAQ,WAAW,MAAM,IAAI,KAAK;GAAE;;;;;CAMjD,MAAM,yBAAyB,EAAE,QAAQ,OAAO,WAAW,GAAG,GAAG,QAAQ,GAAG,SAAS,GAAG,OAAO,SAAS,aAAa,MAAM,kBAAkB,WAAW;EACpJ,MAAM,iBAAiB,KAAK,aAAa,OAAO;AAChD,MAAI,CAAC,kBAAkB,UAAU,WAAW,EACxC,QAAO,EAAE;AAEb,OAAK,eAAe;EAIpB,MAAM,aAAa,KAAK,OAAO,cAAc,kBAAkB;EAE/D,MAAM,UAAU,KAAK,OAAO,cAAc,kBAAkB,CAAC,GAAG,EAAE,EAAE,KAAK;EAEzE,MAAM,aAAa,QAAQ;EAC3B,MAAM,YAAY,QAAQ,IAAI,QAAQ;EAGtC,MAAM,cAAc,KAAK,OAAO,cAAc,kBAAkB,CAAC,IAAI,OAAO,IAAI,OAAO,EAAE,KAAK;EAC9F,MAAM,cAAc,YAAY,IAAI,YAAY;EAChD,MAAM,eAAe,YAAY;EACjC,MAAM,aAAa;GACf,GAAG;GACH,GAAG;GAEH,OAAO,cAAc;GACrB,QAAQ,YAAY;GACvB;EAWD,MAAM,YAAY,iBAVG,KAAK,eAAe;GACrC,QAAQ;GACR;GACA;GACA;GACA;GACA,UAAU;IAAE;IAAG;IAAG;IAAO;IAAQ;GACjC;GACA,MAAM,WAAW;GACpB,CAAC,CAC8C;EAKhD,MAAM,sCAAsB,IAAI,KAAK;EACrC,MAAM,cAAc,EAAE;EACtB,MAAM,kBAAkB,OAAO,SAAS,WAAW;AACnD,OAAK,IAAI,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACvC,OAAI,mBAAmB,YAAY,UAAU,WACzC;GAEJ,MAAM,WAAW,UAAU;GAC3B,IAAI,OAAO;IACP,OAAO,SAAS;IAChB,OAAO;IACP,OAAO,SAAS;IAChB,QAAQ;IACR;IACA;IACA;IACH;AACD,UAAO,oBAAoB;IAAE,OAAO,SAAS;IAAa;IAAM;IAAM,CAAC;GAEvE,MAAM,gBAAgB,KAAK,MAAM;AACjC,OAAI,CAAC,oBAAoB,IAAI,cAAc,CACvC,qBAAoB,IAAI,+BAAe,IAAI,KAAK,CAAC;GAErD,MAAM,uBAAuB,oBAAoB,IAAI,cAAc;GAGnE,MAAM,kBAAkB,KAAK,UAAU,KAAK;AAC5C,OAAI,CAAC,qBAAqB,IAAI,gBAAgB,EAAE;AAC5C,yBAAqB,IAAI,gBAAgB;AACzC,gBAAY,KAAK,KAAK;;;AAG9B,SAAO;;;;;;CAOX,oBAAoB,EAAE,QAAQ,OAAO,WAAW,GAAG,GAAG,QAAQ,GAAG,SAAS,GAAG,OAAO,SAAS,aAAa,MAAM,kBAAkB,WAAW;EACzI,MAAM,iBAAiB,KAAK,aAAa,OAAO;AAChD,MAAI,CAAC,kBAAkB,UAAU,WAAW,EACxC,QAAO,EAAE;AAEb,OAAK,eAAe;EAIpB,MAAM,aAAa,KAAK,OAAO,cAAc,kBAAkB;EAE/D,MAAM,UAAU,KAAK,OAAO,cAAc,kBAAkB,CAAC,GAAG,EAAE,EAAE,KAAK;EAEzE,MAAM,aAAa,QAAQ;EAC3B,MAAM,YAAY,QAAQ,IAAI,QAAQ;EAGtC,MAAM,cAAc,KAAK,OAAO,cAAc,kBAAkB,CAAC,IAAI,OAAO,IAAI,OAAO,EAAE,KAAK;EAC9F,MAAM,cAAc,YAAY,IAAI,YAAY;EAChD,MAAM,eAAe,YAAY;EACjC,MAAM,aAAa;GACf,GAAG;GACH,GAAG;GAEH,OAAO,cAAc;GACrB,QAAQ,YAAY;GACvB;EAWD,MAAM,YAAY,iBAVG,KAAK,eAAe;GACrC,QAAQ;GACR;GACA;GACA;GACA;GACA,UAAU;IAAE;IAAG;IAAG;IAAO;IAAQ;GACjC;GACA,MAAM,WAAW;GACpB,CAAC,CAC8C;EAKhD,MAAM,sCAAsB,IAAI,KAAK;EACrC,MAAM,cAAc,EAAE;EACtB,MAAM,kBAAkB,OAAO,SAAS,WAAW;AACnD,OAAK,IAAI,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACvC,OAAI,mBAAmB,YAAY,UAAU,WACzC;GAEJ,MAAM,WAAW,UAAU;GAC3B,IAAI,OAAO;IACP,OAAO,SAAS;IAChB,OAAO;IACP,OAAO,SAAS;IAChB,QAAQ;IACR;IACA;IACA;IACH;AACD,UAAO,oBAAoB;IAAE,OAAO,SAAS;IAAa;IAAM;IAAM,CAAC;GAEvE,MAAM,gBAAgB,KAAK,MAAM;AACjC,OAAI,CAAC,oBAAoB,IAAI,cAAc,CACvC,qBAAoB,IAAI,+BAAe,IAAI,KAAK,CAAC;GAErD,MAAM,uBAAuB,oBAAoB,IAAI,cAAc;GAGnE,MAAM,kBAAkB,KAAK,UAAU,KAAK;AAC5C,OAAI,CAAC,qBAAqB,IAAI,gBAAgB,EAAE;AAC5C,yBAAqB,IAAI,gBAAgB;AACzC,gBAAY,KAAK,KAAK;;;AAG9B,SAAO;;CAGX,MAAM,oBAAoB,EAAE,QAAQ,OAAO,WAAW,kBAAkB,YAAY,UAAU,SAAS,QAAQ,QAAQ,OAAO;EAC1H,MAAM,aAAa,QAAQ,KAAK,WAAW,KAAK;EAChD,MAAM,OAAO;GACT;GACA,aAAa,KAAK;GAClB;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA,gBAAgB,EAAE;GAClB,WAAW;GACd;AACD,OAAK,MAAM,UAAU,QACjB,KAAI,OAAO,aACP,MAAK,eAAe,OAAO,MAAM,OAAO,UAAU,KAAK;EAG/D,MAAM,EAAE,uBAAuB,KAAK,eAAe,OAAO,KAAK;EAG/D,MAAM,EAAE,GAAG,GAAG,OAAO,WAAW;EAChC,MAAM,eAAe,KAAK,QAAQ,eAAe,YAAY,QAAQ,SAAS,EAAE;AAChF,OAAK,OAAO,uBAAuB,YAAY;GAC3C,SAAS;GACT,SAAS;GACT,aAAa;GACb,cAAc;GACd,QAAQ;GACX,CAAC;AACF,SAAO;GAAE;GAAc;GAAoB;;CAG/C,eAAe,EAAE,QAAQ,OAAO,WAAW,kBAAkB,YAAY,UAAU,SAAS,QAAQ,QAAQ,OAAO;EAC/G,MAAM,aAAa,QAAQ,KAAK,WAAW,KAAK;EAChD,MAAM,OAAO;GACT;GACA,aAAa,KAAK;GAClB;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA,gBAAgB,EAAE;GAClB,WAAW;GACd;AACD,OAAK,MAAM,UAAU,QACjB,KAAI,OAAO,aACP,MAAK,eAAe,OAAO,MAAM,OAAO,UAAU,KAAK;EAG/D,MAAM,EAAE,uBAAuB,KAAK,eAAe,OAAO,KAAK;EAG/D,MAAM,EAAE,GAAG,GAAG,OAAO,WAAW;EAChC,MAAM,eAAe,KAAK,QAAQ,eAAe,YAAY,QAAQ,SAAS,EAAE;AAChF,OAAK,OAAO,uBAAuB,YAAY;GAC3C,SAAS;GACT,SAAS;GACT,aAAa;GACb,cAAc;GACd,QAAQ;GACX,CAAC;AACF,SAAO;GAAE;GAAc;GAAoB;;;;;;CAM/C,gBAAgB,EAAE,SAAS,SAAS,cAAc,aAAa,gBAAgB;EAE3E,MAAM,IAAI,KAAK,IAAI,GAAG,UAAU,aAAa;EAC7C,MAAM,IAAI,KAAK,IAAI,GAAG,UAAU,aAAa;EAC7C,MAAM,QAAQ,KAAK,IAAI,aAAa,UAAU,eAAe,EAAE,GAAG;EAClE,MAAM,SAAS,KAAK,IAAI,cAAc,UAAU,eAAe,EAAE,GAAG;AAEpE,MAAI,SAAS,KAAK,UAAU,EACxB,QAAO;AAEX,SAAO;GAAE;GAAG;GAAG;GAAO;GAAQ;;;;;;ACjmBtC,IAAM,aAAa;CACf,YAAY;EAAE,KAAK;EAAG,MAAM;EAAG;CAC/B,aAAa;EAAE,KAAK;EAAG,OAAO;EAAG;CACjC,eAAe;EAAE,QAAQ;EAAG,MAAM;EAAG;CACrC,gBAAgB;EAAE,QAAQ;EAAG,OAAO;EAAG;CACvC,MAAM;EAAE,KAAK;EAAG,MAAM;EAAG,QAAQ;EAAG,OAAO;EAAG;CACjD;AACD,IAAM,oBAAoB;AAC1B,IAAM,oBAAoB;AAC1B,IAAa,gBAAb,MAA2B;CACvB,YAAY,EAAE,MAAM,iBAAiB;;AAEjC,OAAK,iBAAiB,EAAE;;AAExB,OAAK,UAAU,EAAE;;AAEjB,OAAK,kBAAkB,EAAE;;AAEzB,OAAK,aAAa,EAAE;;AAEpB,OAAK,gBAAgB,EAAE;AACvB,OAAK,OAAO;AACZ,iBAAe,UAAU,IAAI,wBAAwB;AACrD,OAAK,gBAAgB;;CAEzB,aAAa;AACT,SAAO,KAAK;;;CAGhB,SAAS,OAAO;AACZ,MAAI,MAAM,WAAW,CAAC,UAAU,MAAM,SAAS,KAAK,SAAS,EAAE,EAAE;GAE7D,MAAM,cAAc,MAAM,QAAQ,OAAO,QAAQ;AACjD,QAAK,YAAY,YAAY;;;CAGrC,WAAW;AACP,OAAK,MAAM,UAAU,KAAK,YAAY,CAClC,MAAK,cAAc,OAAO;AAE9B,OAAK,eAAe,SAAS;AAC7B,OAAK,gBAAgB,SAAS;AAC9B,OAAK,MAAM,MAAM,KAAK,WAClB,MAAK,WAAW,IAAI,QAAQ;;;CAIpC,WAAW,QAAQ;AACf,MAAI,CAAC,KAAK,eAAe,MAAK,MAAK,EAAE,OAAO,OAAO,GAAG,EAAE;AACpD,QAAK,WAAW,OAAO;AACvB,QAAK,eAAe,KAAK,OAAO;AAEhC,QAAK,YAAY,KAAK,QAAQ;;;CAGtC,SAAS,EAAE,WAAW,UAAU;EAC5B,MAAM,gBAAgB,UAAU,QAAQ,KAAK,MAAM;AAC/C,OAAI,EAAE,MAAM;AACZ,UAAO;KACR,EAAE,CAAC;AACN,OAAK,MAAM,UAAU,KAAK,YAAY,EAAE;GACpC,MAAM,EAAE,WAAW;AACnB,OAAI,QAAQ;IAER,MAAM,WAAW,cAAc;AAC/B,QAAI,UAAU;AACV,SAAI,OAAO,iBACP,QAAO,iBAAiB,SAAS;AAErC,YAAO,WAAW;MAAE,WAAW,CAAC,SAAS;MAAE;MAAQ,CAAC;;UAGvD;AAED,QAAI,OAAO,iBACP,MAAK,MAAM,YAAY,UACnB,QAAO,iBAAiB,SAAS;AAGzC,WAAO,WAAW;KAAE;KAAW;KAAQ,CAAC;;;AAGhD,OAAK,gBAAgB;AACrB,OAAK,mBAAmB;;CAE5B,QAAQ,MAAM,OAAO;AACjB,OAAK,MAAM,UAAU,KAAK,YAAY,EAAE;GACpC,MAAM,EAAE,WAAW;AACnB,OAAI,CAAC,UAAU,WAAW,KAAK,UAAU,GACrC,QAAO,UAAU,MAAM,MAAM;;;CAIzC,QAAQ,MAAM,OAAO;EACjB,MAAM,mBAAmB,eAAe,MAAM;AAC9C,MAAI,CAAC,iBACD;AAEJ,OAAK,MAAM,UAAU,KAAK,YAAY,EAAE;GACpC,MAAM,EAAE,WAAW;AACnB,OAAI,CAAC,UAAU,WAAW,KAAK,UAAU,GACrC,QAAO,oBAAoB,MAAM,MAAM;;;;;;;;CAUnD,YAAY,aAAa;EACrB,MAAM,eAAe,EAAE;AACvB,OAAK,MAAM,UAAU,KAAK,gBACtB,cAAa,OAAO,MAAM;AAG9B,OAAK,gBAAgB,SAAS;AAE9B,OAAK,MAAM,UAAU,KAAK,gBAAgB;AACtC,gBAAa,OAAO,MAAM;AAC1B,QAAK,gBAAgB,KAAK,OAAO;;AAErC,OAAK,IAAI,UAAU,aAAa;GAC5B,MAAM,YAAY,aAAa,OAAO;AACtC,OAAI,CAAC,UAED,MAAK,WAAW,OAAO;YAI3B,UAAU,WAAW,OAAO,UACxB,UAAU,cAAc,OAAO,WAAW;AAC1C,SAAK,cAAc,UAAU;AAC7B,SAAK,WAAW,OAAO;cAElB,WAAW,WAAW;AAE3B,cAAU,SAAS,OAAO,MAAM;AAChC,aAAS;;AAGb,gBAAa,OAAO,MAAM;AAC1B,QAAK,gBAAgB,KAAK,OAAO;;AAErC,OAAK,MAAM,MAAM,cAAc;GAC3B,MAAM,YAAY,aAAa;AAC/B,OAAI,UAEA,MAAK,cAAc,UAAU;;AAGrC,OAAK,UAAU;;;CAGnB,WAAW,QAAQ;EACf,MAAM,EAAE,SAAS,MAAM,YAAY,sBAAsB;EACzD,MAAM,YAAY,OAAO,MAAM,cAAc;AAC7C,SAAO,gBAAgB;AACvB,SAAO,OAAO,KAAK;AAEnB,SAAO,cAAc,OAAO,OAAO;GAAE,MAAM,KAAK;GAAM;GAAQ,CAAC;AAC/D,MAAI,OAAO,YACP,MAAK,cAAc,WAAW,UAAU,CAAC,OAAO,OAAO,YAAY;AAEvE,SAAO,YAAY;;;CAGvB,cAAc,QAAQ;AAClB,SAAO,YAAY;AACnB,MAAI,OAAO,YACP,QAAO,YAAY,QAAQ;AAE/B,SAAO,cAAc;AACrB,SAAO,OAAO;AACd,SAAO,gBAAgB;;;CAG3B,cAAc,mBAAmB,WAAW;AACxC,MAAI,qBAAqB,OAAO,sBAAsB,SAClD,QAAO;EAEX,MAAM,cAAc,qBAAqB;EACzC,IAAI,gBAAgB,KAAK,WAAW;AACpC,MAAI,CAAC,eAAe;AAChB,mBAAgB,SAAS,cAAc,MAAM;AAC7C,iBAAc,MAAM,gBAAgB;AACpC,iBAAc,MAAM,WAAW;AAC/B,iBAAc,MAAM,WAAW;AAC/B,QAAK,eAAe,OAAO,cAAc;AACzC,QAAK,WAAW,eAAe;;EAEnC,IAAI,YAAY,cAAc,cAAc,IAAI,YAAY;AAC5D,MAAI,CAAC,WAAW;AACZ,eAAY,WAAW,SAAS,cAAc,MAAM;AACpD,aAAU,YAAY;AACtB,aAAU,MAAM,WAAW;AAC3B,aAAU,MAAM,SAAS;AACzB,UAAO,OAAO,UAAU,OAAO,WAAW,WAAW;AACrD,iBAAc,OAAO,UAAU;;AAEnC,SAAO;;CAEX,oBAAoB;EAChB,MAAM,cAAc,KAAK,KAAK;EAC9B,MAAM,eAAe,KAAK,KAAK;AAC/B,OAAK,MAAM,MAAM,KAAK,YAAY;GAC9B,MAAM,WAAW,KAAK,cAAc,OAAO;GAC3C,MAAM,UAAU,OAAO,qBAAqB;GAC5C,MAAM,YAAY,KAAK,WAAW;AAClC,OAAI,SAAS;AACT,cAAU,MAAM,UAAU;AAE1B,cAAU,MAAM,OAAO,GAAG,WAAW,SAAS,IAAI,EAAE;AACpD,cAAU,MAAM,MAAM,GAAG,WAAW,SAAS,IAAI,EAAE;AACnD,cAAU,MAAM,QAAQ,GAAG,WAAW,SAAS,QAAQ,YAAY;AACnE,cAAU,MAAM,SAAS,GAAG,WAAW,SAAS,SAAS,aAAa;SAGtE,WAAU,MAAM,UAAU;;;;;;;AChO1C,SAAgB,YAAY,SAAS,OAAO;AACxC,KAAI,MACA,QAAO,QAAQ,MAAM,CAAC,KAAK,CAAC,KAAK,WAAW;AACxC,MAAI,IAAI,WAAW,KAAK,CAEpB,SAAQ,MAAM,YAAY,KAAK,MAAM;MAIrC,SAAQ,MAAM,OAAO;GAE3B;;AAGV,SAAgB,aAAa,SAAS,OAAO;AACzC,KAAI,MACA,QAAO,KAAK,MAAM,CAAC,KAAI,QAAO;AAC1B,MAAI,IAAI,WAAW,KAAK,CAEpB,SAAQ,MAAM,eAAe,IAAI;MAIjC,SAAQ,MAAM,OAAO;GAE3B;;;;;ACpBV,IAAa,SAAb,MAAoB;CAChB,YAAY,OAAO;;;;;AAKf,OAAK,SAAS;AACd,OAAK,QAAQ;GAET,GAAG,KAAK,YAAY;GACpB,GAAG;GACN;AAED,OAAK,KAAK,KAAK,MAAM;;;CAGzB,SAAS,OAAO;EACZ,MAAM,WAAW,KAAK;EACtB,MAAM,KAAK,KAAK;AAEhB,MAAI,MAAM,SAAS,cAAc,MAAM,WAAW;AAC9C,OAAI,SAAS,UACT,IAAG,UAAU,OAAO,SAAS,UAAU;AAC3C,OAAI,MAAM,UACN,IAAG,UAAU,IAAI,MAAM,UAAU;;AAGzC,MAAI,MAAM,CAAC,UAAU,SAAS,OAAO,MAAM,OAAO,EAAE,EAAE;AAClD,gBAAa,IAAI,SAAS,MAAM;AAChC,eAAY,IAAI,MAAM,MAAM;;AAEhC,SAAO,OAAO,KAAK,OAAO,MAAM;AAEhC,OAAK,YAAY;;;CAGrB,aAAa;AACT,MAAI,KAAK,YACL,MAAK,aAAa,KAAK,YAAY;;;;;;;CAS3C,sBAAsB;EAClB,MAAM,cAAc;GAEhB;GACA,KAAK;GAEL,KAAK,MAAM;GACd;EACD,MAAM,UAAU,SAAS,cAAc,MAAM;AAC7C,cAAY,QAAQ,QAAQ,OAAO,QAAQ,YAAY,IAAI,SAAS,EAAE,CAAC,SAAQ,cAAa,QAAQ,UAAU,IAAI,UAAU,CAAC;AAC7H,cAAY,SAAS,KAAK,MAAM,MAAM;AACtC,SAAO;;;CAGX,OAAO,QAAQ;AACX,SAAO,KAAK,MAAM,OAAO,IAAI,KAAK,qBAAqB;;;;;CAK3D,MAAM,QAAQ;;CAEd,WAAW;;CAGX,iBAAiB,UAAU;;CAE3B,SAAS,QAAQ;;CAEjB,QAAQ,MAAM,OAAO;;CAErB,QAAQ,MAAM,OAAO;;CAErB,OAAO,MAAM,OAAO;;CAEpB,YAAY,MAAM,OAAO;;CAEzB,UAAU,MAAM,OAAO;;AAE3B,OAAO,eAAe;CAClB,IAAI;CACJ,OAAO,EAAE;CACT,YAAY;CACZ,WAAW;CACd;;;;AC3FD,IAAM,eAAe;CACjB,QAAQ;CACR,UAAU;CACV,eAAe;CACf,OAAO;CACP,iBAAiB;CACjB,SAAS;CACT,KAAK;CACL,MAAM;CACN,SAAS;CACZ;AACD,IAAa,gBAAb,cAAmC,OAAO;CACtC,YAAY,QAAQ,EAAE,EAAE;AACpB,QAAM,MAAM;AACZ,OAAK,KAAK;AACV,OAAK,YAAY;AACjB,OAAK,YAAY;AACjB,OAAK,YAAY;AACjB,OAAK,SAAS,MAAM;;CAGxB,sBAAsB;EAClB,MAAM,KAAK,SAAS,cAAc,MAAM;AACxC,KAAG,YAAY,KAAK;AACpB,SAAO,OAAO,GAAG,OAAO,aAAa;AACrC,SAAO;;CAEX,aAAa,aAAa;CAC1B,iBAAiB,UAAU;AACvB,MAAI,KAAK,aACL,SAAS,OAAO,KAAK,cAAc,MACnC,CAAC,SAAS,OAAO,KAAK,aAAa,CAEnC,MAAK,WAAW,KAAK;AAIzB,OAAK,eAAe;;CAExB,QAAQ,MAAM;EACV,MAAM,EAAE,SAAS;EACjB,MAAM,aAAa,QAAQ,KAAK,MAAM;AACtC,MAAI,CAAC,WACD;EAEJ,MAAM,cAAc,WAAW,KAAK;AACpC,OAAK,WAAW,aAAa,KAAK,GAAG,KAAK,EAAE;;CAEhD,WAAW,aAAa,GAAG,GAAG;EAC1B,MAAM,KAAK,KAAK;AAChB,MAAI,CAAC,GACD;AAEJ,MAAI,OAAO,gBAAgB,SACvB,IAAG,YAAY;WAEV,CAAC,aAAa;AACnB,QAAK,YAAY;AACjB,MAAG,MAAM,UAAU;AACnB;SAEC;AACD,OAAI,YAAY,KACZ,IAAG,YAAY,YAAY;AAE/B,OAAI,YAAY,KACZ,IAAG,YAAY,YAAY;AAE/B,OAAI,YAAY,UACZ,IAAG,YAAY,YAAY;;AAGnC,OAAK,YAAY;AACjB,KAAG,MAAM,UAAU;AACnB,KAAG,MAAM,YAAY,aAAa,EAAE,MAAM,EAAE;AAC5C,MAAI,eAAe,OAAO,gBAAgB,YAAY,WAAW,YAC7D,QAAO,OAAO,GAAG,OAAO,YAAY,MAAM;;;AAItD,cAAc,eAAe,EACzB,GAAG,OAAO,cACb;;;;AC/ED,IAAM,2BAA2B;CAC7B,qBAAqB,EACjB,yBAAyB,OAC5B;CACD,wBAAwB,EAAE;CAC1B,mBAAmB,EAAE;CACrB,wBAAwB,EAEpB,gBAAgB,MACnB;CACD,wBAAwB,EAAE;CAC1B,0BAA0B,EACtB,qCAAqC,OACxC;CACD,gBAAgB,EAAE;CAClB,kBAAkB;EACd,SAAS;EACT,SAAS;EACZ;CACD,wBAAwB,EAAE;CAC7B;AACD,IAAM,yBAAyB,QAAQ;CACnC,iBAAiB,SAAS;AACtB,SAAO,GAAG,YAAY,QAAQ;;CAElC,yBAAyB;CACzB,yBAAyB;CACzB,yBAAyB;CACzB,yBAAyB;CAC5B;AACD,IAAM,8BAA8B,QAAQ;CACxC,0BAA0B;CAC1B,uBAAuB;AACnB,SAAO,GAAG,mBAAmB;;CAEjC,qBAAqB,aAAa;AAC9B,SAAO,GAAG,kBAAkB,YAAY;;CAE5C,iBAAiB,aAAa;AAC1B,SAAO,GAAG,cAAc,YAAY;;CAExC,mBAAmB,aAAa;AAC5B,SAAO,GAAG,gBAAgB,YAAY;;CAE7C;AACD,IAAM,6BAA6B,QAAQ;CACvC,mCAAmC;CACnC,yBAAyB,GAAG,MAAM;AAC9B,SAAO,GAAG,oBAAoB,GAAG,KAAK;;CAE1C,2BAA2B,GAAG,MAAM;AAChC,SAAO,GAAG,sBAAsB,GAAG,KAAK;;CAE5C,yBAAyB,GAAG,MAAM;AAC9B,SAAO,GAAG,oBAAoB,GAAG,KAAK;;CAE7C;;;;;;AAMD,SAAgB,cAAc,UAAU,MAAM;CAC1C,MAAM,YAAY,kBAAkB;AACpC,KAAI,CAAC,WAAW,UAAU,oBAAoB;AAE1C,YAAU,aAAa,UAAU;AACjC,YAAU,qBAAqB;AAC/B;;AAGJ,WAAU,qBAAqB,UAAU;AAEzC,WAAU,aAAa,SAAU,WAAW,SAAS;AAEjD,MAAI,cAAc,WAAW,cAAc,sBAAsB;GAC7D,MAAM,UAAU,KAAK,mBAAmB,UAAU,QAAQ;AAE1D,OAAI,mBAAmB,YACnB,0BAAyB,QAAQ;AAErC,UAAO;;AAGX,SAAO,KAAK,mBAAmB,WAAW,QAAQ;;;;AAI1D,SAAgB,yBAAyB,IAAI;AAEzC,IAAG,aAAa,yBAAyB;CAEzC,MAAM,kBAAkB;EACpB,GAAG;EACH,4BAA4B,GAAG,aAAa,kCAAkC;EAC9E,oBAAoB,sBAAsB,GAAG;EAC7C,yBAAyB,2BAA2B,GAAG;EACvD,wBAAwB,0BAA0B,GAAG;EACxD;CAGD,MAAM,uBAAuB,GAAG;AAChC,IAAG,eAAe,SAAU,eAAe;EACvC,MAAM,MAAM,qBAAqB,KAAK,IAAI,cAAc;AACxD,MAAI,IACA,QAAO;AAGX,MAAI,iBAAiB,gBAEjB,QAAO,gBAAgB;AAE3B,SAAO;;CAIX,MAAM,iCAAiC,GAAG;AAC1C,IAAG,yBAAyB,WAAY;AAEpC,UADmB,+BAA+B,MAAM,GAAG,IAAI,EAAE,GAC9C,OAAO,OAAO,KAAK,gBAAgB,CAAC;;;;;;ACxH/D,IAAM,YAAY;AAClB,IAAa,eAAb,cAAkC,QAAQ;;CAEtC,OAAO;CACP,cAAc;AACV,SAAO;AAEP,SAAO,eAAe;GAAE,GAAG,OAAO;GAAc,GAAG;GAAuB;;;CAG9E,cAAc,QAAQ;AAClB,gBAAc,OAAO;;;CAGzB,cAAc;AACV,SAAO,OAAO,2BAA2B;;CAE7C,eAAe,QAAQ;AAEnB,MAAI,OAAO,2BAA2B,eAAe,kBAAkB,uBACnE,QAAO;AAEX,MAAI,OAAO,0BAA0B,eAAe,kBAAkB,sBAClE,KAAI,KAAK,2BAA2B,OAAO,EAAE;AAEjD,SAAO;;;;;;;;;CASX,MAAM,OAAO,IAAI,QAAQ,EAAE,EAAE;EACzB,MAAM,EAAE,gBAAgB,MAAM,OAAO;AACrC,MAAI,cAAc,YACd,QAAO;AAGX,MAAI,IAAI,kBAAkB,YAEtB,QAAO,GAAG;AAEd,MAAI,CAAC,QAAQ,GAAG,CACZ,OAAM,IAAI,MAAM,iCAAiC;EAErD,MAAM,sBAAsB,MAAM,wBAAwB,OAAO,EAAE,GAAG,MAAM;AAG5E,SAAO,IAAI,YAAY;GACnB,GAAG;GACH,SAAS;GACT,qBAAqB;IAAE,QAAQ,GAAG;IAAQ,YAAY;IAAO,GAAG;IAAqB;GACxF,CAAC;;CAEN,MAAM,OAAO,QAAQ,EAAE,EAAE;EACrB,MAAM,EAAE,gBAAgB,MAAM,OAAO;AACrC,MAAI,eAAe,WAAW,sBAAsB,EAAE;AACtD,MAAI;GACA,MAAM,WAAW,EAAE;AAEnB,OAAI,MAAM,cAAc,MAAM,MAC1B,UAAS,KAAK,yBAAyB,CAAC;AAE5C,OAAI,MAAM,eACN,UAAS,KAAK,cAAc,MAAM,CAAC;GAIvC,MAAM,UAAU,MAAM,QAAQ,WAAW,SAAS;AAClD,QAAK,MAAM,UAAU,QACjB,KAAI,OAAO,WAAW,WAClB,KAAI,MAAM,wCAAwC,OAAO,SAAS,EAAE;GAG5E,MAAM,SAAS,IAAI,YAAY,MAAM;GAErC,MAAM,UAAU;EAC1B,OAAO,UAAU,YAAY,UAAU,sBAAsB,OAAO,MAAM,QAAQ,WAAW,GAAG;EAChG,OAAO,KAAK,OAAO,IAAI,OAAO,KAAK,SAAS,eAAe,OAAO,cAAc;AACtE,OAAI,MAAM,WAAW,QAAQ,EAAE;AAC/B,OAAI,MAAM,WAAW,OAAO,KAAK,EAAE;AACnC,UAAO;YAEH;AACJ,OAAI,SAAS,UAAU,EAAE;;;;;AAKrC,SAAS,QAAQ,IAAI;AACjB,KAAI,OAAO,2BAA2B,eAAe,cAAc,uBAC/D,QAAO;AAGX,QAAO,QAAQ,MAAM,OAAO,SAAS,GAAG,SAAS,CAAC;;AAEtD,MAAa,gBAAgB,IAAI,cAAc;;;;AC/E/C,SAAS,OAAO;AAChB,IAAM,aAAa,EAAE,iBAAkB,aAAa,aAAa;AACjE,IAAM,eAAe;CACjB,IAAI;CACJ,OAAO;CACP,QAAQ;CACR,OAAO;CACP,WAAW;CACX,kBAAkB;CAClB,eAAe;CACf,aAAa;CACb,YAAY,EAAE;CACd,QAAQ;CACR,QAAQ;CACR,aAAa,EAAE;CACf,IAAI;CACJ,QAAQ;CACR,QAAQ,EAAE;CACV,SAAS,EAAE;CACX,OAAO;CACP,YAAY;CACZ,iBAAiB;CACjB,aAAa;CACb,wBAAwB,EAAE;CAC1B,cAAc;CACd,UAAU;CACV,WAAW;CACX,yBAAyB,EAAE;CAC3B,eAAe;CACf,SAAS,EAAE;CACX,qBAAqB;CACrB,oBAAoB;CACpB,UAAU;CACV,mBAAmB;CACnB,0BAA0B;CAC1B,gBAAgB;CAChB,eAAe;CACf,QAAQ;CACR,UAAU,UAAUC,YAAI,MAAM,MAAM,SAAS,MAAM,MAAM,EAAE;CAC3D,SAAS;CACT,SAAS;CACT,aAAa;CACb,QAAQ;CACR,WAAW;CACX,YAAY;CACZ;CACA,YAAY;CACZ,OAAO;CACP,mBAAmB;CACtB;AAED,IAAM,OAAN,MAAW;CACP,YAAY,OAAO;AACf,OAAK,QAAQ;AACb,OAAK,SAAS;AAEd,OAAK,WAAW,EAAE;AAClB,OAAK,SAAS;AACd,OAAK,SAAS;AACd,OAAK,cAAc;AACnB,OAAK,eAAe;AACpB,OAAK,gBAAgB;AACrB,OAAK,eAAe;AACpB,OAAK,aAAa;AAClB,OAAK,eAAe;AACpB,OAAK,gBAAgB;AACrB,OAAK,UAAU;AACf,OAAK,gBAAgB;AACrB,OAAK,cAAc;GACf,YAAY;GACZ,YAAY;GACf;AACD,OAAK,QAAQ,IAAI,MAAM,EAAE,IAAI,WAAW,CAAC;AACzC,OAAK,UAAU;GACX,KAAK;GACL,cAAc;GACd,sBAAsB;GACtB,eAAe;GACf,UAAU;GACV,WAAW;GACX,SAAS;GACT,iBAAiB;GACjB,SAAS;GACT,iBAAiB;GACjB,cAAc;GACd,eAAe;GACf,oBAAoB;GACpB,WAAW;GACd;AACD,OAAK,kBAAkB;AACvB,OAAK,eAAe;AACpB,OAAK,eAAe;GAChB,MAAM;GACN,GAAG;GACH,GAAG;GACH,QAAQ;GACR,OAAO;GACV;;;;;AAKD,OAAK,uBAAuB;;AAK5B,OAAK,kBAAkB,UAAU;GAC7B,MAAM,EAAE,iBAAiB;AACzB,OAAI,MAAM,SAAS,gBAAgB;AAC/B,iBAAa,IAAI;AACjB,iBAAa,IAAI;AACjB,iBAAa,SAAS;cAEjB,MAAM,cAAc,MAAM,YAE/B;QAEC;IACD,MAAM,MAAM,MAAM;AAGlB,QAAI,CAAC,IACD;AAEJ,iBAAa,IAAI,IAAI;AACrB,iBAAa,IAAI,IAAI;AACrB,iBAAa,SAAS,KAAK,MAAM;;AAErC,OAAI,KAAK,aACL,MAAK,aAAa,QAAQ,gBAAgB;IAAE,GAAG,aAAa;IAAG,GAAG,aAAa;IAAG;AAEtF,gBAAa,QAAQ;;;AAGzB,OAAK,YAAY,UAAU;GACvB,MAAM,mBAAmB,eAAe,MAAM;GAC9C,MAAM,MAAM,MAAM;AAClB,OAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,KAAK,aACnC;GAGJ,MAAM,SAAS,KAAK,aAAa,WAAW;GAC5C,MAAM,OAAO,KAAK,WAAW,oBAAoB;IAC7C,GAAG,IAAI;IACP,GAAG,IAAI;IACP;IACA,WAAW,KAAK,aAAa,IAAI;IACpC,EAAE,KAAK,qBAAqB;GAC7B,MAAM,EAAE,UAAU;GAClB,MAAM,eAAe,UAAU,MAAM,qBAAqB,MAAM,MAAM;GACtE,MAAM,cAAc,KAAK,MAAM;GAC/B,IAAI,UAAU;AACd,OAAI,aACA,WAAU,aAAa,KAAK,OAAO,MAAM,MAAM;AAEnD,OAAI,CAAC,SAAS;AACV,kBAAc,MAAM,MAAM;AAC1B,SAAK,cAAc,QAAQ,MAAM,MAAM;;;;AAI/C,OAAK,kBAAkB,UAAU;AAE7B,OAAI,KAAK,QAAQ,SAAS,SACtB;GAEJ,MAAM,MAAM,MAAM;GAClB,MAAM,aAAa,KAAK,MAAM,cAAc,mBAAmB;IAC3D,GAAG,IAAI;IACP,GAAG,IAAI;IACP,QAAQ,KAAK,MAAM;IACtB,CAAC;AACF,QAAK,uBAAuB,WAAW,OAAO,MAAM,WAAW;;AAGnE,OAAK,QAAQ;GAAE,GAAG;GAAc,GAAG;GAAO;AAC1C,UAAQ,KAAK;AACb,MAAI,MAAM,aAAa,MAAM,iBACzB,aAAI,KAAK,mHAAmH,EAAE;AAElI,OAAK,YAAY,KAAK,MAAM;AAE5B,MAAI,MAAM,OACN,MAAK,SAAS,MAAM;EAExB,IAAI,kBAAkB,KAAK;AAE3B,MAAI,CAAC,mBAAmB,MAAM,IAAI;AAC9B,OAAI,MAAM,cAAc,sBACpB,aAAI,MAAM,gCAAgC,EAAE;GAGhD,MAAM,eAAe,KAAK,MAAM,aAAa;AAC7C,qBAAkB,cAAc,OAAO,MAAM,IAAI;IAC7C,GAAG,KAAK,MAAM;IACd,WAAW,eAAe,SAAS;KAG/B,MAAM,EAAE,OAAO,WAAW,cAAc;AAExC,mBAAc,qBAAqB;AAEnC,mBAAc,sBAAsB;AACpC,UAAK,eAAe;AACpB,oBAAe,eAAe,KAAK;;IAE1C,CAAC;;AAGN,MAAI,CAAC,gBACD,mBAAkB,KAAK,cAAc,MAAM;AAE/C,OAAK,gBAAgB,KAAK,qBAAqB,iBAAiB,MAAM;AACtE,OAAK,SAAS,MAAM;AAEpB,MAAI,MAAM,wBACN,6BAAkB,WAAW,MAAM,wBAAwB;AAE/D,OAAK,cAAc,OAAO;;;CAG9B,WAAW;AACP,OAAK,eAAe,MAAM;AAC1B,OAAK,eAAe,SAAS;AAC7B,OAAK,gBAAgB;AACrB,OAAK,uBAAuB;AAC5B,OAAK,cAAc,UAAU;AAC7B,OAAK,eAAe;AACpB,OAAK,aAAa,UAAU;AAC5B,OAAK,cAAc;AACnB,OAAK,eAAe,UAAU;AAC9B,OAAK,gBAAgB;AACrB,OAAK,cAAc,UAAU;AAC7B,OAAK,eAAe;AACpB,OAAK,YAAY,UAAU;AAC3B,OAAK,aAAa;AAClB,OAAK,cAAc,SAAS;AAC5B,OAAK,eAAe;AACpB,OAAK,eAAe,UAAU;AAC9B,OAAK,gBAAgB;AACrB,MAAI,CAAC,KAAK,MAAM,UAAU,CAAC,KAAK,MAAM,UAAU,CAAC,KAAK,MAAM,MAAM,KAAK,QAAQ;AAE3E,QAAK,OAAO,eAAe,YAAY,KAAK,OAAO;AACnD,QAAK,SAAS;;;;CAItB,SAAS,OAAO;AACZ,OAAK,MAAM,IAAI,gBAAgB,CAAC,WAAW;AAC3C,MAAI,kBAAkB,MAClB,aAAI,QAAQ,gBAAgB,UAAU,EAAE;AAE5C,MAAI,kBAAkB,MAClB,aAAI,QAAQ,gBAAgB,UAAU,EAAE;AAE5C,MAAI,MAAM,oBAEN,CAAC,UAAU,KAAK,MAAM,kBAAkB,MAAM,kBAAkB,EAAE,CAElE,MAAK,YAAY,MAAM;AAG3B,SAAO,OAAO,KAAK,OAAO,MAAM;AAEhC,OAAK,eAAe,KAAK,MAAM;EAE/B,MAAM,gBAAgB,OAAO,OAAO,KAAK,MAAM;AAC/C,SAAO,OAAO,eAAe;GACzB,OAAO,KAAK,WAAW;GACvB,OAAO,KAAK;GACZ,QAAQ,KAAK;GACb,WAAW,KAAK,eAAe;GAClC,CAAC;AACF,MAAI,MAAM,UAAU,MAAM,OAAO,OAAO,KAAK,QAAQ,IAAI;AACrD,QAAK,eAAe,MAAM;AAC1B,OAAI,KAAK,WAAW,MAAM,OAAO,eAAe,QAAQ;AAIpD,SAAK,QAAQ,QAAQ;AACrB,SAAK,cAAc,SAAS;AAE5B,SAAK,SAAS;;AAElB,eAAI,IAAI,gDAAgD,MAAM,OAAO,KAAK,EAAE;AAC5E,QAAK,gBAAgB,KAAK,qBAAqB,MAAM,QAAQ,MAAM;AACnE,QAAK,cAAc,OAAO;;AAG9B,OAAK,eAAe,SAAS,cAAc;AAC3C,MAAI,MAAM,oBAAoB,UAAa,KAAK,QAAQ,cACpD,MAAK,OAAO,cAAc,SAAS,EAAE,iBAAiB,MAAM,iBAAiB,CAAC;AAGlF,MAAI,KAAK,cAAc;AACnB,QAAK,YAAY,SAAS,cAAc;AAExC,QAAK,aAAa,iBAAiB,KAAK,cAAc,CAAC,GAAG;AAC1D,QAAK,aAAa,SAAS,cAAc;AACzC,QAAK,cAAc,SAAS,cAAc;AAC1C,QAAK,aAAa,SAAS,cAAc;AACzC,QAAK,WAAW,SAAS,cAAc;AACvC,QAAK,cAAc,SAAS,cAAc;;AAE9C,OAAK,MAAM,IAAI,gBAAgB,CAAC,SAAS;;;;;;CAO7C,YAAY,OAAO,EAAE,kBAAkB,OAAO,EAAE;AAC5C,MAAI,CAAC,KAAK,aAEN,QAAO;AAEX,MAAI,KAAK,MAAM,SACX,QAAO;EAEX,IAAI,SAAS,KAAK;AAClB,MAAI,KAAK,iBACL,MAAK,eAAe;EAExB,MAAM,yBAAyB,KAAK,YAAY,YAAY,KAAK;EACjE,MAAM,0BAA0B,KAAK,aAAa,YAAY,KAAK;EACnE,MAAM,2BAA2B,KAAK,cAAc,YAAY,KAAK;EACrE,MAAM,0BAA0B,KAAK,aAAa,YAAY,KAAK;AACnE,WACI,UACI,0BACA,2BACA,4BACA;AACR,SAAO;;;;;;;CAOX,OAAO,QAAQ;AACX,MAAI,CAAC,KAAK,aAEN;EAGJ,IAAI,eAAe,KAAK,YAAY,EAAE,kBAAkB,MAAM,CAAC;AAE/D,iBAAe,UAAU;AACzB,MAAI,CAAC,aACD;AAEJ,OAAK,MAAM,IAAI,eAAe,CAAC,gBAAgB;AAC/C,MAAI,KAAK,MAAM,cACX,MAAK,MAAM,cAAc,aAAa;MAGtC,MAAK,YAAY,aAAa;;;CAItC,IAAI,gBAAgB;AAChB,SAAO,KAAK,gBAAgB;;;CAGhC,WAAW;AACP,SAAO,KAAK,YAAY;AACxB,SAAO,KAAK,YAAY;;;;;CAK5B,aAAa,MAAM;AACf,SAAO,KAAK,YAAY;AACxB,SAAO,KAAK,YAAY,aAAa,KAAK;;;CAG9C,YAAY;AACR,SAAO,KAAK;;;CAGhB,WAAW,MAAM;EACb,MAAM,QAAQ,KAAK,MAAM,cAAc,mBAAmB,KAAK,CAAC;AAChE,SAAO,MAAM,SAAS,MAAM,KAAK;;CAGrC,oBAAoB,MAAM;AACtB,OAAK,QAAQ,KAAK,SAAS;AAC3B,SAAO,KAAK,MAAM,cAAc,4BAA4B,KAAK,CAAC;;CAGtE,YAAY,MAAM;AACd,SAAO,KAAK,MAAM,eAAe,oBAAoB,KAAK;;;;;CAK9D,cAAc,WAAW,cAAc,OAAO;AAC1C,OAAK,MAAM,MAAM,UACb,MAAK,aAAa,gBAAgB,IAAI;GAAE,YAAY;GAAI,MAAM,UAAU;GAAK;GAAa,CAAC;;;;;CAMnG,iBAAiB,aAAa;AAC1B,OAAK,MAAM,MAAM,YACb,MAAK,aAAa,gBAAgB,OAAO,GAAG;;;;;CAMpD,kBAAkB,QAAQ;AACtB,OAAK,cAAc,iBAAiB,OAAO;;CAE/C,wBAAwB,QAAQ;AAC5B,OAAK,aAAa,uBAAuB,OAAO;;CAEpD,2BAA2B,QAAQ;AAC/B,OAAK,cAAc,0BAA0B,OAAO;;CAExD,MAAM,QAAQ,SAAS,MAAM;AACzB,SAAO,KAAK,WAAW;EACvB,MAAM,EAAE,UAAU;AAClB,QAAM,IAAI,aAAa,CAAC,gBAAgB;AACxC,QAAM,IAAI,QAAQ,CAAC,WAAW;EAC9B,MAAM,QAAQ,KAAK,WAAW,QAAQ;GAElC,QAAQ,KAAK,aAAa,UAAU,KAAK;GACzC,OAAO,KAAK,YAAY,UAAU;GAClC,WAAW,KAAK,aAAa,KAAK;GAClC,kBAAkB,KAAK,aAAa;GACpC,SAAS,KAAK,cAAc,YAAY;GACxC,GAAG;GACN,CAAC;AACF,QAAM,IAAI,QAAQ,CAAC,SAAS;AAC5B,SAAO;;;CAGX,cAAc,OAAO;EACjB,IAAI,SAAS,MAAM;AAEnB,MAAI,OAAO,WAAW,UAAU;AAC5B,YAAS,SAAS,eAAe,OAAO;AACxC,UAAO,OAAO;;AAElB,MAAI,CAAC,QAAQ;AACT,YAAS,SAAS,cAAc,SAAS;AACzC,UAAO,KAAK,MAAM,MAAM;AAGxB,OAAI,MAAM,SAAS,OAAO,MAAM,UAAU,SACtC,QAAO,QAAQ,MAAM;AAEzB,OAAI,MAAM,UAAU,OAAO,MAAM,WAAW,SACxC,QAAO,SAAS,MAAM;AAG1B,IADe,MAAM,UAAU,SAAS,MACjC,YAAY,OAAO;;AAE9B,SAAO,OAAO,OAAO,OAAO,MAAM,MAAM;AACxC,SAAO;;;CAGX,eAAe,OAAO;AAClB,MAAI,CAAC,KAAK,OACN;EAEJ,MAAM,EAAE,OAAO,WAAW;AAE1B,MAAI,SAAS,UAAU,GAAG;GACtB,MAAM,WAAW,OAAO,SAAS,MAAM,GAAG,GAAG,MAAM,MAAM;AACzD,QAAK,OAAO,MAAM,QAAQ;;AAE9B,MAAI,UAAU,WAAW,GAAG;GACxB,MAAM,YAAY,OAAO,SAAS,OAAO,GAAG,GAAG,OAAO,MAAM;AAE5D,QAAK,OAAO,MAAM,WAAW,MAAM,OAAO,YAAY;AACtD,QAAK,OAAO,MAAM,SAAS;;;;CAInC,oBAAoB;EAChB,MAAM,EAAE,WAAW;AACnB,MAAI,CAAC,OACD;EAGJ,MAAM,WAAW,OAAO,eAAe,OAAO;EAC9C,MAAM,YAAY,OAAO,gBAAgB,OAAO;AAChD,MAAI,aAAa,KAAK,SAAS,cAAc,KAAK,QAAQ;AAEtD,QAAK,QAAQ;AAEb,QAAK,SAAS;AACd,QAAK,aAAa,SAAS;IAAE,OAAO;IAAU,QAAQ;IAAW,CAAC;AAElE,QAAK,cAAc,iBAAiB,KAAK,cAAc,CAAC,GAAG;AAC3D,QAAK,MAAM,SAAS;IAAE,OAAO;IAAU,QAAQ;IAAW,CAAC;;;CAGnE,qBAAqB,iBAAiB,OAAO;EACzC,MAAM,EAGN,IAEA,YAGK;AACL,SAAO,IAAI,cAAc;GACrB,QAAQ;GAER,yBAAyB,CAAC;GAC1B,oBAAoB;GAEpB,eAAc,YAAW,KAAK,WAAW,QAAQ,OAAO;GACxD,UAAU,KAAK,eAAe,KAAK,KAAK;GAExC;GAGH,CAAC;;CAGN,cAAc,OAAO;EACjB,MAAM,yBAAyB,KAAK,MAAM,aAAa;EACvD,MAAM,qBAAqB,OAAO,2BAA2B,WAAW,yBAAyB;EAGjG,MAAM,cAAc;GAChB,UAAU,EAAE;GACZ,eAAe;GACf,iBAAiB;GACjB,GAAG,MAAM;GACZ;AACD,MAAI,CAAC,YAAY,SAAS,SAAS,cAAc,CAC7C,aAAY,SAAS,KAAK,cAAc;EAE5C,MAAM,qBAAqB,EAEvB,WAAW,KAAK,MAAM,aAAa,SAAS,WAAW,kBAAkB,QAC5E;EAED,MAAM,eAAe,KAAK,MAAM,aAAa;AAE7C,SAAO,KAAK,aAAa;GAIrB,eAAe;GAEf,MAAM;GACN,GAAG;GAEH,qBAAqB;IACjB,GAAG;IACH,GAAG;IACH,QAAQ,KAAK,cAAc,MAAM;IACjC,iBAAiB,KAAK,MAAM;IAC5B,YAAY;IACf;GACD,WAAW,eAAe,SAAS;AAG/B,SAAK,eAAe;AAEpB,mBAAe,eAAe,KAAK;;GAE1C,CAAC;;CAIN,gBAAgB;AACZ,SAAO,KAAK,MAAM,aAAa,KAAK;;CAGxC,YAAY;EACR,MAAM,EAAE,UAAU,KAAK;EACvB,MAAM,kBAAkB,MAAM,QAAQ,MAAM,GACtC,QAEE,QACM,CAAC,MAAM,GACP,CAAC,IAAIC,iBAAQ,EAAE,IAAI,gBAAgB,CAAC,CAAC;AACnD,MAAI,gBAAgB,UAAU,KAAK,MAAM,WAErC,iBAAgB,GAAG,MAAM,aAAa,KAAK,MAAM;AAErD,SAAO;;CAEX,iBAAiB;EACb,MAAM,EAAE,YAAY,KAAK;AACzB,MAAI,KAAK,iBAAiB,QACtB,yBAAQ,IAAI,MAAM,wBAAwB,CAAC;;;CAInD,mBAAmB;AACf,MAAI,KAAK,QAAQ,SAAS,SACtB;EAEJ,MAAM,EAAE,iBAAiB;AACzB,MAAI,aAAa,OAAO;GAEpB,MAAM,EAAE,QAAQ,cAAc,KAAK,MAAM,cAAc,mBAAmB,aAAa;AACvF,QAAK,YAAY,aAAa,OAAO,SAAS;GAW9C,IAAI,aAAa;GACjB,IAAI,UAAU;AACd,QAAK,MAAM,QAAQ,QAAQ;AACvB,iBAAa;AACb,cAAU,KAAK,OAAO,QAAQ,MAAM,aAAa,MAAM,IAAI;;AAE/D,OAAI,CAAC,SAAS;AACV,SAAK,MAAM,UAAU,YAAY,aAAa,MAAM;AACpD,SAAK,cAAc,QAAQ,YAAY,aAAa,MAAM;;AAG9D,gBAAa,QAAQ;;;CAG7B,gBAAgB;EACZ,MAAM,YAAY,KAAK,MAAM,UAAU,KAAK;AAC5C,MAAI,UACA,WAAU,MAAM,SAAS,KAAK,MAAM,UAAU,KAAK,YAAY;;CAGvE,WAAW,QAAQ;AACf,OAAK,SAAS;AACd,MAAI,CAAC,KAAK,cAEN;AAGJ,MAAI,CAAC,KAAK,QAAQ;AACd,QAAK,SAAS,KAAK,OAAO,eAAe;AAEzC,OAAI,CAAC,KAAK,OAAO,eAAe,KAAK,MAAM,OACvC,MAAK,MAAM,OAAO,aAAa,KAAK,QAAQ,KAAK,MAAM,OAAO,WAAW;;AAQjF,MAAI,KAAK,OAAO,SAAS,QACrB,MAAK,OAAO,mBAAmB;GAC3B,OAAO;GACP,WAAW;IAAC;IAAK;IAAK;IAAG;IAAI;GAC7B,mBAAmB;GACnB,WAAW;GACX,WAAW;GACd,CAAC;AAEN,OAAK,MAAM,oBAAoB,KAAK,OAAO;AAC3C,MAAI,KAAK,OAAO,SAAS,QAGrB,MAAK,MAAM,mBAAmB,KAAK,OAAO,GAAG;EAGjD,MAAM,WAAW,IAAI,UAAU;AAC/B,WAAS,MAAM;AACf,OAAK,cAAc,eAAe,SAAS;AAC3C,OAAK,eAAe,IAAI,aAAa,KAAK,MAAM,UAAU,KAAK,QAAQ;GACnE,aAAa,KAAK,MAAM;GACxB,aAAa,OAAO,KAAK,YAAY,CAAC,KAAK,cAAc;IAErD,MAAM,CAAC,uBAAuB,gBAAgB,eAAe,kBAAkB,YAAY;IAC3F,MAAM,kBAAkB,KAAK,MAAM,yBAAyB;AAE5D,WAAO;KACH,YAAY,IAAI,sBAFJ;MAAE,GAAG;MAAgB,GAAG;MAAiB,OAAO;MAAW,CAEzB;KAC9C;KACA;KACH;KACH;GACF,QAAQ;IACJ,aAAa,KAAK;IAClB,aAAa,KAAK;IAClB,cAAc,KAAK;IACtB;GACJ,CAAC;AACF,OAAK,MAAM,aAAa,eACpB,MAAK,aAAa,GAAG,WAAW,KAAK,SAAS;AAElD,OAAK,cAAc,IAAI,YAAY;GAC/B;GACA,cAAc,KAAK;GACnB,mBAAmB,KAAK,mBAAmB,KAAK,KAAK;GACrD,0BAA0B,KAAK,0BAA0B,KAAK,KAAK;GACnE,OAAO,KAAK,WAAW;GACvB,WAAW,KAAK,eAAe;GAC/B,OAAO,KAAK;GACZ,QAAQ,KAAK;GAChB,CAAC;EAGF,MAAM,WAAW,KAAK,YAAY,cAAc,CAAC;AAEjD,OAAK,eAAe,IAAI,aAAa,KAAK,QAAQ;GAC9C,MAAM;GACN,OAAO,KAAK;GACZ;GACA;GACH,CAAC;AACF,OAAK,gBAAgB,IAAI,cAAc;GACnC,MAAM;GACN,QAAQ,KAAK;GAChB,CAAC;AACF,OAAK,eAAe,IAAI,aAAa,KAAK,OAAO;AACjD,OAAK,aAAa,IAAI,WAAW,KAAK,OAAO;AAC7C,OAAK,gBAAgB,IAAI,cAAc;GACnC,MAAM;GACN,eAAe,KAAK,QAAQ;GAC/B,CAAC;AACF,OAAK,cAAc,WAAW,IAAI,eAAe,CAAC;AAClD,OAAK,SAAS,KAAK,MAAM;AACzB,OAAK,mBAAmB;AACxB,OAAK,MAAM,QAAQ;;;CAGvB,YAAY,cAAc,eAAe;EACrC,MAAM,EAAE,QAAQ,OAAO,KAAK,aAAa;AACzC,OAAK,MAAM,eAAe;GAAE;GAAQ;GAAI,CAAC;EACzC,MAAM,OAAO;GACT,QAAQ,KAAK,MAAM;GACnB,QAAQ,KAAK,aAAa,WAAW;GACrC,WAAW,KAAK,YAAY,cAAc;GAC1C,kBAAkB,KAAK,aAAa;GACpC,OAAO,KAAK,YAAY,UAAU;GAClC,MAAM;GACN,SAAS,KAAK,cAAc,YAAY;GACxC,GAAG;GACN;AACD,OAAK,cAAc,aAAa,KAAK;AACrC,MAAI,KAAK,SAAS,SAGd,MAAK,cAAc,SAAS;GACxB,WAAW,KAAK;GAChB,QAAQ,KAAK;GAChB,CAAC;AAEN,OAAK,MAAM,cAAc;GAAE;GAAQ;GAAI,CAAC;;CAG5C,iBAAiB;AACb,OAAK,gBAAgB;AAErB,MAAI,KAAK,oBAAoB,OAAO,GAAG;AACnC,QAAK,aAAa;AAClB,QAAK,MAAM,OAAO;AAClB,eAAI,MAAM,GAAG,KAAK,QAAQ,EAAE;AAE5B,OAAI,KAAK,MAAM,WACX,MAAK,MAAM,WAAW,KAAK,QAAQ;;AAG3C,OAAK,mBAAmB;AACxB,OAAK,eAAe;AAGpB,OAAK,aAAa,cAAc;AAGhC,MAAI,KAAK,QAAQ,SAAS,SACtB,MAAK,kBAAkB;AAG3B,OAAK,QAAQ;AAIb,MAAI,KAAK,YACL,MAAK,YAAY,kBAAkB;;CAI3C,mBAAmB,QAAQ;EAEvB,MAAM,YAAY,KAAK,MAAM,kBAAkB,OAAO,IAAI,OAAO;AAEjE,MAAI,KAAK,WAAW;AAChB,QAAK,YAAY;IAAE,GAAG,KAAK;KAAY,OAAO,SAAS;IAAW;AAClE,OAAI,CAAC,KAAK,MAAM,WAEZ;QAAI,KAAK,YACL,MAAK,YAAY,SAAS,EAAE,WAAW,KAAK,WAAW,CAAC;;;;CAKxE,0BAA0B,kBAAkB;AACxC,OAAK,YAAY,aAAa,iBAAiB,cAAc;AAC7D,OAAK,MAAM,yBAAyB,iBAAiB;;CAEzD,iBAAiB;EACb,MAAM,EAAE,UAAU;AAClB,QAAM,IAAI,YAAY,CAAC,SAAS;AAChC,QAAM,IAAI,YAAY,CAAC,WAAW;EAElC,MAAM,qBAAqB,KAAK,cAAc;AAC9C,QAAM,IAAI,WAAW,CAAC,QAAQ,mBAAmB,IAAI,WAAW,CAAC,WAAW;AAC5E,QAAM,IAAI,WAAW,CAAC,QAAQ,mBAAmB,IAAI,WAAW,CAAC,WAAW;;CAEhF,cAAc;EACV,MAAM,EAAE,SAAS,UAAU;AAC3B,UAAQ,MAAM,MAAM,IAAI,YAAY,CAAC,OAAO;AAC5C,UAAQ,eAAe,MAAM,IAAI,gBAAgB,CAAC;AAClD,UAAQ,uBAAuB,MAAM,IAAI,oBAAoB,CAAC;AAC9D,UAAQ,gBAAgB,MAAM,IAAI,eAAe,CAAC;AAClD,UAAQ,WACJ,MAAM,IAAI,kBAAkB,CAAC,OACzB,MAAM,IAAI,2BAA2B,CAAC,OACtC,MAAM,IAAI,mBAAmB,CAAC;AACtC,UAAQ,YAAY,MAAM,IAAI,aAAa,CAAC;AAE5C,UAAQ,UAAU,MAAM,IAAI,WAAW,CAAC;AACxC,UAAQ,UAAU,MAAM,IAAI,WAAW,CAAC;AACxC,UAAQ,kBAAkB,MAAM,IAAI,WAAW,CAAC,gBAAgB;AAChE,UAAQ,kBAAkB,MAAM,IAAI,WAAW,CAAC,gBAAgB;EAChE,MAAM,cAAc,KAAK,MAAM,IAAI,eAAe;AAClD,UAAQ,eAAe,YAAY,IAAI,gBAAgB,CAAC;AACxD,UAAQ,gBAAgB,YAAY,IAAI,iBAAiB,CAAC;AAC1D,UAAQ,qBAAqB,YAAY,IAAI,sBAAsB,CAAC;AACpE,UAAQ,YAAY,YAAY,IAAI,aAAa,CAAC;;;AAG1D,KAAK,eAAe;AAGpB,KAAK,UAAU;AACf,mBAAe;;;;AC/1Bf,IAAM,aAAN,cAAyB,SAAS;CAC9B,YAAY,SAAS;EACjB,MAAM,EAAE,aAAa,GAAG,oBAAoB;AAC5C,QAAM,gBAAgB;AACtB,MAAI,gBAAgB,OAChB,MAAK,OAAO,cAAc;;CAGlC,SAAS,EAAE,OAAO;EACd,MAAM,EAAE,UAAU,WAAW,SAAS,KAAK,kBAAkB;AAC7D,SAAO,KAAK,iBAAiB;GACzB,gBAAgB,CAAC,WAAW,SAAS;GACrC,aAAa;GACb,WAAW;GACd,CAAC;;CAEN,IAAI,EAAE,KAAK,YAAY;EACnB,MAAM,QAAQ,KAAK,UAAU;EAC7B,MAAM,iBAAiB,MAAM,kBAAkB,KAAK,WAAW,SAAS;AACxE,MAAI,CAAC,eACD,QAAO;EACX,MAAM,YAAY,MAAM,aAAa,KAAK,kBAAkB,CAAC;EAC7D,MAAM,cAAc,MAAM,eAAe;EACzC,MAAM,SAAS;GAAC,eAAe;GAAI,eAAe;GAAI;GAAU;EAEhE,MAAM,WADW,KAAK,aAAa,KAAK,kBAAkB,CAAC,CACjC,cAAc,QAAQ,KAAK,YAAY;AACjE,SAAO,KAAK,iBAAiB,SAAS;;CAE1C,SAAS;AACL,SAAO,KAAK,iBAAiB;GACzB,gBAAgB;GAChB,aAAa;GACb,WAAW;GACd,CAAC;;CAEN,KAAK,EAAE,kBAAS;EAGZ,MAAM,QADY,KAAK,UAAU,CAAC,aAAa,KAAK,kBAAkB,CAAC,QAC9C,KAAK,KAAKC,QAAM;AACzC,SAAO,KAAK,iBAAiB,EAAE,MAAM,CAAC;;CAE1C,iBAAiB,OAAO;EAEpB,MAAM,EAAE,WAAW,UAAU,SAAS,SAAS,SAAS;EACxD,MAAM,QAAQ,WAAW,EAAE;EAC3B,MAAM,iBAAiB,WAAW,SAAS,GAAG;AAC9C,QAAM,OAAO,MAAM,MAAM,UAAU,gBAAgB,UAAU,eAAe;AAC5E,MAAI,YAAY,QAAQ,YAAY,IAChC,OAAM,YAAY,IAAI,YAAY,KAAK,IAAI,GAAG;AAElD,QAAM,WAAW,MAAM,UAAU,CAAC,cAAc,aAAa;AAC7D,SAAO;;;AAGf,IAAqB,kBAArB,cAA6C,WAAW;CACpD,cAAc;AACV,QAAM,GAAG,UAAU;AACnB,OAAK,kBAAkB;AACvB,OAAK,aAAa;GACd,oBAAoB;GACpB,wBAAwB,IAAI,mBAAmB;IAAC;IAAa;IAAY;IAAO,CAAC;GACpF;AACD,OAAK,WAAW;;CAEpB,SAAS,OAAO;AACZ,QAAM,SAAS,MAAM;AAErB,OAAK,aAAa;AAClB,OAAK,cAAc;;;;;;ACvE3B,IAAM,YAAN,cAAwB,KAAK;CACzB,YAAY,QAAQ,EAAE,EAAE;AACpB,QAAM,MAAM;;CAEhB,gBAAgB,WAAW;AACvB,SAAO,UAAU,OAAO,KAAKC,gCAAsBC;;CAEvD,IAAI,iBAAiB;AACjB,SAAO;;;AAGf,UAAU,cAAc;AACxB,yBAAe;;;;ACdf,IAAM,iBAAiB;AAEvB,IAAM,YAAY;AAClB,IAAM,qBAAqB,KAAK,KAAK;AAErC,SAAgB,gBAAgB,EAAE,KAAK,IAAI,QAAQ;AAE/C,KAAI,IAAI,OACJ,QAAO,IAAI;CAGf,MAAM,eAAe,MAAM,MAAM;CACjC,MAAM,SAAS,MAAM,MAAM;CAC3B,MAAM,YAAY;EACd,GAAG,MAAM;EACT,qBAAqB;AACjB,OAAI,gBAAgB;AAKpB,kBAAe,GAAG;;EAEzB;AACD,WAAU,aAAa;EAAE,GAAG,qBAAqB,KAAK,KAAK;EAAE,GAAG,UAAU;EAAY;AACtF,WAAU,UAAU,UAAU,QAAQ,eAAe,IAAI;CACzD,IAAI;AACJ,KAAI,CAAC,QAAQ,KAAK,MAAM,OAAO,IAAI;AAK/B,SAAO,OAAO,WAAW;GACrB;GACA,OAAO;GACP,QAAQ;GACR,aAAa;GACb,WAAW,aAAa,IAAI;GAC/B,CAAC;AACF,MAAI,MAAM,cACN,cAAa,MAAM,IAAI;MAGvB,WAAU,eAAe;AACrB,aAAU;AACV,gBAAa,cAAc,IAAI;;;AAI3C,KAAI,MAAM;AACN,iBAAe;AACf,OAAK,SAAS,UAAU;AACxB,OAAK,SAAS,aAAa;QAE1B;AACD,iBAAe,IAAIC,aAAK,UAAU;AAClC,MAAI,GAAG,gBAAgB;AACnB,sBAAmB,IAAI;IACzB;;AAEN,cAAa,SAAS,+BAAe,IAAI,KAAK;AAE9C,KAAI,SAAS;AACb,KAAI,GAAG,gBAAgB;AACnB,MAAI,aAAa,cACb,aAAY,cAAc,IAAI;GACpC;AACF,QAAO;;AAEX,SAAS,aAAa,MAAM,KAAK;CAC7B,MAAM,uBAAuB;AACzB,MAAI,KAAK,cAEL,WAAU,MAAM,IAAI;MAIpB,KAAI,IAAI,QAAQ,eAAe;;AAGvC,KAAI,GAAG,QAAQ,eAAe;;AAElC,SAAgB,mBAAmB,KAAK;AACpC,KAAI,QAAQ,UAAU;AACtB,KAAI,SAAS;;AAEjB,SAAgB,qBAAqB,KAAK,aAAa;CACnD,MAAM,SAAS,cACT;EACE,mBAAmB;EACnB,cAAc;EACd,WAAW;EACX,OAAO;EACP,qBAAqB;EACrB,qBAAqB;EACrB,qBAAqB;EACrB,qBAAqB;EACrB,qBAAqB;EACrB,qBAAqB;EACxB,GACC,EAAE;AACR,KAAI,cAAc,IAAI,KAAK,QACvB,QAAO,WAAW;AAEtB,QAAO;;AAEX,SAAgB,SAAS,MAAM,OAAO;AAClC,MAAK,SAAS,aAAa,IAAI,MAAM;AACrC,cAAa,KAAK;;AAEtB,SAAgB,YAAY,MAAM,OAAO;AACrC,MAAK,SAAS,aAAa,OAAO,MAAM;AACxC,cAAa,KAAK;;AAEtB,SAAgB,YAAY,MAAM,OAAO;AACrC,cAAa,KAAK;;AAEtB,SAAgB,UAAU,MAAM,KAAK,OAAO,kBAAkB;CAC1D,IAAI,EAAE,oBAAoB,KAAK;CAC/B,IAAI,aAAa;AACjB,KAAI,CAAC,iBAAiB;AAGlB,oBAAkB,YAAY,MAAM,KAAK,iBAAiB;AAC1D,OAAK,SAAS,kBAAkB;AAChC,eAAa;;AAEjB,KAAI,CAAC,KAAK,cACN;AAEJ,MAAK,YAAY,kBAAkB;EAC/B,WAAW,CAAC,gBAAgB;EAC5B,cAAa,YAAW,CAAC,KAAK,MAAM,eAAe,KAAK,MAAM,YAAY,OAAO,MAC5E,MAAM,OAAO,OAAO,MAAM,MAAM,OAAO,MAAM,MAAM,UAAU,SAAS,UAAU;EACrF;EACA,aAAa;EAChB,CAAC;;AAEN,SAAgB,eAAe,MAAM,KAAK,OAAO,kBAAkB;CAC/D,IAAI,EAAE,oBAAoB,KAAK;CAC/B,IAAI,aAAa;AACjB,KAAI,CAAC,iBAAiB;AAGlB,oBAAkB,YAAY,MAAM,KAAK,iBAAiB;AAC1D,OAAK,SAAS,kBAAkB;AAChC,eAAa;;AAEjB,KAAI,CAAC,KAAK,cACN;AAEJ,MAAK,YAAY,kBAAkB;EAC/B,WAAW,CAAC,gBAAgB;EAC5B,cAAa,WAAU;AACnB,OAAI,KAAK,MAAM,eAAe,CAAC,KAAK,MAAM,YAAY,OAAO,CACzD,QAAO;GAEX,MAAM,QAAQ,OAAO;AACrB,OAAI,MAAM,MAAM,aAAa,MAAM,YAAY,MAAM,MAAM,SAAS,MAAM,KACtE,QAAO;AAEX,UAAO;;EAEX;EACA,aAAa;EAChB,CAAC;;AAEN,SAAgB,cAAc,KAAK;CAC/B,MAAM,aAAa,IAAI,iBAAiB;CACxC,MAAM,OAEN,YAAY,QAER,YAAY;AAChB,KAAI,SAAS,QACT,QAAO;AAEX,KAAI,QAAQ,SAAS,WACjB,OAAM,IAAI,MAAM,yBAAyB;AAE7C,QAAO;;AAEX,SAAgB,eAAe,KAAK;AAChC,KAAI,cAAc,IAAI,KAAK,QACvB,QAAO,IAAIC,mBAAU,EAAE,IAAI,gBAAgB,CAAC;AAEhD,QAAO,IAAIC,iBAAQ,EAAE,IAAI,gBAAgB,CAAC;;AAE9C,SAAgB,aAAa,KAAK;CAC9B,MAAM,EAAE,KAAK,QAAQ,IAAI,WAAW;CACpC,MAAM,YAAY;EAGd,YAAa,MAAM,OAAO,MAAO;EACjC,UAAU;EACV,MAAM,IAAI,SAAS;EACnB,SAAS,IAAI,YAAY;EACzB,OAAO,IAAI,UAAU;EACrB,SAAS,IAAI,YAAY;EACzB,QAAQ,IAAI,sBAAsB;EACrC;AACD,KAAI,IAAI,cAAc,CAElB,uBAAsB,KAAK,UAAU;AAEzC,QAAO;;AAEX,SAAS,sBAAsB,KAAK,WAAW;AAC3C,KAAI,IAAI,sBAAsB;EAE1B,MAAM,EAAE,aAAa,IAAI,sBAAsB;AAC/C,MAAI,CAAC,YAAY,SAAS,MAAM,OAC5B;EAGJ,MAAM,SAAS,IAAI,UAAU;EAC7B,MAAM,EAAE,WAAW,UAAU,UAAU;EAEvC,MAAM,UAAU,SAAS,IAAI;EAC7B,MAAM,WAAW,IAAI,SAAS,KAAK;EACnC,MAAM,UAAU,SAAS,IAAI;EAE7B,MAAM,SAAS,cAAc,CAAC,WAAW,SAAS,CAAC;EACnD,MAAM,KAAK,UAAU,OAAO;EAC5B,MAAM,KAAK,UAAU,OAAO;EAC5B,MAAM,+BAA+B,KAAK,KAAK,KAAK,KAAK,KAAK,GAAG;EACjE,MAAM,eAAe,QAAQ;EAC7B,MAAM,iBAAiB,MAAM;EAC7B,MAAMC,UAAQ,eAAe,OAEpB,iBAAiB,KAAK,IAAI,aAAa,GAAI,UAC7C,iBAAiB,KAAK,IAAI,aAAa,GAAI;AAClD,YAAU,OAAO,KAAK,KAAKA,QAAM;AAGjC,YAAU,WAAW;GAAC;GAAG;IADA,UADG,iBAAiB,KAAK,IAAI,aAAa,GAAIA,WAExB,cAAc,SAAS;GAAC;YAGlE,OAAO,IAAI,UAAU,cAAc,SAGxC,WAAU,WAAW;EAAC;EAAG;EAAG,IAAI,UAAU;EAAU;;AAG5D,SAAS,YAAY,MAAM,KAAK,kBAAkB;CAC9C,MAAM,YAAY,aAAa,IAAI;CACnC,MAAM,EAAE,UAAU,KAAK;CACvB,MAAM,OAAQ,SAAS,QAAQ,MAAM,CAAC,MAAM,MAAM,EAAE,OAAO,eAAe,IACtE,eAAe,IAAI;AACvB,KAAI,iBAGA,MAAK,MAAM,kBAAkB;CAKjC,MAAM,QAAQ,kBAAkB,SAAS,IAAI,UAAU;CACvD,MAAM,OAAO,kBAAkB,QAAQ,IAAI,UAAU;AACrD,KAAI,OAAO,SAAS,MAAM,EAAE;AACxB,YAAU,QAAQ,QAAQ,IAAI,UAAU;AACxC,YAAU,OAAO,OAAO,IAAI,UAAU;;AAG1C,QAAO,KAAK,aAAa;EACrB,OAAO,KAAK;EACZ,QAAQ,KAAK;EACb;EACH,CAAC;;AAEN,SAAS,YAAY,MAAM,KAAK;CAC5B,MAAM,EAAE,cAAc,eAAe,KAAK;AAC1C,KAAI,YAAY;EAEZ,MAAM,iBAAiB,MAAM,KAAK,eAAc,UAAS,MAAM,GAAG;EAElE,MAAM,qBADa,QAAQ,KAAK,MAAM,QAAQ,QAAQ,CAChB,MAAK,UAAS,SAAS,CAAC,eAAe,SAAS,MAAM,GAAG,CAAC;EAChG,IAAI,YAAY,KAAK,cAAc;EACnC,MAAM,oBAAoB,UAAU,WAAU,OAAM,GAAG,OAAO,eAAe;EAC7E,MAAM,oBAAoB,UAAU,SAAS,KAAK,oBAAoB;AACtE,MAAI,sBAAsB,mBAAmB;AACzC,OAAI,qBAAqB,GAAG;AACxB,gBAAY,UAAU,OAAO;AAC7B,cAAU,qBAAqB,YAAY,MAAM,IAAI;;AAEzD,QAAK,YAAY,kBAAkB;IAC/B;IACA,cAAa,YAAW,CAAC,KAAK,MAAM,eAAe,KAAK,MAAM,YAAY,OAAO,MAC5E,OAAO,SAAS,OAAO,kBAAkB,CAAC,eAAe,SAAS,OAAO,MAAM,GAAG;IACvF,aAAa;IAChB,CAAC;;;AAIV,MAAK,SAAS,kBAAkB;;AAEpC,SAAS,UAAU,MAAM,KAAK;AAC1B,MAAK,SAAS,EACV,WAAW,aAAa,IAAI,EAC/B,CAAC;AAIF,MAAK,YAAY,EAAE,kBAAkB,MAAM,CAAC;;AAEhD,SAAS,aAAa,MAAM;AACxB,KAAI,KAAK,SAAS,WACd;CAEJ,MAAM,SAAS,EAAE;AACjB,MAAK,SAAS,aAAa,SAAQ,cAAa;EAC5C,MAAM,YAAY,UAAU,MAAM;EAClC,MAAM,QAAQ,IAAI,UAAU,UAAU,MAAM;AAC5C,SAAO,KAAK,MAAM;GACpB;AACF,MAAK,SAAS,EAAE,QAAQ,CAAC;;;;;AC5T7B,IAAqB,cAArB,MAAiC;CAE7B,YAAY,OAAO;AACf,MAAI,CAAC,MAAM,GACP,OAAM,IAAI,MAAM,+BAA+B;AAEnD,OAAK,KAAK,MAAM;AAChB,OAAK,OAAO;AACZ,OAAK,gBAAgB,MAAM,iBAAiB;AAC5C,OAAK,OAAO,MAAM;AAClB,OAAK,MAAM;AACX,OAAK,OAAO;AACZ,OAAK,QAAQ;;CAGjB,MAAM,KAAK,IAAI;AACX,OAAK,MAAM;AACX,OAAK,OAAO,gBAAgB;GAAE;GAAK;GAAI,MAAM,KAAK,MAAM;GAAM,CAAC;AAC/D,WAAS,KAAK,MAAM,KAAK;;CAE7B,WAAW;AACP,MAAI,KAAK,KACL,aAAY,KAAK,MAAM,KAAK;;CAGpC,SAAS,OAAO;AAEZ,SAAO,OAAO,KAAK,OAAO,OAAO,EAAE,IAAI,KAAK,IAAI,CAAC;AAEjD,MAAI,KAAK,KACL,aAAY,KAAK,MAAM,KAAK;;CAGpC,OAAO,IAAI,kBAAkB;AACzB,YAAU,KAAK,MAAM,KAAK,KAAK,MAAM,iBAAiB;;;;;;ACjC9D,IAAMC,wBAAsB;;AAG5B,SAAgB,cAAc,KAAK,MAAM,WAAW,WAAW;AAG3D,KAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,SAAS,CAAC,IAAI,MAAM,QAC1C;CAEJ,MAAM,SAAS,QAAQ,WAAW,QAAQ;AAC1C,KAAI,cAAc,WAAW;EAEzB,MAAM,aAAa,QAAQ,WAAW,QAAQ;EAC9C,MAAM,eAAe,IAAI,IAAI,WAAW,KAAI,MAAK,EAAE,GAAG,CAAC;AACvD,OAAK,MAAM,SAAS,OAChB,cAAa,OAAO,MAAM,GAAG;AAEjC,OAAK,MAAM,MAAM,aACb,KAAI,IAAI,SAAS,GAAG,CAChB,KAAI,YAAY,GAAG;;AAK/B,MAAK,MAAM,SAAS,QAAQ;EACxB,MAAM,cAAc,IAAI,SAAS,MAAM,GAAG;AAC1C,MAAI,YAIA,EADsB,YAAY,kBAAkB,aACtC,SAAS,MAAM,MAAM;MAGnC,KAAI,SAAS,IAAI,YAAY;GACzB,IAAI,MAAM;GACV;GAEA,MAAM,MAAM,MAAM;GACrB,CAAC,EAEF,MAAM,MAAM,SAAS;;CAQ7B,MAAM,YAAY,IAAI,MAAM;CAE5B,MAAM,cAAc,EAAE;AACtB,MAAK,MAAM,SAAS,QAAQ;EAExB,IAAI,EAAE,aAAa,MAAM;AACzB,MAAI,CAAC,YAAY,CAAC,UAAU,SAAS,SAAS,CAC1C,YAAWA;AAEf,cAAY,YAAY,YAAY,aAAa,EAAE;AACnD,cAAY,UAAU,KAAK,MAAM,GAAG;;AAExC,MAAK,MAAM,YAAY,aAAa;EAChC,MAAM,aAAa,YAAY;EAC/B,IAAI,iBAAiB,aAAaA,wBAAsB,UAAU,SAAS,UAAU,QAAQ,SAAS;EACtG,IAAI,cAAc,aAAaA,wBAAsB,SAAY;AACjE,OAAK,IAAI,IAAI,WAAW,SAAS,GAAG,KAAK,GAAG,KAAK;GAC7C,MAAM,UAAU,WAAW;GAC3B,MAAM,aAAa,UAAU,QAAQ,QAAQ;AAC7C,OAAI,eAAe,iBAAiB,GAAG;AACnC,QAAI,UAAU,SAAS,YAAY;AACnC,QAAI,aAAa,eAEb;;AAGR;AACA,iBAAc;;;;;;;AC3E1B,IAAqB,mBAArB,MAAsC;CAElC,YAAY,OAAO;AACf,SAAO,MAAM,IAAI,iBAAiB;AAClC,OAAK,KAAK,MAAM;AAChB,OAAK,OAAO;AACZ,OAAK,gBAAgB,MAAM,iBAAiB;AAC5C,OAAK,OAAO,MAAM;AAClB,OAAK,WAAW,MAAM;AACtB,OAAK,MAAM;AACX,OAAK,OAAO;;CAGhB,MAAM,KAAK,IAAI;AACX,OAAK,MAAM;AACX,OAAK,OAAO,gBAAgB;GAAE;GAAK;GAAI,CAAC;;CAE5C,OAAO,IAAI,kBAAkB;AACzB,MAAI,CAAC,KAAK,QAAQ,CAAC,KAAK,IACpB;AACJ,iBAAe,KAAK,MAAM,KAAK,KAAK,MAAM,iBAAiB;;;;;;ACpBnE,IAAM,sBAAsB;AAC5B,SAAS,gBAAgB,OAAO;AAC5B,KAAI,MAAM,MAAM,SACZ,QAAO,2BAA2B,MAAM,MAAM;UAEzC,MAAM,MAAM,KACjB,QAAO,yBAAyB,MAAM,MAAM;AAEhD,QAAO;;;;;AAMX,SAAgB,mBAAmB,KAAK,WAAW,WAAW;AAG1D,KAAI,CAAC,OAAO,CAAC,IAAI,SAAS,CAAC,IAAI,MAAM,QACjC;CAEJ,MAAM,SAAS,QAAQ,WAAW,QAAQ;AAC1C,KAAI,cAAc,WAAW;EAEzB,MAAM,aAAa,QAAQ,WAAW,QAAQ;EAC9C,MAAM,oBAAoB,IAAI,IAAI,WAAW,KAAI,MAAK,gBAAgB,EAAE,CAAC,CAAC;EAC1E,MAAM,mBAAmB,IAAI,IAAI,OAAO,KAAI,MAAK,gBAAgB,EAAE,CAAC,CAAC;AACrE,OAAK,MAAM,WAAW,kBAClB,KAAI,CAAC,iBAAiB,IAAI,QAAQ,EAC9B;OAAI,IAAI,SAAS,QAAQ,CACrB,KAAI,YAAY,QAAQ;;;CAMxC,MAAM,cAAc,EAAE;AACtB,MAAK,MAAM,SAAS,QAAQ;EACxB,MAAM,UAAU,gBAAgB,MAAM;EACtC,MAAM,cAAc,IAAI,SAAS,QAAQ;AACzC,MAAI,YAIA,aAAY,WADU,YAAY,kBAAkB;OAGnD;GACD,MAAM,WAAW,IAAI,iBAAiB;IAClC,IAAI;IACJ,MAAM,MAAM,MAAM;IAClB,UAAU,MAAM,MAAM;IACzB,CAAC;AACF,eAAY,WAAW;AACvB,OAAI,SAAS,UAAU,MAAM,MAAM,SAAS;;;CAMpD,MAAM,YAAY,IAAI,MAAM;AAC5B,MAAK,MAAM,CAAC,SAAS,UAAU,OAAO,QAAQ,YAAY,EAAE;EACxD,MAAM,WAAW,MAAM,YAAY;EACnC,MAAM,qBAAqB,aAAa,sBAAsB,UAAU,SAAS,UAAU,QAAQ,SAAS;AAE5G,MAD2B,UAAU,QAAQ,QAAQ,KAC1B,qBAAqB,GAAG;GAC/C,MAAM,eAAe,aAAa,sBAAsB,SAAY;AACpE,OAAI,UAAU,SAAS,aAAa;;;;;;;;;;;AC1DhD,IAAqB,gBAArB,MAAmC;CAC/B,YAAY,OAAO;AACf,OAAK,2BAA2B;AAC5B,QAAK,eAAe,KAAK,MAAM,KAAK,OAAO,KAAK,OAAO,QAAQ,KAAK,OAAO,OAAO;AAClF,OAAI,CAAC,KAAK,KACN;AAGJ,OADmB,cAAc,KAAK,KAAK,IACzB,CAAC,KAAK,OAAO,MAC3B,MAAK,OAAO,SAAS,EAAE,OAAO,eAAe,KAAK,KAAK,EAAE,CAAC;;AAGlE,OAAK,6BAA6B;AAC9B,OAAI,KAAK,QAAQ,KAAK,YAAY;IAC9B,MAAM,EAAE,aAAa,iBAAiB,KAAK,KAAK,cAAc;AAC9D,WAAO,OAAO,KAAK,WAAW,OAAO;KACjC,OAAO,GAAG,YAAY;KACtB,QAAQ,GAAG,aAAa;KAC3B,CAAC;;;AAGV,OAAK,yBAAyB;GAC1B,MAAM,OAAO,KAAK;GAClB,MAAM,MAAM,KAAK;AACjB,OAAI,QAAQ,KAAK;AACb,SAAK,SAAS;KACV,OAAO,KAAK,OAAO,SAAS,eAAe,IAAI;KAC/C,WAAW,aAAa,IAAI;KAC/B,CAAC;AAEF,QAAI,KAAK,cACL,MAAK,QAAQ;;;AAKzB,OAAK,qBAAqB,UAAU;GAChC,MAAM,OAAO,KAAK;AAClB,OAAI,CAAC,QAAQ,CAAC,KAAK,cACf;GAEJ,MAAM,YAAY;IACd,MAAM,MAAM;IACZ,cAAc,MAAM;IACpB,UAAU;IACb;GACD,MAAM,WAAW,KAAK;AACtB,OAAI,CAAC,MAAM,SAAS,UAAU;AAE1B,cAAU,SAAS,MAAM,cAAc,UAAU,SAAS;AAC1D,cAAU,SAAS,MAAM,cAAc,UAAU,SAAS;AAC1D,cAAU,eAAe;KACrB,GAAG,SAAS,IAAI,UAAU;KAC1B,GAAG,SAAS,IAAI,UAAU;KAC7B;;AAEL,WAAQ,UAAU,MAAlB;IACI,KAAK;AACD,UAAK,eAAe,UAAU;AAC9B,UAAK,sBAAsB;MACvB,GAAG,MAAM;MACT,SAAS,MAAM,cAAc;MAC7B,SAAS,MAAM,cAAc;MAChC;AACD;IACJ,KAAK;AACD,eAAU,OAAO;AACjB,UAAK,SAAS,UAAU;AACxB;IACJ,KAAK;AACD,eAAU,OAAO;AACjB,UAAK,SAAS,UAAU;AACxB;IACJ,KAAK;AACD,eAAU,OAAO;AACjB,UAAK,SAAS,UAAU;AACxB;IACJ,KAAK;AACD,eAAU,WAAW;AACrB,UAAK,SAAS,UAAU;AACxB;IACJ,KAAK;AACD,eAAU,OAAO;AACjB,eAAU,WAAW;AACrB,UAAK,SAAS,UAAU;AACxB;IACJ,KAAK;AACD,eAAU,OAAO;AACjB,UAAK,eAAe,UAAU;AAC9B;IACJ,KAAK;AACD,eAAU,OAAO;AACjB,UAAK,eAAe,UAAU;AAC9B;IACJ,QACI;;;EAGZ,MAAM,EAAE,cAAc,UAAU;AAChC,OAAK,eAAe;AACpB,OAAK,wBAAwB,MAAM,yBAAyB;AAC5D,OAAK,SAAS,KAAK,YAAY,MAAM;;;CAGzC,YAAY,OAAO;EACf,MAAM,EAAE,cAAc,OAAO,iBAAiB,GAAG,cAAc;AAC/D,MAAI,CAAC,eAAe,oBAAoB,OAEpC,WAAU,kBAAkB;AAEhC,SAAO;;;CAGX,SAAS,OAAO;AACZ,MAAI,KAAK,gBAAgB,MAAM,OAC3B,MAAK,eAAe,KAAK,MAAM,KAAK,OAAO,KAAK,OAAO,QAAQ,MAAM,OAAO;AAEhF,SAAO,OAAO,KAAK,QAAQ,KAAK,YAAY,MAAM,CAAC;AACnD,MAAI,KAAK,SAAS,KAAK,KACnB,MAAK,MAAM,SAAS;GAChB,GAAG,KAAK;GACR,YAAY;IACR,GAAG,qBAAqB,KAAK,MAAM,KAAK,aAAa;IACrD,GAAG,KAAK,OAAO;IAClB;GACJ,CAAC;;;CAMV,MAAM,KAAK;AACP,OAAK,OAAO;AACZ,SAAO,KAAK,eAAe,KAAK,kBAAkB,IAAI,GAAG,KAAK,eAAe,IAAI;;CAErF,eAAe,KAAK;EAEhB,MAAM,YAAY,SAAS,cAAc,MAAM;AAC/C,SAAO,OAAO,UAAU,OAAO;GAC3B,UAAU;GACV,MAAM;GACN,KAAK;GACL,WAAW;GACX,eAAe;GAClB,CAAC;AACF,OAAK,aAAa;AAClB,OAAK,QAAQ,IAAIC,aAAK;GAClB,GAAG,KAAK;GACR,QAAQ;GACR,YAAY;IAAE,GAAG,qBAAqB,KAAK,MAAM;IAAE,GAAG,KAAK,OAAO;IAAY;GAC9E,OAAO,KAAK,OAAO,SAAS,eAAe,IAAI;GAC/C,WAAW,aAAa,IAAI;GAC/B,CAAC;AACF,MAAI,GAAG,UAAU,KAAK,qBAAqB;AAC3C,MAAI,GAAG,UAAU,KAAK,iBAAiB;AACvC,MAAI,GAAG,aAAa,KAAK,kBAAkB;AAC3C,MAAI,GAAG,aAAa,KAAK,kBAAkB;AAC3C,MAAI,GAAG,QAAQ,KAAK,kBAAkB;AACtC,MAAI,GAAG,WAAW,KAAK,kBAAkB;AACzC,MAAI,GAAG,aAAa,KAAK,kBAAkB;AAC3C,MAAI,GAAG,YAAY,KAAK,kBAAkB;AAC1C,MAAI,GAAG,SAAS,KAAK,kBAAkB;AACvC,MAAI,GAAG,YAAY,KAAK,kBAAkB;AAC1C,OAAK,sBAAsB;AAC3B,SAAO;;CAEX,kBAAkB,KAAK;EAEnB,MAAM,KAAK,IAAI,QAAQ,QAAQ;AAC/B,MAAI,cAAc,sBACd,aAAI,KAAK,sGAAsG,EAAE;AAErH,OAAK,QAAQ,gBAAgB;GACzB;GACA;GACA,MAAM,IAAIA,aAAK;IACX,GAAG,KAAK;IACR;IACA,YAAY;KAAE,GAAG,qBAAqB,KAAK,KAAK;KAAE,GAAG,KAAK,OAAO;KAAY;IAChF,CAAC;GACL,CAAC;AACF,MAAI,GAAG,aAAa,KAAK,mBAAmB;AAC5C,OAAK,eAAe,KAAK,KAAK,OAAO,EAAE,EAAE,KAAK,OAAO,OAAO;AAC5D,SAAO,SAAS,cAAc,MAAM;;CAExC,eAAe,KAAK,MAAM,YAAY,WAAW;AAC7C,MAAI,KAAK,sBACL,oBAAmB,KAAK,YAAY,UAAU;MAG9C,eAAc,KAAK,MAAM,YAAY,UAAU;;;CAIvD,WAAW;EACP,MAAM,MAAM,KAAK;AACjB,MAAI,IACA,KAAI,KAAK,aACL,MAAK,qBAAqB,IAAI;MAG9B,MAAK,kBAAkB,IAAI;AAGnC,OAAK,QAAQ;AACb,OAAK,OAAO;AACZ,OAAK,aAAa;;CAEtB,kBAAkB,KAAK;AACnB,MAAI,IAAI,UAAU,KAAK,qBAAqB;AAC5C,MAAI,IAAI,UAAU,KAAK,iBAAiB;AACxC,MAAI,IAAI,aAAa,KAAK,kBAAkB;AAC5C,MAAI,IAAI,aAAa,KAAK,kBAAkB;AAC5C,MAAI,IAAI,QAAQ,KAAK,kBAAkB;AACvC,MAAI,IAAI,WAAW,KAAK,kBAAkB;AAC1C,MAAI,IAAI,aAAa,KAAK,kBAAkB;AAC5C,MAAI,IAAI,YAAY,KAAK,kBAAkB;AAC3C,MAAI,IAAI,SAAS,KAAK,kBAAkB;AACxC,MAAI,IAAI,YAAY,KAAK,kBAAkB;AAC3C,OAAK,OAAO,UAAU;;CAE1B,qBAAqB,KAAK;AACtB,MAAI,IAAI,aAAa,KAAK,mBAAmB;AAC7C,OAAK,eAAe,KAAK,KAAK,OAAO,KAAK,OAAO,QAAQ,EAAE,CAAC;AAC5D,qBAAmB,IAAI;;CAE3B,qBAAqB;AACjB,SAAO;;;CAGX,WAAW,QAAQ;AACf,SAAO,KAAK,MAAM;AAClB,SAAO,KAAK,MAAM,WAAW,OAAO;;;CAGxC,oBAAoB,QAAQ;AACxB,SAAO,KAAK,MAAM;AAClB,SAAO,KAAK,MAAM,oBAAoB,OAAO;;;CAGjD,YAAY,QAAQ;AAChB,SAAO,KAAK,MAAM;AAClB,SAAO,KAAK,MAAM,YAAY,OAAO;;;CAGzC,WAAW;AACP,MAAI,KAAK,KACL,MAAK,KAAK,cAAc,KAAK;;;CAIrC,YAAY;AACR,MAAI,CAAC,KAAK,KACN,QAAO;AAEX,SAAO,KAAK,eAAe,KAAK,KAAK,WAAW,GAAG,KAAK,MAAM,WAAW"}