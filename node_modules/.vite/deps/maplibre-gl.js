import { t as __commonJS } from "./chunk-DrBMkljp.js";

//#region node_modules/maplibre-gl/dist/maplibre-gl.js
var require_maplibre_gl = /* @__PURE__ */ __commonJS({ "node_modules/maplibre-gl/dist/maplibre-gl.js": ((exports, module) => {
	/**
	* MapLibre GL JS
	* @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.17.0/LICENSE.txt
	*/
	(function(global, factory) {
		typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.maplibregl = factory());
	})(exports, (function() {
		var maplibregl = {};
		var modules = {};
		function define$1(moduleName, _dependencies, moduleFactory) {
			modules[moduleName] = moduleFactory;
			if (moduleName !== "index") return;
			var workerBundleString = "var sharedModule = {}; (" + modules.shared + ")(sharedModule); (" + modules.worker + ")(sharedModule);";
			var sharedModule = {};
			modules.shared(sharedModule);
			modules.index(maplibregl, sharedModule);
			if (typeof window !== "undefined") maplibregl.setWorkerUrl(window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" })));
			return maplibregl;
		}
		define$1("shared", ["exports"], (function(t) {
			function e(t$1, e$1, r$1, n$1) {
				return new (r$1 || (r$1 = Promise))((function(i$1, s$1) {
					function a(t$2) {
						try {
							l$1(n$1.next(t$2));
						} catch (t$3) {
							s$1(t$3);
						}
					}
					function o$1(t$2) {
						try {
							l$1(n$1.throw(t$2));
						} catch (t$3) {
							s$1(t$3);
						}
					}
					function l$1(t$2) {
						var e$2;
						t$2.done ? i$1(t$2.value) : (e$2 = t$2.value, e$2 instanceof r$1 ? e$2 : new r$1((function(t$3) {
							t$3(e$2);
						}))).then(a, o$1);
					}
					l$1((n$1 = n$1.apply(t$1, e$1 || [])).next());
				}));
			}
			function r(t$1, e$1) {
				this.x = t$1, this.y = e$1;
			}
			function n(t$1) {
				return t$1 && t$1.__esModule && Object.prototype.hasOwnProperty.call(t$1, "default") ? t$1.default : t$1;
			}
			var i, s;
			r.prototype = {
				clone() {
					return new r(this.x, this.y);
				},
				add(t$1) {
					return this.clone()._add(t$1);
				},
				sub(t$1) {
					return this.clone()._sub(t$1);
				},
				multByPoint(t$1) {
					return this.clone()._multByPoint(t$1);
				},
				divByPoint(t$1) {
					return this.clone()._divByPoint(t$1);
				},
				mult(t$1) {
					return this.clone()._mult(t$1);
				},
				div(t$1) {
					return this.clone()._div(t$1);
				},
				rotate(t$1) {
					return this.clone()._rotate(t$1);
				},
				rotateAround(t$1, e$1) {
					return this.clone()._rotateAround(t$1, e$1);
				},
				matMult(t$1) {
					return this.clone()._matMult(t$1);
				},
				unit() {
					return this.clone()._unit();
				},
				perp() {
					return this.clone()._perp();
				},
				round() {
					return this.clone()._round();
				},
				mag() {
					return Math.sqrt(this.x * this.x + this.y * this.y);
				},
				equals(t$1) {
					return this.x === t$1.x && this.y === t$1.y;
				},
				dist(t$1) {
					return Math.sqrt(this.distSqr(t$1));
				},
				distSqr(t$1) {
					const e$1 = t$1.x - this.x, r$1 = t$1.y - this.y;
					return e$1 * e$1 + r$1 * r$1;
				},
				angle() {
					return Math.atan2(this.y, this.x);
				},
				angleTo(t$1) {
					return Math.atan2(this.y - t$1.y, this.x - t$1.x);
				},
				angleWith(t$1) {
					return this.angleWithSep(t$1.x, t$1.y);
				},
				angleWithSep(t$1, e$1) {
					return Math.atan2(this.x * e$1 - this.y * t$1, this.x * t$1 + this.y * e$1);
				},
				_matMult(t$1) {
					const e$1 = t$1[2] * this.x + t$1[3] * this.y;
					return this.x = t$1[0] * this.x + t$1[1] * this.y, this.y = e$1, this;
				},
				_add(t$1) {
					return this.x += t$1.x, this.y += t$1.y, this;
				},
				_sub(t$1) {
					return this.x -= t$1.x, this.y -= t$1.y, this;
				},
				_mult(t$1) {
					return this.x *= t$1, this.y *= t$1, this;
				},
				_div(t$1) {
					return this.x /= t$1, this.y /= t$1, this;
				},
				_multByPoint(t$1) {
					return this.x *= t$1.x, this.y *= t$1.y, this;
				},
				_divByPoint(t$1) {
					return this.x /= t$1.x, this.y /= t$1.y, this;
				},
				_unit() {
					return this._div(this.mag()), this;
				},
				_perp() {
					const t$1 = this.y;
					return this.y = this.x, this.x = -t$1, this;
				},
				_rotate(t$1) {
					const e$1 = Math.cos(t$1), r$1 = Math.sin(t$1), n$1 = r$1 * this.x + e$1 * this.y;
					return this.x = e$1 * this.x - r$1 * this.y, this.y = n$1, this;
				},
				_rotateAround(t$1, e$1) {
					const r$1 = Math.cos(t$1), n$1 = Math.sin(t$1), i$1 = e$1.y + n$1 * (this.x - e$1.x) + r$1 * (this.y - e$1.y);
					return this.x = e$1.x + r$1 * (this.x - e$1.x) - n$1 * (this.y - e$1.y), this.y = i$1, this;
				},
				_round() {
					return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
				},
				constructor: r
			}, r.convert = function(t$1) {
				if (t$1 instanceof r) return t$1;
				if (Array.isArray(t$1)) return new r(+t$1[0], +t$1[1]);
				if (void 0 !== t$1.x && void 0 !== t$1.y) return new r(+t$1.x, +t$1.y);
				throw new Error("Expected [x, y] or {x, y} point format");
			};
			var o = n(function() {
				if (s) return i;
				function t$1(t$2, e$1, r$1, n$1) {
					this.cx = 3 * t$2, this.bx = 3 * (r$1 - t$2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e$1, this.by = 3 * (n$1 - e$1) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t$2, this.p1y = e$1, this.p2x = r$1, this.p2y = n$1;
				}
				return s = 1, i = t$1, t$1.prototype = {
					sampleCurveX: function(t$2) {
						return ((this.ax * t$2 + this.bx) * t$2 + this.cx) * t$2;
					},
					sampleCurveY: function(t$2) {
						return ((this.ay * t$2 + this.by) * t$2 + this.cy) * t$2;
					},
					sampleCurveDerivativeX: function(t$2) {
						return (3 * this.ax * t$2 + 2 * this.bx) * t$2 + this.cx;
					},
					solveCurveX: function(t$2, e$1) {
						if (void 0 === e$1 && (e$1 = 1e-6), t$2 < 0) return 0;
						if (t$2 > 1) return 1;
						for (var r$1 = t$2, n$1 = 0; n$1 < 8; n$1++) {
							var i$1 = this.sampleCurveX(r$1) - t$2;
							if (Math.abs(i$1) < e$1) return r$1;
							var s$1 = this.sampleCurveDerivativeX(r$1);
							if (Math.abs(s$1) < 1e-6) break;
							r$1 -= i$1 / s$1;
						}
						var a = 0, o$1 = 1;
						for (r$1 = t$2, n$1 = 0; n$1 < 20 && (i$1 = this.sampleCurveX(r$1), !(Math.abs(i$1 - t$2) < e$1)); n$1++) t$2 > i$1 ? a = r$1 : o$1 = r$1, r$1 = .5 * (o$1 - a) + a;
						return r$1;
					},
					solve: function(t$2, e$1) {
						return this.sampleCurveY(this.solveCurveX(t$2, e$1));
					}
				}, i;
			}());
			let l, u;
			function c() {
				return l ??= "undefined" != typeof OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof createImageBitmap, l;
			}
			function h() {
				if (null == u && (u = !1, c())) {
					const t$1 = 5, e$1 = new OffscreenCanvas(t$1, t$1).getContext("2d", { willReadFrequently: !0 });
					if (e$1) {
						for (let r$2 = 0; r$2 < t$1 * t$1; r$2++) {
							const n$1 = 4 * r$2;
							e$1.fillStyle = `rgb(${n$1},${n$1 + 1},${n$1 + 2})`, e$1.fillRect(r$2 % t$1, Math.floor(r$2 / t$1), 1, 1);
						}
						const r$1 = e$1.getImageData(0, 0, t$1, t$1).data;
						for (let e$2 = 0; e$2 < t$1 * t$1 * 4; e$2++) if (e$2 % 4 != 3 && r$1[e$2] !== e$2) {
							u = !0;
							break;
						}
					}
				}
				return u || !1;
			}
			var p = 1e-6, f = "undefined" != typeof Float32Array ? Float32Array : Array;
			function d() {
				var t$1 = new f(9);
				return f != Float32Array && (t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[5] = 0, t$1[6] = 0, t$1[7] = 0), t$1[0] = 1, t$1[4] = 1, t$1[8] = 1, t$1;
			}
			function y(t$1) {
				return t$1[0] = 1, t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[4] = 0, t$1[5] = 1, t$1[6] = 0, t$1[7] = 0, t$1[8] = 0, t$1[9] = 0, t$1[10] = 1, t$1[11] = 0, t$1[12] = 0, t$1[13] = 0, t$1[14] = 0, t$1[15] = 1, t$1;
			}
			function m() {
				var t$1 = new f(3);
				return f != Float32Array && (t$1[0] = 0, t$1[1] = 0, t$1[2] = 0), t$1;
			}
			function g(t$1) {
				var e$1 = t$1[0], r$1 = t$1[1], n$1 = t$1[2];
				return Math.sqrt(e$1 * e$1 + r$1 * r$1 + n$1 * n$1);
			}
			function x(t$1, e$1, r$1) {
				var n$1 = new f(3);
				return n$1[0] = t$1, n$1[1] = e$1, n$1[2] = r$1, n$1;
			}
			function v(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] + r$1[0], t$1[1] = e$1[1] + r$1[1], t$1[2] = e$1[2] + r$1[2], t$1;
			}
			function b(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] * r$1, t$1[1] = e$1[1] * r$1, t$1[2] = e$1[2] * r$1, t$1;
			}
			function w(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2], a = r$1[0], o$1 = r$1[1], l$1 = r$1[2];
				return t$1[0] = i$1 * l$1 - s$1 * o$1, t$1[1] = s$1 * a - n$1 * l$1, t$1[2] = n$1 * o$1 - i$1 * a, t$1;
			}
			var _, S = g;
			function A(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2], a = e$1[3];
				return t$1[0] = r$1[0] * n$1 + r$1[4] * i$1 + r$1[8] * s$1 + r$1[12] * a, t$1[1] = r$1[1] * n$1 + r$1[5] * i$1 + r$1[9] * s$1 + r$1[13] * a, t$1[2] = r$1[2] * n$1 + r$1[6] * i$1 + r$1[10] * s$1 + r$1[14] * a, t$1[3] = r$1[3] * n$1 + r$1[7] * i$1 + r$1[11] * s$1 + r$1[15] * a, t$1;
			}
			function k() {
				var t$1 = new f(4);
				return f != Float32Array && (t$1[0] = 0, t$1[1] = 0, t$1[2] = 0), t$1[3] = 1, t$1;
			}
			function E(t$1, e$1, r$1, n$1) {
				var i$1 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "zyx", s$1 = Math.PI / 360;
				e$1 *= s$1, n$1 *= s$1, r$1 *= s$1;
				var a = Math.sin(e$1), o$1 = Math.cos(e$1), l$1 = Math.sin(r$1), u$1 = Math.cos(r$1), c$1 = Math.sin(n$1), h$1 = Math.cos(n$1);
				switch (i$1) {
					case "xyz":
						t$1[0] = a * u$1 * h$1 + o$1 * l$1 * c$1, t$1[1] = o$1 * l$1 * h$1 - a * u$1 * c$1, t$1[2] = o$1 * u$1 * c$1 + a * l$1 * h$1, t$1[3] = o$1 * u$1 * h$1 - a * l$1 * c$1;
						break;
					case "xzy":
						t$1[0] = a * u$1 * h$1 - o$1 * l$1 * c$1, t$1[1] = o$1 * l$1 * h$1 - a * u$1 * c$1, t$1[2] = o$1 * u$1 * c$1 + a * l$1 * h$1, t$1[3] = o$1 * u$1 * h$1 + a * l$1 * c$1;
						break;
					case "yxz":
						t$1[0] = a * u$1 * h$1 + o$1 * l$1 * c$1, t$1[1] = o$1 * l$1 * h$1 - a * u$1 * c$1, t$1[2] = o$1 * u$1 * c$1 - a * l$1 * h$1, t$1[3] = o$1 * u$1 * h$1 + a * l$1 * c$1;
						break;
					case "yzx":
						t$1[0] = a * u$1 * h$1 + o$1 * l$1 * c$1, t$1[1] = o$1 * l$1 * h$1 + a * u$1 * c$1, t$1[2] = o$1 * u$1 * c$1 - a * l$1 * h$1, t$1[3] = o$1 * u$1 * h$1 - a * l$1 * c$1;
						break;
					case "zxy":
						t$1[0] = a * u$1 * h$1 - o$1 * l$1 * c$1, t$1[1] = o$1 * l$1 * h$1 + a * u$1 * c$1, t$1[2] = o$1 * u$1 * c$1 + a * l$1 * h$1, t$1[3] = o$1 * u$1 * h$1 - a * l$1 * c$1;
						break;
					case "zyx":
						t$1[0] = a * u$1 * h$1 - o$1 * l$1 * c$1, t$1[1] = o$1 * l$1 * h$1 + a * u$1 * c$1, t$1[2] = o$1 * u$1 * c$1 - a * l$1 * h$1, t$1[3] = o$1 * u$1 * h$1 + a * l$1 * c$1;
						break;
					default: throw new Error("Unknown angle order " + i$1);
				}
				return t$1;
			}
			function T() {
				var t$1 = new f(2);
				return f != Float32Array && (t$1[0] = 0, t$1[1] = 0), t$1;
			}
			function I(t$1, e$1) {
				var r$1 = new f(2);
				return r$1[0] = t$1, r$1[1] = e$1, r$1;
			}
			m(), _ = new f(4), f != Float32Array && (_[0] = 0, _[1] = 0, _[2] = 0, _[3] = 0), m(), x(1, 0, 0), x(0, 1, 0), k(), k(), d(), T();
			const M = 8192;
			function F(t$1, e$1, r$1) {
				return e$1 * (M / (t$1.tileSize * Math.pow(2, r$1 - t$1.tileID.overscaledZ)));
			}
			function D(t$1, e$1) {
				return (t$1 % e$1 + e$1) % e$1;
			}
			function z(t$1, e$1, r$1) {
				return t$1 * (1 - r$1) + e$1 * r$1;
			}
			function P(t$1) {
				if (t$1 <= 0) return 0;
				if (t$1 >= 1) return 1;
				const e$1 = t$1 * t$1, r$1 = e$1 * t$1;
				return 4 * (t$1 < .5 ? r$1 : 3 * (t$1 - e$1) + r$1 - .75);
			}
			function B(t$1, e$1, r$1, n$1) {
				const i$1 = new o(t$1, e$1, r$1, n$1);
				return (t$2) => i$1.solve(t$2);
			}
			const V = B(.25, .1, .25, 1);
			function C(t$1, e$1, r$1) {
				return Math.min(r$1, Math.max(e$1, t$1));
			}
			function L(t$1, e$1, r$1) {
				const n$1 = r$1 - e$1, i$1 = ((t$1 - e$1) % n$1 + n$1) % n$1 + e$1;
				return i$1 === e$1 ? r$1 : i$1;
			}
			function O(t$1, ...e$1) {
				for (const r$1 of e$1) for (const e$2 in r$1) t$1[e$2] = r$1[e$2];
				return t$1;
			}
			let R = 1;
			function N(t$1, e$1, r$1) {
				const n$1 = {};
				for (const r$2 in t$1) n$1[r$2] = e$1.call(this, t$1[r$2], r$2, t$1);
				return n$1;
			}
			function $(t$1, e$1, r$1) {
				const n$1 = {};
				for (const r$2 in t$1) e$1.call(this, t$1[r$2], r$2, t$1) && (n$1[r$2] = t$1[r$2]);
				return n$1;
			}
			function U(t$1) {
				return Array.isArray(t$1) ? t$1.map(U) : "object" == typeof t$1 && t$1 ? N(t$1, U) : t$1;
			}
			const q = {};
			function j(t$1) {
				q[t$1] || ("undefined" != typeof console && console.warn(t$1), q[t$1] = !0);
			}
			function G(t$1, e$1, r$1) {
				return (r$1.y - t$1.y) * (e$1.x - t$1.x) > (e$1.y - t$1.y) * (r$1.x - t$1.x);
			}
			function X(t$1) {
				return "undefined" != typeof WorkerGlobalScope && void 0 !== t$1 && t$1 instanceof WorkerGlobalScope;
			}
			let Y = null;
			function Z(t$1) {
				return "undefined" != typeof ImageBitmap && t$1 instanceof ImageBitmap;
			}
			const H = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
			function K(t$1, r$1, n$1, i$1, s$1) {
				return e(this, void 0, void 0, (function* () {
					if ("undefined" == typeof VideoFrame) throw new Error("VideoFrame not supported");
					const e$1 = new VideoFrame(t$1, { timestamp: 0 });
					try {
						const a = null == e$1 ? void 0 : e$1.format;
						if (!a || !a.startsWith("BGR") && !a.startsWith("RGB")) throw new Error(`Unrecognized format ${a}`);
						const o$1 = a.startsWith("BGR"), l$1 = new Uint8ClampedArray(i$1 * s$1 * 4);
						if (yield e$1.copyTo(l$1, function(t$2, e$2, r$2, n$2, i$2) {
							const s$2 = 4 * Math.max(-e$2, 0), a$1 = (Math.max(0, r$2) - r$2) * n$2 * 4 + s$2, o$2 = 4 * n$2, l$2 = Math.max(0, e$2), u$1 = Math.max(0, r$2);
							return {
								rect: {
									x: l$2,
									y: u$1,
									width: Math.min(t$2.width, e$2 + n$2) - l$2,
									height: Math.min(t$2.height, r$2 + i$2) - u$1
								},
								layout: [{
									offset: a$1,
									stride: o$2
								}]
							};
						}(t$1, r$1, n$1, i$1, s$1)), o$1) for (let t$2 = 0; t$2 < l$1.length; t$2 += 4) {
							const e$2 = l$1[t$2];
							l$1[t$2] = l$1[t$2 + 2], l$1[t$2 + 2] = e$2;
						}
						return l$1;
					} finally {
						e$1.close();
					}
				}));
			}
			let W, J;
			function Q(t$1, e$1, r$1, n$1) {
				return t$1.addEventListener(e$1, r$1, n$1), { unsubscribe: () => {
					t$1.removeEventListener(e$1, r$1, n$1);
				} };
			}
			function tt(t$1) {
				return t$1 * Math.PI / 180;
			}
			function et(t$1) {
				return t$1 / Math.PI * 180;
			}
			const rt = {
				touchstart: !0,
				touchmove: !0,
				touchmoveWindow: !0,
				touchend: !0,
				touchcancel: !0
			}, nt = {
				dblclick: !0,
				click: !0,
				mouseover: !0,
				mouseout: !0,
				mousedown: !0,
				mousemove: !0,
				mousemoveWindow: !0,
				mouseup: !0,
				mouseupWindow: !0,
				contextmenu: !0,
				wheel: !0
			}, it = "AbortError";
			class st extends Error {
				constructor(t$1 = it) {
					super(t$1 instanceof Error ? t$1.message : t$1), this.name = it, t$1 instanceof Error && t$1.stack && (this.stack = t$1.stack);
				}
			}
			function at(t$1) {
				return t$1.name === it;
			}
			const ot = {
				MAX_PARALLEL_IMAGE_REQUESTS: 16,
				MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
				MAX_TILE_CACHE_ZOOM_LEVELS: 5,
				REGISTERED_PROTOCOLS: {},
				WORKER_URL: ""
			};
			function lt(t$1) {
				return ot.REGISTERED_PROTOCOLS[t$1.substring(0, t$1.indexOf("://"))];
			}
			const ut = "global-dispatcher";
			class ct extends Error {
				constructor(t$1, e$1, r$1, n$1) {
					super(`AJAXError: ${e$1} (${t$1}): ${r$1}`), this.status = t$1, this.statusText = e$1, this.url = r$1, this.body = n$1;
				}
			}
			const ht = () => X(self) ? self.worker && self.worker.referrer : ("blob:" === window.location.protocol ? window.parent : window).location.href, pt = function(t$1, r$1) {
				if (/:\/\//.test(t$1.url) && !/^https?:|^file:/.test(t$1.url)) {
					const e$1 = lt(t$1.url);
					if (e$1) return e$1(t$1, r$1);
					if (X(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
						type: "GR",
						data: t$1,
						targetMapId: ut
					}, r$1);
				}
				if (!(/^file:/.test(n$1 = t$1.url) || /^file:/.test(ht()) && !/^\w+:/.test(n$1))) {
					if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function(t$2, r$2) {
						return e(this, void 0, void 0, (function* () {
							const e$1 = new Request(t$2.url, {
								method: t$2.method || "GET",
								body: t$2.body,
								credentials: t$2.credentials,
								headers: t$2.headers,
								cache: t$2.cache,
								referrer: ht(),
								signal: r$2.signal
							});
							let n$2, i$1;
							"json" !== t$2.type || e$1.headers.has("Accept") || e$1.headers.set("Accept", "application/json");
							try {
								n$2 = yield fetch(e$1);
							} catch (e$2) {
								if (at(e$2)) throw e$2;
								throw new ct(0, e$2.message, t$2.url, new Blob());
							}
							if (!n$2.ok) {
								const e$2 = yield n$2.blob();
								throw new ct(n$2.status, n$2.statusText, t$2.url, e$2);
							}
							i$1 = "arrayBuffer" === t$2.type || "image" === t$2.type ? n$2.arrayBuffer() : "json" === t$2.type ? n$2.json() : n$2.text();
							const s$1 = yield i$1;
							return r$2.signal.throwIfAborted(), {
								data: s$1,
								cacheControl: n$2.headers.get("Cache-Control"),
								expires: n$2.headers.get("Expires")
							};
						}));
					}(t$1, r$1);
					if (X(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
						type: "GR",
						data: t$1,
						mustQueue: !0,
						targetMapId: ut
					}, r$1);
				}
				var n$1;
				return function(t$2, e$1) {
					return new Promise(((r$2, n$2) => {
						var i$1;
						const s$1 = new XMLHttpRequest();
						s$1.open(t$2.method || "GET", t$2.url, !0), "arrayBuffer" !== t$2.type && "image" !== t$2.type || (s$1.responseType = "arraybuffer");
						for (const e$2 in t$2.headers) s$1.setRequestHeader(e$2, t$2.headers[e$2]);
						"json" === t$2.type && (s$1.responseType = "text", !(null === (i$1 = t$2.headers) || void 0 === i$1) && i$1.Accept || s$1.setRequestHeader("Accept", "application/json")), s$1.withCredentials = "include" === t$2.credentials, s$1.onerror = () => {
							n$2(new Error(s$1.statusText));
						}, s$1.onload = () => {
							if (!e$1.signal.aborted) if ((s$1.status >= 200 && s$1.status < 300 || 0 === s$1.status) && null !== s$1.response) {
								let e$2 = s$1.response;
								if ("json" === t$2.type) try {
									e$2 = JSON.parse(s$1.response);
								} catch (t$3) {
									n$2(t$3);
									return;
								}
								r$2({
									data: e$2,
									cacheControl: s$1.getResponseHeader("Cache-Control"),
									expires: s$1.getResponseHeader("Expires")
								});
							} else {
								const e$2 = new Blob([s$1.response], { type: s$1.getResponseHeader("Content-Type") });
								n$2(new ct(s$1.status, s$1.statusText, t$2.url, e$2));
							}
						}, e$1.signal.addEventListener("abort", (() => {
							s$1.abort(), n$2(new st(e$1.signal.reason));
						})), s$1.send(t$2.body);
					}));
				}(t$1, r$1);
			};
			function ft(t$1) {
				if (!t$1 || t$1.indexOf("://") <= 0 || 0 === t$1.indexOf("data:image/") || 0 === t$1.indexOf("blob:")) return !0;
				const e$1 = new URL(t$1), r$1 = window.location;
				return e$1.protocol === r$1.protocol && e$1.host === r$1.host;
			}
			function dt(t$1, e$1, r$1) {
				r$1[t$1] && -1 !== r$1[t$1].indexOf(e$1) || (r$1[t$1] = r$1[t$1] || [], r$1[t$1].push(e$1));
			}
			function yt(t$1, e$1, r$1) {
				if (r$1 && r$1[t$1]) {
					const n$1 = r$1[t$1].indexOf(e$1);
					-1 !== n$1 && r$1[t$1].splice(n$1, 1);
				}
			}
			class mt {
				constructor(t$1, e$1 = {}) {
					O(this, e$1), this.type = t$1;
				}
			}
			class gt extends mt {
				constructor(t$1, e$1 = {}) {
					super("error", O({ error: t$1 }, e$1));
				}
			}
			class xt {
				on(t$1, e$1) {
					return this._listeners = this._listeners || {}, dt(t$1, e$1, this._listeners), { unsubscribe: () => {
						this.off(t$1, e$1);
					} };
				}
				off(t$1, e$1) {
					return yt(t$1, e$1, this._listeners), yt(t$1, e$1, this._oneTimeListeners), this;
				}
				once(t$1, e$1) {
					return e$1 ? (this._oneTimeListeners = this._oneTimeListeners || {}, dt(t$1, e$1, this._oneTimeListeners), this) : new Promise(((e$2) => this.once(t$1, e$2)));
				}
				fire(t$1, e$1) {
					"string" == typeof t$1 && (t$1 = new mt(t$1, e$1 || {}));
					const r$1 = t$1.type;
					if (this.listens(r$1)) {
						t$1.target = this;
						const e$2 = this._listeners && this._listeners[r$1] ? this._listeners[r$1].slice() : [];
						for (const r$2 of e$2) r$2.call(this, t$1);
						const n$1 = this._oneTimeListeners && this._oneTimeListeners[r$1] ? this._oneTimeListeners[r$1].slice() : [];
						for (const e$3 of n$1) yt(r$1, e$3, this._oneTimeListeners), e$3.call(this, t$1);
						const i$1 = this._eventedParent;
						i$1 && (O(t$1, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i$1.fire(t$1));
					} else t$1 instanceof gt && console.error(t$1.error);
					return this;
				}
				listens(t$1) {
					return this._listeners && this._listeners[t$1] && this._listeners[t$1].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t$1] && this._oneTimeListeners[t$1].length > 0 || this._eventedParent && this._eventedParent.listens(t$1);
				}
				setEventedParent(t$1, e$1) {
					return this._eventedParent = t$1, this._eventedParentData = e$1, this;
				}
			}
			var vt = {
				$version: 8,
				$root: {
					version: {
						required: !0,
						type: "enum",
						values: [8]
					},
					name: { type: "string" },
					metadata: { type: "*" },
					center: {
						type: "array",
						value: "number",
						length: 2
					},
					centerAltitude: { type: "number" },
					zoom: { type: "number" },
					bearing: {
						type: "number",
						default: 0,
						period: 360,
						units: "degrees"
					},
					pitch: {
						type: "number",
						default: 0,
						units: "degrees"
					},
					roll: {
						type: "number",
						default: 0,
						units: "degrees"
					},
					state: {
						type: "state",
						default: {}
					},
					light: { type: "light" },
					sky: { type: "sky" },
					projection: { type: "projection" },
					terrain: { type: "terrain" },
					sources: {
						required: !0,
						type: "sources"
					},
					sprite: { type: "sprite" },
					glyphs: { type: "string" },
					"font-faces": { type: "fontFaces" },
					transition: { type: "transition" },
					layers: {
						required: !0,
						type: "array",
						value: "layer"
					}
				},
				sources: { "*": { type: "source" } },
				source: [
					"source_vector",
					"source_raster",
					"source_raster_dem",
					"source_geojson",
					"source_video",
					"source_image"
				],
				source_vector: {
					type: {
						required: !0,
						type: "enum",
						values: { vector: {} }
					},
					url: { type: "string" },
					tiles: {
						type: "array",
						value: "string"
					},
					bounds: {
						type: "array",
						value: "number",
						length: 4,
						default: [
							-180,
							-85.051129,
							180,
							85.051129
						]
					},
					scheme: {
						type: "enum",
						values: {
							xyz: {},
							tms: {}
						},
						default: "xyz"
					},
					minzoom: {
						type: "number",
						default: 0
					},
					maxzoom: {
						type: "number",
						default: 22
					},
					attribution: { type: "string" },
					promoteId: { type: "promoteId" },
					volatile: {
						type: "boolean",
						default: !1
					},
					encoding: {
						type: "enum",
						values: {
							mvt: {},
							mlt: {}
						},
						default: "mvt"
					},
					"*": { type: "*" }
				},
				source_raster: {
					type: {
						required: !0,
						type: "enum",
						values: { raster: {} }
					},
					url: { type: "string" },
					tiles: {
						type: "array",
						value: "string"
					},
					bounds: {
						type: "array",
						value: "number",
						length: 4,
						default: [
							-180,
							-85.051129,
							180,
							85.051129
						]
					},
					minzoom: {
						type: "number",
						default: 0
					},
					maxzoom: {
						type: "number",
						default: 22
					},
					tileSize: {
						type: "number",
						default: 512,
						units: "pixels"
					},
					scheme: {
						type: "enum",
						values: {
							xyz: {},
							tms: {}
						},
						default: "xyz"
					},
					attribution: { type: "string" },
					volatile: {
						type: "boolean",
						default: !1
					},
					"*": { type: "*" }
				},
				source_raster_dem: {
					type: {
						required: !0,
						type: "enum",
						values: { "raster-dem": {} }
					},
					url: { type: "string" },
					tiles: {
						type: "array",
						value: "string"
					},
					bounds: {
						type: "array",
						value: "number",
						length: 4,
						default: [
							-180,
							-85.051129,
							180,
							85.051129
						]
					},
					minzoom: {
						type: "number",
						default: 0
					},
					maxzoom: {
						type: "number",
						default: 22
					},
					tileSize: {
						type: "number",
						default: 512,
						units: "pixels"
					},
					attribution: { type: "string" },
					encoding: {
						type: "enum",
						values: {
							terrarium: {},
							mapbox: {},
							custom: {}
						},
						default: "mapbox"
					},
					redFactor: {
						type: "number",
						default: 1
					},
					blueFactor: {
						type: "number",
						default: 1
					},
					greenFactor: {
						type: "number",
						default: 1
					},
					baseShift: {
						type: "number",
						default: 0
					},
					volatile: {
						type: "boolean",
						default: !1
					},
					"*": { type: "*" }
				},
				source_geojson: {
					type: {
						required: !0,
						type: "enum",
						values: { geojson: {} }
					},
					data: {
						required: !0,
						type: "*"
					},
					maxzoom: {
						type: "number",
						default: 18
					},
					attribution: { type: "string" },
					buffer: {
						type: "number",
						default: 128,
						maximum: 512,
						minimum: 0
					},
					filter: { type: "filter" },
					tolerance: {
						type: "number",
						default: .375
					},
					cluster: {
						type: "boolean",
						default: !1
					},
					clusterRadius: {
						type: "number",
						default: 50,
						minimum: 0
					},
					clusterMaxZoom: { type: "number" },
					clusterMinPoints: { type: "number" },
					clusterProperties: { type: "*" },
					lineMetrics: {
						type: "boolean",
						default: !1
					},
					generateId: {
						type: "boolean",
						default: !1
					},
					promoteId: { type: "promoteId" }
				},
				source_video: {
					type: {
						required: !0,
						type: "enum",
						values: { video: {} }
					},
					urls: {
						required: !0,
						type: "array",
						value: "string"
					},
					coordinates: {
						required: !0,
						type: "array",
						length: 4,
						value: {
							type: "array",
							length: 2,
							value: "number"
						}
					}
				},
				source_image: {
					type: {
						required: !0,
						type: "enum",
						values: { image: {} }
					},
					url: {
						required: !0,
						type: "string"
					},
					coordinates: {
						required: !0,
						type: "array",
						length: 4,
						value: {
							type: "array",
							length: 2,
							value: "number"
						}
					}
				},
				layer: {
					id: {
						type: "string",
						required: !0
					},
					type: {
						type: "enum",
						values: {
							fill: {},
							line: {},
							symbol: {},
							circle: {},
							heatmap: {},
							"fill-extrusion": {},
							raster: {},
							hillshade: {},
							"color-relief": {},
							background: {}
						},
						required: !0
					},
					metadata: { type: "*" },
					source: { type: "string" },
					"source-layer": { type: "string" },
					minzoom: {
						type: "number",
						minimum: 0,
						maximum: 24
					},
					maxzoom: {
						type: "number",
						minimum: 0,
						maximum: 24
					},
					filter: { type: "filter" },
					layout: { type: "layout" },
					paint: { type: "paint" }
				},
				layout: [
					"layout_fill",
					"layout_line",
					"layout_circle",
					"layout_heatmap",
					"layout_fill-extrusion",
					"layout_symbol",
					"layout_raster",
					"layout_hillshade",
					"layout_color-relief",
					"layout_background"
				],
				layout_background: { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					expression: {
						interpolated: !1,
						parameters: ["global-state"]
					},
					"property-type": "data-constant"
				} },
				layout_fill: {
					"fill-sort-key": {
						type: "number",
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					visibility: {
						type: "enum",
						values: {
							visible: {},
							none: {}
						},
						default: "visible",
						expression: {
							interpolated: !1,
							parameters: ["global-state"]
						},
						"property-type": "data-constant"
					}
				},
				layout_circle: {
					"circle-sort-key": {
						type: "number",
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					visibility: {
						type: "enum",
						values: {
							visible: {},
							none: {}
						},
						default: "visible",
						expression: {
							interpolated: !1,
							parameters: ["global-state"]
						},
						"property-type": "data-constant"
					}
				},
				layout_heatmap: { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					expression: {
						interpolated: !1,
						parameters: ["global-state"]
					},
					"property-type": "data-constant"
				} },
				"layout_fill-extrusion": { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					expression: {
						interpolated: !1,
						parameters: ["global-state"]
					},
					"property-type": "data-constant"
				} },
				layout_line: {
					"line-cap": {
						type: "enum",
						values: {
							butt: {},
							round: {},
							square: {}
						},
						default: "butt",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"line-join": {
						type: "enum",
						values: {
							bevel: {},
							round: {},
							miter: {}
						},
						default: "miter",
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"line-miter-limit": {
						type: "number",
						default: 2,
						requires: [{ "line-join": "miter" }],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"line-round-limit": {
						type: "number",
						default: 1.05,
						requires: [{ "line-join": "round" }],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"line-sort-key": {
						type: "number",
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					visibility: {
						type: "enum",
						values: {
							visible: {},
							none: {}
						},
						default: "visible",
						expression: {
							interpolated: !1,
							parameters: ["global-state"]
						},
						"property-type": "data-constant"
					}
				},
				layout_symbol: {
					"symbol-placement": {
						type: "enum",
						values: {
							point: {},
							line: {},
							"line-center": {}
						},
						default: "point",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"symbol-spacing": {
						type: "number",
						default: 250,
						minimum: 1,
						units: "pixels",
						requires: [{ "symbol-placement": "line" }],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"symbol-avoid-edges": {
						type: "boolean",
						default: !1,
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"symbol-sort-key": {
						type: "number",
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"symbol-z-order": {
						type: "enum",
						values: {
							auto: {},
							"viewport-y": {},
							source: {}
						},
						default: "auto",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-allow-overlap": {
						type: "boolean",
						default: !1,
						requires: ["icon-image", { "!": "icon-overlap" }],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-overlap": {
						type: "enum",
						values: {
							never: {},
							always: {},
							cooperative: {}
						},
						requires: ["icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-ignore-placement": {
						type: "boolean",
						default: !1,
						requires: ["icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-optional": {
						type: "boolean",
						default: !1,
						requires: ["icon-image", "text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-rotation-alignment": {
						type: "enum",
						values: {
							map: {},
							viewport: {},
							auto: {}
						},
						default: "auto",
						requires: ["icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-size": {
						type: "number",
						default: 1,
						minimum: 0,
						units: "factor of the original icon size",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-text-fit": {
						type: "enum",
						values: {
							none: {},
							width: {},
							height: {},
							both: {}
						},
						default: "none",
						requires: ["icon-image", "text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-text-fit-padding": {
						type: "array",
						value: "number",
						length: 4,
						default: [
							0,
							0,
							0,
							0
						],
						units: "pixels",
						requires: [
							"icon-image",
							"text-field",
							{ "icon-text-fit": [
								"both",
								"width",
								"height"
							] }
						],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-image": {
						type: "resolvedImage",
						tokens: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-rotate": {
						type: "number",
						default: 0,
						period: 360,
						units: "degrees",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-padding": {
						type: "padding",
						default: [2],
						units: "pixels",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-keep-upright": {
						type: "boolean",
						default: !1,
						requires: [
							"icon-image",
							{ "icon-rotation-alignment": "map" },
							{ "symbol-placement": ["line", "line-center"] }
						],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-offset": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-anchor": {
						type: "enum",
						values: {
							center: {},
							left: {},
							right: {},
							top: {},
							bottom: {},
							"top-left": {},
							"top-right": {},
							"bottom-left": {},
							"bottom-right": {}
						},
						default: "center",
						requires: ["icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-pitch-alignment": {
						type: "enum",
						values: {
							map: {},
							viewport: {},
							auto: {}
						},
						default: "auto",
						requires: ["icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-pitch-alignment": {
						type: "enum",
						values: {
							map: {},
							viewport: {},
							auto: {}
						},
						default: "auto",
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-rotation-alignment": {
						type: "enum",
						values: {
							map: {},
							viewport: {},
							"viewport-glyph": {},
							auto: {}
						},
						default: "auto",
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-field": {
						type: "formatted",
						default: "",
						tokens: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-font": {
						type: "array",
						value: "string",
						default: ["Open Sans Regular", "Arial Unicode MS Regular"],
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-size": {
						type: "number",
						default: 16,
						minimum: 0,
						units: "pixels",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-max-width": {
						type: "number",
						default: 10,
						minimum: 0,
						units: "ems",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-line-height": {
						type: "number",
						default: 1.2,
						units: "ems",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-letter-spacing": {
						type: "number",
						default: 0,
						units: "ems",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-justify": {
						type: "enum",
						values: {
							auto: {},
							left: {},
							center: {},
							right: {}
						},
						default: "center",
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-radial-offset": {
						type: "number",
						units: "ems",
						default: 0,
						requires: ["text-field"],
						"property-type": "data-driven",
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						}
					},
					"text-variable-anchor": {
						type: "array",
						value: "enum",
						values: {
							center: {},
							left: {},
							right: {},
							top: {},
							bottom: {},
							"top-left": {},
							"top-right": {},
							"bottom-left": {},
							"bottom-right": {}
						},
						requires: ["text-field", { "symbol-placement": ["point"] }],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-variable-anchor-offset": {
						type: "variableAnchorOffsetCollection",
						requires: ["text-field", { "symbol-placement": ["point"] }],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-anchor": {
						type: "enum",
						values: {
							center: {},
							left: {},
							right: {},
							top: {},
							bottom: {},
							"top-left": {},
							"top-right": {},
							"bottom-left": {},
							"bottom-right": {}
						},
						default: "center",
						requires: ["text-field", { "!": "text-variable-anchor" }],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-max-angle": {
						type: "number",
						default: 45,
						units: "degrees",
						requires: ["text-field", { "symbol-placement": ["line", "line-center"] }],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-writing-mode": {
						type: "array",
						value: "enum",
						values: {
							horizontal: {},
							vertical: {}
						},
						requires: ["text-field", { "symbol-placement": ["point"] }],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-rotate": {
						type: "number",
						default: 0,
						period: 360,
						units: "degrees",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-padding": {
						type: "number",
						default: 2,
						minimum: 0,
						units: "pixels",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-keep-upright": {
						type: "boolean",
						default: !0,
						requires: [
							"text-field",
							{ "text-rotation-alignment": "map" },
							{ "symbol-placement": ["line", "line-center"] }
						],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-transform": {
						type: "enum",
						values: {
							none: {},
							uppercase: {},
							lowercase: {}
						},
						default: "none",
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-offset": {
						type: "array",
						value: "number",
						units: "ems",
						length: 2,
						default: [0, 0],
						requires: ["text-field", { "!": "text-radial-offset" }],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-allow-overlap": {
						type: "boolean",
						default: !1,
						requires: ["text-field", { "!": "text-overlap" }],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-overlap": {
						type: "enum",
						values: {
							never: {},
							always: {},
							cooperative: {}
						},
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-ignore-placement": {
						type: "boolean",
						default: !1,
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-optional": {
						type: "boolean",
						default: !1,
						requires: ["text-field", "icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					visibility: {
						type: "enum",
						values: {
							visible: {},
							none: {}
						},
						default: "visible",
						expression: {
							interpolated: !1,
							parameters: ["global-state"]
						},
						"property-type": "data-constant"
					}
				},
				layout_raster: { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					expression: {
						interpolated: !1,
						parameters: ["global-state"]
					},
					"property-type": "data-constant"
				} },
				layout_hillshade: { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					expression: {
						interpolated: !1,
						parameters: ["global-state"]
					},
					"property-type": "data-constant"
				} },
				"layout_color-relief": { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					expression: {
						interpolated: !1,
						parameters: ["global-state"]
					},
					"property-type": "data-constant"
				} },
				filter: {
					type: "boolean",
					expression: {
						interpolated: !1,
						parameters: ["zoom", "feature"]
					},
					"property-type": "data-driven"
				},
				filter_operator: {
					type: "enum",
					values: {
						"==": {},
						"!=": {},
						">": {},
						">=": {},
						"<": {},
						"<=": {},
						in: {},
						"!in": {},
						all: {},
						any: {},
						none: {},
						has: {},
						"!has": {}
					}
				},
				geometry_type: {
					type: "enum",
					values: {
						Point: {},
						LineString: {},
						Polygon: {}
					}
				},
				function: {
					expression: { type: "expression" },
					stops: {
						type: "array",
						value: "function_stop"
					},
					base: {
						type: "number",
						default: 1,
						minimum: 0
					},
					property: {
						type: "string",
						default: "$zoom"
					},
					type: {
						type: "enum",
						values: {
							identity: {},
							exponential: {},
							interval: {},
							categorical: {}
						},
						default: "exponential"
					},
					colorSpace: {
						type: "enum",
						values: {
							rgb: {},
							lab: {},
							hcl: {}
						},
						default: "rgb"
					},
					default: {
						type: "*",
						required: !1
					}
				},
				function_stop: {
					type: "array",
					minimum: 0,
					maximum: 24,
					value: ["number", "color"],
					length: 2
				},
				expression: {
					type: "array",
					value: "expression_name",
					minimum: 1
				},
				light: {
					anchor: {
						type: "enum",
						default: "viewport",
						values: {
							map: {},
							viewport: {}
						},
						"property-type": "data-constant",
						transition: !1,
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						}
					},
					position: {
						type: "array",
						default: [
							1.15,
							210,
							30
						],
						length: 3,
						value: "number",
						"property-type": "data-constant",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						}
					},
					color: {
						type: "color",
						"property-type": "data-constant",
						default: "#ffffff",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					intensity: {
						type: "number",
						"property-type": "data-constant",
						default: .5,
						minimum: 0,
						maximum: 1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					}
				},
				sky: {
					"sky-color": {
						type: "color",
						"property-type": "data-constant",
						default: "#88C6FC",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"horizon-color": {
						type: "color",
						"property-type": "data-constant",
						default: "#ffffff",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"fog-color": {
						type: "color",
						"property-type": "data-constant",
						default: "#ffffff",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"fog-ground-blend": {
						type: "number",
						"property-type": "data-constant",
						default: .5,
						minimum: 0,
						maximum: 1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"horizon-fog-blend": {
						type: "number",
						"property-type": "data-constant",
						default: .8,
						minimum: 0,
						maximum: 1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"sky-horizon-blend": {
						type: "number",
						"property-type": "data-constant",
						default: .8,
						minimum: 0,
						maximum: 1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"atmosphere-blend": {
						type: "number",
						"property-type": "data-constant",
						default: .8,
						minimum: 0,
						maximum: 1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					}
				},
				terrain: {
					source: {
						type: "string",
						required: !0
					},
					exaggeration: {
						type: "number",
						minimum: 0,
						default: 1
					}
				},
				projection: { type: {
					type: "projectionDefinition",
					default: "mercator",
					"property-type": "data-constant",
					transition: !1,
					expression: {
						interpolated: !0,
						parameters: ["zoom"]
					}
				} },
				paint: [
					"paint_fill",
					"paint_line",
					"paint_circle",
					"paint_heatmap",
					"paint_fill-extrusion",
					"paint_symbol",
					"paint_raster",
					"paint_hillshade",
					"paint_color-relief",
					"paint_background"
				],
				paint_fill: {
					"fill-antialias": {
						type: "boolean",
						default: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						requires: [{ "!": "fill-pattern" }],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-outline-color": {
						type: "color",
						transition: !0,
						requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["fill-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-pattern": {
						type: "resolvedImage",
						transition: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "cross-faded-data-driven"
					}
				},
				"paint_fill-extrusion": {
					"fill-extrusion-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-extrusion-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						requires: [{ "!": "fill-extrusion-pattern" }],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-extrusion-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-extrusion-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["fill-extrusion-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-extrusion-pattern": {
						type: "resolvedImage",
						transition: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "cross-faded-data-driven"
					},
					"fill-extrusion-height": {
						type: "number",
						default: 0,
						minimum: 0,
						units: "meters",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-extrusion-base": {
						type: "number",
						default: 0,
						minimum: 0,
						units: "meters",
						transition: !0,
						requires: ["fill-extrusion-height"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-extrusion-vertical-gradient": {
						type: "boolean",
						default: !0,
						transition: !1,
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				paint_line: {
					"line-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						requires: [{ "!": "line-pattern" }],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"line-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["line-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"line-width": {
						type: "number",
						default: 1,
						minimum: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-gap-width": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-offset": {
						type: "number",
						default: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-blur": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-dasharray": {
						type: "array",
						value: "number",
						minimum: 0,
						transition: !0,
						units: "line widths",
						requires: [{ "!": "line-pattern" }],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "cross-faded-data-driven"
					},
					"line-pattern": {
						type: "resolvedImage",
						transition: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "cross-faded-data-driven"
					},
					"line-gradient": {
						type: "color",
						transition: !1,
						requires: [
							{ "!": "line-dasharray" },
							{ "!": "line-pattern" },
							{
								source: "geojson",
								has: { lineMetrics: !0 }
							}
						],
						expression: {
							interpolated: !0,
							parameters: ["line-progress"]
						},
						"property-type": "color-ramp"
					}
				},
				paint_circle: {
					"circle-radius": {
						type: "number",
						default: 5,
						minimum: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-blur": {
						type: "number",
						default: 0,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"circle-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["circle-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"circle-pitch-scale": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"circle-pitch-alignment": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "viewport",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"circle-stroke-width": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-stroke-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-stroke-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					}
				},
				paint_heatmap: {
					"heatmap-radius": {
						type: "number",
						default: 30,
						minimum: 1,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"heatmap-weight": {
						type: "number",
						default: 1,
						minimum: 0,
						transition: !1,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"heatmap-intensity": {
						type: "number",
						default: 1,
						minimum: 0,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"heatmap-color": {
						type: "color",
						default: [
							"interpolate",
							["linear"],
							["heatmap-density"],
							0,
							"rgba(0, 0, 255, 0)",
							.1,
							"royalblue",
							.3,
							"cyan",
							.5,
							"lime",
							.7,
							"yellow",
							1,
							"red"
						],
						transition: !1,
						expression: {
							interpolated: !0,
							parameters: ["heatmap-density"]
						},
						"property-type": "color-ramp"
					},
					"heatmap-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				paint_symbol: {
					"icon-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"icon-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"icon-halo-color": {
						type: "color",
						default: "rgba(0, 0, 0, 0)",
						transition: !0,
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"icon-halo-width": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"icon-halo-blur": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"icon-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["icon-image", "icon-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"text-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						overridable: !0,
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"text-halo-color": {
						type: "color",
						default: "rgba(0, 0, 0, 0)",
						transition: !0,
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"text-halo-width": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"text-halo-blur": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"text-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["text-field", "text-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				paint_raster: {
					"raster-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-hue-rotate": {
						type: "number",
						default: 0,
						period: 360,
						transition: !0,
						units: "degrees",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-brightness-min": {
						type: "number",
						default: 0,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-brightness-max": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-saturation": {
						type: "number",
						default: 0,
						minimum: -1,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-contrast": {
						type: "number",
						default: 0,
						minimum: -1,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-resampling": {
						type: "enum",
						values: {
							linear: {},
							nearest: {}
						},
						default: "linear",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-fade-duration": {
						type: "number",
						default: 300,
						minimum: 0,
						transition: !1,
						units: "milliseconds",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				paint_hillshade: {
					"hillshade-illumination-direction": {
						type: "numberArray",
						default: 335,
						minimum: 0,
						maximum: 359,
						transition: !1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-illumination-altitude": {
						type: "numberArray",
						default: 45,
						minimum: 0,
						maximum: 90,
						transition: !1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-illumination-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "viewport",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-exaggeration": {
						type: "number",
						default: .5,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-shadow-color": {
						type: "colorArray",
						default: "#000000",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-highlight-color": {
						type: "colorArray",
						default: "#FFFFFF",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-accent-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-method": {
						type: "enum",
						values: {
							standard: {},
							basic: {},
							combined: {},
							igor: {},
							multidirectional: {}
						},
						default: "standard",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				"paint_color-relief": {
					"color-relief-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"color-relief-color": {
						type: "color",
						transition: !1,
						expression: {
							interpolated: !0,
							parameters: ["elevation"]
						},
						"property-type": "color-ramp"
					}
				},
				paint_background: {
					"background-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						requires: [{ "!": "background-pattern" }],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"background-pattern": {
						type: "resolvedImage",
						transition: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "cross-faded"
					},
					"background-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				transition: {
					duration: {
						type: "number",
						default: 300,
						minimum: 0,
						units: "milliseconds"
					},
					delay: {
						type: "number",
						default: 0,
						minimum: 0,
						units: "milliseconds"
					}
				},
				"property-type": {
					"data-driven": { type: "property-type" },
					"cross-faded": { type: "property-type" },
					"cross-faded-data-driven": { type: "property-type" },
					"color-ramp": { type: "property-type" },
					"data-constant": { type: "property-type" },
					constant: { type: "property-type" }
				},
				promoteId: { "*": { type: "string" } },
				interpolation: {
					type: "array",
					value: "interpolation_name",
					minimum: 1
				},
				interpolation_name: {
					type: "enum",
					values: {
						linear: { syntax: {
							overloads: [{
								parameters: [],
								"output-type": "interpolation"
							}],
							parameters: []
						} },
						exponential: { syntax: {
							overloads: [{
								parameters: ["base"],
								"output-type": "interpolation"
							}],
							parameters: [{
								name: "base",
								type: "number literal"
							}]
						} },
						"cubic-bezier": { syntax: {
							overloads: [{
								parameters: [
									"x1",
									"y1",
									"x2",
									"y2"
								],
								"output-type": "interpolation"
							}],
							parameters: [
								{
									name: "x1",
									type: "number literal"
								},
								{
									name: "y1",
									type: "number literal"
								},
								{
									name: "x2",
									type: "number literal"
								},
								{
									name: "y2",
									type: "number literal"
								}
							]
						} }
					}
				}
			};
			const bt = [
				"type",
				"source",
				"source-layer",
				"minzoom",
				"maxzoom",
				"filter",
				"layout"
			];
			function wt(t$1, e$1) {
				const r$1 = {};
				for (const e$2 in t$1) "ref" !== e$2 && (r$1[e$2] = t$1[e$2]);
				return bt.forEach(((t$2) => {
					t$2 in e$1 && (r$1[t$2] = e$1[t$2]);
				})), r$1;
			}
			function _t(t$1, e$1) {
				if (Array.isArray(t$1)) {
					if (!Array.isArray(e$1) || t$1.length !== e$1.length) return !1;
					for (let r$1 = 0; r$1 < t$1.length; r$1++) if (!_t(t$1[r$1], e$1[r$1])) return !1;
					return !0;
				}
				if ("object" == typeof t$1 && null !== t$1 && null !== e$1) {
					if ("object" != typeof e$1) return !1;
					if (Object.keys(t$1).length !== Object.keys(e$1).length) return !1;
					for (const r$1 in t$1) if (!_t(t$1[r$1], e$1[r$1])) return !1;
					return !0;
				}
				return t$1 === e$1;
			}
			function St(t$1, e$1) {
				t$1.push(e$1);
			}
			function At(t$1, e$1, r$1) {
				St(r$1, {
					command: "addSource",
					args: [t$1, e$1[t$1]]
				});
			}
			function kt(t$1, e$1, r$1) {
				St(e$1, {
					command: "removeSource",
					args: [t$1]
				}), r$1[t$1] = !0;
			}
			function Et(t$1, e$1, r$1, n$1) {
				kt(t$1, r$1, n$1), At(t$1, e$1, r$1);
			}
			function Tt(t$1, e$1, r$1) {
				let n$1;
				for (n$1 in t$1[r$1]) if (Object.prototype.hasOwnProperty.call(t$1[r$1], n$1) && "data" !== n$1 && !_t(t$1[r$1][n$1], e$1[r$1][n$1])) return !1;
				for (n$1 in e$1[r$1]) if (Object.prototype.hasOwnProperty.call(e$1[r$1], n$1) && "data" !== n$1 && !_t(t$1[r$1][n$1], e$1[r$1][n$1])) return !1;
				return !0;
			}
			function It(t$1, e$1, r$1, n$1, i$1, s$1) {
				t$1 = t$1 || {}, e$1 = e$1 || {};
				for (const a in t$1) Object.prototype.hasOwnProperty.call(t$1, a) && (_t(t$1[a], e$1[a]) || r$1.push({
					command: s$1,
					args: [
						n$1,
						a,
						e$1[a],
						i$1
					]
				}));
				for (const a in e$1) Object.prototype.hasOwnProperty.call(e$1, a) && !Object.prototype.hasOwnProperty.call(t$1, a) && (_t(t$1[a], e$1[a]) || r$1.push({
					command: s$1,
					args: [
						n$1,
						a,
						e$1[a],
						i$1
					]
				}));
			}
			function Mt(t$1) {
				return t$1.id;
			}
			function Ft(t$1, e$1) {
				return t$1[e$1.id] = e$1, t$1;
			}
			class Dt {
				constructor(t$1, e$1, r$1, n$1) {
					this.message = (t$1 ? `${t$1}: ` : "") + r$1, n$1 && (this.identifier = n$1), null != e$1 && e$1.__line__ && (this.line = e$1.__line__);
				}
			}
			function zt(t$1, ...e$1) {
				for (const r$1 of e$1) for (const e$2 in r$1) t$1[e$2] = r$1[e$2];
				return t$1;
			}
			class Pt extends Error {
				constructor(t$1, e$1) {
					super(e$1), this.message = e$1, this.key = t$1;
				}
			}
			class Bt {
				constructor(t$1, e$1 = []) {
					this.parent = t$1, this.bindings = {};
					for (const [t$2, r$1] of e$1) this.bindings[t$2] = r$1;
				}
				concat(t$1) {
					return new Bt(this, t$1);
				}
				get(t$1) {
					if (this.bindings[t$1]) return this.bindings[t$1];
					if (this.parent) return this.parent.get(t$1);
					throw new Error(`${t$1} not found in scope.`);
				}
				has(t$1) {
					return !!this.bindings[t$1] || !!this.parent && this.parent.has(t$1);
				}
			}
			const Vt = { kind: "null" }, Ct = { kind: "number" }, Lt = { kind: "string" }, Ot = { kind: "boolean" }, Rt = { kind: "color" }, Nt = { kind: "projectionDefinition" }, $t = { kind: "object" }, Ut = { kind: "value" }, qt = { kind: "collator" }, jt = { kind: "formatted" }, Gt = { kind: "padding" }, Xt = { kind: "colorArray" }, Yt = { kind: "numberArray" }, Zt = { kind: "resolvedImage" }, Ht = { kind: "variableAnchorOffsetCollection" };
			function Kt(t$1, e$1) {
				return {
					kind: "array",
					itemType: t$1,
					N: e$1
				};
			}
			function Wt(t$1) {
				if ("array" === t$1.kind) {
					const e$1 = Wt(t$1.itemType);
					return "number" == typeof t$1.N ? `array<${e$1}, ${t$1.N}>` : "value" === t$1.itemType.kind ? "array" : `array<${e$1}>`;
				}
				return t$1.kind;
			}
			const Jt = [
				Vt,
				Ct,
				Lt,
				Ot,
				Rt,
				Nt,
				jt,
				$t,
				Kt(Ut),
				Gt,
				Yt,
				Xt,
				Zt,
				Ht
			];
			function Qt(t$1, e$1) {
				if ("error" === e$1.kind) return null;
				if ("array" === t$1.kind) {
					if ("array" === e$1.kind && (0 === e$1.N && "value" === e$1.itemType.kind || !Qt(t$1.itemType, e$1.itemType)) && ("number" != typeof t$1.N || t$1.N === e$1.N)) return null;
				} else {
					if (t$1.kind === e$1.kind) return null;
					if ("value" === t$1.kind) {
						for (const t$2 of Jt) if (!Qt(t$2, e$1)) return null;
					}
				}
				return `Expected ${Wt(t$1)} but found ${Wt(e$1)} instead.`;
			}
			function te(t$1, e$1) {
				return e$1.some(((e$2) => e$2.kind === t$1.kind));
			}
			function ee(t$1, e$1) {
				return e$1.some(((e$2) => "null" === e$2 ? null === t$1 : "array" === e$2 ? Array.isArray(t$1) : "object" === e$2 ? t$1 && !Array.isArray(t$1) && "object" == typeof t$1 : e$2 === typeof t$1));
			}
			function re(t$1, e$1) {
				return "array" === t$1.kind && "array" === e$1.kind ? t$1.itemType.kind === e$1.itemType.kind && "number" == typeof t$1.N : t$1.kind === e$1.kind;
			}
			const ne = .96422, ie = .82521, se = 4 / 29, ae = 6 / 29, oe = 3 * ae * ae, le = ae * ae * ae, ue = Math.PI / 180, ce = 180 / Math.PI;
			function he(t$1) {
				return (t$1 %= 360) < 0 && (t$1 += 360), t$1;
			}
			function pe([t$1, e$1, r$1, n$1]) {
				let i$1, s$1;
				const a = de((.2225045 * (t$1 = fe(t$1)) + .7168786 * (e$1 = fe(e$1)) + .0606169 * (r$1 = fe(r$1))) / 1);
				t$1 === e$1 && e$1 === r$1 ? i$1 = s$1 = a : (i$1 = de((.4360747 * t$1 + .3850649 * e$1 + .1430804 * r$1) / ne), s$1 = de((.0139322 * t$1 + .0971045 * e$1 + .7141733 * r$1) / ie));
				const o$1 = 116 * a - 16;
				return [
					o$1 < 0 ? 0 : o$1,
					500 * (i$1 - a),
					200 * (a - s$1),
					n$1
				];
			}
			function fe(t$1) {
				return t$1 <= .04045 ? t$1 / 12.92 : Math.pow((t$1 + .055) / 1.055, 2.4);
			}
			function de(t$1) {
				return t$1 > le ? Math.pow(t$1, 1 / 3) : t$1 / oe + se;
			}
			function ye([t$1, e$1, r$1, n$1]) {
				let i$1 = (t$1 + 16) / 116, s$1 = isNaN(e$1) ? i$1 : i$1 + e$1 / 500, a = isNaN(r$1) ? i$1 : i$1 - r$1 / 200;
				return i$1 = 1 * ge(i$1), s$1 = ne * ge(s$1), a = ie * ge(a), [
					me(3.1338561 * s$1 - 1.6168667 * i$1 - .4906146 * a),
					me(-.9787684 * s$1 + 1.9161415 * i$1 + .033454 * a),
					me(.0719453 * s$1 - .2289914 * i$1 + 1.4052427 * a),
					n$1
				];
			}
			function me(t$1) {
				return (t$1 = t$1 <= .00304 ? 12.92 * t$1 : 1.055 * Math.pow(t$1, 1 / 2.4) - .055) < 0 ? 0 : t$1 > 1 ? 1 : t$1;
			}
			function ge(t$1) {
				return t$1 > ae ? t$1 * t$1 * t$1 : oe * (t$1 - se);
			}
			const xe = Object.hasOwn || function(t$1, e$1) {
				return Object.prototype.hasOwnProperty.call(t$1, e$1);
			};
			function ve(t$1, e$1) {
				return xe(t$1, e$1) ? t$1[e$1] : void 0;
			}
			function be(t$1) {
				return parseInt(t$1.padEnd(2, t$1), 16) / 255;
			}
			function we(t$1, e$1) {
				return _e(e$1 ? t$1 / 100 : t$1, 0, 1);
			}
			function _e(t$1, e$1, r$1) {
				return Math.min(Math.max(e$1, t$1), r$1);
			}
			function Se(t$1) {
				return !t$1.some(Number.isNaN);
			}
			const Ae = {
				aliceblue: [
					240,
					248,
					255
				],
				antiquewhite: [
					250,
					235,
					215
				],
				aqua: [
					0,
					255,
					255
				],
				aquamarine: [
					127,
					255,
					212
				],
				azure: [
					240,
					255,
					255
				],
				beige: [
					245,
					245,
					220
				],
				bisque: [
					255,
					228,
					196
				],
				black: [
					0,
					0,
					0
				],
				blanchedalmond: [
					255,
					235,
					205
				],
				blue: [
					0,
					0,
					255
				],
				blueviolet: [
					138,
					43,
					226
				],
				brown: [
					165,
					42,
					42
				],
				burlywood: [
					222,
					184,
					135
				],
				cadetblue: [
					95,
					158,
					160
				],
				chartreuse: [
					127,
					255,
					0
				],
				chocolate: [
					210,
					105,
					30
				],
				coral: [
					255,
					127,
					80
				],
				cornflowerblue: [
					100,
					149,
					237
				],
				cornsilk: [
					255,
					248,
					220
				],
				crimson: [
					220,
					20,
					60
				],
				cyan: [
					0,
					255,
					255
				],
				darkblue: [
					0,
					0,
					139
				],
				darkcyan: [
					0,
					139,
					139
				],
				darkgoldenrod: [
					184,
					134,
					11
				],
				darkgray: [
					169,
					169,
					169
				],
				darkgreen: [
					0,
					100,
					0
				],
				darkgrey: [
					169,
					169,
					169
				],
				darkkhaki: [
					189,
					183,
					107
				],
				darkmagenta: [
					139,
					0,
					139
				],
				darkolivegreen: [
					85,
					107,
					47
				],
				darkorange: [
					255,
					140,
					0
				],
				darkorchid: [
					153,
					50,
					204
				],
				darkred: [
					139,
					0,
					0
				],
				darksalmon: [
					233,
					150,
					122
				],
				darkseagreen: [
					143,
					188,
					143
				],
				darkslateblue: [
					72,
					61,
					139
				],
				darkslategray: [
					47,
					79,
					79
				],
				darkslategrey: [
					47,
					79,
					79
				],
				darkturquoise: [
					0,
					206,
					209
				],
				darkviolet: [
					148,
					0,
					211
				],
				deeppink: [
					255,
					20,
					147
				],
				deepskyblue: [
					0,
					191,
					255
				],
				dimgray: [
					105,
					105,
					105
				],
				dimgrey: [
					105,
					105,
					105
				],
				dodgerblue: [
					30,
					144,
					255
				],
				firebrick: [
					178,
					34,
					34
				],
				floralwhite: [
					255,
					250,
					240
				],
				forestgreen: [
					34,
					139,
					34
				],
				fuchsia: [
					255,
					0,
					255
				],
				gainsboro: [
					220,
					220,
					220
				],
				ghostwhite: [
					248,
					248,
					255
				],
				gold: [
					255,
					215,
					0
				],
				goldenrod: [
					218,
					165,
					32
				],
				gray: [
					128,
					128,
					128
				],
				green: [
					0,
					128,
					0
				],
				greenyellow: [
					173,
					255,
					47
				],
				grey: [
					128,
					128,
					128
				],
				honeydew: [
					240,
					255,
					240
				],
				hotpink: [
					255,
					105,
					180
				],
				indianred: [
					205,
					92,
					92
				],
				indigo: [
					75,
					0,
					130
				],
				ivory: [
					255,
					255,
					240
				],
				khaki: [
					240,
					230,
					140
				],
				lavender: [
					230,
					230,
					250
				],
				lavenderblush: [
					255,
					240,
					245
				],
				lawngreen: [
					124,
					252,
					0
				],
				lemonchiffon: [
					255,
					250,
					205
				],
				lightblue: [
					173,
					216,
					230
				],
				lightcoral: [
					240,
					128,
					128
				],
				lightcyan: [
					224,
					255,
					255
				],
				lightgoldenrodyellow: [
					250,
					250,
					210
				],
				lightgray: [
					211,
					211,
					211
				],
				lightgreen: [
					144,
					238,
					144
				],
				lightgrey: [
					211,
					211,
					211
				],
				lightpink: [
					255,
					182,
					193
				],
				lightsalmon: [
					255,
					160,
					122
				],
				lightseagreen: [
					32,
					178,
					170
				],
				lightskyblue: [
					135,
					206,
					250
				],
				lightslategray: [
					119,
					136,
					153
				],
				lightslategrey: [
					119,
					136,
					153
				],
				lightsteelblue: [
					176,
					196,
					222
				],
				lightyellow: [
					255,
					255,
					224
				],
				lime: [
					0,
					255,
					0
				],
				limegreen: [
					50,
					205,
					50
				],
				linen: [
					250,
					240,
					230
				],
				magenta: [
					255,
					0,
					255
				],
				maroon: [
					128,
					0,
					0
				],
				mediumaquamarine: [
					102,
					205,
					170
				],
				mediumblue: [
					0,
					0,
					205
				],
				mediumorchid: [
					186,
					85,
					211
				],
				mediumpurple: [
					147,
					112,
					219
				],
				mediumseagreen: [
					60,
					179,
					113
				],
				mediumslateblue: [
					123,
					104,
					238
				],
				mediumspringgreen: [
					0,
					250,
					154
				],
				mediumturquoise: [
					72,
					209,
					204
				],
				mediumvioletred: [
					199,
					21,
					133
				],
				midnightblue: [
					25,
					25,
					112
				],
				mintcream: [
					245,
					255,
					250
				],
				mistyrose: [
					255,
					228,
					225
				],
				moccasin: [
					255,
					228,
					181
				],
				navajowhite: [
					255,
					222,
					173
				],
				navy: [
					0,
					0,
					128
				],
				oldlace: [
					253,
					245,
					230
				],
				olive: [
					128,
					128,
					0
				],
				olivedrab: [
					107,
					142,
					35
				],
				orange: [
					255,
					165,
					0
				],
				orangered: [
					255,
					69,
					0
				],
				orchid: [
					218,
					112,
					214
				],
				palegoldenrod: [
					238,
					232,
					170
				],
				palegreen: [
					152,
					251,
					152
				],
				paleturquoise: [
					175,
					238,
					238
				],
				palevioletred: [
					219,
					112,
					147
				],
				papayawhip: [
					255,
					239,
					213
				],
				peachpuff: [
					255,
					218,
					185
				],
				peru: [
					205,
					133,
					63
				],
				pink: [
					255,
					192,
					203
				],
				plum: [
					221,
					160,
					221
				],
				powderblue: [
					176,
					224,
					230
				],
				purple: [
					128,
					0,
					128
				],
				rebeccapurple: [
					102,
					51,
					153
				],
				red: [
					255,
					0,
					0
				],
				rosybrown: [
					188,
					143,
					143
				],
				royalblue: [
					65,
					105,
					225
				],
				saddlebrown: [
					139,
					69,
					19
				],
				salmon: [
					250,
					128,
					114
				],
				sandybrown: [
					244,
					164,
					96
				],
				seagreen: [
					46,
					139,
					87
				],
				seashell: [
					255,
					245,
					238
				],
				sienna: [
					160,
					82,
					45
				],
				silver: [
					192,
					192,
					192
				],
				skyblue: [
					135,
					206,
					235
				],
				slateblue: [
					106,
					90,
					205
				],
				slategray: [
					112,
					128,
					144
				],
				slategrey: [
					112,
					128,
					144
				],
				snow: [
					255,
					250,
					250
				],
				springgreen: [
					0,
					255,
					127
				],
				steelblue: [
					70,
					130,
					180
				],
				tan: [
					210,
					180,
					140
				],
				teal: [
					0,
					128,
					128
				],
				thistle: [
					216,
					191,
					216
				],
				tomato: [
					255,
					99,
					71
				],
				turquoise: [
					64,
					224,
					208
				],
				violet: [
					238,
					130,
					238
				],
				wheat: [
					245,
					222,
					179
				],
				white: [
					255,
					255,
					255
				],
				whitesmoke: [
					245,
					245,
					245
				],
				yellow: [
					255,
					255,
					0
				],
				yellowgreen: [
					154,
					205,
					50
				]
			};
			function ke(t$1, e$1, r$1) {
				return t$1 + r$1 * (e$1 - t$1);
			}
			function Ee(t$1, e$1, r$1) {
				return t$1.map(((t$2, n$1) => ke(t$2, e$1[n$1], r$1)));
			}
			class Te {
				constructor(t$1, e$1, r$1, n$1 = 1, i$1 = !0) {
					this.r = t$1, this.g = e$1, this.b = r$1, this.a = n$1, i$1 || (this.r *= n$1, this.g *= n$1, this.b *= n$1, n$1 || this.overwriteGetter("rgb", [
						t$1,
						e$1,
						r$1,
						n$1
					]));
				}
				static parse(t$1) {
					if (t$1 instanceof Te) return t$1;
					if ("string" != typeof t$1) return;
					const e$1 = function(t$2) {
						if ("transparent" === (t$2 = t$2.toLowerCase().trim())) return [
							0,
							0,
							0,
							0
						];
						const e$2 = ve(Ae, t$2);
						if (e$2) {
							const [t$3, r$2, n$1] = e$2;
							return [
								t$3 / 255,
								r$2 / 255,
								n$1 / 255,
								1
							];
						}
						if (t$2.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(t$2)) {
							const e$3 = t$2.length < 6 ? 1 : 2;
							let r$2 = 1;
							return [
								be(t$2.slice(r$2, r$2 += e$3)),
								be(t$2.slice(r$2, r$2 += e$3)),
								be(t$2.slice(r$2, r$2 += e$3)),
								be(t$2.slice(r$2, r$2 + e$3) || "ff")
							];
						}
						if (t$2.startsWith("rgb")) {
							const e$3 = t$2.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
							if (e$3) {
								const [t$3, r$2, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1] = e$3, f$1 = [
									i$1 || " ",
									o$1 || " ",
									c$1
								].join("");
								if ("  " === f$1 || "  /" === f$1 || ",," === f$1 || ",,," === f$1) {
									const t$4 = [
										n$1,
										a,
										u$1
									].join(""), e$4 = "%%%" === t$4 ? 100 : "" === t$4 ? 255 : 0;
									if (e$4) {
										const t$5 = [
											_e(+r$2 / e$4, 0, 1),
											_e(+s$1 / e$4, 0, 1),
											_e(+l$1 / e$4, 0, 1),
											h$1 ? we(+h$1, p$1) : 1
										];
										if (Se(t$5)) return t$5;
									}
								}
								return;
							}
						}
						const r$1 = t$2.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
						if (r$1) {
							const [t$3, e$3, n$1, i$1, s$1, a, o$1, l$1, u$1] = r$1, c$1 = [
								n$1 || " ",
								s$1 || " ",
								o$1
							].join("");
							if ("  " === c$1 || "  /" === c$1 || ",," === c$1 || ",,," === c$1) {
								const t$4 = [
									+e$3,
									_e(+i$1, 0, 100),
									_e(+a, 0, 100),
									l$1 ? we(+l$1, u$1) : 1
								];
								if (Se(t$4)) return function([t$5, e$4, r$2, n$2]) {
									function i$2(n$3) {
										const i$3 = (n$3 + t$5 / 30) % 12, s$2 = e$4 * Math.min(r$2, 1 - r$2);
										return r$2 - s$2 * Math.max(-1, Math.min(i$3 - 3, 9 - i$3, 1));
									}
									return t$5 = he(t$5), e$4 /= 100, r$2 /= 100, [
										i$2(0),
										i$2(8),
										i$2(4),
										n$2
									];
								}(t$4);
							}
						}
					}(t$1);
					return e$1 ? new Te(...e$1, !1) : void 0;
				}
				get rgb() {
					const { r: t$1, g: e$1, b: r$1, a: n$1 } = this, i$1 = n$1 || Infinity;
					return this.overwriteGetter("rgb", [
						t$1 / i$1,
						e$1 / i$1,
						r$1 / i$1,
						n$1
					]);
				}
				get hcl() {
					return this.overwriteGetter("hcl", function(t$1) {
						const [e$1, r$1, n$1, i$1] = pe(t$1), s$1 = Math.sqrt(r$1 * r$1 + n$1 * n$1);
						return [
							Math.round(1e4 * s$1) ? he(Math.atan2(n$1, r$1) * ce) : NaN,
							s$1,
							e$1,
							i$1
						];
					}(this.rgb));
				}
				get lab() {
					return this.overwriteGetter("lab", pe(this.rgb));
				}
				overwriteGetter(t$1, e$1) {
					return Object.defineProperty(this, t$1, { value: e$1 }), e$1;
				}
				toString() {
					const [t$1, e$1, r$1, n$1] = this.rgb;
					return `rgba(${[
						t$1,
						e$1,
						r$1
					].map(((t$2) => Math.round(255 * t$2))).join(",")},${n$1})`;
				}
				static interpolate(t$1, e$1, r$1, n$1 = "rgb") {
					switch (n$1) {
						case "rgb": {
							const [n$2, i$1, s$1, a] = Ee(t$1.rgb, e$1.rgb, r$1);
							return new Te(n$2, i$1, s$1, a, !1);
						}
						case "hcl": {
							const [n$2, i$1, s$1, a] = t$1.hcl, [o$1, l$1, u$1, c$1] = e$1.hcl;
							let h$1, p$1;
							if (isNaN(n$2) || isNaN(o$1)) isNaN(n$2) ? isNaN(o$1) ? h$1 = NaN : (h$1 = o$1, 1 !== s$1 && 0 !== s$1 || (p$1 = l$1)) : (h$1 = n$2, 1 !== u$1 && 0 !== u$1 || (p$1 = i$1));
							else {
								let t$2 = o$1 - n$2;
								o$1 > n$2 && t$2 > 180 ? t$2 -= 360 : o$1 < n$2 && n$2 - o$1 > 180 && (t$2 += 360), h$1 = n$2 + r$1 * t$2;
							}
							const [f$1, d$1, y$1, m$1] = function([t$2, e$2, r$2, n$3]) {
								return t$2 = isNaN(t$2) ? 0 : t$2 * ue, ye([
									r$2,
									Math.cos(t$2) * e$2,
									Math.sin(t$2) * e$2,
									n$3
								]);
							}([
								h$1,
								null != p$1 ? p$1 : ke(i$1, l$1, r$1),
								ke(s$1, u$1, r$1),
								ke(a, c$1, r$1)
							]);
							return new Te(f$1, d$1, y$1, m$1, !1);
						}
						case "lab": {
							const [n$2, i$1, s$1, a] = ye(Ee(t$1.lab, e$1.lab, r$1));
							return new Te(n$2, i$1, s$1, a, !1);
						}
					}
				}
			}
			Te.black = new Te(0, 0, 0, 1), Te.white = new Te(1, 1, 1, 1), Te.transparent = new Te(0, 0, 0, 0), Te.red = new Te(1, 0, 0, 1);
			class Ie {
				constructor(t$1, e$1, r$1) {
					this.sensitivity = t$1 ? e$1 ? "variant" : "case" : e$1 ? "accent" : "base", this.locale = r$1, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
						sensitivity: this.sensitivity,
						usage: "search"
					});
				}
				compare(t$1, e$1) {
					return this.collator.compare(t$1, e$1);
				}
				resolvedLocale() {
					return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
				}
			}
			const Me = [
				"bottom",
				"center",
				"top"
			];
			class Fe {
				constructor(t$1, e$1, r$1, n$1, i$1, s$1) {
					this.text = t$1, this.image = e$1, this.scale = r$1, this.fontStack = n$1, this.textColor = i$1, this.verticalAlign = s$1;
				}
			}
			class De {
				constructor(t$1) {
					this.sections = t$1;
				}
				static fromString(t$1) {
					return new De([new Fe(t$1, null, null, null, null, null)]);
				}
				isEmpty() {
					return 0 === this.sections.length || !this.sections.some(((t$1) => 0 !== t$1.text.length || t$1.image && 0 !== t$1.image.name.length));
				}
				static factory(t$1) {
					return t$1 instanceof De ? t$1 : De.fromString(t$1);
				}
				toString() {
					return 0 === this.sections.length ? "" : this.sections.map(((t$1) => t$1.text)).join("");
				}
			}
			class ze {
				constructor(t$1) {
					this.values = t$1.slice();
				}
				static parse(t$1) {
					if (t$1 instanceof ze) return t$1;
					if ("number" == typeof t$1) return new ze([
						t$1,
						t$1,
						t$1,
						t$1
					]);
					if (Array.isArray(t$1) && !(t$1.length < 1 || t$1.length > 4)) {
						for (const e$1 of t$1) if ("number" != typeof e$1) return;
						switch (t$1.length) {
							case 1:
								t$1 = [
									t$1[0],
									t$1[0],
									t$1[0],
									t$1[0]
								];
								break;
							case 2:
								t$1 = [
									t$1[0],
									t$1[1],
									t$1[0],
									t$1[1]
								];
								break;
							case 3: t$1 = [
								t$1[0],
								t$1[1],
								t$1[2],
								t$1[1]
							];
						}
						return new ze(t$1);
					}
				}
				toString() {
					return JSON.stringify(this.values);
				}
				static interpolate(t$1, e$1, r$1) {
					return new ze(Ee(t$1.values, e$1.values, r$1));
				}
			}
			class Pe {
				constructor(t$1) {
					this.values = t$1.slice();
				}
				static parse(t$1) {
					if (t$1 instanceof Pe) return t$1;
					if ("number" == typeof t$1) return new Pe([t$1]);
					if (Array.isArray(t$1)) {
						for (const e$1 of t$1) if ("number" != typeof e$1) return;
						return new Pe(t$1);
					}
				}
				toString() {
					return JSON.stringify(this.values);
				}
				static interpolate(t$1, e$1, r$1) {
					return new Pe(Ee(t$1.values, e$1.values, r$1));
				}
			}
			class Be {
				constructor(t$1) {
					this.values = t$1.slice();
				}
				static parse(t$1) {
					if (t$1 instanceof Be) return t$1;
					if ("string" == typeof t$1) {
						const e$2 = Te.parse(t$1);
						if (!e$2) return;
						return new Be([e$2]);
					}
					if (!Array.isArray(t$1)) return;
					const e$1 = [];
					for (const r$1 of t$1) {
						if ("string" != typeof r$1) return;
						const t$2 = Te.parse(r$1);
						if (!t$2) return;
						e$1.push(t$2);
					}
					return new Be(e$1);
				}
				toString() {
					return JSON.stringify(this.values);
				}
				static interpolate(t$1, e$1, r$1, n$1 = "rgb") {
					const i$1 = [];
					if (t$1.values.length != e$1.values.length) throw new Error(`colorArray: Arrays have mismatched length (${t$1.values.length} vs. ${e$1.values.length}), cannot interpolate.`);
					for (let s$1 = 0; s$1 < t$1.values.length; s$1++) i$1.push(Te.interpolate(t$1.values[s$1], e$1.values[s$1], r$1, n$1));
					return new Be(i$1);
				}
			}
			class Ve extends Error {
				constructor(t$1) {
					super(t$1), this.name = "RuntimeError";
				}
				toJSON() {
					return this.message;
				}
			}
			const Ce = new Set([
				"center",
				"left",
				"right",
				"top",
				"bottom",
				"top-left",
				"top-right",
				"bottom-left",
				"bottom-right"
			]);
			class Le {
				constructor(t$1) {
					this.values = t$1.slice();
				}
				static parse(t$1) {
					if (t$1 instanceof Le) return t$1;
					if (Array.isArray(t$1) && !(t$1.length < 1) && t$1.length % 2 == 0) {
						for (let e$1 = 0; e$1 < t$1.length; e$1 += 2) {
							const r$1 = t$1[e$1], n$1 = t$1[e$1 + 1];
							if ("string" != typeof r$1 || !Ce.has(r$1)) return;
							if (!Array.isArray(n$1) || 2 !== n$1.length || "number" != typeof n$1[0] || "number" != typeof n$1[1]) return;
						}
						return new Le(t$1);
					}
				}
				toString() {
					return JSON.stringify(this.values);
				}
				static interpolate(t$1, e$1, r$1) {
					const n$1 = t$1.values, i$1 = e$1.values;
					if (n$1.length !== i$1.length) throw new Ve(`Cannot interpolate values of different length. from: ${t$1.toString()}, to: ${e$1.toString()}`);
					const s$1 = [];
					for (let t$2 = 0; t$2 < n$1.length; t$2 += 2) {
						if (n$1[t$2] !== i$1[t$2]) throw new Ve(`Cannot interpolate values containing mismatched anchors. from[${t$2}]: ${n$1[t$2]}, to[${t$2}]: ${i$1[t$2]}`);
						s$1.push(n$1[t$2]);
						const [e$2, a] = n$1[t$2 + 1], [o$1, l$1] = i$1[t$2 + 1];
						s$1.push([ke(e$2, o$1, r$1), ke(a, l$1, r$1)]);
					}
					return new Le(s$1);
				}
			}
			class Oe {
				constructor(t$1) {
					this.name = t$1.name, this.available = t$1.available;
				}
				toString() {
					return this.name;
				}
				static fromString(t$1) {
					return t$1 ? new Oe({
						name: t$1,
						available: !1
					}) : null;
				}
			}
			class Re {
				constructor(t$1, e$1, r$1) {
					this.from = t$1, this.to = e$1, this.transition = r$1;
				}
				static interpolate(t$1, e$1, r$1) {
					return new Re(t$1, e$1, r$1);
				}
				static parse(t$1) {
					return t$1 instanceof Re ? t$1 : Array.isArray(t$1) && 3 === t$1.length && "string" == typeof t$1[0] && "string" == typeof t$1[1] && "number" == typeof t$1[2] ? new Re(t$1[0], t$1[1], t$1[2]) : "object" == typeof t$1 && "string" == typeof t$1.from && "string" == typeof t$1.to && "number" == typeof t$1.transition ? new Re(t$1.from, t$1.to, t$1.transition) : "string" == typeof t$1 ? new Re(t$1, t$1, 1) : void 0;
				}
			}
			function Ne(t$1, e$1, r$1, n$1) {
				return "number" == typeof t$1 && t$1 >= 0 && t$1 <= 255 && "number" == typeof e$1 && e$1 >= 0 && e$1 <= 255 && "number" == typeof r$1 && r$1 >= 0 && r$1 <= 255 ? void 0 === n$1 || "number" == typeof n$1 && n$1 >= 0 && n$1 <= 1 ? null : `Invalid rgba value [${[
					t$1,
					e$1,
					r$1,
					n$1
				].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n$1 ? [
					t$1,
					e$1,
					r$1,
					n$1
				] : [
					t$1,
					e$1,
					r$1
				]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
			}
			function $e(t$1) {
				if (null === t$1 || "string" == typeof t$1 || "boolean" == typeof t$1 || "number" == typeof t$1 || t$1 instanceof Re || t$1 instanceof Te || t$1 instanceof Ie || t$1 instanceof De || t$1 instanceof ze || t$1 instanceof Pe || t$1 instanceof Be || t$1 instanceof Le || t$1 instanceof Oe) return !0;
				if (Array.isArray(t$1)) {
					for (const e$1 of t$1) if (!$e(e$1)) return !1;
					return !0;
				}
				if ("object" == typeof t$1) {
					for (const e$1 in t$1) if (!$e(t$1[e$1])) return !1;
					return !0;
				}
				return !1;
			}
			function Ue(t$1) {
				if (null === t$1) return Vt;
				if ("string" == typeof t$1) return Lt;
				if ("boolean" == typeof t$1) return Ot;
				if ("number" == typeof t$1) return Ct;
				if (t$1 instanceof Te) return Rt;
				if (t$1 instanceof Re) return Nt;
				if (t$1 instanceof Ie) return qt;
				if (t$1 instanceof De) return jt;
				if (t$1 instanceof ze) return Gt;
				if (t$1 instanceof Pe) return Yt;
				if (t$1 instanceof Be) return Xt;
				if (t$1 instanceof Le) return Ht;
				if (t$1 instanceof Oe) return Zt;
				if (Array.isArray(t$1)) {
					const e$1 = t$1.length;
					let r$1;
					for (const e$2 of t$1) {
						const t$2 = Ue(e$2);
						if (r$1) {
							if (r$1 === t$2) continue;
							r$1 = Ut;
							break;
						}
						r$1 = t$2;
					}
					return Kt(r$1 || Ut, e$1);
				}
				return $t;
			}
			function qe(t$1) {
				const e$1 = typeof t$1;
				return null === t$1 ? "" : "string" === e$1 || "number" === e$1 || "boolean" === e$1 ? String(t$1) : t$1 instanceof Te || t$1 instanceof Re || t$1 instanceof De || t$1 instanceof ze || t$1 instanceof Pe || t$1 instanceof Be || t$1 instanceof Le || t$1 instanceof Oe ? t$1.toString() : JSON.stringify(t$1);
			}
			class je {
				constructor(t$1, e$1) {
					this.type = t$1, this.value = e$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error(`'literal' expression requires exactly one argument, but found ${t$1.length - 1} instead.`);
					if (!$e(t$1[1])) return e$1.error("invalid value");
					const r$1 = t$1[1];
					let n$1 = Ue(r$1);
					const i$1 = e$1.expectedType;
					return "array" !== n$1.kind || 0 !== n$1.N || !i$1 || "array" !== i$1.kind || "number" == typeof i$1.N && 0 !== i$1.N || (n$1 = i$1), new je(n$1, r$1);
				}
				evaluate() {
					return this.value;
				}
				eachChild() {}
				outputDefined() {
					return !0;
				}
			}
			const Ge = {
				string: Lt,
				number: Ct,
				boolean: Ot,
				object: $t
			};
			class Xe {
				constructor(t$1, e$1) {
					this.type = t$1, this.args = e$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 2) return e$1.error("Expected at least one argument.");
					let r$1, n$1 = 1;
					const i$1 = t$1[0];
					if ("array" === i$1) {
						let i$2, s$2;
						if (t$1.length > 2) {
							const r$2 = t$1[1];
							if ("string" != typeof r$2 || !(r$2 in Ge) || "object" === r$2) return e$1.error("The item type argument of \"array\" must be one of string, number, boolean", 1);
							i$2 = Ge[r$2], n$1++;
						} else i$2 = Ut;
						if (t$1.length > 3) {
							if (null !== t$1[2] && ("number" != typeof t$1[2] || t$1[2] < 0 || t$1[2] !== Math.floor(t$1[2]))) return e$1.error("The length argument to \"array\" must be a positive integer literal", 2);
							s$2 = t$1[2], n$1++;
						}
						r$1 = Kt(i$2, s$2);
					} else {
						if (!Ge[i$1]) throw new Error(`Types doesn't contain name = ${i$1}`);
						r$1 = Ge[i$1];
					}
					const s$1 = [];
					for (; n$1 < t$1.length; n$1++) {
						const r$2 = e$1.parse(t$1[n$1], n$1, Ut);
						if (!r$2) return null;
						s$1.push(r$2);
					}
					return new Xe(r$1, s$1);
				}
				evaluate(t$1) {
					for (let e$1 = 0; e$1 < this.args.length; e$1++) {
						const r$1 = this.args[e$1].evaluate(t$1);
						if (!Qt(this.type, Ue(r$1))) return r$1;
						if (e$1 === this.args.length - 1) throw new Ve(`Expected value to be of type ${Wt(this.type)}, but found ${Wt(Ue(r$1))} instead.`);
					}
					throw new Error();
				}
				eachChild(t$1) {
					this.args.forEach(t$1);
				}
				outputDefined() {
					return this.args.every(((t$1) => t$1.outputDefined()));
				}
			}
			const Ye = {
				"to-boolean": Ot,
				"to-color": Rt,
				"to-number": Ct,
				"to-string": Lt
			};
			class Ze {
				constructor(t$1, e$1) {
					this.type = t$1, this.args = e$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 2) return e$1.error("Expected at least one argument.");
					const r$1 = t$1[0];
					if (!Ye[r$1]) throw new Error(`Can't parse ${r$1} as it is not part of the known types`);
					if (("to-boolean" === r$1 || "to-string" === r$1) && 2 !== t$1.length) return e$1.error("Expected one argument.");
					const n$1 = Ye[r$1], i$1 = [];
					for (let r$2 = 1; r$2 < t$1.length; r$2++) {
						const n$2 = e$1.parse(t$1[r$2], r$2, Ut);
						if (!n$2) return null;
						i$1.push(n$2);
					}
					return new Ze(n$1, i$1);
				}
				evaluate(t$1) {
					switch (this.type.kind) {
						case "boolean": return Boolean(this.args[0].evaluate(t$1));
						case "color": {
							let e$1, r$1;
							for (const n$1 of this.args) {
								if (e$1 = n$1.evaluate(t$1), r$1 = null, e$1 instanceof Te) return e$1;
								if ("string" == typeof e$1) {
									const r$2 = t$1.parseColor(e$1);
									if (r$2) return r$2;
								} else if (Array.isArray(e$1) && (r$1 = e$1.length < 3 || e$1.length > 4 ? `Invalid rgba value ${JSON.stringify(e$1)}: expected an array containing either three or four numeric values.` : Ne(e$1[0], e$1[1], e$1[2], e$1[3]), !r$1)) return new Te(e$1[0] / 255, e$1[1] / 255, e$1[2] / 255, e$1[3]);
							}
							throw new Ve(r$1 || `Could not parse color from value '${"string" == typeof e$1 ? e$1 : JSON.stringify(e$1)}'`);
						}
						case "padding": {
							let e$1;
							for (const r$1 of this.args) {
								e$1 = r$1.evaluate(t$1);
								const n$1 = ze.parse(e$1);
								if (n$1) return n$1;
							}
							throw new Ve(`Could not parse padding from value '${"string" == typeof e$1 ? e$1 : JSON.stringify(e$1)}'`);
						}
						case "numberArray": {
							let e$1;
							for (const r$1 of this.args) {
								e$1 = r$1.evaluate(t$1);
								const n$1 = Pe.parse(e$1);
								if (n$1) return n$1;
							}
							throw new Ve(`Could not parse numberArray from value '${"string" == typeof e$1 ? e$1 : JSON.stringify(e$1)}'`);
						}
						case "colorArray": {
							let e$1;
							for (const r$1 of this.args) {
								e$1 = r$1.evaluate(t$1);
								const n$1 = Be.parse(e$1);
								if (n$1) return n$1;
							}
							throw new Ve(`Could not parse colorArray from value '${"string" == typeof e$1 ? e$1 : JSON.stringify(e$1)}'`);
						}
						case "variableAnchorOffsetCollection": {
							let e$1;
							for (const r$1 of this.args) {
								e$1 = r$1.evaluate(t$1);
								const n$1 = Le.parse(e$1);
								if (n$1) return n$1;
							}
							throw new Ve(`Could not parse variableAnchorOffsetCollection from value '${"string" == typeof e$1 ? e$1 : JSON.stringify(e$1)}'`);
						}
						case "number": {
							let e$1 = null;
							for (const r$1 of this.args) {
								if (e$1 = r$1.evaluate(t$1), null === e$1) return 0;
								const n$1 = Number(e$1);
								if (!isNaN(n$1)) return n$1;
							}
							throw new Ve(`Could not convert ${JSON.stringify(e$1)} to number.`);
						}
						case "formatted": return De.fromString(qe(this.args[0].evaluate(t$1)));
						case "resolvedImage": return Oe.fromString(qe(this.args[0].evaluate(t$1)));
						case "projectionDefinition": return this.args[0].evaluate(t$1);
						default: return qe(this.args[0].evaluate(t$1));
					}
				}
				eachChild(t$1) {
					this.args.forEach(t$1);
				}
				outputDefined() {
					return this.args.every(((t$1) => t$1.outputDefined()));
				}
			}
			const He = [
				"Unknown",
				"Point",
				"LineString",
				"Polygon"
			];
			class Ke {
				constructor() {
					this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
				}
				id() {
					return this.feature && "id" in this.feature ? this.feature.id : null;
				}
				geometryType() {
					return this.feature ? "number" == typeof this.feature.type ? He[this.feature.type] : this.feature.type : null;
				}
				geometry() {
					return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
				}
				canonicalID() {
					return this.canonical;
				}
				properties() {
					return this.feature && this.feature.properties || {};
				}
				parseColor(t$1) {
					let e$1 = this._parseColorCache.get(t$1);
					return e$1 || (e$1 = Te.parse(t$1), this._parseColorCache.set(t$1, e$1)), e$1;
				}
			}
			class We {
				constructor(t$1, e$1, r$1 = [], n$1, i$1 = new Bt(), s$1 = []) {
					this.registry = t$1, this.path = r$1, this.key = r$1.map(((t$2) => `[${t$2}]`)).join(""), this.scope = i$1, this.errors = s$1, this.expectedType = n$1, this._isConstant = e$1;
				}
				parse(t$1, e$1, r$1, n$1, i$1 = {}) {
					return e$1 ? this.concat(e$1, r$1, n$1)._parse(t$1, i$1) : this._parse(t$1, i$1);
				}
				_parse(t$1, e$1) {
					function r$1(t$2, e$2, r$2) {
						return "assert" === r$2 ? new Xe(e$2, [t$2]) : "coerce" === r$2 ? new Ze(e$2, [t$2]) : t$2;
					}
					if (null !== t$1 && "string" != typeof t$1 && "boolean" != typeof t$1 && "number" != typeof t$1 || (t$1 = ["literal", t$1]), Array.isArray(t$1)) {
						if (0 === t$1.length) return this.error("Expected an array with at least one element. If you wanted a literal array, use [\"literal\", []].");
						const n$1 = t$1[0];
						if ("string" != typeof n$1) return this.error(`Expression name must be a string, but found ${typeof n$1} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
						const i$1 = this.registry[n$1];
						if (i$1) {
							let n$2 = i$1.parse(t$1, this);
							if (!n$2) return null;
							if (this.expectedType) {
								const t$2 = this.expectedType, i$2 = n$2.type;
								if ("string" !== t$2.kind && "number" !== t$2.kind && "boolean" !== t$2.kind && "object" !== t$2.kind && "array" !== t$2.kind || "value" !== i$2.kind) {
									if ("projectionDefinition" === t$2.kind && ["string", "array"].includes(i$2.kind) || [
										"color",
										"formatted",
										"resolvedImage"
									].includes(t$2.kind) && ["value", "string"].includes(i$2.kind) || ["padding", "numberArray"].includes(t$2.kind) && [
										"value",
										"number",
										"array"
									].includes(i$2.kind) || "colorArray" === t$2.kind && [
										"value",
										"string",
										"array"
									].includes(i$2.kind) || "variableAnchorOffsetCollection" === t$2.kind && ["value", "array"].includes(i$2.kind)) n$2 = r$1(n$2, t$2, e$1.typeAnnotation || "coerce");
									else if (this.checkSubtype(t$2, i$2)) return null;
								} else n$2 = r$1(n$2, t$2, e$1.typeAnnotation || "assert");
							}
							if (!(n$2 instanceof je) && "resolvedImage" !== n$2.type.kind && this._isConstant(n$2)) {
								const t$2 = new Ke();
								try {
									n$2 = new je(n$2.type, n$2.evaluate(t$2));
								} catch (t$3) {
									return this.error(t$3.message), null;
								}
							}
							return n$2;
						}
						return this.error(`Unknown expression "${n$1}". If you wanted a literal array, use ["literal", [...]].`, 0);
					}
					return this.error(void 0 === t$1 ? "'undefined' value invalid. Use null instead." : "object" == typeof t$1 ? "Bare objects invalid. Use [\"literal\", {...}] instead." : `Expected an array, but found ${typeof t$1} instead.`);
				}
				concat(t$1, e$1, r$1) {
					const n$1 = "number" == typeof t$1 ? this.path.concat(t$1) : this.path, i$1 = r$1 ? this.scope.concat(r$1) : this.scope;
					return new We(this.registry, this._isConstant, n$1, e$1 || null, i$1, this.errors);
				}
				error(t$1, ...e$1) {
					const r$1 = `${this.key}${e$1.map(((t$2) => `[${t$2}]`)).join("")}`;
					this.errors.push(new Pt(r$1, t$1));
				}
				checkSubtype(t$1, e$1) {
					const r$1 = Qt(t$1, e$1);
					return r$1 && this.error(r$1), r$1;
				}
			}
			class Je {
				constructor(t$1, e$1) {
					this.type = e$1.type, this.bindings = [].concat(t$1), this.result = e$1;
				}
				evaluate(t$1) {
					return this.result.evaluate(t$1);
				}
				eachChild(t$1) {
					for (const e$1 of this.bindings) t$1(e$1[1]);
					t$1(this.result);
				}
				static parse(t$1, e$1) {
					if (t$1.length < 4) return e$1.error(`Expected at least 3 arguments, but found ${t$1.length - 1} instead.`);
					const r$1 = [];
					for (let n$2 = 1; n$2 < t$1.length - 1; n$2 += 2) {
						const i$1 = t$1[n$2];
						if ("string" != typeof i$1) return e$1.error(`Expected string, but found ${typeof i$1} instead.`, n$2);
						if (/[^a-zA-Z0-9_]/.test(i$1)) return e$1.error("Variable names must contain only alphanumeric characters or '_'.", n$2);
						const s$1 = e$1.parse(t$1[n$2 + 1], n$2 + 1);
						if (!s$1) return null;
						r$1.push([i$1, s$1]);
					}
					const n$1 = e$1.parse(t$1[t$1.length - 1], t$1.length - 1, e$1.expectedType, r$1);
					return n$1 ? new Je(r$1, n$1) : null;
				}
				outputDefined() {
					return this.result.outputDefined();
				}
			}
			class Qe {
				constructor(t$1, e$1) {
					this.type = e$1.type, this.name = t$1, this.boundExpression = e$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length || "string" != typeof t$1[1]) return e$1.error("'var' expression requires exactly one string literal argument.");
					const r$1 = t$1[1];
					return e$1.scope.has(r$1) ? new Qe(r$1, e$1.scope.get(r$1)) : e$1.error(`Unknown variable "${r$1}". Make sure "${r$1}" has been bound in an enclosing "let" expression before using it.`, 1);
				}
				evaluate(t$1) {
					return this.boundExpression.evaluate(t$1);
				}
				eachChild() {}
				outputDefined() {
					return !1;
				}
			}
			class tr {
				constructor(t$1, e$1, r$1) {
					this.type = t$1, this.index = e$1, this.input = r$1;
				}
				static parse(t$1, e$1) {
					if (3 !== t$1.length) return e$1.error(`Expected 2 arguments, but found ${t$1.length - 1} instead.`);
					const r$1 = e$1.parse(t$1[1], 1, Ct), n$1 = e$1.parse(t$1[2], 2, Kt(e$1.expectedType || Ut));
					return r$1 && n$1 ? new tr(n$1.type.itemType, r$1, n$1) : null;
				}
				evaluate(t$1) {
					const e$1 = this.index.evaluate(t$1), r$1 = this.input.evaluate(t$1);
					if (e$1 < 0) throw new Ve(`Array index out of bounds: ${e$1} < 0.`);
					if (e$1 >= r$1.length) throw new Ve(`Array index out of bounds: ${e$1} > ${r$1.length - 1}.`);
					if (e$1 !== Math.floor(e$1)) throw new Ve(`Array index must be an integer, but found ${e$1} instead.`);
					return r$1[e$1];
				}
				eachChild(t$1) {
					t$1(this.index), t$1(this.input);
				}
				outputDefined() {
					return !1;
				}
			}
			class er {
				constructor(t$1, e$1) {
					this.type = Ot, this.needle = t$1, this.haystack = e$1;
				}
				static parse(t$1, e$1) {
					if (3 !== t$1.length) return e$1.error(`Expected 2 arguments, but found ${t$1.length - 1} instead.`);
					const r$1 = e$1.parse(t$1[1], 1, Ut), n$1 = e$1.parse(t$1[2], 2, Ut);
					return r$1 && n$1 ? te(r$1.type, [
						Ot,
						Lt,
						Ct,
						Vt,
						Ut
					]) ? new er(r$1, n$1) : e$1.error(`Expected first argument to be of type boolean, string, number or null, but found ${Wt(r$1.type)} instead`) : null;
				}
				evaluate(t$1) {
					const e$1 = this.needle.evaluate(t$1), r$1 = this.haystack.evaluate(t$1);
					if (!r$1) return !1;
					if (!ee(e$1, [
						"boolean",
						"string",
						"number",
						"null"
					])) throw new Ve(`Expected first argument to be of type boolean, string, number or null, but found ${Wt(Ue(e$1))} instead.`);
					if (!ee(r$1, ["string", "array"])) throw new Ve(`Expected second argument to be of type array or string, but found ${Wt(Ue(r$1))} instead.`);
					return r$1.indexOf(e$1) >= 0;
				}
				eachChild(t$1) {
					t$1(this.needle), t$1(this.haystack);
				}
				outputDefined() {
					return !0;
				}
			}
			class rr {
				constructor(t$1, e$1, r$1) {
					this.type = Ct, this.needle = t$1, this.haystack = e$1, this.fromIndex = r$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length <= 2 || t$1.length >= 5) return e$1.error(`Expected 2 or 3 arguments, but found ${t$1.length - 1} instead.`);
					const r$1 = e$1.parse(t$1[1], 1, Ut), n$1 = e$1.parse(t$1[2], 2, Ut);
					if (!r$1 || !n$1) return null;
					if (!te(r$1.type, [
						Ot,
						Lt,
						Ct,
						Vt,
						Ut
					])) return e$1.error(`Expected first argument to be of type boolean, string, number or null, but found ${Wt(r$1.type)} instead`);
					if (4 === t$1.length) {
						const i$1 = e$1.parse(t$1[3], 3, Ct);
						return i$1 ? new rr(r$1, n$1, i$1) : null;
					}
					return new rr(r$1, n$1);
				}
				evaluate(t$1) {
					const e$1 = this.needle.evaluate(t$1), r$1 = this.haystack.evaluate(t$1);
					if (!ee(e$1, [
						"boolean",
						"string",
						"number",
						"null"
					])) throw new Ve(`Expected first argument to be of type boolean, string, number or null, but found ${Wt(Ue(e$1))} instead.`);
					let n$1;
					if (this.fromIndex && (n$1 = this.fromIndex.evaluate(t$1)), ee(r$1, ["string"])) {
						const t$2 = r$1.indexOf(e$1, n$1);
						return -1 === t$2 ? -1 : [...r$1.slice(0, t$2)].length;
					}
					if (ee(r$1, ["array"])) return r$1.indexOf(e$1, n$1);
					throw new Ve(`Expected second argument to be of type array or string, but found ${Wt(Ue(r$1))} instead.`);
				}
				eachChild(t$1) {
					t$1(this.needle), t$1(this.haystack), this.fromIndex && t$1(this.fromIndex);
				}
				outputDefined() {
					return !1;
				}
			}
			class nr {
				constructor(t$1, e$1, r$1, n$1, i$1, s$1) {
					this.inputType = t$1, this.type = e$1, this.input = r$1, this.cases = n$1, this.outputs = i$1, this.otherwise = s$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 5) return e$1.error(`Expected at least 4 arguments, but found only ${t$1.length - 1}.`);
					if (t$1.length % 2 != 1) return e$1.error("Expected an even number of arguments.");
					let r$1, n$1;
					e$1.expectedType && "value" !== e$1.expectedType.kind && (n$1 = e$1.expectedType);
					const i$1 = {}, s$1 = [];
					for (let a$1 = 2; a$1 < t$1.length - 1; a$1 += 2) {
						let o$2 = t$1[a$1];
						const l$1 = t$1[a$1 + 1];
						Array.isArray(o$2) || (o$2 = [o$2]);
						const u$1 = e$1.concat(a$1);
						if (0 === o$2.length) return u$1.error("Expected at least one branch label.");
						for (const t$2 of o$2) {
							if ("number" != typeof t$2 && "string" != typeof t$2) return u$1.error("Branch labels must be numbers or strings.");
							if ("number" == typeof t$2 && Math.abs(t$2) > Number.MAX_SAFE_INTEGER) return u$1.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
							if ("number" == typeof t$2 && Math.floor(t$2) !== t$2) return u$1.error("Numeric branch labels must be integer values.");
							if (r$1) {
								if (u$1.checkSubtype(r$1, Ue(t$2))) return null;
							} else r$1 = Ue(t$2);
							if (void 0 !== i$1[String(t$2)]) return u$1.error("Branch labels must be unique.");
							i$1[String(t$2)] = s$1.length;
						}
						const c$1 = e$1.parse(l$1, a$1, n$1);
						if (!c$1) return null;
						n$1 = n$1 || c$1.type, s$1.push(c$1);
					}
					const a = e$1.parse(t$1[1], 1, Ut);
					if (!a) return null;
					const o$1 = e$1.parse(t$1[t$1.length - 1], t$1.length - 1, n$1);
					return o$1 ? "value" !== a.type.kind && e$1.concat(1).checkSubtype(r$1, a.type) ? null : new nr(r$1, n$1, a, i$1, s$1, o$1) : null;
				}
				evaluate(t$1) {
					const e$1 = this.input.evaluate(t$1);
					return (Ue(e$1) === this.inputType && this.outputs[this.cases[e$1]] || this.otherwise).evaluate(t$1);
				}
				eachChild(t$1) {
					t$1(this.input), this.outputs.forEach(t$1), t$1(this.otherwise);
				}
				outputDefined() {
					return this.outputs.every(((t$1) => t$1.outputDefined())) && this.otherwise.outputDefined();
				}
			}
			class ir {
				constructor(t$1, e$1, r$1) {
					this.type = t$1, this.branches = e$1, this.otherwise = r$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 4) return e$1.error(`Expected at least 3 arguments, but found only ${t$1.length - 1}.`);
					if (t$1.length % 2 != 0) return e$1.error("Expected an odd number of arguments.");
					let r$1;
					e$1.expectedType && "value" !== e$1.expectedType.kind && (r$1 = e$1.expectedType);
					const n$1 = [];
					for (let i$2 = 1; i$2 < t$1.length - 1; i$2 += 2) {
						const s$1 = e$1.parse(t$1[i$2], i$2, Ot);
						if (!s$1) return null;
						const a = e$1.parse(t$1[i$2 + 1], i$2 + 1, r$1);
						if (!a) return null;
						n$1.push([s$1, a]), r$1 = r$1 || a.type;
					}
					const i$1 = e$1.parse(t$1[t$1.length - 1], t$1.length - 1, r$1);
					if (!i$1) return null;
					if (!r$1) throw new Error("Can't infer output type");
					return new ir(r$1, n$1, i$1);
				}
				evaluate(t$1) {
					for (const [e$1, r$1] of this.branches) if (e$1.evaluate(t$1)) return r$1.evaluate(t$1);
					return this.otherwise.evaluate(t$1);
				}
				eachChild(t$1) {
					for (const [e$1, r$1] of this.branches) t$1(e$1), t$1(r$1);
					t$1(this.otherwise);
				}
				outputDefined() {
					return this.branches.every((([t$1, e$1]) => e$1.outputDefined())) && this.otherwise.outputDefined();
				}
			}
			class sr {
				constructor(t$1, e$1, r$1, n$1) {
					this.type = t$1, this.input = e$1, this.beginIndex = r$1, this.endIndex = n$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length <= 2 || t$1.length >= 5) return e$1.error(`Expected 2 or 3 arguments, but found ${t$1.length - 1} instead.`);
					const r$1 = e$1.parse(t$1[1], 1, Ut), n$1 = e$1.parse(t$1[2], 2, Ct);
					if (!r$1 || !n$1) return null;
					if (!te(r$1.type, [
						Kt(Ut),
						Lt,
						Ut
					])) return e$1.error(`Expected first argument to be of type array or string, but found ${Wt(r$1.type)} instead`);
					if (4 === t$1.length) {
						const i$1 = e$1.parse(t$1[3], 3, Ct);
						return i$1 ? new sr(r$1.type, r$1, n$1, i$1) : null;
					}
					return new sr(r$1.type, r$1, n$1);
				}
				evaluate(t$1) {
					const e$1 = this.input.evaluate(t$1), r$1 = this.beginIndex.evaluate(t$1);
					let n$1;
					if (this.endIndex && (n$1 = this.endIndex.evaluate(t$1)), ee(e$1, ["string"])) return [...e$1].slice(r$1, n$1).join("");
					if (ee(e$1, ["array"])) return e$1.slice(r$1, n$1);
					throw new Ve(`Expected first argument to be of type array or string, but found ${Wt(Ue(e$1))} instead.`);
				}
				eachChild(t$1) {
					t$1(this.input), t$1(this.beginIndex), this.endIndex && t$1(this.endIndex);
				}
				outputDefined() {
					return !1;
				}
			}
			function ar(t$1, e$1) {
				const r$1 = t$1.length - 1;
				let n$1, i$1, s$1 = 0, a = r$1, o$1 = 0;
				for (; s$1 <= a;) if (o$1 = Math.floor((s$1 + a) / 2), n$1 = t$1[o$1], i$1 = t$1[o$1 + 1], n$1 <= e$1) {
					if (o$1 === r$1 || e$1 < i$1) return o$1;
					s$1 = o$1 + 1;
				} else {
					if (!(n$1 > e$1)) throw new Ve("Input is not a number.");
					a = o$1 - 1;
				}
				return 0;
			}
			class or {
				constructor(t$1, e$1, r$1) {
					this.type = t$1, this.input = e$1, this.labels = [], this.outputs = [];
					for (const [t$2, e$2] of r$1) this.labels.push(t$2), this.outputs.push(e$2);
				}
				static parse(t$1, e$1) {
					if (t$1.length - 1 < 4) return e$1.error(`Expected at least 4 arguments, but found only ${t$1.length - 1}.`);
					if ((t$1.length - 1) % 2 != 0) return e$1.error("Expected an even number of arguments.");
					const r$1 = e$1.parse(t$1[1], 1, Ct);
					if (!r$1) return null;
					const n$1 = [];
					let i$1 = null;
					e$1.expectedType && "value" !== e$1.expectedType.kind && (i$1 = e$1.expectedType);
					for (let r$2 = 1; r$2 < t$1.length; r$2 += 2) {
						const s$1 = 1 === r$2 ? -Infinity : t$1[r$2], a = t$1[r$2 + 1], o$1 = r$2, l$1 = r$2 + 1;
						if ("number" != typeof s$1) return e$1.error("Input/output pairs for \"step\" expressions must be defined using literal numeric values (not computed expressions) for the input values.", o$1);
						if (n$1.length && n$1[n$1.length - 1][0] >= s$1) return e$1.error("Input/output pairs for \"step\" expressions must be arranged with input values in strictly ascending order.", o$1);
						const u$1 = e$1.parse(a, l$1, i$1);
						if (!u$1) return null;
						i$1 = i$1 || u$1.type, n$1.push([s$1, u$1]);
					}
					return new or(i$1, r$1, n$1);
				}
				evaluate(t$1) {
					const e$1 = this.labels, r$1 = this.outputs;
					if (1 === e$1.length) return r$1[0].evaluate(t$1);
					const n$1 = this.input.evaluate(t$1);
					if (n$1 <= e$1[0]) return r$1[0].evaluate(t$1);
					const i$1 = e$1.length;
					return n$1 >= e$1[i$1 - 1] ? r$1[i$1 - 1].evaluate(t$1) : r$1[ar(e$1, n$1)].evaluate(t$1);
				}
				eachChild(t$1) {
					t$1(this.input);
					for (const e$1 of this.outputs) t$1(e$1);
				}
				outputDefined() {
					return this.outputs.every(((t$1) => t$1.outputDefined()));
				}
			}
			function lr(t$1) {
				return t$1 && t$1.__esModule && Object.prototype.hasOwnProperty.call(t$1, "default") ? t$1.default : t$1;
			}
			var ur, cr, pr = lr(function() {
				if (cr) return ur;
				function t$1(t$2, e$1, r$1, n$1) {
					this.cx = 3 * t$2, this.bx = 3 * (r$1 - t$2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e$1, this.by = 3 * (n$1 - e$1) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t$2, this.p1y = e$1, this.p2x = r$1, this.p2y = n$1;
				}
				return cr = 1, ur = t$1, t$1.prototype = {
					sampleCurveX: function(t$2) {
						return ((this.ax * t$2 + this.bx) * t$2 + this.cx) * t$2;
					},
					sampleCurveY: function(t$2) {
						return ((this.ay * t$2 + this.by) * t$2 + this.cy) * t$2;
					},
					sampleCurveDerivativeX: function(t$2) {
						return (3 * this.ax * t$2 + 2 * this.bx) * t$2 + this.cx;
					},
					solveCurveX: function(t$2, e$1) {
						if (void 0 === e$1 && (e$1 = 1e-6), t$2 < 0) return 0;
						if (t$2 > 1) return 1;
						for (var r$1 = t$2, n$1 = 0; n$1 < 8; n$1++) {
							var i$1 = this.sampleCurveX(r$1) - t$2;
							if (Math.abs(i$1) < e$1) return r$1;
							var s$1 = this.sampleCurveDerivativeX(r$1);
							if (Math.abs(s$1) < 1e-6) break;
							r$1 -= i$1 / s$1;
						}
						var a = 0, o$1 = 1;
						for (r$1 = t$2, n$1 = 0; n$1 < 20 && (i$1 = this.sampleCurveX(r$1), !(Math.abs(i$1 - t$2) < e$1)); n$1++) t$2 > i$1 ? a = r$1 : o$1 = r$1, r$1 = .5 * (o$1 - a) + a;
						return r$1;
					},
					solve: function(t$2, e$1) {
						return this.sampleCurveY(this.solveCurveX(t$2, e$1));
					}
				}, ur;
			}());
			class fr {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.type = t$1, this.operator = e$1, this.interpolation = r$1, this.input = n$1, this.labels = [], this.outputs = [];
					for (const [t$2, e$2] of i$1) this.labels.push(t$2), this.outputs.push(e$2);
				}
				static interpolationFactor(t$1, e$1, r$1, n$1) {
					let i$1 = 0;
					if ("exponential" === t$1.name) i$1 = dr(e$1, t$1.base, r$1, n$1);
					else if ("linear" === t$1.name) i$1 = dr(e$1, 1, r$1, n$1);
					else if ("cubic-bezier" === t$1.name) {
						const s$1 = t$1.controlPoints;
						i$1 = new pr(s$1[0], s$1[1], s$1[2], s$1[3]).solve(dr(e$1, 1, r$1, n$1));
					}
					return i$1;
				}
				static parse(t$1, e$1) {
					let [r$1, n$1, i$1, ...s$1] = t$1;
					if (!Array.isArray(n$1) || 0 === n$1.length) return e$1.error("Expected an interpolation type expression.", 1);
					if ("linear" === n$1[0]) n$1 = { name: "linear" };
					else if ("exponential" === n$1[0]) {
						const t$2 = n$1[1];
						if ("number" != typeof t$2) return e$1.error("Exponential interpolation requires a numeric base.", 1, 1);
						n$1 = {
							name: "exponential",
							base: t$2
						};
					} else {
						if ("cubic-bezier" !== n$1[0]) return e$1.error(`Unknown interpolation type ${String(n$1[0])}`, 1, 0);
						{
							const t$2 = n$1.slice(1);
							if (4 !== t$2.length || t$2.some(((t$3) => "number" != typeof t$3 || t$3 < 0 || t$3 > 1))) return e$1.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
							n$1 = {
								name: "cubic-bezier",
								controlPoints: t$2
							};
						}
					}
					if (t$1.length - 1 < 4) return e$1.error(`Expected at least 4 arguments, but found only ${t$1.length - 1}.`);
					if ((t$1.length - 1) % 2 != 0) return e$1.error("Expected an even number of arguments.");
					if (i$1 = e$1.parse(i$1, 2, Ct), !i$1) return null;
					const a = [];
					let o$1 = null;
					"interpolate-hcl" !== r$1 && "interpolate-lab" !== r$1 || e$1.expectedType == Xt ? e$1.expectedType && "value" !== e$1.expectedType.kind && (o$1 = e$1.expectedType) : o$1 = Rt;
					for (let t$2 = 0; t$2 < s$1.length; t$2 += 2) {
						const r$2 = s$1[t$2], n$2 = s$1[t$2 + 1], i$2 = t$2 + 3, l$1 = t$2 + 4;
						if ("number" != typeof r$2) return e$1.error("Input/output pairs for \"interpolate\" expressions must be defined using literal numeric values (not computed expressions) for the input values.", i$2);
						if (a.length && a[a.length - 1][0] >= r$2) return e$1.error("Input/output pairs for \"interpolate\" expressions must be arranged with input values in strictly ascending order.", i$2);
						const u$1 = e$1.parse(n$2, l$1, o$1);
						if (!u$1) return null;
						o$1 = o$1 || u$1.type, a.push([r$2, u$1]);
					}
					return re(o$1, Ct) || re(o$1, Nt) || re(o$1, Rt) || re(o$1, Gt) || re(o$1, Yt) || re(o$1, Xt) || re(o$1, Ht) || re(o$1, Kt(Ct)) ? new fr(o$1, r$1, n$1, i$1, a) : e$1.error(`Type ${Wt(o$1)} is not interpolatable.`);
				}
				evaluate(t$1) {
					const e$1 = this.labels, r$1 = this.outputs;
					if (1 === e$1.length) return r$1[0].evaluate(t$1);
					const n$1 = this.input.evaluate(t$1);
					if (n$1 <= e$1[0]) return r$1[0].evaluate(t$1);
					const i$1 = e$1.length;
					if (n$1 >= e$1[i$1 - 1]) return r$1[i$1 - 1].evaluate(t$1);
					const s$1 = ar(e$1, n$1), a = fr.interpolationFactor(this.interpolation, n$1, e$1[s$1], e$1[s$1 + 1]), o$1 = r$1[s$1].evaluate(t$1), l$1 = r$1[s$1 + 1].evaluate(t$1);
					switch (this.operator) {
						case "interpolate": switch (this.type.kind) {
							case "number": return ke(o$1, l$1, a);
							case "color": return Te.interpolate(o$1, l$1, a);
							case "padding": return ze.interpolate(o$1, l$1, a);
							case "colorArray": return Be.interpolate(o$1, l$1, a);
							case "numberArray": return Pe.interpolate(o$1, l$1, a);
							case "variableAnchorOffsetCollection": return Le.interpolate(o$1, l$1, a);
							case "array": return Ee(o$1, l$1, a);
							case "projectionDefinition": return Re.interpolate(o$1, l$1, a);
						}
						case "interpolate-hcl": switch (this.type.kind) {
							case "color": return Te.interpolate(o$1, l$1, a, "hcl");
							case "colorArray": return Be.interpolate(o$1, l$1, a, "hcl");
						}
						case "interpolate-lab": switch (this.type.kind) {
							case "color": return Te.interpolate(o$1, l$1, a, "lab");
							case "colorArray": return Be.interpolate(o$1, l$1, a, "lab");
						}
					}
				}
				eachChild(t$1) {
					t$1(this.input);
					for (const e$1 of this.outputs) t$1(e$1);
				}
				outputDefined() {
					return this.outputs.every(((t$1) => t$1.outputDefined()));
				}
			}
			function dr(t$1, e$1, r$1, n$1) {
				const i$1 = n$1 - r$1, s$1 = t$1 - r$1;
				return 0 === i$1 ? 0 : 1 === e$1 ? s$1 / i$1 : (Math.pow(e$1, s$1) - 1) / (Math.pow(e$1, i$1) - 1);
			}
			const yr = {
				color: Te.interpolate,
				number: ke,
				padding: ze.interpolate,
				numberArray: Pe.interpolate,
				colorArray: Be.interpolate,
				variableAnchorOffsetCollection: Le.interpolate,
				array: Ee
			};
			class mr {
				constructor(t$1, e$1) {
					this.type = t$1, this.args = e$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 2) return e$1.error("Expected at least one argument.");
					let r$1 = null;
					const n$1 = e$1.expectedType;
					n$1 && "value" !== n$1.kind && (r$1 = n$1);
					const i$1 = [];
					for (const n$2 of t$1.slice(1)) {
						const t$2 = e$1.parse(n$2, 1 + i$1.length, r$1, void 0, { typeAnnotation: "omit" });
						if (!t$2) return null;
						r$1 = r$1 || t$2.type, i$1.push(t$2);
					}
					if (!r$1) throw new Error("No output type");
					return new mr(n$1 && i$1.some(((t$2) => Qt(n$1, t$2.type))) ? Ut : r$1, i$1);
				}
				evaluate(t$1) {
					let e$1, r$1 = null, n$1 = 0;
					for (const i$1 of this.args) if (n$1++, r$1 = i$1.evaluate(t$1), r$1 && r$1 instanceof Oe && !r$1.available && (e$1 || (e$1 = r$1.name), r$1 = null, n$1 === this.args.length && (r$1 = e$1)), null !== r$1) break;
					return r$1;
				}
				eachChild(t$1) {
					this.args.forEach(t$1);
				}
				outputDefined() {
					return this.args.every(((t$1) => t$1.outputDefined()));
				}
			}
			function gr(t$1, e$1) {
				return "==" === t$1 || "!=" === t$1 ? "boolean" === e$1.kind || "string" === e$1.kind || "number" === e$1.kind || "null" === e$1.kind || "value" === e$1.kind : "string" === e$1.kind || "number" === e$1.kind || "value" === e$1.kind;
			}
			function xr(t$1, e$1, r$1, n$1) {
				return 0 === n$1.compare(e$1, r$1);
			}
			function vr(t$1, e$1, r$1) {
				const n$1 = "==" !== t$1 && "!=" !== t$1;
				return class i$1 {
					constructor(t$2, e$2, r$2) {
						this.type = Ot, this.lhs = t$2, this.rhs = e$2, this.collator = r$2, this.hasUntypedArgument = "value" === t$2.type.kind || "value" === e$2.type.kind;
					}
					static parse(t$2, e$2) {
						if (3 !== t$2.length && 4 !== t$2.length) return e$2.error("Expected two or three arguments.");
						const r$2 = t$2[0];
						let s$1 = e$2.parse(t$2[1], 1, Ut);
						if (!s$1) return null;
						if (!gr(r$2, s$1.type)) return e$2.concat(1).error(`"${r$2}" comparisons are not supported for type '${Wt(s$1.type)}'.`);
						let a = e$2.parse(t$2[2], 2, Ut);
						if (!a) return null;
						if (!gr(r$2, a.type)) return e$2.concat(2).error(`"${r$2}" comparisons are not supported for type '${Wt(a.type)}'.`);
						if (s$1.type.kind !== a.type.kind && "value" !== s$1.type.kind && "value" !== a.type.kind) return e$2.error(`Cannot compare types '${Wt(s$1.type)}' and '${Wt(a.type)}'.`);
						n$1 && ("value" === s$1.type.kind && "value" !== a.type.kind ? s$1 = new Xe(a.type, [s$1]) : "value" !== s$1.type.kind && "value" === a.type.kind && (a = new Xe(s$1.type, [a])));
						let o$1 = null;
						if (4 === t$2.length) {
							if ("string" !== s$1.type.kind && "string" !== a.type.kind && "value" !== s$1.type.kind && "value" !== a.type.kind) return e$2.error("Cannot use collator to compare non-string types.");
							if (o$1 = e$2.parse(t$2[3], 3, qt), !o$1) return null;
						}
						return new i$1(s$1, a, o$1);
					}
					evaluate(i$2) {
						const s$1 = this.lhs.evaluate(i$2), a = this.rhs.evaluate(i$2);
						if (n$1 && this.hasUntypedArgument) {
							const e$2 = Ue(s$1), r$2 = Ue(a);
							if (e$2.kind !== r$2.kind || "string" !== e$2.kind && "number" !== e$2.kind) throw new Ve(`Expected arguments for "${t$1}" to be (string, string) or (number, number), but found (${e$2.kind}, ${r$2.kind}) instead.`);
						}
						if (this.collator && !n$1 && this.hasUntypedArgument) {
							const t$2 = Ue(s$1), r$2 = Ue(a);
							if ("string" !== t$2.kind || "string" !== r$2.kind) return e$1(i$2, s$1, a);
						}
						return this.collator ? r$1(i$2, s$1, a, this.collator.evaluate(i$2)) : e$1(i$2, s$1, a);
					}
					eachChild(t$2) {
						t$2(this.lhs), t$2(this.rhs), this.collator && t$2(this.collator);
					}
					outputDefined() {
						return !0;
					}
				};
			}
			const br = vr("==", (function(t$1, e$1, r$1) {
				return e$1 === r$1;
			}), xr), wr = vr("!=", (function(t$1, e$1, r$1) {
				return e$1 !== r$1;
			}), (function(t$1, e$1, r$1, n$1) {
				return !xr(0, e$1, r$1, n$1);
			})), _r = vr("<", (function(t$1, e$1, r$1) {
				return e$1 < r$1;
			}), (function(t$1, e$1, r$1, n$1) {
				return n$1.compare(e$1, r$1) < 0;
			})), Sr = vr(">", (function(t$1, e$1, r$1) {
				return e$1 > r$1;
			}), (function(t$1, e$1, r$1, n$1) {
				return n$1.compare(e$1, r$1) > 0;
			})), Ar = vr("<=", (function(t$1, e$1, r$1) {
				return e$1 <= r$1;
			}), (function(t$1, e$1, r$1, n$1) {
				return n$1.compare(e$1, r$1) <= 0;
			})), kr = vr(">=", (function(t$1, e$1, r$1) {
				return e$1 >= r$1;
			}), (function(t$1, e$1, r$1, n$1) {
				return n$1.compare(e$1, r$1) >= 0;
			}));
			class Er {
				constructor(t$1, e$1, r$1) {
					this.type = qt, this.locale = r$1, this.caseSensitive = t$1, this.diacriticSensitive = e$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error("Expected one argument.");
					const r$1 = t$1[1];
					if ("object" != typeof r$1 || Array.isArray(r$1)) return e$1.error("Collator options argument must be an object.");
					const n$1 = e$1.parse(void 0 !== r$1["case-sensitive"] && r$1["case-sensitive"], 1, Ot);
					if (!n$1) return null;
					const i$1 = e$1.parse(void 0 !== r$1["diacritic-sensitive"] && r$1["diacritic-sensitive"], 1, Ot);
					if (!i$1) return null;
					let s$1 = null;
					return r$1.locale && (s$1 = e$1.parse(r$1.locale, 1, Lt), !s$1) ? null : new Er(n$1, i$1, s$1);
				}
				evaluate(t$1) {
					return new Ie(this.caseSensitive.evaluate(t$1), this.diacriticSensitive.evaluate(t$1), this.locale ? this.locale.evaluate(t$1) : null);
				}
				eachChild(t$1) {
					t$1(this.caseSensitive), t$1(this.diacriticSensitive), this.locale && t$1(this.locale);
				}
				outputDefined() {
					return !1;
				}
			}
			class Tr {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.type = Lt, this.number = t$1, this.locale = e$1, this.currency = r$1, this.minFractionDigits = n$1, this.maxFractionDigits = i$1;
				}
				static parse(t$1, e$1) {
					if (3 !== t$1.length) return e$1.error("Expected two arguments.");
					const r$1 = e$1.parse(t$1[1], 1, Ct);
					if (!r$1) return null;
					const n$1 = t$1[2];
					if ("object" != typeof n$1 || Array.isArray(n$1)) return e$1.error("NumberFormat options argument must be an object.");
					let i$1 = null;
					if (n$1.locale && (i$1 = e$1.parse(n$1.locale, 1, Lt), !i$1)) return null;
					let s$1 = null;
					if (n$1.currency && (s$1 = e$1.parse(n$1.currency, 1, Lt), !s$1)) return null;
					let a = null;
					if (n$1["min-fraction-digits"] && (a = e$1.parse(n$1["min-fraction-digits"], 1, Ct), !a)) return null;
					let o$1 = null;
					return n$1["max-fraction-digits"] && (o$1 = e$1.parse(n$1["max-fraction-digits"], 1, Ct), !o$1) ? null : new Tr(r$1, i$1, s$1, a, o$1);
				}
				evaluate(t$1) {
					return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t$1) : [], {
						style: this.currency ? "currency" : "decimal",
						currency: this.currency ? this.currency.evaluate(t$1) : void 0,
						minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t$1) : void 0,
						maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t$1) : void 0
					}).format(this.number.evaluate(t$1));
				}
				eachChild(t$1) {
					t$1(this.number), this.locale && t$1(this.locale), this.currency && t$1(this.currency), this.minFractionDigits && t$1(this.minFractionDigits), this.maxFractionDigits && t$1(this.maxFractionDigits);
				}
				outputDefined() {
					return !1;
				}
			}
			class Ir {
				constructor(t$1) {
					this.type = jt, this.sections = t$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 2) return e$1.error("Expected at least one argument.");
					const r$1 = t$1[1];
					if (!Array.isArray(r$1) && "object" == typeof r$1) return e$1.error("First argument must be an image or text section.");
					const n$1 = [];
					let i$1 = !1;
					for (let r$2 = 1; r$2 <= t$1.length - 1; ++r$2) {
						const s$1 = t$1[r$2];
						if (i$1 && "object" == typeof s$1 && !Array.isArray(s$1)) {
							i$1 = !1;
							let t$2 = null;
							if (s$1["font-scale"] && (t$2 = e$1.parse(s$1["font-scale"], 1, Ct), !t$2)) return null;
							let r$3 = null;
							if (s$1["text-font"] && (r$3 = e$1.parse(s$1["text-font"], 1, Kt(Lt)), !r$3)) return null;
							let a = null;
							if (s$1["text-color"] && (a = e$1.parse(s$1["text-color"], 1, Rt), !a)) return null;
							let o$1 = null;
							if (s$1["vertical-align"]) {
								if ("string" == typeof s$1["vertical-align"] && !Me.includes(s$1["vertical-align"])) return e$1.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${s$1["vertical-align"]}' instead.`);
								if (o$1 = e$1.parse(s$1["vertical-align"], 1, Lt), !o$1) return null;
							}
							const l$1 = n$1[n$1.length - 1];
							l$1.scale = t$2, l$1.font = r$3, l$1.textColor = a, l$1.verticalAlign = o$1;
						} else {
							const s$2 = e$1.parse(t$1[r$2], 1, Ut);
							if (!s$2) return null;
							const a = s$2.type.kind;
							if ("string" !== a && "value" !== a && "null" !== a && "resolvedImage" !== a) return e$1.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
							i$1 = !0, n$1.push({
								content: s$2,
								scale: null,
								font: null,
								textColor: null,
								verticalAlign: null
							});
						}
					}
					return new Ir(n$1);
				}
				evaluate(t$1) {
					return new De(this.sections.map(((e$1) => {
						const r$1 = e$1.content.evaluate(t$1);
						return Ue(r$1) === Zt ? new Fe("", r$1, null, null, null, e$1.verticalAlign ? e$1.verticalAlign.evaluate(t$1) : null) : new Fe(qe(r$1), null, e$1.scale ? e$1.scale.evaluate(t$1) : null, e$1.font ? e$1.font.evaluate(t$1).join(",") : null, e$1.textColor ? e$1.textColor.evaluate(t$1) : null, e$1.verticalAlign ? e$1.verticalAlign.evaluate(t$1) : null);
					})));
				}
				eachChild(t$1) {
					for (const e$1 of this.sections) t$1(e$1.content), e$1.scale && t$1(e$1.scale), e$1.font && t$1(e$1.font), e$1.textColor && t$1(e$1.textColor), e$1.verticalAlign && t$1(e$1.verticalAlign);
				}
				outputDefined() {
					return !1;
				}
			}
			class Mr {
				constructor(t$1) {
					this.type = Zt, this.input = t$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error("Expected two arguments.");
					const r$1 = e$1.parse(t$1[1], 1, Lt);
					return r$1 ? new Mr(r$1) : e$1.error("No image name provided.");
				}
				evaluate(t$1) {
					const e$1 = this.input.evaluate(t$1), r$1 = Oe.fromString(e$1);
					return r$1 && t$1.availableImages && (r$1.available = t$1.availableImages.indexOf(e$1) > -1), r$1;
				}
				eachChild(t$1) {
					t$1(this.input);
				}
				outputDefined() {
					return !1;
				}
			}
			class Fr {
				constructor(t$1) {
					this.type = Ct, this.input = t$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error(`Expected 1 argument, but found ${t$1.length - 1} instead.`);
					const r$1 = e$1.parse(t$1[1], 1);
					return r$1 ? "array" !== r$1.type.kind && "string" !== r$1.type.kind && "value" !== r$1.type.kind ? e$1.error(`Expected argument of type string or array, but found ${Wt(r$1.type)} instead.`) : new Fr(r$1) : null;
				}
				evaluate(t$1) {
					const e$1 = this.input.evaluate(t$1);
					if ("string" == typeof e$1) return [...e$1].length;
					if (Array.isArray(e$1)) return e$1.length;
					throw new Ve(`Expected value to be of type string or array, but found ${Wt(Ue(e$1))} instead.`);
				}
				eachChild(t$1) {
					t$1(this.input);
				}
				outputDefined() {
					return !1;
				}
			}
			const Dr = 8192;
			function zr(t$1, e$1) {
				const r$1 = (180 + t$1[0]) / 360, n$1 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t$1[1] * Math.PI / 360))) / 360, i$1 = Math.pow(2, e$1.z);
				return [Math.round(r$1 * i$1 * Dr), Math.round(n$1 * i$1 * Dr)];
			}
			function Pr(t$1, e$1) {
				const r$1 = Math.pow(2, e$1.z);
				return [(i$1 = (t$1[0] / Dr + e$1.x) / r$1, 360 * i$1 - 180), (n$1 = (t$1[1] / Dr + e$1.y) / r$1, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n$1) * Math.PI / 180)) - 90)];
				var n$1, i$1;
			}
			function Br(t$1, e$1) {
				t$1[0] = Math.min(t$1[0], e$1[0]), t$1[1] = Math.min(t$1[1], e$1[1]), t$1[2] = Math.max(t$1[2], e$1[0]), t$1[3] = Math.max(t$1[3], e$1[1]);
			}
			function Vr(t$1, e$1) {
				return !(t$1[0] <= e$1[0] || t$1[2] >= e$1[2] || t$1[1] <= e$1[1] || t$1[3] >= e$1[3]);
			}
			function Cr(t$1, e$1, r$1) {
				const n$1 = t$1[0] - e$1[0], i$1 = t$1[1] - e$1[1], s$1 = t$1[0] - r$1[0], a = t$1[1] - r$1[1];
				return n$1 * a - s$1 * i$1 == 0 && n$1 * s$1 <= 0 && i$1 * a <= 0;
			}
			function Lr(t$1, e$1, r$1, n$1) {
				return 0 != (i$1 = [n$1[0] - r$1[0], n$1[1] - r$1[1]])[0] * (s$1 = [e$1[0] - t$1[0], e$1[1] - t$1[1]])[1] - i$1[1] * s$1[0] && !(!qr(t$1, e$1, r$1, n$1) || !qr(r$1, n$1, t$1, e$1));
				var i$1, s$1;
			}
			function Or(t$1, e$1, r$1) {
				for (const n$1 of r$1) for (let r$2 = 0; r$2 < n$1.length - 1; ++r$2) if (Lr(t$1, e$1, n$1[r$2], n$1[r$2 + 1])) return !0;
				return !1;
			}
			function Rr(t$1, e$1, r$1 = !1) {
				let n$1 = !1;
				for (const o$1 of e$1) for (let e$2 = 0; e$2 < o$1.length - 1; e$2++) {
					if (Cr(t$1, o$1[e$2], o$1[e$2 + 1])) return r$1;
					(s$1 = o$1[e$2])[1] > (i$1 = t$1)[1] != (a = o$1[e$2 + 1])[1] > i$1[1] && i$1[0] < (a[0] - s$1[0]) * (i$1[1] - s$1[1]) / (a[1] - s$1[1]) + s$1[0] && (n$1 = !n$1);
				}
				var i$1, s$1, a;
				return n$1;
			}
			function Nr(t$1, e$1) {
				for (const r$1 of e$1) if (Rr(t$1, r$1)) return !0;
				return !1;
			}
			function $r(t$1, e$1) {
				for (const r$1 of t$1) if (!Rr(r$1, e$1)) return !1;
				for (let r$1 = 0; r$1 < t$1.length - 1; ++r$1) if (Or(t$1[r$1], t$1[r$1 + 1], e$1)) return !1;
				return !0;
			}
			function Ur(t$1, e$1) {
				for (const r$1 of e$1) if ($r(t$1, r$1)) return !0;
				return !1;
			}
			function qr(t$1, e$1, r$1, n$1) {
				const i$1 = n$1[0] - r$1[0], s$1 = n$1[1] - r$1[1], a = (t$1[0] - r$1[0]) * s$1 - i$1 * (t$1[1] - r$1[1]), o$1 = (e$1[0] - r$1[0]) * s$1 - i$1 * (e$1[1] - r$1[1]);
				return a > 0 && o$1 < 0 || a < 0 && o$1 > 0;
			}
			function jr(t$1, e$1, r$1) {
				const n$1 = [];
				for (let i$1 = 0; i$1 < t$1.length; i$1++) {
					const s$1 = [];
					for (let n$2 = 0; n$2 < t$1[i$1].length; n$2++) {
						const a = zr(t$1[i$1][n$2], r$1);
						Br(e$1, a), s$1.push(a);
					}
					n$1.push(s$1);
				}
				return n$1;
			}
			function Gr(t$1, e$1, r$1) {
				const n$1 = [];
				for (let i$1 = 0; i$1 < t$1.length; i$1++) {
					const s$1 = jr(t$1[i$1], e$1, r$1);
					n$1.push(s$1);
				}
				return n$1;
			}
			function Xr(t$1, e$1, r$1, n$1) {
				if (t$1[0] < r$1[0] || t$1[0] > r$1[2]) {
					const e$2 = .5 * n$1;
					let i$1 = t$1[0] - r$1[0] > e$2 ? -n$1 : r$1[0] - t$1[0] > e$2 ? n$1 : 0;
					0 === i$1 && (i$1 = t$1[0] - r$1[2] > e$2 ? -n$1 : r$1[2] - t$1[0] > e$2 ? n$1 : 0), t$1[0] += i$1;
				}
				Br(e$1, t$1);
			}
			function Yr(t$1, e$1, r$1, n$1) {
				const i$1 = Math.pow(2, n$1.z) * Dr, s$1 = [n$1.x * Dr, n$1.y * Dr], a = [];
				for (const n$2 of t$1) for (const t$2 of n$2) {
					const n$3 = [t$2.x + s$1[0], t$2.y + s$1[1]];
					Xr(n$3, e$1, r$1, i$1), a.push(n$3);
				}
				return a;
			}
			function Zr(t$1, e$1, r$1, n$1) {
				const i$1 = Math.pow(2, n$1.z) * Dr, s$1 = [n$1.x * Dr, n$1.y * Dr], a = [];
				for (const r$2 of t$1) {
					const t$2 = [];
					for (const n$2 of r$2) {
						const r$3 = [n$2.x + s$1[0], n$2.y + s$1[1]];
						Br(e$1, r$3), t$2.push(r$3);
					}
					a.push(t$2);
				}
				if (e$1[2] - e$1[0] <= i$1 / 2) {
					(o$1 = e$1)[0] = o$1[1] = Infinity, o$1[2] = o$1[3] = -Infinity;
					for (const t$2 of a) for (const n$2 of t$2) Xr(n$2, e$1, r$1, i$1);
				}
				var o$1;
				return a;
			}
			class Hr {
				constructor(t$1, e$1) {
					this.type = Ot, this.geojson = t$1, this.geometries = e$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error(`'within' expression requires exactly one argument, but found ${t$1.length - 1} instead.`);
					if ($e(t$1[1])) {
						const e$2 = t$1[1];
						if ("FeatureCollection" === e$2.type) {
							const t$2 = [];
							for (const r$1 of e$2.features) {
								const { type: e$3, coordinates: n$1 } = r$1.geometry;
								"Polygon" === e$3 && t$2.push(n$1), "MultiPolygon" === e$3 && t$2.push(...n$1);
							}
							if (t$2.length) return new Hr(e$2, {
								type: "MultiPolygon",
								coordinates: t$2
							});
						} else if ("Feature" === e$2.type) {
							const t$2 = e$2.geometry.type;
							if ("Polygon" === t$2 || "MultiPolygon" === t$2) return new Hr(e$2, e$2.geometry);
						} else if ("Polygon" === e$2.type || "MultiPolygon" === e$2.type) return new Hr(e$2, e$2);
					}
					return e$1.error("'within' expression requires valid geojson object that contains polygon geometry type.");
				}
				evaluate(t$1) {
					if (null != t$1.geometry() && null != t$1.canonicalID()) {
						if ("Point" === t$1.geometryType()) return function(t$2, e$1) {
							const r$1 = [
								Infinity,
								Infinity,
								-Infinity,
								-Infinity
							], n$1 = [
								Infinity,
								Infinity,
								-Infinity,
								-Infinity
							], i$1 = t$2.canonicalID();
							if ("Polygon" === e$1.type) {
								const s$1 = jr(e$1.coordinates, n$1, i$1), a = Yr(t$2.geometry(), r$1, n$1, i$1);
								if (!Vr(r$1, n$1)) return !1;
								for (const t$3 of a) if (!Rr(t$3, s$1)) return !1;
							}
							if ("MultiPolygon" === e$1.type) {
								const s$1 = Gr(e$1.coordinates, n$1, i$1), a = Yr(t$2.geometry(), r$1, n$1, i$1);
								if (!Vr(r$1, n$1)) return !1;
								for (const t$3 of a) if (!Nr(t$3, s$1)) return !1;
							}
							return !0;
						}(t$1, this.geometries);
						if ("LineString" === t$1.geometryType()) return function(t$2, e$1) {
							const r$1 = [
								Infinity,
								Infinity,
								-Infinity,
								-Infinity
							], n$1 = [
								Infinity,
								Infinity,
								-Infinity,
								-Infinity
							], i$1 = t$2.canonicalID();
							if ("Polygon" === e$1.type) {
								const s$1 = jr(e$1.coordinates, n$1, i$1), a = Zr(t$2.geometry(), r$1, n$1, i$1);
								if (!Vr(r$1, n$1)) return !1;
								for (const t$3 of a) if (!$r(t$3, s$1)) return !1;
							}
							if ("MultiPolygon" === e$1.type) {
								const s$1 = Gr(e$1.coordinates, n$1, i$1), a = Zr(t$2.geometry(), r$1, n$1, i$1);
								if (!Vr(r$1, n$1)) return !1;
								for (const t$3 of a) if (!Ur(t$3, s$1)) return !1;
							}
							return !0;
						}(t$1, this.geometries);
					}
					return !1;
				}
				eachChild() {}
				outputDefined() {
					return !0;
				}
			}
			let Kr = class {
				constructor(t$1 = [], e$1 = (t$2, e$2) => t$2 < e$2 ? -1 : t$2 > e$2 ? 1 : 0) {
					if (this.data = t$1, this.length = this.data.length, this.compare = e$1, this.length > 0) for (let t$2 = (this.length >> 1) - 1; t$2 >= 0; t$2--) this._down(t$2);
				}
				push(t$1) {
					this.data.push(t$1), this._up(this.length++);
				}
				pop() {
					if (0 === this.length) return;
					const t$1 = this.data[0], e$1 = this.data.pop();
					return --this.length > 0 && (this.data[0] = e$1, this._down(0)), t$1;
				}
				peek() {
					return this.data[0];
				}
				_up(t$1) {
					const { data: e$1, compare: r$1 } = this, n$1 = e$1[t$1];
					for (; t$1 > 0;) {
						const i$1 = t$1 - 1 >> 1, s$1 = e$1[i$1];
						if (r$1(n$1, s$1) >= 0) break;
						e$1[t$1] = s$1, t$1 = i$1;
					}
					e$1[t$1] = n$1;
				}
				_down(t$1) {
					const { data: e$1, compare: r$1 } = this, n$1 = this.length >> 1, i$1 = e$1[t$1];
					for (; t$1 < n$1;) {
						let n$2 = 1 + (t$1 << 1);
						const s$1 = n$2 + 1;
						if (s$1 < this.length && r$1(e$1[s$1], e$1[n$2]) < 0 && (n$2 = s$1), r$1(e$1[n$2], i$1) >= 0) break;
						e$1[t$1] = e$1[n$2], t$1 = n$2;
					}
					e$1[t$1] = i$1;
				}
			};
			function Wr(t$1, e$1, r$1 = 0, n$1 = t$1.length - 1, i$1 = Qr) {
				for (; n$1 > r$1;) {
					if (n$1 - r$1 > 600) {
						const s$2 = n$1 - r$1 + 1, a$1 = e$1 - r$1 + 1, o$2 = Math.log(s$2), l$1 = .5 * Math.exp(2 * o$2 / 3), u$1 = .5 * Math.sqrt(o$2 * l$1 * (s$2 - l$1) / s$2) * (a$1 - s$2 / 2 < 0 ? -1 : 1);
						Wr(t$1, e$1, Math.max(r$1, Math.floor(e$1 - a$1 * l$1 / s$2 + u$1)), Math.min(n$1, Math.floor(e$1 + (s$2 - a$1) * l$1 / s$2 + u$1)), i$1);
					}
					const s$1 = t$1[e$1];
					let a = r$1, o$1 = n$1;
					for (Jr(t$1, r$1, e$1), i$1(t$1[n$1], s$1) > 0 && Jr(t$1, r$1, n$1); a < o$1;) {
						for (Jr(t$1, a, o$1), a++, o$1--; i$1(t$1[a], s$1) < 0;) a++;
						for (; i$1(t$1[o$1], s$1) > 0;) o$1--;
					}
					0 === i$1(t$1[r$1], s$1) ? Jr(t$1, r$1, o$1) : (o$1++, Jr(t$1, o$1, n$1)), o$1 <= e$1 && (r$1 = o$1 + 1), e$1 <= o$1 && (n$1 = o$1 - 1);
				}
			}
			function Jr(t$1, e$1, r$1) {
				const n$1 = t$1[e$1];
				t$1[e$1] = t$1[r$1], t$1[r$1] = n$1;
			}
			function Qr(t$1, e$1) {
				return t$1 < e$1 ? -1 : t$1 > e$1 ? 1 : 0;
			}
			function tn(t$1, e$1) {
				if (t$1.length <= 1) return [t$1];
				const r$1 = [];
				let n$1, i$1;
				for (const e$2 of t$1) {
					const t$2 = rn(e$2);
					0 !== t$2 && (e$2.area = Math.abs(t$2), void 0 === i$1 && (i$1 = t$2 < 0), i$1 === t$2 < 0 ? (n$1 && r$1.push(n$1), n$1 = [e$2]) : n$1.push(e$2));
				}
				if (n$1 && r$1.push(n$1), e$1 > 1) for (let t$2 = 0; t$2 < r$1.length; t$2++) r$1[t$2].length <= e$1 || (Wr(r$1[t$2], e$1, 1, r$1[t$2].length - 1, en), r$1[t$2] = r$1[t$2].slice(0, e$1));
				return r$1;
			}
			function en(t$1, e$1) {
				return e$1.area - t$1.area;
			}
			function rn(t$1) {
				let e$1 = 0;
				for (let r$1, n$1, i$1 = 0, s$1 = t$1.length, a = s$1 - 1; i$1 < s$1; a = i$1++) r$1 = t$1[i$1], n$1 = t$1[a], e$1 += (n$1.x - r$1.x) * (r$1.y + n$1.y);
				return e$1;
			}
			const nn = 1 / 298.257223563, sn = nn * (2 - nn), an = Math.PI / 180;
			class on {
				constructor(t$1) {
					const e$1 = 6378.137 * an * 1e3, r$1 = Math.cos(t$1 * an), n$1 = 1 / (1 - sn * (1 - r$1 * r$1)), i$1 = Math.sqrt(n$1);
					this.kx = e$1 * i$1 * r$1, this.ky = e$1 * i$1 * n$1 * (1 - sn);
				}
				distance(t$1, e$1) {
					const r$1 = this.wrap(t$1[0] - e$1[0]) * this.kx, n$1 = (t$1[1] - e$1[1]) * this.ky;
					return Math.sqrt(r$1 * r$1 + n$1 * n$1);
				}
				pointOnLine(t$1, e$1) {
					let r$1, n$1, i$1, s$1, a = Infinity;
					for (let o$1 = 0; o$1 < t$1.length - 1; o$1++) {
						let l$1 = t$1[o$1][0], u$1 = t$1[o$1][1], c$1 = this.wrap(t$1[o$1 + 1][0] - l$1) * this.kx, h$1 = (t$1[o$1 + 1][1] - u$1) * this.ky, p$1 = 0;
						0 === c$1 && 0 === h$1 || (p$1 = (this.wrap(e$1[0] - l$1) * this.kx * c$1 + (e$1[1] - u$1) * this.ky * h$1) / (c$1 * c$1 + h$1 * h$1), p$1 > 1 ? (l$1 = t$1[o$1 + 1][0], u$1 = t$1[o$1 + 1][1]) : p$1 > 0 && (l$1 += c$1 / this.kx * p$1, u$1 += h$1 / this.ky * p$1)), c$1 = this.wrap(e$1[0] - l$1) * this.kx, h$1 = (e$1[1] - u$1) * this.ky;
						const f$1 = c$1 * c$1 + h$1 * h$1;
						f$1 < a && (a = f$1, r$1 = l$1, n$1 = u$1, i$1 = o$1, s$1 = p$1);
					}
					return {
						point: [r$1, n$1],
						index: i$1,
						t: Math.max(0, Math.min(1, s$1))
					};
				}
				wrap(t$1) {
					for (; t$1 < -180;) t$1 += 360;
					for (; t$1 > 180;) t$1 -= 360;
					return t$1;
				}
			}
			function ln(t$1, e$1) {
				return e$1[0] - t$1[0];
			}
			function un(t$1) {
				return t$1[1] - t$1[0] + 1;
			}
			function cn(t$1, e$1) {
				return t$1[1] >= t$1[0] && t$1[1] < e$1;
			}
			function hn(t$1, e$1) {
				if (t$1[0] > t$1[1]) return [null, null];
				const r$1 = un(t$1);
				if (e$1) {
					if (2 === r$1) return [t$1, null];
					const e$2 = Math.floor(r$1 / 2);
					return [[t$1[0], t$1[0] + e$2], [t$1[0] + e$2, t$1[1]]];
				}
				if (1 === r$1) return [t$1, null];
				const n$1 = Math.floor(r$1 / 2) - 1;
				return [[t$1[0], t$1[0] + n$1], [t$1[0] + n$1 + 1, t$1[1]]];
			}
			function pn(t$1, e$1) {
				if (!cn(e$1, t$1.length)) return [
					Infinity,
					Infinity,
					-Infinity,
					-Infinity
				];
				const r$1 = [
					Infinity,
					Infinity,
					-Infinity,
					-Infinity
				];
				for (let n$1 = e$1[0]; n$1 <= e$1[1]; ++n$1) Br(r$1, t$1[n$1]);
				return r$1;
			}
			function fn(t$1) {
				const e$1 = [
					Infinity,
					Infinity,
					-Infinity,
					-Infinity
				];
				for (const r$1 of t$1) for (const t$2 of r$1) Br(e$1, t$2);
				return e$1;
			}
			function dn(t$1) {
				return t$1[0] !== -Infinity && t$1[1] !== -Infinity && t$1[2] !== Infinity && t$1[3] !== Infinity;
			}
			function yn(t$1, e$1, r$1) {
				if (!dn(t$1) || !dn(e$1)) return NaN;
				let n$1 = 0, i$1 = 0;
				return t$1[2] < e$1[0] && (n$1 = e$1[0] - t$1[2]), t$1[0] > e$1[2] && (n$1 = t$1[0] - e$1[2]), t$1[1] > e$1[3] && (i$1 = t$1[1] - e$1[3]), t$1[3] < e$1[1] && (i$1 = e$1[1] - t$1[3]), r$1.distance([0, 0], [n$1, i$1]);
			}
			function mn(t$1, e$1, r$1) {
				const n$1 = r$1.pointOnLine(e$1, t$1);
				return r$1.distance(t$1, n$1.point);
			}
			function gn(t$1, e$1, r$1, n$1, i$1) {
				const s$1 = Math.min(mn(t$1, [r$1, n$1], i$1), mn(e$1, [r$1, n$1], i$1)), a = Math.min(mn(r$1, [t$1, e$1], i$1), mn(n$1, [t$1, e$1], i$1));
				return Math.min(s$1, a);
			}
			function xn(t$1, e$1, r$1, n$1, i$1) {
				if (!cn(e$1, t$1.length) || !cn(n$1, r$1.length)) return Infinity;
				let s$1 = Infinity;
				for (let a = e$1[0]; a < e$1[1]; ++a) {
					const e$2 = t$1[a], o$1 = t$1[a + 1];
					for (let t$2 = n$1[0]; t$2 < n$1[1]; ++t$2) {
						const n$2 = r$1[t$2], a$1 = r$1[t$2 + 1];
						if (Lr(e$2, o$1, n$2, a$1)) return 0;
						s$1 = Math.min(s$1, gn(e$2, o$1, n$2, a$1, i$1));
					}
				}
				return s$1;
			}
			function vn(t$1, e$1, r$1, n$1, i$1) {
				if (!cn(e$1, t$1.length) || !cn(n$1, r$1.length)) return NaN;
				let s$1 = Infinity;
				for (let a = e$1[0]; a <= e$1[1]; ++a) for (let e$2 = n$1[0]; e$2 <= n$1[1]; ++e$2) if (s$1 = Math.min(s$1, i$1.distance(t$1[a], r$1[e$2])), 0 === s$1) return s$1;
				return s$1;
			}
			function bn(t$1, e$1, r$1) {
				if (Rr(t$1, e$1, !0)) return 0;
				let n$1 = Infinity;
				for (const i$1 of e$1) {
					const e$2 = i$1[0], s$1 = i$1[i$1.length - 1];
					if (e$2 !== s$1 && (n$1 = Math.min(n$1, mn(t$1, [s$1, e$2], r$1)), 0 === n$1)) return n$1;
					const a = r$1.pointOnLine(i$1, t$1);
					if (n$1 = Math.min(n$1, r$1.distance(t$1, a.point)), 0 === n$1) return n$1;
				}
				return n$1;
			}
			function wn(t$1, e$1, r$1, n$1) {
				if (!cn(e$1, t$1.length)) return NaN;
				for (let n$2 = e$1[0]; n$2 <= e$1[1]; ++n$2) if (Rr(t$1[n$2], r$1, !0)) return 0;
				let i$1 = Infinity;
				for (let s$1 = e$1[0]; s$1 < e$1[1]; ++s$1) {
					const e$2 = t$1[s$1], a = t$1[s$1 + 1];
					for (const t$2 of r$1) for (let r$2 = 0, s$2 = t$2.length, o$1 = s$2 - 1; r$2 < s$2; o$1 = r$2++) {
						const s$3 = t$2[o$1], l$1 = t$2[r$2];
						if (Lr(e$2, a, s$3, l$1)) return 0;
						i$1 = Math.min(i$1, gn(e$2, a, s$3, l$1, n$1));
					}
				}
				return i$1;
			}
			function _n(t$1, e$1) {
				for (const r$1 of t$1) for (const t$2 of r$1) if (Rr(t$2, e$1, !0)) return !0;
				return !1;
			}
			function Sn(t$1, e$1, r$1, n$1 = Infinity) {
				const i$1 = fn(t$1), s$1 = fn(e$1);
				if (n$1 !== Infinity && yn(i$1, s$1, r$1) >= n$1) return n$1;
				if (Vr(i$1, s$1)) {
					if (_n(t$1, e$1)) return 0;
				} else if (_n(e$1, t$1)) return 0;
				let a = Infinity;
				for (const n$2 of t$1) for (let t$2 = 0, i$2 = n$2.length, s$2 = i$2 - 1; t$2 < i$2; s$2 = t$2++) {
					const i$3 = n$2[s$2], o$1 = n$2[t$2];
					for (const t$3 of e$1) for (let e$2 = 0, n$3 = t$3.length, s$3 = n$3 - 1; e$2 < n$3; s$3 = e$2++) {
						const n$4 = t$3[s$3], l$1 = t$3[e$2];
						if (Lr(i$3, o$1, n$4, l$1)) return 0;
						a = Math.min(a, gn(i$3, o$1, n$4, l$1, r$1));
					}
				}
				return a;
			}
			function An(t$1, e$1, r$1, n$1, i$1, s$1) {
				if (!s$1) return;
				const a = yn(pn(n$1, s$1), i$1, r$1);
				a < e$1 && t$1.push([
					a,
					s$1,
					[0, 0]
				]);
			}
			function kn(t$1, e$1, r$1, n$1, i$1, s$1, a) {
				if (!s$1 || !a) return;
				const o$1 = yn(pn(n$1, s$1), pn(i$1, a), r$1);
				o$1 < e$1 && t$1.push([
					o$1,
					s$1,
					a
				]);
			}
			function En(t$1, e$1, r$1, n$1, i$1 = Infinity) {
				let s$1 = Math.min(n$1.distance(t$1[0], r$1[0][0]), i$1);
				if (0 === s$1) return s$1;
				const a = new Kr([[
					0,
					[0, t$1.length - 1],
					[0, 0]
				]], ln), o$1 = fn(r$1);
				for (; a.length > 0;) {
					const i$2 = a.pop();
					if (i$2[0] >= s$1) continue;
					const l$1 = i$2[1], u$1 = e$1 ? 50 : 100;
					if (un(l$1) <= u$1) {
						if (!cn(l$1, t$1.length)) return NaN;
						if (e$1) {
							const e$2 = wn(t$1, l$1, r$1, n$1);
							if (isNaN(e$2) || 0 === e$2) return e$2;
							s$1 = Math.min(s$1, e$2);
						} else for (let e$2 = l$1[0]; e$2 <= l$1[1]; ++e$2) {
							const i$3 = bn(t$1[e$2], r$1, n$1);
							if (s$1 = Math.min(s$1, i$3), 0 === s$1) return 0;
						}
					} else {
						const r$2 = hn(l$1, e$1);
						An(a, s$1, n$1, t$1, o$1, r$2[0]), An(a, s$1, n$1, t$1, o$1, r$2[1]);
					}
				}
				return s$1;
			}
			function Tn(t$1, e$1, r$1, n$1, i$1, s$1 = Infinity) {
				let a = Math.min(s$1, i$1.distance(t$1[0], r$1[0]));
				if (0 === a) return a;
				const o$1 = new Kr([[
					0,
					[0, t$1.length - 1],
					[0, r$1.length - 1]
				]], ln);
				for (; o$1.length > 0;) {
					const s$2 = o$1.pop();
					if (s$2[0] >= a) continue;
					const l$1 = s$2[1], u$1 = s$2[2], c$1 = e$1 ? 50 : 100, h$1 = n$1 ? 50 : 100;
					if (un(l$1) <= c$1 && un(u$1) <= h$1) {
						if (!cn(l$1, t$1.length) && cn(u$1, r$1.length)) return NaN;
						let s$3;
						if (e$1 && n$1) s$3 = xn(t$1, l$1, r$1, u$1, i$1), a = Math.min(a, s$3);
						else if (e$1 && !n$1) {
							const e$2 = t$1.slice(l$1[0], l$1[1] + 1);
							for (let t$2 = u$1[0]; t$2 <= u$1[1]; ++t$2) if (s$3 = mn(r$1[t$2], e$2, i$1), a = Math.min(a, s$3), 0 === a) return a;
						} else if (!e$1 && n$1) {
							const e$2 = r$1.slice(u$1[0], u$1[1] + 1);
							for (let r$2 = l$1[0]; r$2 <= l$1[1]; ++r$2) if (s$3 = mn(t$1[r$2], e$2, i$1), a = Math.min(a, s$3), 0 === a) return a;
						} else s$3 = vn(t$1, l$1, r$1, u$1, i$1), a = Math.min(a, s$3);
					} else {
						const s$3 = hn(l$1, e$1), c$2 = hn(u$1, n$1);
						kn(o$1, a, i$1, t$1, r$1, s$3[0], c$2[0]), kn(o$1, a, i$1, t$1, r$1, s$3[0], c$2[1]), kn(o$1, a, i$1, t$1, r$1, s$3[1], c$2[0]), kn(o$1, a, i$1, t$1, r$1, s$3[1], c$2[1]);
					}
				}
				return a;
			}
			function In(t$1) {
				return "MultiPolygon" === t$1.type ? t$1.coordinates.map(((t$2) => ({
					type: "Polygon",
					coordinates: t$2
				}))) : "MultiLineString" === t$1.type ? t$1.coordinates.map(((t$2) => ({
					type: "LineString",
					coordinates: t$2
				}))) : "MultiPoint" === t$1.type ? t$1.coordinates.map(((t$2) => ({
					type: "Point",
					coordinates: t$2
				}))) : [t$1];
			}
			class Mn {
				constructor(t$1, e$1) {
					this.type = Ct, this.geojson = t$1, this.geometries = e$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error(`'distance' expression requires exactly one argument, but found ${t$1.length - 1} instead.`);
					if ($e(t$1[1])) {
						const e$2 = t$1[1];
						if ("FeatureCollection" === e$2.type) return new Mn(e$2, e$2.features.map(((t$2) => In(t$2.geometry))).flat());
						if ("Feature" === e$2.type) return new Mn(e$2, In(e$2.geometry));
						if ("type" in e$2 && "coordinates" in e$2) return new Mn(e$2, In(e$2));
					}
					return e$1.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
				}
				evaluate(t$1) {
					if (null != t$1.geometry() && null != t$1.canonicalID()) {
						if ("Point" === t$1.geometryType()) return function(t$2, e$1) {
							const r$1 = t$2.geometry(), n$1 = r$1.flat().map(((e$2) => Pr([e$2.x, e$2.y], t$2.canonical)));
							if (0 === r$1.length) return NaN;
							const i$1 = new on(n$1[0][1]);
							let s$1 = Infinity;
							for (const t$3 of e$1) {
								switch (t$3.type) {
									case "Point":
										s$1 = Math.min(s$1, Tn(n$1, !1, [t$3.coordinates], !1, i$1, s$1));
										break;
									case "LineString":
										s$1 = Math.min(s$1, Tn(n$1, !1, t$3.coordinates, !0, i$1, s$1));
										break;
									case "Polygon": s$1 = Math.min(s$1, En(n$1, !1, t$3.coordinates, i$1, s$1));
								}
								if (0 === s$1) return s$1;
							}
							return s$1;
						}(t$1, this.geometries);
						if ("LineString" === t$1.geometryType()) return function(t$2, e$1) {
							const r$1 = t$2.geometry(), n$1 = r$1.flat().map(((e$2) => Pr([e$2.x, e$2.y], t$2.canonical)));
							if (0 === r$1.length) return NaN;
							const i$1 = new on(n$1[0][1]);
							let s$1 = Infinity;
							for (const t$3 of e$1) {
								switch (t$3.type) {
									case "Point":
										s$1 = Math.min(s$1, Tn(n$1, !0, [t$3.coordinates], !1, i$1, s$1));
										break;
									case "LineString":
										s$1 = Math.min(s$1, Tn(n$1, !0, t$3.coordinates, !0, i$1, s$1));
										break;
									case "Polygon": s$1 = Math.min(s$1, En(n$1, !0, t$3.coordinates, i$1, s$1));
								}
								if (0 === s$1) return s$1;
							}
							return s$1;
						}(t$1, this.geometries);
						if ("Polygon" === t$1.geometryType()) return function(t$2, e$1) {
							const r$1 = t$2.geometry();
							if (0 === r$1.length || 0 === r$1[0].length) return NaN;
							const n$1 = tn(r$1, 0).map(((e$2) => e$2.map(((e$3) => e$3.map(((e$4) => Pr([e$4.x, e$4.y], t$2.canonical))))))), i$1 = new on(n$1[0][0][0][1]);
							let s$1 = Infinity;
							for (const t$3 of e$1) for (const e$2 of n$1) {
								switch (t$3.type) {
									case "Point":
										s$1 = Math.min(s$1, En([t$3.coordinates], !1, e$2, i$1, s$1));
										break;
									case "LineString":
										s$1 = Math.min(s$1, En(t$3.coordinates, !0, e$2, i$1, s$1));
										break;
									case "Polygon": s$1 = Math.min(s$1, Sn(e$2, t$3.coordinates, i$1, s$1));
								}
								if (0 === s$1) return s$1;
							}
							return s$1;
						}(t$1, this.geometries);
					}
					return NaN;
				}
				eachChild() {}
				outputDefined() {
					return !0;
				}
			}
			class Fn {
				constructor(t$1) {
					this.type = Ut, this.key = t$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error(`Expected 1 argument, but found ${t$1.length - 1} instead.`);
					const r$1 = t$1[1];
					return null == r$1 ? e$1.error("Global state property must be defined.") : "string" != typeof r$1 ? e$1.error(`Global state property must be string, but found ${typeof t$1[1]} instead.`) : new Fn(r$1);
				}
				evaluate(t$1) {
					var e$1;
					const r$1 = null === (e$1 = t$1.globals) || void 0 === e$1 ? void 0 : e$1.globalState;
					return r$1 && 0 !== Object.keys(r$1).length ? ve(r$1, this.key) : null;
				}
				eachChild() {}
				outputDefined() {
					return !1;
				}
			}
			const Dn = {
				"==": br,
				"!=": wr,
				">": Sr,
				"<": _r,
				">=": kr,
				"<=": Ar,
				array: Xe,
				at: tr,
				boolean: Xe,
				case: ir,
				coalesce: mr,
				collator: Er,
				format: Ir,
				image: Mr,
				in: er,
				"index-of": rr,
				interpolate: fr,
				"interpolate-hcl": fr,
				"interpolate-lab": fr,
				length: Fr,
				let: Je,
				literal: je,
				match: nr,
				number: Xe,
				"number-format": Tr,
				object: Xe,
				slice: sr,
				step: or,
				string: Xe,
				"to-boolean": Ze,
				"to-color": Ze,
				"to-number": Ze,
				"to-string": Ze,
				var: Qe,
				within: Hr,
				distance: Mn,
				"global-state": Fn
			};
			class zn {
				constructor(t$1, e$1, r$1, n$1) {
					this.name = t$1, this.type = e$1, this._evaluate = r$1, this.args = n$1;
				}
				evaluate(t$1) {
					return this._evaluate(t$1, this.args);
				}
				eachChild(t$1) {
					this.args.forEach(t$1);
				}
				outputDefined() {
					return !1;
				}
				static parse(t$1, e$1) {
					const r$1 = t$1[0], n$1 = zn.definitions[r$1];
					if (!n$1) return e$1.error(`Unknown expression "${r$1}". If you wanted a literal array, use ["literal", [...]].`, 0);
					const i$1 = Array.isArray(n$1) ? n$1[0] : n$1.type, s$1 = Array.isArray(n$1) ? [[n$1[1], n$1[2]]] : n$1.overloads, a = s$1.filter((([e$2]) => !Array.isArray(e$2) || e$2.length === t$1.length - 1));
					let o$1 = null;
					for (const [n$2, s$2] of a) {
						o$1 = new We(e$1.registry, Ln, e$1.path, null, e$1.scope);
						const a$1 = [];
						let l$1 = !1;
						for (let e$2 = 1; e$2 < t$1.length; e$2++) {
							const r$2 = t$1[e$2], i$2 = Array.isArray(n$2) ? n$2[e$2 - 1] : n$2.type, s$3 = o$1.parse(r$2, 1 + a$1.length, i$2);
							if (!s$3) {
								l$1 = !0;
								break;
							}
							a$1.push(s$3);
						}
						if (!l$1) if (Array.isArray(n$2) && n$2.length !== a$1.length) o$1.error(`Expected ${n$2.length} arguments, but found ${a$1.length} instead.`);
						else {
							for (let t$2 = 0; t$2 < a$1.length; t$2++) {
								const e$2 = Array.isArray(n$2) ? n$2[t$2] : n$2.type, r$2 = a$1[t$2];
								o$1.concat(t$2 + 1).checkSubtype(e$2, r$2.type);
							}
							if (0 === o$1.errors.length) return new zn(r$1, i$1, s$2, a$1);
						}
					}
					if (1 === a.length) e$1.errors.push(...o$1.errors);
					else {
						const r$2 = (a.length ? a : s$1).map((([t$2]) => {
							return e$2 = t$2, Array.isArray(e$2) ? `(${e$2.map(Wt).join(", ")})` : `(${Wt(e$2.type)}...)`;
							var e$2;
						})).join(" | "), n$2 = [];
						for (let r$3 = 1; r$3 < t$1.length; r$3++) {
							const i$2 = e$1.parse(t$1[r$3], 1 + n$2.length);
							if (!i$2) return null;
							n$2.push(Wt(i$2.type));
						}
						e$1.error(`Expected arguments of type ${r$2}, but found (${n$2.join(", ")}) instead.`);
					}
					return null;
				}
				static register(t$1, e$1) {
					zn.definitions = e$1;
					for (const r$1 in e$1) t$1[r$1] = zn;
				}
			}
			function Pn(t$1, [e$1, r$1, n$1, i$1]) {
				e$1 = e$1.evaluate(t$1), r$1 = r$1.evaluate(t$1), n$1 = n$1.evaluate(t$1);
				const s$1 = i$1 ? i$1.evaluate(t$1) : 1, a = Ne(e$1, r$1, n$1, s$1);
				if (a) throw new Ve(a);
				return new Te(e$1 / 255, r$1 / 255, n$1 / 255, s$1, !1);
			}
			function Bn(t$1, e$1) {
				return t$1 in e$1;
			}
			function Vn(t$1, e$1) {
				const r$1 = e$1[t$1];
				return void 0 === r$1 ? null : r$1;
			}
			function Cn(t$1) {
				return { type: t$1 };
			}
			function Ln(t$1) {
				if (t$1 instanceof Qe) return Ln(t$1.boundExpression);
				if (t$1 instanceof zn && "error" === t$1.name) return !1;
				if (t$1 instanceof Er) return !1;
				if (t$1 instanceof Hr) return !1;
				if (t$1 instanceof Mn) return !1;
				if (t$1 instanceof Fn) return !1;
				const e$1 = t$1 instanceof Ze || t$1 instanceof Xe;
				let r$1 = !0;
				return t$1.eachChild(((t$2) => {
					r$1 = e$1 ? r$1 && Ln(t$2) : r$1 && t$2 instanceof je;
				})), !!r$1 && On(t$1) && Nn(t$1, [
					"zoom",
					"heatmap-density",
					"elevation",
					"line-progress",
					"accumulated",
					"is-supported-script"
				]);
			}
			function On(t$1) {
				if (t$1 instanceof zn) {
					if ("get" === t$1.name && 1 === t$1.args.length) return !1;
					if ("feature-state" === t$1.name) return !1;
					if ("has" === t$1.name && 1 === t$1.args.length) return !1;
					if ("properties" === t$1.name || "geometry-type" === t$1.name || "id" === t$1.name) return !1;
					if (/^filter-/.test(t$1.name)) return !1;
				}
				if (t$1 instanceof Hr) return !1;
				if (t$1 instanceof Mn) return !1;
				let e$1 = !0;
				return t$1.eachChild(((t$2) => {
					e$1 && !On(t$2) && (e$1 = !1);
				})), e$1;
			}
			function Rn(t$1) {
				if (t$1 instanceof zn && "feature-state" === t$1.name) return !1;
				let e$1 = !0;
				return t$1.eachChild(((t$2) => {
					e$1 && !Rn(t$2) && (e$1 = !1);
				})), e$1;
			}
			function Nn(t$1, e$1) {
				if (t$1 instanceof zn && e$1.indexOf(t$1.name) >= 0) return !1;
				let r$1 = !0;
				return t$1.eachChild(((t$2) => {
					r$1 && !Nn(t$2, e$1) && (r$1 = !1);
				})), r$1;
			}
			function $n(t$1) {
				return {
					result: "success",
					value: t$1
				};
			}
			function Un(t$1) {
				return {
					result: "error",
					value: t$1
				};
			}
			function qn(t$1) {
				return "data-driven" === t$1["property-type"] || "cross-faded-data-driven" === t$1["property-type"];
			}
			function jn(t$1) {
				return !!t$1.expression && t$1.expression.parameters.indexOf("zoom") > -1;
			}
			function Gn(t$1) {
				return !!t$1.expression && t$1.expression.interpolated;
			}
			function Xn(t$1) {
				return t$1 instanceof Number ? "number" : t$1 instanceof String ? "string" : t$1 instanceof Boolean ? "boolean" : Array.isArray(t$1) ? "array" : null === t$1 ? "null" : typeof t$1;
			}
			function Yn(t$1) {
				return "object" == typeof t$1 && null !== t$1 && !Array.isArray(t$1) && Ue(t$1) === $t;
			}
			function Zn(t$1) {
				return t$1;
			}
			function Hn(t$1, e$1) {
				const r$1 = t$1.stops && "object" == typeof t$1.stops[0][0], n$1 = r$1 || !(r$1 || void 0 !== t$1.property), i$1 = t$1.type || (Gn(e$1) ? "exponential" : "interval"), s$1 = function(t$2) {
					switch (t$2.type) {
						case "color": return Te.parse;
						case "padding": return ze.parse;
						case "numberArray": return Pe.parse;
						case "colorArray": return Be.parse;
						default: return null;
					}
				}(e$1);
				if (s$1 && ((t$1 = zt({}, t$1)).stops && (t$1.stops = t$1.stops.map(((t$2) => [t$2[0], s$1(t$2[1])]))), t$1.default = s$1(t$1.default ? t$1.default : e$1.default)), t$1.colorSpace && "rgb" !== (a = t$1.colorSpace) && "hcl" !== a && "lab" !== a) throw new Error(`Unknown color space: "${t$1.colorSpace}"`);
				var a;
				const o$1 = function(t$2) {
					switch (t$2) {
						case "exponential": return Qn;
						case "interval": return Jn;
						case "categorical": return Wn;
						case "identity": return ti;
						default: throw new Error(`Unknown function type "${t$2}"`);
					}
				}(i$1);
				let l$1, u$1;
				if ("categorical" === i$1) {
					l$1 = Object.create(null);
					for (const e$2 of t$1.stops) l$1[e$2[0]] = e$2[1];
					u$1 = typeof t$1.stops[0][0];
				}
				if (r$1) {
					const r$2 = {}, n$2 = [];
					for (let e$2 = 0; e$2 < t$1.stops.length; e$2++) {
						const i$3 = t$1.stops[e$2], s$3 = i$3[0].zoom;
						void 0 === r$2[s$3] && (r$2[s$3] = {
							zoom: s$3,
							type: t$1.type,
							property: t$1.property,
							default: t$1.default,
							stops: []
						}, n$2.push(s$3)), r$2[s$3].stops.push([i$3[0].value, i$3[1]]);
					}
					const i$2 = [];
					for (const t$2 of n$2) i$2.push([r$2[t$2].zoom, Hn(r$2[t$2], e$1)]);
					const s$2 = { name: "linear" };
					return {
						kind: "composite",
						interpolationType: s$2,
						interpolationFactor: fr.interpolationFactor.bind(void 0, s$2),
						zoomStops: i$2.map(((t$2) => t$2[0])),
						evaluate: ({ zoom: r$3 }, n$3) => Qn({
							stops: i$2,
							base: t$1.base
						}, e$1, r$3).evaluate(r$3, n$3)
					};
				}
				if (n$1) {
					const r$2 = "exponential" === i$1 ? {
						name: "exponential",
						base: void 0 !== t$1.base ? t$1.base : 1
					} : null;
					return {
						kind: "camera",
						interpolationType: r$2,
						interpolationFactor: fr.interpolationFactor.bind(void 0, r$2),
						zoomStops: t$1.stops.map(((t$2) => t$2[0])),
						evaluate: ({ zoom: r$3 }) => o$1(t$1, e$1, r$3, l$1, u$1)
					};
				}
				return {
					kind: "source",
					evaluate(r$2, n$2) {
						const i$2 = n$2 && n$2.properties ? n$2.properties[t$1.property] : void 0;
						return void 0 === i$2 ? Kn(t$1.default, e$1.default) : o$1(t$1, e$1, i$2, l$1, u$1);
					}
				};
			}
			function Kn(t$1, e$1, r$1) {
				return void 0 !== t$1 ? t$1 : void 0 !== e$1 ? e$1 : void 0 !== r$1 ? r$1 : void 0;
			}
			function Wn(t$1, e$1, r$1, n$1, i$1) {
				return Kn(typeof r$1 === i$1 ? n$1[r$1] : void 0, t$1.default, e$1.default);
			}
			function Jn(t$1, e$1, r$1) {
				if ("number" !== Xn(r$1)) return Kn(t$1.default, e$1.default);
				const n$1 = t$1.stops.length;
				if (1 === n$1) return t$1.stops[0][1];
				if (r$1 <= t$1.stops[0][0]) return t$1.stops[0][1];
				if (r$1 >= t$1.stops[n$1 - 1][0]) return t$1.stops[n$1 - 1][1];
				const i$1 = ar(t$1.stops.map(((t$2) => t$2[0])), r$1);
				return t$1.stops[i$1][1];
			}
			function Qn(t$1, e$1, r$1) {
				const n$1 = void 0 !== t$1.base ? t$1.base : 1;
				if ("number" !== Xn(r$1)) return Kn(t$1.default, e$1.default);
				const i$1 = t$1.stops.length;
				if (1 === i$1) return t$1.stops[0][1];
				if (r$1 <= t$1.stops[0][0]) return t$1.stops[0][1];
				if (r$1 >= t$1.stops[i$1 - 1][0]) return t$1.stops[i$1 - 1][1];
				const s$1 = ar(t$1.stops.map(((t$2) => t$2[0])), r$1), a = function(t$2, e$2, r$2, n$2) {
					const i$2 = n$2 - r$2, s$2 = t$2 - r$2;
					return 0 === i$2 ? 0 : 1 === e$2 ? s$2 / i$2 : (Math.pow(e$2, s$2) - 1) / (Math.pow(e$2, i$2) - 1);
				}(r$1, n$1, t$1.stops[s$1][0], t$1.stops[s$1 + 1][0]), o$1 = t$1.stops[s$1][1], l$1 = t$1.stops[s$1 + 1][1], u$1 = yr[e$1.type] || Zn;
				return "function" == typeof o$1.evaluate ? { evaluate(...e$2) {
					const r$2 = o$1.evaluate.apply(void 0, e$2), n$2 = l$1.evaluate.apply(void 0, e$2);
					if (void 0 !== r$2 && void 0 !== n$2) return u$1(r$2, n$2, a, t$1.colorSpace);
				} } : u$1(o$1, l$1, a, t$1.colorSpace);
			}
			function ti(t$1, e$1, r$1) {
				switch (e$1.type) {
					case "color":
						r$1 = Te.parse(r$1);
						break;
					case "formatted":
						r$1 = De.fromString(r$1.toString());
						break;
					case "resolvedImage":
						r$1 = Oe.fromString(r$1.toString());
						break;
					case "padding":
						r$1 = ze.parse(r$1);
						break;
					case "colorArray":
						r$1 = Be.parse(r$1);
						break;
					case "numberArray":
						r$1 = Pe.parse(r$1);
						break;
					default: Xn(r$1) === e$1.type || "enum" === e$1.type && e$1.values[r$1] || (r$1 = void 0);
				}
				return Kn(r$1, t$1.default, e$1.default);
			}
			zn.register(Dn, {
				error: [
					{ kind: "error" },
					[Lt],
					(t$1, [e$1]) => {
						throw new Ve(e$1.evaluate(t$1));
					}
				],
				typeof: [
					Lt,
					[Ut],
					(t$1, [e$1]) => Wt(Ue(e$1.evaluate(t$1)))
				],
				"to-rgba": [
					Kt(Ct, 4),
					[Rt],
					(t$1, [e$1]) => {
						const [r$1, n$1, i$1, s$1] = e$1.evaluate(t$1).rgb;
						return [
							255 * r$1,
							255 * n$1,
							255 * i$1,
							s$1
						];
					}
				],
				rgb: [
					Rt,
					[
						Ct,
						Ct,
						Ct
					],
					Pn
				],
				rgba: [
					Rt,
					[
						Ct,
						Ct,
						Ct,
						Ct
					],
					Pn
				],
				has: {
					type: Ot,
					overloads: [[[Lt], (t$1, [e$1]) => Bn(e$1.evaluate(t$1), t$1.properties())], [[Lt, $t], (t$1, [e$1, r$1]) => Bn(e$1.evaluate(t$1), r$1.evaluate(t$1))]]
				},
				get: {
					type: Ut,
					overloads: [[[Lt], (t$1, [e$1]) => Vn(e$1.evaluate(t$1), t$1.properties())], [[Lt, $t], (t$1, [e$1, r$1]) => Vn(e$1.evaluate(t$1), r$1.evaluate(t$1))]]
				},
				"feature-state": [
					Ut,
					[Lt],
					(t$1, [e$1]) => Vn(e$1.evaluate(t$1), t$1.featureState || {})
				],
				properties: [
					$t,
					[],
					(t$1) => t$1.properties()
				],
				"geometry-type": [
					Lt,
					[],
					(t$1) => t$1.geometryType()
				],
				id: [
					Ut,
					[],
					(t$1) => t$1.id()
				],
				zoom: [
					Ct,
					[],
					(t$1) => t$1.globals.zoom
				],
				"heatmap-density": [
					Ct,
					[],
					(t$1) => t$1.globals.heatmapDensity || 0
				],
				elevation: [
					Ct,
					[],
					(t$1) => t$1.globals.elevation || 0
				],
				"line-progress": [
					Ct,
					[],
					(t$1) => t$1.globals.lineProgress || 0
				],
				accumulated: [
					Ut,
					[],
					(t$1) => void 0 === t$1.globals.accumulated ? null : t$1.globals.accumulated
				],
				"+": [
					Ct,
					Cn(Ct),
					(t$1, e$1) => {
						let r$1 = 0;
						for (const n$1 of e$1) r$1 += n$1.evaluate(t$1);
						return r$1;
					}
				],
				"*": [
					Ct,
					Cn(Ct),
					(t$1, e$1) => {
						let r$1 = 1;
						for (const n$1 of e$1) r$1 *= n$1.evaluate(t$1);
						return r$1;
					}
				],
				"-": {
					type: Ct,
					overloads: [[[Ct, Ct], (t$1, [e$1, r$1]) => e$1.evaluate(t$1) - r$1.evaluate(t$1)], [[Ct], (t$1, [e$1]) => -e$1.evaluate(t$1)]]
				},
				"/": [
					Ct,
					[Ct, Ct],
					(t$1, [e$1, r$1]) => e$1.evaluate(t$1) / r$1.evaluate(t$1)
				],
				"%": [
					Ct,
					[Ct, Ct],
					(t$1, [e$1, r$1]) => e$1.evaluate(t$1) % r$1.evaluate(t$1)
				],
				ln2: [
					Ct,
					[],
					() => Math.LN2
				],
				pi: [
					Ct,
					[],
					() => Math.PI
				],
				e: [
					Ct,
					[],
					() => Math.E
				],
				"^": [
					Ct,
					[Ct, Ct],
					(t$1, [e$1, r$1]) => Math.pow(e$1.evaluate(t$1), r$1.evaluate(t$1))
				],
				sqrt: [
					Ct,
					[Ct],
					(t$1, [e$1]) => Math.sqrt(e$1.evaluate(t$1))
				],
				log10: [
					Ct,
					[Ct],
					(t$1, [e$1]) => Math.log(e$1.evaluate(t$1)) / Math.LN10
				],
				ln: [
					Ct,
					[Ct],
					(t$1, [e$1]) => Math.log(e$1.evaluate(t$1))
				],
				log2: [
					Ct,
					[Ct],
					(t$1, [e$1]) => Math.log(e$1.evaluate(t$1)) / Math.LN2
				],
				sin: [
					Ct,
					[Ct],
					(t$1, [e$1]) => Math.sin(e$1.evaluate(t$1))
				],
				cos: [
					Ct,
					[Ct],
					(t$1, [e$1]) => Math.cos(e$1.evaluate(t$1))
				],
				tan: [
					Ct,
					[Ct],
					(t$1, [e$1]) => Math.tan(e$1.evaluate(t$1))
				],
				asin: [
					Ct,
					[Ct],
					(t$1, [e$1]) => Math.asin(e$1.evaluate(t$1))
				],
				acos: [
					Ct,
					[Ct],
					(t$1, [e$1]) => Math.acos(e$1.evaluate(t$1))
				],
				atan: [
					Ct,
					[Ct],
					(t$1, [e$1]) => Math.atan(e$1.evaluate(t$1))
				],
				min: [
					Ct,
					Cn(Ct),
					(t$1, e$1) => Math.min(...e$1.map(((e$2) => e$2.evaluate(t$1))))
				],
				max: [
					Ct,
					Cn(Ct),
					(t$1, e$1) => Math.max(...e$1.map(((e$2) => e$2.evaluate(t$1))))
				],
				abs: [
					Ct,
					[Ct],
					(t$1, [e$1]) => Math.abs(e$1.evaluate(t$1))
				],
				round: [
					Ct,
					[Ct],
					(t$1, [e$1]) => {
						const r$1 = e$1.evaluate(t$1);
						return r$1 < 0 ? -Math.round(-r$1) : Math.round(r$1);
					}
				],
				floor: [
					Ct,
					[Ct],
					(t$1, [e$1]) => Math.floor(e$1.evaluate(t$1))
				],
				ceil: [
					Ct,
					[Ct],
					(t$1, [e$1]) => Math.ceil(e$1.evaluate(t$1))
				],
				"filter-==": [
					Ot,
					[Lt, Ut],
					(t$1, [e$1, r$1]) => t$1.properties()[e$1.value] === r$1.value
				],
				"filter-id-==": [
					Ot,
					[Ut],
					(t$1, [e$1]) => t$1.id() === e$1.value
				],
				"filter-type-==": [
					Ot,
					[Lt],
					(t$1, [e$1]) => t$1.geometryType() === e$1.value
				],
				"filter-<": [
					Ot,
					[Lt, Ut],
					(t$1, [e$1, r$1]) => {
						const n$1 = t$1.properties()[e$1.value], i$1 = r$1.value;
						return typeof n$1 == typeof i$1 && n$1 < i$1;
					}
				],
				"filter-id-<": [
					Ot,
					[Ut],
					(t$1, [e$1]) => {
						const r$1 = t$1.id(), n$1 = e$1.value;
						return typeof r$1 == typeof n$1 && r$1 < n$1;
					}
				],
				"filter->": [
					Ot,
					[Lt, Ut],
					(t$1, [e$1, r$1]) => {
						const n$1 = t$1.properties()[e$1.value], i$1 = r$1.value;
						return typeof n$1 == typeof i$1 && n$1 > i$1;
					}
				],
				"filter-id->": [
					Ot,
					[Ut],
					(t$1, [e$1]) => {
						const r$1 = t$1.id(), n$1 = e$1.value;
						return typeof r$1 == typeof n$1 && r$1 > n$1;
					}
				],
				"filter-<=": [
					Ot,
					[Lt, Ut],
					(t$1, [e$1, r$1]) => {
						const n$1 = t$1.properties()[e$1.value], i$1 = r$1.value;
						return typeof n$1 == typeof i$1 && n$1 <= i$1;
					}
				],
				"filter-id-<=": [
					Ot,
					[Ut],
					(t$1, [e$1]) => {
						const r$1 = t$1.id(), n$1 = e$1.value;
						return typeof r$1 == typeof n$1 && r$1 <= n$1;
					}
				],
				"filter->=": [
					Ot,
					[Lt, Ut],
					(t$1, [e$1, r$1]) => {
						const n$1 = t$1.properties()[e$1.value], i$1 = r$1.value;
						return typeof n$1 == typeof i$1 && n$1 >= i$1;
					}
				],
				"filter-id->=": [
					Ot,
					[Ut],
					(t$1, [e$1]) => {
						const r$1 = t$1.id(), n$1 = e$1.value;
						return typeof r$1 == typeof n$1 && r$1 >= n$1;
					}
				],
				"filter-has": [
					Ot,
					[Ut],
					(t$1, [e$1]) => e$1.value in t$1.properties()
				],
				"filter-has-id": [
					Ot,
					[],
					(t$1) => null !== t$1.id() && void 0 !== t$1.id()
				],
				"filter-type-in": [
					Ot,
					[Kt(Lt)],
					(t$1, [e$1]) => e$1.value.indexOf(t$1.geometryType()) >= 0
				],
				"filter-id-in": [
					Ot,
					[Kt(Ut)],
					(t$1, [e$1]) => e$1.value.indexOf(t$1.id()) >= 0
				],
				"filter-in-small": [
					Ot,
					[Lt, Kt(Ut)],
					(t$1, [e$1, r$1]) => r$1.value.indexOf(t$1.properties()[e$1.value]) >= 0
				],
				"filter-in-large": [
					Ot,
					[Lt, Kt(Ut)],
					(t$1, [e$1, r$1]) => function(t$2, e$2, r$2, n$1) {
						for (; r$2 <= n$1;) {
							const i$1 = r$2 + n$1 >> 1;
							if (e$2[i$1] === t$2) return !0;
							e$2[i$1] > t$2 ? n$1 = i$1 - 1 : r$2 = i$1 + 1;
						}
						return !1;
					}(t$1.properties()[e$1.value], r$1.value, 0, r$1.value.length - 1)
				],
				all: {
					type: Ot,
					overloads: [[[Ot, Ot], (t$1, [e$1, r$1]) => e$1.evaluate(t$1) && r$1.evaluate(t$1)], [Cn(Ot), (t$1, e$1) => {
						for (const r$1 of e$1) if (!r$1.evaluate(t$1)) return !1;
						return !0;
					}]]
				},
				any: {
					type: Ot,
					overloads: [[[Ot, Ot], (t$1, [e$1, r$1]) => e$1.evaluate(t$1) || r$1.evaluate(t$1)], [Cn(Ot), (t$1, e$1) => {
						for (const r$1 of e$1) if (r$1.evaluate(t$1)) return !0;
						return !1;
					}]]
				},
				"!": [
					Ot,
					[Ot],
					(t$1, [e$1]) => !e$1.evaluate(t$1)
				],
				"is-supported-script": [
					Ot,
					[Lt],
					(t$1, [e$1]) => {
						const r$1 = t$1.globals && t$1.globals.isSupportedScript;
						return !r$1 || r$1(e$1.evaluate(t$1));
					}
				],
				upcase: [
					Lt,
					[Lt],
					(t$1, [e$1]) => e$1.evaluate(t$1).toUpperCase()
				],
				downcase: [
					Lt,
					[Lt],
					(t$1, [e$1]) => e$1.evaluate(t$1).toLowerCase()
				],
				concat: [
					Lt,
					Cn(Ut),
					(t$1, e$1) => e$1.map(((e$2) => qe(e$2.evaluate(t$1)))).join("")
				],
				"resolved-locale": [
					Lt,
					[qt],
					(t$1, [e$1]) => e$1.evaluate(t$1).resolvedLocale()
				]
			});
			class ei {
				constructor(t$1, e$1, r$1) {
					this.expression = t$1, this._warningHistory = {}, this._evaluator = new Ke(), this._defaultValue = e$1 ? function(t$2) {
						if ("color" === t$2.type && Yn(t$2.default)) return new Te(0, 0, 0, 0);
						switch (t$2.type) {
							case "color": return Te.parse(t$2.default) || null;
							case "padding": return ze.parse(t$2.default) || null;
							case "numberArray": return Pe.parse(t$2.default) || null;
							case "colorArray": return Be.parse(t$2.default) || null;
							case "variableAnchorOffsetCollection": return Le.parse(t$2.default) || null;
							case "projectionDefinition": return Re.parse(t$2.default) || null;
							default: return void 0 === t$2.default ? null : t$2.default;
						}
					}(e$1) : null, this._enumValues = e$1 && "enum" === e$1.type ? e$1.values : null, this._globalState = r$1;
				}
				evaluateWithoutErrorHandling(t$1, e$1, r$1, n$1, i$1, s$1) {
					return this._globalState && (t$1 = ci(t$1, this._globalState)), this._evaluator.globals = t$1, this._evaluator.feature = e$1, this._evaluator.featureState = r$1, this._evaluator.canonical = n$1, this._evaluator.availableImages = i$1 || null, this._evaluator.formattedSection = s$1, this.expression.evaluate(this._evaluator);
				}
				evaluate(t$1, e$1, r$1, n$1, i$1, s$1) {
					this._globalState && (t$1 = ci(t$1, this._globalState)), this._evaluator.globals = t$1, this._evaluator.feature = e$1 || null, this._evaluator.featureState = r$1 || null, this._evaluator.canonical = n$1, this._evaluator.availableImages = i$1 || null, this._evaluator.formattedSection = s$1 || null;
					try {
						const t$2 = this.expression.evaluate(this._evaluator);
						if (null == t$2 || "number" == typeof t$2 && t$2 != t$2) return this._defaultValue;
						if (this._enumValues && !(t$2 in this._enumValues)) throw new Ve(`Expected value to be one of ${Object.keys(this._enumValues).map(((t$3) => JSON.stringify(t$3))).join(", ")}, but found ${JSON.stringify(t$2)} instead.`);
						return t$2;
					} catch (t$2) {
						return this._warningHistory[t$2.message] || (this._warningHistory[t$2.message] = !0, "undefined" != typeof console && console.warn(t$2.message)), this._defaultValue;
					}
				}
			}
			function ri(t$1) {
				return Array.isArray(t$1) && t$1.length > 0 && "string" == typeof t$1[0] && t$1[0] in Dn;
			}
			function ni(t$1, e$1, r$1) {
				const n$1 = new We(Dn, Ln, [], e$1 ? function(t$2) {
					const e$2 = {
						color: Rt,
						string: Lt,
						number: Ct,
						enum: Lt,
						boolean: Ot,
						formatted: jt,
						padding: Gt,
						numberArray: Yt,
						colorArray: Xt,
						projectionDefinition: Nt,
						resolvedImage: Zt,
						variableAnchorOffsetCollection: Ht
					};
					return "array" === t$2.type ? Kt(e$2[t$2.value] || Ut, t$2.length) : e$2[t$2.type];
				}(e$1) : void 0), i$1 = n$1.parse(t$1, void 0, void 0, void 0, e$1 && "string" === e$1.type ? { typeAnnotation: "coerce" } : void 0);
				return i$1 ? $n(new ei(i$1, e$1, r$1)) : Un(n$1.errors);
			}
			class ii {
				constructor(t$1, e$1, r$1) {
					this.kind = t$1, this._styleExpression = e$1, this.isStateDependent = "constant" !== t$1 && !Rn(e$1.expression), this.globalStateRefs = ui(e$1.expression), this._globalState = r$1;
				}
				evaluateWithoutErrorHandling(t$1, e$1, r$1, n$1, i$1, s$1) {
					return this._globalState && (t$1 = ci(t$1, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t$1, e$1, r$1, n$1, i$1, s$1);
				}
				evaluate(t$1, e$1, r$1, n$1, i$1, s$1) {
					return this._globalState && (t$1 = ci(t$1, this._globalState)), this._styleExpression.evaluate(t$1, e$1, r$1, n$1, i$1, s$1);
				}
			}
			class si {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.kind = t$1, this.zoomStops = r$1, this._styleExpression = e$1, this.isStateDependent = "camera" !== t$1 && !Rn(e$1.expression), this.globalStateRefs = ui(e$1.expression), this.interpolationType = n$1, this._globalState = i$1;
				}
				evaluateWithoutErrorHandling(t$1, e$1, r$1, n$1, i$1, s$1) {
					return this._globalState && (t$1 = ci(t$1, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t$1, e$1, r$1, n$1, i$1, s$1);
				}
				evaluate(t$1, e$1, r$1, n$1, i$1, s$1) {
					return this._globalState && (t$1 = ci(t$1, this._globalState)), this._styleExpression.evaluate(t$1, e$1, r$1, n$1, i$1, s$1);
				}
				interpolationFactor(t$1, e$1, r$1) {
					return this.interpolationType ? fr.interpolationFactor(this.interpolationType, t$1, e$1, r$1) : 0;
				}
			}
			function ai(t$1, e$1, r$1) {
				const n$1 = ni(t$1, e$1, r$1);
				if ("error" === n$1.result) return n$1;
				const i$1 = n$1.value.expression, s$1 = On(i$1);
				if (!s$1 && !qn(e$1)) return Un([new Pt("", "data expressions not supported")]);
				const a = Nn(i$1, ["zoom"]);
				if (!a && !jn(e$1)) return Un([new Pt("", "zoom expressions not supported")]);
				const o$1 = li(i$1);
				return o$1 || a ? o$1 instanceof Pt ? Un([o$1]) : o$1 instanceof fr && !Gn(e$1) ? Un([new Pt("", "\"interpolate\" expressions cannot be used with this property")]) : $n(o$1 ? new si(s$1 ? "camera" : "composite", n$1.value, o$1.labels, o$1 instanceof fr ? o$1.interpolation : void 0, r$1) : new ii(s$1 ? "constant" : "source", n$1.value, r$1)) : Un([new Pt("", "\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.")]);
			}
			class oi {
				constructor(t$1, e$1) {
					this._parameters = t$1, this._specification = e$1, zt(this, Hn(this._parameters, this._specification));
				}
				static deserialize(t$1) {
					return new oi(t$1._parameters, t$1._specification);
				}
				static serialize(t$1) {
					return {
						_parameters: t$1._parameters,
						_specification: t$1._specification
					};
				}
			}
			function li(t$1) {
				let e$1 = null;
				if (t$1 instanceof Je) e$1 = li(t$1.result);
				else if (t$1 instanceof mr) {
					for (const r$1 of t$1.args) if (e$1 = li(r$1), e$1) break;
				} else (t$1 instanceof or || t$1 instanceof fr) && t$1.input instanceof zn && "zoom" === t$1.input.name && (e$1 = t$1);
				return e$1 instanceof Pt || t$1.eachChild(((t$2) => {
					const r$1 = li(t$2);
					r$1 instanceof Pt ? e$1 = r$1 : !e$1 && r$1 ? e$1 = new Pt("", "\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.") : e$1 && r$1 && e$1 !== r$1 && (e$1 = new Pt("", "Only one zoom-based \"step\" or \"interpolate\" subexpression may be used in an expression."));
				})), e$1;
			}
			function ui(t$1, e$1 = /* @__PURE__ */ new Set()) {
				return t$1 instanceof Fn && e$1.add(t$1.key), t$1.eachChild(((t$2) => {
					ui(t$2, e$1);
				})), e$1;
			}
			function ci(t$1, e$1) {
				const { zoom: r$1, heatmapDensity: n$1, elevation: i$1, lineProgress: s$1, isSupportedScript: a, accumulated: o$1 } = null != t$1 ? t$1 : {};
				return {
					zoom: r$1,
					heatmapDensity: n$1,
					elevation: i$1,
					lineProgress: s$1,
					isSupportedScript: a,
					accumulated: o$1,
					globalState: e$1
				};
			}
			function hi(t$1) {
				if (!0 === t$1 || !1 === t$1) return !0;
				if (!Array.isArray(t$1) || 0 === t$1.length) return !1;
				switch (t$1[0]) {
					case "has": return t$1.length >= 2 && "$id" !== t$1[1] && "$type" !== t$1[1];
					case "in": return t$1.length >= 3 && ("string" != typeof t$1[1] || Array.isArray(t$1[2]));
					case "!in":
					case "!has":
					case "none": return !1;
					case "==":
					case "!=":
					case ">":
					case ">=":
					case "<":
					case "<=": return 3 !== t$1.length || Array.isArray(t$1[1]) || Array.isArray(t$1[2]);
					case "any":
					case "all":
						for (const e$1 of t$1.slice(1)) if (!hi(e$1) && "boolean" != typeof e$1) return !1;
						return !0;
					default: return !0;
				}
			}
			const pi = {
				type: "boolean",
				default: !1,
				transition: !1,
				"property-type": "data-driven",
				expression: {
					interpolated: !1,
					parameters: ["zoom", "feature"]
				}
			};
			function fi(t$1, e$1) {
				if (null == t$1) return {
					filter: () => !0,
					needGeometry: !1,
					getGlobalStateRefs: () => /* @__PURE__ */ new Set()
				};
				hi(t$1) || (t$1 = mi(t$1));
				const r$1 = ni(t$1, pi, e$1);
				if ("error" === r$1.result) throw new Error(r$1.value.map(((t$2) => `${t$2.key}: ${t$2.message}`)).join(", "));
				return {
					filter: (t$2, e$2, n$1) => r$1.value.evaluate(t$2, e$2, {}, n$1),
					needGeometry: yi(t$1),
					getGlobalStateRefs: () => ui(r$1.value.expression)
				};
			}
			function di(t$1, e$1) {
				return t$1 < e$1 ? -1 : t$1 > e$1 ? 1 : 0;
			}
			function yi(t$1) {
				if (!Array.isArray(t$1)) return !1;
				if ("within" === t$1[0] || "distance" === t$1[0]) return !0;
				for (let e$1 = 1; e$1 < t$1.length; e$1++) if (yi(t$1[e$1])) return !0;
				return !1;
			}
			function mi(t$1) {
				if (!t$1) return !0;
				const e$1 = t$1[0];
				return t$1.length <= 1 ? "any" !== e$1 : "==" === e$1 ? gi(t$1[1], t$1[2], "==") : "!=" === e$1 ? bi(gi(t$1[1], t$1[2], "==")) : "<" === e$1 || ">" === e$1 || "<=" === e$1 || ">=" === e$1 ? gi(t$1[1], t$1[2], e$1) : "any" === e$1 ? (r$1 = t$1.slice(1), ["any"].concat(r$1.map(mi))) : "all" === e$1 ? ["all"].concat(t$1.slice(1).map(mi)) : "none" === e$1 ? ["all"].concat(t$1.slice(1).map(mi).map(bi)) : "in" === e$1 ? xi(t$1[1], t$1.slice(2)) : "!in" === e$1 ? bi(xi(t$1[1], t$1.slice(2))) : "has" === e$1 ? vi(t$1[1]) : "!has" !== e$1 || bi(vi(t$1[1]));
				var r$1;
			}
			function gi(t$1, e$1, r$1) {
				switch (t$1) {
					case "$type": return [`filter-type-${r$1}`, e$1];
					case "$id": return [`filter-id-${r$1}`, e$1];
					default: return [
						`filter-${r$1}`,
						t$1,
						e$1
					];
				}
			}
			function xi(t$1, e$1) {
				if (0 === e$1.length) return !1;
				switch (t$1) {
					case "$type": return ["filter-type-in", ["literal", e$1]];
					case "$id": return ["filter-id-in", ["literal", e$1]];
					default: return e$1.length > 200 && !e$1.some(((t$2) => typeof t$2 != typeof e$1[0])) ? [
						"filter-in-large",
						t$1,
						["literal", e$1.sort(di)]
					] : [
						"filter-in-small",
						t$1,
						["literal", e$1]
					];
				}
			}
			function vi(t$1) {
				switch (t$1) {
					case "$type": return !0;
					case "$id": return ["filter-has-id"];
					default: return ["filter-has", t$1];
				}
			}
			function bi(t$1) {
				return ["!", t$1];
			}
			function wi(t$1) {
				const e$1 = typeof t$1;
				if ("number" === e$1 || "boolean" === e$1 || "string" === e$1 || null == t$1) return JSON.stringify(t$1);
				if (Array.isArray(t$1)) {
					let e$2 = "[";
					for (const r$2 of t$1) e$2 += `${wi(r$2)},`;
					return `${e$2}]`;
				}
				const r$1 = Object.keys(t$1).sort();
				let n$1 = "{";
				for (let e$2 = 0; e$2 < r$1.length; e$2++) n$1 += `${JSON.stringify(r$1[e$2])}:${wi(t$1[r$1[e$2]])},`;
				return `${n$1}}`;
			}
			function _i(t$1) {
				let e$1 = "";
				for (const r$1 of bt) e$1 += `/${wi(t$1[r$1])}`;
				return e$1;
			}
			function Si(t$1) {
				const e$1 = t$1.value;
				return e$1 ? [new Dt(t$1.key, e$1, "constants have been deprecated as of v8")] : [];
			}
			function Ai(t$1) {
				return t$1 instanceof Number || t$1 instanceof String || t$1 instanceof Boolean ? t$1.valueOf() : t$1;
			}
			function ki(t$1) {
				if (Array.isArray(t$1)) return t$1.map(ki);
				if (t$1 instanceof Object && !(t$1 instanceof Number || t$1 instanceof String || t$1 instanceof Boolean)) {
					const e$1 = {};
					for (const r$1 in t$1) e$1[r$1] = ki(t$1[r$1]);
					return e$1;
				}
				return Ai(t$1);
			}
			function Ei(t$1) {
				const e$1 = t$1.key, r$1 = t$1.value, n$1 = t$1.valueSpec || {}, i$1 = t$1.objectElementValidators || {}, s$1 = t$1.style, a = t$1.styleSpec, o$1 = t$1.validateSpec;
				let l$1 = [];
				const u$1 = Xn(r$1);
				if ("object" !== u$1) return [new Dt(e$1, r$1, `object expected, ${u$1} found`)];
				for (const t$2 in r$1) {
					const u$2 = t$2.split(".")[0], c$1 = ve(n$1, u$2) || n$1["*"];
					let h$1;
					if (ve(i$1, u$2)) h$1 = i$1[u$2];
					else if (ve(n$1, u$2)) {
						if (void 0 === r$1[t$2]) continue;
						h$1 = o$1;
					} else if (i$1["*"]) h$1 = i$1["*"];
					else {
						if (!n$1["*"]) {
							l$1.push(new Dt(e$1, r$1[t$2], `unknown property "${t$2}"`));
							continue;
						}
						h$1 = o$1;
					}
					l$1 = l$1.concat(h$1({
						key: (e$1 ? `${e$1}.` : e$1) + t$2,
						value: r$1[t$2],
						valueSpec: c$1,
						style: s$1,
						styleSpec: a,
						object: r$1,
						objectKey: t$2,
						validateSpec: o$1
					}, r$1));
				}
				for (const t$2 in n$1) i$1[t$2] || n$1[t$2].required && void 0 === n$1[t$2].default && void 0 === r$1[t$2] && l$1.push(new Dt(e$1, r$1, `missing required property "${t$2}"`));
				return l$1;
			}
			function Ti(t$1) {
				const e$1 = t$1.value, r$1 = t$1.valueSpec, n$1 = t$1.style, i$1 = t$1.styleSpec, s$1 = t$1.key, a = t$1.arrayElementValidator || t$1.validateSpec;
				if ("array" !== Xn(e$1)) return [new Dt(s$1, e$1, `array expected, ${Xn(e$1)} found`)];
				if (r$1.length && e$1.length !== r$1.length) return [new Dt(s$1, e$1, `array length ${r$1.length} expected, length ${e$1.length} found`)];
				let o$1 = {
					type: r$1.value,
					values: r$1.values
				};
				i$1.$version < 7 && (o$1.function = r$1.function), "object" === Xn(r$1.value) && (o$1 = r$1.value);
				let l$1 = [];
				for (let r$2 = 0; r$2 < e$1.length; r$2++) l$1 = l$1.concat(a({
					array: e$1,
					arrayIndex: r$2,
					value: e$1[r$2],
					valueSpec: o$1,
					validateSpec: t$1.validateSpec,
					style: n$1,
					styleSpec: i$1,
					key: `${s$1}[${r$2}]`
				}));
				return l$1;
			}
			function Ii(t$1) {
				const e$1 = t$1.key, r$1 = t$1.value, n$1 = t$1.valueSpec;
				let i$1 = Xn(r$1);
				return "number" === i$1 && r$1 != r$1 && (i$1 = "NaN"), "number" !== i$1 ? [new Dt(e$1, r$1, `number expected, ${i$1} found`)] : "minimum" in n$1 && r$1 < n$1.minimum ? [new Dt(e$1, r$1, `${r$1} is less than the minimum value ${n$1.minimum}`)] : "maximum" in n$1 && r$1 > n$1.maximum ? [new Dt(e$1, r$1, `${r$1} is greater than the maximum value ${n$1.maximum}`)] : [];
			}
			function Mi(t$1) {
				const e$1 = t$1.valueSpec, r$1 = Ai(t$1.value.type);
				let n$1, i$1, s$1, a = {};
				const o$1 = "categorical" !== r$1 && void 0 === t$1.value.property, l$1 = !o$1, u$1 = "array" === Xn(t$1.value.stops) && "array" === Xn(t$1.value.stops[0]) && "object" === Xn(t$1.value.stops[0][0]), c$1 = Ei({
					key: t$1.key,
					value: t$1.value,
					valueSpec: t$1.styleSpec.function,
					validateSpec: t$1.validateSpec,
					style: t$1.style,
					styleSpec: t$1.styleSpec,
					objectElementValidators: {
						stops: function(t$2) {
							if ("identity" === r$1) return [new Dt(t$2.key, t$2.value, "identity function may not have a \"stops\" property")];
							let e$2 = [];
							const n$2 = t$2.value;
							return e$2 = e$2.concat(Ti({
								key: t$2.key,
								value: n$2,
								valueSpec: t$2.valueSpec,
								validateSpec: t$2.validateSpec,
								style: t$2.style,
								styleSpec: t$2.styleSpec,
								arrayElementValidator: h$1
							})), "array" === Xn(n$2) && 0 === n$2.length && e$2.push(new Dt(t$2.key, n$2, "array must have at least one stop")), e$2;
						},
						default: function(t$2) {
							return t$2.validateSpec({
								key: t$2.key,
								value: t$2.value,
								valueSpec: e$1,
								validateSpec: t$2.validateSpec,
								style: t$2.style,
								styleSpec: t$2.styleSpec
							});
						}
					}
				});
				return "identity" === r$1 && o$1 && c$1.push(new Dt(t$1.key, t$1.value, "missing required property \"property\"")), "identity" === r$1 || t$1.value.stops || c$1.push(new Dt(t$1.key, t$1.value, "missing required property \"stops\"")), "exponential" === r$1 && t$1.valueSpec.expression && !Gn(t$1.valueSpec) && c$1.push(new Dt(t$1.key, t$1.value, "exponential functions not supported")), t$1.styleSpec.$version >= 8 && (l$1 && !qn(t$1.valueSpec) ? c$1.push(new Dt(t$1.key, t$1.value, "property functions not supported")) : o$1 && !jn(t$1.valueSpec) && c$1.push(new Dt(t$1.key, t$1.value, "zoom functions not supported"))), "categorical" !== r$1 && !u$1 || void 0 !== t$1.value.property || c$1.push(new Dt(t$1.key, t$1.value, "\"property\" property is required")), c$1;
				function h$1(t$2) {
					let r$2 = [];
					const n$2 = t$2.value, o$2 = t$2.key;
					if ("array" !== Xn(n$2)) return [new Dt(o$2, n$2, `array expected, ${Xn(n$2)} found`)];
					if (2 !== n$2.length) return [new Dt(o$2, n$2, `array length 2 expected, length ${n$2.length} found`)];
					if (u$1) {
						if ("object" !== Xn(n$2[0])) return [new Dt(o$2, n$2, `object expected, ${Xn(n$2[0])} found`)];
						if (void 0 === n$2[0].zoom) return [new Dt(o$2, n$2, "object stop key must have zoom")];
						if (void 0 === n$2[0].value) return [new Dt(o$2, n$2, "object stop key must have value")];
						if (s$1 && s$1 > Ai(n$2[0].zoom)) return [new Dt(o$2, n$2[0].zoom, "stop zoom values must appear in ascending order")];
						Ai(n$2[0].zoom) !== s$1 && (s$1 = Ai(n$2[0].zoom), i$1 = void 0, a = {}), r$2 = r$2.concat(Ei({
							key: `${o$2}[0]`,
							value: n$2[0],
							valueSpec: { zoom: {} },
							validateSpec: t$2.validateSpec,
							style: t$2.style,
							styleSpec: t$2.styleSpec,
							objectElementValidators: {
								zoom: Ii,
								value: p$1
							}
						}));
					} else r$2 = r$2.concat(p$1({
						key: `${o$2}[0]`,
						value: n$2[0],
						validateSpec: t$2.validateSpec,
						style: t$2.style,
						styleSpec: t$2.styleSpec
					}, n$2));
					return ri(ki(n$2[1])) ? r$2.concat([new Dt(`${o$2}[1]`, n$2[1], "expressions are not allowed in function stops.")]) : r$2.concat(t$2.validateSpec({
						key: `${o$2}[1]`,
						value: n$2[1],
						valueSpec: e$1,
						validateSpec: t$2.validateSpec,
						style: t$2.style,
						styleSpec: t$2.styleSpec
					}));
				}
				function p$1(t$2, s$2) {
					const o$2 = Xn(t$2.value), l$2 = Ai(t$2.value), u$2 = null !== t$2.value ? t$2.value : s$2;
					if (n$1) {
						if (o$2 !== n$1) return [new Dt(t$2.key, u$2, `${o$2} stop domain type must match previous stop domain type ${n$1}`)];
					} else n$1 = o$2;
					if ("number" !== o$2 && "string" !== o$2 && "boolean" !== o$2) return [new Dt(t$2.key, u$2, "stop domain value must be a number, string, or boolean")];
					if ("number" !== o$2 && "categorical" !== r$1) {
						let n$2 = `number expected, ${o$2} found`;
						return qn(e$1) && void 0 === r$1 && (n$2 += "\nIf you intended to use a categorical function, specify `\"type\": \"categorical\"`."), [new Dt(t$2.key, u$2, n$2)];
					}
					return "categorical" !== r$1 || "number" !== o$2 || isFinite(l$2) && Math.floor(l$2) === l$2 ? "categorical" !== r$1 && "number" === o$2 && void 0 !== i$1 && l$2 < i$1 ? [new Dt(t$2.key, u$2, "stop domain values must appear in ascending order")] : (i$1 = l$2, "categorical" === r$1 && l$2 in a ? [new Dt(t$2.key, u$2, "stop domain values must be unique")] : (a[l$2] = !0, [])) : [new Dt(t$2.key, u$2, `integer expected, found ${l$2}`)];
				}
			}
			function Fi(t$1) {
				const e$1 = ("property" === t$1.expressionContext ? ai : ni)(ki(t$1.value), t$1.valueSpec);
				if ("error" === e$1.result) return e$1.value.map(((e$2) => new Dt(`${t$1.key}${e$2.key}`, t$1.value, e$2.message)));
				const r$1 = e$1.value.expression || e$1.value._styleExpression.expression;
				if ("property" === t$1.expressionContext && "text-font" === t$1.propertyKey && !r$1.outputDefined()) return [new Dt(t$1.key, t$1.value, `Invalid data expression for "${t$1.propertyKey}". Output values must be contained as literals within the expression.`)];
				if ("property" === t$1.expressionContext && "layout" === t$1.propertyType && !Rn(r$1)) return [new Dt(t$1.key, t$1.value, "\"feature-state\" data expressions are not supported with layout properties.")];
				if ("filter" === t$1.expressionContext && !Rn(r$1)) return [new Dt(t$1.key, t$1.value, "\"feature-state\" data expressions are not supported with filters.")];
				if (t$1.expressionContext && 0 === t$1.expressionContext.indexOf("cluster")) {
					if (!Nn(r$1, ["zoom", "feature-state"])) return [new Dt(t$1.key, t$1.value, "\"zoom\" and \"feature-state\" expressions are not supported with cluster properties.")];
					if ("cluster-initial" === t$1.expressionContext && !On(r$1)) return [new Dt(t$1.key, t$1.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
				}
				return [];
			}
			function Di(t$1) {
				const e$1 = t$1.key, r$1 = t$1.value, n$1 = Xn(r$1);
				return "string" !== n$1 ? [new Dt(e$1, r$1, `color expected, ${n$1} found`)] : Te.parse(String(r$1)) ? [] : [new Dt(e$1, r$1, `color expected, "${r$1}" found`)];
			}
			function zi(t$1) {
				const e$1 = t$1.key, r$1 = t$1.value, n$1 = t$1.valueSpec, i$1 = [];
				return Array.isArray(n$1.values) ? -1 === n$1.values.indexOf(Ai(r$1)) && i$1.push(new Dt(e$1, r$1, `expected one of [${n$1.values.join(", ")}], ${JSON.stringify(r$1)} found`)) : -1 === Object.keys(n$1.values).indexOf(Ai(r$1)) && i$1.push(new Dt(e$1, r$1, `expected one of [${Object.keys(n$1.values).join(", ")}], ${JSON.stringify(r$1)} found`)), i$1;
			}
			function Pi(t$1) {
				return hi(ki(t$1.value)) ? Fi(zt({}, t$1, {
					expressionContext: "filter",
					valueSpec: { value: "boolean" }
				})) : Bi(t$1);
			}
			function Bi(t$1) {
				const e$1 = t$1.value, r$1 = t$1.key;
				if ("array" !== Xn(e$1)) return [new Dt(r$1, e$1, `array expected, ${Xn(e$1)} found`)];
				const n$1 = t$1.styleSpec;
				let i$1, s$1 = [];
				if (e$1.length < 1) return [new Dt(r$1, e$1, "filter array must have at least 1 element")];
				switch (s$1 = s$1.concat(zi({
					key: `${r$1}[0]`,
					value: e$1[0],
					valueSpec: n$1.filter_operator,
					style: t$1.style,
					styleSpec: t$1.styleSpec
				})), Ai(e$1[0])) {
					case "<":
					case "<=":
					case ">":
					case ">=": e$1.length >= 2 && "$type" === Ai(e$1[1]) && s$1.push(new Dt(r$1, e$1, `"$type" cannot be use with operator "${e$1[0]}"`));
					case "==":
					case "!=": 3 !== e$1.length && s$1.push(new Dt(r$1, e$1, `filter array for operator "${e$1[0]}" must have 3 elements`));
					case "in":
					case "!in":
						e$1.length >= 2 && (i$1 = Xn(e$1[1]), "string" !== i$1 && s$1.push(new Dt(`${r$1}[1]`, e$1[1], `string expected, ${i$1} found`)));
						for (let a = 2; a < e$1.length; a++) i$1 = Xn(e$1[a]), "$type" === Ai(e$1[1]) ? s$1 = s$1.concat(zi({
							key: `${r$1}[${a}]`,
							value: e$1[a],
							valueSpec: n$1.geometry_type,
							style: t$1.style,
							styleSpec: t$1.styleSpec
						})) : "string" !== i$1 && "number" !== i$1 && "boolean" !== i$1 && s$1.push(new Dt(`${r$1}[${a}]`, e$1[a], `string, number, or boolean expected, ${i$1} found`));
						break;
					case "any":
					case "all":
					case "none":
						for (let n$2 = 1; n$2 < e$1.length; n$2++) s$1 = s$1.concat(Bi({
							key: `${r$1}[${n$2}]`,
							value: e$1[n$2],
							style: t$1.style,
							styleSpec: t$1.styleSpec
						}));
						break;
					case "has":
					case "!has": i$1 = Xn(e$1[1]), 2 !== e$1.length ? s$1.push(new Dt(r$1, e$1, `filter array for "${e$1[0]}" operator must have 2 elements`)) : "string" !== i$1 && s$1.push(new Dt(`${r$1}[1]`, e$1[1], `string expected, ${i$1} found`));
				}
				return s$1;
			}
			function Vi(t$1, e$1) {
				const r$1 = t$1.key, n$1 = t$1.validateSpec, i$1 = t$1.style, s$1 = t$1.styleSpec, a = t$1.value, o$1 = t$1.objectKey, l$1 = s$1[`${e$1}_${t$1.layerType}`];
				if (!l$1) return [];
				const u$1 = o$1.match(/^(.*)-transition$/);
				if ("paint" === e$1 && u$1 && l$1[u$1[1]] && l$1[u$1[1]].transition) return n$1({
					key: r$1,
					value: a,
					valueSpec: s$1.transition,
					style: i$1,
					styleSpec: s$1
				});
				const c$1 = t$1.valueSpec || l$1[o$1];
				if (!c$1) return [new Dt(r$1, a, `unknown property "${o$1}"`)];
				let h$1;
				if ("string" === Xn(a) && qn(c$1) && !c$1.tokens && (h$1 = /^{([^}]+)}$/.exec(a))) return [new Dt(r$1, a, `"${o$1}" does not support interpolation syntax\nUse an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(h$1[1])} }\`.`)];
				const p$1 = [];
				return "symbol" === t$1.layerType && "text-font" === o$1 && Yn(ki(a)) && "identity" === Ai(a.type) && p$1.push(new Dt(r$1, a, "\"text-font\" does not support identity functions")), p$1.concat(n$1({
					key: t$1.key,
					value: a,
					valueSpec: c$1,
					style: i$1,
					styleSpec: s$1,
					expressionContext: "property",
					propertyType: e$1,
					propertyKey: o$1
				}));
			}
			function Ci(t$1) {
				return Vi(t$1, "paint");
			}
			function Li(t$1) {
				return Vi(t$1, "layout");
			}
			function Oi(t$1) {
				let e$1 = [];
				const r$1 = t$1.value, n$1 = t$1.key, i$1 = t$1.style, s$1 = t$1.styleSpec;
				if ("object" !== Xn(r$1)) return [new Dt(n$1, r$1, `object expected, ${Xn(r$1)} found`)];
				r$1.type || r$1.ref || e$1.push(new Dt(n$1, r$1, "either \"type\" or \"ref\" is required"));
				let a = Ai(r$1.type);
				const o$1 = Ai(r$1.ref);
				if (r$1.id) {
					const s$2 = Ai(r$1.id);
					for (let a$1 = 0; a$1 < t$1.arrayIndex; a$1++) {
						const t$2 = i$1.layers[a$1];
						Ai(t$2.id) === s$2 && e$1.push(new Dt(n$1, r$1.id, `duplicate layer id "${r$1.id}", previously used at line ${t$2.id.__line__}`));
					}
				}
				if ("ref" in r$1) {
					let t$2;
					[
						"type",
						"source",
						"source-layer",
						"filter",
						"layout"
					].forEach(((t$3) => {
						t$3 in r$1 && e$1.push(new Dt(n$1, r$1[t$3], `"${t$3}" is prohibited for ref layers`));
					})), i$1.layers.forEach(((e$2) => {
						Ai(e$2.id) === o$1 && (t$2 = e$2);
					})), t$2 ? t$2.ref ? e$1.push(new Dt(n$1, r$1.ref, "ref cannot reference another ref layer")) : a = Ai(t$2.type) : e$1.push(new Dt(n$1, r$1.ref, `ref layer "${o$1}" not found`));
				} else if ("background" !== a) if (r$1.source) {
					const t$2 = i$1.sources && i$1.sources[r$1.source], s$2 = t$2 && Ai(t$2.type);
					t$2 ? "vector" === s$2 && "raster" === a ? e$1.push(new Dt(n$1, r$1.source, `layer "${r$1.id}" requires a raster source`)) : "raster-dem" !== s$2 && "hillshade" === a || "raster-dem" !== s$2 && "color-relief" === a ? e$1.push(new Dt(n$1, r$1.source, `layer "${r$1.id}" requires a raster-dem source`)) : "raster" === s$2 && "raster" !== a ? e$1.push(new Dt(n$1, r$1.source, `layer "${r$1.id}" requires a vector source`)) : "vector" !== s$2 || r$1["source-layer"] ? "raster-dem" === s$2 && "hillshade" !== a && "color-relief" !== a ? e$1.push(new Dt(n$1, r$1.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : "line" !== a || !r$1.paint || !r$1.paint["line-gradient"] || "geojson" === s$2 && t$2.lineMetrics || e$1.push(new Dt(n$1, r$1, `layer "${r$1.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e$1.push(new Dt(n$1, r$1, `layer "${r$1.id}" must specify a "source-layer"`)) : e$1.push(new Dt(n$1, r$1.source, `source "${r$1.source}" not found`));
				} else e$1.push(new Dt(n$1, r$1, "missing required property \"source\""));
				return e$1 = e$1.concat(Ei({
					key: n$1,
					value: r$1,
					valueSpec: s$1.layer,
					style: t$1.style,
					styleSpec: t$1.styleSpec,
					validateSpec: t$1.validateSpec,
					objectElementValidators: {
						"*": () => [],
						type: () => t$1.validateSpec({
							key: `${n$1}.type`,
							value: r$1.type,
							valueSpec: s$1.layer.type,
							style: t$1.style,
							styleSpec: t$1.styleSpec,
							validateSpec: t$1.validateSpec,
							object: r$1,
							objectKey: "type"
						}),
						filter: Pi,
						layout: (t$2) => Ei({
							layer: r$1,
							key: t$2.key,
							value: t$2.value,
							style: t$2.style,
							styleSpec: t$2.styleSpec,
							validateSpec: t$2.validateSpec,
							objectElementValidators: { "*": (t$3) => Li(zt({ layerType: a }, t$3)) }
						}),
						paint: (t$2) => Ei({
							layer: r$1,
							key: t$2.key,
							value: t$2.value,
							style: t$2.style,
							styleSpec: t$2.styleSpec,
							validateSpec: t$2.validateSpec,
							objectElementValidators: { "*": (t$3) => Ci(zt({ layerType: a }, t$3)) }
						})
					}
				})), e$1;
			}
			function Ri(t$1) {
				const e$1 = t$1.value, r$1 = t$1.key, n$1 = Xn(e$1);
				return "string" !== n$1 ? [new Dt(r$1, e$1, `string expected, ${n$1} found`)] : [];
			}
			const Ni = { promoteId: function({ key: t$1, value: e$1 }) {
				if ("string" === Xn(e$1)) return Ri({
					key: t$1,
					value: e$1
				});
				{
					const r$1 = [];
					for (const n$1 in e$1) r$1.push(...Ri({
						key: `${t$1}.${n$1}`,
						value: e$1[n$1]
					}));
					return r$1;
				}
			} };
			function $i(t$1) {
				const e$1 = t$1.value, r$1 = t$1.key, n$1 = t$1.styleSpec, i$1 = t$1.style, s$1 = t$1.validateSpec;
				if (!e$1.type) return [new Dt(r$1, e$1, "\"type\" is required")];
				const a = Ai(e$1.type);
				let o$1;
				switch (a) {
					case "vector":
					case "raster": return o$1 = Ei({
						key: r$1,
						value: e$1,
						valueSpec: n$1[`source_${a.replace("-", "_")}`],
						style: t$1.style,
						styleSpec: n$1,
						objectElementValidators: Ni,
						validateSpec: s$1
					}), o$1;
					case "raster-dem": return o$1 = function(t$2) {
						var e$2;
						const r$2 = null !== (e$2 = t$2.sourceName) && void 0 !== e$2 ? e$2 : "", n$2 = t$2.value, i$2 = t$2.styleSpec, s$2 = i$2.source_raster_dem, a$1 = t$2.style;
						let o$2 = [];
						const l$1 = Xn(n$2);
						if (void 0 === n$2) return o$2;
						if ("object" !== l$1) return o$2.push(new Dt("source_raster_dem", n$2, `object expected, ${l$1} found`)), o$2;
						const u$1 = "custom" === Ai(n$2.encoding), c$1 = [
							"redFactor",
							"greenFactor",
							"blueFactor",
							"baseShift"
						], h$1 = t$2.value.encoding ? `"${t$2.value.encoding}"` : "Default";
						for (const e$3 in n$2) !u$1 && c$1.includes(e$3) ? o$2.push(new Dt(e$3, n$2[e$3], `In "${r$2}": "${e$3}" is only valid when "encoding" is set to "custom". ${h$1} encoding found`)) : s$2[e$3] ? o$2 = o$2.concat(t$2.validateSpec({
							key: e$3,
							value: n$2[e$3],
							valueSpec: s$2[e$3],
							validateSpec: t$2.validateSpec,
							style: a$1,
							styleSpec: i$2
						})) : o$2.push(new Dt(e$3, n$2[e$3], `unknown property "${e$3}"`));
						return o$2;
					}({
						sourceName: r$1,
						value: e$1,
						style: t$1.style,
						styleSpec: n$1,
						validateSpec: s$1
					}), o$1;
					case "geojson":
						if (o$1 = Ei({
							key: r$1,
							value: e$1,
							valueSpec: n$1.source_geojson,
							style: i$1,
							styleSpec: n$1,
							validateSpec: s$1,
							objectElementValidators: Ni
						}), e$1.cluster) for (const t$2 in e$1.clusterProperties) {
							const [n$2, i$2] = e$1.clusterProperties[t$2], s$2 = "string" == typeof n$2 ? [
								n$2,
								["accumulated"],
								["get", t$2]
							] : n$2;
							o$1.push(...Fi({
								key: `${r$1}.${t$2}.map`,
								value: i$2,
								expressionContext: "cluster-map"
							})), o$1.push(...Fi({
								key: `${r$1}.${t$2}.reduce`,
								value: s$2,
								expressionContext: "cluster-reduce"
							}));
						}
						return o$1;
					case "video": return Ei({
						key: r$1,
						value: e$1,
						valueSpec: n$1.source_video,
						style: i$1,
						validateSpec: s$1,
						styleSpec: n$1
					});
					case "image": return Ei({
						key: r$1,
						value: e$1,
						valueSpec: n$1.source_image,
						style: i$1,
						validateSpec: s$1,
						styleSpec: n$1
					});
					case "canvas": return [new Dt(r$1, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
					default: return zi({
						key: `${r$1}.type`,
						value: e$1.type,
						valueSpec: { values: [
							"vector",
							"raster",
							"raster-dem",
							"geojson",
							"video",
							"image"
						] }
					});
				}
			}
			function Ui(t$1) {
				const e$1 = t$1.value, r$1 = t$1.styleSpec, n$1 = r$1.light, i$1 = t$1.style;
				let s$1 = [];
				const a = Xn(e$1);
				if (void 0 === e$1) return s$1;
				if ("object" !== a) return s$1 = s$1.concat([new Dt("light", e$1, `object expected, ${a} found`)]), s$1;
				for (const a$1 in e$1) {
					const o$1 = a$1.match(/^(.*)-transition$/);
					s$1 = s$1.concat(o$1 && n$1[o$1[1]] && n$1[o$1[1]].transition ? t$1.validateSpec({
						key: a$1,
						value: e$1[a$1],
						valueSpec: r$1.transition,
						validateSpec: t$1.validateSpec,
						style: i$1,
						styleSpec: r$1
					}) : n$1[a$1] ? t$1.validateSpec({
						key: a$1,
						value: e$1[a$1],
						valueSpec: n$1[a$1],
						validateSpec: t$1.validateSpec,
						style: i$1,
						styleSpec: r$1
					}) : [new Dt(a$1, e$1[a$1], `unknown property "${a$1}"`)]);
				}
				return s$1;
			}
			function qi(t$1) {
				const e$1 = t$1.value, r$1 = t$1.styleSpec, n$1 = r$1.sky, i$1 = t$1.style, s$1 = Xn(e$1);
				if (void 0 === e$1) return [];
				if ("object" !== s$1) return [new Dt("sky", e$1, `object expected, ${s$1} found`)];
				let a = [];
				for (const s$2 in e$1) a = a.concat(n$1[s$2] ? t$1.validateSpec({
					key: s$2,
					value: e$1[s$2],
					valueSpec: n$1[s$2],
					style: i$1,
					styleSpec: r$1
				}) : [new Dt(s$2, e$1[s$2], `unknown property "${s$2}"`)]);
				return a;
			}
			function ji(t$1) {
				const e$1 = t$1.value, r$1 = t$1.styleSpec, n$1 = r$1.terrain, i$1 = t$1.style;
				let s$1 = [];
				const a = Xn(e$1);
				if (void 0 === e$1) return s$1;
				if ("object" !== a) return s$1 = s$1.concat([new Dt("terrain", e$1, `object expected, ${a} found`)]), s$1;
				for (const a$1 in e$1) s$1 = s$1.concat(n$1[a$1] ? t$1.validateSpec({
					key: a$1,
					value: e$1[a$1],
					valueSpec: n$1[a$1],
					validateSpec: t$1.validateSpec,
					style: i$1,
					styleSpec: r$1
				}) : [new Dt(a$1, e$1[a$1], `unknown property "${a$1}"`)]);
				return s$1;
			}
			function Gi(t$1) {
				let e$1 = [];
				const r$1 = t$1.value, n$1 = t$1.key;
				if (Array.isArray(r$1)) {
					const i$1 = [], s$1 = [];
					for (const a in r$1) r$1[a].id && i$1.includes(r$1[a].id) && e$1.push(new Dt(n$1, r$1, `all the sprites' ids must be unique, but ${r$1[a].id} is duplicated`)), i$1.push(r$1[a].id), r$1[a].url && s$1.includes(r$1[a].url) && e$1.push(new Dt(n$1, r$1, `all the sprites' URLs must be unique, but ${r$1[a].url} is duplicated`)), s$1.push(r$1[a].url), e$1 = e$1.concat(Ei({
						key: `${n$1}[${a}]`,
						value: r$1[a],
						valueSpec: {
							id: {
								type: "string",
								required: !0
							},
							url: {
								type: "string",
								required: !0
							}
						},
						validateSpec: t$1.validateSpec
					}));
					return e$1;
				}
				return Ri({
					key: n$1,
					value: r$1
				});
			}
			function Xi(t$1) {
				return Boolean(t$1) && t$1.constructor === Object;
			}
			function Yi(t$1) {
				return Xi(t$1.value) ? [] : [new Dt(t$1.key, t$1.value, `object expected, ${Xn(t$1.value)} found`)];
			}
			const Zi = {
				"*": () => [],
				array: Ti,
				boolean: function(t$1) {
					const e$1 = t$1.value, r$1 = t$1.key, n$1 = Xn(e$1);
					return "boolean" !== n$1 ? [new Dt(r$1, e$1, `boolean expected, ${n$1} found`)] : [];
				},
				number: Ii,
				color: Di,
				constants: Si,
				enum: zi,
				filter: Pi,
				function: Mi,
				layer: Oi,
				object: Ei,
				source: $i,
				light: Ui,
				sky: qi,
				terrain: ji,
				projection: function(t$1) {
					const e$1 = t$1.value, r$1 = t$1.styleSpec, n$1 = r$1.projection, i$1 = t$1.style, s$1 = Xn(e$1);
					if (void 0 === e$1) return [];
					if ("object" !== s$1) return [new Dt("projection", e$1, `object expected, ${s$1} found`)];
					let a = [];
					for (const s$2 in e$1) a = a.concat(n$1[s$2] ? t$1.validateSpec({
						key: s$2,
						value: e$1[s$2],
						valueSpec: n$1[s$2],
						style: i$1,
						styleSpec: r$1
					}) : [new Dt(s$2, e$1[s$2], `unknown property "${s$2}"`)]);
					return a;
				},
				projectionDefinition: function(t$1) {
					const e$1 = t$1.key;
					let r$1 = t$1.value;
					r$1 = r$1 instanceof String ? r$1.valueOf() : r$1;
					const n$1 = Xn(r$1);
					return "array" !== n$1 || function(t$2) {
						return Array.isArray(t$2) && 3 === t$2.length && "string" == typeof t$2[0] && "string" == typeof t$2[1] && "number" == typeof t$2[2];
					}(r$1) || function(t$2) {
						return !![
							"interpolate",
							"step",
							"literal"
						].includes(t$2[0]);
					}(r$1) ? ["array", "string"].includes(n$1) ? [] : [new Dt(e$1, r$1, `projection expected, invalid type "${n$1}" found`)] : [new Dt(e$1, r$1, `projection expected, invalid array ${JSON.stringify(r$1)} found`)];
				},
				string: Ri,
				formatted: function(t$1) {
					return 0 === Ri(t$1).length ? [] : Fi(t$1);
				},
				resolvedImage: function(t$1) {
					return 0 === Ri(t$1).length ? [] : Fi(t$1);
				},
				padding: function(t$1) {
					const e$1 = t$1.key, r$1 = t$1.value;
					if ("array" === Xn(r$1)) {
						if (r$1.length < 1 || r$1.length > 4) return [new Dt(e$1, r$1, `padding requires 1 to 4 values; ${r$1.length} values found`)];
						const n$1 = { type: "number" };
						let i$1 = [];
						for (let s$1 = 0; s$1 < r$1.length; s$1++) i$1 = i$1.concat(t$1.validateSpec({
							key: `${e$1}[${s$1}]`,
							value: r$1[s$1],
							validateSpec: t$1.validateSpec,
							valueSpec: n$1
						}));
						return i$1;
					}
					return Ii({
						key: e$1,
						value: r$1,
						valueSpec: {}
					});
				},
				numberArray: function(t$1) {
					const e$1 = t$1.key, r$1 = t$1.value;
					if ("array" === Xn(r$1)) {
						const n$1 = { type: "number" };
						if (r$1.length < 1) return [new Dt(e$1, r$1, "array length at least 1 expected, length 0 found")];
						let i$1 = [];
						for (let s$1 = 0; s$1 < r$1.length; s$1++) i$1 = i$1.concat(t$1.validateSpec({
							key: `${e$1}[${s$1}]`,
							value: r$1[s$1],
							validateSpec: t$1.validateSpec,
							valueSpec: n$1
						}));
						return i$1;
					}
					return Ii({
						key: e$1,
						value: r$1,
						valueSpec: {}
					});
				},
				colorArray: function(t$1) {
					const e$1 = t$1.key, r$1 = t$1.value;
					if ("array" === Xn(r$1)) {
						if (r$1.length < 1) return [new Dt(e$1, r$1, "array length at least 1 expected, length 0 found")];
						let t$2 = [];
						for (let n$1 = 0; n$1 < r$1.length; n$1++) t$2 = t$2.concat(Di({
							key: `${e$1}[${n$1}]`,
							value: r$1[n$1]
						}));
						return t$2;
					}
					return Di({
						key: e$1,
						value: r$1
					});
				},
				variableAnchorOffsetCollection: function(t$1) {
					const e$1 = t$1.key, r$1 = t$1.value, n$1 = Xn(r$1), i$1 = t$1.styleSpec;
					if ("array" !== n$1 || r$1.length < 1 || r$1.length % 2 != 0) return [new Dt(e$1, r$1, "variableAnchorOffsetCollection requires a non-empty array of even length")];
					let s$1 = [];
					for (let n$2 = 0; n$2 < r$1.length; n$2 += 2) s$1 = s$1.concat(zi({
						key: `${e$1}[${n$2}]`,
						value: r$1[n$2],
						valueSpec: i$1.layout_symbol["text-anchor"]
					})), s$1 = s$1.concat(Ti({
						key: `${e$1}[${n$2 + 1}]`,
						value: r$1[n$2 + 1],
						valueSpec: {
							length: 2,
							value: "number"
						},
						validateSpec: t$1.validateSpec,
						style: t$1.style,
						styleSpec: i$1
					}));
					return s$1;
				},
				sprite: Gi,
				state: Yi,
				fontFaces: function(t$1) {
					const e$1 = t$1.key, r$1 = t$1.value, n$1 = t$1.validateSpec, i$1 = t$1.styleSpec, s$1 = t$1.style;
					if (!Xi(r$1)) return [new Dt(e$1, r$1, `object expected, ${Xn(r$1)} found`)];
					const a = [];
					for (const t$2 in r$1) {
						const o$1 = r$1[t$2], l$1 = Xn(o$1);
						if ("string" === l$1) a.push(...Ri({
							key: `${e$1}.${t$2}`,
							value: o$1
						}));
						else if ("array" === l$1) {
							const r$2 = {
								url: {
									type: "string",
									required: !0
								},
								"unicode-range": {
									type: "array",
									value: "string"
								}
							};
							for (const [l$2, u$1] of o$1.entries()) a.push(...Ei({
								key: `${e$1}.${t$2}[${l$2}]`,
								value: u$1,
								valueSpec: r$2,
								styleSpec: i$1,
								style: s$1,
								validateSpec: n$1
							}));
						} else a.push(new Dt(`${e$1}.${t$2}`, o$1, `string or array expected, ${l$1} found`));
					}
					return a;
				}
			};
			function Hi(t$1) {
				const e$1 = t$1.value, r$1 = t$1.valueSpec, n$1 = t$1.styleSpec;
				return t$1.validateSpec = Hi, r$1.expression && Yn(Ai(e$1)) ? Mi(t$1) : r$1.expression && ri(ki(e$1)) ? Fi(t$1) : r$1.type && Zi[r$1.type] ? Zi[r$1.type](t$1) : Ei(zt({}, t$1, { valueSpec: r$1.type ? n$1[r$1.type] : r$1 }));
			}
			function Ki(t$1) {
				const e$1 = t$1.value, r$1 = t$1.key, n$1 = Ri(t$1);
				return n$1.length || (-1 === e$1.indexOf("{fontstack}") && n$1.push(new Dt(r$1, e$1, "\"glyphs\" url must include a \"{fontstack}\" token")), -1 === e$1.indexOf("{range}") && n$1.push(new Dt(r$1, e$1, "\"glyphs\" url must include a \"{range}\" token"))), n$1;
			}
			function Wi(t$1, e$1 = vt) {
				let r$1 = [];
				return r$1 = r$1.concat(Hi({
					key: "",
					value: t$1,
					valueSpec: e$1.$root,
					styleSpec: e$1,
					style: t$1,
					validateSpec: Hi,
					objectElementValidators: {
						glyphs: Ki,
						"*": () => []
					}
				})), t$1.constants && (r$1 = r$1.concat(Si({
					key: "constants",
					value: t$1.constants
				}))), Qi(r$1);
			}
			function Ji(t$1) {
				return function(e$1) {
					return t$1(Object.assign({}, e$1, { validateSpec: Hi }));
				};
			}
			function Qi(t$1) {
				return [].concat(t$1).sort(((t$2, e$1) => t$2.line - e$1.line));
			}
			function ts(t$1) {
				return function(...e$1) {
					return Qi(t$1.apply(this, e$1));
				};
			}
			Wi.source = ts(Ji($i)), Wi.sprite = ts(Ji(Gi)), Wi.glyphs = ts(Ji(Ki)), Wi.light = ts(Ji(Ui)), Wi.sky = ts(Ji(qi)), Wi.terrain = ts(Ji(ji)), Wi.state = ts(Ji(Yi)), Wi.layer = ts(Ji(Oi)), Wi.filter = ts(Ji(Pi)), Wi.paintProperty = ts(Ji(Ci)), Wi.layoutProperty = ts(Ji(Li));
			const es = {
				type: "enum",
				"property-type": "data-constant",
				expression: {
					interpolated: !1,
					parameters: ["global-state"]
				},
				values: {
					visible: {},
					none: {}
				},
				transition: !1,
				default: "visible"
			};
			class rs {
				constructor(t$1, e$1) {
					this._globalState = e$1, this.setValue(t$1);
				}
				evaluate() {
					var t$1;
					return null !== (t$1 = this._literalValue) && void 0 !== t$1 ? t$1 : this._compiledValue.evaluate({});
				}
				setValue(t$1) {
					if (null == t$1 || "visible" === t$1 || "none" === t$1) return this._literalValue = "none" === t$1 ? "none" : "visible", this._compiledValue = void 0, void (this._globalStateRefs = /* @__PURE__ */ new Set());
					const e$1 = ni(t$1, es, this._globalState);
					if ("error" === e$1.result) throw this._literalValue = "visible", this._compiledValue = void 0, new Error(e$1.value.map(((t$2) => `${t$2.key}: ${t$2.message}`)).join(", "));
					this._literalValue = void 0, this._compiledValue = e$1.value, this._globalStateRefs = ui(e$1.value.expression);
				}
				getGlobalStateRefs() {
					return this._globalStateRefs;
				}
			}
			const ns = vt, is = Wi, ss = is.light, as = is.sky, os = is.paintProperty, ls = is.layoutProperty;
			function us(t$1, e$1) {
				let r$1 = !1;
				if (e$1 && e$1.length) for (const n$1 of e$1) t$1.fire(new gt(new Error(n$1.message))), r$1 = !0;
				return r$1;
			}
			class cs {
				constructor(t$1, e$1, r$1) {
					const n$1 = this.cells = [];
					if (t$1 instanceof ArrayBuffer) {
						this.arrayBuffer = t$1;
						const i$2 = new Int32Array(this.arrayBuffer);
						t$1 = i$2[0], this.d = (e$1 = i$2[1]) + 2 * (r$1 = i$2[2]);
						for (let t$2 = 0; t$2 < this.d * this.d; t$2++) {
							const e$2 = i$2[3 + t$2], r$2 = i$2[3 + t$2 + 1];
							n$1.push(e$2 === r$2 ? null : i$2.subarray(e$2, r$2));
						}
						const s$1 = i$2[3 + n$1.length + 1];
						this.keys = i$2.subarray(i$2[3 + n$1.length], s$1), this.bboxes = i$2.subarray(s$1), this.insert = this._insertReadonly;
					} else {
						this.d = e$1 + 2 * r$1;
						for (let t$2 = 0; t$2 < this.d * this.d; t$2++) n$1.push([]);
						this.keys = [], this.bboxes = [];
					}
					this.n = e$1, this.extent = t$1, this.padding = r$1, this.scale = e$1 / t$1, this.uid = 0;
					const i$1 = r$1 / e$1 * t$1;
					this.min = -i$1, this.max = t$1 + i$1;
				}
				insert(t$1, e$1, r$1, n$1, i$1) {
					this._forEachCell(e$1, r$1, n$1, i$1, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t$1), this.bboxes.push(e$1), this.bboxes.push(r$1), this.bboxes.push(n$1), this.bboxes.push(i$1);
				}
				_insertReadonly() {
					throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
				}
				_insertCell(t$1, e$1, r$1, n$1, i$1, s$1) {
					this.cells[i$1].push(s$1);
				}
				query(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = this.min, a = this.max;
					if (t$1 <= s$1 && e$1 <= s$1 && a <= r$1 && a <= n$1 && !i$1) return Array.prototype.slice.call(this.keys);
					{
						const s$2 = [];
						return this._forEachCell(t$1, e$1, r$1, n$1, this._queryCell, s$2, {}, i$1), s$2;
					}
				}
				_queryCell(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1) {
					const l$1 = this.cells[i$1];
					if (null !== l$1) {
						const i$2 = this.keys, u$1 = this.bboxes;
						for (let c$1 = 0; c$1 < l$1.length; c$1++) {
							const h$1 = l$1[c$1];
							if (void 0 === a[h$1]) {
								const l$2 = 4 * h$1;
								(o$1 ? o$1(u$1[l$2 + 0], u$1[l$2 + 1], u$1[l$2 + 2], u$1[l$2 + 3]) : t$1 <= u$1[l$2 + 2] && e$1 <= u$1[l$2 + 3] && r$1 >= u$1[l$2 + 0] && n$1 >= u$1[l$2 + 1]) ? (a[h$1] = !0, s$1.push(i$2[h$1])) : a[h$1] = !1;
							}
						}
					}
				}
				_forEachCell(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1) {
					const l$1 = this._convertToCellCoord(t$1), u$1 = this._convertToCellCoord(e$1), c$1 = this._convertToCellCoord(r$1), h$1 = this._convertToCellCoord(n$1);
					for (let p$1 = l$1; p$1 <= c$1; p$1++) for (let l$2 = u$1; l$2 <= h$1; l$2++) {
						const u$2 = this.d * l$2 + p$1;
						if ((!o$1 || o$1(this._convertFromCellCoord(p$1), this._convertFromCellCoord(l$2), this._convertFromCellCoord(p$1 + 1), this._convertFromCellCoord(l$2 + 1))) && i$1.call(this, t$1, e$1, r$1, n$1, u$2, s$1, a, o$1)) return;
					}
				}
				_convertFromCellCoord(t$1) {
					return (t$1 - this.padding) / this.scale;
				}
				_convertToCellCoord(t$1) {
					return Math.max(0, Math.min(this.d - 1, Math.floor(t$1 * this.scale) + this.padding));
				}
				toArrayBuffer() {
					if (this.arrayBuffer) return this.arrayBuffer;
					const t$1 = this.cells, e$1 = 3 + this.cells.length + 1 + 1;
					let r$1 = 0;
					for (let t$2 = 0; t$2 < this.cells.length; t$2++) r$1 += this.cells[t$2].length;
					const n$1 = new Int32Array(e$1 + r$1 + this.keys.length + this.bboxes.length);
					n$1[0] = this.extent, n$1[1] = this.n, n$1[2] = this.padding;
					let i$1 = e$1;
					for (let e$2 = 0; e$2 < t$1.length; e$2++) {
						const r$2 = t$1[e$2];
						n$1[3 + e$2] = i$1, n$1.set(r$2, i$1), i$1 += r$2.length;
					}
					return n$1[3 + t$1.length] = i$1, n$1.set(this.keys, i$1), i$1 += this.keys.length, n$1[3 + t$1.length + 1] = i$1, n$1.set(this.bboxes, i$1), i$1 += this.bboxes.length, n$1.buffer;
				}
				static serialize(t$1, e$1) {
					const r$1 = t$1.toArrayBuffer();
					return e$1 && e$1.push(r$1), { buffer: r$1 };
				}
				static deserialize(t$1) {
					return new cs(t$1.buffer);
				}
			}
			const hs = {};
			function ps(t$1, e$1, r$1 = {}) {
				if (hs[t$1]) throw new Error(`${t$1} is already registered.`);
				Object.defineProperty(e$1, "_classRegistryKey", {
					value: t$1,
					writeable: !1
				}), hs[t$1] = {
					klass: e$1,
					omit: r$1.omit || [],
					shallow: r$1.shallow || []
				};
			}
			ps("Object", Object), ps("Set", Set), ps("TransferableGridIndex", cs), ps("Color", Te), ps("Error", Error), ps("AJAXError", ct), ps("ResolvedImage", Oe), ps("StylePropertyFunction", oi), ps("StyleExpression", ei, { omit: ["_evaluator"] }), ps("ZoomDependentExpression", si), ps("ZoomConstantExpression", ii), ps("CompoundExpression", zn, { omit: ["_evaluate"] });
			for (const t$1 in Dn) Dn[t$1]._classRegistryKey || ps(`Expression_${t$1}`, Dn[t$1]);
			function fs(t$1) {
				return t$1 && "undefined" != typeof ArrayBuffer && (t$1 instanceof ArrayBuffer || t$1.constructor && "ArrayBuffer" === t$1.constructor.name);
			}
			function ds(t$1) {
				return t$1.$name || t$1.constructor._classRegistryKey;
			}
			function ys(t$1) {
				return !function(t$2) {
					if (null === t$2 || "object" != typeof t$2) return !1;
					const e$1 = ds(t$2);
					return !(!e$1 || "Object" === e$1);
				}(t$1) && (null == t$1 || "boolean" == typeof t$1 || "number" == typeof t$1 || "string" == typeof t$1 || t$1 instanceof Boolean || t$1 instanceof Number || t$1 instanceof String || t$1 instanceof Date || t$1 instanceof RegExp || t$1 instanceof Blob || t$1 instanceof Error || fs(t$1) || Z(t$1) || ArrayBuffer.isView(t$1) || t$1 instanceof ImageData);
			}
			function ms(t$1, e$1) {
				if (ys(t$1)) return (fs(t$1) || Z(t$1)) && e$1 && e$1.push(t$1), ArrayBuffer.isView(t$1) && e$1 && e$1.push(t$1.buffer), t$1 instanceof ImageData && e$1 && e$1.push(t$1.data.buffer), t$1;
				if (Array.isArray(t$1)) {
					const r$2 = [];
					for (const n$2 of t$1) r$2.push(ms(n$2, e$1));
					return r$2;
				}
				if ("object" != typeof t$1) throw new Error("can't serialize object of type " + typeof t$1);
				const r$1 = ds(t$1);
				if (!r$1) throw new Error(`can't serialize object of unregistered class ${t$1.constructor.name}`);
				if (!hs[r$1]) throw new Error(`${r$1} is not registered.`);
				const { klass: n$1 } = hs[r$1], i$1 = n$1.serialize ? n$1.serialize(t$1, e$1) : {};
				if (n$1.serialize) {
					if (e$1 && i$1 === e$1[e$1.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
				} else {
					for (const n$2 in t$1) {
						if (!t$1.hasOwnProperty(n$2)) continue;
						if (hs[r$1].omit.indexOf(n$2) >= 0) continue;
						const s$1 = t$1[n$2];
						i$1[n$2] = hs[r$1].shallow.indexOf(n$2) >= 0 ? s$1 : ms(s$1, e$1);
					}
					t$1 instanceof Error && (i$1.message = t$1.message);
				}
				if (i$1.$name) throw new Error("$name property is reserved for worker serialization logic.");
				return "Object" !== r$1 && (i$1.$name = r$1), i$1;
			}
			function gs(t$1) {
				if (ys(t$1)) return t$1;
				if (Array.isArray(t$1)) return t$1.map(gs);
				if ("object" != typeof t$1) throw new Error("can't deserialize object of type " + typeof t$1);
				const e$1 = ds(t$1) || "Object";
				if (!hs[e$1]) throw new Error(`can't deserialize unregistered class ${e$1}`);
				const { klass: r$1 } = hs[e$1];
				if (!r$1) throw new Error(`can't deserialize unregistered class ${e$1}`);
				if (r$1.deserialize) return r$1.deserialize(t$1);
				const n$1 = Object.create(r$1.prototype);
				for (const r$2 of Object.keys(t$1)) {
					if ("$name" === r$2) continue;
					const i$1 = t$1[r$2];
					n$1[r$2] = hs[e$1].shallow.indexOf(r$2) >= 0 ? i$1 : gs(i$1);
				}
				return n$1;
			}
			class xs {
				constructor() {
					this.first = !0;
				}
				update(t$1, e$1) {
					const r$1 = Math.floor(t$1);
					return this.first ? (this.first = !1, this.lastIntegerZoom = r$1, this.lastIntegerZoomTime = 0, this.lastZoom = t$1, this.lastFloorZoom = r$1, !0) : (this.lastFloorZoom > r$1 ? (this.lastIntegerZoom = r$1 + 1, this.lastIntegerZoomTime = e$1) : this.lastFloorZoom < r$1 && (this.lastIntegerZoom = r$1, this.lastIntegerZoomTime = e$1), t$1 !== this.lastZoom && (this.lastZoom = t$1, this.lastFloorZoom = r$1, !0));
				}
			}
			function vs(t$1) {
				return /[\u02EA\u02EB\u2E80-\u2FDF\u2FF0-\u303F\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FD-\u30FF\u3105-\u312F\u31A0-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uF900-\uFA6D\uFA70-\uFAD9\uFE10-\uFE1F\uFE30-\uFE4F\uFF00-\uFFEF]|\uD81B[\uDFE0-\uDFFF]|[\uD81C-\uD822\uD840-\uD868\uD86A-\uD86D\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD88C][\uDC00-\uDFFF]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD1E\uDD80-\uDDF2]|\uD82B[\uDFF0-\uDFFF]|\uD82C[\uDC00-\uDEFB]|\uD83C[\uDE00-\uDEFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEAD\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD88D[\uDC00-\uDC79]/gim.test(String.fromCodePoint(t$1));
			}
			function bs(t$1) {
				return /[\u02EA\u02EB\u1100-\u11FF\u1400-\u167F\u18B0-\u18F5\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u3007\u3012\u3013\u3020-\u302F\u3031-\u303F\u3041-\u3096\u309D-\u30FB\u30FD-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFE10-\uFE1F\uFE30-\uFE48\uFE50-\uFE57\uFE5F-\uFE62\uFE67-\uFE6F\uFF00-\uFF07\uFF0A-\uFF0C\uFF0E-\uFF19\uFF1F-\uFF3A\uFF3C\uFF3E\uFF40-\uFF5A\uFFE0-\uFFE2\uFFE4-\uFFE7]|\uD802[\uDD80-\uDD9F]|\uD805[\uDD80-\uDDFF]|\uD806[\uDE00-\uDEBF]|\uD811[\uDC00-\uDE7F]|\uD81B[\uDFE0-\uDFE4\uDFF0-\uDFF6]|[\uD81C-\uD822\uD83D\uD840-\uD868\uD86A-\uD86D\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD88C][\uDC00-\uDFFF]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD1E\uDD80-\uDDF2]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD30-\uDEFB]|\uD833[\uDEC0-\uDFCF]|\uD834[\uDC00-\uDDFF\uDEE0-\uDF7F]|\uD836[\uDC00-\uDEAF]|\uD83C[\uDC00-\uDE00\uDF00-\uDFFF]|\uD83E[\uDD00-\uDEFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEAD\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD88D[\uDC00-\uDC79]/gim.test(String.fromCodePoint(t$1));
			}
			function ws(t$1) {
				return /\s/u.test(String.fromCodePoint(t$1));
			}
			function _s(t$1) {
				for (const e$1 of t$1) if (bs(e$1.codePointAt(0))) return !0;
				return !1;
			}
			function Ss(t$1) {
				for (const e$1 of t$1) if (!Es(e$1.codePointAt(0))) return !1;
				return !0;
			}
			function As(t$1) {
				const e$1 = t$1.map(((t$2) => {
					try {
						return new RegExp(`\\p{sc=${t$2}}`, "u").source;
					} catch (t$3) {
						return null;
					}
				})).filter(((t$2) => t$2));
				return new RegExp(e$1.join("|"), "u");
			}
			const ks = As([
				"Arab",
				"Dupl",
				"Mong",
				"Ougr",
				"Syrc"
			]);
			function Es(t$1) {
				return !ks.test(String.fromCodePoint(t$1));
			}
			function Ts(t$1) {
				return !(bs(t$1) || (e$1 = t$1, /[\xA7\xA9\xAE\xB1\xBC-\xBE\xD7\xF7\u2016\u2020\u2021\u2030\u2031\u203B\u203C\u2042\u2047-\u2049\u2051\u2100-\u218F\u221E\u2234\u2235\u2300-\u2307\u230C-\u231F\u2324-\u2328\u232B\u237D-\u239A\u23BE-\u23CD\u23CF\u23D1-\u23DB\u23E2-\u2422\u2424-\u24FF\u25A0-\u2619\u2620-\u2767\u2776-\u2793\u2B12-\u2B2F\u2B50-\u2B59\u2BB8-\u2BEB\u3000-\u303F\u30A0-\u30FF\uE000-\uF8FF\uFE30-\uFE6F\uFF00-\uFFEF\uFFFC\uFFFD]|[\uDB80-\uDBFF][\uDC00-\uDFFF]/gim.test(String.fromCodePoint(e$1))));
				var e$1;
			}
			const Is = As([
				"Adlm",
				"Arab",
				"Armi",
				"Avst",
				"Chrs",
				"Cprt",
				"Egyp",
				"Elym",
				"Gara",
				"Hatr",
				"Hebr",
				"Hung",
				"Khar",
				"Lydi",
				"Mand",
				"Mani",
				"Mend",
				"Merc",
				"Mero",
				"Narb",
				"Nbat",
				"Nkoo",
				"Orkh",
				"Palm",
				"Phli",
				"Phlp",
				"Phnx",
				"Prti",
				"Rohg",
				"Samr",
				"Sarb",
				"Sogo",
				"Syrc",
				"Thaa",
				"Todr",
				"Yezi"
			]);
			function Ms(t$1) {
				return Is.test(String.fromCodePoint(t$1));
			}
			function Fs(t$1, e$1) {
				return !(!e$1 && Ms(t$1) || /[\u0900-\u0DFF\u0F00-\u109F\u1780-\u17FF]/gim.test(String.fromCodePoint(t$1)));
			}
			function Ds(t$1) {
				for (const e$1 of t$1) if (Ms(e$1.codePointAt(0))) return !0;
				return !1;
			}
			const zs = new class {
				constructor() {
					this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {};
				}
				setState(t$1) {
					this.pluginStatus = t$1.pluginStatus, this.pluginURL = t$1.pluginURL;
				}
				getState() {
					return {
						pluginStatus: this.pluginStatus,
						pluginURL: this.pluginURL
					};
				}
				setMethods(t$1) {
					if (zs.isParsed()) throw new Error("RTL text plugin already registered.");
					this.applyArabicShaping = t$1.applyArabicShaping, this.processBidirectionalText = t$1.processBidirectionalText, this.processStyledBidirectionalText = t$1.processStyledBidirectionalText, this.loadScriptResolve();
				}
				isParsed() {
					return null != this.applyArabicShaping && null != this.processBidirectionalText && null != this.processStyledBidirectionalText;
				}
				getRTLTextPluginStatus() {
					return this.pluginStatus;
				}
				syncState(t$1, r$1) {
					return e(this, void 0, void 0, (function* () {
						if (this.isParsed()) return this.getState();
						if ("loading" !== t$1.pluginStatus) return this.setState(t$1), t$1;
						const e$1 = t$1.pluginURL, n$1 = new Promise(((t$2) => {
							this.loadScriptResolve = t$2;
						}));
						r$1(e$1);
						const i$1 = new Promise(((t$2) => setTimeout((() => t$2()), this.TIMEOUT)));
						if (yield Promise.race([n$1, i$1]), this.isParsed()) {
							const t$2 = {
								pluginStatus: "loaded",
								pluginURL: e$1
							};
							return this.setState(t$2), t$2;
						}
						throw this.setState({
							pluginStatus: "error",
							pluginURL: ""
						}), /* @__PURE__ */ new Error(`RTL Text Plugin failed to import scripts from ${e$1}`);
					}));
				}
			}();
			class Ps {
				constructor(t$1, e$1) {
					this.isSupportedScript = Bs, this.zoom = t$1, e$1 ? (this.now = e$1.now || 0, this.fadeDuration = e$1.fadeDuration || 0, this.zoomHistory = e$1.zoomHistory || new xs(), this.transition = e$1.transition || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new xs(), this.transition = {});
				}
				crossFadingFactor() {
					return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
				}
				getCrossfadeParameters() {
					const t$1 = this.zoom, e$1 = t$1 - Math.floor(t$1), r$1 = this.crossFadingFactor();
					return t$1 > this.zoomHistory.lastIntegerZoom ? {
						fromScale: 2,
						toScale: 1,
						t: e$1 + (1 - e$1) * r$1
					} : {
						fromScale: .5,
						toScale: 1,
						t: 1 - (1 - r$1) * e$1
					};
				}
			}
			function Bs(t$1) {
				return function(t$2, e$1) {
					for (const r$1 of t$2) if (!Fs(r$1.codePointAt(0), e$1)) return !1;
					return !0;
				}(t$1, "loaded" === zs.getRTLTextPluginStatus());
			}
			const Vs = "-transition";
			class Cs {
				constructor(t$1, e$1, r$1) {
					this.property = t$1, this.value = e$1, this.expression = function(t$2, e$2, r$2) {
						if (Yn(t$2)) return new oi(t$2, e$2);
						if (ri(t$2)) {
							const n$1 = ai(t$2, e$2, r$2);
							if ("error" === n$1.result) throw new Error(n$1.value.map(((t$3) => `${t$3.key}: ${t$3.message}`)).join(", "));
							return n$1.value;
						}
						{
							let r$3 = t$2;
							return "color" === e$2.type && "string" == typeof t$2 ? r$3 = Te.parse(t$2) : "padding" !== e$2.type || "number" != typeof t$2 && !Array.isArray(t$2) ? "numberArray" !== e$2.type || "number" != typeof t$2 && !Array.isArray(t$2) ? "colorArray" !== e$2.type || "string" != typeof t$2 && !Array.isArray(t$2) ? "variableAnchorOffsetCollection" === e$2.type && Array.isArray(t$2) ? r$3 = Le.parse(t$2) : "projectionDefinition" === e$2.type && "string" == typeof t$2 && (r$3 = Re.parse(t$2)) : r$3 = Be.parse(t$2) : r$3 = Pe.parse(t$2) : r$3 = ze.parse(t$2), {
								globalStateRefs: /* @__PURE__ */ new Set(),
								_globalState: null,
								kind: "constant",
								evaluate: () => r$3
							};
						}
					}(void 0 === e$1 ? t$1.specification.default : e$1, t$1.specification, r$1);
				}
				isDataDriven() {
					return "source" === this.expression.kind || "composite" === this.expression.kind;
				}
				getGlobalStateRefs() {
					return this.expression.globalStateRefs || /* @__PURE__ */ new Set();
				}
				possiblyEvaluate(t$1, e$1, r$1) {
					return this.property.possiblyEvaluate(this, t$1, e$1, r$1);
				}
			}
			class Ls {
				constructor(t$1, e$1) {
					this.property = t$1, this.value = new Cs(t$1, void 0, e$1);
				}
				transitioned(t$1, e$1) {
					return new Rs(this.property, this.value, e$1, O({}, t$1.transition, this.transition), t$1.now);
				}
				untransitioned() {
					return new Rs(this.property, this.value, null, {}, 0);
				}
			}
			class Os {
				constructor(t$1, e$1) {
					this._properties = t$1, this._values = Object.create(t$1.defaultTransitionablePropertyValues), this._globalState = e$1;
				}
				getValue(t$1) {
					return U(this._values[t$1].value.value);
				}
				setValue(t$1, e$1) {
					Object.prototype.hasOwnProperty.call(this._values, t$1) || (this._values[t$1] = new Ls(this._values[t$1].property, this._globalState)), this._values[t$1].value = new Cs(this._values[t$1].property, null === e$1 ? void 0 : U(e$1), this._globalState);
				}
				getTransition(t$1) {
					return U(this._values[t$1].transition);
				}
				setTransition(t$1, e$1) {
					Object.prototype.hasOwnProperty.call(this._values, t$1) || (this._values[t$1] = new Ls(this._values[t$1].property, this._globalState)), this._values[t$1].transition = U(e$1) || void 0;
				}
				serialize() {
					const t$1 = {};
					for (const e$1 of Object.keys(this._values)) {
						const r$1 = this.getValue(e$1);
						void 0 !== r$1 && (t$1[e$1] = r$1);
						const n$1 = this.getTransition(e$1);
						void 0 !== n$1 && (t$1[`${e$1}${Vs}`] = n$1);
					}
					return t$1;
				}
				transitioned(t$1, e$1) {
					const r$1 = new Ns(this._properties);
					for (const n$1 of Object.keys(this._values)) r$1._values[n$1] = this._values[n$1].transitioned(t$1, e$1._values[n$1]);
					return r$1;
				}
				untransitioned() {
					const t$1 = new Ns(this._properties);
					for (const e$1 of Object.keys(this._values)) t$1._values[e$1] = this._values[e$1].untransitioned();
					return t$1;
				}
			}
			class Rs {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.property = t$1, this.value = e$1, this.begin = i$1 + n$1.delay || 0, this.end = this.begin + n$1.duration || 0, t$1.specification.transition && (n$1.delay || n$1.duration) && (this.prior = r$1);
				}
				possiblyEvaluate(t$1, e$1, r$1) {
					const n$1 = t$1.now || 0, i$1 = this.value.possiblyEvaluate(t$1, e$1, r$1), s$1 = this.prior;
					if (s$1) {
						if (n$1 > this.end) return this.prior = null, i$1;
						if (this.value.isDataDriven()) return this.prior = null, i$1;
						if (n$1 < this.begin) return s$1.possiblyEvaluate(t$1, e$1, r$1);
						{
							const a = (n$1 - this.begin) / (this.end - this.begin);
							return this.property.interpolate(s$1.possiblyEvaluate(t$1, e$1, r$1), i$1, P(a));
						}
					}
					return i$1;
				}
			}
			class Ns {
				constructor(t$1) {
					this._properties = t$1, this._values = Object.create(t$1.defaultTransitioningPropertyValues);
				}
				possiblyEvaluate(t$1, e$1, r$1) {
					const n$1 = new qs(this._properties);
					for (const i$1 of Object.keys(this._values)) n$1._values[i$1] = this._values[i$1].possiblyEvaluate(t$1, e$1, r$1);
					return n$1;
				}
				hasTransition() {
					for (const t$1 of Object.keys(this._values)) if (this._values[t$1].prior) return !0;
					return !1;
				}
			}
			class $s {
				constructor(t$1, e$1) {
					this._properties = t$1, this._values = Object.create(t$1.defaultPropertyValues), this._globalState = e$1;
				}
				hasValue(t$1) {
					return void 0 !== this._values[t$1].value;
				}
				getValue(t$1) {
					return U(this._values[t$1].value);
				}
				setValue(t$1, e$1) {
					this._values[t$1] = new Cs(this._values[t$1].property, null === e$1 ? void 0 : U(e$1), this._globalState);
				}
				serialize() {
					const t$1 = {};
					for (const e$1 of Object.keys(this._values)) {
						const r$1 = this.getValue(e$1);
						void 0 !== r$1 && (t$1[e$1] = r$1);
					}
					return t$1;
				}
				possiblyEvaluate(t$1, e$1, r$1) {
					const n$1 = new qs(this._properties);
					for (const i$1 of Object.keys(this._values)) n$1._values[i$1] = this._values[i$1].possiblyEvaluate(t$1, e$1, r$1);
					return n$1;
				}
			}
			class Us {
				constructor(t$1, e$1, r$1) {
					this.property = t$1, this.value = e$1, this.parameters = r$1;
				}
				isConstant() {
					return "constant" === this.value.kind;
				}
				constantOr(t$1) {
					return "constant" === this.value.kind ? this.value.value : t$1;
				}
				evaluate(t$1, e$1, r$1, n$1) {
					return this.property.evaluate(this.value, this.parameters, t$1, e$1, r$1, n$1);
				}
			}
			class qs {
				constructor(t$1) {
					this._properties = t$1, this._values = Object.create(t$1.defaultPossiblyEvaluatedValues);
				}
				get(t$1) {
					return this._values[t$1];
				}
			}
			class js {
				constructor(t$1) {
					this.specification = t$1;
				}
				possiblyEvaluate(t$1, e$1) {
					if (t$1.isDataDriven()) throw new Error("Value should not be data driven");
					return t$1.expression.evaluate(e$1);
				}
				interpolate(t$1, e$1, r$1) {
					const n$1 = yr[this.specification.type];
					return n$1 ? n$1(t$1, e$1, r$1) : t$1;
				}
			}
			class Gs {
				constructor(t$1, e$1) {
					this.specification = t$1, this.overrides = e$1;
				}
				possiblyEvaluate(t$1, e$1, r$1, n$1) {
					return new Us(this, "constant" === t$1.expression.kind || "camera" === t$1.expression.kind ? {
						kind: "constant",
						value: t$1.expression.evaluate(e$1, null, {}, r$1, n$1)
					} : t$1.expression, e$1);
				}
				interpolate(t$1, e$1, r$1) {
					if ("constant" !== t$1.value.kind || "constant" !== e$1.value.kind) return t$1;
					if (void 0 === t$1.value.value || void 0 === e$1.value.value) return new Us(this, {
						kind: "constant",
						value: void 0
					}, t$1.parameters);
					const n$1 = yr[this.specification.type];
					if (n$1) {
						const i$1 = n$1(t$1.value.value, e$1.value.value, r$1);
						return new Us(this, {
							kind: "constant",
							value: i$1
						}, t$1.parameters);
					}
					return t$1;
				}
				evaluate(t$1, e$1, r$1, n$1, i$1, s$1) {
					return "constant" === t$1.kind ? t$1.value : t$1.evaluate(e$1, r$1, n$1, i$1, s$1);
				}
			}
			class Xs extends Gs {
				possiblyEvaluate(t$1, e$1, r$1, n$1) {
					if (void 0 === t$1.value) return new Us(this, {
						kind: "constant",
						value: void 0
					}, e$1);
					if ("constant" === t$1.expression.kind) {
						const i$1 = t$1.expression.evaluate(e$1, null, {}, r$1, n$1), s$1 = "resolvedImage" === t$1.property.specification.type && "string" != typeof i$1 ? i$1.name : i$1, a = this._calculate(s$1, s$1, s$1, e$1);
						return new Us(this, {
							kind: "constant",
							value: a
						}, e$1);
					}
					if ("camera" === t$1.expression.kind) {
						const r$2 = this._calculate(t$1.expression.evaluate({ zoom: e$1.zoom - 1 }), t$1.expression.evaluate({ zoom: e$1.zoom }), t$1.expression.evaluate({ zoom: e$1.zoom + 1 }), e$1);
						return new Us(this, {
							kind: "constant",
							value: r$2
						}, e$1);
					}
					return new Us(this, t$1.expression, e$1);
				}
				evaluate(t$1, e$1, r$1, n$1, i$1, s$1) {
					if ("source" === t$1.kind) {
						const a = t$1.evaluate(e$1, r$1, n$1, i$1, s$1);
						return this._calculate(a, a, a, e$1);
					}
					return "composite" === t$1.kind ? this._calculate(t$1.evaluate({ zoom: Math.floor(e$1.zoom) - 1 }, r$1, n$1), t$1.evaluate({ zoom: Math.floor(e$1.zoom) }, r$1, n$1), t$1.evaluate({ zoom: Math.floor(e$1.zoom) + 1 }, r$1, n$1), e$1) : t$1.value;
				}
				_calculate(t$1, e$1, r$1, n$1) {
					return n$1.zoom > n$1.zoomHistory.lastIntegerZoom ? {
						from: t$1,
						to: e$1
					} : {
						from: r$1,
						to: e$1
					};
				}
				interpolate(t$1) {
					return t$1;
				}
			}
			class Ys {
				constructor(t$1) {
					this.specification = t$1;
				}
				possiblyEvaluate(t$1, e$1, r$1, n$1) {
					if (void 0 !== t$1.value) {
						if ("constant" === t$1.expression.kind) {
							const i$1 = t$1.expression.evaluate(e$1, null, {}, r$1, n$1);
							return this._calculate(i$1, i$1, i$1, e$1);
						}
						return this._calculate(t$1.expression.evaluate(new Ps(Math.floor(e$1.zoom - 1), e$1)), t$1.expression.evaluate(new Ps(Math.floor(e$1.zoom), e$1)), t$1.expression.evaluate(new Ps(Math.floor(e$1.zoom + 1), e$1)), e$1);
					}
				}
				_calculate(t$1, e$1, r$1, n$1) {
					return n$1.zoom > n$1.zoomHistory.lastIntegerZoom ? {
						from: t$1,
						to: e$1
					} : {
						from: r$1,
						to: e$1
					};
				}
				interpolate(t$1) {
					return t$1;
				}
			}
			class Zs {
				constructor(t$1) {
					this.specification = t$1;
				}
				possiblyEvaluate(t$1, e$1, r$1, n$1) {
					return !!t$1.expression.evaluate(e$1, null, {}, r$1, n$1);
				}
				interpolate() {
					return !1;
				}
			}
			class Hs {
				constructor(t$1) {
					this.properties = t$1, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
					for (const e$1 in t$1) {
						const r$1 = t$1[e$1];
						r$1.specification.overridable && this.overridableProperties.push(e$1);
						const n$1 = this.defaultPropertyValues[e$1] = new Cs(r$1, void 0, void 0), i$1 = this.defaultTransitionablePropertyValues[e$1] = new Ls(r$1, void 0);
						this.defaultTransitioningPropertyValues[e$1] = i$1.untransitioned(), this.defaultPossiblyEvaluatedValues[e$1] = n$1.possiblyEvaluate({});
					}
				}
			}
			ps("DataDrivenProperty", Gs), ps("DataConstantProperty", js), ps("CrossFadedDataDrivenProperty", Xs), ps("CrossFadedProperty", Ys), ps("ColorRampProperty", Zs);
			class Ks extends xt {
				constructor(t$1, e$1, r$1) {
					if (super(), this.id = t$1.id, this.type = t$1.type, this._globalState = r$1, this._featureFilter = {
						filter: () => !0,
						needGeometry: !1,
						getGlobalStateRefs: () => /* @__PURE__ */ new Set()
					}, this._visibilityExpression = function(t$2, e$2) {
						return new rs(t$2, e$2);
					}(this.visibility, r$1), "custom" !== t$1.type && (this.metadata = t$1.metadata, this.minzoom = t$1.minzoom, this.maxzoom = t$1.maxzoom, "background" !== t$1.type && (this.source = t$1.source, this.sourceLayer = t$1["source-layer"], this.filter = t$1.filter, this._featureFilter = fi(t$1.filter, r$1)), e$1.layout && (this._unevaluatedLayout = new $s(e$1.layout, r$1)), e$1.paint)) {
						this._transitionablePaint = new Os(e$1.paint, r$1);
						for (const e$2 in t$1.paint) this.setPaintProperty(e$2, t$1.paint[e$2], { validate: !1 });
						for (const e$2 in t$1.layout) this.setLayoutProperty(e$2, t$1.layout[e$2], { validate: !1 });
						this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new qs(e$1.paint);
					}
				}
				setFilter(t$1) {
					this.filter = t$1, this._featureFilter = fi(t$1, this._globalState);
				}
				getCrossfadeParameters() {
					return this._crossfadeParameters;
				}
				getLayoutProperty(t$1) {
					return "visibility" === t$1 ? this.visibility : this._unevaluatedLayout.getValue(t$1);
				}
				getLayoutAffectingGlobalStateRefs() {
					const t$1 = /* @__PURE__ */ new Set();
					for (const e$1 of this._visibilityExpression.getGlobalStateRefs()) t$1.add(e$1);
					if (this._unevaluatedLayout) for (const e$1 in this._unevaluatedLayout._values) {
						const r$1 = this._unevaluatedLayout._values[e$1];
						for (const e$2 of r$1.getGlobalStateRefs()) t$1.add(e$2);
					}
					for (const e$1 of this._featureFilter.getGlobalStateRefs()) t$1.add(e$1);
					return t$1;
				}
				getPaintAffectingGlobalStateRefs() {
					var t$1;
					const e$1 = new globalThis.Map();
					if (this._transitionablePaint) for (const r$1 in this._transitionablePaint._values) {
						const n$1 = this._transitionablePaint._values[r$1].value;
						for (const i$1 of n$1.getGlobalStateRefs()) {
							const s$1 = null !== (t$1 = e$1.get(i$1)) && void 0 !== t$1 ? t$1 : [];
							s$1.push({
								name: r$1,
								value: n$1.value
							}), e$1.set(i$1, s$1);
						}
					}
					return e$1;
				}
				getVisibilityAffectingGlobalStateRefs() {
					return this._visibilityExpression.getGlobalStateRefs();
				}
				setLayoutProperty(t$1, e$1, r$1 = {}) {
					if (null == e$1 || !this._validate(ls, `layers.${this.id}.layout.${t$1}`, t$1, e$1, r$1)) return "visibility" === t$1 ? (this.visibility = e$1, this._visibilityExpression.setValue(e$1), void this.recalculateVisibility()) : void this._unevaluatedLayout.setValue(t$1, e$1);
				}
				getPaintProperty(t$1) {
					return t$1.endsWith(Vs) ? this._transitionablePaint.getTransition(t$1.slice(0, -11)) : this._transitionablePaint.getValue(t$1);
				}
				setPaintProperty(t$1, e$1, r$1 = {}) {
					if (null != e$1 && this._validate(os, `layers.${this.id}.paint.${t$1}`, t$1, e$1, r$1)) return !1;
					if (t$1.endsWith(Vs)) return this._transitionablePaint.setTransition(t$1.slice(0, -11), e$1 || void 0), !1;
					{
						const r$2 = this._transitionablePaint._values[t$1], n$1 = "cross-faded-data-driven" === r$2.property.specification["property-type"], i$1 = r$2.value.isDataDriven(), s$1 = r$2.value;
						this._transitionablePaint.setValue(t$1, e$1), this._handleSpecialPaintPropertyUpdate(t$1);
						const a = this._transitionablePaint._values[t$1].value;
						return a.isDataDriven() || i$1 || n$1 || this._handleOverridablePaintPropertyUpdate(t$1, s$1, a);
					}
				}
				_handleSpecialPaintPropertyUpdate(t$1) {}
				_handleOverridablePaintPropertyUpdate(t$1, e$1, r$1) {
					return !1;
				}
				isHidden(t$1 = this.minzoom, e$1 = !1) {
					return !!(this.minzoom && t$1 < (e$1 ? Math.floor(this.minzoom) : this.minzoom)) || !!(this.maxzoom && t$1 >= this.maxzoom) || "none" === this._evaluatedVisibility;
				}
				updateTransitions(t$1) {
					this._transitioningPaint = this._transitionablePaint.transitioned(t$1, this._transitioningPaint);
				}
				hasTransition() {
					return this._transitioningPaint.hasTransition();
				}
				recalculateVisibility() {
					this._evaluatedVisibility = this._visibilityExpression.evaluate();
				}
				recalculate(t$1, e$1) {
					t$1.getCrossfadeParameters && (this._crossfadeParameters = t$1.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t$1, void 0, e$1)), this.paint = this._transitioningPaint.possiblyEvaluate(t$1, void 0, e$1);
				}
				serialize() {
					const t$1 = {
						id: this.id,
						type: this.type,
						source: this.source,
						"source-layer": this.sourceLayer,
						metadata: this.metadata,
						minzoom: this.minzoom,
						maxzoom: this.maxzoom,
						filter: this.filter,
						layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
						paint: this._transitionablePaint && this._transitionablePaint.serialize()
					};
					return this.visibility && (t$1.layout = t$1.layout || {}, t$1.layout.visibility = this.visibility), $(t$1, ((t$2, e$1) => !(void 0 === t$2 || "layout" === e$1 && !Object.keys(t$2).length || "paint" === e$1 && !Object.keys(t$2).length)));
				}
				_validate(t$1, e$1, r$1, n$1, i$1 = {}) {
					return (!i$1 || !1 !== i$1.validate) && us(this, t$1.call(is, {
						key: e$1,
						layerType: this.type,
						objectKey: r$1,
						value: n$1,
						styleSpec: vt,
						style: {
							glyphs: !0,
							sprite: !0
						}
					}));
				}
				is3D() {
					return !1;
				}
				isTileClipped() {
					return !1;
				}
				hasOffscreenPass() {
					return !1;
				}
				resize() {}
				isStateDependent() {
					for (const t$1 in this.paint._values) {
						const e$1 = this.paint.get(t$1);
						if (e$1 instanceof Us && qn(e$1.property.specification) && ("source" === e$1.value.kind || "composite" === e$1.value.kind) && e$1.value.isStateDependent) return !0;
					}
					return !1;
				}
			}
			let Ws;
			var Js = { get paint() {
				return Ws = Ws || new Hs({
					"raster-opacity": new js(vt.paint_raster["raster-opacity"]),
					"raster-hue-rotate": new js(vt.paint_raster["raster-hue-rotate"]),
					"raster-brightness-min": new js(vt.paint_raster["raster-brightness-min"]),
					"raster-brightness-max": new js(vt.paint_raster["raster-brightness-max"]),
					"raster-saturation": new js(vt.paint_raster["raster-saturation"]),
					"raster-contrast": new js(vt.paint_raster["raster-contrast"]),
					"raster-resampling": new js(vt.paint_raster["raster-resampling"]),
					"raster-fade-duration": new js(vt.paint_raster["raster-fade-duration"])
				});
			} };
			class Qs extends Ks {
				constructor(t$1, e$1) {
					super(t$1, Js, e$1);
				}
			}
			const ta = {
				Int8: Int8Array,
				Uint8: Uint8Array,
				Int16: Int16Array,
				Uint16: Uint16Array,
				Int32: Int32Array,
				Uint32: Uint32Array,
				Float32: Float32Array
			};
			class ea {
				constructor(t$1, e$1) {
					this._structArray = t$1, this._pos1 = e$1 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
				}
			}
			class ra {
				constructor() {
					this.isTransferred = !1, this.capacity = -1, this.resize(0);
				}
				static serialize(t$1, e$1) {
					return t$1._trim(), e$1 && (t$1.isTransferred = !0, e$1.push(t$1.arrayBuffer)), {
						length: t$1.length,
						arrayBuffer: t$1.arrayBuffer
					};
				}
				static deserialize(t$1) {
					const e$1 = Object.create(this.prototype);
					return e$1.arrayBuffer = t$1.arrayBuffer, e$1.length = t$1.length, e$1.capacity = t$1.arrayBuffer.byteLength / e$1.bytesPerElement, e$1._refreshViews(), e$1;
				}
				_trim() {
					this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
				}
				clear() {
					this.length = 0;
				}
				resize(t$1) {
					this.reserve(t$1), this.length = t$1;
				}
				reserve(t$1) {
					if (t$1 > this.capacity) {
						this.capacity = Math.max(t$1, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
						const e$1 = this.uint8;
						this._refreshViews(), e$1 && this.uint8.set(e$1);
					}
				}
				_refreshViews() {
					throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
				}
			}
			function na(t$1, e$1 = 1) {
				let r$1 = 0, n$1 = 0;
				return {
					members: t$1.map(((t$2) => {
						const i$1 = ta[t$2.type].BYTES_PER_ELEMENT, s$1 = r$1 = ia(r$1, Math.max(e$1, i$1)), a = t$2.components || 1;
						return n$1 = Math.max(n$1, i$1), r$1 += i$1 * a, {
							name: t$2.name,
							type: t$2.type,
							components: a,
							offset: s$1
						};
					})),
					size: ia(r$1, Math.max(n$1, e$1)),
					alignment: e$1
				};
			}
			function ia(t$1, e$1) {
				return Math.ceil(t$1 / e$1) * e$1;
			}
			class sa extends ra {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1) {
					const r$1 = this.length;
					return this.resize(r$1 + 1), this.emplace(r$1, t$1, e$1);
				}
				emplace(t$1, e$1, r$1) {
					const n$1 = 2 * t$1;
					return this.int16[n$1 + 0] = e$1, this.int16[n$1 + 1] = r$1, t$1;
				}
			}
			sa.prototype.bytesPerElement = 4, ps("StructArrayLayout2i4", sa);
			class aa extends ra {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1) {
					const n$1 = this.length;
					return this.resize(n$1 + 1), this.emplace(n$1, t$1, e$1, r$1);
				}
				emplace(t$1, e$1, r$1, n$1) {
					const i$1 = 3 * t$1;
					return this.int16[i$1 + 0] = e$1, this.int16[i$1 + 1] = r$1, this.int16[i$1 + 2] = n$1, t$1;
				}
			}
			aa.prototype.bytesPerElement = 6, ps("StructArrayLayout3i6", aa);
			class oa extends ra {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1) {
					const i$1 = this.length;
					return this.resize(i$1 + 1), this.emplace(i$1, t$1, e$1, r$1, n$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = 4 * t$1;
					return this.int16[s$1 + 0] = e$1, this.int16[s$1 + 1] = r$1, this.int16[s$1 + 2] = n$1, this.int16[s$1 + 3] = i$1, t$1;
				}
			}
			oa.prototype.bytesPerElement = 8, ps("StructArrayLayout4i8", oa);
			class la extends ra {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1) {
					const a = this.length;
					return this.resize(a + 1), this.emplace(a, t$1, e$1, r$1, n$1, i$1, s$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a) {
					const o$1 = 6 * t$1;
					return this.int16[o$1 + 0] = e$1, this.int16[o$1 + 1] = r$1, this.int16[o$1 + 2] = n$1, this.int16[o$1 + 3] = i$1, this.int16[o$1 + 4] = s$1, this.int16[o$1 + 5] = a, t$1;
				}
			}
			la.prototype.bytesPerElement = 12, ps("StructArrayLayout2i4i12", la);
			class ua extends ra {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1) {
					const a = this.length;
					return this.resize(a + 1), this.emplace(a, t$1, e$1, r$1, n$1, i$1, s$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a) {
					const o$1 = 4 * t$1, l$1 = 8 * t$1;
					return this.int16[o$1 + 0] = e$1, this.int16[o$1 + 1] = r$1, this.uint8[l$1 + 4] = n$1, this.uint8[l$1 + 5] = i$1, this.uint8[l$1 + 6] = s$1, this.uint8[l$1 + 7] = a, t$1;
				}
			}
			ua.prototype.bytesPerElement = 8, ps("StructArrayLayout2i4ub8", ua);
			class ca extends ra {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1) {
					const r$1 = this.length;
					return this.resize(r$1 + 1), this.emplace(r$1, t$1, e$1);
				}
				emplace(t$1, e$1, r$1) {
					const n$1 = 2 * t$1;
					return this.float32[n$1 + 0] = e$1, this.float32[n$1 + 1] = r$1, t$1;
				}
			}
			ca.prototype.bytesPerElement = 8, ps("StructArrayLayout2f8", ca);
			class ha extends ra {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1) {
					const c$1 = this.length;
					return this.resize(c$1 + 1), this.emplace(c$1, t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1) {
					const h$1 = 10 * t$1;
					return this.uint16[h$1 + 0] = e$1, this.uint16[h$1 + 1] = r$1, this.uint16[h$1 + 2] = n$1, this.uint16[h$1 + 3] = i$1, this.uint16[h$1 + 4] = s$1, this.uint16[h$1 + 5] = a, this.uint16[h$1 + 6] = o$1, this.uint16[h$1 + 7] = l$1, this.uint16[h$1 + 8] = u$1, this.uint16[h$1 + 9] = c$1, t$1;
				}
			}
			ha.prototype.bytesPerElement = 20, ps("StructArrayLayout10ui20", ha);
			class pa extends ra {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1) {
					const l$1 = this.length;
					return this.resize(l$1 + 1), this.emplace(l$1, t$1, e$1, r$1, n$1, i$1, s$1, a, o$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1) {
					const u$1 = 8 * t$1;
					return this.uint16[u$1 + 0] = e$1, this.uint16[u$1 + 1] = r$1, this.uint16[u$1 + 2] = n$1, this.uint16[u$1 + 3] = i$1, this.uint16[u$1 + 4] = s$1, this.uint16[u$1 + 5] = a, this.uint16[u$1 + 6] = o$1, this.uint16[u$1 + 7] = l$1, t$1;
				}
			}
			pa.prototype.bytesPerElement = 16, ps("StructArrayLayout8ui16", pa);
			class fa extends ra {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1) {
					const p$1 = this.length;
					return this.resize(p$1 + 1), this.emplace(p$1, t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1) {
					const f$1 = 12 * t$1;
					return this.int16[f$1 + 0] = e$1, this.int16[f$1 + 1] = r$1, this.int16[f$1 + 2] = n$1, this.int16[f$1 + 3] = i$1, this.uint16[f$1 + 4] = s$1, this.uint16[f$1 + 5] = a, this.uint16[f$1 + 6] = o$1, this.uint16[f$1 + 7] = l$1, this.int16[f$1 + 8] = u$1, this.int16[f$1 + 9] = c$1, this.int16[f$1 + 10] = h$1, this.int16[f$1 + 11] = p$1, t$1;
				}
			}
			fa.prototype.bytesPerElement = 24, ps("StructArrayLayout4i4ui4i24", fa);
			class da extends ra {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1) {
					const n$1 = this.length;
					return this.resize(n$1 + 1), this.emplace(n$1, t$1, e$1, r$1);
				}
				emplace(t$1, e$1, r$1, n$1) {
					const i$1 = 3 * t$1;
					return this.float32[i$1 + 0] = e$1, this.float32[i$1 + 1] = r$1, this.float32[i$1 + 2] = n$1, t$1;
				}
			}
			da.prototype.bytesPerElement = 12, ps("StructArrayLayout3f12", da);
			class ya extends ra {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
				}
				emplaceBack(t$1) {
					const e$1 = this.length;
					return this.resize(e$1 + 1), this.emplace(e$1, t$1);
				}
				emplace(t$1, e$1) {
					return this.uint32[1 * t$1 + 0] = e$1, t$1;
				}
			}
			ya.prototype.bytesPerElement = 4, ps("StructArrayLayout1ul4", ya);
			class ma extends ra {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1) {
					const u$1 = this.length;
					return this.resize(u$1 + 1), this.emplace(u$1, t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1) {
					const c$1 = 10 * t$1, h$1 = 5 * t$1;
					return this.int16[c$1 + 0] = e$1, this.int16[c$1 + 1] = r$1, this.int16[c$1 + 2] = n$1, this.int16[c$1 + 3] = i$1, this.int16[c$1 + 4] = s$1, this.int16[c$1 + 5] = a, this.uint32[h$1 + 3] = o$1, this.uint16[c$1 + 8] = l$1, this.uint16[c$1 + 9] = u$1, t$1;
				}
			}
			ma.prototype.bytesPerElement = 20, ps("StructArrayLayout6i1ul2ui20", ma);
			class ga extends ra {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1) {
					const a = this.length;
					return this.resize(a + 1), this.emplace(a, t$1, e$1, r$1, n$1, i$1, s$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a) {
					const o$1 = 6 * t$1;
					return this.int16[o$1 + 0] = e$1, this.int16[o$1 + 1] = r$1, this.int16[o$1 + 2] = n$1, this.int16[o$1 + 3] = i$1, this.int16[o$1 + 4] = s$1, this.int16[o$1 + 5] = a, t$1;
				}
			}
			ga.prototype.bytesPerElement = 12, ps("StructArrayLayout2i2i2i12", ga);
			class xa extends ra {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = this.length;
					return this.resize(s$1 + 1), this.emplace(s$1, t$1, e$1, r$1, n$1, i$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1) {
					const a = 4 * t$1, o$1 = 8 * t$1;
					return this.float32[a + 0] = e$1, this.float32[a + 1] = r$1, this.float32[a + 2] = n$1, this.int16[o$1 + 6] = i$1, this.int16[o$1 + 7] = s$1, t$1;
				}
			}
			xa.prototype.bytesPerElement = 16, ps("StructArrayLayout2f1f2i16", xa);
			class va extends ra {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1) {
					const a = this.length;
					return this.resize(a + 1), this.emplace(a, t$1, e$1, r$1, n$1, i$1, s$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a) {
					const o$1 = 16 * t$1, l$1 = 4 * t$1, u$1 = 8 * t$1;
					return this.uint8[o$1 + 0] = e$1, this.uint8[o$1 + 1] = r$1, this.float32[l$1 + 1] = n$1, this.float32[l$1 + 2] = i$1, this.int16[u$1 + 6] = s$1, this.int16[u$1 + 7] = a, t$1;
				}
			}
			va.prototype.bytesPerElement = 16, ps("StructArrayLayout2ub2f2i16", va);
			class ba extends ra {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1) {
					const n$1 = this.length;
					return this.resize(n$1 + 1), this.emplace(n$1, t$1, e$1, r$1);
				}
				emplace(t$1, e$1, r$1, n$1) {
					const i$1 = 3 * t$1;
					return this.uint16[i$1 + 0] = e$1, this.uint16[i$1 + 1] = r$1, this.uint16[i$1 + 2] = n$1, t$1;
				}
			}
			ba.prototype.bytesPerElement = 6, ps("StructArrayLayout3ui6", ba);
			class wa extends ra {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1, m$1) {
					const g$1 = this.length;
					return this.resize(g$1 + 1), this.emplace(g$1, t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1, m$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1, m$1, g$1) {
					const x$1 = 24 * t$1, v$1 = 12 * t$1, b$1 = 48 * t$1;
					return this.int16[x$1 + 0] = e$1, this.int16[x$1 + 1] = r$1, this.uint16[x$1 + 2] = n$1, this.uint16[x$1 + 3] = i$1, this.uint32[v$1 + 2] = s$1, this.uint32[v$1 + 3] = a, this.uint32[v$1 + 4] = o$1, this.uint16[x$1 + 10] = l$1, this.uint16[x$1 + 11] = u$1, this.uint16[x$1 + 12] = c$1, this.float32[v$1 + 7] = h$1, this.float32[v$1 + 8] = p$1, this.uint8[b$1 + 36] = f$1, this.uint8[b$1 + 37] = d$1, this.uint8[b$1 + 38] = y$1, this.uint32[v$1 + 10] = m$1, this.int16[x$1 + 22] = g$1, t$1;
				}
			}
			wa.prototype.bytesPerElement = 48, ps("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", wa);
			class _a extends ra {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1, m$1, g$1, x$1, v$1, b$1, w$1, _$1, S$1, A$1, k$1, E$1, T$1) {
					const I$1 = this.length;
					return this.resize(I$1 + 1), this.emplace(I$1, t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1, m$1, g$1, x$1, v$1, b$1, w$1, _$1, S$1, A$1, k$1, E$1, T$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1, m$1, g$1, x$1, v$1, b$1, w$1, _$1, S$1, A$1, k$1, E$1, T$1, I$1) {
					const M$1 = 32 * t$1, F$1 = 16 * t$1;
					return this.int16[M$1 + 0] = e$1, this.int16[M$1 + 1] = r$1, this.int16[M$1 + 2] = n$1, this.int16[M$1 + 3] = i$1, this.int16[M$1 + 4] = s$1, this.int16[M$1 + 5] = a, this.int16[M$1 + 6] = o$1, this.int16[M$1 + 7] = l$1, this.uint16[M$1 + 8] = u$1, this.uint16[M$1 + 9] = c$1, this.uint16[M$1 + 10] = h$1, this.uint16[M$1 + 11] = p$1, this.uint16[M$1 + 12] = f$1, this.uint16[M$1 + 13] = d$1, this.uint16[M$1 + 14] = y$1, this.uint16[M$1 + 15] = m$1, this.uint16[M$1 + 16] = g$1, this.uint16[M$1 + 17] = x$1, this.uint16[M$1 + 18] = v$1, this.uint16[M$1 + 19] = b$1, this.uint16[M$1 + 20] = w$1, this.uint16[M$1 + 21] = _$1, this.uint16[M$1 + 22] = S$1, this.uint32[F$1 + 12] = A$1, this.float32[F$1 + 13] = k$1, this.float32[F$1 + 14] = E$1, this.uint16[M$1 + 30] = T$1, this.uint16[M$1 + 31] = I$1, t$1;
				}
			}
			_a.prototype.bytesPerElement = 64, ps("StructArrayLayout8i15ui1ul2f2ui64", _a);
			class Sa extends ra {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1) {
					const e$1 = this.length;
					return this.resize(e$1 + 1), this.emplace(e$1, t$1);
				}
				emplace(t$1, e$1) {
					return this.float32[1 * t$1 + 0] = e$1, t$1;
				}
			}
			Sa.prototype.bytesPerElement = 4, ps("StructArrayLayout1f4", Sa);
			class Aa extends ra {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1) {
					const n$1 = this.length;
					return this.resize(n$1 + 1), this.emplace(n$1, t$1, e$1, r$1);
				}
				emplace(t$1, e$1, r$1, n$1) {
					const i$1 = 3 * t$1;
					return this.uint16[6 * t$1 + 0] = e$1, this.float32[i$1 + 1] = r$1, this.float32[i$1 + 2] = n$1, t$1;
				}
			}
			Aa.prototype.bytesPerElement = 12, ps("StructArrayLayout1ui2f12", Aa);
			class ka extends ra {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1) {
					const n$1 = this.length;
					return this.resize(n$1 + 1), this.emplace(n$1, t$1, e$1, r$1);
				}
				emplace(t$1, e$1, r$1, n$1) {
					const i$1 = 4 * t$1;
					return this.uint32[2 * t$1 + 0] = e$1, this.uint16[i$1 + 2] = r$1, this.uint16[i$1 + 3] = n$1, t$1;
				}
			}
			ka.prototype.bytesPerElement = 8, ps("StructArrayLayout1ul2ui8", ka);
			class Ea extends ra {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1) {
					const r$1 = this.length;
					return this.resize(r$1 + 1), this.emplace(r$1, t$1, e$1);
				}
				emplace(t$1, e$1, r$1) {
					const n$1 = 2 * t$1;
					return this.uint16[n$1 + 0] = e$1, this.uint16[n$1 + 1] = r$1, t$1;
				}
			}
			Ea.prototype.bytesPerElement = 4, ps("StructArrayLayout2ui4", Ea);
			class Ta extends ra {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1) {
					const e$1 = this.length;
					return this.resize(e$1 + 1), this.emplace(e$1, t$1);
				}
				emplace(t$1, e$1) {
					return this.uint16[1 * t$1 + 0] = e$1, t$1;
				}
			}
			Ta.prototype.bytesPerElement = 2, ps("StructArrayLayout1ui2", Ta);
			class Ia extends ra {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1) {
					const i$1 = this.length;
					return this.resize(i$1 + 1), this.emplace(i$1, t$1, e$1, r$1, n$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = 4 * t$1;
					return this.float32[s$1 + 0] = e$1, this.float32[s$1 + 1] = r$1, this.float32[s$1 + 2] = n$1, this.float32[s$1 + 3] = i$1, t$1;
				}
			}
			Ia.prototype.bytesPerElement = 16, ps("StructArrayLayout4f16", Ia);
			class Ma extends ea {
				get anchorPointX() {
					return this._structArray.int16[this._pos2 + 0];
				}
				get anchorPointY() {
					return this._structArray.int16[this._pos2 + 1];
				}
				get x1() {
					return this._structArray.int16[this._pos2 + 2];
				}
				get y1() {
					return this._structArray.int16[this._pos2 + 3];
				}
				get x2() {
					return this._structArray.int16[this._pos2 + 4];
				}
				get y2() {
					return this._structArray.int16[this._pos2 + 5];
				}
				get featureIndex() {
					return this._structArray.uint32[this._pos4 + 3];
				}
				get sourceLayerIndex() {
					return this._structArray.uint16[this._pos2 + 8];
				}
				get bucketIndex() {
					return this._structArray.uint16[this._pos2 + 9];
				}
				get anchorPoint() {
					return new r(this.anchorPointX, this.anchorPointY);
				}
			}
			Ma.prototype.size = 20;
			class Fa extends ma {
				get(t$1) {
					return new Ma(this, t$1);
				}
			}
			ps("CollisionBoxArray", Fa);
			class Da extends ea {
				get anchorX() {
					return this._structArray.int16[this._pos2 + 0];
				}
				get anchorY() {
					return this._structArray.int16[this._pos2 + 1];
				}
				get glyphStartIndex() {
					return this._structArray.uint16[this._pos2 + 2];
				}
				get numGlyphs() {
					return this._structArray.uint16[this._pos2 + 3];
				}
				get vertexStartIndex() {
					return this._structArray.uint32[this._pos4 + 2];
				}
				get lineStartIndex() {
					return this._structArray.uint32[this._pos4 + 3];
				}
				get lineLength() {
					return this._structArray.uint32[this._pos4 + 4];
				}
				get segment() {
					return this._structArray.uint16[this._pos2 + 10];
				}
				get lowerSize() {
					return this._structArray.uint16[this._pos2 + 11];
				}
				get upperSize() {
					return this._structArray.uint16[this._pos2 + 12];
				}
				get lineOffsetX() {
					return this._structArray.float32[this._pos4 + 7];
				}
				get lineOffsetY() {
					return this._structArray.float32[this._pos4 + 8];
				}
				get writingMode() {
					return this._structArray.uint8[this._pos1 + 36];
				}
				get placedOrientation() {
					return this._structArray.uint8[this._pos1 + 37];
				}
				set placedOrientation(t$1) {
					this._structArray.uint8[this._pos1 + 37] = t$1;
				}
				get hidden() {
					return this._structArray.uint8[this._pos1 + 38];
				}
				set hidden(t$1) {
					this._structArray.uint8[this._pos1 + 38] = t$1;
				}
				get crossTileID() {
					return this._structArray.uint32[this._pos4 + 10];
				}
				set crossTileID(t$1) {
					this._structArray.uint32[this._pos4 + 10] = t$1;
				}
				get associatedIconIndex() {
					return this._structArray.int16[this._pos2 + 22];
				}
			}
			Da.prototype.size = 48;
			class za extends wa {
				get(t$1) {
					return new Da(this, t$1);
				}
			}
			ps("PlacedSymbolArray", za);
			class Pa extends ea {
				get anchorX() {
					return this._structArray.int16[this._pos2 + 0];
				}
				get anchorY() {
					return this._structArray.int16[this._pos2 + 1];
				}
				get rightJustifiedTextSymbolIndex() {
					return this._structArray.int16[this._pos2 + 2];
				}
				get centerJustifiedTextSymbolIndex() {
					return this._structArray.int16[this._pos2 + 3];
				}
				get leftJustifiedTextSymbolIndex() {
					return this._structArray.int16[this._pos2 + 4];
				}
				get verticalPlacedTextSymbolIndex() {
					return this._structArray.int16[this._pos2 + 5];
				}
				get placedIconSymbolIndex() {
					return this._structArray.int16[this._pos2 + 6];
				}
				get verticalPlacedIconSymbolIndex() {
					return this._structArray.int16[this._pos2 + 7];
				}
				get key() {
					return this._structArray.uint16[this._pos2 + 8];
				}
				get textBoxStartIndex() {
					return this._structArray.uint16[this._pos2 + 9];
				}
				get textBoxEndIndex() {
					return this._structArray.uint16[this._pos2 + 10];
				}
				get verticalTextBoxStartIndex() {
					return this._structArray.uint16[this._pos2 + 11];
				}
				get verticalTextBoxEndIndex() {
					return this._structArray.uint16[this._pos2 + 12];
				}
				get iconBoxStartIndex() {
					return this._structArray.uint16[this._pos2 + 13];
				}
				get iconBoxEndIndex() {
					return this._structArray.uint16[this._pos2 + 14];
				}
				get verticalIconBoxStartIndex() {
					return this._structArray.uint16[this._pos2 + 15];
				}
				get verticalIconBoxEndIndex() {
					return this._structArray.uint16[this._pos2 + 16];
				}
				get featureIndex() {
					return this._structArray.uint16[this._pos2 + 17];
				}
				get numHorizontalGlyphVertices() {
					return this._structArray.uint16[this._pos2 + 18];
				}
				get numVerticalGlyphVertices() {
					return this._structArray.uint16[this._pos2 + 19];
				}
				get numIconVertices() {
					return this._structArray.uint16[this._pos2 + 20];
				}
				get numVerticalIconVertices() {
					return this._structArray.uint16[this._pos2 + 21];
				}
				get useRuntimeCollisionCircles() {
					return this._structArray.uint16[this._pos2 + 22];
				}
				get crossTileID() {
					return this._structArray.uint32[this._pos4 + 12];
				}
				set crossTileID(t$1) {
					this._structArray.uint32[this._pos4 + 12] = t$1;
				}
				get textBoxScale() {
					return this._structArray.float32[this._pos4 + 13];
				}
				get collisionCircleDiameter() {
					return this._structArray.float32[this._pos4 + 14];
				}
				get textAnchorOffsetStartIndex() {
					return this._structArray.uint16[this._pos2 + 30];
				}
				get textAnchorOffsetEndIndex() {
					return this._structArray.uint16[this._pos2 + 31];
				}
			}
			Pa.prototype.size = 64;
			class Ba extends _a {
				get(t$1) {
					return new Pa(this, t$1);
				}
			}
			ps("SymbolInstanceArray", Ba);
			class Va extends Sa {
				getoffsetX(t$1) {
					return this.float32[1 * t$1 + 0];
				}
			}
			ps("GlyphOffsetArray", Va);
			class Ca extends aa {
				getx(t$1) {
					return this.int16[3 * t$1 + 0];
				}
				gety(t$1) {
					return this.int16[3 * t$1 + 1];
				}
				gettileUnitDistanceFromAnchor(t$1) {
					return this.int16[3 * t$1 + 2];
				}
			}
			ps("SymbolLineVertexArray", Ca);
			class La extends ea {
				get textAnchor() {
					return this._structArray.uint16[this._pos2 + 0];
				}
				get textOffset0() {
					return this._structArray.float32[this._pos4 + 1];
				}
				get textOffset1() {
					return this._structArray.float32[this._pos4 + 2];
				}
			}
			La.prototype.size = 12;
			class Oa extends Aa {
				get(t$1) {
					return new La(this, t$1);
				}
			}
			ps("TextAnchorOffsetArray", Oa);
			class Ra extends ea {
				get featureIndex() {
					return this._structArray.uint32[this._pos4 + 0];
				}
				get sourceLayerIndex() {
					return this._structArray.uint16[this._pos2 + 2];
				}
				get bucketIndex() {
					return this._structArray.uint16[this._pos2 + 3];
				}
			}
			Ra.prototype.size = 8;
			class Na extends ka {
				get(t$1) {
					return new Ra(this, t$1);
				}
			}
			ps("FeatureIndexArray", Na);
			class $a extends sa {}
			class Ua extends sa {}
			class qa extends sa {}
			class ja extends la {}
			class Ga extends ua {}
			class Xa extends ca {}
			class Ya extends ha {}
			class Za extends pa {}
			class Ha extends fa {}
			class Ka extends da {}
			class Wa extends ya {}
			class Ja extends ga {}
			class Qa extends va {}
			class to extends ba {}
			class eo extends Ea {}
			const { members: no } = na([{
				name: "a_pos",
				components: 2,
				type: "Int16"
			}], 4);
			class io {
				constructor(t$1 = []) {
					this._forceNewSegmentOnNextPrepare = !1, this.segments = t$1;
				}
				prepareSegment(t$1, e$1, r$1, n$1) {
					const i$1 = this.segments[this.segments.length - 1];
					return t$1 > io.MAX_VERTEX_ARRAY_LENGTH && j(`Max vertices per segment is ${io.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t$1}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${io.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !i$1 || i$1.vertexLength + t$1 > io.MAX_VERTEX_ARRAY_LENGTH || i$1.sortKey !== n$1 ? this.createNewSegment(e$1, r$1, n$1) : i$1;
				}
				createNewSegment(t$1, e$1, r$1) {
					const n$1 = {
						vertexOffset: t$1.length,
						primitiveOffset: e$1.length,
						vertexLength: 0,
						primitiveLength: 0,
						vaos: {}
					};
					return void 0 !== r$1 && (n$1.sortKey = r$1), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(n$1), n$1;
				}
				getOrCreateLatestSegment(t$1, e$1, r$1) {
					return this.prepareSegment(0, t$1, e$1, r$1);
				}
				forceNewSegmentOnNextPrepare() {
					this._forceNewSegmentOnNextPrepare = !0;
				}
				get() {
					return this.segments;
				}
				destroy() {
					for (const t$1 of this.segments) for (const e$1 in t$1.vaos) t$1.vaos[e$1].destroy();
				}
				static simpleSegment(t$1, e$1, r$1, n$1) {
					return new io([{
						vertexOffset: t$1,
						primitiveOffset: e$1,
						vertexLength: r$1,
						primitiveLength: n$1,
						vaos: {},
						sortKey: 0
					}]);
				}
			}
			function so(t$1, e$1) {
				return 256 * (t$1 = C(Math.floor(t$1), 0, 255)) + C(Math.floor(e$1), 0, 255);
			}
			io.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, ps("SegmentVector", io);
			const ao = na([
				{
					name: "a_pattern_from",
					components: 4,
					type: "Uint16"
				},
				{
					name: "a_pattern_to",
					components: 4,
					type: "Uint16"
				},
				{
					name: "a_pixel_ratio_from",
					components: 1,
					type: "Uint16"
				},
				{
					name: "a_pixel_ratio_to",
					components: 1,
					type: "Uint16"
				}
			]), oo = na([{
				name: "a_dasharray_from",
				components: 4,
				type: "Uint16"
			}, {
				name: "a_dasharray_to",
				components: 4,
				type: "Uint16"
			}]);
			var lo, uo, co, ho = { exports: {} }, po = { exports: {} }, fo = { exports: {} }, mo = n(function() {
				if (co) return ho.exports;
				co = 1;
				var t$1 = (lo || (lo = 1, po.exports = function(t$2, e$2) {
					var r$1, n$1, i$1, s$1, a, o$1, l$1, u$1;
					for (n$1 = t$2.length - (r$1 = 3 & t$2.length), i$1 = e$2, a = 3432918353, o$1 = 461845907, u$1 = 0; u$1 < n$1;) l$1 = 255 & t$2.charCodeAt(u$1) | (255 & t$2.charCodeAt(++u$1)) << 8 | (255 & t$2.charCodeAt(++u$1)) << 16 | (255 & t$2.charCodeAt(++u$1)) << 24, ++u$1, i$1 = 27492 + (65535 & (s$1 = 5 * (65535 & (i$1 = (i$1 ^= l$1 = (65535 & (l$1 = (l$1 = (65535 & l$1) * a + (((l$1 >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l$1 >>> 17)) * o$1 + (((l$1 >>> 16) * o$1 & 65535) << 16) & 4294967295) << 13 | i$1 >>> 19)) + ((5 * (i$1 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s$1 >>> 16) & 65535) << 16);
					switch (l$1 = 0, r$1) {
						case 3: l$1 ^= (255 & t$2.charCodeAt(u$1 + 2)) << 16;
						case 2: l$1 ^= (255 & t$2.charCodeAt(u$1 + 1)) << 8;
						case 1: i$1 ^= l$1 = (65535 & (l$1 = (l$1 = (65535 & (l$1 ^= 255 & t$2.charCodeAt(u$1))) * a + (((l$1 >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l$1 >>> 17)) * o$1 + (((l$1 >>> 16) * o$1 & 65535) << 16) & 4294967295;
					}
					return i$1 ^= t$2.length, i$1 = 2246822507 * (65535 & (i$1 ^= i$1 >>> 16)) + ((2246822507 * (i$1 >>> 16) & 65535) << 16) & 4294967295, i$1 = 3266489909 * (65535 & (i$1 ^= i$1 >>> 13)) + ((3266489909 * (i$1 >>> 16) & 65535) << 16) & 4294967295, (i$1 ^= i$1 >>> 16) >>> 0;
				}), po.exports), e$1 = (uo || (uo = 1, fo.exports = function(t$2, e$2) {
					for (var r$1, n$1 = t$2.length, i$1 = e$2 ^ n$1, s$1 = 0; n$1 >= 4;) r$1 = 1540483477 * (65535 & (r$1 = 255 & t$2.charCodeAt(s$1) | (255 & t$2.charCodeAt(++s$1)) << 8 | (255 & t$2.charCodeAt(++s$1)) << 16 | (255 & t$2.charCodeAt(++s$1)) << 24)) + ((1540483477 * (r$1 >>> 16) & 65535) << 16), i$1 = 1540483477 * (65535 & i$1) + ((1540483477 * (i$1 >>> 16) & 65535) << 16) ^ (r$1 = 1540483477 * (65535 & (r$1 ^= r$1 >>> 24)) + ((1540483477 * (r$1 >>> 16) & 65535) << 16)), n$1 -= 4, ++s$1;
					switch (n$1) {
						case 3: i$1 ^= (255 & t$2.charCodeAt(s$1 + 2)) << 16;
						case 2: i$1 ^= (255 & t$2.charCodeAt(s$1 + 1)) << 8;
						case 1: i$1 = 1540483477 * (65535 & (i$1 ^= 255 & t$2.charCodeAt(s$1))) + ((1540483477 * (i$1 >>> 16) & 65535) << 16);
					}
					return i$1 = 1540483477 * (65535 & (i$1 ^= i$1 >>> 13)) + ((1540483477 * (i$1 >>> 16) & 65535) << 16), (i$1 ^= i$1 >>> 15) >>> 0;
				}), fo.exports);
				return ho.exports = t$1, ho.exports.murmur3 = t$1, ho.exports.murmur2 = e$1, ho.exports;
			}());
			class go {
				constructor() {
					this.ids = [], this.positions = [], this.indexed = !1;
				}
				add(t$1, e$1, r$1, n$1) {
					this.ids.push(xo(t$1)), this.positions.push(e$1, r$1, n$1);
				}
				getPositions(t$1) {
					if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
					const e$1 = xo(t$1);
					let r$1 = 0, n$1 = this.ids.length - 1;
					for (; r$1 < n$1;) {
						const t$2 = r$1 + n$1 >> 1;
						this.ids[t$2] >= e$1 ? n$1 = t$2 : r$1 = t$2 + 1;
					}
					const i$1 = [];
					for (; this.ids[r$1] === e$1;) i$1.push({
						index: this.positions[3 * r$1],
						start: this.positions[3 * r$1 + 1],
						end: this.positions[3 * r$1 + 2]
					}), r$1++;
					return i$1;
				}
				static serialize(t$1, e$1) {
					const r$1 = new Float64Array(t$1.ids), n$1 = new Uint32Array(t$1.positions);
					return vo(r$1, n$1, 0, r$1.length - 1), e$1 && e$1.push(r$1.buffer, n$1.buffer), {
						ids: r$1,
						positions: n$1
					};
				}
				static deserialize(t$1) {
					const e$1 = new go();
					return e$1.ids = t$1.ids, e$1.positions = t$1.positions, e$1.indexed = !0, e$1;
				}
			}
			function xo(t$1) {
				const e$1 = +t$1;
				return !isNaN(e$1) && e$1 <= Number.MAX_SAFE_INTEGER ? e$1 : mo(String(t$1));
			}
			function vo(t$1, e$1, r$1, n$1) {
				for (; r$1 < n$1;) {
					const i$1 = t$1[r$1 + n$1 >> 1];
					let s$1 = r$1 - 1, a = n$1 + 1;
					for (;;) {
						do
							s$1++;
						while (t$1[s$1] < i$1);
						do
							a--;
						while (t$1[a] > i$1);
						if (s$1 >= a) break;
						bo(t$1, s$1, a), bo(e$1, 3 * s$1, 3 * a), bo(e$1, 3 * s$1 + 1, 3 * a + 1), bo(e$1, 3 * s$1 + 2, 3 * a + 2);
					}
					a - r$1 < n$1 - a ? (vo(t$1, e$1, r$1, a), r$1 = a + 1) : (vo(t$1, e$1, a + 1, n$1), n$1 = a);
				}
			}
			function bo(t$1, e$1, r$1) {
				const n$1 = t$1[e$1];
				t$1[e$1] = t$1[r$1], t$1[r$1] = n$1;
			}
			ps("FeaturePositionMap", go);
			class wo {
				constructor(t$1, e$1) {
					this.gl = t$1.gl, this.location = e$1;
				}
			}
			class _o extends wo {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = 0;
				}
				set(t$1) {
					this.current !== t$1 && (this.current = t$1, this.gl.uniform1f(this.location, t$1));
				}
			}
			class So extends wo {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = [
						0,
						0,
						0,
						0
					];
				}
				set(t$1) {
					t$1[0] === this.current[0] && t$1[1] === this.current[1] && t$1[2] === this.current[2] && t$1[3] === this.current[3] || (this.current = t$1, this.gl.uniform4f(this.location, t$1[0], t$1[1], t$1[2], t$1[3]));
				}
			}
			class Ao extends wo {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = Te.transparent;
				}
				set(t$1) {
					t$1.r === this.current.r && t$1.g === this.current.g && t$1.b === this.current.b && t$1.a === this.current.a || (this.current = t$1, this.gl.uniform4f(this.location, t$1.r, t$1.g, t$1.b, t$1.a));
				}
			}
			const ko = new Float32Array(16);
			function Eo(t$1) {
				return [so(255 * t$1.r, 255 * t$1.g), so(255 * t$1.b, 255 * t$1.a)];
			}
			class To {
				constructor(t$1, e$1, r$1) {
					this.value = t$1, this.uniformNames = e$1.map(((t$2) => `u_${t$2}`)), this.type = r$1;
				}
				setUniform(t$1, e$1, r$1) {
					t$1.set(r$1.constantOr(this.value));
				}
				getBinding(t$1, e$1, r$1) {
					return "color" === this.type ? new Ao(t$1, e$1) : new _o(t$1, e$1);
				}
			}
			class Io {
				constructor(t$1, e$1) {
					this.uniformNames = e$1.map(((t$2) => `u_${t$2}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
				}
				setConstantPatternPositions(t$1, e$1) {
					this.pixelRatioFrom = e$1.pixelRatio, this.pixelRatioTo = t$1.pixelRatio, this.patternFrom = e$1.tlbr, this.patternTo = t$1.tlbr;
				}
				setConstantDashPositions(t$1, e$1) {
					this.dashTo = [
						0,
						t$1.y,
						t$1.height,
						t$1.width
					], this.dashFrom = [
						0,
						e$1.y,
						e$1.height,
						e$1.width
					];
				}
				setUniform(t$1, e$1, r$1, n$1) {
					let i$1 = null;
					"u_pattern_to" === n$1 ? i$1 = this.patternTo : "u_pattern_from" === n$1 ? i$1 = this.patternFrom : "u_dasharray_to" === n$1 ? i$1 = this.dashTo : "u_dasharray_from" === n$1 ? i$1 = this.dashFrom : "u_pixel_ratio_to" === n$1 ? i$1 = this.pixelRatioTo : "u_pixel_ratio_from" === n$1 && (i$1 = this.pixelRatioFrom), null !== i$1 && t$1.set(i$1);
				}
				getBinding(t$1, e$1, r$1) {
					return "u_pattern" === r$1.substr(0, 9) || "u_dasharray_" === r$1.substr(0, 12) ? new So(t$1, e$1) : new _o(t$1, e$1);
				}
			}
			class Mo {
				constructor(t$1, e$1, r$1, n$1) {
					this.expression = t$1, this.type = r$1, this.maxValue = 0, this.paintVertexAttributes = e$1.map(((t$2) => ({
						name: `a_${t$2}`,
						type: "Float32",
						components: "color" === r$1 ? 2 : 1,
						offset: 0
					}))), this.paintVertexArray = new n$1();
				}
				populatePaintArray(t$1, e$1, r$1) {
					const n$1 = this.paintVertexArray.length, i$1 = this.expression.evaluate(new Ps(0, r$1), e$1, {}, r$1.canonical, [], r$1.formattedSection);
					this.paintVertexArray.resize(t$1), this._setPaintValue(n$1, t$1, i$1);
				}
				updatePaintArray(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = this.expression.evaluate(new Ps(0, i$1), r$1, n$1);
					this._setPaintValue(t$1, e$1, s$1);
				}
				_setPaintValue(t$1, e$1, r$1) {
					if ("color" === this.type) {
						const n$1 = Eo(r$1);
						for (let r$2 = t$1; r$2 < e$1; r$2++) this.paintVertexArray.emplace(r$2, n$1[0], n$1[1]);
					} else {
						for (let n$1 = t$1; n$1 < e$1; n$1++) this.paintVertexArray.emplace(n$1, r$1);
						this.maxValue = Math.max(this.maxValue, Math.abs(r$1));
					}
				}
				upload(t$1) {
					this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t$1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
				}
				destroy() {
					this.paintVertexBuffer && this.paintVertexBuffer.destroy();
				}
			}
			class Fo {
				constructor(t$1, e$1, r$1, n$1, i$1, s$1) {
					this.expression = t$1, this.uniformNames = e$1.map(((t$2) => `u_${t$2}_t`)), this.type = r$1, this.useIntegerZoom = n$1, this.zoom = i$1, this.maxValue = 0, this.paintVertexAttributes = e$1.map(((t$2) => ({
						name: `a_${t$2}`,
						type: "Float32",
						components: "color" === r$1 ? 4 : 2,
						offset: 0
					}))), this.paintVertexArray = new s$1();
				}
				populatePaintArray(t$1, e$1, r$1) {
					const n$1 = this.expression.evaluate(new Ps(this.zoom, r$1), e$1, {}, r$1.canonical, [], r$1.formattedSection), i$1 = this.expression.evaluate(new Ps(this.zoom + 1, r$1), e$1, {}, r$1.canonical, [], r$1.formattedSection), s$1 = this.paintVertexArray.length;
					this.paintVertexArray.resize(t$1), this._setPaintValue(s$1, t$1, n$1, i$1);
				}
				updatePaintArray(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = this.expression.evaluate(new Ps(this.zoom, i$1), r$1, n$1), a = this.expression.evaluate(new Ps(this.zoom + 1, i$1), r$1, n$1);
					this._setPaintValue(t$1, e$1, s$1, a);
				}
				_setPaintValue(t$1, e$1, r$1, n$1) {
					if ("color" === this.type) {
						const i$1 = Eo(r$1), s$1 = Eo(n$1);
						for (let r$2 = t$1; r$2 < e$1; r$2++) this.paintVertexArray.emplace(r$2, i$1[0], i$1[1], s$1[0], s$1[1]);
					} else {
						for (let i$1 = t$1; i$1 < e$1; i$1++) this.paintVertexArray.emplace(i$1, r$1, n$1);
						this.maxValue = Math.max(this.maxValue, Math.abs(r$1), Math.abs(n$1));
					}
				}
				upload(t$1) {
					this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t$1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
				}
				destroy() {
					this.paintVertexBuffer && this.paintVertexBuffer.destroy();
				}
				setUniform(t$1, e$1) {
					const r$1 = this.useIntegerZoom ? Math.floor(e$1.zoom) : e$1.zoom, n$1 = C(this.expression.interpolationFactor(r$1, this.zoom, this.zoom + 1), 0, 1);
					t$1.set(n$1);
				}
				getBinding(t$1, e$1, r$1) {
					return new _o(t$1, e$1);
				}
			}
			class Do {
				constructor(t$1, e$1, r$1, n$1, i$1, s$1) {
					this.expression = t$1, this.type = e$1, this.useIntegerZoom = r$1, this.zoom = n$1, this.layerId = s$1, this.zoomInPaintVertexArray = new i$1(), this.zoomOutPaintVertexArray = new i$1();
				}
				populatePaintArray(t$1, e$1, r$1) {
					const n$1 = this.zoomInPaintVertexArray.length;
					this.zoomInPaintVertexArray.resize(t$1), this.zoomOutPaintVertexArray.resize(t$1), this._setPaintValues(n$1, t$1, this.getPositionIds(e$1), r$1);
				}
				updatePaintArray(t$1, e$1, r$1, n$1, i$1) {
					this._setPaintValues(t$1, e$1, this.getPositionIds(r$1), i$1);
				}
				_setPaintValues(t$1, e$1, r$1, n$1) {
					const i$1 = this.getPositions(n$1);
					if (!i$1 || !r$1) return;
					const s$1 = i$1[r$1.min], a = i$1[r$1.mid], o$1 = i$1[r$1.max];
					if (s$1 && a && o$1) for (let r$2 = t$1; r$2 < e$1; r$2++) this.emplace(this.zoomInPaintVertexArray, r$2, a, s$1), this.emplace(this.zoomOutPaintVertexArray, r$2, a, o$1);
				}
				upload(t$1) {
					if (this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer) {
						const e$1 = this.getVertexAttributes();
						this.zoomInPaintVertexBuffer = t$1.createVertexBuffer(this.zoomInPaintVertexArray, e$1, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t$1.createVertexBuffer(this.zoomOutPaintVertexArray, e$1, this.expression.isStateDependent);
					}
				}
				destroy() {
					this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
				}
			}
			class zo extends Do {
				getPositions(t$1) {
					return t$1.imagePositions;
				}
				getPositionIds(t$1) {
					return t$1.patterns && t$1.patterns[this.layerId];
				}
				getVertexAttributes() {
					return ao.members;
				}
				emplace(t$1, e$1, r$1, n$1) {
					t$1.emplace(e$1, r$1.tlbr[0], r$1.tlbr[1], r$1.tlbr[2], r$1.tlbr[3], n$1.tlbr[0], n$1.tlbr[1], n$1.tlbr[2], n$1.tlbr[3], r$1.pixelRatio, n$1.pixelRatio);
				}
			}
			class Po extends Do {
				getPositions(t$1) {
					return t$1.dashPositions;
				}
				getPositionIds(t$1) {
					return t$1.dashes && t$1.dashes[this.layerId];
				}
				getVertexAttributes() {
					return oo.members;
				}
				emplace(t$1, e$1, r$1, n$1) {
					t$1.emplace(e$1, 0, r$1.y, r$1.height, r$1.width, 0, n$1.y, n$1.height, n$1.width);
				}
			}
			class Bo {
				constructor(t$1, e$1, r$1) {
					this.binders = {}, this._buffers = [];
					const n$1 = [];
					for (const i$1 in t$1.paint._values) {
						if (!r$1(i$1)) continue;
						const s$1 = t$1.paint.get(i$1);
						if (!(s$1 instanceof Us && qn(s$1.property.specification))) continue;
						const a = Co(i$1, t$1.type), o$1 = s$1.value, l$1 = s$1.property.specification.type, u$1 = s$1.property.useIntegerZoom, c$1 = s$1.property.specification["property-type"], h$1 = "cross-faded" === c$1 || "cross-faded-data-driven" === c$1;
						if ("constant" === o$1.kind) this.binders[i$1] = h$1 ? new Io(o$1.value, a) : new To(o$1.value, a, l$1), n$1.push(`/u_${i$1}`);
						else if ("source" === o$1.kind || h$1) {
							const r$2 = Lo(i$1, l$1, "source");
							this.binders[i$1] = h$1 ? "line-dasharray" === i$1 ? new Po(o$1, l$1, u$1, e$1, r$2, t$1.id) : new zo(o$1, l$1, u$1, e$1, r$2, t$1.id) : new Mo(o$1, a, l$1, r$2), n$1.push(`/a_${i$1}`);
						} else {
							const t$2 = Lo(i$1, l$1, "composite");
							this.binders[i$1] = new Fo(o$1, a, l$1, u$1, e$1, t$2), n$1.push(`/z_${i$1}`);
						}
					}
					this.cacheKey = n$1.sort().join("");
				}
				getMaxValue(t$1) {
					const e$1 = this.binders[t$1];
					return e$1 instanceof Mo || e$1 instanceof Fo ? e$1.maxValue : 0;
				}
				populatePaintArrays(t$1, e$1, r$1) {
					for (const n$1 in this.binders) {
						const i$1 = this.binders[n$1];
						(i$1 instanceof Mo || i$1 instanceof Fo || i$1 instanceof Do) && i$1.populatePaintArray(t$1, e$1, r$1);
					}
				}
				setConstantPatternPositions(t$1, e$1) {
					for (const r$1 in this.binders) {
						const n$1 = this.binders[r$1];
						n$1 instanceof Io && n$1.setConstantPatternPositions(t$1, e$1);
					}
				}
				setConstantDashPositions(t$1, e$1) {
					for (const r$1 in this.binders) {
						const n$1 = this.binders[r$1];
						n$1 instanceof Io && n$1.setConstantDashPositions(t$1, e$1);
					}
				}
				updatePaintArrays(t$1, e$1, r$1, n$1, i$1) {
					let s$1 = !1;
					for (const a in t$1) {
						const o$1 = e$1.getPositions(a);
						for (const e$2 of o$1) {
							const o$2 = r$1.feature(e$2.index);
							for (const r$2 in this.binders) {
								const l$1 = this.binders[r$2];
								if ((l$1 instanceof Mo || l$1 instanceof Fo || l$1 instanceof Do) && !0 === l$1.expression.isStateDependent) l$1.expression = n$1.paint.get(r$2).value, l$1.updatePaintArray(e$2.start, e$2.end, o$2, t$1[a], i$1), s$1 = !0;
							}
						}
					}
					return s$1;
				}
				defines() {
					const t$1 = [];
					for (const e$1 in this.binders) {
						const r$1 = this.binders[e$1];
						(r$1 instanceof To || r$1 instanceof Io) && t$1.push(...r$1.uniformNames.map(((t$2) => `#define HAS_UNIFORM_${t$2}`)));
					}
					return t$1;
				}
				getBinderAttributes() {
					const t$1 = [];
					for (const e$1 in this.binders) {
						const r$1 = this.binders[e$1];
						if (r$1 instanceof Mo || r$1 instanceof Fo) for (let e$2 = 0; e$2 < r$1.paintVertexAttributes.length; e$2++) t$1.push(r$1.paintVertexAttributes[e$2].name);
						else if (r$1 instanceof Do) {
							const e$2 = r$1.getVertexAttributes();
							for (const r$2 of e$2) t$1.push(r$2.name);
						}
					}
					return t$1;
				}
				getBinderUniforms() {
					const t$1 = [];
					for (const e$1 in this.binders) {
						const r$1 = this.binders[e$1];
						if (r$1 instanceof To || r$1 instanceof Io || r$1 instanceof Fo) for (const e$2 of r$1.uniformNames) t$1.push(e$2);
					}
					return t$1;
				}
				getPaintVertexBuffers() {
					return this._buffers;
				}
				getUniforms(t$1, e$1) {
					const r$1 = [];
					for (const n$1 in this.binders) {
						const i$1 = this.binders[n$1];
						if (i$1 instanceof To || i$1 instanceof Io || i$1 instanceof Fo) {
							for (const s$1 of i$1.uniformNames) if (e$1[s$1]) {
								const a = i$1.getBinding(t$1, e$1[s$1], s$1);
								r$1.push({
									name: s$1,
									property: n$1,
									binding: a
								});
							}
						}
					}
					return r$1;
				}
				setUniforms(t$1, e$1, r$1, n$1) {
					for (const { name: t$2, property: i$1, binding: s$1 } of e$1) this.binders[i$1].setUniform(s$1, n$1, r$1.get(i$1), t$2);
				}
				updatePaintBuffers(t$1) {
					this._buffers = [];
					for (const e$1 in this.binders) {
						const r$1 = this.binders[e$1];
						if (t$1 && r$1 instanceof Do) {
							const e$2 = 2 === t$1.fromScale ? r$1.zoomInPaintVertexBuffer : r$1.zoomOutPaintVertexBuffer;
							e$2 && this._buffers.push(e$2);
						} else (r$1 instanceof Mo || r$1 instanceof Fo) && r$1.paintVertexBuffer && this._buffers.push(r$1.paintVertexBuffer);
					}
				}
				upload(t$1) {
					for (const e$1 in this.binders) {
						const r$1 = this.binders[e$1];
						(r$1 instanceof Mo || r$1 instanceof Fo || r$1 instanceof Do) && r$1.upload(t$1);
					}
					this.updatePaintBuffers();
				}
				destroy() {
					for (const t$1 in this.binders) {
						const e$1 = this.binders[t$1];
						(e$1 instanceof Mo || e$1 instanceof Fo || e$1 instanceof Do) && e$1.destroy();
					}
				}
			}
			class Vo {
				constructor(t$1, e$1, r$1 = () => !0) {
					this.programConfigurations = {};
					for (const n$1 of t$1) this.programConfigurations[n$1.id] = new Bo(n$1, e$1, r$1);
					this.needsUpload = !1, this._featureMap = new go(), this._bufferOffset = 0;
				}
				populatePaintArrays(t$1, e$1, r$1, n$1) {
					for (const r$2 in this.programConfigurations) this.programConfigurations[r$2].populatePaintArrays(t$1, e$1, n$1);
					void 0 !== e$1.id && this._featureMap.add(e$1.id, r$1, this._bufferOffset, t$1), this._bufferOffset = t$1, this.needsUpload = !0;
				}
				updatePaintArrays(t$1, e$1, r$1, n$1) {
					for (const i$1 of r$1) this.needsUpload = this.programConfigurations[i$1.id].updatePaintArrays(t$1, this._featureMap, e$1, i$1, n$1) || this.needsUpload;
				}
				get(t$1) {
					return this.programConfigurations[t$1];
				}
				upload(t$1) {
					if (this.needsUpload) {
						for (const e$1 in this.programConfigurations) this.programConfigurations[e$1].upload(t$1);
						this.needsUpload = !1;
					}
				}
				destroy() {
					for (const t$1 in this.programConfigurations) this.programConfigurations[t$1].destroy();
				}
			}
			function Co(t$1, e$1) {
				return {
					"text-opacity": ["opacity"],
					"icon-opacity": ["opacity"],
					"text-color": ["fill_color"],
					"icon-color": ["fill_color"],
					"text-halo-color": ["halo_color"],
					"icon-halo-color": ["halo_color"],
					"text-halo-blur": ["halo_blur"],
					"icon-halo-blur": ["halo_blur"],
					"text-halo-width": ["halo_width"],
					"icon-halo-width": ["halo_width"],
					"line-gap-width": ["gapwidth"],
					"line-dasharray": ["dasharray_to", "dasharray_from"],
					"line-pattern": [
						"pattern_to",
						"pattern_from",
						"pixel_ratio_to",
						"pixel_ratio_from"
					],
					"fill-pattern": [
						"pattern_to",
						"pattern_from",
						"pixel_ratio_to",
						"pixel_ratio_from"
					],
					"fill-extrusion-pattern": [
						"pattern_to",
						"pattern_from",
						"pixel_ratio_to",
						"pixel_ratio_from"
					]
				}[t$1] || [t$1.replace(`${e$1}-`, "").replace(/-/g, "_")];
			}
			function Lo(t$1, e$1, r$1) {
				const n$1 = {
					color: {
						source: ca,
						composite: Ia
					},
					number: {
						source: Sa,
						composite: ca
					}
				}, i$1 = function(t$2) {
					return {
						"line-pattern": {
							source: Ya,
							composite: Ya
						},
						"fill-pattern": {
							source: Ya,
							composite: Ya
						},
						"fill-extrusion-pattern": {
							source: Ya,
							composite: Ya
						},
						"line-dasharray": {
							source: Za,
							composite: Za
						}
					}[t$2];
				}(t$1);
				return i$1 && i$1[r$1] || n$1[e$1][r$1];
			}
			ps("ConstantBinder", To), ps("CrossFadedConstantBinder", Io), ps("SourceExpressionBinder", Mo), ps("CrossFadedPatternBinder", zo), ps("CrossFadedDasharrayBinder", Po), ps("CompositeExpressionBinder", Fo), ps("ProgramConfiguration", Bo, { omit: ["_buffers"] }), ps("ProgramConfigurationSet", Vo);
			const Oo = Math.pow(2, 14) - 1, Ro = -Oo - 1;
			function No(t$1) {
				const e$1 = M / t$1.extent, r$1 = t$1.loadGeometry();
				for (let t$2 = 0; t$2 < r$1.length; t$2++) {
					const n$1 = r$1[t$2];
					for (let t$3 = 0; t$3 < n$1.length; t$3++) {
						const r$2 = n$1[t$3], i$1 = Math.round(r$2.x * e$1), s$1 = Math.round(r$2.y * e$1);
						r$2.x = C(i$1, Ro, Oo), r$2.y = C(s$1, Ro, Oo), (i$1 < r$2.x || i$1 > r$2.x + 1 || s$1 < r$2.y || s$1 > r$2.y + 1) && j("Geometry exceeds allowed extent, reduce your vector tile buffer size");
					}
				}
				return r$1;
			}
			function $o(t$1, e$1) {
				return {
					type: t$1.type,
					id: t$1.id,
					properties: t$1.properties,
					geometry: e$1 ? No(t$1) : []
				};
			}
			const Uo = -32768;
			function qo(t$1, e$1, r$1, n$1, i$1) {
				t$1.emplaceBack(Uo + 8 * e$1 + n$1, Uo + 8 * r$1 + i$1);
			}
			class jo {
				constructor(t$1) {
					this.zoom = t$1.zoom, this.overscaling = t$1.overscaling, this.layers = t$1.layers, this.layerIds = this.layers.map(((t$2) => t$2.id)), this.index = t$1.index, this.hasDependencies = !1, this.layoutVertexArray = new Ua(), this.indexArray = new to(), this.segments = new io(), this.programConfigurations = new Vo(t$1.layers, t$1.zoom), this.stateDependentLayerIds = this.layers.filter(((t$2) => t$2.isStateDependent())).map(((t$2) => t$2.id));
				}
				populate(t$1, e$1, r$1) {
					const n$1 = this.layers[0], i$1 = [];
					let s$1 = null, a = !1, o$1 = "heatmap" === n$1.type;
					if ("circle" === n$1.type) {
						const t$2 = n$1;
						s$1 = t$2.layout.get("circle-sort-key"), a = !s$1.isConstant(), o$1 = o$1 || "map" === t$2.paint.get("circle-pitch-alignment");
					}
					const l$1 = o$1 ? e$1.subdivisionGranularity.circle : 1;
					for (const { feature: e$2, id: n$2, index: o$2, sourceLayerIndex: l$2 } of t$1) {
						const t$2 = this.layers[0]._featureFilter.needGeometry, u$1 = $o(e$2, t$2);
						if (!this.layers[0]._featureFilter.filter(new Ps(this.zoom), u$1, r$1)) continue;
						const c$1 = a ? s$1.evaluate(u$1, {}, r$1) : void 0, h$1 = {
							id: n$2,
							properties: e$2.properties,
							type: e$2.type,
							sourceLayerIndex: l$2,
							index: o$2,
							geometry: t$2 ? u$1.geometry : No(e$2),
							patterns: {},
							sortKey: c$1
						};
						i$1.push(h$1);
					}
					a && i$1.sort(((t$2, e$2) => t$2.sortKey - e$2.sortKey));
					for (const n$2 of i$1) {
						const { geometry: i$2, index: s$2, sourceLayerIndex: a$1 } = n$2, o$2 = t$1[s$2].feature;
						this.addFeature(n$2, i$2, s$2, r$1, l$1), e$1.featureIndex.insert(o$2, i$2, s$2, a$1, this.index);
					}
				}
				update(t$1, e$1, r$1) {
					this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t$1, e$1, this.stateDependentLayers, { imagePositions: r$1 });
				}
				isEmpty() {
					return 0 === this.layoutVertexArray.length;
				}
				uploadPending() {
					return !this.uploaded || this.programConfigurations.needsUpload;
				}
				upload(t$1) {
					this.uploaded || (this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, no), this.indexBuffer = t$1.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t$1), this.uploaded = !0;
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
				}
				addFeature(t$1, e$1, r$1, n$1, i$1 = 1) {
					let s$1;
					switch (i$1) {
						case 1:
							s$1 = [0, 7];
							break;
						case 3:
							s$1 = [
								0,
								2,
								5,
								7
							];
							break;
						case 5:
							s$1 = [
								0,
								1,
								3,
								4,
								6,
								7
							];
							break;
						case 7:
							s$1 = [
								0,
								1,
								2,
								3,
								4,
								5,
								6,
								7
							];
							break;
						default: throw new Error(`Invalid circle bucket granularity: ${i$1}; valid values are 1, 3, 5, 7.`);
					}
					const a = s$1.length;
					for (const r$2 of e$1) for (const e$2 of r$2) {
						const r$3 = e$2.x, n$2 = e$2.y;
						if (r$3 < 0 || r$3 >= M || n$2 < 0 || n$2 >= M) continue;
						const i$2 = this.segments.prepareSegment(a * a, this.layoutVertexArray, this.indexArray, t$1.sortKey), o$1 = i$2.vertexLength;
						for (let t$2 = 0; t$2 < a; t$2++) for (let e$3 = 0; e$3 < a; e$3++) qo(this.layoutVertexArray, r$3, n$2, s$1[e$3], s$1[t$2]);
						for (let t$2 = 0; t$2 < a - 1; t$2++) for (let e$3 = 0; e$3 < a - 1; e$3++) {
							const r$4 = o$1 + t$2 * a + e$3, n$3 = o$1 + (t$2 + 1) * a + e$3;
							this.indexArray.emplaceBack(r$4, n$3 + 1, r$4 + 1), this.indexArray.emplaceBack(r$4, n$3, n$3 + 1);
						}
						i$2.vertexLength += a * a, i$2.primitiveLength += (a - 1) * (a - 1) * 2;
					}
					this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t$1, r$1, {
						imagePositions: {},
						canonical: n$1
					});
				}
			}
			function Go(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) if (tl(e$1, t$1[r$1])) return !0;
				for (let r$1 = 0; r$1 < e$1.length; r$1++) if (tl(t$1, e$1[r$1])) return !0;
				return !!Ho(t$1, e$1);
			}
			function Xo(t$1, e$1, r$1) {
				return !!tl(t$1, e$1) || !!Wo(e$1, t$1, r$1);
			}
			function Yo(t$1, e$1) {
				if (1 === t$1.length) return Qo(e$1, t$1[0]);
				for (let r$1 = 0; r$1 < e$1.length; r$1++) {
					const n$1 = e$1[r$1];
					for (let e$2 = 0; e$2 < n$1.length; e$2++) if (tl(t$1, n$1[e$2])) return !0;
				}
				for (let r$1 = 0; r$1 < t$1.length; r$1++) if (Qo(e$1, t$1[r$1])) return !0;
				for (let r$1 = 0; r$1 < e$1.length; r$1++) if (Ho(t$1, e$1[r$1])) return !0;
				return !1;
			}
			function Zo(t$1, e$1, r$1) {
				if (t$1.length > 1) {
					if (Ho(t$1, e$1)) return !0;
					for (let n$1 = 0; n$1 < e$1.length; n$1++) if (Wo(e$1[n$1], t$1, r$1)) return !0;
				}
				for (let n$1 = 0; n$1 < t$1.length; n$1++) if (Wo(t$1[n$1], e$1, r$1)) return !0;
				return !1;
			}
			function Ho(t$1, e$1) {
				if (0 === t$1.length || 0 === e$1.length) return !1;
				for (let r$1 = 0; r$1 < t$1.length - 1; r$1++) {
					const n$1 = t$1[r$1], i$1 = t$1[r$1 + 1];
					for (let t$2 = 0; t$2 < e$1.length - 1; t$2++) if (Ko(n$1, i$1, e$1[t$2], e$1[t$2 + 1])) return !0;
				}
				return !1;
			}
			function Ko(t$1, e$1, r$1, n$1) {
				return G(t$1, r$1, n$1) !== G(e$1, r$1, n$1) && G(t$1, e$1, r$1) !== G(t$1, e$1, n$1);
			}
			function Wo(t$1, e$1, r$1) {
				const n$1 = r$1 * r$1;
				if (1 === e$1.length) return t$1.distSqr(e$1[0]) < n$1;
				for (let r$2 = 1; r$2 < e$1.length; r$2++) if (Jo(t$1, e$1[r$2 - 1], e$1[r$2]) < n$1) return !0;
				return !1;
			}
			function Jo(t$1, e$1, r$1) {
				const n$1 = e$1.distSqr(r$1);
				if (0 === n$1) return t$1.distSqr(e$1);
				const i$1 = ((t$1.x - e$1.x) * (r$1.x - e$1.x) + (t$1.y - e$1.y) * (r$1.y - e$1.y)) / n$1;
				return t$1.distSqr(i$1 < 0 ? e$1 : i$1 > 1 ? r$1 : r$1.sub(e$1)._mult(i$1)._add(e$1));
			}
			function Qo(t$1, e$1) {
				let r$1, n$1, i$1, s$1 = !1;
				for (let a = 0; a < t$1.length; a++) {
					r$1 = t$1[a];
					for (let t$2 = 0, a$1 = r$1.length - 1; t$2 < r$1.length; a$1 = t$2++) n$1 = r$1[t$2], i$1 = r$1[a$1], n$1.y > e$1.y != i$1.y > e$1.y && e$1.x < (i$1.x - n$1.x) * (e$1.y - n$1.y) / (i$1.y - n$1.y) + n$1.x && (s$1 = !s$1);
				}
				return s$1;
			}
			function tl(t$1, e$1) {
				let r$1 = !1;
				for (let n$1 = 0, i$1 = t$1.length - 1; n$1 < t$1.length; i$1 = n$1++) {
					const s$1 = t$1[n$1], a = t$1[i$1];
					s$1.y > e$1.y != a.y > e$1.y && e$1.x < (a.x - s$1.x) * (e$1.y - s$1.y) / (a.y - s$1.y) + s$1.x && (r$1 = !r$1);
				}
				return r$1;
			}
			function el(t$1, e$1, r$1) {
				const n$1 = r$1[0], i$1 = r$1[2];
				if (t$1.x < n$1.x && e$1.x < n$1.x || t$1.x > i$1.x && e$1.x > i$1.x || t$1.y < n$1.y && e$1.y < n$1.y || t$1.y > i$1.y && e$1.y > i$1.y) return !1;
				const s$1 = G(t$1, e$1, r$1[0]);
				return s$1 !== G(t$1, e$1, r$1[1]) || s$1 !== G(t$1, e$1, r$1[2]) || s$1 !== G(t$1, e$1, r$1[3]);
			}
			function rl(t$1, e$1, r$1) {
				const n$1 = e$1.paint.get(t$1).value;
				return "constant" === n$1.kind ? n$1.value : r$1.programConfigurations.get(e$1.id).getMaxValue(t$1);
			}
			function nl(t$1) {
				return Math.sqrt(t$1[0] * t$1[0] + t$1[1] * t$1[1]);
			}
			function il(t$1, e$1, n$1, i$1, s$1) {
				if (!e$1[0] && !e$1[1]) return t$1;
				const a = r.convert(e$1)._mult(s$1);
				"viewport" === n$1 && a._rotate(-i$1);
				const o$1 = [];
				for (let e$2 = 0; e$2 < t$1.length; e$2++) o$1.push(t$1[e$2].sub(a));
				return o$1;
			}
			function sl(t$1) {
				const e$1 = [];
				for (let r$1 = 0; r$1 < t$1.length; r$1++) {
					const n$1 = t$1[r$1], i$1 = e$1.at(-1);
					(0 === r$1 || i$1 && !n$1.equals(i$1)) && e$1.push(n$1);
				}
				return e$1;
			}
			function al({ queryGeometry: t$1, size: e$1 }, r$1) {
				return Xo(t$1, r$1, e$1);
			}
			function ol({ queryGeometry: t$1, size: e$1, transform: r$1, unwrappedTileID: n$1, getElevation: i$1 }, s$1) {
				return Xo(t$1, s$1, e$1 * (r$1.projectTileCoordinates(s$1.x, s$1.y, n$1, i$1).signedDistanceFromCamera / r$1.cameraToCenterDistance));
			}
			function ll({ queryGeometry: t$1, size: e$1, transform: r$1, unwrappedTileID: n$1, getElevation: i$1 }, s$1) {
				const a = r$1.projectTileCoordinates(s$1.x, s$1.y, n$1, i$1).signedDistanceFromCamera, o$1 = e$1 * (r$1.cameraToCenterDistance / a);
				return Xo(t$1, hl(s$1, r$1, n$1, i$1), o$1);
			}
			function ul({ queryGeometry: t$1, size: e$1, transform: r$1, unwrappedTileID: n$1, getElevation: i$1 }, s$1) {
				return Xo(t$1, hl(s$1, r$1, n$1, i$1), e$1);
			}
			function cl({ queryGeometry: t$1, size: e$1, transform: r$1, unwrappedTileID: n$1, getElevation: i$1, pitchAlignment: s$1 = "map", pitchScale: a = "map" }, o$1) {
				const l$1 = "map" === s$1 ? "map" === a ? al : ol : "map" === a ? ll : ul, u$1 = {
					queryGeometry: t$1,
					size: e$1,
					transform: r$1,
					unwrappedTileID: n$1,
					getElevation: i$1
				};
				for (const t$2 of o$1) for (const e$2 of t$2) if (l$1(u$1, e$2)) return !0;
				return !1;
			}
			function hl(t$1, e$1, n$1, i$1) {
				const s$1 = e$1.projectTileCoordinates(t$1.x, t$1.y, n$1, i$1).point;
				return new r((.5 * s$1.x + .5) * e$1.width, (.5 * -s$1.y + .5) * e$1.height);
			}
			let pl, fl;
			ps("CircleBucket", jo, { omit: ["layers"] });
			var dl = {
				get paint() {
					return fl = fl || new Hs({
						"circle-radius": new Gs(vt.paint_circle["circle-radius"]),
						"circle-color": new Gs(vt.paint_circle["circle-color"]),
						"circle-blur": new Gs(vt.paint_circle["circle-blur"]),
						"circle-opacity": new Gs(vt.paint_circle["circle-opacity"]),
						"circle-translate": new js(vt.paint_circle["circle-translate"]),
						"circle-translate-anchor": new js(vt.paint_circle["circle-translate-anchor"]),
						"circle-pitch-scale": new js(vt.paint_circle["circle-pitch-scale"]),
						"circle-pitch-alignment": new js(vt.paint_circle["circle-pitch-alignment"]),
						"circle-stroke-width": new Gs(vt.paint_circle["circle-stroke-width"]),
						"circle-stroke-color": new Gs(vt.paint_circle["circle-stroke-color"]),
						"circle-stroke-opacity": new Gs(vt.paint_circle["circle-stroke-opacity"])
					});
				},
				get layout() {
					return pl = pl || new Hs({ "circle-sort-key": new Gs(vt.layout_circle["circle-sort-key"]) });
				}
			};
			class yl extends Ks {
				constructor(t$1, e$1) {
					super(t$1, dl, e$1);
				}
				createBucket(t$1) {
					return new jo(t$1);
				}
				queryRadius(t$1) {
					const e$1 = t$1;
					return rl("circle-radius", this, e$1) + rl("circle-stroke-width", this, e$1) + nl(this.paint.get("circle-translate"));
				}
				queryIntersectsFeature({ queryGeometry: t$1, feature: e$1, featureState: r$1, geometry: n$1, transform: i$1, pixelsToTileUnits: s$1, unwrappedTileID: a, getElevation: o$1 }) {
					const l$1 = il(t$1, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -i$1.bearingInRadians, s$1), u$1 = this.paint.get("circle-radius").evaluate(e$1, r$1) + this.paint.get("circle-stroke-width").evaluate(e$1, r$1), c$1 = this.paint.get("circle-pitch-scale"), h$1 = this.paint.get("circle-pitch-alignment");
					let p$1, f$1;
					return "map" === h$1 ? (p$1 = l$1, f$1 = u$1 * s$1) : (p$1 = function(t$2, e$2, r$2, n$2) {
						return t$2.map(((t$3) => hl(t$3, e$2, r$2, n$2)));
					}(l$1, i$1, a, o$1), f$1 = u$1), cl({
						queryGeometry: p$1,
						size: f$1,
						transform: i$1,
						unwrappedTileID: a,
						getElevation: o$1,
						pitchAlignment: h$1,
						pitchScale: c$1
					}, n$1);
				}
			}
			class ml extends jo {}
			let gl;
			ps("HeatmapBucket", ml, { omit: ["layers"] });
			var xl = { get paint() {
				return gl = gl || new Hs({
					"heatmap-radius": new Gs(vt.paint_heatmap["heatmap-radius"]),
					"heatmap-weight": new Gs(vt.paint_heatmap["heatmap-weight"]),
					"heatmap-intensity": new js(vt.paint_heatmap["heatmap-intensity"]),
					"heatmap-color": new Zs(vt.paint_heatmap["heatmap-color"]),
					"heatmap-opacity": new js(vt.paint_heatmap["heatmap-opacity"])
				});
			} };
			function vl(t$1, { width: e$1, height: r$1 }, n$1, i$1) {
				if (i$1) {
					if (i$1 instanceof Uint8ClampedArray) i$1 = new Uint8Array(i$1.buffer);
					else if (i$1.length !== e$1 * r$1 * n$1) throw new RangeError(`mismatched image size. expected: ${i$1.length} but got: ${e$1 * r$1 * n$1}`);
				} else i$1 = new Uint8Array(e$1 * r$1 * n$1);
				return t$1.width = e$1, t$1.height = r$1, t$1.data = i$1, t$1;
			}
			function bl(t$1, { width: e$1, height: r$1 }, n$1) {
				if (e$1 === t$1.width && r$1 === t$1.height) return;
				const i$1 = vl({}, {
					width: e$1,
					height: r$1
				}, n$1);
				wl(t$1, i$1, {
					x: 0,
					y: 0
				}, {
					x: 0,
					y: 0
				}, {
					width: Math.min(t$1.width, e$1),
					height: Math.min(t$1.height, r$1)
				}, n$1), t$1.width = e$1, t$1.height = r$1, t$1.data = i$1.data;
			}
			function wl(t$1, e$1, r$1, n$1, i$1, s$1) {
				if (0 === i$1.width || 0 === i$1.height) return e$1;
				if (i$1.width > t$1.width || i$1.height > t$1.height || r$1.x > t$1.width - i$1.width || r$1.y > t$1.height - i$1.height) throw new RangeError("out of range source coordinates for image copy");
				if (i$1.width > e$1.width || i$1.height > e$1.height || n$1.x > e$1.width - i$1.width || n$1.y > e$1.height - i$1.height) throw new RangeError("out of range destination coordinates for image copy");
				const a = t$1.data, o$1 = e$1.data;
				if (a === o$1) throw new Error("srcData equals dstData, so image is already copied");
				for (let l$1 = 0; l$1 < i$1.height; l$1++) {
					const u$1 = ((r$1.y + l$1) * t$1.width + r$1.x) * s$1, c$1 = ((n$1.y + l$1) * e$1.width + n$1.x) * s$1;
					for (let t$2 = 0; t$2 < i$1.width * s$1; t$2++) o$1[c$1 + t$2] = a[u$1 + t$2];
				}
				return e$1;
			}
			class _l {
				constructor(t$1, e$1) {
					vl(this, t$1, 1, e$1);
				}
				resize(t$1) {
					bl(this, t$1, 1);
				}
				clone() {
					return new _l({
						width: this.width,
						height: this.height
					}, new Uint8Array(this.data));
				}
				static copy(t$1, e$1, r$1, n$1, i$1) {
					wl(t$1, e$1, r$1, n$1, i$1, 1);
				}
			}
			class Sl {
				constructor(t$1, e$1) {
					vl(this, t$1, 4, e$1);
				}
				resize(t$1) {
					bl(this, t$1, 4);
				}
				replace(t$1, e$1) {
					e$1 ? this.data.set(t$1) : this.data = t$1 instanceof Uint8ClampedArray ? new Uint8Array(t$1.buffer) : t$1;
				}
				clone() {
					return new Sl({
						width: this.width,
						height: this.height
					}, new Uint8Array(this.data));
				}
				static copy(t$1, e$1, r$1, n$1, i$1) {
					wl(t$1, e$1, r$1, n$1, i$1, 4);
				}
				setPixel(t$1, e$1, r$1) {
					const n$1 = 4 * (t$1 * this.width + e$1);
					this.data[n$1 + 0] = Math.round(255 * r$1.r / r$1.a), this.data[n$1 + 1] = Math.round(255 * r$1.g / r$1.a), this.data[n$1 + 2] = Math.round(255 * r$1.b / r$1.a), this.data[n$1 + 3] = Math.round(255 * r$1.a);
				}
			}
			function Al(t$1) {
				const e$1 = {}, r$1 = t$1.resolution || 256, n$1 = t$1.clips ? t$1.clips.length : 1, i$1 = t$1.image || new Sl({
					width: r$1,
					height: n$1
				});
				if (Math.log(r$1) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${r$1}`);
				const s$1 = (n$2, s$2, a) => {
					e$1[t$1.evaluationKey] = a;
					const o$1 = t$1.expression.evaluate(e$1);
					i$1.setPixel(n$2 / 4 / r$1, s$2 / 4, o$1);
				};
				if (t$1.clips) for (let e$2 = 0, i$2 = 0; e$2 < n$1; ++e$2, i$2 += 4 * r$1) for (let n$2 = 0, a = 0; n$2 < r$1; n$2++, a += 4) {
					const o$1 = n$2 / (r$1 - 1), { start: l$1, end: u$1 } = t$1.clips[e$2];
					s$1(i$2, a, l$1 * (1 - o$1) + u$1 * o$1);
				}
				else for (let t$2 = 0, e$2 = 0; t$2 < r$1; t$2++, e$2 += 4) s$1(0, e$2, t$2 / (r$1 - 1));
				return i$1;
			}
			ps("AlphaImage", _l), ps("RGBAImage", Sl);
			const kl = "big-fb";
			class El extends Ks {
				createBucket(t$1) {
					return new ml(t$1);
				}
				constructor(t$1, e$1) {
					super(t$1, xl, e$1), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
				}
				_handleSpecialPaintPropertyUpdate(t$1) {
					"heatmap-color" === t$1 && this._updateColorRamp();
				}
				_updateColorRamp() {
					this.colorRamp = Al({
						expression: this._transitionablePaint._values["heatmap-color"].value.expression,
						evaluationKey: "heatmapDensity",
						image: this.colorRamp
					}), this.colorRampTexture = null;
				}
				resize() {
					this.heatmapFbos.has(kl) && this.heatmapFbos.delete(kl);
				}
				queryRadius(t$1) {
					return rl("heatmap-radius", this, t$1);
				}
				queryIntersectsFeature({ queryGeometry: t$1, feature: e$1, featureState: r$1, geometry: n$1, transform: i$1, pixelsToTileUnits: s$1, unwrappedTileID: a, getElevation: o$1 }) {
					return cl({
						queryGeometry: t$1,
						size: this.paint.get("heatmap-radius").evaluate(e$1, r$1) * s$1,
						transform: i$1,
						unwrappedTileID: a,
						getElevation: o$1
					}, n$1);
				}
				hasOffscreenPass() {
					return 0 !== this.paint.get("heatmap-opacity") && !this.isHidden();
				}
			}
			let Tl;
			var Il = { get paint() {
				return Tl = Tl || new Hs({
					"hillshade-illumination-direction": new js(vt.paint_hillshade["hillshade-illumination-direction"]),
					"hillshade-illumination-altitude": new js(vt.paint_hillshade["hillshade-illumination-altitude"]),
					"hillshade-illumination-anchor": new js(vt.paint_hillshade["hillshade-illumination-anchor"]),
					"hillshade-exaggeration": new js(vt.paint_hillshade["hillshade-exaggeration"]),
					"hillshade-shadow-color": new js(vt.paint_hillshade["hillshade-shadow-color"]),
					"hillshade-highlight-color": new js(vt.paint_hillshade["hillshade-highlight-color"]),
					"hillshade-accent-color": new js(vt.paint_hillshade["hillshade-accent-color"]),
					"hillshade-method": new js(vt.paint_hillshade["hillshade-method"])
				});
			} };
			class Ml extends Ks {
				constructor(t$1, e$1) {
					super(t$1, Il, e$1), this.recalculate({
						zoom: 0,
						zoomHistory: {}
					}, void 0);
				}
				getIlluminationProperties() {
					let t$1 = this.paint.get("hillshade-illumination-direction").values, e$1 = this.paint.get("hillshade-illumination-altitude").values, r$1 = this.paint.get("hillshade-highlight-color").values, n$1 = this.paint.get("hillshade-shadow-color").values;
					const i$1 = Math.max(t$1.length, e$1.length, r$1.length, n$1.length);
					t$1 = t$1.concat(Array(i$1 - t$1.length).fill(t$1.at(-1))), e$1 = e$1.concat(Array(i$1 - e$1.length).fill(e$1.at(-1))), r$1 = r$1.concat(Array(i$1 - r$1.length).fill(r$1.at(-1))), n$1 = n$1.concat(Array(i$1 - n$1.length).fill(n$1.at(-1)));
					const s$1 = e$1.map(tt);
					return {
						directionRadians: t$1.map(tt),
						altitudeRadians: s$1,
						shadowColor: n$1,
						highlightColor: r$1
					};
				}
				hasOffscreenPass() {
					return 0 !== this.paint.get("hillshade-exaggeration") && !this.isHidden();
				}
			}
			let Fl;
			var Dl = { get paint() {
				return Fl = Fl || new Hs({
					"color-relief-opacity": new js(vt["paint_color-relief"]["color-relief-opacity"]),
					"color-relief-color": new Zs(vt["paint_color-relief"]["color-relief-color"])
				});
			} };
			class zl {
				constructor(t$1, e$1, r$1, n$1) {
					this.context = t$1, this.format = r$1, this.texture = t$1.gl.createTexture(), this.update(e$1, n$1);
				}
				update(t$1, e$1, r$1) {
					const { width: n$1, height: i$1 } = t$1, s$1 = !(this.size && this.size[0] === n$1 && this.size[1] === i$1 || r$1), { context: a } = this, { gl: o$1 } = a;
					if (this.useMipmap = Boolean(e$1 && e$1.useMipmap), o$1.bindTexture(o$1.TEXTURE_2D, this.texture), a.pixelStoreUnpackFlipY.set(!1), a.pixelStoreUnpack.set(1), a.pixelStoreUnpackPremultiplyAlpha.set(this.format === o$1.RGBA && (!e$1 || !1 !== e$1.premultiply)), s$1) this.size = [n$1, i$1], t$1 instanceof HTMLImageElement || t$1 instanceof HTMLCanvasElement || t$1 instanceof HTMLVideoElement || t$1 instanceof ImageData || Z(t$1) ? o$1.texImage2D(o$1.TEXTURE_2D, 0, this.format, this.format, o$1.UNSIGNED_BYTE, t$1) : o$1.texImage2D(o$1.TEXTURE_2D, 0, this.format, n$1, i$1, 0, this.format, o$1.UNSIGNED_BYTE, t$1.data);
					else {
						const { x: e$2, y: s$2 } = r$1 || {
							x: 0,
							y: 0
						};
						t$1 instanceof HTMLImageElement || t$1 instanceof HTMLCanvasElement || t$1 instanceof HTMLVideoElement || t$1 instanceof ImageData || Z(t$1) ? o$1.texSubImage2D(o$1.TEXTURE_2D, 0, e$2, s$2, o$1.RGBA, o$1.UNSIGNED_BYTE, t$1) : o$1.texSubImage2D(o$1.TEXTURE_2D, 0, e$2, s$2, n$1, i$1, o$1.RGBA, o$1.UNSIGNED_BYTE, t$1.data);
					}
					this.useMipmap && this.isSizePowerOfTwo() && o$1.generateMipmap(o$1.TEXTURE_2D), a.pixelStoreUnpackFlipY.setDefault(), a.pixelStoreUnpack.setDefault(), a.pixelStoreUnpackPremultiplyAlpha.setDefault();
				}
				bind(t$1, e$1, r$1) {
					const { context: n$1 } = this, { gl: i$1 } = n$1;
					i$1.bindTexture(i$1.TEXTURE_2D, this.texture), r$1 !== i$1.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (r$1 = i$1.LINEAR), t$1 !== this.filter && (i$1.texParameteri(i$1.TEXTURE_2D, i$1.TEXTURE_MAG_FILTER, t$1), i$1.texParameteri(i$1.TEXTURE_2D, i$1.TEXTURE_MIN_FILTER, r$1 || t$1), this.filter = t$1), e$1 !== this.wrap && (i$1.texParameteri(i$1.TEXTURE_2D, i$1.TEXTURE_WRAP_S, e$1), i$1.texParameteri(i$1.TEXTURE_2D, i$1.TEXTURE_WRAP_T, e$1), this.wrap = e$1);
				}
				isSizePowerOfTwo() {
					return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
				}
				destroy() {
					const { gl: t$1 } = this.context;
					t$1.deleteTexture(this.texture), this.texture = null;
				}
			}
			class Pl {
				constructor(t$1, e$1, r$1, n$1 = 1, i$1 = 1, s$1 = 1, a = 0) {
					if (this.uid = t$1, e$1.height !== e$1.width) throw new RangeError("DEM tiles must be square");
					if (r$1 && ![
						"mapbox",
						"terrarium",
						"custom"
					].includes(r$1)) return void j(`"${r$1}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
					this.stride = e$1.height;
					const o$1 = this.dim = e$1.height - 2;
					switch (this.data = new Uint32Array(e$1.data.buffer), r$1) {
						case "terrarium":
							this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
							break;
						case "custom":
							this.redFactor = n$1, this.greenFactor = i$1, this.blueFactor = s$1, this.baseShift = a;
							break;
						default: this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = .1, this.baseShift = 1e4;
					}
					for (let t$2 = 0; t$2 < o$1; t$2++) this.data[this._idx(-1, t$2)] = this.data[this._idx(0, t$2)], this.data[this._idx(o$1, t$2)] = this.data[this._idx(o$1 - 1, t$2)], this.data[this._idx(t$2, -1)] = this.data[this._idx(t$2, 0)], this.data[this._idx(t$2, o$1)] = this.data[this._idx(t$2, o$1 - 1)];
					this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(o$1, -1)] = this.data[this._idx(o$1 - 1, 0)], this.data[this._idx(-1, o$1)] = this.data[this._idx(0, o$1 - 1)], this.data[this._idx(o$1, o$1)] = this.data[this._idx(o$1 - 1, o$1 - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
					for (let t$2 = 0; t$2 < o$1; t$2++) for (let e$2 = 0; e$2 < o$1; e$2++) {
						const r$2 = this.get(t$2, e$2);
						r$2 > this.max && (this.max = r$2), r$2 < this.min && (this.min = r$2);
					}
				}
				get(t$1, e$1) {
					const r$1 = new Uint8Array(this.data.buffer), n$1 = 4 * this._idx(t$1, e$1);
					return this.unpack(r$1[n$1], r$1[n$1 + 1], r$1[n$1 + 2]);
				}
				getUnpackVector() {
					return [
						this.redFactor,
						this.greenFactor,
						this.blueFactor,
						this.baseShift
					];
				}
				_idx(t$1, e$1) {
					if (t$1 < -1 || t$1 >= this.dim + 1 || e$1 < -1 || e$1 >= this.dim + 1) throw new RangeError(`Out of range source coordinates for DEM data. x: ${t$1}, y: ${e$1}, dim: ${this.dim}`);
					return (e$1 + 1) * this.stride + (t$1 + 1);
				}
				unpack(t$1, e$1, r$1) {
					return t$1 * this.redFactor + e$1 * this.greenFactor + r$1 * this.blueFactor - this.baseShift;
				}
				pack(t$1) {
					return Bl(t$1, this.getUnpackVector());
				}
				getPixels() {
					return new Sl({
						width: this.stride,
						height: this.stride
					}, new Uint8Array(this.data.buffer));
				}
				backfillBorder(t$1, e$1, r$1) {
					if (this.dim !== t$1.dim) throw new Error("dem dimension mismatch");
					let n$1 = e$1 * this.dim, i$1 = e$1 * this.dim + this.dim, s$1 = r$1 * this.dim, a = r$1 * this.dim + this.dim;
					switch (e$1) {
						case -1:
							n$1 = i$1 - 1;
							break;
						case 1: i$1 = n$1 + 1;
					}
					switch (r$1) {
						case -1:
							s$1 = a - 1;
							break;
						case 1: a = s$1 + 1;
					}
					const o$1 = -e$1 * this.dim, l$1 = -r$1 * this.dim;
					for (let e$2 = s$1; e$2 < a; e$2++) for (let r$2 = n$1; r$2 < i$1; r$2++) this.data[this._idx(r$2, e$2)] = t$1.data[this._idx(r$2 + o$1, e$2 + l$1)];
				}
			}
			function Bl(t$1, e$1) {
				const r$1 = e$1[0], n$1 = e$1[1], i$1 = e$1[2], s$1 = e$1[3], a = Math.min(r$1, n$1, i$1), o$1 = Math.round((t$1 + s$1) / a);
				return {
					r: Math.floor(o$1 * a / r$1) % 256,
					g: Math.floor(o$1 * a / n$1) % 256,
					b: Math.floor(o$1 * a / i$1) % 256
				};
			}
			ps("DEMData", Pl);
			class Vl extends Ks {
				constructor(t$1, e$1) {
					super(t$1, Dl, e$1);
				}
				_createColorRamp(t$1) {
					const e$1 = {
						elevationStops: [],
						colorStops: []
					}, r$1 = this._transitionablePaint._values["color-relief-color"].value.expression;
					if (r$1 instanceof ii && r$1._styleExpression.expression instanceof fr) {
						this.colorRampExpression = r$1;
						const t$2 = r$1._styleExpression.expression;
						e$1.elevationStops = t$2.labels, e$1.colorStops = [];
						for (const r$2 of e$1.elevationStops) e$1.colorStops.push(t$2.evaluate({ globals: { elevation: r$2 } }));
					}
					if (e$1.elevationStops.length < 1 && (e$1.elevationStops = [0], e$1.colorStops = [Te.transparent]), e$1.elevationStops.length < 2 && (e$1.elevationStops.push(e$1.elevationStops[0] + 1), e$1.colorStops.push(e$1.colorStops[0])), e$1.elevationStops.length <= t$1) return e$1;
					const n$1 = {
						elevationStops: [],
						colorStops: []
					}, i$1 = (e$1.elevationStops.length - 1) / (t$1 - 1);
					for (let t$2 = 0; t$2 < e$1.elevationStops.length - .5; t$2 += i$1) n$1.elevationStops.push(e$1.elevationStops[Math.round(t$2)]), n$1.colorStops.push(e$1.colorStops[Math.round(t$2)]);
					return j(`Too many colors in specification of ${this.id} color-relief layer, may not render properly. Max possible colors: ${t$1}, provided: ${e$1.elevationStops.length}`), n$1;
				}
				_colorRampChanged() {
					return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression;
				}
				getColorRampTextures(t$1, e$1, r$1) {
					if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
					const n$1 = this._createColorRamp(e$1), i$1 = new Sl({
						width: n$1.colorStops.length,
						height: 1
					}), s$1 = new Sl({
						width: n$1.colorStops.length,
						height: 1
					});
					for (let t$2 = 0; t$2 < n$1.elevationStops.length; t$2++) {
						const e$2 = Bl(n$1.elevationStops[t$2], r$1);
						s$1.setPixel(0, t$2, new Te(e$2.r / 255, e$2.g / 255, e$2.b / 255, 1)), i$1.setPixel(0, t$2, n$1.colorStops[t$2]);
					}
					return this.colorRampTextures = {
						elevationTexture: new zl(t$1, s$1, t$1.gl.RGBA),
						colorTexture: new zl(t$1, i$1, t$1.gl.RGBA)
					}, this.colorRampTextures;
				}
				hasOffscreenPass() {
					return !this.isHidden() && !!this.colorRampTextures;
				}
			}
			const { members: Ll } = na([{
				name: "a_pos",
				components: 2,
				type: "Int16"
			}], 4);
			function Ol(t$1, e$1, r$1) {
				const n$1 = r$1.patternDependencies;
				let i$1 = !1;
				for (const r$2 of e$1) {
					const e$2 = r$2.paint.get(`${t$1}-pattern`);
					e$2.isConstant() || (i$1 = !0);
					const s$1 = e$2.constantOr(null);
					s$1 && (i$1 = !0, n$1[s$1.to] = !0, n$1[s$1.from] = !0);
				}
				return i$1;
			}
			function Rl(t$1, e$1, r$1, n$1, i$1) {
				const { zoom: s$1 } = n$1, a = i$1.patternDependencies;
				for (const n$2 of e$1) {
					const e$2 = n$2.paint.get(`${t$1}-pattern`).value;
					if ("constant" !== e$2.kind) {
						let t$2 = e$2.evaluate({ zoom: s$1 - 1 }, r$1, {}, i$1.availableImages), o$1 = e$2.evaluate({ zoom: s$1 }, r$1, {}, i$1.availableImages), l$1 = e$2.evaluate({ zoom: s$1 + 1 }, r$1, {}, i$1.availableImages);
						t$2 = t$2 && t$2.name ? t$2.name : t$2, o$1 = o$1 && o$1.name ? o$1.name : o$1, l$1 = l$1 && l$1.name ? l$1.name : l$1, a[t$2] = !0, a[o$1] = !0, a[l$1] = !0, r$1.patterns[n$2.id] = {
							min: t$2,
							mid: o$1,
							max: l$1
						};
					}
				}
				return r$1;
			}
			function Nl(t$1, e$1, r$1, n$1, i$1) {
				let s$1;
				if (i$1 === function(t$2, e$2, r$2, n$2) {
					let i$2 = 0;
					for (let s$2 = e$2, a = r$2 - n$2; s$2 < r$2; s$2 += n$2) i$2 += (t$2[a] - t$2[s$2]) * (t$2[s$2 + 1] + t$2[a + 1]), a = s$2;
					return i$2;
				}(t$1, e$1, r$1, n$1) > 0) for (let i$2 = e$1; i$2 < r$1; i$2 += n$1) s$1 = lu(i$2 / n$1 | 0, t$1[i$2], t$1[i$2 + 1], s$1);
				else for (let i$2 = r$1 - n$1; i$2 >= e$1; i$2 -= n$1) s$1 = lu(i$2 / n$1 | 0, t$1[i$2], t$1[i$2 + 1], s$1);
				return s$1 && ru(s$1, s$1.next) && (uu(s$1), s$1 = s$1.next), s$1;
			}
			function $l(t$1, e$1) {
				if (!t$1) return t$1;
				e$1 || (e$1 = t$1);
				let r$1, n$1 = t$1;
				do
					if (r$1 = !1, n$1.steiner || !ru(n$1, n$1.next) && 0 !== eu(n$1.prev, n$1, n$1.next)) n$1 = n$1.next;
					else {
						if (uu(n$1), n$1 = e$1 = n$1.prev, n$1 === n$1.next) break;
						r$1 = !0;
					}
				while (r$1 || n$1 !== e$1);
				return e$1;
			}
			function Ul(t$1, e$1, r$1, n$1, i$1, s$1, a) {
				if (!t$1) return;
				!a && s$1 && function(t$2, e$2, r$2, n$2) {
					let i$2 = t$2;
					do
						0 === i$2.z && (i$2.z = Kl(i$2.x, i$2.y, e$2, r$2, n$2)), i$2.prevZ = i$2.prev, i$2.nextZ = i$2.next, i$2 = i$2.next;
					while (i$2 !== t$2);
					i$2.prevZ.nextZ = null, i$2.prevZ = null, function(t$3) {
						let e$3, r$3 = 1;
						do {
							let n$3, i$3 = t$3;
							t$3 = null;
							let s$2 = null;
							for (e$3 = 0; i$3;) {
								e$3++;
								let a$1 = i$3, o$2 = 0;
								for (let t$4 = 0; t$4 < r$3 && (o$2++, a$1 = a$1.nextZ, a$1); t$4++);
								let l$1 = r$3;
								for (; o$2 > 0 || l$1 > 0 && a$1;) 0 !== o$2 && (0 === l$1 || !a$1 || i$3.z <= a$1.z) ? (n$3 = i$3, i$3 = i$3.nextZ, o$2--) : (n$3 = a$1, a$1 = a$1.nextZ, l$1--), s$2 ? s$2.nextZ = n$3 : t$3 = n$3, n$3.prevZ = s$2, s$2 = n$3;
								i$3 = a$1;
							}
							s$2.nextZ = null, r$3 *= 2;
						} while (e$3 > 1);
					}(i$2);
				}(t$1, n$1, i$1, s$1);
				let o$1 = t$1;
				for (; t$1.prev !== t$1.next;) {
					const l$1 = t$1.prev, u$1 = t$1.next;
					if (s$1 ? jl(t$1, n$1, i$1, s$1) : ql(t$1)) e$1.push(l$1.i, t$1.i, u$1.i), uu(t$1), t$1 = u$1.next, o$1 = u$1.next;
					else if ((t$1 = u$1) === o$1) {
						a ? 1 === a ? Ul(t$1 = Gl($l(t$1), e$1), e$1, r$1, n$1, i$1, s$1, 2) : 2 === a && Xl(t$1, e$1, r$1, n$1, i$1, s$1) : Ul($l(t$1), e$1, r$1, n$1, i$1, s$1, 1);
						break;
					}
				}
			}
			function ql(t$1) {
				const e$1 = t$1.prev, r$1 = t$1, n$1 = t$1.next;
				if (eu(e$1, r$1, n$1) >= 0) return !1;
				const i$1 = e$1.x, s$1 = r$1.x, a = n$1.x, o$1 = e$1.y, l$1 = r$1.y, u$1 = n$1.y, c$1 = Math.min(i$1, s$1, a), h$1 = Math.min(o$1, l$1, u$1), p$1 = Math.max(i$1, s$1, a), f$1 = Math.max(o$1, l$1, u$1);
				let d$1 = n$1.next;
				for (; d$1 !== e$1;) {
					if (d$1.x >= c$1 && d$1.x <= p$1 && d$1.y >= h$1 && d$1.y <= f$1 && Ql(i$1, o$1, s$1, l$1, a, u$1, d$1.x, d$1.y) && eu(d$1.prev, d$1, d$1.next) >= 0) return !1;
					d$1 = d$1.next;
				}
				return !0;
			}
			function jl(t$1, e$1, r$1, n$1) {
				const i$1 = t$1.prev, s$1 = t$1, a = t$1.next;
				if (eu(i$1, s$1, a) >= 0) return !1;
				const o$1 = i$1.x, l$1 = s$1.x, u$1 = a.x, c$1 = i$1.y, h$1 = s$1.y, p$1 = a.y, f$1 = Math.min(o$1, l$1, u$1), d$1 = Math.min(c$1, h$1, p$1), y$1 = Math.max(o$1, l$1, u$1), m$1 = Math.max(c$1, h$1, p$1), g$1 = Kl(f$1, d$1, e$1, r$1, n$1), x$1 = Kl(y$1, m$1, e$1, r$1, n$1);
				let v$1 = t$1.prevZ, b$1 = t$1.nextZ;
				for (; v$1 && v$1.z >= g$1 && b$1 && b$1.z <= x$1;) {
					if (v$1.x >= f$1 && v$1.x <= y$1 && v$1.y >= d$1 && v$1.y <= m$1 && v$1 !== i$1 && v$1 !== a && Ql(o$1, c$1, l$1, h$1, u$1, p$1, v$1.x, v$1.y) && eu(v$1.prev, v$1, v$1.next) >= 0) return !1;
					if (v$1 = v$1.prevZ, b$1.x >= f$1 && b$1.x <= y$1 && b$1.y >= d$1 && b$1.y <= m$1 && b$1 !== i$1 && b$1 !== a && Ql(o$1, c$1, l$1, h$1, u$1, p$1, b$1.x, b$1.y) && eu(b$1.prev, b$1, b$1.next) >= 0) return !1;
					b$1 = b$1.nextZ;
				}
				for (; v$1 && v$1.z >= g$1;) {
					if (v$1.x >= f$1 && v$1.x <= y$1 && v$1.y >= d$1 && v$1.y <= m$1 && v$1 !== i$1 && v$1 !== a && Ql(o$1, c$1, l$1, h$1, u$1, p$1, v$1.x, v$1.y) && eu(v$1.prev, v$1, v$1.next) >= 0) return !1;
					v$1 = v$1.prevZ;
				}
				for (; b$1 && b$1.z <= x$1;) {
					if (b$1.x >= f$1 && b$1.x <= y$1 && b$1.y >= d$1 && b$1.y <= m$1 && b$1 !== i$1 && b$1 !== a && Ql(o$1, c$1, l$1, h$1, u$1, p$1, b$1.x, b$1.y) && eu(b$1.prev, b$1, b$1.next) >= 0) return !1;
					b$1 = b$1.nextZ;
				}
				return !0;
			}
			function Gl(t$1, e$1) {
				let r$1 = t$1;
				do {
					const n$1 = r$1.prev, i$1 = r$1.next.next;
					!ru(n$1, i$1) && nu(n$1, r$1, r$1.next, i$1) && au(n$1, i$1) && au(i$1, n$1) && (e$1.push(n$1.i, r$1.i, i$1.i), uu(r$1), uu(r$1.next), r$1 = t$1 = i$1), r$1 = r$1.next;
				} while (r$1 !== t$1);
				return $l(r$1);
			}
			function Xl(t$1, e$1, r$1, n$1, i$1, s$1) {
				let a = t$1;
				do {
					let t$2 = a.next.next;
					for (; t$2 !== a.prev;) {
						if (a.i !== t$2.i && tu(a, t$2)) {
							let o$1 = ou(a, t$2);
							a = $l(a, a.next), o$1 = $l(o$1, o$1.next), Ul(a, e$1, r$1, n$1, i$1, s$1, 0), Ul(o$1, e$1, r$1, n$1, i$1, s$1, 0);
							return;
						}
						t$2 = t$2.next;
					}
					a = a.next;
				} while (a !== t$1);
			}
			function Yl(t$1, e$1) {
				let r$1 = t$1.x - e$1.x;
				return 0 === r$1 && (r$1 = t$1.y - e$1.y, 0 === r$1) && (r$1 = (t$1.next.y - t$1.y) / (t$1.next.x - t$1.x) - (e$1.next.y - e$1.y) / (e$1.next.x - e$1.x)), r$1;
			}
			function Zl(t$1, e$1) {
				const r$1 = function(t$2, e$2) {
					let r$2 = e$2;
					const n$2 = t$2.x, i$1 = t$2.y;
					let s$1, a = -Infinity;
					if (ru(t$2, r$2)) return r$2;
					do {
						if (ru(t$2, r$2.next)) return r$2.next;
						if (i$1 <= r$2.y && i$1 >= r$2.next.y && r$2.next.y !== r$2.y) {
							const t$3 = r$2.x + (i$1 - r$2.y) * (r$2.next.x - r$2.x) / (r$2.next.y - r$2.y);
							if (t$3 <= n$2 && t$3 > a && (a = t$3, s$1 = r$2.x < r$2.next.x ? r$2 : r$2.next, t$3 === n$2)) return s$1;
						}
						r$2 = r$2.next;
					} while (r$2 !== e$2);
					if (!s$1) return null;
					const o$1 = s$1, l$1 = s$1.x, u$1 = s$1.y;
					let c$1 = Infinity;
					r$2 = s$1;
					do {
						if (n$2 >= r$2.x && r$2.x >= l$1 && n$2 !== r$2.x && Jl(i$1 < u$1 ? n$2 : a, i$1, l$1, u$1, i$1 < u$1 ? a : n$2, i$1, r$2.x, r$2.y)) {
							const e$3 = Math.abs(i$1 - r$2.y) / (n$2 - r$2.x);
							au(r$2, t$2) && (e$3 < c$1 || e$3 === c$1 && (r$2.x > s$1.x || r$2.x === s$1.x && Hl(s$1, r$2))) && (s$1 = r$2, c$1 = e$3);
						}
						r$2 = r$2.next;
					} while (r$2 !== o$1);
					return s$1;
				}(t$1, e$1);
				if (!r$1) return e$1;
				const n$1 = ou(r$1, t$1);
				return $l(n$1, n$1.next), $l(r$1, r$1.next);
			}
			function Hl(t$1, e$1) {
				return eu(t$1.prev, t$1, e$1.prev) < 0 && eu(e$1.next, t$1, t$1.next) < 0;
			}
			function Kl(t$1, e$1, r$1, n$1, i$1) {
				return (t$1 = 1431655765 & ((t$1 = 858993459 & ((t$1 = 252645135 & ((t$1 = 16711935 & ((t$1 = (t$1 - r$1) * i$1 | 0) | t$1 << 8)) | t$1 << 4)) | t$1 << 2)) | t$1 << 1)) | (e$1 = 1431655765 & ((e$1 = 858993459 & ((e$1 = 252645135 & ((e$1 = 16711935 & ((e$1 = (e$1 - n$1) * i$1 | 0) | e$1 << 8)) | e$1 << 4)) | e$1 << 2)) | e$1 << 1)) << 1;
			}
			function Wl(t$1) {
				let e$1 = t$1, r$1 = t$1;
				do
					(e$1.x < r$1.x || e$1.x === r$1.x && e$1.y < r$1.y) && (r$1 = e$1), e$1 = e$1.next;
				while (e$1 !== t$1);
				return r$1;
			}
			function Jl(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1) {
				return (i$1 - a) * (e$1 - o$1) >= (t$1 - a) * (s$1 - o$1) && (t$1 - a) * (n$1 - o$1) >= (r$1 - a) * (e$1 - o$1) && (r$1 - a) * (s$1 - o$1) >= (i$1 - a) * (n$1 - o$1);
			}
			function Ql(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1) {
				return !(t$1 === a && e$1 === o$1) && Jl(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1);
			}
			function tu(t$1, e$1) {
				return t$1.next.i !== e$1.i && t$1.prev.i !== e$1.i && !function(t$2, e$2) {
					let r$1 = t$2;
					do {
						if (r$1.i !== t$2.i && r$1.next.i !== t$2.i && r$1.i !== e$2.i && r$1.next.i !== e$2.i && nu(r$1, r$1.next, t$2, e$2)) return !0;
						r$1 = r$1.next;
					} while (r$1 !== t$2);
					return !1;
				}(t$1, e$1) && (au(t$1, e$1) && au(e$1, t$1) && function(t$2, e$2) {
					let r$1 = t$2, n$1 = !1;
					const i$1 = (t$2.x + e$2.x) / 2, s$1 = (t$2.y + e$2.y) / 2;
					do
						r$1.y > s$1 != r$1.next.y > s$1 && r$1.next.y !== r$1.y && i$1 < (r$1.next.x - r$1.x) * (s$1 - r$1.y) / (r$1.next.y - r$1.y) + r$1.x && (n$1 = !n$1), r$1 = r$1.next;
					while (r$1 !== t$2);
					return n$1;
				}(t$1, e$1) && (eu(t$1.prev, t$1, e$1.prev) || eu(t$1, e$1.prev, e$1)) || ru(t$1, e$1) && eu(t$1.prev, t$1, t$1.next) > 0 && eu(e$1.prev, e$1, e$1.next) > 0);
			}
			function eu(t$1, e$1, r$1) {
				return (e$1.y - t$1.y) * (r$1.x - e$1.x) - (e$1.x - t$1.x) * (r$1.y - e$1.y);
			}
			function ru(t$1, e$1) {
				return t$1.x === e$1.x && t$1.y === e$1.y;
			}
			function nu(t$1, e$1, r$1, n$1) {
				const i$1 = su(eu(t$1, e$1, r$1)), s$1 = su(eu(t$1, e$1, n$1)), a = su(eu(r$1, n$1, t$1)), o$1 = su(eu(r$1, n$1, e$1));
				return i$1 !== s$1 && a !== o$1 || !(0 !== i$1 || !iu(t$1, r$1, e$1)) || !(0 !== s$1 || !iu(t$1, n$1, e$1)) || !(0 !== a || !iu(r$1, t$1, n$1)) || !(0 !== o$1 || !iu(r$1, e$1, n$1));
			}
			function iu(t$1, e$1, r$1) {
				return e$1.x <= Math.max(t$1.x, r$1.x) && e$1.x >= Math.min(t$1.x, r$1.x) && e$1.y <= Math.max(t$1.y, r$1.y) && e$1.y >= Math.min(t$1.y, r$1.y);
			}
			function su(t$1) {
				return t$1 > 0 ? 1 : t$1 < 0 ? -1 : 0;
			}
			function au(t$1, e$1) {
				return eu(t$1.prev, t$1, t$1.next) < 0 ? eu(t$1, e$1, t$1.next) >= 0 && eu(t$1, t$1.prev, e$1) >= 0 : eu(t$1, e$1, t$1.prev) < 0 || eu(t$1, t$1.next, e$1) < 0;
			}
			function ou(t$1, e$1) {
				const r$1 = cu(t$1.i, t$1.x, t$1.y), n$1 = cu(e$1.i, e$1.x, e$1.y), i$1 = t$1.next, s$1 = e$1.prev;
				return t$1.next = e$1, e$1.prev = t$1, r$1.next = i$1, i$1.prev = r$1, n$1.next = r$1, r$1.prev = n$1, s$1.next = n$1, n$1.prev = s$1, n$1;
			}
			function lu(t$1, e$1, r$1, n$1) {
				const i$1 = cu(t$1, e$1, r$1);
				return n$1 ? (i$1.next = n$1.next, i$1.prev = n$1, n$1.next.prev = i$1, n$1.next = i$1) : (i$1.prev = i$1, i$1.next = i$1), i$1;
			}
			function uu(t$1) {
				t$1.next.prev = t$1.prev, t$1.prev.next = t$1.next, t$1.prevZ && (t$1.prevZ.nextZ = t$1.nextZ), t$1.nextZ && (t$1.nextZ.prevZ = t$1.prevZ);
			}
			function cu(t$1, e$1, r$1) {
				return {
					i: t$1,
					x: e$1,
					y: r$1,
					prev: null,
					next: null,
					z: 0,
					prevZ: null,
					nextZ: null,
					steiner: !1
				};
			}
			class hu {
				constructor(t$1, e$1) {
					if (e$1 > t$1) throw new Error("Min granularity must not be greater than base granularity.");
					this._baseZoomGranularity = t$1, this._minGranularity = e$1;
				}
				getGranularityForZoomLevel(t$1) {
					return Math.max(Math.floor(this._baseZoomGranularity / (1 << t$1)), this._minGranularity, 1);
				}
			}
			class pu {
				constructor(t$1) {
					this.fill = t$1.fill, this.line = t$1.line, this.tile = t$1.tile, this.stencil = t$1.stencil, this.circle = t$1.circle;
				}
			}
			pu.noSubdivision = new pu({
				fill: new hu(0, 0),
				line: new hu(0, 0),
				tile: new hu(0, 0),
				stencil: new hu(0, 0),
				circle: 1
			}), ps("SubdivisionGranularityExpression", hu), ps("SubdivisionGranularitySetting", pu);
			const fu = -32768, du = 32767;
			class yu {
				constructor(t$1, e$1) {
					this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = !1, this._granularity = t$1, this._granularityCellSize = M / t$1, this._canonical = e$1;
				}
				_getKey(t$1, e$1) {
					return (t$1 += 32768) << 16 | e$1 + 32768;
				}
				_vertexToIndex(t$1, e$1) {
					if (t$1 < -32768 || e$1 < -32768 || t$1 > 32767 || e$1 > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
					const r$1 = 0 | Math.round(t$1), n$1 = 0 | Math.round(e$1), i$1 = this._getKey(r$1, n$1);
					if (this._vertexDictionary.has(i$1)) return this._vertexDictionary.get(i$1);
					const s$1 = this._vertexBuffer.length / 2;
					return this._vertexDictionary.set(i$1, s$1), this._vertexBuffer.push(r$1, n$1), s$1;
				}
				_subdivideTrianglesScanline(t$1) {
					if (this._granularity < 2) return function(t$2, e$2) {
						const r$2 = [];
						for (let n$1 = 0; n$1 < e$2.length; n$1 += 3) {
							const i$1 = e$2[n$1], s$1 = e$2[n$1 + 1], a = e$2[n$1 + 2], o$1 = t$2[2 * i$1], l$1 = t$2[2 * i$1 + 1];
							(t$2[2 * s$1] - o$1) * (t$2[2 * a + 1] - l$1) - (t$2[2 * s$1 + 1] - l$1) * (t$2[2 * a] - o$1) > 0 ? (r$2.push(i$1), r$2.push(a), r$2.push(s$1)) : (r$2.push(i$1), r$2.push(s$1), r$2.push(a));
						}
						return r$2;
					}(this._vertexBuffer, t$1);
					const e$1 = [], r$1 = t$1.length;
					for (let n$1 = 0; n$1 < r$1; n$1 += 3) {
						const r$2 = [
							t$1[n$1 + 0],
							t$1[n$1 + 1],
							t$1[n$1 + 2]
						], i$1 = [
							this._vertexBuffer[2 * t$1[n$1 + 0] + 0],
							this._vertexBuffer[2 * t$1[n$1 + 0] + 1],
							this._vertexBuffer[2 * t$1[n$1 + 1] + 0],
							this._vertexBuffer[2 * t$1[n$1 + 1] + 1],
							this._vertexBuffer[2 * t$1[n$1 + 2] + 0],
							this._vertexBuffer[2 * t$1[n$1 + 2] + 1]
						];
						let s$1 = Infinity, a = Infinity, o$1 = -Infinity, l$1 = -Infinity;
						for (let t$2 = 0; t$2 < 3; t$2++) {
							const e$2 = i$1[2 * t$2], r$3 = i$1[2 * t$2 + 1];
							s$1 = Math.min(s$1, e$2), o$1 = Math.max(o$1, e$2), a = Math.min(a, r$3), l$1 = Math.max(l$1, r$3);
						}
						if (s$1 === o$1 || a === l$1) continue;
						const u$1 = Math.floor(s$1 / this._granularityCellSize), c$1 = Math.ceil(o$1 / this._granularityCellSize), h$1 = Math.floor(a / this._granularityCellSize), p$1 = Math.ceil(l$1 / this._granularityCellSize);
						if (u$1 !== c$1 || h$1 !== p$1) for (let t$2 = h$1; t$2 < p$1; t$2++) {
							const n$2 = this._scanlineGenerateVertexRingForCellRow(t$2, i$1, r$2);
							xu(this._vertexBuffer, n$2, e$1);
						}
						else e$1.push(...r$2);
					}
					return e$1;
				}
				_scanlineGenerateVertexRingForCellRow(t$1, e$1, r$1) {
					const n$1 = t$1 * this._granularityCellSize, i$1 = n$1 + this._granularityCellSize, s$1 = [];
					for (let t$2 = 0; t$2 < 3; t$2++) {
						const a = e$1[2 * t$2], o$1 = e$1[2 * t$2 + 1], l$1 = e$1[2 * (t$2 + 1) % 6], u$1 = e$1[(2 * (t$2 + 1) + 1) % 6], c$1 = e$1[2 * (t$2 + 2) % 6], h$1 = e$1[(2 * (t$2 + 2) + 1) % 6], p$1 = l$1 - a, f$1 = u$1 - o$1, d$1 = 0 === p$1, y$1 = 0 === f$1, m$1 = (n$1 - o$1) / f$1, g$1 = (i$1 - o$1) / f$1, x$1 = Math.min(m$1, g$1), v$1 = Math.max(m$1, g$1);
						if (!y$1 && (x$1 >= 1 || v$1 <= 0) || y$1 && (o$1 < n$1 || o$1 > i$1)) {
							u$1 >= n$1 && u$1 <= i$1 && s$1.push(r$1[(t$2 + 1) % 3]);
							continue;
						}
						!y$1 && x$1 > 0 && s$1.push(this._vertexToIndex(a + p$1 * x$1, o$1 + f$1 * x$1));
						const b$1 = a + p$1 * Math.max(x$1, 0), w$1 = a + p$1 * Math.min(v$1, 1);
						d$1 || this._generateIntraEdgeVertices(s$1, a, o$1, l$1, u$1, b$1, w$1), !y$1 && v$1 < 1 && s$1.push(this._vertexToIndex(a + p$1 * v$1, o$1 + f$1 * v$1)), (y$1 || u$1 >= n$1 && u$1 <= i$1) && s$1.push(r$1[(t$2 + 1) % 3]), !y$1 && (u$1 <= n$1 || u$1 >= i$1) && this._generateInterEdgeVertices(s$1, a, o$1, l$1, u$1, c$1, h$1, w$1, n$1, i$1);
					}
					return s$1;
				}
				_generateIntraEdgeVertices(t$1, e$1, r$1, n$1, i$1, s$1, a) {
					const o$1 = n$1 - e$1, l$1 = i$1 - r$1, u$1 = 0 === l$1, c$1 = u$1 ? Math.min(e$1, n$1) : Math.min(s$1, a), h$1 = u$1 ? Math.max(e$1, n$1) : Math.max(s$1, a), p$1 = Math.floor(c$1 / this._granularityCellSize) + 1, f$1 = Math.ceil(h$1 / this._granularityCellSize) - 1;
					if (u$1 ? e$1 < n$1 : s$1 < a) for (let n$2 = p$1; n$2 <= f$1; n$2++) {
						const i$2 = n$2 * this._granularityCellSize;
						t$1.push(this._vertexToIndex(i$2, r$1 + l$1 * (i$2 - e$1) / o$1));
					}
					else for (let n$2 = f$1; n$2 >= p$1; n$2--) {
						const i$2 = n$2 * this._granularityCellSize;
						t$1.push(this._vertexToIndex(i$2, r$1 + l$1 * (i$2 - e$1) / o$1));
					}
				}
				_generateInterEdgeVertices(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1) {
					const c$1 = i$1 - r$1, h$1 = s$1 - n$1, p$1 = a - i$1, f$1 = (l$1 - i$1) / p$1, d$1 = (u$1 - i$1) / p$1, y$1 = Math.min(f$1, d$1), m$1 = Math.max(f$1, d$1), g$1 = n$1 + h$1 * y$1;
					let x$1 = Math.floor(Math.min(g$1, o$1) / this._granularityCellSize) + 1, v$1 = Math.ceil(Math.max(g$1, o$1) / this._granularityCellSize) - 1, b$1 = o$1 < g$1;
					const w$1 = 0 === p$1;
					if (w$1 && (a === l$1 || a === u$1)) return;
					if (w$1 || y$1 >= 1 || m$1 <= 0) {
						const t$2 = r$1 - a, n$2 = s$1 + (e$1 - s$1) * Math.min((l$1 - a) / t$2, (u$1 - a) / t$2);
						x$1 = Math.floor(Math.min(n$2, o$1) / this._granularityCellSize) + 1, v$1 = Math.ceil(Math.max(n$2, o$1) / this._granularityCellSize) - 1, b$1 = o$1 < n$2;
					}
					const _$1 = c$1 > 0 ? u$1 : l$1;
					if (b$1) for (let e$2 = x$1; e$2 <= v$1; e$2++) t$1.push(this._vertexToIndex(e$2 * this._granularityCellSize, _$1));
					else for (let e$2 = v$1; e$2 >= x$1; e$2--) t$1.push(this._vertexToIndex(e$2 * this._granularityCellSize, _$1));
				}
				_generateOutline(t$1) {
					const e$1 = [];
					for (const r$1 of t$1) {
						const t$2 = gu(r$1, this._granularity, !0), n$1 = this._pointArrayToIndices(t$2), i$1 = [];
						for (let t$3 = 1; t$3 < n$1.length; t$3++) i$1.push(n$1[t$3 - 1]), i$1.push(n$1[t$3]);
						e$1.push(i$1);
					}
					return e$1;
				}
				_handlePoles(t$1) {
					let e$1 = !1, r$1 = !1;
					this._canonical && (0 === this._canonical.y && (e$1 = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (r$1 = !0)), (e$1 || r$1) && this._fillPoles(t$1, e$1, r$1);
				}
				_ensureNoPoleVertices() {
					const t$1 = this._vertexBuffer;
					for (let e$1 = 0; e$1 < t$1.length; e$1 += 2) {
						const r$1 = t$1[e$1 + 1];
						r$1 === fu && (t$1[e$1 + 1] = -32767), r$1 === du && (t$1[e$1 + 1] = 32766);
					}
				}
				_generatePoleQuad(t$1, e$1, r$1, n$1, i$1, s$1) {
					n$1 > i$1 != (s$1 === fu) ? (t$1.push(e$1), t$1.push(r$1), t$1.push(this._vertexToIndex(n$1, s$1)), t$1.push(r$1), t$1.push(this._vertexToIndex(i$1, s$1)), t$1.push(this._vertexToIndex(n$1, s$1))) : (t$1.push(r$1), t$1.push(e$1), t$1.push(this._vertexToIndex(n$1, s$1)), t$1.push(this._vertexToIndex(i$1, s$1)), t$1.push(r$1), t$1.push(this._vertexToIndex(n$1, s$1)));
				}
				_fillPoles(t$1, e$1, r$1) {
					const n$1 = this._vertexBuffer, i$1 = M, s$1 = t$1.length;
					for (let a = 2; a < s$1; a += 3) {
						const s$2 = t$1[a - 2], o$1 = t$1[a - 1], l$1 = t$1[a], u$1 = n$1[2 * s$2], c$1 = n$1[2 * s$2 + 1], h$1 = n$1[2 * o$1], p$1 = n$1[2 * o$1 + 1], f$1 = n$1[2 * l$1], d$1 = n$1[2 * l$1 + 1];
						e$1 && (0 === c$1 && 0 === p$1 && this._generatePoleQuad(t$1, s$2, o$1, u$1, h$1, fu), 0 === p$1 && 0 === d$1 && this._generatePoleQuad(t$1, o$1, l$1, h$1, f$1, fu), 0 === d$1 && 0 === c$1 && this._generatePoleQuad(t$1, l$1, s$2, f$1, u$1, fu)), r$1 && (c$1 === i$1 && p$1 === i$1 && this._generatePoleQuad(t$1, s$2, o$1, u$1, h$1, du), p$1 === i$1 && d$1 === i$1 && this._generatePoleQuad(t$1, o$1, l$1, h$1, f$1, du), d$1 === i$1 && c$1 === i$1 && this._generatePoleQuad(t$1, l$1, s$2, f$1, u$1, du));
					}
				}
				_initializeVertices(t$1) {
					for (let e$1 = 0; e$1 < t$1.length; e$1 += 2) this._vertexToIndex(t$1[e$1], t$1[e$1 + 1]);
				}
				subdividePolygonInternal(t$1, e$1) {
					if (this._used) throw new Error("Subdivision: multiple use not allowed.");
					this._used = !0;
					const { flattened: r$1, holeIndices: n$1 } = function(t$2) {
						const e$2 = [], r$2 = [];
						for (const n$2 of t$2) if (0 !== n$2.length) {
							n$2 !== t$2[0] && e$2.push(r$2.length / 2);
							for (let t$3 = 0; t$3 < n$2.length; t$3++) r$2.push(n$2[t$3].x), r$2.push(n$2[t$3].y);
						}
						return {
							flattened: r$2,
							holeIndices: e$2
						};
					}(t$1);
					let i$1;
					this._initializeVertices(r$1);
					try {
						const t$2 = function(t$3, e$3, r$2 = 2) {
							const n$2 = e$3 && e$3.length, i$2 = n$2 ? e$3[0] * r$2 : t$3.length;
							let s$2 = Nl(t$3, 0, i$2, r$2, !0);
							const a = [];
							if (!s$2 || s$2.next === s$2.prev) return a;
							let o$1, l$1, u$1;
							if (n$2 && (s$2 = function(t$4, e$4, r$3, n$3) {
								const i$3 = [];
								for (let r$4 = 0, s$3 = e$4.length; r$4 < s$3; r$4++) {
									const a$1 = Nl(t$4, e$4[r$4] * n$3, r$4 < s$3 - 1 ? e$4[r$4 + 1] * n$3 : t$4.length, n$3, !1);
									a$1 === a$1.next && (a$1.steiner = !0), i$3.push(Wl(a$1));
								}
								i$3.sort(Yl);
								for (let t$5 = 0; t$5 < i$3.length; t$5++) r$3 = Zl(i$3[t$5], r$3);
								return r$3;
							}(t$3, e$3, s$2, r$2)), t$3.length > 80 * r$2) {
								o$1 = t$3[0], l$1 = t$3[1];
								let e$4 = o$1, n$3 = l$1;
								for (let s$3 = r$2; s$3 < i$2; s$3 += r$2) {
									const r$3 = t$3[s$3], i$3 = t$3[s$3 + 1];
									r$3 < o$1 && (o$1 = r$3), i$3 < l$1 && (l$1 = i$3), r$3 > e$4 && (e$4 = r$3), i$3 > n$3 && (n$3 = i$3);
								}
								u$1 = Math.max(e$4 - o$1, n$3 - l$1), u$1 = 0 !== u$1 ? 32767 / u$1 : 0;
							}
							return Ul(s$2, a, r$2, o$1, l$1, u$1, 0), a;
						}(r$1, n$1), e$2 = this._convertIndices(r$1, t$2);
						i$1 = this._subdivideTrianglesScanline(e$2);
					} catch (t$2) {
						console.error(t$2);
					}
					let s$1 = [];
					return e$1 && (s$1 = this._generateOutline(t$1)), this._ensureNoPoleVertices(), this._handlePoles(i$1), {
						verticesFlattened: this._vertexBuffer,
						indicesTriangles: i$1,
						indicesLineList: s$1
					};
				}
				_convertIndices(t$1, e$1) {
					const r$1 = [];
					for (let n$1 = 0; n$1 < e$1.length; n$1++) r$1.push(this._vertexToIndex(t$1[2 * e$1[n$1]], t$1[2 * e$1[n$1] + 1]));
					return r$1;
				}
				_pointArrayToIndices(t$1) {
					const e$1 = [];
					for (let r$1 = 0; r$1 < t$1.length; r$1++) {
						const n$1 = t$1[r$1];
						e$1.push(this._vertexToIndex(n$1.x, n$1.y));
					}
					return e$1;
				}
			}
			function mu(t$1, e$1, r$1, n$1 = !0) {
				return new yu(r$1, e$1).subdividePolygonInternal(t$1, n$1);
			}
			function gu(t$1, e$1, n$1 = !1) {
				if (!t$1 || t$1.length < 1) return [];
				if (t$1.length < 2) return [];
				const i$1 = t$1[0], s$1 = t$1[t$1.length - 1], a = n$1 && (i$1.x !== s$1.x || i$1.y !== s$1.y);
				if (e$1 < 2) return a ? [...t$1, t$1[0]] : [...t$1];
				const o$1 = Math.floor(M / e$1), l$1 = [];
				l$1.push(new r(t$1[0].x, t$1[0].y));
				const u$1 = t$1.length, c$1 = a ? u$1 : u$1 - 1;
				for (let e$2 = 0; e$2 < c$1; e$2++) {
					const n$2 = t$1[e$2], i$2 = e$2 < u$1 - 1 ? t$1[e$2 + 1] : t$1[0], s$2 = n$2.x, a$1 = n$2.y, c$2 = i$2.x, h$1 = i$2.y, p$1 = s$2 !== c$2, f$1 = a$1 !== h$1;
					if (!p$1 && !f$1) continue;
					const d$1 = c$2 - s$2, y$1 = h$1 - a$1, m$1 = Math.abs(d$1), g$1 = Math.abs(y$1);
					let x$1 = s$2, v$1 = a$1;
					for (;;) {
						const t$2 = d$1 > 0 ? (Math.floor(x$1 / o$1) + 1) * o$1 : (Math.ceil(x$1 / o$1) - 1) * o$1, e$3 = y$1 > 0 ? (Math.floor(v$1 / o$1) + 1) * o$1 : (Math.ceil(v$1 / o$1) - 1) * o$1, n$3 = Math.abs(x$1 - t$2), i$3 = Math.abs(v$1 - e$3), s$3 = Math.abs(x$1 - c$2), a$2 = Math.abs(v$1 - h$1), u$2 = p$1 ? n$3 / m$1 : Number.POSITIVE_INFINITY, b$2 = f$1 ? i$3 / g$1 : Number.POSITIVE_INFINITY;
						if ((s$3 <= n$3 || !p$1) && (a$2 <= i$3 || !f$1)) break;
						if (u$2 < b$2 && p$1 || !f$1) {
							x$1 = t$2, v$1 += y$1 * u$2;
							const e$4 = new r(x$1, Math.round(v$1));
							l$1[l$1.length - 1].x === e$4.x && l$1[l$1.length - 1].y === e$4.y || l$1.push(e$4);
						} else {
							x$1 += d$1 * b$2, v$1 = e$3;
							const t$3 = new r(Math.round(x$1), v$1);
							l$1[l$1.length - 1].x === t$3.x && l$1[l$1.length - 1].y === t$3.y || l$1.push(t$3);
						}
					}
					const b$1 = new r(c$2, h$1);
					l$1[l$1.length - 1].x === b$1.x && l$1[l$1.length - 1].y === b$1.y || l$1.push(b$1);
				}
				return l$1;
			}
			function xu(t$1, e$1, r$1) {
				if (0 === e$1.length) throw new Error("Subdivision vertex ring is empty.");
				let n$1 = 0, i$1 = t$1[2 * e$1[0]];
				for (let r$2 = 1; r$2 < e$1.length; r$2++) {
					const s$2 = t$1[2 * e$1[r$2]];
					s$2 < i$1 && (i$1 = s$2, n$1 = r$2);
				}
				const s$1 = e$1.length;
				let a = n$1, o$1 = (a + 1) % s$1;
				for (;;) {
					const n$2 = a - 1 >= 0 ? a - 1 : s$1 - 1, i$2 = (o$1 + 1) % s$1, l$1 = t$1[2 * e$1[n$2]], u$1 = t$1[2 * e$1[i$2]], c$1 = t$1[2 * e$1[a]], h$1 = t$1[2 * e$1[a] + 1], p$1 = t$1[2 * e$1[o$1] + 1];
					let f$1 = !1;
					if (l$1 < u$1) f$1 = !0;
					else if (l$1 > u$1) f$1 = !1;
					else {
						const r$2 = p$1 - h$1, s$2 = -(t$1[2 * e$1[o$1]] - c$1), a$1 = h$1 < p$1 ? 1 : -1;
						((l$1 - c$1) * r$2 + (t$1[2 * e$1[n$2] + 1] - h$1) * s$2) * a$1 > ((u$1 - c$1) * r$2 + (t$1[2 * e$1[i$2] + 1] - h$1) * s$2) * a$1 && (f$1 = !0);
					}
					if (f$1) {
						const t$2 = e$1[n$2], i$3 = e$1[a], l$2 = e$1[o$1];
						t$2 !== i$3 && t$2 !== l$2 && i$3 !== l$2 && r$1.push(l$2, i$3, t$2), a--, a < 0 && (a = s$1 - 1);
					} else {
						const t$2 = e$1[i$2], n$3 = e$1[a], l$2 = e$1[o$1];
						t$2 !== n$3 && t$2 !== l$2 && n$3 !== l$2 && r$1.push(l$2, n$3, t$2), o$1++, o$1 >= s$1 && (o$1 = 0);
					}
					if (n$2 === i$2) break;
				}
			}
			function vu(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1) {
				const u$1 = i$1.length / 2, c$1 = a && o$1 && l$1;
				if (u$1 < io.MAX_VERTEX_ARRAY_LENGTH) {
					const h$1 = e$1.prepareSegment(u$1, r$1, n$1), p$1 = h$1.vertexLength;
					for (let t$2 = 0; t$2 < s$1.length; t$2 += 3) n$1.emplaceBack(p$1 + s$1[t$2], p$1 + s$1[t$2 + 1], p$1 + s$1[t$2 + 2]);
					let f$1, d$1;
					h$1.vertexLength += u$1, h$1.primitiveLength += s$1.length / 3, c$1 && (d$1 = a.prepareSegment(u$1, r$1, o$1), f$1 = d$1.vertexLength, d$1.vertexLength += u$1);
					for (let e$2 = 0; e$2 < i$1.length; e$2 += 2) t$1(i$1[e$2], i$1[e$2 + 1]);
					if (c$1) for (let t$2 = 0; t$2 < l$1.length; t$2++) {
						const e$2 = l$1[t$2];
						for (let t$3 = 1; t$3 < e$2.length; t$3 += 2) o$1.emplaceBack(f$1 + e$2[t$3 - 1], f$1 + e$2[t$3]);
						d$1.primitiveLength += e$2.length / 2;
					}
				} else (function(t$2, e$2, r$2, n$2, i$2, s$2) {
					const a$1 = [];
					for (let t$3 = 0; t$3 < n$2.length / 2; t$3++) a$1.push(-1);
					const o$2 = { count: 0 };
					let l$2 = 0, u$2 = t$2.getOrCreateLatestSegment(e$2, r$2), c$2 = u$2.vertexLength;
					for (let h$1 = 2; h$1 < i$2.length; h$1 += 3) {
						const p$1 = i$2[h$1 - 2], f$1 = i$2[h$1 - 1], d$1 = i$2[h$1];
						let y$1 = a$1[p$1] < l$2, m$1 = a$1[f$1] < l$2, g$1 = a$1[d$1] < l$2;
						u$2.vertexLength + ((y$1 ? 1 : 0) + (m$1 ? 1 : 0) + (g$1 ? 1 : 0)) > io.MAX_VERTEX_ARRAY_LENGTH && (u$2 = t$2.createNewSegment(e$2, r$2), l$2 = o$2.count, y$1 = !0, m$1 = !0, g$1 = !0, c$2 = 0);
						const x$1 = bu(a$1, n$2, s$2, o$2, p$1, y$1, u$2), v$1 = bu(a$1, n$2, s$2, o$2, f$1, m$1, u$2), b$1 = bu(a$1, n$2, s$2, o$2, d$1, g$1, u$2);
						r$2.emplaceBack(c$2 + x$1 - l$2, c$2 + v$1 - l$2, c$2 + b$1 - l$2), u$2.primitiveLength++;
					}
				})(e$1, r$1, n$1, i$1, s$1, t$1), c$1 && function(t$2, e$2, r$2, n$2, i$2, s$2) {
					const a$1 = [];
					for (let t$3 = 0; t$3 < n$2.length / 2; t$3++) a$1.push(-1);
					const o$2 = { count: 0 };
					let l$2 = 0, u$2 = t$2.getOrCreateLatestSegment(e$2, r$2), c$2 = u$2.vertexLength;
					for (let h$1 = 0; h$1 < i$2.length; h$1++) {
						const p$1 = i$2[h$1];
						for (let f$1 = 1; f$1 < i$2[h$1].length; f$1 += 2) {
							const i$3 = p$1[f$1 - 1], h$2 = p$1[f$1];
							let d$1 = a$1[i$3] < l$2, y$1 = a$1[h$2] < l$2;
							u$2.vertexLength + ((d$1 ? 1 : 0) + (y$1 ? 1 : 0)) > io.MAX_VERTEX_ARRAY_LENGTH && (u$2 = t$2.createNewSegment(e$2, r$2), l$2 = o$2.count, d$1 = !0, y$1 = !0, c$2 = 0);
							const m$1 = bu(a$1, n$2, s$2, o$2, i$3, d$1, u$2), g$1 = bu(a$1, n$2, s$2, o$2, h$2, y$1, u$2);
							r$2.emplaceBack(c$2 + m$1 - l$2, c$2 + g$1 - l$2), u$2.primitiveLength++;
						}
					}
				}(a, r$1, o$1, i$1, l$1, t$1), e$1.forceNewSegmentOnNextPrepare(), a?.forceNewSegmentOnNextPrepare();
			}
			function bu(t$1, e$1, r$1, n$1, i$1, s$1, a) {
				if (s$1) {
					const s$2 = n$1.count;
					return r$1(e$1[2 * i$1], e$1[2 * i$1 + 1]), t$1[i$1] = n$1.count, n$1.count++, a.vertexLength++, s$2;
				}
				return t$1[i$1];
			}
			class wu {
				constructor(t$1) {
					this.zoom = t$1.zoom, this.overscaling = t$1.overscaling, this.layers = t$1.layers, this.layerIds = this.layers.map(((t$2) => t$2.id)), this.index = t$1.index, this.hasDependencies = !1, this.patternFeatures = [], this.layoutVertexArray = new qa(), this.indexArray = new to(), this.indexArray2 = new eo(), this.programConfigurations = new Vo(t$1.layers, t$1.zoom), this.segments = new io(), this.segments2 = new io(), this.stateDependentLayerIds = this.layers.filter(((t$2) => t$2.isStateDependent())).map(((t$2) => t$2.id));
				}
				populate(t$1, e$1, r$1) {
					this.hasDependencies = Ol("fill", this.layers, e$1);
					const n$1 = this.layers[0].layout.get("fill-sort-key"), i$1 = !n$1.isConstant(), s$1 = [];
					for (const { feature: a, id: o$1, index: l$1, sourceLayerIndex: u$1 } of t$1) {
						const t$2 = this.layers[0]._featureFilter.needGeometry, c$1 = $o(a, t$2);
						if (!this.layers[0]._featureFilter.filter(new Ps(this.zoom), c$1, r$1)) continue;
						const h$1 = i$1 ? n$1.evaluate(c$1, {}, r$1, e$1.availableImages) : void 0, p$1 = {
							id: o$1,
							properties: a.properties,
							type: a.type,
							sourceLayerIndex: u$1,
							index: l$1,
							geometry: t$2 ? c$1.geometry : No(a),
							patterns: {},
							sortKey: h$1
						};
						s$1.push(p$1);
					}
					i$1 && s$1.sort(((t$2, e$2) => t$2.sortKey - e$2.sortKey));
					for (const n$2 of s$1) {
						const { geometry: i$2, index: s$2, sourceLayerIndex: a } = n$2;
						if (this.hasDependencies) {
							const t$2 = Rl("fill", this.layers, n$2, { zoom: this.zoom }, e$1);
							this.patternFeatures.push(t$2);
						} else this.addFeature(n$2, i$2, s$2, r$1, {}, e$1.subdivisionGranularity);
						e$1.featureIndex.insert(t$1[s$2].feature, i$2, s$2, a, this.index);
					}
				}
				update(t$1, e$1, r$1) {
					this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t$1, e$1, this.stateDependentLayers, { imagePositions: r$1 });
				}
				addFeatures(t$1, e$1, r$1) {
					for (const n$1 of this.patternFeatures) this.addFeature(n$1, n$1.geometry, n$1.index, e$1, r$1, t$1.subdivisionGranularity);
				}
				isEmpty() {
					return 0 === this.layoutVertexArray.length;
				}
				uploadPending() {
					return !this.uploaded || this.programConfigurations.needsUpload;
				}
				upload(t$1) {
					this.uploaded || (this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, Ll), this.indexBuffer = t$1.createIndexBuffer(this.indexArray), this.indexBuffer2 = t$1.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t$1), this.uploaded = !0;
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
				}
				addFeature(t$1, e$1, r$1, n$1, i$1, s$1) {
					for (const t$2 of tn(e$1, 500)) {
						const e$2 = mu(t$2, n$1, s$1.fill.getGranularityForZoomLevel(n$1.z)), r$2 = this.layoutVertexArray;
						vu(((t$3, e$3) => {
							r$2.emplaceBack(t$3, e$3);
						}), this.segments, this.layoutVertexArray, this.indexArray, e$2.verticesFlattened, e$2.indicesTriangles, this.segments2, this.indexArray2, e$2.indicesLineList);
					}
					this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t$1, r$1, {
						imagePositions: i$1,
						canonical: n$1
					});
				}
			}
			let _u, Su;
			ps("FillBucket", wu, { omit: ["layers", "patternFeatures"] });
			var Au = {
				get paint() {
					return Su = Su || new Hs({
						"fill-antialias": new js(vt.paint_fill["fill-antialias"]),
						"fill-opacity": new Gs(vt.paint_fill["fill-opacity"]),
						"fill-color": new Gs(vt.paint_fill["fill-color"]),
						"fill-outline-color": new Gs(vt.paint_fill["fill-outline-color"]),
						"fill-translate": new js(vt.paint_fill["fill-translate"]),
						"fill-translate-anchor": new js(vt.paint_fill["fill-translate-anchor"]),
						"fill-pattern": new Xs(vt.paint_fill["fill-pattern"])
					});
				},
				get layout() {
					return _u = _u || new Hs({ "fill-sort-key": new Gs(vt.layout_fill["fill-sort-key"]) });
				}
			};
			class ku extends Ks {
				constructor(t$1, e$1) {
					super(t$1, Au, e$1);
				}
				recalculate(t$1, e$1) {
					super.recalculate(t$1, e$1);
					const r$1 = this.paint._values["fill-outline-color"];
					"constant" === r$1.value.kind && void 0 === r$1.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
				}
				createBucket(t$1) {
					return new wu(t$1);
				}
				queryRadius() {
					return nl(this.paint.get("fill-translate"));
				}
				queryIntersectsFeature({ queryGeometry: t$1, geometry: e$1, transform: r$1, pixelsToTileUnits: n$1 }) {
					return Yo(il(t$1, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -r$1.bearingInRadians, n$1), e$1);
				}
				isTileClipped() {
					return !0;
				}
			}
			const Eu = na([{
				name: "a_pos",
				components: 2,
				type: "Int16"
			}, {
				name: "a_normal_ed",
				components: 4,
				type: "Int16"
			}], 4), Tu = na([{
				name: "a_centroid",
				components: 2,
				type: "Int16"
			}], 4), { members: Iu } = Eu;
			class Mu {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.properties = {}, this.extent = r$1, this.type = 0, this.id = void 0, this._pbf = t$1, this._geometry = -1, this._keys = n$1, this._values = i$1, t$1.readFields(Fu, this, e$1);
				}
				loadGeometry() {
					const t$1 = this._pbf;
					t$1.pos = this._geometry;
					const e$1 = t$1.readVarint() + t$1.pos, n$1 = [];
					let i$1, s$1 = 1, a = 0, o$1 = 0, l$1 = 0;
					for (; t$1.pos < e$1;) {
						if (a <= 0) {
							const e$2 = t$1.readVarint();
							s$1 = 7 & e$2, a = e$2 >> 3;
						}
						if (a--, 1 === s$1 || 2 === s$1) o$1 += t$1.readSVarint(), l$1 += t$1.readSVarint(), 1 === s$1 && (i$1 && n$1.push(i$1), i$1 = []), i$1 && i$1.push(new r(o$1, l$1));
						else {
							if (7 !== s$1) throw new Error(`unknown command ${s$1}`);
							i$1 && i$1.push(i$1[0].clone());
						}
					}
					return i$1 && n$1.push(i$1), n$1;
				}
				bbox() {
					const t$1 = this._pbf;
					t$1.pos = this._geometry;
					const e$1 = t$1.readVarint() + t$1.pos;
					let r$1 = 1, n$1 = 0, i$1 = 0, s$1 = 0, a = Infinity, o$1 = -Infinity, l$1 = Infinity, u$1 = -Infinity;
					for (; t$1.pos < e$1;) {
						if (n$1 <= 0) {
							const e$2 = t$1.readVarint();
							r$1 = 7 & e$2, n$1 = e$2 >> 3;
						}
						if (n$1--, 1 === r$1 || 2 === r$1) i$1 += t$1.readSVarint(), s$1 += t$1.readSVarint(), i$1 < a && (a = i$1), i$1 > o$1 && (o$1 = i$1), s$1 < l$1 && (l$1 = s$1), s$1 > u$1 && (u$1 = s$1);
						else if (7 !== r$1) throw new Error(`unknown command ${r$1}`);
					}
					return [
						a,
						l$1,
						o$1,
						u$1
					];
				}
				toGeoJSON(t$1, e$1, r$1) {
					const n$1 = this.extent * Math.pow(2, r$1), i$1 = this.extent * t$1, s$1 = this.extent * e$1, a = this.loadGeometry();
					function o$1(t$2) {
						return [360 * (t$2.x + i$1) / n$1 - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (t$2.y + s$1) / n$1) * Math.PI)) - 90];
					}
					function l$1(t$2) {
						return t$2.map(o$1);
					}
					let u$1;
					if (1 === this.type) {
						const t$2 = [];
						for (const e$3 of a) t$2.push(e$3[0]);
						const e$2 = l$1(t$2);
						u$1 = 1 === t$2.length ? {
							type: "Point",
							coordinates: e$2[0]
						} : {
							type: "MultiPoint",
							coordinates: e$2
						};
					} else if (2 === this.type) {
						const t$2 = a.map(l$1);
						u$1 = 1 === t$2.length ? {
							type: "LineString",
							coordinates: t$2[0]
						} : {
							type: "MultiLineString",
							coordinates: t$2
						};
					} else {
						if (3 !== this.type) throw new Error("unknown feature type");
						{
							const t$2 = Du(a), e$2 = [];
							for (const r$2 of t$2) e$2.push(r$2.map(l$1));
							u$1 = 1 === e$2.length ? {
								type: "Polygon",
								coordinates: e$2[0]
							} : {
								type: "MultiPolygon",
								coordinates: e$2
							};
						}
					}
					const c$1 = {
						type: "Feature",
						geometry: u$1,
						properties: this.properties
					};
					return null != this.id && (c$1.id = this.id), c$1;
				}
			}
			function Fu(t$1, e$1, r$1) {
				1 === t$1 ? e$1.id = r$1.readVarint() : 2 === t$1 ? function(t$2, e$2) {
					const r$2 = t$2.readVarint() + t$2.pos;
					for (; t$2.pos < r$2;) {
						const r$3 = e$2._keys[t$2.readVarint()], n$1 = e$2._values[t$2.readVarint()];
						e$2.properties[r$3] = n$1;
					}
				}(r$1, e$1) : 3 === t$1 ? e$1.type = r$1.readVarint() : 4 === t$1 && (e$1._geometry = r$1.pos);
			}
			function Du(t$1) {
				const e$1 = t$1.length;
				if (e$1 <= 1) return [t$1];
				const r$1 = [];
				let n$1, i$1;
				for (let s$1 = 0; s$1 < e$1; s$1++) {
					const e$2 = zu(t$1[s$1]);
					0 !== e$2 && (void 0 === i$1 && (i$1 = e$2 < 0), i$1 === e$2 < 0 ? (n$1 && r$1.push(n$1), n$1 = [t$1[s$1]]) : n$1 && n$1.push(t$1[s$1]));
				}
				return n$1 && r$1.push(n$1), r$1;
			}
			function zu(t$1) {
				let e$1 = 0;
				for (let r$1, n$1, i$1 = 0, s$1 = t$1.length, a = s$1 - 1; i$1 < s$1; a = i$1++) r$1 = t$1[i$1], n$1 = t$1[a], e$1 += (n$1.x - r$1.x) * (r$1.y + n$1.y);
				return e$1;
			}
			Mu.types = [
				"Unknown",
				"Point",
				"LineString",
				"Polygon"
			];
			class Pu {
				constructor(t$1, e$1) {
					this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = t$1, this._keys = [], this._values = [], this._features = [], t$1.readFields(Bu, this, e$1), this.length = this._features.length;
				}
				feature(t$1) {
					if (t$1 < 0 || t$1 >= this._features.length) throw new Error("feature index out of bounds");
					this._pbf.pos = this._features[t$1];
					const e$1 = this._pbf.readVarint() + this._pbf.pos;
					return new Mu(this._pbf, e$1, this.extent, this._keys, this._values);
				}
			}
			function Bu(t$1, e$1, r$1) {
				15 === t$1 ? e$1.version = r$1.readVarint() : 1 === t$1 ? e$1.name = r$1.readString() : 5 === t$1 ? e$1.extent = r$1.readVarint() : 2 === t$1 ? e$1._features.push(r$1.pos) : 3 === t$1 ? e$1._keys.push(r$1.readString()) : 4 === t$1 && e$1._values.push(function(t$2) {
					let e$2 = null;
					const r$2 = t$2.readVarint() + t$2.pos;
					for (; t$2.pos < r$2;) {
						const r$3 = t$2.readVarint() >> 3;
						e$2 = 1 === r$3 ? t$2.readString() : 2 === r$3 ? t$2.readFloat() : 3 === r$3 ? t$2.readDouble() : 4 === r$3 ? t$2.readVarint64() : 5 === r$3 ? t$2.readVarint() : 6 === r$3 ? t$2.readSVarint() : 7 === r$3 ? t$2.readBoolean() : null;
					}
					if (null == e$2) throw new Error("unknown feature value");
					return e$2;
				}(r$1));
			}
			class Vu {
				constructor(t$1, e$1) {
					this.layers = t$1.readFields(Cu, {}, e$1);
				}
			}
			function Cu(t$1, e$1, r$1) {
				if (3 === t$1) {
					const t$2 = new Pu(r$1, r$1.readVarint() + r$1.pos);
					t$2.length && (e$1[t$2.name] = t$2);
				}
			}
			const Lu = Math.pow(2, 13);
			function Ou(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1) {
				t$1.emplaceBack(e$1, r$1, 2 * Math.floor(n$1 * Lu) + a, i$1 * Lu * 2, s$1 * Lu * 2, Math.round(o$1));
			}
			class Ru {
				constructor(t$1) {
					this.zoom = t$1.zoom, this.overscaling = t$1.overscaling, this.layers = t$1.layers, this.layerIds = this.layers.map(((t$2) => t$2.id)), this.index = t$1.index, this.hasDependencies = !1, this.layoutVertexArray = new ja(), this.centroidVertexArray = new $a(), this.indexArray = new to(), this.programConfigurations = new Vo(t$1.layers, t$1.zoom), this.segments = new io(), this.stateDependentLayerIds = this.layers.filter(((t$2) => t$2.isStateDependent())).map(((t$2) => t$2.id));
				}
				populate(t$1, e$1, r$1) {
					this.features = [], this.hasDependencies = Ol("fill-extrusion", this.layers, e$1);
					for (const { feature: n$1, id: i$1, index: s$1, sourceLayerIndex: a } of t$1) {
						const t$2 = this.layers[0]._featureFilter.needGeometry, o$1 = $o(n$1, t$2);
						if (!this.layers[0]._featureFilter.filter(new Ps(this.zoom), o$1, r$1)) continue;
						const l$1 = {
							id: i$1,
							sourceLayerIndex: a,
							index: s$1,
							geometry: t$2 ? o$1.geometry : No(n$1),
							properties: n$1.properties,
							type: n$1.type,
							patterns: {}
						};
						this.hasDependencies ? this.features.push(Rl("fill-extrusion", this.layers, l$1, { zoom: this.zoom }, e$1)) : this.addFeature(l$1, l$1.geometry, s$1, r$1, {}, e$1.subdivisionGranularity), e$1.featureIndex.insert(n$1, l$1.geometry, s$1, a, this.index, !0);
					}
				}
				addFeatures(t$1, e$1, r$1) {
					for (const n$1 of this.features) {
						const { geometry: i$1 } = n$1;
						this.addFeature(n$1, i$1, n$1.index, e$1, r$1, t$1.subdivisionGranularity);
					}
				}
				update(t$1, e$1, r$1) {
					this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t$1, e$1, this.stateDependentLayers, { imagePositions: r$1 });
				}
				isEmpty() {
					return 0 === this.layoutVertexArray.length && 0 === this.centroidVertexArray.length;
				}
				uploadPending() {
					return !this.uploaded || this.programConfigurations.needsUpload;
				}
				upload(t$1) {
					this.uploaded || (this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, Iu), this.centroidVertexBuffer = t$1.createVertexBuffer(this.centroidVertexArray, Tu.members, !0), this.indexBuffer = t$1.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t$1), this.uploaded = !0;
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
				}
				addFeature(t$1, e$1, r$1, n$1, i$1, s$1) {
					for (const r$2 of tn(e$1, 500)) {
						const e$2 = {
							x: 0,
							y: 0,
							sampleCount: 0
						}, i$2 = this.layoutVertexArray.length;
						this.processPolygon(e$2, n$1, t$1, r$2, s$1);
						const a = this.layoutVertexArray.length - i$2, o$1 = Math.floor(e$2.x / e$2.sampleCount), l$1 = Math.floor(e$2.y / e$2.sampleCount);
						for (let t$2 = 0; t$2 < a; t$2++) this.centroidVertexArray.emplaceBack(o$1, l$1);
					}
					this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t$1, r$1, {
						imagePositions: i$1,
						canonical: n$1
					});
				}
				processPolygon(t$1, e$1, r$1, n$1, i$1) {
					if (n$1.length < 1) return;
					if (Uu(n$1[0])) return;
					for (const e$2 of n$1) 0 !== e$2.length && Nu(t$1, e$2);
					const s$1 = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, a = i$1.fill.getGranularityForZoomLevel(e$1.z), o$1 = "Polygon" === Mu.types[r$1.type];
					for (const t$2 of n$1) {
						if (0 === t$2.length) continue;
						if (Uu(t$2)) continue;
						const e$2 = gu(t$2, a, o$1);
						this._generateSideFaces(e$2, s$1);
					}
					if (!o$1) return;
					const l$1 = mu(n$1, e$1, a, !1), u$1 = this.layoutVertexArray;
					vu(((t$2, e$2) => {
						Ou(u$1, t$2, e$2, 0, 0, 1, 1, 0);
					}), this.segments, this.layoutVertexArray, this.indexArray, l$1.verticesFlattened, l$1.indicesTriangles);
				}
				_generateSideFaces(t$1, e$1) {
					let r$1 = 0;
					for (let n$1 = 1; n$1 < t$1.length; n$1++) {
						const i$1 = t$1[n$1], s$1 = t$1[n$1 - 1];
						if ($u(i$1, s$1)) continue;
						e$1.segment.vertexLength + 4 > io.MAX_VERTEX_ARRAY_LENGTH && (e$1.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
						const a = i$1.sub(s$1)._perp()._unit(), o$1 = s$1.dist(i$1);
						r$1 + o$1 > 32768 && (r$1 = 0), Ou(this.layoutVertexArray, i$1.x, i$1.y, a.x, a.y, 0, 0, r$1), Ou(this.layoutVertexArray, i$1.x, i$1.y, a.x, a.y, 0, 1, r$1), r$1 += o$1, Ou(this.layoutVertexArray, s$1.x, s$1.y, a.x, a.y, 0, 0, r$1), Ou(this.layoutVertexArray, s$1.x, s$1.y, a.x, a.y, 0, 1, r$1);
						const l$1 = e$1.segment.vertexLength;
						this.indexArray.emplaceBack(l$1, l$1 + 2, l$1 + 1), this.indexArray.emplaceBack(l$1 + 1, l$1 + 2, l$1 + 3), e$1.segment.vertexLength += 4, e$1.segment.primitiveLength += 2;
					}
				}
			}
			function Nu(t$1, e$1) {
				for (let r$1 = 0; r$1 < e$1.length; r$1++) {
					const n$1 = e$1[r$1];
					r$1 === e$1.length - 1 && e$1[0].x === n$1.x && e$1[0].y === n$1.y || (t$1.x += n$1.x, t$1.y += n$1.y, t$1.sampleCount++);
				}
			}
			function $u(t$1, e$1) {
				return t$1.x === e$1.x && (t$1.x < 0 || t$1.x > M) || t$1.y === e$1.y && (t$1.y < 0 || t$1.y > M);
			}
			function Uu(t$1) {
				return t$1.every(((t$2) => t$2.x < 0)) || t$1.every(((t$2) => t$2.x > M)) || t$1.every(((t$2) => t$2.y < 0)) || t$1.every(((t$2) => t$2.y > M));
			}
			let qu;
			ps("FillExtrusionBucket", Ru, { omit: ["layers", "features"] });
			var ju = { get paint() {
				return qu = qu || new Hs({
					"fill-extrusion-opacity": new js(vt["paint_fill-extrusion"]["fill-extrusion-opacity"]),
					"fill-extrusion-color": new Gs(vt["paint_fill-extrusion"]["fill-extrusion-color"]),
					"fill-extrusion-translate": new js(vt["paint_fill-extrusion"]["fill-extrusion-translate"]),
					"fill-extrusion-translate-anchor": new js(vt["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
					"fill-extrusion-pattern": new Xs(vt["paint_fill-extrusion"]["fill-extrusion-pattern"]),
					"fill-extrusion-height": new Gs(vt["paint_fill-extrusion"]["fill-extrusion-height"]),
					"fill-extrusion-base": new Gs(vt["paint_fill-extrusion"]["fill-extrusion-base"]),
					"fill-extrusion-vertical-gradient": new js(vt["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])
				});
			} };
			class Gu extends Ks {
				constructor(t$1, e$1) {
					super(t$1, ju, e$1);
				}
				createBucket(t$1) {
					return new Ru(t$1);
				}
				queryRadius() {
					return nl(this.paint.get("fill-extrusion-translate"));
				}
				is3D() {
					return !0;
				}
				queryIntersectsFeature({ queryGeometry: t$1, feature: e$1, featureState: n$1, geometry: i$1, transform: s$1, pixelsToTileUnits: a, pixelPosMatrix: o$1 }) {
					const l$1 = il(t$1, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -s$1.bearingInRadians, a), u$1 = this.paint.get("fill-extrusion-height").evaluate(e$1, n$1), c$1 = this.paint.get("fill-extrusion-base").evaluate(e$1, n$1), h$1 = function(t$2, e$2) {
						const n$2 = [];
						for (const i$2 of t$2) {
							const t$3 = [
								i$2.x,
								i$2.y,
								0,
								1
							];
							A(t$3, t$3, e$2), n$2.push(new r(t$3[0] / t$3[3], t$3[1] / t$3[3]));
						}
						return n$2;
					}(l$1, o$1), p$1 = function(t$2, e$2, n$2, i$2) {
						const s$2 = [], a$1 = [], o$2 = i$2[8] * e$2, l$2 = i$2[9] * e$2, u$2 = i$2[10] * e$2, c$2 = i$2[11] * e$2, h$2 = i$2[8] * n$2, p$2 = i$2[9] * n$2, f$1 = i$2[10] * n$2, d$1 = i$2[11] * n$2;
						for (const e$3 of t$2) {
							const t$3 = [], n$3 = [];
							for (const s$3 of e$3) {
								const e$4 = s$3.x, a$2 = s$3.y, y$1 = i$2[0] * e$4 + i$2[4] * a$2 + i$2[12], m$1 = i$2[1] * e$4 + i$2[5] * a$2 + i$2[13], g$1 = i$2[2] * e$4 + i$2[6] * a$2 + i$2[14], x$1 = i$2[3] * e$4 + i$2[7] * a$2 + i$2[15], v$1 = g$1 + u$2, b$1 = x$1 + c$2, w$1 = y$1 + h$2, _$1 = m$1 + p$2, S$1 = g$1 + f$1, A$1 = x$1 + d$1, k$1 = new r((y$1 + o$2) / b$1, (m$1 + l$2) / b$1);
								k$1.z = v$1 / b$1, t$3.push(k$1);
								const E$1 = new r(w$1 / A$1, _$1 / A$1);
								E$1.z = S$1 / A$1, n$3.push(E$1);
							}
							s$2.push(t$3), a$1.push(n$3);
						}
						return [s$2, a$1];
					}(i$1, c$1, u$1, o$1);
					return function(t$2, e$2, r$1) {
						let n$2 = Infinity;
						Yo(r$1, e$2) && (n$2 = Yu(r$1, e$2[0]));
						for (let i$2 = 0; i$2 < e$2.length; i$2++) {
							const s$2 = e$2[i$2], a$1 = t$2[i$2];
							for (let t$3 = 0; t$3 < s$2.length - 1; t$3++) {
								const e$3 = s$2[t$3], i$3 = [
									e$3,
									s$2[t$3 + 1],
									a$1[t$3 + 1],
									a$1[t$3],
									e$3
								];
								Go(r$1, i$3) && (n$2 = Math.min(n$2, Yu(r$1, i$3)));
							}
						}
						return n$2 !== Infinity && n$2;
					}(p$1[0], p$1[1], h$1);
				}
			}
			function Xu(t$1, e$1) {
				return t$1.x * e$1.x + t$1.y * e$1.y;
			}
			function Yu(t$1, e$1) {
				if (1 === t$1.length) {
					let r$1 = 0;
					const n$1 = e$1[r$1++];
					let i$1;
					for (; !i$1 || n$1.equals(i$1);) if (i$1 = e$1[r$1++], !i$1) return Infinity;
					for (; r$1 < e$1.length; r$1++) {
						const s$1 = e$1[r$1], a = t$1[0], o$1 = i$1.sub(n$1), l$1 = s$1.sub(n$1), u$1 = a.sub(n$1), c$1 = Xu(o$1, o$1), h$1 = Xu(o$1, l$1), p$1 = Xu(l$1, l$1), f$1 = Xu(u$1, o$1), d$1 = Xu(u$1, l$1), y$1 = c$1 * p$1 - h$1 * h$1, m$1 = (p$1 * f$1 - h$1 * d$1) / y$1, g$1 = (c$1 * d$1 - h$1 * f$1) / y$1, x$1 = n$1.z * (1 - m$1 - g$1) + i$1.z * m$1 + s$1.z * g$1;
						if (isFinite(x$1)) return x$1;
					}
					return Infinity;
				}
				{
					let t$2 = Infinity;
					for (const r$1 of e$1) t$2 = Math.min(t$2, r$1.z);
					return t$2;
				}
			}
			const { members: Hu } = na([{
				name: "a_pos_normal",
				components: 2,
				type: "Int16"
			}, {
				name: "a_data",
				components: 4,
				type: "Uint8"
			}], 4), { members: Wu } = na([{
				name: "a_uv_x",
				components: 1,
				type: "Float32"
			}, {
				name: "a_split_index",
				components: 1,
				type: "Float32"
			}]), Ju = Math.cos(Math.PI / 180 * 37.5), Qu = Math.pow(2, 14) / .5;
			class tc {
				constructor(t$1) {
					this.zoom = t$1.zoom, this.overscaling = t$1.overscaling, this.layers = t$1.layers, this.layerIds = this.layers.map(((t$2) => t$2.id)), this.index = t$1.index, this.hasDependencies = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(((t$2) => {
						this.gradients[t$2.id] = {};
					})), this.layoutVertexArray = new Ga(), this.layoutVertexArray2 = new Xa(), this.indexArray = new to(), this.programConfigurations = new Vo(t$1.layers, t$1.zoom), this.segments = new io(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(((t$2) => t$2.isStateDependent())).map(((t$2) => t$2.id));
				}
				populate(t$1, e$1, r$1) {
					this.hasDependencies = Ol("line", this.layers, e$1) || this.hasLineDasharray(this.layers);
					const n$1 = this.layers[0].layout.get("line-sort-key"), i$1 = !n$1.isConstant(), s$1 = [];
					for (const { feature: e$2, id: a, index: o$1, sourceLayerIndex: l$1 } of t$1) {
						const t$2 = this.layers[0]._featureFilter.needGeometry, u$1 = $o(e$2, t$2);
						if (!this.layers[0]._featureFilter.filter(new Ps(this.zoom), u$1, r$1)) continue;
						const c$1 = i$1 ? n$1.evaluate(u$1, {}, r$1) : void 0, h$1 = {
							id: a,
							properties: e$2.properties,
							type: e$2.type,
							sourceLayerIndex: l$1,
							index: o$1,
							geometry: t$2 ? u$1.geometry : No(e$2),
							patterns: {},
							dashes: {},
							sortKey: c$1
						};
						s$1.push(h$1);
					}
					i$1 && s$1.sort(((t$2, e$2) => t$2.sortKey - e$2.sortKey));
					for (const n$2 of s$1) {
						const { geometry: i$2, index: s$2, sourceLayerIndex: a } = n$2;
						this.hasDependencies ? (Ol("line", this.layers, e$1) ? Rl("line", this.layers, n$2, { zoom: this.zoom }, e$1) : this.hasLineDasharray(this.layers) && this.addLineDashDependencies(this.layers, n$2, this.zoom, e$1), this.patternFeatures.push(n$2)) : this.addFeature(n$2, i$2, s$2, r$1, {}, {}, e$1.subdivisionGranularity), e$1.featureIndex.insert(t$1[s$2].feature, i$2, s$2, a, this.index);
					}
				}
				update(t$1, e$1, r$1, n$1) {
					this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t$1, e$1, this.stateDependentLayers, {
						imagePositions: r$1,
						dashPositions: n$1
					});
				}
				addFeatures(t$1, e$1, r$1, n$1) {
					for (const i$1 of this.patternFeatures) this.addFeature(i$1, i$1.geometry, i$1.index, e$1, r$1, n$1, t$1.subdivisionGranularity);
				}
				isEmpty() {
					return 0 === this.layoutVertexArray.length;
				}
				uploadPending() {
					return !this.uploaded || this.programConfigurations.needsUpload;
				}
				upload(t$1) {
					this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t$1.createVertexBuffer(this.layoutVertexArray2, Wu)), this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, Hu), this.indexBuffer = t$1.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t$1), this.uploaded = !0;
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
				}
				lineFeatureClips(t$1) {
					if (t$1.properties && Object.prototype.hasOwnProperty.call(t$1.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t$1.properties, "mapbox_clip_end")) return {
						start: +t$1.properties.mapbox_clip_start,
						end: +t$1.properties.mapbox_clip_end
					};
				}
				addFeature(t$1, e$1, r$1, n$1, i$1, s$1, a) {
					const o$1 = this.layers[0].layout, l$1 = o$1.get("line-join").evaluate(t$1, {}), u$1 = o$1.get("line-cap"), c$1 = o$1.get("line-miter-limit"), h$1 = o$1.get("line-round-limit");
					this.lineClips = this.lineFeatureClips(t$1);
					for (const r$2 of e$1) this.addLine(r$2, t$1, l$1, u$1, c$1, h$1, n$1, a);
					this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t$1, r$1, {
						imagePositions: i$1,
						dashPositions: s$1,
						canonical: n$1
					});
				}
				addLine(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1) {
					if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t$1 = gu(t$1, a ? o$1.line.getGranularityForZoomLevel(a.z) : 1), this.lineClips) {
						this.lineClipsArray.push(this.lineClips);
						for (let e$2 = 0; e$2 < t$1.length - 1; e$2++) this.totalDistance += t$1[e$2].dist(t$1[e$2 + 1]);
						this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
					}
					const l$1 = "Polygon" === Mu.types[e$1.type];
					let u$1 = t$1.length;
					for (; u$1 >= 2 && t$1[u$1 - 1].equals(t$1[u$1 - 2]);) u$1--;
					let c$1 = 0;
					for (; c$1 < u$1 - 1 && t$1[c$1].equals(t$1[c$1 + 1]);) c$1++;
					if (u$1 < (l$1 ? 3 : 2)) return;
					"bevel" === r$1 && (i$1 = 1.05);
					const h$1 = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, p$1 = this.segments.prepareSegment(10 * u$1, this.layoutVertexArray, this.indexArray);
					let f$1, d$1, y$1, m$1, g$1;
					this.e1 = this.e2 = -1, l$1 && (f$1 = t$1[u$1 - 2], g$1 = t$1[c$1].sub(f$1)._unit()._perp());
					for (let e$2 = c$1; e$2 < u$1; e$2++) {
						if (y$1 = e$2 === u$1 - 1 ? l$1 ? t$1[c$1 + 1] : void 0 : t$1[e$2 + 1], y$1 && t$1[e$2].equals(y$1)) continue;
						g$1 && (m$1 = g$1), f$1 && (d$1 = f$1), f$1 = t$1[e$2], g$1 = y$1 ? y$1.sub(f$1)._unit()._perp() : m$1, m$1 = m$1 || g$1;
						let a$1 = m$1.add(g$1);
						0 === a$1.x && 0 === a$1.y || a$1._unit();
						const o$2 = m$1.x * g$1.x + m$1.y * g$1.y, x$1 = a$1.x * g$1.x + a$1.y * g$1.y, v$1 = 0 !== x$1 ? 1 / x$1 : Infinity, b$1 = 2 * Math.sqrt(2 - 2 * x$1), w$1 = x$1 < Ju && d$1 && y$1, _$1 = m$1.x * g$1.y - m$1.y * g$1.x > 0;
						if (w$1 && e$2 > c$1) {
							const t$2 = f$1.dist(d$1);
							if (t$2 > 2 * h$1) {
								const e$3 = f$1.sub(f$1.sub(d$1)._mult(h$1 / t$2)._round());
								this.updateDistance(d$1, e$3), this.addCurrentVertex(e$3, m$1, 0, 0, p$1), d$1 = e$3;
							}
						}
						const S$1 = d$1 && y$1;
						let A$1 = S$1 ? r$1 : l$1 ? "butt" : n$1;
						if (S$1 && "round" === A$1 && (v$1 < s$1 ? A$1 = "miter" : v$1 <= 2 && (A$1 = "fakeround")), "miter" === A$1 && v$1 > i$1 && (A$1 = "bevel"), "bevel" === A$1 && (v$1 > 2 && (A$1 = "flipbevel"), v$1 < i$1 && (A$1 = "miter")), d$1 && this.updateDistance(d$1, f$1), "miter" === A$1) a$1._mult(v$1), this.addCurrentVertex(f$1, a$1, 0, 0, p$1);
						else if ("flipbevel" === A$1) {
							if (v$1 > 100) a$1 = g$1.mult(-1);
							else {
								const t$2 = v$1 * m$1.add(g$1).mag() / m$1.sub(g$1).mag();
								a$1._perp()._mult(t$2 * (_$1 ? -1 : 1));
							}
							this.addCurrentVertex(f$1, a$1, 0, 0, p$1), this.addCurrentVertex(f$1, a$1.mult(-1), 0, 0, p$1);
						} else if ("bevel" === A$1 || "fakeround" === A$1) {
							const t$2 = -Math.sqrt(v$1 * v$1 - 1), e$3 = _$1 ? t$2 : 0, r$2 = _$1 ? 0 : t$2;
							if (d$1 && this.addCurrentVertex(f$1, m$1, e$3, r$2, p$1), "fakeround" === A$1) {
								const t$3 = Math.round(180 * b$1 / Math.PI / 20);
								for (let e$4 = 1; e$4 < t$3; e$4++) {
									let r$3 = e$4 / t$3;
									if (.5 !== r$3) {
										const t$4 = r$3 - .5;
										r$3 += r$3 * t$4 * (r$3 - 1) * ((1.0904 + o$2 * (o$2 * (3.55645 - 1.43519 * o$2) - 3.2452)) * t$4 * t$4 + (.848013 + o$2 * (.215638 * o$2 - 1.06021)));
									}
									const n$2 = g$1.sub(m$1)._mult(r$3)._add(m$1)._unit()._mult(_$1 ? -1 : 1);
									this.addHalfVertex(f$1, n$2.x, n$2.y, !1, _$1, 0, p$1);
								}
							}
							y$1 && this.addCurrentVertex(f$1, g$1, -e$3, -r$2, p$1);
						} else if ("butt" === A$1) this.addCurrentVertex(f$1, a$1, 0, 0, p$1);
						else if ("square" === A$1) {
							const t$2 = d$1 ? 1 : -1;
							this.addCurrentVertex(f$1, a$1, t$2, t$2, p$1);
						} else "round" === A$1 && (d$1 && (this.addCurrentVertex(f$1, m$1, 0, 0, p$1), this.addCurrentVertex(f$1, m$1, 1, 1, p$1, !0)), y$1 && (this.addCurrentVertex(f$1, g$1, -1, -1, p$1, !0), this.addCurrentVertex(f$1, g$1, 0, 0, p$1)));
						if (w$1 && e$2 < u$1 - 1) {
							const t$2 = f$1.dist(y$1);
							if (t$2 > 2 * h$1) {
								const e$3 = f$1.add(y$1.sub(f$1)._mult(h$1 / t$2)._round());
								this.updateDistance(f$1, e$3), this.addCurrentVertex(e$3, g$1, 0, 0, p$1), f$1 = e$3;
							}
						}
					}
				}
				addCurrentVertex(t$1, e$1, r$1, n$1, i$1, s$1 = !1) {
					const a = e$1.y * n$1 - e$1.x, o$1 = -e$1.y - e$1.x * n$1;
					this.addHalfVertex(t$1, e$1.x + e$1.y * r$1, e$1.y - e$1.x * r$1, s$1, !1, r$1, i$1), this.addHalfVertex(t$1, a, o$1, s$1, !0, -n$1, i$1), this.distance > Qu / 2 && 0 === this.totalDistance && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t$1, e$1, r$1, n$1, i$1, s$1));
				}
				addHalfVertex({ x: t$1, y: e$1 }, r$1, n$1, i$1, s$1, a, o$1) {
					const l$1 = .5 * (this.lineClips ? this.scaledDistance * (Qu - 1) : this.scaledDistance);
					this.layoutVertexArray.emplaceBack((t$1 << 1) + (i$1 ? 1 : 0), (e$1 << 1) + (s$1 ? 1 : 0), Math.round(63 * r$1) + 128, Math.round(63 * n$1) + 128, 1 + (0 === a ? 0 : a < 0 ? -1 : 1) | (63 & l$1) << 2, l$1 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
					const u$1 = o$1.vertexLength++;
					this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, u$1, this.e2), o$1.primitiveLength++), s$1 ? this.e2 = u$1 : this.e1 = u$1;
				}
				updateScaledDistance() {
					this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
				}
				updateDistance(t$1, e$1) {
					this.distance += t$1.dist(e$1), this.updateScaledDistance();
				}
				hasLineDasharray(t$1) {
					for (const e$1 of t$1) {
						const t$2 = e$1.paint.get("line-dasharray");
						if (t$2 && !t$2.isConstant()) return !0;
					}
					return !1;
				}
				addLineDashDependencies(t$1, e$1, r$1, n$1) {
					for (const i$1 of t$1) {
						const t$2 = i$1.paint.get("line-dasharray");
						if (!t$2 || "constant" === t$2.value.kind) continue;
						const s$1 = "round" === i$1.layout.get("line-cap"), a = {
							dasharray: t$2.value.evaluate({ zoom: r$1 - 1 }, e$1, {}),
							round: s$1
						}, o$1 = {
							dasharray: t$2.value.evaluate({ zoom: r$1 }, e$1, {}),
							round: s$1
						}, l$1 = {
							dasharray: t$2.value.evaluate({ zoom: r$1 + 1 }, e$1, {}),
							round: s$1
						}, u$1 = `${a.dasharray.join(",")},${a.round}`, c$1 = `${o$1.dasharray.join(",")},${o$1.round}`, h$1 = `${l$1.dasharray.join(",")},${l$1.round}`;
						n$1.dashDependencies[u$1] = a, n$1.dashDependencies[c$1] = o$1, n$1.dashDependencies[h$1] = l$1, e$1.dashes[i$1.id] = {
							min: u$1,
							mid: c$1,
							max: h$1
						};
					}
				}
			}
			let ec, rc;
			ps("LineBucket", tc, { omit: ["layers", "patternFeatures"] });
			var nc = {
				get paint() {
					return rc = rc || new Hs({
						"line-opacity": new Gs(vt.paint_line["line-opacity"]),
						"line-color": new Gs(vt.paint_line["line-color"]),
						"line-translate": new js(vt.paint_line["line-translate"]),
						"line-translate-anchor": new js(vt.paint_line["line-translate-anchor"]),
						"line-width": new Gs(vt.paint_line["line-width"]),
						"line-gap-width": new Gs(vt.paint_line["line-gap-width"]),
						"line-offset": new Gs(vt.paint_line["line-offset"]),
						"line-blur": new Gs(vt.paint_line["line-blur"]),
						"line-dasharray": new Xs(vt.paint_line["line-dasharray"]),
						"line-pattern": new Xs(vt.paint_line["line-pattern"]),
						"line-gradient": new Zs(vt.paint_line["line-gradient"])
					});
				},
				get layout() {
					return ec = ec || new Hs({
						"line-cap": new js(vt.layout_line["line-cap"]),
						"line-join": new Gs(vt.layout_line["line-join"]),
						"line-miter-limit": new js(vt.layout_line["line-miter-limit"]),
						"line-round-limit": new js(vt.layout_line["line-round-limit"]),
						"line-sort-key": new Gs(vt.layout_line["line-sort-key"])
					});
				}
			};
			class ic extends Gs {
				possiblyEvaluate(t$1, e$1) {
					return e$1 = new Ps(Math.floor(e$1.zoom), {
						now: e$1.now,
						fadeDuration: e$1.fadeDuration,
						zoomHistory: e$1.zoomHistory,
						transition: e$1.transition
					}), super.possiblyEvaluate(t$1, e$1);
				}
				evaluate(t$1, e$1, r$1, n$1) {
					return e$1 = O({}, e$1, { zoom: Math.floor(e$1.zoom) }), super.evaluate(t$1, e$1, r$1, n$1);
				}
			}
			let sc;
			class ac extends Ks {
				constructor(t$1, e$1) {
					super(t$1, nc, e$1), this.gradientVersion = 0, sc || (sc = new ic(nc.paint.properties["line-width"].specification), sc.useIntegerZoom = !0);
				}
				_handleSpecialPaintPropertyUpdate(t$1) {
					if ("line-gradient" === t$1) {
						const t$2 = this.gradientExpression();
						this.stepInterpolant = !!function(t$3) {
							return void 0 !== t$3._styleExpression;
						}(t$2) && t$2._styleExpression.expression instanceof or, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
					}
				}
				gradientExpression() {
					return this._transitionablePaint._values["line-gradient"].value.expression;
				}
				recalculate(t$1, e$1) {
					super.recalculate(t$1, e$1), this.paint._values["line-floorwidth"] = sc.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t$1);
				}
				createBucket(t$1) {
					return new tc(t$1);
				}
				queryRadius(t$1) {
					const e$1 = t$1, r$1 = oc(rl("line-width", this, e$1), rl("line-gap-width", this, e$1)), n$1 = rl("line-offset", this, e$1);
					return r$1 / 2 + Math.abs(n$1) + nl(this.paint.get("line-translate"));
				}
				queryIntersectsFeature({ queryGeometry: t$1, feature: e$1, featureState: n$1, geometry: i$1, transform: s$1, pixelsToTileUnits: a }) {
					const o$1 = il(t$1, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -s$1.bearingInRadians, a), l$1 = a / 2 * oc(this.paint.get("line-width").evaluate(e$1, n$1), this.paint.get("line-gap-width").evaluate(e$1, n$1)), u$1 = this.paint.get("line-offset").evaluate(e$1, n$1);
					return u$1 && (i$1 = function(t$2, e$2) {
						const n$2 = [];
						for (let i$2 = 0; i$2 < t$2.length; i$2++) {
							const s$2 = sl(t$2[i$2]), a$1 = [];
							for (let t$3 = 0; t$3 < s$2.length; t$3++) {
								const n$3 = s$2[t$3], i$3 = s$2[t$3 - 1], o$2 = s$2[t$3 + 1], l$2 = 0 === t$3 ? new r(0, 0) : n$3.sub(i$3)._unit()._perp(), u$2 = t$3 === s$2.length - 1 ? new r(0, 0) : o$2.sub(n$3)._unit()._perp(), c$1 = l$2._add(u$2)._unit(), h$1 = c$1.x * u$2.x + c$1.y * u$2.y;
								0 !== h$1 && c$1._mult(1 / h$1), a$1.push(c$1._mult(e$2)._add(n$3));
							}
							n$2.push(a$1);
						}
						return n$2;
					}(i$1, u$1 * a)), function(t$2, e$2, r$1) {
						for (let n$2 = 0; n$2 < e$2.length; n$2++) {
							const i$2 = e$2[n$2];
							if (t$2.length >= 3) {
								for (let e$3 = 0; e$3 < i$2.length; e$3++) if (tl(t$2, i$2[e$3])) return !0;
							}
							if (Zo(t$2, i$2, r$1)) return !0;
						}
						return !1;
					}(o$1, i$1, l$1);
				}
				isTileClipped() {
					return !0;
				}
			}
			function oc(t$1, e$1) {
				return e$1 > 0 ? e$1 + 2 * t$1 : t$1;
			}
			const lc = na([
				{
					name: "a_pos_offset",
					components: 4,
					type: "Int16"
				},
				{
					name: "a_data",
					components: 4,
					type: "Uint16"
				},
				{
					name: "a_pixeloffset",
					components: 4,
					type: "Int16"
				}
			], 4), uc = na([{
				name: "a_projected_pos",
				components: 3,
				type: "Float32"
			}], 4);
			na([{
				name: "a_fade_opacity",
				components: 1,
				type: "Uint32"
			}], 4);
			const cc = na([
				{
					name: "a_placed",
					components: 2,
					type: "Uint8"
				},
				{
					name: "a_shift",
					components: 2,
					type: "Float32"
				},
				{
					name: "a_box_real",
					components: 2,
					type: "Int16"
				}
			]);
			na([
				{
					type: "Int16",
					name: "anchorPointX"
				},
				{
					type: "Int16",
					name: "anchorPointY"
				},
				{
					type: "Int16",
					name: "x1"
				},
				{
					type: "Int16",
					name: "y1"
				},
				{
					type: "Int16",
					name: "x2"
				},
				{
					type: "Int16",
					name: "y2"
				},
				{
					type: "Uint32",
					name: "featureIndex"
				},
				{
					type: "Uint16",
					name: "sourceLayerIndex"
				},
				{
					type: "Uint16",
					name: "bucketIndex"
				}
			]);
			const hc = na([
				{
					name: "a_pos",
					components: 2,
					type: "Int16"
				},
				{
					name: "a_anchor_pos",
					components: 2,
					type: "Int16"
				},
				{
					name: "a_extrude",
					components: 2,
					type: "Int16"
				}
			], 4), pc = na([
				{
					name: "a_pos",
					components: 2,
					type: "Float32"
				},
				{
					name: "a_radius",
					components: 1,
					type: "Float32"
				},
				{
					name: "a_flags",
					components: 2,
					type: "Int16"
				}
			], 4);
			function fc(t$1, e$1, r$1) {
				return t$1.sections.forEach(((t$2) => {
					t$2.text = function(t$3, e$2, r$2) {
						const n$1 = e$2.layout.get("text-transform").evaluate(r$2, {});
						return "uppercase" === n$1 ? t$3 = t$3.toLocaleUpperCase() : "lowercase" === n$1 && (t$3 = t$3.toLocaleLowerCase()), zs.applyArabicShaping && (t$3 = zs.applyArabicShaping(t$3)), t$3;
					}(t$2.text, e$1, r$1);
				})), t$1;
			}
			na([{
				name: "triangle",
				components: 3,
				type: "Uint16"
			}]), na([
				{
					type: "Int16",
					name: "anchorX"
				},
				{
					type: "Int16",
					name: "anchorY"
				},
				{
					type: "Uint16",
					name: "glyphStartIndex"
				},
				{
					type: "Uint16",
					name: "numGlyphs"
				},
				{
					type: "Uint32",
					name: "vertexStartIndex"
				},
				{
					type: "Uint32",
					name: "lineStartIndex"
				},
				{
					type: "Uint32",
					name: "lineLength"
				},
				{
					type: "Uint16",
					name: "segment"
				},
				{
					type: "Uint16",
					name: "lowerSize"
				},
				{
					type: "Uint16",
					name: "upperSize"
				},
				{
					type: "Float32",
					name: "lineOffsetX"
				},
				{
					type: "Float32",
					name: "lineOffsetY"
				},
				{
					type: "Uint8",
					name: "writingMode"
				},
				{
					type: "Uint8",
					name: "placedOrientation"
				},
				{
					type: "Uint8",
					name: "hidden"
				},
				{
					type: "Uint32",
					name: "crossTileID"
				},
				{
					type: "Int16",
					name: "associatedIconIndex"
				}
			]), na([
				{
					type: "Int16",
					name: "anchorX"
				},
				{
					type: "Int16",
					name: "anchorY"
				},
				{
					type: "Int16",
					name: "rightJustifiedTextSymbolIndex"
				},
				{
					type: "Int16",
					name: "centerJustifiedTextSymbolIndex"
				},
				{
					type: "Int16",
					name: "leftJustifiedTextSymbolIndex"
				},
				{
					type: "Int16",
					name: "verticalPlacedTextSymbolIndex"
				},
				{
					type: "Int16",
					name: "placedIconSymbolIndex"
				},
				{
					type: "Int16",
					name: "verticalPlacedIconSymbolIndex"
				},
				{
					type: "Uint16",
					name: "key"
				},
				{
					type: "Uint16",
					name: "textBoxStartIndex"
				},
				{
					type: "Uint16",
					name: "textBoxEndIndex"
				},
				{
					type: "Uint16",
					name: "verticalTextBoxStartIndex"
				},
				{
					type: "Uint16",
					name: "verticalTextBoxEndIndex"
				},
				{
					type: "Uint16",
					name: "iconBoxStartIndex"
				},
				{
					type: "Uint16",
					name: "iconBoxEndIndex"
				},
				{
					type: "Uint16",
					name: "verticalIconBoxStartIndex"
				},
				{
					type: "Uint16",
					name: "verticalIconBoxEndIndex"
				},
				{
					type: "Uint16",
					name: "featureIndex"
				},
				{
					type: "Uint16",
					name: "numHorizontalGlyphVertices"
				},
				{
					type: "Uint16",
					name: "numVerticalGlyphVertices"
				},
				{
					type: "Uint16",
					name: "numIconVertices"
				},
				{
					type: "Uint16",
					name: "numVerticalIconVertices"
				},
				{
					type: "Uint16",
					name: "useRuntimeCollisionCircles"
				},
				{
					type: "Uint32",
					name: "crossTileID"
				},
				{
					type: "Float32",
					name: "textBoxScale"
				},
				{
					type: "Float32",
					name: "collisionCircleDiameter"
				},
				{
					type: "Uint16",
					name: "textAnchorOffsetStartIndex"
				},
				{
					type: "Uint16",
					name: "textAnchorOffsetEndIndex"
				}
			]), na([{
				type: "Float32",
				name: "offsetX"
			}]), na([
				{
					type: "Int16",
					name: "x"
				},
				{
					type: "Int16",
					name: "y"
				},
				{
					type: "Int16",
					name: "tileUnitDistanceFromAnchor"
				}
			]), na([{
				type: "Uint16",
				name: "textAnchor"
			}, {
				type: "Float32",
				components: 2,
				name: "textOffset"
			}]);
			var dc = 24;
			const yc = {
				"!": "",
				"#": "",
				$: "",
				"%": "",
				"&": "",
				"(": "",
				")": "",
				"*": "",
				"+": "",
				",": "",
				"-": "",
				".": "",
				"/": "",
				":": "",
				";": "",
				"<": "",
				"=": "",
				">": "",
				"?": "",
				"@": "",
				"[": "",
				"\\": "",
				"]": "",
				"^": "",
				_: "",
				"`": "",
				"{": "",
				"|": "",
				"}": "",
				"~": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": ""
			}, mc = {
				10: !0,
				32: !0,
				38: !0,
				41: !0,
				43: !0,
				45: !0,
				47: !0,
				173: !0,
				183: !0,
				8203: !0,
				8208: !0,
				8211: !0,
				8231: !0
			}, gc = { 40: !0 };
			function xc(t$1, e$1, r$1, n$1, i$1, s$1) {
				if ("fontStack" in e$1) {
					const n$2 = r$1[e$1.fontStack], s$2 = n$2 && n$2[t$1];
					return s$2 ? s$2.metrics.advance * e$1.scale + i$1 : 0;
				}
				{
					const t$2 = n$1[e$1.imageName];
					return t$2 ? t$2.displaySize[0] * e$1.scale * dc / s$1 + i$1 : 0;
				}
			}
			function vc(t$1, e$1, r$1, n$1) {
				const i$1 = Math.pow(t$1 - e$1, 2);
				return n$1 ? t$1 < e$1 ? i$1 / 2 : 2 * i$1 : i$1 + Math.abs(r$1) * r$1;
			}
			function bc(t$1, e$1, r$1) {
				let n$1 = 0;
				return 10 === t$1 && (n$1 -= 1e4), r$1 && (n$1 += 150), 40 !== t$1 && 65288 !== t$1 || (n$1 += 50), 41 !== e$1 && 65289 !== e$1 || (n$1 += 50), n$1;
			}
			function wc(t$1, e$1, r$1, n$1, i$1, s$1) {
				let a = null, o$1 = vc(e$1, r$1, i$1, s$1);
				for (const t$2 of n$1) {
					const n$2 = vc(e$1 - t$2.x, r$1, i$1, s$1) + t$2.badness;
					n$2 <= o$1 && (a = t$2, o$1 = n$2);
				}
				return {
					index: t$1,
					x: e$1,
					priorBreak: a,
					badness: o$1
				};
			}
			function _c(t$1) {
				return t$1 ? _c(t$1.priorBreak).concat(t$1.index) : [];
			}
			class Sc {
				constructor(t$1 = "", e$1 = [], r$1 = []) {
					this.text = t$1, this.sections = e$1, this.sectionIndex = r$1, this.imageSectionID = null;
				}
				static fromFeature(t$1, e$1) {
					const r$1 = new Sc();
					for (let n$1 = 0; n$1 < t$1.sections.length; n$1++) {
						const i$1 = t$1.sections[n$1];
						i$1.image ? r$1.addImageSection(i$1) : r$1.addTextSection(i$1, e$1);
					}
					return r$1;
				}
				length() {
					return [...this.text].length;
				}
				getSection(t$1) {
					return this.sections[this.sectionIndex[t$1]];
				}
				getSectionIndex(t$1) {
					return this.sectionIndex[t$1];
				}
				verticalizePunctuation() {
					this.text = function(t$1) {
						let e$1 = "", r$1 = {
							premature: !0,
							value: void 0
						};
						const n$1 = t$1[Symbol.iterator]();
						let i$1 = n$1.next();
						const s$1 = t$1[Symbol.iterator]();
						s$1.next();
						let a = s$1.next();
						for (; !i$1.done;) e$1 += !a.done && Ts(a.value.codePointAt(0)) && !yc[a.value] || !r$1.premature && Ts(r$1.value.codePointAt(0)) && !yc[r$1.value] || !yc[i$1.value] ? i$1.value : yc[i$1.value], r$1 = {
							value: i$1.value,
							premature: !1
						}, i$1 = n$1.next(), a = s$1.next();
						return e$1;
					}(this.text);
				}
				hasZeroWidthSpaces() {
					return this.text.includes("");
				}
				trim() {
					const t$1 = this.text.match(/^\s*/), e$1 = t$1 ? t$1[0].length : 0, r$1 = this.text.match(/\S\s*$/), n$1 = r$1 ? r$1[0].length - 1 : 0;
					this.text = this.text.substring(e$1, this.text.length - n$1), this.sectionIndex = this.sectionIndex.slice(e$1, this.sectionIndex.length - n$1);
				}
				substring(t$1, e$1) {
					const r$1 = [...this.text].slice(t$1, e$1).join(""), n$1 = this.sectionIndex.slice(t$1, e$1);
					return new Sc(r$1, this.sections, n$1);
				}
				toCodeUnitIndex(t$1) {
					return [...this.text].slice(0, t$1).join("").length;
				}
				toString() {
					return this.text;
				}
				getMaxScale() {
					return this.sectionIndex.reduce(((t$1, e$1) => Math.max(t$1, this.sections[e$1].scale)), 0);
				}
				getMaxImageSize(t$1) {
					let e$1 = 0, r$1 = 0;
					for (let n$1 = 0; n$1 < this.length(); n$1++) {
						const i$1 = this.getSection(n$1);
						if ("imageName" in i$1) {
							const n$2 = t$1[i$1.imageName];
							if (!n$2) continue;
							const s$1 = n$2.displaySize;
							e$1 = Math.max(e$1, s$1[0]), r$1 = Math.max(r$1, s$1[1]);
						}
					}
					return {
						maxImageWidth: e$1,
						maxImageHeight: r$1
					};
				}
				addTextSection(t$1, e$1) {
					this.text += t$1.text, this.sections.push({
						scale: t$1.scale || 1,
						verticalAlign: t$1.verticalAlign || "bottom",
						fontStack: t$1.fontStack || e$1
					});
					const r$1 = this.sections.length - 1;
					this.sectionIndex.push(...[...t$1.text].map((() => r$1)));
				}
				addImageSection(t$1) {
					const e$1 = t$1.image ? t$1.image.name : "";
					if (0 === e$1.length) return void j("Can't add FormattedSection with an empty image.");
					const r$1 = this.getNextImageSectionCharCode();
					r$1 ? (this.text += String.fromCharCode(r$1), this.sections.push({
						scale: 1,
						verticalAlign: t$1.verticalAlign || "bottom",
						imageName: e$1
					}), this.sectionIndex.push(this.sections.length - 1)) : j("Reached maximum number of images 6401");
				}
				getNextImageSectionCharCode() {
					return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
				}
				determineLineBreaks(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = [], a = this.determineAverageLineWidth(t$1, e$1, r$1, n$1, i$1), o$1 = this.hasZeroWidthSpaces();
					let l$1 = 0, u$1 = 0;
					const c$1 = this.text[Symbol.iterator]();
					let h$1 = c$1.next();
					const p$1 = this.text[Symbol.iterator]();
					p$1.next();
					let f$1 = p$1.next();
					const d$1 = this.text[Symbol.iterator]();
					d$1.next(), d$1.next();
					let y$1 = d$1.next();
					for (; !h$1.done;) {
						const e$2 = this.getSection(u$1), m$1 = h$1.value.codePointAt(0);
						if (ws(m$1) || (l$1 += xc(m$1, e$2, r$1, n$1, t$1, i$1)), !f$1.done) {
							const t$2 = vs(m$1), r$2 = f$1.value.codePointAt(0);
							(mc[m$1] || t$2 || "imageName" in e$2 || !y$1.done && gc[r$2]) && s$1.push(wc(u$1 + 1, l$1, a, s$1, bc(m$1, r$2, t$2 && o$1), !1));
						}
						u$1++, h$1 = c$1.next(), f$1 = p$1.next(), y$1 = d$1.next();
					}
					return _c(wc(this.length(), l$1, a, s$1, 0, !0));
				}
				determineAverageLineWidth(t$1, e$1, r$1, n$1, i$1) {
					let s$1 = 0, a = 0;
					for (const e$2 of this.text) {
						const o$1 = this.getSection(a);
						s$1 += xc(e$2.codePointAt(0), o$1, r$1, n$1, t$1, i$1), a++;
					}
					return s$1 / Math.max(1, Math.ceil(s$1 / e$1));
				}
			}
			const Ac = 4294967296, kc = 1 / Ac, Ec = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf-8");
			class Tc {
				constructor(t$1 = new Uint8Array(16)) {
					this.buf = ArrayBuffer.isView(t$1) ? t$1 : new Uint8Array(t$1), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
				}
				readFields(t$1, e$1, r$1 = this.length) {
					for (; this.pos < r$1;) {
						const r$2 = this.readVarint(), n$1 = r$2 >> 3, i$1 = this.pos;
						this.type = 7 & r$2, t$1(n$1, e$1, this), this.pos === i$1 && this.skip(r$2);
					}
					return e$1;
				}
				readMessage(t$1, e$1) {
					return this.readFields(t$1, e$1, this.readVarint() + this.pos);
				}
				readFixed32() {
					const t$1 = this.dataView.getUint32(this.pos, !0);
					return this.pos += 4, t$1;
				}
				readSFixed32() {
					const t$1 = this.dataView.getInt32(this.pos, !0);
					return this.pos += 4, t$1;
				}
				readFixed64() {
					const t$1 = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * Ac;
					return this.pos += 8, t$1;
				}
				readSFixed64() {
					const t$1 = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * Ac;
					return this.pos += 8, t$1;
				}
				readFloat() {
					const t$1 = this.dataView.getFloat32(this.pos, !0);
					return this.pos += 4, t$1;
				}
				readDouble() {
					const t$1 = this.dataView.getFloat64(this.pos, !0);
					return this.pos += 8, t$1;
				}
				readVarint(t$1) {
					const e$1 = this.buf;
					let r$1, n$1;
					return n$1 = e$1[this.pos++], r$1 = 127 & n$1, n$1 < 128 ? r$1 : (n$1 = e$1[this.pos++], r$1 |= (127 & n$1) << 7, n$1 < 128 ? r$1 : (n$1 = e$1[this.pos++], r$1 |= (127 & n$1) << 14, n$1 < 128 ? r$1 : (n$1 = e$1[this.pos++], r$1 |= (127 & n$1) << 21, n$1 < 128 ? r$1 : (n$1 = e$1[this.pos], r$1 |= (15 & n$1) << 28, function(t$2, e$2, r$2) {
						const n$2 = r$2.buf;
						let i$1, s$1;
						if (s$1 = n$2[r$2.pos++], i$1 = (112 & s$1) >> 4, s$1 < 128) return Ic(t$2, i$1, e$2);
						if (s$1 = n$2[r$2.pos++], i$1 |= (127 & s$1) << 3, s$1 < 128) return Ic(t$2, i$1, e$2);
						if (s$1 = n$2[r$2.pos++], i$1 |= (127 & s$1) << 10, s$1 < 128) return Ic(t$2, i$1, e$2);
						if (s$1 = n$2[r$2.pos++], i$1 |= (127 & s$1) << 17, s$1 < 128) return Ic(t$2, i$1, e$2);
						if (s$1 = n$2[r$2.pos++], i$1 |= (127 & s$1) << 24, s$1 < 128) return Ic(t$2, i$1, e$2);
						if (s$1 = n$2[r$2.pos++], i$1 |= (1 & s$1) << 31, s$1 < 128) return Ic(t$2, i$1, e$2);
						throw new Error("Expected varint not more than 10 bytes");
					}(r$1, t$1, this)))));
				}
				readVarint64() {
					return this.readVarint(!0);
				}
				readSVarint() {
					const t$1 = this.readVarint();
					return t$1 % 2 == 1 ? (t$1 + 1) / -2 : t$1 / 2;
				}
				readBoolean() {
					return Boolean(this.readVarint());
				}
				readString() {
					const t$1 = this.readVarint() + this.pos, e$1 = this.pos;
					return this.pos = t$1, t$1 - e$1 >= 12 && Ec ? Ec.decode(this.buf.subarray(e$1, t$1)) : function(t$2, e$2, r$1) {
						let n$1 = "", i$1 = e$2;
						for (; i$1 < r$1;) {
							const e$3 = t$2[i$1];
							let s$1, a, o$1, l$1 = null, u$1 = e$3 > 239 ? 4 : e$3 > 223 ? 3 : e$3 > 191 ? 2 : 1;
							if (i$1 + u$1 > r$1) break;
							1 === u$1 ? e$3 < 128 && (l$1 = e$3) : 2 === u$1 ? (s$1 = t$2[i$1 + 1], 128 == (192 & s$1) && (l$1 = (31 & e$3) << 6 | 63 & s$1, l$1 <= 127 && (l$1 = null))) : 3 === u$1 ? (s$1 = t$2[i$1 + 1], a = t$2[i$1 + 2], 128 == (192 & s$1) && 128 == (192 & a) && (l$1 = (15 & e$3) << 12 | (63 & s$1) << 6 | 63 & a, (l$1 <= 2047 || l$1 >= 55296 && l$1 <= 57343) && (l$1 = null))) : 4 === u$1 && (s$1 = t$2[i$1 + 1], a = t$2[i$1 + 2], o$1 = t$2[i$1 + 3], 128 == (192 & s$1) && 128 == (192 & a) && 128 == (192 & o$1) && (l$1 = (15 & e$3) << 18 | (63 & s$1) << 12 | (63 & a) << 6 | 63 & o$1, (l$1 <= 65535 || l$1 >= 1114112) && (l$1 = null))), null === l$1 ? (l$1 = 65533, u$1 = 1) : l$1 > 65535 && (l$1 -= 65536, n$1 += String.fromCharCode(l$1 >>> 10 & 1023 | 55296), l$1 = 56320 | 1023 & l$1), n$1 += String.fromCharCode(l$1), i$1 += u$1;
						}
						return n$1;
					}(this.buf, e$1, t$1);
				}
				readBytes() {
					const t$1 = this.readVarint() + this.pos, e$1 = this.buf.subarray(this.pos, t$1);
					return this.pos = t$1, e$1;
				}
				readPackedVarint(t$1 = [], e$1) {
					const r$1 = this.readPackedEnd();
					for (; this.pos < r$1;) t$1.push(this.readVarint(e$1));
					return t$1;
				}
				readPackedSVarint(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readSVarint());
					return t$1;
				}
				readPackedBoolean(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readBoolean());
					return t$1;
				}
				readPackedFloat(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readFloat());
					return t$1;
				}
				readPackedDouble(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readDouble());
					return t$1;
				}
				readPackedFixed32(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readFixed32());
					return t$1;
				}
				readPackedSFixed32(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readSFixed32());
					return t$1;
				}
				readPackedFixed64(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readFixed64());
					return t$1;
				}
				readPackedSFixed64(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readSFixed64());
					return t$1;
				}
				readPackedEnd() {
					return 2 === this.type ? this.readVarint() + this.pos : this.pos + 1;
				}
				skip(t$1) {
					const e$1 = 7 & t$1;
					if (0 === e$1) for (; this.buf[this.pos++] > 127;);
					else if (2 === e$1) this.pos = this.readVarint() + this.pos;
					else if (5 === e$1) this.pos += 4;
					else {
						if (1 !== e$1) throw new Error(`Unimplemented type: ${e$1}`);
						this.pos += 8;
					}
				}
				writeTag(t$1, e$1) {
					this.writeVarint(t$1 << 3 | e$1);
				}
				realloc(t$1) {
					let e$1 = this.length || 16;
					for (; e$1 < this.pos + t$1;) e$1 *= 2;
					if (e$1 !== this.length) {
						const t$2 = new Uint8Array(e$1);
						t$2.set(this.buf), this.buf = t$2, this.dataView = new DataView(t$2.buffer), this.length = e$1;
					}
				}
				finish() {
					return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
				}
				writeFixed32(t$1) {
					this.realloc(4), this.dataView.setInt32(this.pos, t$1, !0), this.pos += 4;
				}
				writeSFixed32(t$1) {
					this.realloc(4), this.dataView.setInt32(this.pos, t$1, !0), this.pos += 4;
				}
				writeFixed64(t$1) {
					this.realloc(8), this.dataView.setInt32(this.pos, -1 & t$1, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t$1 * kc), !0), this.pos += 8;
				}
				writeSFixed64(t$1) {
					this.realloc(8), this.dataView.setInt32(this.pos, -1 & t$1, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t$1 * kc), !0), this.pos += 8;
				}
				writeVarint(t$1) {
					(t$1 = +t$1 || 0) > 268435455 || t$1 < 0 ? function(t$2, e$1) {
						let r$1, n$1;
						if (t$2 >= 0 ? (r$1 = t$2 % 4294967296 | 0, n$1 = t$2 / 4294967296 | 0) : (r$1 = ~(-t$2 % 4294967296), n$1 = ~(-t$2 / 4294967296), 4294967295 ^ r$1 ? r$1 = r$1 + 1 | 0 : (r$1 = 0, n$1 = n$1 + 1 | 0)), t$2 >= 0x10000000000000000 || t$2 < -0x10000000000000000) throw new Error("Given varint doesn't fit into 10 bytes");
						e$1.realloc(10), function(t$3, e$2, r$2) {
							r$2.buf[r$2.pos++] = 127 & t$3 | 128, t$3 >>>= 7, r$2.buf[r$2.pos++] = 127 & t$3 | 128, t$3 >>>= 7, r$2.buf[r$2.pos++] = 127 & t$3 | 128, t$3 >>>= 7, r$2.buf[r$2.pos++] = 127 & t$3 | 128, r$2.buf[r$2.pos] = 127 & (t$3 >>>= 7);
						}(r$1, 0, e$1), function(t$3, e$2) {
							const r$2 = (7 & t$3) << 4;
							e$2.buf[e$2.pos++] |= r$2 | ((t$3 >>>= 3) ? 128 : 0), t$3 && (e$2.buf[e$2.pos++] = 127 & t$3 | ((t$3 >>>= 7) ? 128 : 0), t$3 && (e$2.buf[e$2.pos++] = 127 & t$3 | ((t$3 >>>= 7) ? 128 : 0), t$3 && (e$2.buf[e$2.pos++] = 127 & t$3 | ((t$3 >>>= 7) ? 128 : 0), t$3 && (e$2.buf[e$2.pos++] = 127 & t$3 | ((t$3 >>>= 7) ? 128 : 0), t$3 && (e$2.buf[e$2.pos++] = 127 & t$3)))));
						}(n$1, e$1);
					}(t$1, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t$1 | (t$1 > 127 ? 128 : 0), t$1 <= 127 || (this.buf[this.pos++] = 127 & (t$1 >>>= 7) | (t$1 > 127 ? 128 : 0), t$1 <= 127 || (this.buf[this.pos++] = 127 & (t$1 >>>= 7) | (t$1 > 127 ? 128 : 0), t$1 <= 127 || (this.buf[this.pos++] = t$1 >>> 7 & 127))));
				}
				writeSVarint(t$1) {
					this.writeVarint(t$1 < 0 ? 2 * -t$1 - 1 : 2 * t$1);
				}
				writeBoolean(t$1) {
					this.writeVarint(+t$1);
				}
				writeString(t$1) {
					t$1 = String(t$1), this.realloc(4 * t$1.length), this.pos++;
					const e$1 = this.pos;
					this.pos = function(t$2, e$2, r$2) {
						for (let n$1, i$1, s$1 = 0; s$1 < e$2.length; s$1++) {
							if (n$1 = e$2.charCodeAt(s$1), n$1 > 55295 && n$1 < 57344) {
								if (!i$1) {
									n$1 > 56319 || s$1 + 1 === e$2.length ? (t$2[r$2++] = 239, t$2[r$2++] = 191, t$2[r$2++] = 189) : i$1 = n$1;
									continue;
								}
								if (n$1 < 56320) {
									t$2[r$2++] = 239, t$2[r$2++] = 191, t$2[r$2++] = 189, i$1 = n$1;
									continue;
								}
								n$1 = i$1 - 55296 << 10 | n$1 - 56320 | 65536, i$1 = null;
							} else i$1 && (t$2[r$2++] = 239, t$2[r$2++] = 191, t$2[r$2++] = 189, i$1 = null);
							n$1 < 128 ? t$2[r$2++] = n$1 : (n$1 < 2048 ? t$2[r$2++] = n$1 >> 6 | 192 : (n$1 < 65536 ? t$2[r$2++] = n$1 >> 12 | 224 : (t$2[r$2++] = n$1 >> 18 | 240, t$2[r$2++] = n$1 >> 12 & 63 | 128), t$2[r$2++] = n$1 >> 6 & 63 | 128), t$2[r$2++] = 63 & n$1 | 128);
						}
						return r$2;
					}(this.buf, t$1, this.pos);
					const r$1 = this.pos - e$1;
					r$1 >= 128 && Mc(e$1, r$1, this), this.pos = e$1 - 1, this.writeVarint(r$1), this.pos += r$1;
				}
				writeFloat(t$1) {
					this.realloc(4), this.dataView.setFloat32(this.pos, t$1, !0), this.pos += 4;
				}
				writeDouble(t$1) {
					this.realloc(8), this.dataView.setFloat64(this.pos, t$1, !0), this.pos += 8;
				}
				writeBytes(t$1) {
					const e$1 = t$1.length;
					this.writeVarint(e$1), this.realloc(e$1);
					for (let r$1 = 0; r$1 < e$1; r$1++) this.buf[this.pos++] = t$1[r$1];
				}
				writeRawMessage(t$1, e$1) {
					this.pos++;
					const r$1 = this.pos;
					t$1(e$1, this);
					const n$1 = this.pos - r$1;
					n$1 >= 128 && Mc(r$1, n$1, this), this.pos = r$1 - 1, this.writeVarint(n$1), this.pos += n$1;
				}
				writeMessage(t$1, e$1, r$1) {
					this.writeTag(t$1, 2), this.writeRawMessage(e$1, r$1);
				}
				writePackedVarint(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, Fc, e$1);
				}
				writePackedSVarint(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, Dc, e$1);
				}
				writePackedBoolean(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, Bc, e$1);
				}
				writePackedFloat(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, zc, e$1);
				}
				writePackedDouble(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, Pc, e$1);
				}
				writePackedFixed32(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, Vc, e$1);
				}
				writePackedSFixed32(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, Cc, e$1);
				}
				writePackedFixed64(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, Lc, e$1);
				}
				writePackedSFixed64(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, Oc, e$1);
				}
				writeBytesField(t$1, e$1) {
					this.writeTag(t$1, 2), this.writeBytes(e$1);
				}
				writeFixed32Field(t$1, e$1) {
					this.writeTag(t$1, 5), this.writeFixed32(e$1);
				}
				writeSFixed32Field(t$1, e$1) {
					this.writeTag(t$1, 5), this.writeSFixed32(e$1);
				}
				writeFixed64Field(t$1, e$1) {
					this.writeTag(t$1, 1), this.writeFixed64(e$1);
				}
				writeSFixed64Field(t$1, e$1) {
					this.writeTag(t$1, 1), this.writeSFixed64(e$1);
				}
				writeVarintField(t$1, e$1) {
					this.writeTag(t$1, 0), this.writeVarint(e$1);
				}
				writeSVarintField(t$1, e$1) {
					this.writeTag(t$1, 0), this.writeSVarint(e$1);
				}
				writeStringField(t$1, e$1) {
					this.writeTag(t$1, 2), this.writeString(e$1);
				}
				writeFloatField(t$1, e$1) {
					this.writeTag(t$1, 5), this.writeFloat(e$1);
				}
				writeDoubleField(t$1, e$1) {
					this.writeTag(t$1, 1), this.writeDouble(e$1);
				}
				writeBooleanField(t$1, e$1) {
					this.writeVarintField(t$1, +e$1);
				}
			}
			function Ic(t$1, e$1, r$1) {
				return r$1 ? 4294967296 * e$1 + (t$1 >>> 0) : 4294967296 * (e$1 >>> 0) + (t$1 >>> 0);
			}
			function Mc(t$1, e$1, r$1) {
				const n$1 = e$1 <= 16383 ? 1 : e$1 <= 2097151 ? 2 : e$1 <= 268435455 ? 3 : Math.floor(Math.log(e$1) / (7 * Math.LN2));
				r$1.realloc(n$1);
				for (let e$2 = r$1.pos - 1; e$2 >= t$1; e$2--) r$1.buf[e$2 + n$1] = r$1.buf[e$2];
			}
			function Fc(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeVarint(t$1[r$1]);
			}
			function Dc(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeSVarint(t$1[r$1]);
			}
			function zc(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeFloat(t$1[r$1]);
			}
			function Pc(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeDouble(t$1[r$1]);
			}
			function Bc(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeBoolean(t$1[r$1]);
			}
			function Vc(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeFixed32(t$1[r$1]);
			}
			function Cc(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeSFixed32(t$1[r$1]);
			}
			function Lc(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeFixed64(t$1[r$1]);
			}
			function Oc(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeSFixed64(t$1[r$1]);
			}
			function Rc(t$1, e$1, r$1) {
				1 === t$1 && r$1.readMessage(Nc, e$1);
			}
			function Nc(t$1, e$1, r$1) {
				if (3 === t$1) {
					const { id: t$2, bitmap: n$1, width: i$1, height: s$1, left: a, top: o$1, advance: l$1 } = r$1.readMessage($c, {});
					e$1.push({
						id: t$2,
						bitmap: new _l({
							width: i$1 + 6,
							height: s$1 + 6
						}, n$1),
						metrics: {
							width: i$1,
							height: s$1,
							left: a,
							top: o$1,
							advance: l$1
						}
					});
				}
			}
			function $c(t$1, e$1, r$1) {
				1 === t$1 ? e$1.id = r$1.readVarint() : 2 === t$1 ? e$1.bitmap = r$1.readBytes() : 3 === t$1 ? e$1.width = r$1.readVarint() : 4 === t$1 ? e$1.height = r$1.readVarint() : 5 === t$1 ? e$1.left = r$1.readSVarint() : 6 === t$1 ? e$1.top = r$1.readSVarint() : 7 === t$1 && (e$1.advance = r$1.readVarint());
			}
			function Uc(t$1) {
				let e$1 = 0, r$1 = 0;
				for (const n$2 of t$1) e$1 += n$2.w * n$2.h, r$1 = Math.max(r$1, n$2.w);
				t$1.sort(((t$2, e$2) => e$2.h - t$2.h));
				const n$1 = [{
					x: 0,
					y: 0,
					w: Math.max(Math.ceil(Math.sqrt(e$1 / .95)), r$1),
					h: Infinity
				}];
				let i$1 = 0, s$1 = 0;
				for (const e$2 of t$1) for (let t$2 = n$1.length - 1; t$2 >= 0; t$2--) {
					const r$2 = n$1[t$2];
					if (!(e$2.w > r$2.w || e$2.h > r$2.h)) {
						if (e$2.x = r$2.x, e$2.y = r$2.y, s$1 = Math.max(s$1, e$2.y + e$2.h), i$1 = Math.max(i$1, e$2.x + e$2.w), e$2.w === r$2.w && e$2.h === r$2.h) {
							const e$3 = n$1.pop();
							e$3 && t$2 < n$1.length && (n$1[t$2] = e$3);
						} else e$2.h === r$2.h ? (r$2.x += e$2.w, r$2.w -= e$2.w) : e$2.w === r$2.w ? (r$2.y += e$2.h, r$2.h -= e$2.h) : (n$1.push({
							x: r$2.x + e$2.w,
							y: r$2.y,
							w: r$2.w - e$2.w,
							h: e$2.h
						}), r$2.y += e$2.h, r$2.h -= e$2.h);
						break;
					}
				}
				return {
					w: i$1,
					h: s$1,
					fill: e$1 / (i$1 * s$1) || 0
				};
			}
			class qc {
				constructor(t$1, { pixelRatio: e$1, version: r$1, stretchX: n$1, stretchY: i$1, content: s$1, textFitWidth: a, textFitHeight: o$1 }) {
					this.paddedRect = t$1, this.pixelRatio = e$1, this.stretchX = n$1, this.stretchY = i$1, this.content = s$1, this.version = r$1, this.textFitWidth = a, this.textFitHeight = o$1;
				}
				get tl() {
					return [this.paddedRect.x + 1, this.paddedRect.y + 1];
				}
				get br() {
					return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
				}
				get tlbr() {
					return this.tl.concat(this.br);
				}
				get displaySize() {
					return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
				}
			}
			class jc {
				constructor(t$1, e$1) {
					const r$1 = {}, n$1 = {};
					this.haveRenderCallbacks = [];
					const i$1 = [];
					this.addImages(t$1, r$1, i$1), this.addImages(e$1, n$1, i$1);
					const { w: s$1, h: a } = Uc(i$1), o$1 = new Sl({
						width: s$1 || 1,
						height: a || 1
					});
					for (const e$2 in t$1) {
						const n$2 = t$1[e$2], i$2 = r$1[e$2].paddedRect;
						Sl.copy(n$2.data, o$1, {
							x: 0,
							y: 0
						}, {
							x: i$2.x + 1,
							y: i$2.y + 1
						}, n$2.data);
					}
					for (const t$2 in e$1) {
						const r$2 = e$1[t$2], i$2 = n$1[t$2].paddedRect, s$2 = i$2.x + 1, a$1 = i$2.y + 1, l$1 = r$2.data.width, u$1 = r$2.data.height;
						Sl.copy(r$2.data, o$1, {
							x: 0,
							y: 0
						}, {
							x: s$2,
							y: a$1
						}, r$2.data), Sl.copy(r$2.data, o$1, {
							x: 0,
							y: u$1 - 1
						}, {
							x: s$2,
							y: a$1 - 1
						}, {
							width: l$1,
							height: 1
						}), Sl.copy(r$2.data, o$1, {
							x: 0,
							y: 0
						}, {
							x: s$2,
							y: a$1 + u$1
						}, {
							width: l$1,
							height: 1
						}), Sl.copy(r$2.data, o$1, {
							x: l$1 - 1,
							y: 0
						}, {
							x: s$2 - 1,
							y: a$1
						}, {
							width: 1,
							height: u$1
						}), Sl.copy(r$2.data, o$1, {
							x: 0,
							y: 0
						}, {
							x: s$2 + l$1,
							y: a$1
						}, {
							width: 1,
							height: u$1
						});
					}
					this.image = o$1, this.iconPositions = r$1, this.patternPositions = n$1;
				}
				addImages(t$1, e$1, r$1) {
					for (const n$1 in t$1) {
						const i$1 = t$1[n$1], s$1 = {
							x: 0,
							y: 0,
							w: i$1.data.width + 2,
							h: i$1.data.height + 2
						};
						r$1.push(s$1), e$1[n$1] = new qc(s$1, i$1), i$1.hasRenderCallback && this.haveRenderCallbacks.push(n$1);
					}
				}
				patchUpdatedImages(t$1, e$1) {
					t$1.dispatchRenderCallbacks(this.haveRenderCallbacks);
					for (const r$1 in t$1.updatedImages) this.patchUpdatedImage(this.iconPositions[r$1], t$1.getImage(r$1), e$1), this.patchUpdatedImage(this.patternPositions[r$1], t$1.getImage(r$1), e$1);
				}
				patchUpdatedImage(t$1, e$1, r$1) {
					if (!t$1 || !e$1) return;
					if (t$1.version === e$1.version) return;
					t$1.version = e$1.version;
					const [n$1, i$1] = t$1.tl;
					r$1.update(e$1.data, void 0, {
						x: n$1,
						y: i$1
					});
				}
			}
			var Gc;
			function Xc(e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1) {
				const m$1 = Sc.fromFeature(e$1, s$1);
				let g$1;
				p$1 === t.az.vertical && m$1.verticalizePunctuation();
				let x$1 = m$1.determineLineBreaks(c$1, a, r$1, i$1, d$1);
				const { processBidirectionalText: v$1, processStyledBidirectionalText: b$1 } = zs;
				if (v$1 && 1 === m$1.sections.length) {
					g$1 = [], x$1 = x$1.map(((t$2) => m$1.toCodeUnitIndex(t$2)));
					const t$1 = v$1(m$1.toString(), x$1);
					for (const e$2 of t$1) {
						const t$2 = [...e$2].map((() => 0));
						g$1.push(new Sc(e$2, m$1.sections, t$2));
					}
				} else if (b$1) {
					g$1 = [], x$1 = x$1.map(((t$2) => m$1.toCodeUnitIndex(t$2)));
					let t$1 = 0;
					const e$2 = [];
					for (const r$3 of m$1.text) e$2.push(...Array(r$3.length).fill(m$1.sectionIndex[t$1])), t$1++;
					const r$2 = b$1(m$1.text, e$2, x$1);
					for (const t$2 of r$2) {
						const e$3 = [];
						let r$3 = "";
						for (const n$2 of t$2[0]) e$3.push(t$2[1][r$3.length]), r$3 += n$2;
						g$1.push(new Sc(t$2[0], m$1.sections, e$3));
					}
				} else g$1 = function(t$1, e$2) {
					const r$2 = [];
					let n$2 = 0;
					for (const i$2 of e$2) r$2.push(t$1.substring(n$2, i$2)), n$2 = i$2;
					return n$2 < t$1.length() && r$2.push(t$1.substring(n$2, t$1.length())), r$2;
				}(m$1, x$1);
				const w$1 = [], _$1 = {
					positionedLines: w$1,
					text: m$1.toString(),
					top: h$1[1],
					bottom: h$1[1],
					left: h$1[0],
					right: h$1[0],
					writingMode: p$1,
					iconsInText: !1,
					verticalizable: !1
				};
				return function(t$1, e$2, r$2, n$2, i$2, s$2, a$1, o$2, l$2, u$2, c$2, h$2) {
					let p$2 = 0, f$2 = 0, d$2 = 0, y$2 = 0;
					const m$2 = "right" === o$2 ? 1 : "left" === o$2 ? 0 : .5, g$2 = dc / h$2;
					let x$2 = 0;
					for (const a$2 of i$2) {
						a$2.trim();
						const i$3 = a$2.getMaxScale(), o$3 = {
							positionedGlyphs: [],
							lineOffset: 0
						};
						t$1.positionedLines[x$2] = o$3;
						const h$3 = o$3.positionedGlyphs;
						let v$3 = 0;
						if (!a$2.length()) {
							f$2 += s$2, ++x$2;
							continue;
						}
						const b$3 = Zc(n$2, a$2, g$2);
						let w$2 = 0;
						for (const s$3 of a$2.text) {
							const o$4 = a$2.getSection(w$2), d$3 = s$3.codePointAt(0), y$3 = Kc(l$2, c$2, d$3), m$3 = {
								glyph: d$3,
								imageName: null,
								x: p$2,
								y: f$2 + -17,
								vertical: y$3,
								scale: 1,
								fontStack: "",
								sectionIndex: a$2.getSectionIndex(w$2),
								metrics: null,
								rect: null
							};
							let x$3;
							if ("fontStack" in o$4) {
								if (x$3 = Wc(o$4, d$3, y$3, b$3, e$2, r$2), !x$3) continue;
								m$3.fontStack = o$4.fontStack;
							} else {
								if (t$1.iconsInText = !0, o$4.scale *= g$2, x$3 = Jc(o$4, y$3, i$3, b$3, n$2), !x$3) continue;
								v$3 = Math.max(v$3, x$3.imageOffset), m$3.imageName = o$4.imageName;
							}
							const { rect: _$3, metrics: S$1, baselineOffset: A$1 } = x$3;
							m$3.y += A$1, m$3.scale = o$4.scale, m$3.metrics = S$1, m$3.rect = _$3, h$3.push(m$3), y$3 ? (t$1.verticalizable = !0, p$2 += ("imageName" in o$4 ? S$1.advance : dc) * o$4.scale + u$2) : p$2 += S$1.advance * o$4.scale + u$2, w$2++;
						}
						0 !== h$3.length && (d$2 = Math.max(p$2 - u$2, d$2), Qc(h$3, 0, h$3.length - 1, m$2)), p$2 = 0, o$3.lineOffset = Math.max(v$3, (i$3 - 1) * dc);
						const _$2 = s$2 * i$3 + v$3;
						f$2 += _$2, y$2 = Math.max(_$2, y$2), ++x$2;
					}
					const { horizontalAlign: v$2, verticalAlign: b$2 } = Yc(a$1);
					(function(t$2, e$3, r$3, n$3, i$3, s$3, a$2, o$3, l$3) {
						const u$3 = (e$3 - r$3) * i$3;
						let c$3 = 0;
						c$3 = s$3 !== a$2 ? -o$3 * n$3 - -17 : -n$3 * l$3 * a$2 + .5 * a$2;
						for (const e$4 of t$2) for (const t$3 of e$4.positionedGlyphs) t$3.x += u$3, t$3.y += c$3;
					})(t$1.positionedLines, m$2, v$2, b$2, d$2, y$2, s$2, f$2, i$2.length), t$1.top += -b$2 * f$2, t$1.bottom = t$1.top + f$2, t$1.left += -v$2 * d$2, t$1.right = t$1.left + d$2;
				}(_$1, r$1, n$1, i$1, g$1, o$1, l$1, u$1, p$1, c$1, f$1, y$1), !function(t$1) {
					for (const e$2 of t$1) if (0 !== e$2.positionedGlyphs.length) return !1;
					return !0;
				}(w$1) && _$1;
			}
			function Yc(t$1) {
				let e$1 = .5, r$1 = .5;
				switch (t$1) {
					case "right":
					case "top-right":
					case "bottom-right":
						e$1 = 1;
						break;
					case "left":
					case "top-left":
					case "bottom-left": e$1 = 0;
				}
				switch (t$1) {
					case "bottom":
					case "bottom-right":
					case "bottom-left":
						r$1 = 1;
						break;
					case "top":
					case "top-right":
					case "top-left": r$1 = 0;
				}
				return {
					horizontalAlign: e$1,
					verticalAlign: r$1
				};
			}
			function Zc(t$1, e$1, r$1) {
				const n$1 = e$1.getMaxScale() * dc, { maxImageWidth: i$1, maxImageHeight: s$1 } = e$1.getMaxImageSize(t$1), a = Math.max(n$1, s$1 * r$1);
				return {
					verticalLineContentWidth: Math.max(n$1, i$1 * r$1),
					horizontalLineContentHeight: a
				};
			}
			function Hc(t$1) {
				switch (t$1) {
					case "top": return 0;
					case "center": return .5;
					default: return 1;
				}
			}
			function Kc(e$1, r$1, n$1) {
				return !(e$1 === t.az.horizontal || !r$1 && !bs(n$1) || r$1 && (ws(n$1) || (i$1 = n$1, /\p{sc=Arab}/u.test(String.fromCodePoint(i$1)))));
				var i$1;
			}
			function Wc(t$1, e$1, r$1, n$1, i$1, s$1) {
				const a = s$1[t$1.fontStack], o$1 = function(t$2, e$2, r$2, n$2) {
					if (t$2 && t$2.rect) return t$2;
					const i$2 = e$2[r$2.fontStack], s$2 = i$2 && i$2[n$2];
					return s$2 ? {
						rect: null,
						metrics: s$2.metrics
					} : null;
				}(a && a[e$1], i$1, t$1, e$1);
				if (null === o$1) return null;
				let l$1;
				if (r$1) l$1 = n$1.verticalLineContentWidth - t$1.scale * dc;
				else {
					const e$2 = Hc(t$1.verticalAlign);
					l$1 = (n$1.horizontalLineContentHeight - t$1.scale * dc) * e$2;
				}
				return {
					rect: o$1.rect,
					metrics: o$1.metrics,
					baselineOffset: l$1
				};
			}
			function Jc(t$1, e$1, r$1, n$1, i$1) {
				const s$1 = i$1[t$1.imageName];
				if (!s$1) return null;
				const a = s$1.paddedRect, o$1 = s$1.displaySize, l$1 = {
					width: o$1[0],
					height: o$1[1],
					left: 1,
					top: -3,
					advance: e$1 ? o$1[1] : o$1[0]
				};
				let u$1;
				if (e$1) u$1 = n$1.verticalLineContentWidth - o$1[1] * t$1.scale;
				else {
					const e$2 = Hc(t$1.verticalAlign);
					u$1 = (n$1.horizontalLineContentHeight - o$1[1] * t$1.scale) * e$2;
				}
				return {
					rect: a,
					metrics: l$1,
					baselineOffset: u$1,
					imageOffset: (e$1 ? o$1[0] : o$1[1]) * t$1.scale - dc * r$1
				};
			}
			function Qc(t$1, e$1, r$1, n$1) {
				if (0 === n$1) return;
				const i$1 = t$1[r$1], s$1 = (t$1[r$1].x + i$1.metrics.advance * i$1.scale) * n$1;
				for (let n$2 = e$1; n$2 <= r$1; n$2++) t$1[n$2].x -= s$1;
			}
			function th(t$1, e$1, r$1) {
				const { horizontalAlign: n$1, verticalAlign: i$1 } = Yc(r$1), s$1 = e$1[0] - t$1.displaySize[0] * n$1, a = e$1[1] - t$1.displaySize[1] * i$1;
				return {
					image: t$1,
					top: a,
					bottom: a + t$1.displaySize[1],
					left: s$1,
					right: s$1 + t$1.displaySize[0]
				};
			}
			function eh(t$1) {
				var e$1, r$1;
				let n$1 = t$1.left, i$1 = t$1.top, s$1 = t$1.right - n$1, a = t$1.bottom - i$1;
				const o$1 = null !== (e$1 = t$1.image.textFitWidth) && void 0 !== e$1 ? e$1 : "stretchOrShrink", l$1 = null !== (r$1 = t$1.image.textFitHeight) && void 0 !== r$1 ? r$1 : "stretchOrShrink", u$1 = (t$1.image.content[2] - t$1.image.content[0]) / (t$1.image.content[3] - t$1.image.content[1]);
				if ("proportional" === l$1) {
					if ("stretchOnly" === o$1 && s$1 / a < u$1 || "proportional" === o$1) {
						const t$2 = Math.ceil(a * u$1);
						n$1 *= t$2 / s$1, s$1 = t$2;
					}
				} else if ("proportional" === o$1 && "stretchOnly" === l$1 && 0 !== u$1 && s$1 / a > u$1) {
					const t$2 = Math.ceil(s$1 / u$1);
					i$1 *= t$2 / a, a = t$2;
				}
				return {
					x1: n$1,
					y1: i$1,
					x2: n$1 + s$1,
					y2: i$1 + a
				};
			}
			function rh(t$1, e$1, r$1, n$1, i$1, s$1) {
				const a = t$1.image;
				let o$1;
				if (a.content) {
					const t$2 = a.content, e$2 = a.pixelRatio || 1;
					o$1 = [
						t$2[0] / e$2,
						t$2[1] / e$2,
						a.displaySize[0] - t$2[2] / e$2,
						a.displaySize[1] - t$2[3] / e$2
					];
				}
				const l$1 = e$1.left * s$1, u$1 = e$1.right * s$1;
				let c$1, h$1, p$1, f$1;
				"width" === r$1 || "both" === r$1 ? (f$1 = i$1[0] + l$1 - n$1[3], h$1 = i$1[0] + u$1 + n$1[1]) : (f$1 = i$1[0] + (l$1 + u$1 - a.displaySize[0]) / 2, h$1 = f$1 + a.displaySize[0]);
				const d$1 = e$1.top * s$1, y$1 = e$1.bottom * s$1;
				return "height" === r$1 || "both" === r$1 ? (c$1 = i$1[1] + d$1 - n$1[0], p$1 = i$1[1] + y$1 + n$1[2]) : (c$1 = i$1[1] + (d$1 + y$1 - a.displaySize[1]) / 2, p$1 = c$1 + a.displaySize[1]), {
					image: a,
					top: c$1,
					right: h$1,
					bottom: p$1,
					left: f$1,
					collisionPadding: o$1
				};
			}
			ps("ImagePosition", qc), ps("ImageAtlas", jc), t.az = void 0, (Gc = t.az || (t.az = {}))[Gc.none = 0] = "none", Gc[Gc.horizontal = 1] = "horizontal", Gc[Gc.vertical = 2] = "vertical", Gc[Gc.horizontalOnly = 3] = "horizontalOnly";
			const nh = 128, ih = 32640;
			function sh(t$1, e$1) {
				const { expression: r$1 } = e$1;
				if ("constant" === r$1.kind) return {
					kind: "constant",
					layoutSize: r$1.evaluate(new Ps(t$1 + 1))
				};
				if ("source" === r$1.kind) return { kind: "source" };
				{
					const { zoomStops: e$2, interpolationType: n$1 } = r$1;
					let i$1 = 0;
					for (; i$1 < e$2.length && e$2[i$1] <= t$1;) i$1++;
					i$1 = Math.max(0, i$1 - 1);
					let s$1 = i$1;
					for (; s$1 < e$2.length && e$2[s$1] < t$1 + 1;) s$1++;
					s$1 = Math.min(e$2.length - 1, s$1);
					const a = e$2[i$1], o$1 = e$2[s$1];
					return "composite" === r$1.kind ? {
						kind: "composite",
						minZoom: a,
						maxZoom: o$1,
						interpolationType: n$1
					} : {
						kind: "camera",
						minZoom: a,
						maxZoom: o$1,
						minSize: r$1.evaluate(new Ps(a)),
						maxSize: r$1.evaluate(new Ps(o$1)),
						interpolationType: n$1
					};
				}
			}
			function ah(t$1, e$1, r$1) {
				let n$1 = "never";
				const i$1 = t$1.get(e$1);
				return i$1 ? n$1 = i$1 : t$1.get(r$1) && (n$1 = "always"), n$1;
			}
			const oh = [{
				name: "a_fade_opacity",
				components: 1,
				type: "Uint8",
				offset: 0
			}];
			function lh(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1) {
				const f$1 = o$1 ? Math.min(ih, Math.round(o$1[0])) : 0, d$1 = o$1 ? Math.min(ih, Math.round(o$1[1])) : 0;
				t$1.emplaceBack(e$1, r$1, Math.round(32 * n$1), Math.round(32 * i$1), s$1, a, (f$1 << 1) + (l$1 ? 1 : 0), d$1, 16 * u$1, 16 * c$1, 256 * h$1, 256 * p$1);
			}
			function uh(t$1, e$1, r$1) {
				t$1.emplaceBack(e$1.x, e$1.y, r$1), t$1.emplaceBack(e$1.x, e$1.y, r$1), t$1.emplaceBack(e$1.x, e$1.y, r$1), t$1.emplaceBack(e$1.x, e$1.y, r$1);
			}
			function ch(t$1) {
				for (const e$1 of t$1.sections) if (Ds(e$1.text)) return !0;
				return !1;
			}
			class hh {
				constructor(t$1) {
					this.layoutVertexArray = new Ha(), this.indexArray = new to(), this.programConfigurations = t$1, this.segments = new io(), this.dynamicLayoutVertexArray = new Ka(), this.opacityVertexArray = new Wa(), this.hasVisibleVertices = !1, this.placedSymbolArray = new za();
				}
				isEmpty() {
					return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
				}
				upload(t$1, e$1, r$1, n$1) {
					this.isEmpty() || (r$1 && (this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, lc.members), this.indexBuffer = t$1.createIndexBuffer(this.indexArray, e$1), this.dynamicLayoutVertexBuffer = t$1.createVertexBuffer(this.dynamicLayoutVertexArray, uc.members, !0), this.opacityVertexBuffer = t$1.createVertexBuffer(this.opacityVertexArray, oh, !0), this.opacityVertexBuffer.itemSize = 1), (r$1 || n$1) && this.programConfigurations.upload(t$1));
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
				}
			}
			ps("SymbolBuffers", hh);
			class ph {
				constructor(t$1, e$1, r$1) {
					this.layoutVertexArray = new t$1(), this.layoutAttributes = e$1, this.indexArray = new r$1(), this.segments = new io(), this.collisionVertexArray = new Qa();
				}
				upload(t$1) {
					this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t$1.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t$1.createVertexBuffer(this.collisionVertexArray, cc.members, !0);
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
				}
			}
			ps("CollisionBuffers", ph);
			class fh {
				constructor(e$1) {
					this.collisionBoxArray = e$1.collisionBoxArray, this.zoom = e$1.zoom, this.overscaling = e$1.overscaling, this.layers = e$1.layers, this.layerIds = this.layers.map(((t$1) => t$1.id)), this.index = e$1.index, this.pixelRatio = e$1.pixelRatio, this.sourceLayerIndex = e$1.sourceLayerIndex, this.hasDependencies = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
					const r$1 = this.layers[0]._unevaluatedLayout._values;
					this.textSizeData = sh(this.zoom, r$1["text-size"]), this.iconSizeData = sh(this.zoom, r$1["icon-size"]);
					const n$1 = this.layers[0].layout, i$1 = n$1.get("symbol-sort-key"), s$1 = n$1.get("symbol-z-order");
					this.canOverlap = "never" !== ah(n$1, "text-overlap", "text-allow-overlap") || "never" !== ah(n$1, "icon-overlap", "icon-allow-overlap") || n$1.get("text-ignore-placement") || n$1.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== s$1 && !i$1.isConstant(), this.sortFeaturesByY = ("viewport-y" === s$1 || "auto" === s$1 && !this.sortFeaturesByKey) && this.canOverlap, "point" === n$1.get("symbol-placement") && (this.writingModes = n$1.get("text-writing-mode").map(((e$2) => t.az[e$2]))), this.stateDependentLayerIds = this.layers.filter(((t$1) => t$1.isStateDependent())).map(((t$1) => t$1.id)), this.sourceID = e$1.sourceID;
				}
				createArrays() {
					this.text = new hh(new Vo(this.layers, this.zoom, ((t$1) => /^text/.test(t$1)))), this.icon = new hh(new Vo(this.layers, this.zoom, ((t$1) => /^icon/.test(t$1)))), this.glyphOffsetArray = new Va(), this.lineVertexArray = new Ca(), this.symbolInstances = new Ba(), this.textAnchorOffsets = new Oa();
				}
				calculateGlyphDependencies(t$1, e$1, r$1, n$1, i$1) {
					for (const s$1 of t$1) if (e$1[s$1.codePointAt(0)] = !0, (r$1 || n$1) && i$1) {
						const t$2 = yc[s$1];
						t$2 && (e$1[t$2.codePointAt(0)] = !0);
					}
				}
				populate(e$1, r$1, n$1) {
					const i$1 = this.layers[0], s$1 = i$1.layout, a = s$1.get("text-font"), o$1 = s$1.get("text-field"), l$1 = s$1.get("icon-image"), u$1 = ("constant" !== o$1.value.kind || o$1.value.value instanceof De && !o$1.value.value.isEmpty() || o$1.value.value.toString().length > 0) && ("constant" !== a.value.kind || a.value.value.length > 0), c$1 = "constant" !== l$1.value.kind || !!l$1.value.value || Object.keys(l$1.parameters).length > 0, h$1 = s$1.get("symbol-sort-key");
					if (this.features = [], !u$1 && !c$1) return;
					const p$1 = r$1.iconDependencies, f$1 = r$1.glyphDependencies, d$1 = r$1.availableImages, y$1 = new Ps(this.zoom);
					for (const { feature: r$2, id: o$2, index: l$2, sourceLayerIndex: m$1 } of e$1) {
						const e$2 = i$1._featureFilter.needGeometry, g$1 = $o(r$2, e$2);
						if (!i$1._featureFilter.filter(y$1, g$1, n$1)) continue;
						let x$1, v$1;
						if (e$2 || (g$1.geometry = No(r$2)), u$1) {
							const t$1 = i$1.getValueAndResolveTokens("text-field", g$1, n$1, d$1), e$3 = De.factory(t$1), r$3 = this.hasRTLText = this.hasRTLText || ch(e$3);
							(!r$3 || "unavailable" === zs.getRTLTextPluginStatus() || r$3 && zs.isParsed()) && (x$1 = fc(e$3, i$1, g$1));
						}
						if (c$1) {
							const t$1 = i$1.getValueAndResolveTokens("icon-image", g$1, n$1, d$1);
							v$1 = t$1 instanceof Oe ? t$1 : Oe.fromString(t$1);
						}
						if (!x$1 && !v$1) continue;
						const b$1 = this.sortFeaturesByKey ? h$1.evaluate(g$1, {}, n$1) : void 0;
						if (this.features.push({
							id: o$2,
							text: x$1,
							icon: v$1,
							index: l$2,
							sourceLayerIndex: m$1,
							geometry: g$1.geometry,
							properties: r$2.properties,
							type: Mu.types[r$2.type],
							sortKey: b$1
						}), v$1 && (p$1[v$1.name] = !0), x$1) {
							const e$3 = a.evaluate(g$1, {}, n$1).join(","), r$3 = "viewport" !== s$1.get("text-rotation-alignment") && "point" !== s$1.get("symbol-placement");
							this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(t.az.vertical) >= 0;
							for (const t$1 of x$1.sections) if (t$1.image) p$1[t$1.image.name] = !0;
							else {
								const n$2 = _s(x$1.toString()), i$2 = t$1.fontStack || e$3, s$2 = f$1[i$2] = f$1[i$2] || {};
								this.calculateGlyphDependencies(t$1.text, s$2, r$3, this.allowVerticalPlacement, n$2);
							}
						}
					}
					"line" === s$1.get("symbol-placement") && (this.features = function(t$1) {
						const e$2 = {}, r$2 = {}, n$2 = [];
						let i$2 = 0;
						function s$2(e$3) {
							n$2.push(t$1[e$3]), i$2++;
						}
						function a$1(t$2, e$3, i$3) {
							const s$3 = r$2[t$2];
							return delete r$2[t$2], r$2[e$3] = s$3, n$2[s$3].geometry[0].pop(), n$2[s$3].geometry[0] = n$2[s$3].geometry[0].concat(i$3[0]), s$3;
						}
						function o$2(t$2, r$3, i$3) {
							const s$3 = e$2[r$3];
							return delete e$2[r$3], e$2[t$2] = s$3, n$2[s$3].geometry[0].shift(), n$2[s$3].geometry[0] = i$3[0].concat(n$2[s$3].geometry[0]), s$3;
						}
						function l$2(t$2, e$3, r$3) {
							const n$3 = r$3 ? e$3[0][e$3[0].length - 1] : e$3[0][0];
							return `${t$2}:${n$3.x}:${n$3.y}`;
						}
						for (let u$2 = 0; u$2 < t$1.length; u$2++) {
							const c$2 = t$1[u$2], h$2 = c$2.geometry, p$2 = c$2.text ? c$2.text.toString() : null;
							if (!p$2) {
								s$2(u$2);
								continue;
							}
							const f$2 = l$2(p$2, h$2), d$2 = l$2(p$2, h$2, !0);
							if (f$2 in r$2 && d$2 in e$2 && r$2[f$2] !== e$2[d$2]) {
								const t$2 = o$2(f$2, d$2, h$2), i$3 = a$1(f$2, d$2, n$2[t$2].geometry);
								delete e$2[f$2], delete r$2[d$2], r$2[l$2(p$2, n$2[i$3].geometry, !0)] = i$3, n$2[t$2].geometry = null;
							} else f$2 in r$2 ? a$1(f$2, d$2, h$2) : d$2 in e$2 ? o$2(f$2, d$2, h$2) : (s$2(u$2), e$2[f$2] = i$2 - 1, r$2[d$2] = i$2 - 1);
						}
						return n$2.filter(((t$2) => t$2.geometry));
					}(this.features)), this.sortFeaturesByKey && this.features.sort(((t$1, e$2) => t$1.sortKey - e$2.sortKey));
				}
				update(t$1, e$1, r$1) {
					this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t$1, e$1, this.layers, { imagePositions: r$1 }), this.icon.programConfigurations.updatePaintArrays(t$1, e$1, this.layers, { imagePositions: r$1 }));
				}
				isEmpty() {
					return 0 === this.symbolInstances.length && !this.hasRTLText;
				}
				uploadPending() {
					return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
				}
				upload(t$1) {
					!this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t$1), this.iconCollisionBox.upload(t$1)), this.text.upload(t$1, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t$1, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
				}
				destroyDebugData() {
					this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
				}
				destroy() {
					this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
				}
				addToLineVertexArray(t$1, e$1) {
					const r$1 = this.lineVertexArray.length;
					if (void 0 !== t$1.segment) {
						let r$2 = t$1.dist(e$1[t$1.segment + 1]), n$1 = t$1.dist(e$1[t$1.segment]);
						const i$1 = {};
						for (let n$2 = t$1.segment + 1; n$2 < e$1.length; n$2++) i$1[n$2] = {
							x: e$1[n$2].x,
							y: e$1[n$2].y,
							tileUnitDistanceFromAnchor: r$2
						}, n$2 < e$1.length - 1 && (r$2 += e$1[n$2 + 1].dist(e$1[n$2]));
						for (let r$3 = t$1.segment || 0; r$3 >= 0; r$3--) i$1[r$3] = {
							x: e$1[r$3].x,
							y: e$1[r$3].y,
							tileUnitDistanceFromAnchor: n$1
						}, r$3 > 0 && (n$1 += e$1[r$3 - 1].dist(e$1[r$3]));
						for (let t$2 = 0; t$2 < e$1.length; t$2++) {
							const e$2 = i$1[t$2];
							this.lineVertexArray.emplaceBack(e$2.x, e$2.y, e$2.tileUnitDistanceFromAnchor);
						}
					}
					return {
						lineStartIndex: r$1,
						lineLength: this.lineVertexArray.length - r$1
					};
				}
				addSymbols(e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1) {
					const f$1 = e$1.indexArray, d$1 = e$1.layoutVertexArray, y$1 = e$1.segments.prepareSegment(4 * r$1.length, d$1, f$1, this.canOverlap ? a.sortKey : void 0), m$1 = this.glyphOffsetArray.length, g$1 = y$1.vertexLength, x$1 = this.allowVerticalPlacement && o$1 === t.az.vertical ? Math.PI / 2 : 0, v$1 = a.text && a.text.sections;
					for (let t$1 = 0; t$1 < r$1.length; t$1++) {
						const { tl: i$2, tr: s$2, bl: o$2, br: u$2, tex: c$2, pixelOffsetTL: h$2, pixelOffsetBR: m$2, minFontScaleX: g$2, minFontScaleY: b$1, glyphOffset: w$1, isSDF: _$1, sectionIndex: S$1 } = r$1[t$1], A$1 = y$1.vertexLength, k$1 = w$1[1];
						lh(d$1, l$1.x, l$1.y, i$2.x, k$1 + i$2.y, c$2.x, c$2.y, n$1, _$1, h$2.x, h$2.y, g$2, b$1), lh(d$1, l$1.x, l$1.y, s$2.x, k$1 + s$2.y, c$2.x + c$2.w, c$2.y, n$1, _$1, m$2.x, h$2.y, g$2, b$1), lh(d$1, l$1.x, l$1.y, o$2.x, k$1 + o$2.y, c$2.x, c$2.y + c$2.h, n$1, _$1, h$2.x, m$2.y, g$2, b$1), lh(d$1, l$1.x, l$1.y, u$2.x, k$1 + u$2.y, c$2.x + c$2.w, c$2.y + c$2.h, n$1, _$1, m$2.x, m$2.y, g$2, b$1), uh(e$1.dynamicLayoutVertexArray, l$1, x$1), f$1.emplaceBack(A$1, A$1 + 2, A$1 + 1), f$1.emplaceBack(A$1 + 1, A$1 + 2, A$1 + 3), y$1.vertexLength += 4, y$1.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w$1[0]), t$1 !== r$1.length - 1 && S$1 === r$1[t$1 + 1].sectionIndex || e$1.programConfigurations.populatePaintArrays(d$1.length, a, a.index, {
							imagePositions: {},
							canonical: p$1,
							formattedSection: v$1 && v$1[S$1]
						});
					}
					e$1.placedSymbolArray.emplaceBack(l$1.x, l$1.y, m$1, this.glyphOffsetArray.length - m$1, g$1, u$1, c$1, l$1.segment, n$1 ? n$1[0] : 0, n$1 ? n$1[1] : 0, i$1[0], i$1[1], o$1, 0, !1, 0, h$1);
				}
				_addCollisionDebugVertex(t$1, e$1, r$1, n$1, i$1, s$1) {
					return e$1.emplaceBack(0, 0), t$1.emplaceBack(r$1.x, r$1.y, n$1, i$1, Math.round(s$1.x), Math.round(s$1.y));
				}
				addCollisionDebugVertices(t$1, e$1, n$1, i$1, s$1, a, o$1) {
					const l$1 = s$1.segments.prepareSegment(4, s$1.layoutVertexArray, s$1.indexArray), u$1 = l$1.vertexLength, c$1 = s$1.layoutVertexArray, h$1 = s$1.collisionVertexArray, p$1 = o$1.anchorX, f$1 = o$1.anchorY;
					this._addCollisionDebugVertex(c$1, h$1, a, p$1, f$1, new r(t$1, e$1)), this._addCollisionDebugVertex(c$1, h$1, a, p$1, f$1, new r(n$1, e$1)), this._addCollisionDebugVertex(c$1, h$1, a, p$1, f$1, new r(n$1, i$1)), this._addCollisionDebugVertex(c$1, h$1, a, p$1, f$1, new r(t$1, i$1)), l$1.vertexLength += 4;
					const d$1 = s$1.indexArray;
					d$1.emplaceBack(u$1, u$1 + 1), d$1.emplaceBack(u$1 + 1, u$1 + 2), d$1.emplaceBack(u$1 + 2, u$1 + 3), d$1.emplaceBack(u$1 + 3, u$1), l$1.primitiveLength += 4;
				}
				addDebugCollisionBoxes(t$1, e$1, r$1, n$1) {
					for (let i$1 = t$1; i$1 < e$1; i$1++) {
						const t$2 = this.collisionBoxArray.get(i$1);
						this.addCollisionDebugVertices(t$2.x1, t$2.y1, t$2.x2, t$2.y2, n$1 ? this.textCollisionBox : this.iconCollisionBox, t$2.anchorPoint, r$1);
					}
				}
				generateCollisionDebugBuffers() {
					this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new ph(Ja, hc.members, eo), this.iconCollisionBox = new ph(Ja, hc.members, eo);
					for (let t$1 = 0; t$1 < this.symbolInstances.length; t$1++) {
						const e$1 = this.symbolInstances.get(t$1);
						this.addDebugCollisionBoxes(e$1.textBoxStartIndex, e$1.textBoxEndIndex, e$1, !0), this.addDebugCollisionBoxes(e$1.verticalTextBoxStartIndex, e$1.verticalTextBoxEndIndex, e$1, !0), this.addDebugCollisionBoxes(e$1.iconBoxStartIndex, e$1.iconBoxEndIndex, e$1, !1), this.addDebugCollisionBoxes(e$1.verticalIconBoxStartIndex, e$1.verticalIconBoxEndIndex, e$1, !1);
					}
				}
				_deserializeCollisionBoxesForSymbol(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1) {
					const u$1 = {};
					for (let n$2 = e$1; n$2 < r$1; n$2++) {
						const e$2 = t$1.get(n$2);
						u$1.textBox = {
							x1: e$2.x1,
							y1: e$2.y1,
							x2: e$2.x2,
							y2: e$2.y2,
							anchorPointX: e$2.anchorPointX,
							anchorPointY: e$2.anchorPointY
						}, u$1.textFeatureIndex = e$2.featureIndex;
						break;
					}
					for (let e$2 = n$1; e$2 < i$1; e$2++) {
						const r$2 = t$1.get(e$2);
						u$1.verticalTextBox = {
							x1: r$2.x1,
							y1: r$2.y1,
							x2: r$2.x2,
							y2: r$2.y2,
							anchorPointX: r$2.anchorPointX,
							anchorPointY: r$2.anchorPointY
						}, u$1.verticalTextFeatureIndex = r$2.featureIndex;
						break;
					}
					for (let e$2 = s$1; e$2 < a; e$2++) {
						const r$2 = t$1.get(e$2);
						u$1.iconBox = {
							x1: r$2.x1,
							y1: r$2.y1,
							x2: r$2.x2,
							y2: r$2.y2,
							anchorPointX: r$2.anchorPointX,
							anchorPointY: r$2.anchorPointY
						}, u$1.iconFeatureIndex = r$2.featureIndex;
						break;
					}
					for (let e$2 = o$1; e$2 < l$1; e$2++) {
						const r$2 = t$1.get(e$2);
						u$1.verticalIconBox = {
							x1: r$2.x1,
							y1: r$2.y1,
							x2: r$2.x2,
							y2: r$2.y2,
							anchorPointX: r$2.anchorPointX,
							anchorPointY: r$2.anchorPointY
						}, u$1.verticalIconFeatureIndex = r$2.featureIndex;
						break;
					}
					return u$1;
				}
				deserializeCollisionBoxes(t$1) {
					this.collisionArrays = [];
					for (let e$1 = 0; e$1 < this.symbolInstances.length; e$1++) {
						const r$1 = this.symbolInstances.get(e$1);
						this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t$1, r$1.textBoxStartIndex, r$1.textBoxEndIndex, r$1.verticalTextBoxStartIndex, r$1.verticalTextBoxEndIndex, r$1.iconBoxStartIndex, r$1.iconBoxEndIndex, r$1.verticalIconBoxStartIndex, r$1.verticalIconBoxEndIndex));
					}
				}
				hasTextData() {
					return this.text.segments.get().length > 0;
				}
				hasIconData() {
					return this.icon.segments.get().length > 0;
				}
				hasDebugData() {
					return this.textCollisionBox && this.iconCollisionBox;
				}
				hasTextCollisionBoxData() {
					return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
				}
				hasIconCollisionBoxData() {
					return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
				}
				addIndicesForPlacedSymbol(t$1, e$1) {
					const r$1 = t$1.placedSymbolArray.get(e$1), n$1 = r$1.vertexStartIndex + 4 * r$1.numGlyphs;
					for (let e$2 = r$1.vertexStartIndex; e$2 < n$1; e$2 += 4) t$1.indexArray.emplaceBack(e$2, e$2 + 2, e$2 + 1), t$1.indexArray.emplaceBack(e$2 + 1, e$2 + 2, e$2 + 3);
				}
				getSortedSymbolIndexes(t$1) {
					if (this.sortedAngle === t$1 && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
					const e$1 = Math.sin(t$1), r$1 = Math.cos(t$1), n$1 = [], i$1 = [], s$1 = [];
					for (let t$2 = 0; t$2 < this.symbolInstances.length; ++t$2) {
						s$1.push(t$2);
						const a = this.symbolInstances.get(t$2);
						n$1.push(0 | Math.round(e$1 * a.anchorX + r$1 * a.anchorY)), i$1.push(a.featureIndex);
					}
					return s$1.sort(((t$2, e$2) => n$1[t$2] - n$1[e$2] || i$1[e$2] - i$1[t$2])), s$1;
				}
				addToSortKeyRanges(t$1, e$1) {
					const r$1 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
					r$1 && r$1.sortKey === e$1 ? r$1.symbolInstanceEnd = t$1 + 1 : this.sortKeyRanges.push({
						sortKey: e$1,
						symbolInstanceStart: t$1,
						symbolInstanceEnd: t$1 + 1
					});
				}
				sortFeatures(t$1) {
					if (this.sortFeaturesByY && this.sortedAngle !== t$1 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
						this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t$1), this.sortedAngle = t$1, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
						for (const t$2 of this.symbolInstanceIndexes) {
							const e$1 = this.symbolInstances.get(t$2);
							this.featureSortOrder.push(e$1.featureIndex), [
								e$1.rightJustifiedTextSymbolIndex,
								e$1.centerJustifiedTextSymbolIndex,
								e$1.leftJustifiedTextSymbolIndex
							].forEach(((t$3, e$2, r$1) => {
								t$3 >= 0 && r$1.indexOf(t$3) === e$2 && this.addIndicesForPlacedSymbol(this.text, t$3);
							})), e$1.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e$1.verticalPlacedTextSymbolIndex), e$1.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e$1.placedIconSymbolIndex), e$1.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e$1.verticalPlacedIconSymbolIndex);
						}
						this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
					}
				}
			}
			let dh, yh;
			ps("SymbolBucket", fh, { omit: [
				"layers",
				"collisionBoxArray",
				"features",
				"compareText"
			] }), fh.MAX_GLYPHS = 65535, fh.addDynamicAttributes = uh;
			var mh = {
				get paint() {
					return yh = yh || new Hs({
						"icon-opacity": new Gs(vt.paint_symbol["icon-opacity"]),
						"icon-color": new Gs(vt.paint_symbol["icon-color"]),
						"icon-halo-color": new Gs(vt.paint_symbol["icon-halo-color"]),
						"icon-halo-width": new Gs(vt.paint_symbol["icon-halo-width"]),
						"icon-halo-blur": new Gs(vt.paint_symbol["icon-halo-blur"]),
						"icon-translate": new js(vt.paint_symbol["icon-translate"]),
						"icon-translate-anchor": new js(vt.paint_symbol["icon-translate-anchor"]),
						"text-opacity": new Gs(vt.paint_symbol["text-opacity"]),
						"text-color": new Gs(vt.paint_symbol["text-color"], {
							runtimeType: Rt,
							getOverride: (t$1) => t$1.textColor,
							hasOverride: (t$1) => !!t$1.textColor
						}),
						"text-halo-color": new Gs(vt.paint_symbol["text-halo-color"]),
						"text-halo-width": new Gs(vt.paint_symbol["text-halo-width"]),
						"text-halo-blur": new Gs(vt.paint_symbol["text-halo-blur"]),
						"text-translate": new js(vt.paint_symbol["text-translate"]),
						"text-translate-anchor": new js(vt.paint_symbol["text-translate-anchor"])
					});
				},
				get layout() {
					return dh = dh || new Hs({
						"symbol-placement": new js(vt.layout_symbol["symbol-placement"]),
						"symbol-spacing": new js(vt.layout_symbol["symbol-spacing"]),
						"symbol-avoid-edges": new js(vt.layout_symbol["symbol-avoid-edges"]),
						"symbol-sort-key": new Gs(vt.layout_symbol["symbol-sort-key"]),
						"symbol-z-order": new js(vt.layout_symbol["symbol-z-order"]),
						"icon-allow-overlap": new js(vt.layout_symbol["icon-allow-overlap"]),
						"icon-overlap": new js(vt.layout_symbol["icon-overlap"]),
						"icon-ignore-placement": new js(vt.layout_symbol["icon-ignore-placement"]),
						"icon-optional": new js(vt.layout_symbol["icon-optional"]),
						"icon-rotation-alignment": new js(vt.layout_symbol["icon-rotation-alignment"]),
						"icon-size": new Gs(vt.layout_symbol["icon-size"]),
						"icon-text-fit": new js(vt.layout_symbol["icon-text-fit"]),
						"icon-text-fit-padding": new js(vt.layout_symbol["icon-text-fit-padding"]),
						"icon-image": new Gs(vt.layout_symbol["icon-image"]),
						"icon-rotate": new Gs(vt.layout_symbol["icon-rotate"]),
						"icon-padding": new Gs(vt.layout_symbol["icon-padding"]),
						"icon-keep-upright": new js(vt.layout_symbol["icon-keep-upright"]),
						"icon-offset": new Gs(vt.layout_symbol["icon-offset"]),
						"icon-anchor": new Gs(vt.layout_symbol["icon-anchor"]),
						"icon-pitch-alignment": new js(vt.layout_symbol["icon-pitch-alignment"]),
						"text-pitch-alignment": new js(vt.layout_symbol["text-pitch-alignment"]),
						"text-rotation-alignment": new js(vt.layout_symbol["text-rotation-alignment"]),
						"text-field": new Gs(vt.layout_symbol["text-field"]),
						"text-font": new Gs(vt.layout_symbol["text-font"]),
						"text-size": new Gs(vt.layout_symbol["text-size"]),
						"text-max-width": new Gs(vt.layout_symbol["text-max-width"]),
						"text-line-height": new js(vt.layout_symbol["text-line-height"]),
						"text-letter-spacing": new Gs(vt.layout_symbol["text-letter-spacing"]),
						"text-justify": new Gs(vt.layout_symbol["text-justify"]),
						"text-radial-offset": new Gs(vt.layout_symbol["text-radial-offset"]),
						"text-variable-anchor": new js(vt.layout_symbol["text-variable-anchor"]),
						"text-variable-anchor-offset": new Gs(vt.layout_symbol["text-variable-anchor-offset"]),
						"text-anchor": new Gs(vt.layout_symbol["text-anchor"]),
						"text-max-angle": new js(vt.layout_symbol["text-max-angle"]),
						"text-writing-mode": new js(vt.layout_symbol["text-writing-mode"]),
						"text-rotate": new Gs(vt.layout_symbol["text-rotate"]),
						"text-padding": new js(vt.layout_symbol["text-padding"]),
						"text-keep-upright": new js(vt.layout_symbol["text-keep-upright"]),
						"text-transform": new Gs(vt.layout_symbol["text-transform"]),
						"text-offset": new Gs(vt.layout_symbol["text-offset"]),
						"text-allow-overlap": new js(vt.layout_symbol["text-allow-overlap"]),
						"text-overlap": new js(vt.layout_symbol["text-overlap"]),
						"text-ignore-placement": new js(vt.layout_symbol["text-ignore-placement"]),
						"text-optional": new js(vt.layout_symbol["text-optional"])
					});
				}
			};
			class gh {
				constructor(t$1) {
					if (void 0 === t$1.property.overrides) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
					this.type = t$1.property.overrides ? t$1.property.overrides.runtimeType : Vt, this.defaultValue = t$1;
				}
				evaluate(t$1) {
					if (t$1.formattedSection) {
						const e$1 = this.defaultValue.property.overrides;
						if (e$1 && e$1.hasOverride(t$1.formattedSection)) return e$1.getOverride(t$1.formattedSection);
					}
					return t$1.feature && t$1.featureState ? this.defaultValue.evaluate(t$1.feature, t$1.featureState) : this.defaultValue.property.specification.default;
				}
				eachChild(t$1) {
					this.defaultValue.isConstant() || t$1(this.defaultValue.value._styleExpression.expression);
				}
				outputDefined() {
					return !1;
				}
				serialize() {
					return null;
				}
			}
			ps("FormatSectionOverride", gh, { omit: ["defaultValue"] });
			class xh extends Ks {
				constructor(t$1, e$1) {
					super(t$1, mh, e$1);
				}
				recalculate(t$1, e$1) {
					if (super.recalculate(t$1, e$1), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = "map" === this.layout.get("text-rotation-alignment") ? "map" : "viewport"), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {
						const t$2 = this.layout.get("text-writing-mode");
						if (t$2) {
							const e$2 = [];
							for (const r$1 of t$2) e$2.indexOf(r$1) < 0 && e$2.push(r$1);
							this.layout._values["text-writing-mode"] = e$2;
						} else this.layout._values["text-writing-mode"] = ["horizontal"];
					}
					this._setPaintOverrides();
				}
				getValueAndResolveTokens(t$1, e$1, r$1, n$1) {
					const i$1 = this.layout.get(t$1).evaluate(e$1, {}, r$1, n$1), s$1 = this._unevaluatedLayout._values[t$1];
					return s$1.isDataDriven() || ri(s$1.value) || !i$1 ? i$1 : function(t$2, e$2) {
						return e$2.replace(/{([^{}]+)}/g, ((e$3, r$2) => t$2 && r$2 in t$2 ? String(t$2[r$2]) : ""));
					}(e$1.properties, i$1);
				}
				createBucket(t$1) {
					return new fh(t$1);
				}
				queryRadius() {
					return 0;
				}
				queryIntersectsFeature() {
					throw new Error("Should take a different path in FeatureIndex");
				}
				_setPaintOverrides() {
					for (const t$1 of mh.paint.overridableProperties) {
						if (!xh.hasPaintOverride(this.layout, t$1)) continue;
						const e$1 = this.paint.get(t$1), n$1 = new ei(new gh(e$1), e$1.property.specification);
						let i$1 = null;
						i$1 = "constant" === e$1.value.kind || "source" === e$1.value.kind ? new ii("source", n$1) : new si("composite", n$1, e$1.value.zoomStops), this.paint._values[t$1] = new Us(e$1.property, i$1, e$1.parameters);
					}
				}
				_handleOverridablePaintPropertyUpdate(t$1, e$1, r$1) {
					return !(!this.layout || e$1.isDataDriven() || r$1.isDataDriven()) && xh.hasPaintOverride(this.layout, t$1);
				}
				static hasPaintOverride(t$1, e$1) {
					const r$1 = t$1.get("text-field"), n$1 = mh.paint.properties[e$1];
					let i$1 = !1;
					const s$1 = (t$2) => {
						for (const e$2 of t$2) if (n$1.overrides && n$1.overrides.hasOverride(e$2)) return void (i$1 = !0);
					};
					if ("constant" === r$1.value.kind && r$1.value.value instanceof De) s$1(r$1.value.value.sections);
					else if ("source" === r$1.value.kind || "composite" === r$1.value.kind) {
						const t$2 = (e$3) => {
							i$1 || (e$3 instanceof je && Ue(e$3.value) === jt ? s$1(e$3.value.sections) : e$3 instanceof Ir ? s$1(e$3.sections) : e$3.eachChild(t$2));
						}, e$2 = r$1.value;
						e$2._styleExpression && t$2(e$2._styleExpression.expression);
					}
					return i$1;
				}
			}
			let vh;
			var bh = { get paint() {
				return vh = vh || new Hs({
					"background-color": new js(vt.paint_background["background-color"]),
					"background-pattern": new Ys(vt.paint_background["background-pattern"]),
					"background-opacity": new js(vt.paint_background["background-opacity"])
				});
			} };
			class wh extends Ks {
				constructor(t$1, e$1) {
					super(t$1, bh, e$1);
				}
			}
			class _h extends Ks {
				constructor(t$1, e$1) {
					super(t$1, {}, e$1), this.onAdd = (t$2) => {
						this.implementation.onAdd && this.implementation.onAdd(t$2, t$2.painter.context.gl);
					}, this.onRemove = (t$2) => {
						this.implementation.onRemove && this.implementation.onRemove(t$2, t$2.painter.context.gl);
					}, this.implementation = t$1;
				}
				is3D() {
					return "3d" === this.implementation.renderingMode;
				}
				hasOffscreenPass() {
					return void 0 !== this.implementation.prerender;
				}
				recalculate() {}
				updateTransitions() {}
				hasTransition() {
					return !1;
				}
				serialize() {
					throw new Error("Custom layers cannot be serialized");
				}
			}
			class Sh {
				constructor(t$1) {
					this._methodToThrottle = t$1, this._triggered = !1, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
						this._triggered = !1, this._methodToThrottle();
					});
				}
				trigger() {
					this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout((() => {
						this._triggered = !1, this._methodToThrottle();
					}), 0));
				}
				remove() {
					delete this._channel, this._methodToThrottle = () => {};
				}
			}
			const Ah = { once: !0 }, kh = 6371008.8;
			class Eh {
				constructor(t$1, e$1) {
					if (isNaN(t$1) || isNaN(e$1)) throw new Error(`Invalid LngLat object: (${t$1}, ${e$1})`);
					if (this.lng = +t$1, this.lat = +e$1, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
				}
				wrap() {
					return new Eh(L(this.lng, -180, 180), this.lat);
				}
				toArray() {
					return [this.lng, this.lat];
				}
				toString() {
					return `LngLat(${this.lng}, ${this.lat})`;
				}
				distanceTo(t$1) {
					const e$1 = Math.PI / 180, r$1 = this.lat * e$1, n$1 = t$1.lat * e$1, i$1 = Math.sin(r$1) * Math.sin(n$1) + Math.cos(r$1) * Math.cos(n$1) * Math.cos((t$1.lng - this.lng) * e$1);
					return kh * Math.acos(Math.min(i$1, 1));
				}
				static convert(t$1) {
					if (t$1 instanceof Eh) return t$1;
					if (Array.isArray(t$1) && (2 === t$1.length || 3 === t$1.length)) return new Eh(Number(t$1[0]), Number(t$1[1]));
					if (!Array.isArray(t$1) && "object" == typeof t$1 && null !== t$1) return new Eh(Number("lng" in t$1 ? t$1.lng : t$1.lon), Number(t$1.lat));
					throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
				}
			}
			const Th = 2 * Math.PI * kh;
			function Ih(t$1) {
				return Th * Math.cos(t$1 * Math.PI / 180);
			}
			function Mh(t$1) {
				return (180 + t$1) / 360;
			}
			function Fh(t$1) {
				return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t$1 * Math.PI / 360))) / 360;
			}
			function Dh(t$1, e$1) {
				return t$1 / Ih(e$1);
			}
			function zh(t$1) {
				return 360 * t$1 - 180;
			}
			function Ph(t$1) {
				return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t$1) * Math.PI / 180)) - 90;
			}
			function Bh(t$1, e$1) {
				return t$1 * Ih(Ph(e$1));
			}
			class Vh {
				constructor(t$1, e$1, r$1 = 0) {
					this.x = +t$1, this.y = +e$1, this.z = +r$1;
				}
				static fromLngLat(t$1, e$1 = 0) {
					const r$1 = Eh.convert(t$1);
					return new Vh(Mh(r$1.lng), Fh(r$1.lat), Dh(e$1, r$1.lat));
				}
				toLngLat() {
					return new Eh(zh(this.x), Ph(this.y));
				}
				toAltitude() {
					return Bh(this.z, this.y);
				}
				meterInMercatorCoordinateUnits() {
					return 1 / Th * (t$1 = Ph(this.y), 1 / Math.cos(t$1 * Math.PI / 180));
					var t$1;
				}
			}
			function Ch(t$1, e$1, r$1) {
				var n$1 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r$1);
				return [t$1 * n$1 - 2 * Math.PI * 6378137 / 2, e$1 * n$1 - 2 * Math.PI * 6378137 / 2];
			}
			class Lh {
				constructor(t$1, e$1, r$1) {
					if (!function(t$2, e$2, r$2) {
						return !(t$2 < 0 || t$2 > 25 || r$2 < 0 || r$2 >= Math.pow(2, t$2) || e$2 < 0 || e$2 >= Math.pow(2, t$2));
					}(t$1, e$1, r$1)) throw new Error(`x=${e$1}, y=${r$1}, z=${t$1} outside of bounds. 0<=x<${Math.pow(2, t$1)}, 0<=y<${Math.pow(2, t$1)} 0<=z<=25 `);
					this.z = t$1, this.x = e$1, this.y = r$1, this.key = Nh(0, t$1, t$1, e$1, r$1);
				}
				equals(t$1) {
					return this.z === t$1.z && this.x === t$1.x && this.y === t$1.y;
				}
				url(t$1, e$1, r$1) {
					const n$1 = (s$1 = this.y, a = this.z, o$1 = Ch(256 * (i$1 = this.x), 256 * (s$1 = Math.pow(2, a) - s$1 - 1), a), l$1 = Ch(256 * (i$1 + 1), 256 * (s$1 + 1), a), o$1[0] + "," + o$1[1] + "," + l$1[0] + "," + l$1[1]);
					var i$1, s$1, a, o$1, l$1;
					const u$1 = function(t$2, e$2, r$2) {
						let n$2, i$2 = "";
						for (let s$2 = t$2; s$2 > 0; s$2--) n$2 = 1 << s$2 - 1, i$2 += (e$2 & n$2 ? 1 : 0) + (r$2 & n$2 ? 2 : 0);
						return i$2;
					}(this.z, this.x, this.y);
					return t$1[(this.x + this.y) % t$1.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === r$1 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, e$1 > 1 ? "@2x" : "").replace(/{quadkey}/g, u$1).replace(/{bbox-epsg-3857}/g, n$1);
				}
				isChildOf(t$1) {
					const e$1 = this.z - t$1.z;
					return e$1 > 0 && t$1.x === this.x >> e$1 && t$1.y === this.y >> e$1;
				}
				getTilePoint(t$1) {
					const e$1 = Math.pow(2, this.z);
					return new r((t$1.x * e$1 - this.x) * M, (t$1.y * e$1 - this.y) * M);
				}
				toString() {
					return `${this.z}/${this.x}/${this.y}`;
				}
			}
			class Oh {
				constructor(t$1, e$1) {
					this.wrap = t$1, this.canonical = e$1, this.key = Nh(t$1, e$1.z, e$1.z, e$1.x, e$1.y);
				}
			}
			class Rh {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					if (this.terrainRttPosMatrix32f = null, t$1 < r$1) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t$1}; z = ${r$1}`);
					this.overscaledZ = t$1, this.wrap = e$1, this.canonical = new Lh(r$1, +n$1, +i$1), this.key = Nh(e$1, t$1, r$1, n$1, i$1);
				}
				clone() {
					return new Rh(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
				}
				equals(t$1) {
					return this.overscaledZ === t$1.overscaledZ && this.wrap === t$1.wrap && this.canonical.equals(t$1.canonical);
				}
				scaledTo(t$1) {
					if (t$1 > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t$1}; overscaledZ = ${this.overscaledZ}`);
					const e$1 = this.canonical.z - t$1;
					return t$1 > this.canonical.z ? new Rh(t$1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Rh(t$1, this.wrap, t$1, this.canonical.x >> e$1, this.canonical.y >> e$1);
				}
				isOverscaled() {
					return this.overscaledZ > this.canonical.z;
				}
				calculateScaledKey(t$1, e$1) {
					if (t$1 > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t$1}; overscaledZ = ${this.overscaledZ}`);
					const r$1 = this.canonical.z - t$1;
					return t$1 > this.canonical.z ? Nh(this.wrap * +e$1, t$1, this.canonical.z, this.canonical.x, this.canonical.y) : Nh(this.wrap * +e$1, t$1, t$1, this.canonical.x >> r$1, this.canonical.y >> r$1);
				}
				isChildOf(t$1) {
					if (t$1.wrap !== this.wrap) return !1;
					if (this.overscaledZ - t$1.overscaledZ <= 0) return !1;
					if (0 === t$1.overscaledZ) return this.overscaledZ > 0;
					const e$1 = this.canonical.z - t$1.canonical.z;
					return !(e$1 < 0) && t$1.canonical.x === this.canonical.x >> e$1 && t$1.canonical.y === this.canonical.y >> e$1;
				}
				children(t$1) {
					if (this.overscaledZ >= t$1) return [new Rh(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
					const e$1 = this.canonical.z + 1, r$1 = 2 * this.canonical.x, n$1 = 2 * this.canonical.y;
					return [
						new Rh(e$1, this.wrap, e$1, r$1, n$1),
						new Rh(e$1, this.wrap, e$1, r$1 + 1, n$1),
						new Rh(e$1, this.wrap, e$1, r$1, n$1 + 1),
						new Rh(e$1, this.wrap, e$1, r$1 + 1, n$1 + 1)
					];
				}
				isLessThan(t$1) {
					return this.wrap < t$1.wrap || !(this.wrap > t$1.wrap) && (this.overscaledZ < t$1.overscaledZ || !(this.overscaledZ > t$1.overscaledZ) && (this.canonical.x < t$1.canonical.x || !(this.canonical.x > t$1.canonical.x) && this.canonical.y < t$1.canonical.y));
				}
				wrapped() {
					return new Rh(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
				}
				unwrapTo(t$1) {
					return new Rh(this.overscaledZ, t$1, this.canonical.z, this.canonical.x, this.canonical.y);
				}
				overscaleFactor() {
					return Math.pow(2, this.overscaledZ - this.canonical.z);
				}
				toUnwrapped() {
					return new Oh(this.wrap, this.canonical);
				}
				toString() {
					return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
				}
				getTilePoint(t$1) {
					return this.canonical.getTilePoint(new Vh(t$1.x - this.wrap, t$1.y));
				}
			}
			function Nh(t$1, e$1, r$1, n$1, i$1) {
				(t$1 *= 2) < 0 && (t$1 = -1 * t$1 - 1);
				const s$1 = 1 << r$1;
				return (s$1 * s$1 * t$1 + s$1 * i$1 + n$1).toString(36) + r$1.toString(36) + e$1.toString(36);
			}
			function $h(t$1, e$1) {
				return e$1 ? t$1.properties[e$1] : t$1.id;
			}
			function Uh(t$1, e$1) {
				const r$1 = { id: t$1.id };
				if (e$1.removeAllProperties && (delete t$1.removeProperties, delete t$1.addOrUpdateProperties, delete e$1.removeProperties), e$1.removeProperties) for (const r$2 of e$1.removeProperties) {
					const e$2 = t$1.addOrUpdateProperties.findIndex(((t$2) => t$2.key === r$2));
					e$2 > -1 && t$1.addOrUpdateProperties.splice(e$2, 1);
				}
				return (t$1.removeAllProperties || e$1.removeAllProperties) && (r$1.removeAllProperties = !0), (t$1.removeProperties || e$1.removeProperties) && (r$1.removeProperties = [...t$1.removeProperties || [], ...e$1.removeProperties || []]), (t$1.addOrUpdateProperties || e$1.addOrUpdateProperties) && (r$1.addOrUpdateProperties = [...t$1.addOrUpdateProperties || [], ...e$1.addOrUpdateProperties || []]), (t$1.newGeometry || e$1.newGeometry) && (r$1.newGeometry = e$1.newGeometry || t$1.newGeometry), r$1;
			}
			function qh(t$1) {
				var e$1, r$1;
				if (!t$1) return {};
				const n$1 = {};
				return n$1.removeAll = t$1.removeAll, n$1.remove = new Set(t$1.remove || []), n$1.add = new Map(null === (e$1 = t$1.add) || void 0 === e$1 ? void 0 : e$1.map(((t$2) => [t$2.id, t$2]))), n$1.update = new Map(null === (r$1 = t$1.update) || void 0 === r$1 ? void 0 : r$1.map(((t$2) => [t$2.id, t$2]))), n$1;
			}
			ps("CanonicalTileID", Lh), ps("OverscaledTileID", Rh, { omit: ["terrainRttPosMatrix32f"] });
			class jh {
				constructor() {
					this.minX = Infinity, this.maxX = -Infinity, this.minY = Infinity, this.maxY = -Infinity;
				}
				extend(t$1) {
					return this.minX = Math.min(this.minX, t$1.x), this.minY = Math.min(this.minY, t$1.y), this.maxX = Math.max(this.maxX, t$1.x), this.maxY = Math.max(this.maxY, t$1.y), this;
				}
				expandBy(t$1) {
					return this.minX -= t$1, this.minY -= t$1, this.maxX += t$1, this.maxY += t$1, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = Infinity, this.maxX = -Infinity, this.minY = Infinity, this.maxY = -Infinity), this;
				}
				shrinkBy(t$1) {
					return this.expandBy(-t$1);
				}
				map(t$1) {
					const e$1 = new jh();
					return e$1.extend(t$1(new r(this.minX, this.minY))), e$1.extend(t$1(new r(this.maxX, this.minY))), e$1.extend(t$1(new r(this.minX, this.maxY))), e$1.extend(t$1(new r(this.maxX, this.maxY))), e$1;
				}
				static fromPoints(t$1) {
					const e$1 = new jh();
					for (const r$1 of t$1) e$1.extend(r$1);
					return e$1;
				}
				contains(t$1) {
					return t$1.x >= this.minX && t$1.x <= this.maxX && t$1.y >= this.minY && t$1.y <= this.maxY;
				}
				empty() {
					return this.minX > this.maxX;
				}
				width() {
					return this.maxX - this.minX;
				}
				height() {
					return this.maxY - this.minY;
				}
				covers(t$1) {
					return !this.empty() && !t$1.empty() && t$1.minX >= this.minX && t$1.maxX <= this.maxX && t$1.minY >= this.minY && t$1.maxY <= this.maxY;
				}
				intersects(t$1) {
					return !this.empty() && !t$1.empty() && t$1.minX <= this.maxX && t$1.maxX >= this.minX && t$1.minY <= this.maxY && t$1.maxY >= this.minY;
				}
			}
			class Gh {
				constructor(t$1) {
					this._stringToNumber = {}, this._numberToString = [];
					for (let e$1 = 0; e$1 < t$1.length; e$1++) {
						const r$1 = t$1[e$1];
						this._stringToNumber[r$1] = e$1, this._numberToString[e$1] = r$1;
					}
				}
				encode(t$1) {
					return this._stringToNumber[t$1];
				}
				decode(t$1) {
					if (t$1 >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t$1} can't be >= this._numberToString.length ${this._numberToString.length}`);
					return this._numberToString[t$1];
				}
			}
			class Xh {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.type = "Feature", this._vectorTileFeature = t$1, this._x = r$1, this._y = n$1, this._z = e$1, this.properties = t$1.properties, this.id = i$1;
				}
				projectPoint(t$1, e$1, r$1, n$1) {
					return [360 * (t$1.x + e$1) / n$1 - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (t$1.y + r$1) / n$1) * Math.PI)) - 90];
				}
				projectLine(t$1, e$1, r$1, n$1) {
					return t$1.map(((t$2) => this.projectPoint(t$2, e$1, r$1, n$1)));
				}
				get geometry() {
					if (this._geometry) return this._geometry;
					const t$1 = this._vectorTileFeature, e$1 = t$1.extent * Math.pow(2, this._z), r$1 = t$1.extent * this._x, n$1 = t$1.extent * this._y, i$1 = t$1.loadGeometry();
					switch (t$1.type) {
						case 1: {
							const t$2 = [];
							for (const e$2 of i$1) t$2.push(e$2[0]);
							const s$1 = this.projectLine(t$2, r$1, n$1, e$1);
							this._geometry = 1 === t$2.length ? {
								type: "Point",
								coordinates: s$1[0]
							} : {
								type: "MultiPoint",
								coordinates: s$1
							};
							break;
						}
						case 2: {
							const t$2 = i$1.map(((t$3) => this.projectLine(t$3, r$1, n$1, e$1)));
							this._geometry = 1 === t$2.length ? {
								type: "LineString",
								coordinates: t$2[0]
							} : {
								type: "MultiLineString",
								coordinates: t$2
							};
							break;
						}
						case 3: {
							const t$2 = Du(i$1), s$1 = [];
							for (const i$2 of t$2) s$1.push(i$2.map(((t$3) => this.projectLine(t$3, r$1, n$1, e$1))));
							this._geometry = 1 === s$1.length ? {
								type: "Polygon",
								coordinates: s$1[0]
							} : {
								type: "MultiPolygon",
								coordinates: s$1
							};
							break;
						}
						default: throw new Error(`unknown feature type: ${t$1.type}`);
					}
					return this._geometry;
				}
				set geometry(t$1) {
					this._geometry = t$1;
				}
				toJSON() {
					const t$1 = { geometry: this.geometry };
					for (const e$1 in this) "_geometry" !== e$1 && "_vectorTileFeature" !== e$1 && "_x" !== e$1 && "_y" !== e$1 && "_z" !== e$1 && (t$1[e$1] = this[e$1]);
					return t$1;
				}
			}
			class Yh {
				_name;
				dataBuffer;
				nullabilityBuffer;
				_size;
				constructor(t$1, e$1, r$1) {
					this._name = t$1, this.dataBuffer = e$1, "number" == typeof r$1 ? this._size = r$1 : (this.nullabilityBuffer = r$1, this._size = r$1.size());
				}
				getValue(t$1) {
					return this.nullabilityBuffer && !this.nullabilityBuffer.get(t$1) ? null : this.getValueFromBuffer(t$1);
				}
				has(t$1) {
					return this.nullabilityBuffer && this.nullabilityBuffer.get(t$1) || !this.nullabilityBuffer;
				}
				get name() {
					return this._name;
				}
				get size() {
					return this._size;
				}
			}
			class Zh extends Yh {}
			class Hh extends Zh {
				getValueFromBuffer(t$1) {
					return this.dataBuffer[t$1];
				}
			}
			class Kh extends Zh {
				getValueFromBuffer(t$1) {
					return this.dataBuffer[t$1];
				}
			}
			class Wh extends Yh {
				delta;
				constructor(t$1, e$1, r$1, n$1) {
					super(t$1, e$1, n$1), this.delta = r$1;
				}
			}
			class Jh extends Wh {
				constructor(t$1, e$1, r$1, n$1) {
					super(t$1, Int32Array.of(e$1), r$1, n$1);
				}
				getValueFromBuffer(t$1) {
					return this.dataBuffer[0] + t$1 * this.delta;
				}
			}
			class Qh extends Yh {
				constructor(t$1, e$1, r$1) {
					super(t$1, Int32Array.of(e$1), r$1);
				}
				getValueFromBuffer(t$1) {
					return this.dataBuffer[0];
				}
			}
			class tp {
				_name;
				_geometryVector;
				_idVector;
				_propertyVectors;
				_extent;
				propertyVectorsMap;
				constructor(t$1, e$1, r$1, n$1, i$1 = 4096) {
					this._name = t$1, this._geometryVector = e$1, this._idVector = r$1, this._propertyVectors = n$1, this._extent = i$1;
				}
				get name() {
					return this._name;
				}
				get idVector() {
					return this._idVector;
				}
				get geometryVector() {
					return this._geometryVector;
				}
				get propertyVectors() {
					return this._propertyVectors;
				}
				getPropertyVector(t$1) {
					return this.propertyVectorsMap || (this.propertyVectorsMap = new Map(this._propertyVectors.map(((t$2) => [t$2.name, t$2])))), this.propertyVectorsMap.get(t$1);
				}
				*[Symbol.iterator]() {
					const t$1 = this.geometryVector[Symbol.iterator]();
					let e$1 = 0;
					for (; e$1 < this.numFeatures;) {
						let r$1;
						this.idVector && (r$1 = this.containsMaxSaveIntegerValues(this.idVector) ? Number(this.idVector.getValue(e$1)) : this.idVector.getValue(e$1));
						const n$1 = t$1?.next().value, i$1 = {};
						for (const t$2 of this.propertyVectors) {
							if (!t$2) continue;
							const r$2 = t$2.name, n$2 = t$2.getValue(e$1);
							null !== n$2 && (i$1[r$2] = n$2);
						}
						e$1++, yield {
							id: r$1,
							geometry: n$1,
							properties: i$1
						};
					}
				}
				get numFeatures() {
					return this.geometryVector.numGeometries;
				}
				get extent() {
					return this._extent;
				}
				getFeatures() {
					const t$1 = [], e$1 = this.geometryVector.getGeometries();
					for (let r$1 = 0; r$1 < this.numFeatures; r$1++) {
						let n$1;
						this.idVector && (n$1 = this.containsMaxSaveIntegerValues(this.idVector) ? Number(this.idVector.getValue(r$1)) : this.idVector.getValue(r$1));
						const i$1 = {
							coordinates: e$1[r$1],
							type: this.geometryVector.geometryType(r$1)
						}, s$1 = {};
						for (const t$2 of this.propertyVectors) {
							if (!t$2) continue;
							const e$2 = t$2.name, n$2 = t$2.getValue(r$1);
							null !== n$2 && (s$1[e$2] = n$2);
						}
						t$1.push({
							id: n$1,
							geometry: i$1,
							properties: s$1
						});
					}
					return t$1;
				}
				containsMaxSaveIntegerValues(t$1) {
					return t$1 instanceof Hh || t$1 instanceof Qh && t$1 instanceof Jh || t$1 instanceof Kh;
				}
			}
			class ep {
				value;
				constructor(t$1) {
					this.value = t$1;
				}
				get() {
					return this.value;
				}
				set(t$1) {
					this.value = t$1;
				}
				increment() {
					return this.value++;
				}
				add(t$1) {
					this.value += t$1;
				}
			}
			var rp, np, ip, sp, ap, op, lp, up, cp, hp;
			function pp(t$1, e$1, r$1) {
				const n$1 = new Int32Array(r$1);
				let i$1 = 0, s$1 = e$1.get();
				for (let e$2 = 0; e$2 < n$1.length; e$2++) {
					let e$3 = t$1[s$1++], r$2 = 127 & e$3;
					e$3 < 128 || (e$3 = t$1[s$1++], r$2 |= (127 & e$3) << 7, e$3 < 128 || (e$3 = t$1[s$1++], r$2 |= (127 & e$3) << 14, e$3 < 128 || (e$3 = t$1[s$1++], r$2 |= (127 & e$3) << 21, e$3 < 128 || (e$3 = t$1[s$1++], r$2 |= (15 & e$3) << 28)))), n$1[i$1++] = r$2;
				}
				return e$1.set(s$1), n$1;
			}
			function fp(t$1, e$1, r$1) {
				const n$1 = new BigInt64Array(r$1);
				for (let r$2 = 0; r$2 < n$1.length; r$2++) n$1[r$2] = xp(t$1, e$1);
				return n$1;
			}
			function dp(t$1, e$1) {
				let r$1, n$1;
				return n$1 = t$1[e$1.get()], e$1.increment(), r$1 = 127 & n$1, n$1 < 128 ? r$1 : (n$1 = t$1[e$1.get()], e$1.increment(), r$1 |= (127 & n$1) << 7, n$1 < 128 ? r$1 : (n$1 = t$1[e$1.get()], e$1.increment(), r$1 |= (127 & n$1) << 14, n$1 < 128 ? r$1 : (n$1 = t$1[e$1.get()], e$1.increment(), r$1 |= (127 & n$1) << 21, n$1 < 128 ? r$1 : (n$1 = t$1[e$1.get()], r$1 |= (15 & n$1) << 28, function(t$2, e$2, r$2) {
					let n$2, i$1;
					if (i$1 = e$2[r$2.get()], r$2.increment(), n$2 = (112 & i$1) >> 4, i$1 < 128) return 4294967296 * n$2 + (t$2 >>> 0);
					if (i$1 = e$2[r$2.get()], r$2.increment(), n$2 |= (127 & i$1) << 3, i$1 < 128) return 4294967296 * n$2 + (t$2 >>> 0);
					if (i$1 = e$2[r$2.get()], r$2.increment(), n$2 |= (127 & i$1) << 10, i$1 < 128) return 4294967296 * n$2 + (t$2 >>> 0);
					if (i$1 = e$2[r$2.get()], r$2.increment(), n$2 |= (127 & i$1) << 17, i$1 < 128) return 4294967296 * n$2 + (t$2 >>> 0);
					if (i$1 = e$2[r$2.get()], r$2.increment(), n$2 |= (127 & i$1) << 24, i$1 < 128) return 4294967296 * n$2 + (t$2 >>> 0);
					if (i$1 = e$2[r$2.get()], r$2.increment(), n$2 |= (1 & i$1) << 31, i$1 < 128) return 4294967296 * n$2 + (t$2 >>> 0);
					throw new Error("Expected varint not more than 10 bytes");
				}(r$1, t$1, e$1)))));
			}
			function yp(t$1, e$1, r$1, n$1) {
				throw new Error("FastPFor is not implemented yet.");
			}
			function mp(t$1) {
				return t$1 >>> 1 ^ -(1 & t$1);
			}
			function gp(t$1) {
				return t$1 >> 1n ^ -(1n & t$1);
			}
			function xp(t$1, e$1) {
				let r$1 = 0n, n$1 = 0, i$1 = e$1.get();
				for (; i$1 < t$1.length;) {
					const e$2 = t$1[i$1++];
					if (r$1 |= BigInt(127 & e$2) << BigInt(n$1), !(128 & e$2)) break;
					if (n$1 += 7, n$1 >= 64) throw new Error("Varint too long");
				}
				return e$1.set(i$1), r$1;
			}
			function vp(t$1, e$1, r$1) {
				const n$1 = new Int32Array(r$1);
				let i$1 = 0;
				for (let r$2 = 0; r$2 < e$1; r$2++) {
					const s$1 = t$1[r$2];
					n$1.fill(t$1[r$2 + e$1], i$1, i$1 + s$1), i$1 += s$1;
				}
				return n$1;
			}
			function bp(t$1, e$1, r$1) {
				const n$1 = new BigInt64Array(r$1);
				let i$1 = 0;
				for (let r$2 = 0; r$2 < e$1; r$2++) {
					const s$1 = Number(t$1[r$2]);
					n$1.fill(t$1[r$2 + e$1], i$1, i$1 + s$1), i$1 += s$1;
				}
				return n$1;
			}
			function wp(t$1, e$1, r$1) {
				const n$1 = new Float64Array(r$1);
				let i$1 = 0;
				for (let r$2 = 0; r$2 < e$1; r$2++) {
					const s$1 = t$1[r$2];
					n$1.fill(t$1[r$2 + e$1], i$1, i$1 + s$1), i$1 += s$1;
				}
				return n$1;
			}
			function _p(t$1) {
				const e$1 = t$1.length / 4 * 4;
				let r$1 = 1;
				if (e$1 >= 4) for (let n$1 = t$1[0]; r$1 < e$1 - 4; r$1 += 4) n$1 = t$1[r$1] += n$1, n$1 = t$1[r$1 + 1] += n$1, n$1 = t$1[r$1 + 2] += n$1, n$1 = t$1[r$1 + 3] += n$1;
				for (; r$1 != t$1.length;) t$1[r$1] += t$1[r$1 - 1], ++r$1;
			}
			function Sp(t$1) {
				t$1[0] = t$1[0] >>> 1 ^ -(1 & t$1[0]), t$1[1] = t$1[1] >>> 1 ^ -(1 & t$1[1]);
				const e$1 = t$1.length / 4 * 4;
				let r$1 = 2;
				if (e$1 >= 4) for (; r$1 < e$1 - 4; r$1 += 4) {
					const e$2 = t$1[r$1], n$1 = t$1[r$1 + 1], i$1 = t$1[r$1 + 2], s$1 = t$1[r$1 + 3];
					t$1[r$1] = (e$2 >>> 1 ^ -(1 & e$2)) + t$1[r$1 - 2], t$1[r$1 + 1] = (n$1 >>> 1 ^ -(1 & n$1)) + t$1[r$1 - 1], t$1[r$1 + 2] = (i$1 >>> 1 ^ -(1 & i$1)) + t$1[r$1], t$1[r$1 + 3] = (s$1 >>> 1 ^ -(1 & s$1)) + t$1[r$1 + 1];
				}
				for (; r$1 != t$1.length; r$1 += 2) t$1[r$1] = (t$1[r$1] >>> 1 ^ -(1 & t$1[r$1])) + t$1[r$1 - 2], t$1[r$1 + 1] = (t$1[r$1 + 1] >>> 1 ^ -(1 & t$1[r$1 + 1])) + t$1[r$1 - 1];
			}
			(function(t$1) {
				t$1.NONE = "NONE", t$1.DELTA = "DELTA", t$1.COMPONENTWISE_DELTA = "COMPONENTWISE_DELTA", t$1.RLE = "RLE", t$1.MORTON = "MORTON", t$1.PDE = "PDE";
			})(rp || (rp = {})), function(t$1) {
				t$1.NONE = "NONE", t$1.FAST_PFOR = "FAST_PFOR", t$1.VARINT = "VARINT", t$1.ALP = "ALP";
			}(np || (np = {})), function(t$1) {
				t$1.PRESENT = "PRESENT", t$1.DATA = "DATA", t$1.OFFSET = "OFFSET", t$1.LENGTH = "LENGTH";
			}(ip || (ip = {}));
			class Ap {
				_dictionaryType;
				_offsetType;
				_lengthType;
				constructor(t$1, e$1, r$1) {
					this._dictionaryType = t$1, this._offsetType = e$1, this._lengthType = r$1;
				}
				get dictionaryType() {
					return this._dictionaryType;
				}
				get offsetType() {
					return this._offsetType;
				}
				get lengthType() {
					return this._lengthType;
				}
			}
			function kp(t$1, e$1) {
				const r$1 = function(t$2, e$2) {
					const r$2 = t$2[e$2.get()], n$1 = Object.values(ip)[r$2 >> 4];
					let i$1 = null;
					switch (n$1) {
						case ip.DATA:
							i$1 = new Ap(Object.values(sp)[15 & r$2]);
							break;
						case ip.OFFSET:
							i$1 = new Ap(null, Object.values(ap)[15 & r$2]);
							break;
						case ip.LENGTH: i$1 = new Ap(null, null, Object.values(op)[15 & r$2]);
					}
					e$2.increment();
					const s$1 = t$2[e$2.get()], a = Object.values(rp)[s$1 >> 5], o$1 = Object.values(rp)[s$1 >> 2 & 7], l$1 = Object.values(np)[3 & s$1];
					e$2.increment();
					const u$1 = pp(t$2, e$2, 2), c$1 = u$1[0];
					return {
						physicalStreamType: n$1,
						logicalStreamType: i$1,
						logicalLevelTechnique1: a,
						logicalLevelTechnique2: o$1,
						physicalLevelTechnique: l$1,
						numValues: c$1,
						byteLength: u$1[1],
						decompressedCount: c$1
					};
				}(t$1, e$1);
				return r$1.logicalLevelTechnique1 === rp.MORTON ? function(t$2, e$2, r$2) {
					const n$1 = pp(e$2, r$2, 2);
					return {
						physicalStreamType: t$2.physicalStreamType,
						logicalStreamType: t$2.logicalStreamType,
						logicalLevelTechnique1: t$2.logicalLevelTechnique1,
						logicalLevelTechnique2: t$2.logicalLevelTechnique2,
						physicalLevelTechnique: t$2.physicalLevelTechnique,
						numValues: t$2.numValues,
						byteLength: t$2.byteLength,
						decompressedCount: t$2.decompressedCount,
						numBits: n$1[0],
						coordinateShift: n$1[1]
					};
				}(r$1, t$1, e$1) : rp.RLE !== r$1.logicalLevelTechnique1 && rp.RLE !== r$1.logicalLevelTechnique2 || np.NONE === r$1.physicalLevelTechnique ? r$1 : function(t$2, e$2, r$2) {
					const n$1 = pp(e$2, r$2, 2);
					return {
						physicalStreamType: t$2.physicalStreamType,
						logicalStreamType: t$2.logicalStreamType,
						logicalLevelTechnique1: t$2.logicalLevelTechnique1,
						logicalLevelTechnique2: t$2.logicalLevelTechnique2,
						physicalLevelTechnique: t$2.physicalLevelTechnique,
						numValues: t$2.numValues,
						byteLength: t$2.byteLength,
						decompressedCount: n$1[1],
						runs: n$1[0],
						numRleValues: n$1[1]
					};
				}(r$1, t$1, e$1);
			}
			(function(t$1) {
				t$1.NONE = "NONE", t$1.SINGLE = "SINGLE", t$1.SHARED = "SHARED", t$1.VERTEX = "VERTEX", t$1.MORTON = "MORTON", t$1.FSST = "FSST";
			})(sp || (sp = {})), function(t$1) {
				t$1.VERTEX = "VERTEX", t$1.INDEX = "INDEX", t$1.STRING = "STRING", t$1.KEY = "KEY";
			}(ap || (ap = {})), function(t$1) {
				t$1.VAR_BINARY = "VAR_BINARY", t$1.GEOMETRIES = "GEOMETRIES", t$1.PARTS = "PARTS", t$1.RINGS = "RINGS", t$1.TRIANGLES = "TRIANGLES", t$1.SYMBOL = "SYMBOL", t$1.DICTIONARY = "DICTIONARY";
			}(op || (op = {})), function(t$1) {
				t$1[t$1.FLAT = 0] = "FLAT", t$1[t$1.CONST = 1] = "CONST", t$1[t$1.SEQUENCE = 2] = "SEQUENCE", t$1[t$1.DICTIONARY = 3] = "DICTIONARY", t$1[t$1.FSST_DICTIONARY = 4] = "FSST_DICTIONARY";
			}(lp || (lp = {}));
			class Ep {
				values;
				_size;
				constructor(t$1, e$1) {
					this.values = t$1, this._size = e$1;
				}
				get(t$1) {
					const e$1 = Math.floor(t$1 / 8);
					return 1 == (this.values[e$1] >> t$1 % 8 & 1);
				}
				set(t$1, e$1) {
					const r$1 = Math.floor(t$1 / 8);
					this.values[r$1] = this.values[r$1] | (e$1 ? 1 : 0) << t$1 % 8;
				}
				getInt(t$1) {
					const e$1 = Math.floor(t$1 / 8);
					return this.values[e$1] >> t$1 % 8 & 1;
				}
				size() {
					return this._size;
				}
				getBuffer() {
					return this.values;
				}
			}
			function Tp(t$1, e$1, r$1, n$1, i$1) {
				return function(t$2, e$2, r$2) {
					switch (e$2.logicalLevelTechnique1) {
						case rp.DELTA: return e$2.logicalLevelTechnique2 === rp.RLE ? function(t$3, e$3, r$3) {
							const n$2 = new Int32Array(r$3);
							let i$2 = 0, s$1 = 0;
							for (let r$4 = 0; r$4 < e$3; r$4++) {
								const a = t$3[r$4], o$1 = mp(t$3[r$4 + e$3]);
								for (let t$4 = 0; t$4 < a; t$4++) s$1 += o$1, n$2[i$2++] = s$1;
							}
							return n$2;
						}(t$2, e$2.runs, e$2.numRleValues) : (function(t$3) {
							t$3[0] = t$3[0] >>> 1 ^ -(1 & t$3[0]);
							const e$3 = t$3.length / 4 * 4;
							let r$3 = 1;
							if (e$3 >= 4) for (; r$3 < e$3 - 4; r$3 += 4) {
								const e$4 = t$3[r$3], n$2 = t$3[r$3 + 1], i$2 = t$3[r$3 + 2], s$1 = t$3[r$3 + 3];
								t$3[r$3] = (e$4 >>> 1 ^ -(1 & e$4)) + t$3[r$3 - 1], t$3[r$3 + 1] = (n$2 >>> 1 ^ -(1 & n$2)) + t$3[r$3], t$3[r$3 + 2] = (i$2 >>> 1 ^ -(1 & i$2)) + t$3[r$3 + 1], t$3[r$3 + 3] = (s$1 >>> 1 ^ -(1 & s$1)) + t$3[r$3 + 2];
							}
							for (; r$3 != t$3.length; ++r$3) t$3[r$3] = (t$3[r$3] >>> 1 ^ -(1 & t$3[r$3])) + t$3[r$3 - 1];
						}(t$2), t$2);
						case rp.RLE: return function(t$3, e$3, r$3) {
							return r$3 ? function(t$4, e$4, r$4) {
								const n$2 = new Int32Array(r$4);
								let i$2 = 0;
								for (let r$5 = 0; r$5 < e$4; r$5++) {
									const s$1 = t$4[r$5];
									let a = t$4[r$5 + e$4];
									a = a >>> 1 ^ -(1 & a), n$2.fill(a, i$2, i$2 + s$1), i$2 += s$1;
								}
								return n$2;
							}(t$3, e$3.runs, e$3.numRleValues) : vp(t$3, e$3.runs, e$3.numRleValues);
						}(t$2, e$2, r$2);
						case rp.MORTON: return _p(t$2), t$2;
						case rp.COMPONENTWISE_DELTA: return Sp(t$2), t$2;
						case rp.NONE: return r$2 && function(t$3) {
							for (let e$3 = 0; e$3 < t$3.length; e$3++) {
								const r$3 = t$3[e$3];
								t$3[e$3] = r$3 >>> 1 ^ -(1 & r$3);
							}
						}(t$2), t$2;
						default: throw new Error(`The specified Logical level technique is not supported: ${e$2.logicalLevelTechnique1}`);
					}
				}(Mp(t$1, e$1, r$1), r$1, n$1);
			}
			function Ip(t$1, e$1, r$1) {
				return function(t$2, e$2) {
					if (e$2.logicalLevelTechnique1 === rp.DELTA && e$2.logicalLevelTechnique2 === rp.NONE) return function(t$3) {
						const e$3 = new Int32Array(t$3.length + 1);
						e$3[0] = 0, e$3[1] = mp(t$3[0]);
						let r$2 = e$3[1], n$1 = 2;
						for (; n$1 != e$3.length; ++n$1) {
							const i$1 = t$3[n$1 - 1];
							r$2 += i$1 >>> 1 ^ -(1 & i$1), e$3[n$1] = e$3[n$1 - 1] + r$2;
						}
						return e$3;
					}(t$2);
					if (e$2.logicalLevelTechnique1 === rp.RLE && e$2.logicalLevelTechnique2 === rp.NONE) return function(t$3, e$3, r$2) {
						const n$1 = new Int32Array(r$2 + 1);
						n$1[0] = 0;
						let i$1 = 1, s$1 = n$1[0];
						for (let r$3 = 0; r$3 < e$3; r$3++) {
							const a = t$3[r$3], o$1 = t$3[r$3 + e$3];
							for (let t$4 = i$1; t$4 < i$1 + a; t$4++) n$1[t$4] = o$1 + s$1, s$1 = n$1[t$4];
							i$1 += a;
						}
						return n$1;
					}(t$2, e$2.runs, e$2.numRleValues);
					if (e$2.logicalLevelTechnique1 === rp.NONE && e$2.logicalLevelTechnique2 === rp.NONE) {
						(function(t$3) {
							let e$3 = 0;
							for (let r$3 = 0; r$3 < t$3.length; r$3++) t$3[r$3] += e$3, e$3 = t$3[r$3];
						})(t$2);
						const r$2 = new Int32Array(e$2.numValues + 1);
						return r$2[0] = 0, r$2.set(t$2, 1), r$2;
					}
					if (e$2.logicalLevelTechnique1 === rp.DELTA && e$2.logicalLevelTechnique2 === rp.RLE) {
						const r$2 = function(t$3, e$3, r$3) {
							const n$1 = new Int32Array(r$3 + 1);
							n$1[0] = 0;
							let i$1 = 1, s$1 = n$1[0];
							for (let r$4 = 0; r$4 < e$3; r$4++) {
								const a = t$3[r$4];
								let o$1 = t$3[r$4 + e$3];
								o$1 = o$1 >>> 1 ^ -(1 & o$1);
								for (let t$4 = i$1; t$4 < i$1 + a; t$4++) n$1[t$4] = o$1 + s$1, s$1 = n$1[t$4];
								i$1 += a;
							}
							return n$1;
						}(t$2, e$2.runs, e$2.numRleValues);
						return _p(r$2), r$2;
					}
					throw new Error("Only delta encoding is supported for transforming length to offset streams yet.");
				}(Mp(t$1, e$1, r$1), r$1);
			}
			function Mp(t$1, e$1, r$1) {
				const n$1 = r$1.physicalLevelTechnique;
				if (n$1 === np.FAST_PFOR) return yp();
				if (n$1 === np.VARINT) return pp(t$1, e$1, r$1.numValues);
				if (n$1 === np.NONE) {
					const n$2 = e$1.get();
					e$1.add(r$1.byteLength);
					const i$1 = t$1.subarray(n$2, e$1.get());
					return new Int32Array(i$1);
				}
				throw new Error("Specified physicalLevelTechnique is not supported (yet).");
			}
			function Fp(t$1, e$1, r$1, n$1) {
				const i$1 = Mp(t$1, e$1, r$1);
				if (1 === i$1.length) {
					const t$2 = i$1[0];
					return n$1 ? mp(t$2) : t$2;
				}
				return n$1 ? function(t$2) {
					return mp(t$2[1]);
				}(i$1) : function(t$2) {
					return t$2[1];
				}(i$1);
			}
			function Dp(t$1, e$1, r$1) {
				return function(t$2) {
					if (2 == t$2.length) {
						const e$2 = mp(t$2[1]);
						return [e$2, e$2];
					}
					return [mp(t$2[2]), mp(t$2[3])];
				}(Mp(t$1, e$1, r$1));
			}
			function zp(t$1, e$1, r$1) {
				return function(t$2) {
					if (2 == t$2.length) {
						const e$2 = gp(t$2[1]);
						return [e$2, e$2];
					}
					return [gp(t$2[2]), gp(t$2[3])];
				}(fp(t$1, e$1, r$1.numValues));
			}
			function Pp(t$1, e$1, r$1, n$1) {
				return function(t$2, e$2, r$2) {
					switch (e$2.logicalLevelTechnique1) {
						case rp.DELTA: return e$2.logicalLevelTechnique2 === rp.RLE ? function(t$3, e$3, r$3) {
							const n$2 = new BigInt64Array(r$3);
							let i$1 = 0, s$1 = 0n;
							for (let r$4 = 0; r$4 < e$3; r$4++) {
								const a = Number(t$3[r$4]), o$1 = gp(t$3[r$4 + e$3]);
								for (let t$4 = 0; t$4 < a; t$4++) s$1 += o$1, n$2[i$1++] = s$1;
							}
							return n$2;
						}(t$2, e$2.runs, e$2.numRleValues) : (function(t$3) {
							t$3[0] = t$3[0] >> 1n ^ -(1n & t$3[0]);
							const e$3 = t$3.length / 4 * 4;
							let r$3 = 1;
							if (e$3 >= 4) for (; r$3 < e$3 - 4; r$3 += 4) {
								const e$4 = t$3[r$3], n$2 = t$3[r$3 + 1], i$1 = t$3[r$3 + 2], s$1 = t$3[r$3 + 3];
								t$3[r$3] = (e$4 >> 1n ^ -(1n & e$4)) + t$3[r$3 - 1], t$3[r$3 + 1] = (n$2 >> 1n ^ -(1n & n$2)) + t$3[r$3], t$3[r$3 + 2] = (i$1 >> 1n ^ -(1n & i$1)) + t$3[r$3 + 1], t$3[r$3 + 3] = (s$1 >> 1n ^ -(1n & s$1)) + t$3[r$3 + 2];
							}
							for (; r$3 != t$3.length; ++r$3) t$3[r$3] = (t$3[r$3] >> 1n ^ -(1n & t$3[r$3])) + t$3[r$3 - 1];
						}(t$2), t$2);
						case rp.RLE: return function(t$3, e$3, r$3) {
							return r$3 ? function(t$4, e$4, r$4) {
								const n$2 = new BigInt64Array(r$4);
								let i$1 = 0;
								for (let r$5 = 0; r$5 < e$4; r$5++) {
									const s$1 = Number(t$4[r$5]);
									let a = t$4[r$5 + e$4];
									a = a >> 1n ^ -(1n & a), n$2.fill(a, i$1, i$1 + s$1), i$1 += s$1;
								}
								return n$2;
							}(t$3, e$3.runs, e$3.numRleValues) : bp(t$3, e$3.runs, e$3.numRleValues);
						}(t$2, e$2, r$2);
						case rp.NONE: return r$2 && function(t$3) {
							for (let e$3 = 0; e$3 < t$3.length; e$3++) {
								const r$3 = t$3[e$3];
								t$3[e$3] = r$3 >> 1n ^ -(1n & r$3);
							}
						}(t$2), t$2;
						default: throw new Error(`The specified Logical level technique is not supported: ${e$2.logicalLevelTechnique1}`);
					}
				}(fp(t$1, e$1, r$1.numValues), r$1, n$1);
			}
			function Bp(t$1, e$1, r$1, n$1) {
				const i$1 = fp(t$1, e$1, r$1.numValues);
				if (1 === i$1.length) {
					const t$2 = i$1[0];
					return n$1 ? gp(t$2) : t$2;
				}
				return n$1 ? function(t$2) {
					return gp(t$2[1]);
				}(i$1) : function(t$2) {
					return t$2[1];
				}(i$1);
			}
			function Vp(t$1, e$1, r$1, n$1, i$1) {
				return function(t$2, e$2, r$2, n$2) {
					switch (e$2.logicalLevelTechnique1) {
						case rp.DELTA: return e$2.logicalLevelTechnique2 === rp.RLE && (t$2 = vp(t$2, e$2.runs, e$2.numRleValues)), function(t$3, e$3) {
							const r$3 = new Int32Array(t$3.size());
							let n$3 = 0;
							t$3.get(0) ? (r$3[0] = t$3.get(0) ? e$3[0] >>> 1 ^ -(1 & e$3[0]) : 0, n$3 = 1) : r$3[0] = 0;
							let i$2 = 1;
							for (; i$2 != r$3.length; ++i$2) r$3[i$2] = t$3.get(i$2) ? r$3[i$2 - 1] + (e$3[n$3] >>> 1 ^ -(1 & e$3[n$3++])) : r$3[i$2 - 1];
							return r$3;
						}(n$2, t$2);
						case rp.RLE: return function(t$3, e$3, r$3, n$3) {
							const i$2 = e$3;
							return r$3 ? function(t$4, e$4, r$4) {
								const n$4 = new Int32Array(t$4.size());
								let i$3 = 0;
								for (let s$1 = 0; s$1 < r$4; s$1++) {
									const a = e$4[s$1];
									let o$1 = e$4[s$1 + r$4];
									o$1 = o$1 >>> 1 ^ -(1 & o$1);
									for (let e$5 = i$3; e$5 < i$3 + a; e$5++) t$4.get(e$5) ? n$4[e$5] = o$1 : (n$4[e$5] = 0, i$3++);
									i$3 += a;
								}
								return n$4;
							}(n$3, t$3, i$2.runs) : function(t$4, e$4, r$4) {
								const n$4 = new Int32Array(t$4.size());
								let i$3 = 0;
								for (let s$1 = 0; s$1 < r$4; s$1++) {
									const a = e$4[s$1], o$1 = e$4[s$1 + r$4];
									for (let e$5 = i$3; e$5 < i$3 + a; e$5++) t$4.get(e$5) ? n$4[e$5] = o$1 : (n$4[e$5] = 0, i$3++);
									i$3 += a;
								}
								return n$4;
							}(n$3, t$3, i$2.runs);
						}(t$2, e$2, r$2, n$2);
						case rp.MORTON: return _p(t$2), t$2;
						case rp.COMPONENTWISE_DELTA: return Sp(t$2), t$2;
						case rp.NONE: return t$2 = r$2 ? function(t$3, e$3) {
							const r$3 = new Int32Array(t$3.size());
							let n$3 = 0, i$2 = 0;
							for (; i$2 != r$3.length; ++i$2) if (t$3.get(i$2)) {
								const t$4 = e$3[n$3++];
								r$3[i$2] = t$4 >>> 1 ^ -(1 & t$4);
							} else r$3[i$2] = 0;
							return r$3;
						}(n$2, t$2) : function(t$3, e$3) {
							const r$3 = new Int32Array(t$3.size());
							let n$3 = 0, i$2 = 0;
							for (; i$2 != r$3.length; ++i$2) r$3[i$2] = t$3.get(i$2) ? e$3[n$3++] : 0;
							return r$3;
						}(n$2, t$2), t$2;
						default: throw new Error("The specified Logical level technique is not supported");
					}
				}(r$1.physicalLevelTechnique === np.FAST_PFOR ? yp() : pp(t$1, e$1, r$1.numValues), r$1, n$1, i$1);
			}
			function Cp(t$1, e$1, r$1, n$1) {
				const i$1 = t$1.logicalLevelTechnique1;
				if (i$1 === rp.RLE) return 1 === t$1.runs ? lp.CONST : lp.FLAT;
				const s$1 = e$1 instanceof Ep ? e$1.size() : e$1;
				if (i$1 === rp.DELTA && t$1.logicalLevelTechnique2 === rp.RLE) {
					const e$2 = t$1.runs, i$2 = 2;
					if (t$1.numRleValues !== s$1) return lp.FLAT;
					if (1 === e$2) return lp.SEQUENCE;
					if (2 === e$2) {
						const e$3 = n$1.get();
						let s$2;
						if (t$1.physicalLevelTechnique === np.VARINT) s$2 = pp(r$1, n$1, 4);
						else {
							const t$2 = n$1.get();
							s$2 = new Int32Array(r$1.buffer, r$1.byteOffset + t$2, 4);
						}
						if (n$1.set(e$3), s$2[2] === i$2 && s$2[3] === i$2) return lp.SEQUENCE;
					}
				}
				return 1 === t$1.numValues ? lp.CONST : lp.FLAT;
			}
			class Lp extends Zh {
				getValueFromBuffer(t$1) {
					return this.dataBuffer[t$1];
				}
			}
			class Op extends Wh {
				constructor(t$1, e$1, r$1, n$1) {
					super(t$1, BigInt64Array.of(e$1), r$1, n$1);
				}
				getValueFromBuffer(t$1) {
					return this.dataBuffer[0] + BigInt(t$1) * this.delta;
				}
			}
			class Rp {
				_geometryOffsets;
				_partOffsets;
				_ringOffsets;
				constructor(t$1, e$1, r$1) {
					this._geometryOffsets = t$1, this._partOffsets = e$1, this._ringOffsets = r$1;
				}
				get geometryOffsets() {
					return this._geometryOffsets;
				}
				get partOffsets() {
					return this._partOffsets;
				}
				get ringOffsets() {
					return this._ringOffsets;
				}
			}
			function Np(t$1, e$1, r$1) {
				return {
					x: $p(t$1, e$1) - r$1,
					y: $p(t$1 >> 1, e$1) - r$1
				};
			}
			function $p(t$1, e$1) {
				let r$1 = 0;
				for (let n$1 = 0; n$1 < e$1; n$1++) r$1 |= (t$1 & 1 << 2 * n$1) >> n$1;
				return r$1;
			}
			(function(t$1) {
				t$1[t$1.POINT = 0] = "POINT", t$1[t$1.LINESTRING = 1] = "LINESTRING", t$1[t$1.POLYGON = 2] = "POLYGON", t$1[t$1.MULTIPOINT = 3] = "MULTIPOINT", t$1[t$1.MULTILINESTRING = 4] = "MULTILINESTRING", t$1[t$1.MULTIPOLYGON = 5] = "MULTIPOLYGON";
			})(up || (up = {})), function(t$1) {
				t$1[t$1.POINT = 0] = "POINT", t$1[t$1.LINESTRING = 1] = "LINESTRING", t$1[t$1.POLYGON = 2] = "POLYGON";
			}(cp || (cp = {})), function(t$1) {
				t$1[t$1.MORTON = 0] = "MORTON", t$1[t$1.VEC_2 = 1] = "VEC_2", t$1[t$1.VEC_3 = 2] = "VEC_3";
			}(hp || (hp = {}));
			class Up {
				createPoint(t$1) {
					return [[t$1]];
				}
				createMultiPoint(t$1) {
					return t$1.map(((t$2) => [t$2]));
				}
				createLineString(t$1) {
					return [t$1];
				}
				createMultiLineString(t$1) {
					return t$1;
				}
				createPolygon(t$1, e$1) {
					return [t$1].concat(e$1);
				}
				createMultiPolygon(t$1) {
					return t$1.flat();
				}
			}
			function qp(t$1) {
				const e$1 = new Array(t$1.numGeometries);
				let n$1 = 1, i$1 = 1, s$1 = 1, a = 0;
				const o$1 = new Up();
				let l$1 = 0, u$1 = 0;
				const c$1 = t$1.mortonSettings, h$1 = t$1.topologyVector, p$1 = h$1.geometryOffsets, f$1 = h$1.partOffsets, d$1 = h$1.ringOffsets, y$1 = t$1.vertexOffsets, m$1 = t$1.containsPolygonGeometry(), g$1 = t$1.vertexBuffer;
				for (let h$2 = 0; h$2 < t$1.numGeometries; h$2++) {
					const x$1 = t$1.geometryType(h$2);
					if (x$1 === up.POINT) {
						if (y$1 && 0 !== y$1.length) if (t$1.vertexBufferType === hp.VEC_2) {
							const t$2 = 2 * y$1[u$1++], n$2 = new r(g$1[t$2], g$1[t$2 + 1]);
							e$1[a++] = o$1.createPoint(n$2);
						} else {
							const t$2 = Np(g$1[y$1[u$1++]], c$1.numBits, c$1.coordinateShift), n$2 = new r(t$2.x, t$2.y);
							e$1[a++] = o$1.createPoint(n$2);
						}
						else {
							const t$2 = new r(g$1[l$1++], g$1[l$1++]);
							e$1[a++] = o$1.createPoint(t$2);
						}
						p$1 && s$1++, f$1 && n$1++, d$1 && i$1++;
					} else if (x$1 === up.MULTIPOINT) {
						const t$2 = p$1[s$1] - p$1[s$1 - 1];
						s$1++;
						const n$2 = new Array(t$2);
						if (y$1 && 0 !== y$1.length) {
							for (let e$2 = 0; e$2 < t$2; e$2++) {
								const t$3 = 2 * y$1[u$1++];
								n$2[e$2] = new r(g$1[t$3], g$1[t$3 + 1]);
							}
							e$1[a++] = o$1.createMultiPoint(n$2);
						} else {
							for (let e$2 = 0; e$2 < t$2; e$2++) {
								const t$3 = g$1[l$1++], i$2 = g$1[l$1++];
								n$2[e$2] = new r(t$3, i$2);
							}
							e$1[a++] = o$1.createMultiPoint(n$2);
						}
					} else if (x$1 === up.LINESTRING) {
						let r$1, h$3 = 0;
						m$1 ? (h$3 = d$1[i$1] - d$1[i$1 - 1], i$1++) : h$3 = f$1[n$1] - f$1[n$1 - 1], n$1++, y$1 && 0 !== y$1.length ? (r$1 = t$1.vertexBufferType === hp.VEC_2 ? Zp(g$1, y$1, u$1, h$3, !1) : Hp(g$1, y$1, u$1, h$3, !1, c$1), u$1 += h$3) : (r$1 = Yp(g$1, l$1, h$3, !1), l$1 += 2 * h$3), e$1[a++] = o$1.createLineString(r$1), p$1 && s$1++;
					} else if (x$1 === up.POLYGON) {
						const r$1 = f$1[n$1] - f$1[n$1 - 1];
						n$1++;
						const h$3 = new Array(r$1 - 1);
						let m$2 = d$1[i$1] - d$1[i$1 - 1];
						if (i$1++, y$1 && 0 !== y$1.length) {
							const r$2 = t$1.vertexBufferType === hp.VEC_2 ? Gp(g$1, y$1, u$1, m$2) : Xp(g$1, y$1, u$1, m$2, 0, c$1);
							u$1 += m$2;
							for (let e$2 = 0; e$2 < h$3.length; e$2++) m$2 = d$1[i$1] - d$1[i$1 - 1], i$1++, h$3[e$2] = t$1.vertexBufferType === hp.VEC_2 ? Gp(g$1, y$1, u$1, m$2) : Xp(g$1, y$1, u$1, m$2, 0, c$1), u$1 += m$2;
							e$1[a++] = o$1.createPolygon(r$2, h$3);
						} else {
							const t$2 = jp(g$1, l$1, m$2);
							l$1 += 2 * m$2;
							for (let t$3 = 0; t$3 < h$3.length; t$3++) m$2 = d$1[i$1] - d$1[i$1 - 1], i$1++, h$3[t$3] = jp(g$1, l$1, m$2), l$1 += 2 * m$2;
							e$1[a++] = o$1.createPolygon(t$2, h$3);
						}
						p$1 && s$1++;
					} else if (x$1 === up.MULTILINESTRING) {
						const r$1 = p$1[s$1] - p$1[s$1 - 1];
						s$1++;
						const h$3 = new Array(r$1);
						if (y$1 && 0 !== y$1.length) {
							for (let e$2 = 0; e$2 < r$1; e$2++) {
								let r$2 = 0;
								m$1 ? (r$2 = d$1[i$1] - d$1[i$1 - 1], i$1++) : r$2 = f$1[n$1] - f$1[n$1 - 1], n$1++;
								h$3[e$2] = t$1.vertexBufferType === hp.VEC_2 ? Zp(g$1, y$1, u$1, r$2, !1) : Hp(g$1, y$1, u$1, r$2, !1, c$1), u$1 += r$2;
							}
							e$1[a++] = o$1.createMultiLineString(h$3);
						} else {
							for (let t$2 = 0; t$2 < r$1; t$2++) {
								let e$2 = 0;
								m$1 ? (e$2 = d$1[i$1] - d$1[i$1 - 1], i$1++) : e$2 = f$1[n$1] - f$1[n$1 - 1], n$1++, h$3[t$2] = Yp(g$1, l$1, e$2, !1), l$1 += 2 * e$2;
							}
							e$1[a++] = o$1.createMultiLineString(h$3);
						}
					} else {
						if (x$1 !== up.MULTIPOLYGON) throw new Error("The specified geometry type is currently not supported.");
						{
							const r$1 = p$1[s$1] - p$1[s$1 - 1];
							s$1++;
							const h$3 = new Array(r$1);
							let m$2 = 0;
							if (y$1 && 0 !== y$1.length) {
								for (let e$2 = 0; e$2 < r$1; e$2++) {
									const r$2 = f$1[n$1] - f$1[n$1 - 1];
									n$1++;
									const s$2 = new Array(r$2 - 1);
									m$2 = d$1[i$1] - d$1[i$1 - 1], i$1++;
									const a$1 = t$1.vertexBufferType === hp.VEC_2 ? Gp(g$1, y$1, u$1, m$2) : Xp(g$1, y$1, u$1, m$2, 0, c$1);
									u$1 += m$2;
									for (let e$3 = 0; e$3 < s$2.length; e$3++) m$2 = d$1[i$1] - d$1[i$1 - 1], i$1++, s$2[e$3] = t$1.vertexBufferType === hp.VEC_2 ? Gp(g$1, y$1, u$1, m$2) : Xp(g$1, y$1, u$1, m$2, 0, c$1), u$1 += m$2;
									h$3[e$2] = o$1.createPolygon(a$1, s$2);
								}
								e$1[a++] = o$1.createMultiPolygon(h$3);
							} else {
								for (let t$2 = 0; t$2 < r$1; t$2++) {
									const e$2 = f$1[n$1] - f$1[n$1 - 1];
									n$1++;
									const r$2 = new Array(e$2 - 1);
									m$2 = d$1[i$1] - d$1[i$1 - 1], i$1++;
									const s$2 = jp(g$1, l$1, m$2);
									l$1 += 2 * m$2;
									for (let t$3 = 0; t$3 < r$2.length; t$3++) {
										const e$3 = d$1[i$1] - d$1[i$1 - 1];
										i$1++, r$2[t$3] = jp(g$1, l$1, e$3), l$1 += 2 * e$3;
									}
									h$3[t$2] = o$1.createPolygon(s$2, r$2);
								}
								e$1[a++] = o$1.createMultiPolygon(h$3);
							}
						}
					}
				}
				return e$1;
			}
			function jp(t$1, e$1, r$1) {
				return Yp(t$1, e$1, r$1, !0);
			}
			function Gp(t$1, e$1, r$1, n$1) {
				return Zp(t$1, e$1, r$1, n$1, !0);
			}
			function Xp(t$1, e$1, r$1, n$1, i$1, s$1) {
				return Hp(t$1, e$1, r$1, n$1, !0, s$1);
			}
			function Yp(t$1, e$1, n$1, i$1) {
				const s$1 = new Array(i$1 ? n$1 + 1 : n$1);
				for (let i$2 = 0; i$2 < 2 * n$1; i$2 += 2) s$1[i$2 / 2] = new r(t$1[e$1 + i$2], t$1[e$1 + i$2 + 1]);
				return i$1 && (s$1[s$1.length - 1] = s$1[0]), s$1;
			}
			function Zp(t$1, e$1, n$1, i$1, s$1) {
				const a = new Array(s$1 ? i$1 + 1 : i$1);
				for (let s$2 = 0; s$2 < 2 * i$1; s$2 += 2) {
					const i$2 = 2 * e$1[n$1 + s$2 / 2];
					a[s$2 / 2] = new r(t$1[i$2], t$1[i$2 + 1]);
				}
				return s$1 && (a[a.length - 1] = a[0]), a;
			}
			function Hp(t$1, e$1, n$1, i$1, s$1, a) {
				const o$1 = new Array(s$1 ? i$1 + 1 : i$1);
				for (let s$2 = 0; s$2 < i$1; s$2++) {
					const i$2 = Np(t$1[e$1[n$1 + s$2]], a.numBits, a.coordinateShift);
					o$1[s$2] = new r(i$2.x, i$2.y);
				}
				return s$1 && (o$1[o$1.length - 1] = o$1[0]), o$1;
			}
			class Kp {
				_vertexBufferType;
				_topologyVector;
				_vertexOffsets;
				_vertexBuffer;
				_mortonSettings;
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this._vertexBufferType = t$1, this._topologyVector = e$1, this._vertexOffsets = r$1, this._vertexBuffer = n$1, this._mortonSettings = i$1;
				}
				get vertexBufferType() {
					return this._vertexBufferType;
				}
				get topologyVector() {
					return this._topologyVector;
				}
				get vertexOffsets() {
					return this._vertexOffsets;
				}
				get vertexBuffer() {
					return this._vertexBuffer;
				}
				*[Symbol.iterator]() {
					const t$1 = qp(this);
					let e$1 = 0;
					for (; e$1 < this.numGeometries;) yield {
						coordinates: t$1[e$1],
						type: this.geometryType(e$1)
					}, e$1++;
				}
				getSimpleEncodedVertex(t$1) {
					const e$1 = this.vertexOffsets ? 2 * this.vertexOffsets[t$1] : 2 * t$1;
					return [this.vertexBuffer[e$1], this.vertexBuffer[e$1 + 1]];
				}
				getVertex(t$1) {
					if (this.vertexOffsets && this.mortonSettings) {
						const e$2 = Np(this.vertexBuffer[this.vertexOffsets[t$1]], this.mortonSettings.numBits, this.mortonSettings.coordinateShift);
						return [e$2.x, e$2.y];
					}
					const e$1 = this.vertexOffsets ? 2 * this.vertexOffsets[t$1] : 2 * t$1;
					return [this.vertexBuffer[e$1], this.vertexBuffer[e$1 + 1]];
				}
				getGeometries() {
					return qp(this);
				}
				get mortonSettings() {
					return this._mortonSettings;
				}
			}
			class Wp extends Kp {
				_numGeometries;
				_geometryType;
				constructor(t$1, e$1, r$1, n$1, i$1, s$1, a) {
					super(r$1, n$1, i$1, s$1, a), this._numGeometries = t$1, this._geometryType = e$1;
				}
				geometryType(t$1) {
					return this._geometryType;
				}
				get numGeometries() {
					return this._numGeometries;
				}
				containsPolygonGeometry() {
					return this._geometryType === up.POLYGON || this._geometryType === up.MULTIPOLYGON;
				}
				containsSingleGeometryType() {
					return !0;
				}
			}
			class Jp extends Kp {
				_geometryTypes;
				constructor(t$1, e$1, r$1, n$1, i$1, s$1) {
					super(t$1, r$1, n$1, i$1, s$1), this._geometryTypes = e$1;
				}
				geometryType(t$1) {
					return this._geometryTypes[t$1];
				}
				get numGeometries() {
					return this._geometryTypes.length;
				}
				containsPolygonGeometry() {
					for (let t$1 = 0; t$1 < this.numGeometries; t$1++) if (this.geometryType(t$1) === up.POLYGON || this.geometryType(t$1) === up.MULTIPOLYGON) return !0;
					return !1;
				}
				containsSingleGeometryType() {
					return !1;
				}
			}
			class Qp {
				_triangleOffsets;
				_indexBuffer;
				_vertexBuffer;
				_topologyVector;
				constructor(t$1, e$1, r$1, n$1) {
					this._triangleOffsets = t$1, this._indexBuffer = e$1, this._vertexBuffer = r$1, this._topologyVector = n$1;
				}
				get triangleOffsets() {
					return this._triangleOffsets;
				}
				get indexBuffer() {
					return this._indexBuffer;
				}
				get vertexBuffer() {
					return this._vertexBuffer;
				}
				get topologyVector() {
					return this._topologyVector;
				}
				getGeometries() {
					if (!this._topologyVector) throw new Error("Cannot convert GpuVector to coordinates without topology information");
					const t$1 = new Array(this.numGeometries), e$1 = this._topologyVector, n$1 = e$1.partOffsets, i$1 = e$1.ringOffsets, s$1 = e$1.geometryOffsets;
					let a = 0, o$1 = 1, l$1 = 1, u$1 = 1;
					for (let e$2 = 0; e$2 < this.numGeometries; e$2++) switch (this.geometryType(e$2)) {
						case up.POLYGON:
							{
								const c$1 = n$1[o$1] - n$1[o$1 - 1];
								o$1++;
								const h$1 = [];
								for (let t$2 = 0; t$2 < c$1; t$2++) {
									const t$3 = i$1[l$1] - i$1[l$1 - 1];
									l$1++;
									const e$3 = [];
									for (let n$2 = 0; n$2 < t$3; n$2++) {
										const t$4 = this._vertexBuffer[a++], n$3 = this._vertexBuffer[a++];
										e$3.push(new r(t$4, n$3));
									}
									e$3.length > 0 && e$3.push(e$3[0]), h$1.push(e$3);
								}
								t$1[e$2] = h$1, s$1 && u$1++;
							}
							break;
						case up.MULTIPOLYGON: {
							const c$1 = s$1[u$1] - s$1[u$1 - 1];
							u$1++;
							const h$1 = [];
							for (let t$2 = 0; t$2 < c$1; t$2++) {
								const t$3 = n$1[o$1] - n$1[o$1 - 1];
								o$1++;
								for (let e$3 = 0; e$3 < t$3; e$3++) {
									const t$4 = i$1[l$1] - i$1[l$1 - 1];
									l$1++;
									const e$4 = [];
									for (let n$2 = 0; n$2 < t$4; n$2++) {
										const t$5 = this._vertexBuffer[a++], n$3 = this._vertexBuffer[a++];
										e$4.push(new r(t$5, n$3));
									}
									e$4.length > 0 && e$4.push(e$4[0]), h$1.push(e$4);
								}
							}
							t$1[e$2] = h$1;
						}
					}
					return t$1;
				}
				[Symbol.iterator]() {
					return null;
				}
			}
			function tf(t$1, e$1, r$1, n$1, i$1, s$1) {
				return new ef(t$1, e$1, r$1, n$1, i$1, s$1);
			}
			class ef extends Qp {
				_numGeometries;
				_geometryType;
				constructor(t$1, e$1, r$1, n$1, i$1, s$1) {
					super(r$1, n$1, i$1, s$1), this._numGeometries = t$1, this._geometryType = e$1;
				}
				geometryType(t$1) {
					return this._geometryType;
				}
				get numGeometries() {
					return this._numGeometries;
				}
				containsSingleGeometryType() {
					return !0;
				}
			}
			function rf(t$1, e$1, r$1, n$1, i$1) {
				return new nf(t$1, e$1, r$1, n$1, i$1);
			}
			class nf extends Qp {
				_geometryTypes;
				constructor(t$1, e$1, r$1, n$1, i$1) {
					super(e$1, r$1, n$1, i$1), this._geometryTypes = t$1;
				}
				geometryType(t$1) {
					return this._geometryTypes[t$1];
				}
				get numGeometries() {
					return this._geometryTypes.length;
				}
				containsSingleGeometryType() {
					return !1;
				}
			}
			function sf(t$1, e$1, r$1, n$1, i$1) {
				const s$1 = kp(t$1, r$1);
				let a = null, o$1 = null, l$1 = null, u$1 = null, c$1 = null, h$1 = null, p$1 = null, f$1 = null;
				if (Cp(s$1, n$1, t$1, r$1) === lp.CONST) {
					const i$2 = Fp(t$1, r$1, s$1, !1);
					for (let n$2 = 0; n$2 < e$1 - 1; n$2++) {
						const e$2 = kp(t$1, r$1);
						switch (e$2.physicalStreamType) {
							case ip.LENGTH:
								switch (e$2.logicalStreamType.lengthType) {
									case op.GEOMETRIES:
										a = Ip(t$1, r$1, e$2);
										break;
									case op.PARTS:
										o$1 = Ip(t$1, r$1, e$2);
										break;
									case op.RINGS:
										l$1 = Ip(t$1, r$1, e$2);
										break;
									case op.TRIANGLES: p$1 = Ip(t$1, r$1, e$2);
								}
								break;
							case ip.OFFSET:
								switch (e$2.logicalStreamType.offsetType) {
									case ap.VERTEX:
										u$1 = Tp(t$1, r$1, e$2, !1);
										break;
									case ap.INDEX: f$1 = Tp(t$1, r$1, e$2, !1);
								}
								break;
							case ip.DATA: sp.VERTEX === e$2.logicalStreamType.dictionaryType ? c$1 = Tp(t$1, r$1, e$2, !0) : (h$1 = {
								numBits: e$2.numBits,
								coordinateShift: e$2.coordinateShift
							}, c$1 = Tp(t$1, r$1, e$2, !1));
						}
					}
					return null !== f$1 ? null != a || null != o$1 ? tf(n$1, i$2, p$1, f$1, c$1, new Rp(a, o$1, l$1)) : tf(n$1, i$2, p$1, f$1, c$1) : null === h$1 ? function(t$2, e$2, r$2, n$2, i$3) {
						return new Wp(t$2, e$2, hp.VEC_2, r$2, n$2, i$3);
					}(n$1, i$2, new Rp(a, o$1, l$1), u$1, c$1) : function(t$2, e$2, r$2, n$2, i$3, s$2) {
						return new Wp(t$2, e$2, hp.MORTON, r$2, n$2, i$3, s$2);
					}(n$1, i$2, new Rp(a, o$1, l$1), u$1, c$1, h$1);
				}
				const d$1 = Tp(t$1, r$1, s$1, !1);
				for (let n$2 = 0; n$2 < e$1 - 1; n$2++) {
					const e$2 = kp(t$1, r$1);
					switch (e$2.physicalStreamType) {
						case ip.LENGTH:
							switch (e$2.logicalStreamType.lengthType) {
								case op.GEOMETRIES:
									a = Tp(t$1, r$1, e$2, !1);
									break;
								case op.PARTS:
									o$1 = Tp(t$1, r$1, e$2, !1);
									break;
								case op.RINGS:
									l$1 = Tp(t$1, r$1, e$2, !1);
									break;
								case op.TRIANGLES: p$1 = Ip(t$1, r$1, e$2);
							}
							break;
						case ip.OFFSET:
							switch (e$2.logicalStreamType.offsetType) {
								case ap.VERTEX:
									u$1 = Tp(t$1, r$1, e$2, !1);
									break;
								case ap.INDEX: f$1 = Tp(t$1, r$1, e$2, !1);
							}
							break;
						case ip.DATA: sp.VERTEX === e$2.logicalStreamType.dictionaryType ? c$1 = Tp(t$1, r$1, e$2, !0) : (h$1 = {
							numBits: e$2.numBits,
							coordinateShift: e$2.coordinateShift
						}, c$1 = Tp(t$1, r$1, e$2, !1));
					}
				}
				return null !== f$1 && null === o$1 ? rf(d$1, p$1, f$1, c$1) : (null !== a ? (a = af(d$1, a, 2), null !== o$1 && null !== l$1 ? (o$1 = of(d$1, a, o$1, !1), l$1 = function(t$2, e$2, r$2, n$2) {
					const i$2 = new Int32Array(r$2[r$2.length - 1] + 1);
					let s$2 = 0;
					i$2[0] = s$2;
					let a$1 = 1, o$2 = 1, l$2 = 0;
					for (let u$2 = 0; u$2 < t$2.length; u$2++) {
						const c$2 = t$2[u$2], h$2 = e$2[u$2 + 1] - e$2[u$2];
						if (0 !== c$2 && 3 !== c$2) for (let t$3 = 0; t$3 < h$2; t$3++) {
							const t$4 = r$2[a$1] - r$2[a$1 - 1];
							a$1++;
							for (let e$3 = 0; e$3 < t$4; e$3++) s$2 = i$2[o$2++] = s$2 + n$2[l$2++];
						}
						else for (let t$3 = 0; t$3 < h$2; t$3++) i$2[o$2++] = ++s$2, a$1++;
					}
					return i$2;
				}(d$1, a, o$1, l$1)) : null !== o$1 && (o$1 = function(t$2, e$2, r$2) {
					const n$2 = new Int32Array(e$2[e$2.length - 1] + 1);
					let i$2 = 0;
					n$2[0] = i$2;
					let s$2 = 1, a$1 = 0;
					for (let o$2 = 0; o$2 < t$2.length; o$2++) {
						const l$2 = t$2[o$2], u$2 = e$2[o$2 + 1] - e$2[o$2];
						if (4 === l$2 || 1 === l$2) for (let t$3 = 0; t$3 < u$2; t$3++) i$2 = n$2[s$2++] = i$2 + r$2[a$1++];
						else for (let t$3 = 0; t$3 < u$2; t$3++) n$2[s$2++] = ++i$2;
					}
					return n$2;
				}(d$1, a, o$1))) : null !== o$1 && null !== l$1 ? (o$1 = af(d$1, o$1, 1), l$1 = of(d$1, o$1, l$1, !0)) : null !== o$1 && (o$1 = af(d$1, o$1, 0)), null !== f$1 ? rf(d$1, p$1, f$1, c$1, new Rp(a, o$1, l$1)) : null === h$1 ? function(t$2, e$2, r$2, n$2) {
					return new Jp(hp.VEC_2, t$2, e$2, r$2, n$2);
				}(d$1, new Rp(a, o$1, l$1), u$1, c$1) : function(t$2, e$2, r$2, n$2, i$2) {
					return new Jp(hp.MORTON, t$2, e$2, r$2, n$2, i$2);
				}(d$1, new Rp(a, o$1, l$1), u$1, c$1, h$1));
			}
			function af(t$1, e$1, r$1) {
				const n$1 = new Int32Array(t$1.length + 1);
				let i$1 = 0;
				n$1[0] = i$1;
				let s$1 = 0;
				for (let a = 0; a < t$1.length; a++) i$1 = n$1[a + 1] = i$1 + (t$1[a] > r$1 ? e$1[s$1++] : 1);
				return n$1;
			}
			function of(t$1, e$1, r$1, n$1) {
				const i$1 = new Int32Array(e$1[e$1.length - 1] + 1);
				let s$1 = 0;
				i$1[0] = s$1;
				let a = 1, o$1 = 0;
				for (let l$1 = 0; l$1 < t$1.length; l$1++) {
					const u$1 = t$1[l$1], c$1 = e$1[l$1 + 1] - e$1[l$1];
					if (5 === u$1 || 2 === u$1 || n$1 && (4 === u$1 || 1 === u$1)) for (let t$2 = 0; t$2 < c$1; t$2++) s$1 = i$1[a++] = s$1 + r$1[o$1++];
					else for (let t$2 = 0; t$2 < c$1; t$2++) i$1[a++] = ++s$1;
				}
				return i$1;
			}
			class lf extends Yh {
				dataVector;
				constructor(t$1, e$1, r$1) {
					super(t$1, e$1.getBuffer(), r$1), this.dataVector = e$1;
				}
				getValueFromBuffer(t$1) {
					return this.dataVector.get(t$1);
				}
			}
			class uf extends Zh {
				getValueFromBuffer(t$1) {
					return this.dataBuffer[t$1];
				}
			}
			class cf extends Yh {
				constructor(t$1, e$1, r$1) {
					super(t$1, BigInt64Array.of(e$1), r$1);
				}
				getValueFromBuffer(t$1) {
					return this.dataBuffer[0];
				}
			}
			function hf(t$1, e$1, r$1) {
				return pf(t$1, Math.ceil(e$1 / 8), r$1);
			}
			function pf(t$1, e$1, r$1) {
				const n$1 = new Uint8Array(e$1);
				let i$1 = 0;
				for (; i$1 < e$1;) {
					const e$2 = t$1[r$1.increment()];
					if (e$2 <= 127) {
						const s$1 = e$2 + 3, a = t$1[r$1.increment()], o$1 = i$1 + s$1;
						n$1.fill(a, i$1, o$1), i$1 = o$1;
					} else {
						const s$1 = 256 - e$2;
						for (let e$3 = 0; e$3 < s$1; e$3++) n$1[i$1++] = t$1[r$1.increment()];
					}
				}
				return n$1;
			}
			const ff = new TextDecoder();
			function df(t$1, e$1, r$1) {
				return r$1 - e$1 >= 12 ? ff.decode(t$1.subarray(e$1, r$1)) : function(t$2, e$2, r$2) {
					let n$1 = "", i$1 = e$2;
					for (; i$1 < r$2;) {
						const e$3 = t$2[i$1];
						let s$1, a, o$1, l$1 = null, u$1 = e$3 > 239 ? 4 : e$3 > 223 ? 3 : e$3 > 191 ? 2 : 1;
						if (i$1 + u$1 > r$2) break;
						1 === u$1 ? e$3 < 128 && (l$1 = e$3) : 2 === u$1 ? (s$1 = t$2[i$1 + 1], 128 == (192 & s$1) && (l$1 = (31 & e$3) << 6 | 63 & s$1, l$1 <= 127 && (l$1 = null))) : 3 === u$1 ? (s$1 = t$2[i$1 + 1], a = t$2[i$1 + 2], 128 == (192 & s$1) && 128 == (192 & a) && (l$1 = (15 & e$3) << 12 | (63 & s$1) << 6 | 63 & a, (l$1 <= 2047 || l$1 >= 55296 && l$1 <= 57343) && (l$1 = null))) : 4 === u$1 && (s$1 = t$2[i$1 + 1], a = t$2[i$1 + 2], o$1 = t$2[i$1 + 3], 128 == (192 & s$1) && 128 == (192 & a) && 128 == (192 & o$1) && (l$1 = (15 & e$3) << 18 | (63 & s$1) << 12 | (63 & a) << 6 | 63 & o$1, (l$1 <= 65535 || l$1 >= 1114112) && (l$1 = null))), null === l$1 ? (l$1 = 65533, u$1 = 1) : l$1 > 65535 && (l$1 -= 65536, n$1 += String.fromCharCode(l$1 >>> 10 & 1023 | 55296), l$1 = 56320 | 1023 & l$1), n$1 += String.fromCharCode(l$1), i$1 += u$1;
					}
					return n$1;
				}(t$1, e$1, r$1);
			}
			class yf extends Yh {
				offsetBuffer;
				constructor(t$1, e$1, r$1, n$1) {
					super(t$1, r$1, n$1), this.offsetBuffer = e$1;
				}
			}
			class mf extends yf {
				textEncoder;
				constructor(t$1, e$1, r$1, n$1) {
					super(t$1, e$1, r$1, n$1 ?? e$1.length - 1), this.textEncoder = new TextEncoder();
				}
				getValueFromBuffer(t$1) {
					return df(this.dataBuffer, this.offsetBuffer[t$1], this.offsetBuffer[t$1 + 1]);
				}
			}
			class gf extends yf {
				indexBuffer;
				textEncoder;
				constructor(t$1, e$1, r$1, n$1, i$1) {
					super(t$1, r$1, n$1, i$1 ?? e$1.length), this.indexBuffer = e$1, this.indexBuffer = e$1, this.textEncoder = new TextEncoder();
				}
				getValueFromBuffer(t$1) {
					const e$1 = this.indexBuffer[t$1];
					return df(this.dataBuffer, this.offsetBuffer[e$1], this.offsetBuffer[e$1 + 1]);
				}
			}
			class xf extends yf {
				indexBuffer;
				symbolOffsetBuffer;
				symbolTableBuffer;
				textEncoder;
				symbolLengthBuffer;
				lengthBuffer;
				decodedDictionary;
				constructor(t$1, e$1, r$1, n$1, i$1, s$1, a) {
					super(t$1, r$1, n$1, a), this.indexBuffer = e$1, this.symbolOffsetBuffer = i$1, this.symbolTableBuffer = s$1, this.textEncoder = new TextEncoder();
				}
				getValueFromBuffer(t$1) {
					this.decodedDictionary ?? (this.symbolLengthBuffer ?? (this.symbolLengthBuffer = this.offsetToLengthBuffer(this.symbolOffsetBuffer), this.lengthBuffer = this.offsetToLengthBuffer(this.offsetBuffer)), this.decodedDictionary = function(t$2, e$2, r$1) {
						const n$1 = [], i$1 = new Array(e$2.length).fill(0);
						for (let t$3 = 1; t$3 < e$2.length; t$3++) i$1[t$3] = i$1[t$3 - 1] + e$2[t$3 - 1];
						for (let s$1 = 0; s$1 < r$1.length; s$1++) if (255 === r$1[s$1]) n$1.push(r$1[++s$1]);
						else {
							const a = e$2[r$1[s$1]], o$1 = i$1[r$1[s$1]];
							for (let e$3 = 0; e$3 < a; e$3++) n$1.push(t$2[o$1 + e$3]);
						}
						return new Uint8Array(n$1);
					}(this.symbolTableBuffer, this.symbolLengthBuffer, this.dataBuffer));
					const e$1 = this.indexBuffer[t$1];
					return df(this.decodedDictionary, this.offsetBuffer[e$1], this.offsetBuffer[e$1 + 1]);
				}
				offsetToLengthBuffer(t$1) {
					const e$1 = new Uint32Array(t$1.length - 1);
					let r$1 = t$1[0];
					for (let n$1 = 1; n$1 < t$1.length; n$1++) {
						const i$1 = t$1[n$1];
						e$1[n$1 - 1] = i$1 - r$1, r$1 = i$1;
					}
					return e$1;
				}
			}
			function vf(t$1, e$1, r$1, n$1, i$1, s$1) {
				return "scalarType" === r$1.type ? function(t$2, e$2, r$2, n$2, i$2, s$2) {
					let a = null, o$1 = 0;
					if (0 === t$2) return null;
					if (s$2.nullable) {
						const t$3 = kp(e$2, r$2);
						o$1 = t$3.numValues;
						const n$3 = r$2.get(), i$3 = hf(e$2, o$1, r$2);
						r$2.set(n$3 + t$3.byteLength), a = new Ep(i$3, t$3.numValues);
					}
					const l$1 = a ?? n$2;
					switch (i$2.physicalType) {
						case 4:
						case 3: return function(t$3, e$3, r$3, n$3, i$3) {
							const s$3 = kp(t$3, e$3), a$1 = Cp(s$3, i$3, t$3, e$3), o$2 = 3 === n$3.physicalType;
							if (a$1 === lp.FLAT) {
								const n$4 = bf(i$3) ? Vp(t$3, e$3, s$3, o$2, i$3) : Tp(t$3, e$3, s$3, o$2);
								return new Hh(r$3.name, n$4, i$3);
							}
							if (a$1 === lp.SEQUENCE) {
								const n$4 = Dp(t$3, e$3, s$3);
								return new Jh(r$3.name, n$4[0], n$4[1], s$3.numRleValues);
							}
							{
								const n$4 = Fp(t$3, e$3, s$3, o$2);
								return new Qh(r$3.name, n$4, i$3);
							}
						}(e$2, r$2, s$2, i$2, l$1);
						case 9: return function(t$3, e$3, r$3, n$3, i$3) {
							let s$3 = null, a$1 = null, o$2 = null, l$2 = null, u$1 = null, c$1 = null, h$1 = null, p$1 = null;
							for (let t$4 = 0; t$4 < n$3; t$4++) {
								const t$5 = kp(e$3, r$3);
								if (0 !== t$5.byteLength) switch (t$5.physicalStreamType) {
									case ip.PRESENT:
										c$1 = new Ep(hf(e$3, t$5.numValues, r$3), t$5.numValues);
										break;
									case ip.OFFSET:
										a$1 = null != i$3 || null != c$1 ? Vp(e$3, r$3, t$5, !1, i$3 ?? c$1) : Tp(e$3, r$3, t$5, !1);
										break;
									case ip.LENGTH: {
										const n$4 = Ip(e$3, r$3, t$5);
										op.DICTIONARY === t$5.logicalStreamType.lengthType ? s$3 = n$4 : op.SYMBOL === t$5.logicalStreamType.lengthType ? l$2 = n$4 : h$1 = n$4;
										break;
									}
									case ip.DATA: {
										const n$4 = e$3.subarray(r$3.get(), r$3.get() + t$5.byteLength);
										r$3.add(t$5.byteLength);
										const i$4 = t$5.logicalStreamType.dictionaryType;
										sp.FSST === i$4 ? u$1 = n$4 : sp.SINGLE === i$4 || sp.SHARED === i$4 ? o$2 = n$4 : sp.NONE === i$4 && (p$1 = n$4);
										break;
									}
								}
							}
							return function(t$4, e$4, r$4, n$4, i$4, s$4, a$2) {
								return e$4 ? new xf(t$4, r$4, n$4, i$4, s$4, e$4, a$2) : null;
							}(t$3, u$1, a$1, s$3, o$2, l$2, i$3 ?? c$1) ?? function(t$4, e$4, r$4, n$4, i$4) {
								return e$4 ? i$4 ? new gf(t$4, r$4, n$4, e$4, i$4) : new gf(t$4, r$4, n$4, e$4) : null;
							}(t$3, o$2, a$1, s$3, i$3 ?? c$1) ?? function(t$4, e$4, r$4, n$4, i$4) {
								if (!e$4 || !r$4) return null;
								if (n$4) return i$4 ? new gf(t$4, n$4, e$4, r$4, i$4) : new gf(t$4, n$4, e$4, r$4);
								if (i$4 && i$4.size() !== e$4.length - 1) {
									const n$5 = new Int32Array(i$4.size());
									let s$4 = 0;
									for (let t$5 = 0; t$5 < i$4.size(); t$5++) n$5[t$5] = i$4.get(t$5) ? s$4++ : 0;
									return new gf(t$4, n$5, e$4, r$4, i$4);
								}
								return i$4 ? new mf(t$4, e$4, r$4, i$4) : new mf(t$4, e$4, r$4);
							}(t$3, h$1, p$1, a$1, i$3 ?? c$1);
						}(s$2.name, e$2, r$2, s$2.nullable ? t$2 - 1 : t$2, a);
						case 0: return function(t$3, e$3, r$3, n$3, i$3) {
							const s$3 = kp(t$3, e$3), a$1 = s$3.numValues, o$2 = e$3.get(), l$2 = bf(i$3) ? function(t$4, e$4, r$4, n$4) {
								const s$4 = new Ep(pf(t$4, Math.ceil(e$4 / 8), r$4), e$4), a$2 = n$4.size(), o$3 = new Ep(new Uint8Array(a$2), a$2);
								let l$3 = 0;
								for (let t$5 = 0; t$5 < n$4.size(); t$5++) {
									const e$5 = !!n$4.get(t$5) && s$4.get(l$3++);
									o$3.set(t$5, e$5);
								}
								return o$3.getBuffer();
							}(t$3, a$1, e$3, i$3) : hf(t$3, a$1, e$3);
							e$3.set(o$2 + s$3.byteLength);
							const u$1 = new Ep(l$2, a$1);
							return new lf(r$3.name, u$1, i$3);
						}(e$2, r$2, s$2, 0, l$1);
						case 6:
						case 5: return function(t$3, e$3, r$3, n$3, i$3) {
							const s$3 = kp(t$3, e$3), a$1 = Cp(s$3, n$3, t$3, e$3), o$2 = 5 === i$3.physicalType;
							if (a$1 === lp.FLAT) {
								const i$4 = bf(n$3) ? function(t$4, e$4, r$4, n$4, i$5) {
									return function(t$5, e$5, r$5, n$5) {
										switch (e$5.logicalLevelTechnique1) {
											case rp.DELTA: return e$5.logicalLevelTechnique2 === rp.RLE && (t$5 = bp(t$5, e$5.runs, e$5.numRleValues)), function(t$6, e$6) {
												const r$6 = new BigInt64Array(t$6.size());
												let n$6 = 0;
												t$6.get(0) ? (r$6[0] = t$6.get(0) ? e$6[0] >> 1n ^ -(1n & e$6[0]) : 0n, n$6 = 1) : r$6[0] = 0n;
												let i$6 = 1;
												for (; i$6 != r$6.length; ++i$6) r$6[i$6] = t$6.get(i$6) ? r$6[i$6 - 1] + (e$6[n$6] >> 1n ^ -(1n & e$6[n$6++])) : r$6[i$6 - 1];
												return r$6;
											}(n$5, t$5);
											case rp.RLE: return function(t$6, e$6, r$6, n$6) {
												const i$6 = e$6;
												return r$6 ? function(t$7, e$7, r$7) {
													const n$7 = new BigInt64Array(t$7.size());
													let i$7 = 0;
													for (let s$4 = 0; s$4 < r$7; s$4++) {
														const a$2 = Number(e$7[s$4]);
														let o$3 = e$7[s$4 + r$7];
														o$3 = o$3 >> 1n ^ -(1n & o$3);
														for (let e$8 = i$7; e$8 < i$7 + a$2; e$8++) t$7.get(e$8) ? n$7[e$8] = o$3 : (n$7[e$8] = 0n, i$7++);
														i$7 += a$2;
													}
													return n$7;
												}(n$6, t$6, i$6.runs) : function(t$7, e$7, r$7) {
													const n$7 = new BigInt64Array(t$7.size());
													let i$7 = 0;
													for (let s$4 = 0; s$4 < r$7; s$4++) {
														const a$2 = Number(e$7[s$4]), o$3 = e$7[s$4 + r$7];
														for (let e$8 = i$7; e$8 < i$7 + a$2; e$8++) t$7.get(e$8) ? n$7[e$8] = o$3 : (n$7[e$8] = 0n, i$7++);
														i$7 += a$2;
													}
													return n$7;
												}(n$6, t$6, i$6.runs);
											}(t$5, e$5, r$5, n$5);
											case rp.NONE: return t$5 = r$5 ? function(t$6, e$6) {
												const r$6 = new BigInt64Array(t$6.size());
												let n$6 = 0, i$6 = 0;
												for (; i$6 != r$6.length; ++i$6) if (t$6.get(i$6)) {
													const t$7 = e$6[n$6++];
													r$6[i$6] = t$7 >> 1n ^ -(1n & t$7);
												} else r$6[i$6] = 0n;
												return r$6;
											}(n$5, t$5) : function(t$6, e$6) {
												const r$6 = new BigInt64Array(t$6.size());
												let n$6 = 0, i$6 = 0;
												for (; i$6 != r$6.length; ++i$6) r$6[i$6] = t$6.get(i$6) ? e$6[n$6++] : 0n;
												return r$6;
											}(n$5, t$5), t$5;
											default: throw new Error("The specified Logical level technique is not supported");
										}
									}(fp(t$4, e$4, r$4.numValues), r$4, n$4, i$5);
								}(t$3, e$3, s$3, o$2, n$3) : Pp(t$3, e$3, s$3, o$2);
								return new Lp(r$3.name, i$4, n$3);
							}
							if (a$1 === lp.SEQUENCE) {
								const n$4 = zp(t$3, e$3, s$3);
								return new Op(r$3.name, n$4[0], n$4[1], s$3.numRleValues);
							}
							{
								const i$4 = Bp(t$3, e$3, s$3, o$2);
								return new cf(r$3.name, i$4, n$3);
							}
						}(e$2, r$2, s$2, l$1, i$2);
						case 7: return function(t$3, e$3, r$3, n$3) {
							const i$3 = kp(t$3, e$3), s$3 = bf(n$3) ? function(t$4, e$4, r$4, n$4) {
								const i$4 = e$4.get(), s$4 = i$4 + n$4 * Float32Array.BYTES_PER_ELEMENT, a$1 = new Uint8Array(t$4.subarray(i$4, s$4)).buffer, o$2 = new Float32Array(a$1);
								e$4.set(s$4);
								const l$2 = r$4.size(), u$1 = new Float32Array(l$2);
								let c$1 = 0;
								for (let t$5 = 0; t$5 < l$2; t$5++) u$1[t$5] = r$4.get(t$5) ? o$2[c$1++] : 0;
								return u$1;
							}(t$3, e$3, n$3, i$3.numValues) : function(t$4, e$4, r$4) {
								const n$4 = e$4.get(), i$4 = n$4 + r$4 * Float32Array.BYTES_PER_ELEMENT, s$4 = new Uint8Array(t$4.subarray(n$4, i$4)).buffer, a$1 = new Float32Array(s$4);
								return e$4.set(i$4), a$1;
							}(t$3, e$3, i$3.numValues);
							return new uf(r$3.name, s$3, n$3);
						}(e$2, r$2, s$2, l$1);
						case 8: return function(t$3, e$3, r$3, n$3) {
							const i$3 = kp(t$3, e$3), s$3 = bf(n$3) ? function(t$4, e$4, r$4, n$4) {
								const i$4 = e$4.get(), s$4 = i$4 + n$4 * Float64Array.BYTES_PER_ELEMENT, a$1 = new Uint8Array(t$4.subarray(i$4, s$4)).buffer, o$2 = new Float64Array(a$1);
								e$4.set(s$4);
								const l$2 = r$4.size(), u$1 = new Float64Array(l$2);
								let c$1 = 0;
								for (let t$5 = 0; t$5 < l$2; t$5++) u$1[t$5] = r$4.get(t$5) ? o$2[c$1++] : 0;
								return u$1;
							}(t$3, e$3, n$3, i$3.numValues) : function(t$4, e$4, r$4) {
								const n$4 = e$4.get(), i$4 = n$4 + r$4 * Float64Array.BYTES_PER_ELEMENT, s$4 = new Uint8Array(t$4.subarray(n$4, i$4)).buffer, a$1 = new Float64Array(s$4);
								return e$4.set(i$4), a$1;
							}(t$3, e$3, i$3.numValues);
							return new Kh(r$3.name, s$3, n$3);
						}(e$2, r$2, s$2, l$1);
						default: throw new Error(`The specified data type for the field is currently not supported: ${i$2}`);
					}
				}(n$1, t$1, e$1, i$1, r$1.scalarType, r$1) : 1 != n$1 ? null : function(t$2, e$2, r$2, n$2) {
					let i$2 = null, s$2 = null, a = null, o$1 = null, l$1 = !1;
					for (; !l$1;) {
						const r$3 = kp(t$2, e$2);
						switch (r$3.physicalStreamType) {
							case ip.LENGTH:
								op.DICTIONARY === r$3.logicalStreamType.lengthType ? i$2 = Ip(t$2, e$2, r$3) : a = Ip(t$2, e$2, r$3);
								break;
							case ip.DATA: sp.SINGLE === r$3.logicalStreamType.dictionaryType || sp.SHARED === r$3.logicalStreamType.dictionaryType ? (s$2 = t$2.subarray(e$2.get(), e$2.get() + r$3.byteLength), l$1 = !0) : o$1 = t$2.subarray(e$2.get(), e$2.get() + r$3.byteLength), e$2.add(r$3.byteLength);
						}
					}
					const u$1 = r$2.complexType.children, c$1 = [];
					let h$1 = 0;
					for (const l$2 of u$1) {
						const u$2 = pp(t$2, e$2, 1)[0];
						if (0 == u$2) continue;
						const p$1 = `${r$2.name}${"default" === l$2.name ? "" : ":" + l$2.name}`;
						if (2 !== u$2 || "scalarField" !== l$2.type || 9 !== l$2.scalarField.physicalType) throw new Error("Currently only optional string fields are implemented for a struct.");
						const f$1 = kp(t$2, e$2), d$1 = hf(t$2, f$1.numValues, e$2), y$1 = kp(t$2, e$2), m$1 = y$1.decompressedCount !== n$2 ? Vp(t$2, e$2, y$1, !1, new Ep(d$1, f$1.numValues)) : Tp(t$2, e$2, y$1, !1);
						c$1[h$1++] = o$1 ? new xf(p$1, m$1, i$2, s$2, a, o$1, new Ep(d$1, f$1.numValues)) : new gf(p$1, m$1, i$2, s$2, new Ep(d$1, f$1.numValues));
					}
					return c$1;
				}(t$1, e$1, r$1, i$1);
			}
			function bf(t$1) {
				return t$1 instanceof Ep;
			}
			function wf(t$1) {
				if ("id" === t$1.name) return !1;
				if ("scalarType" === t$1.type) {
					const e$1 = t$1.scalarType;
					if ("physicalType" === e$1.type) switch (e$1.physicalType) {
						case 0:
						case 1:
						case 2:
						case 3:
						case 4:
						case 5:
						case 6:
						case 7:
						case 8:
						default: return !1;
						case 9: return !0;
					}
					else if ("logicalType" === e$1.type) return !1;
				} else if ("complexType" === t$1.type) {
					const e$1 = t$1.complexType;
					if ("physicalType" === e$1.type) switch (e$1.physicalType) {
						case 0:
						case 1: return !0;
						default: return !1;
					}
				}
				return console.warn("Unexpected column type in hasStreamCount", t$1), !1;
			}
			const _f = new TextDecoder();
			function Sf(t$1, e$1) {
				const r$1 = pp(t$1, e$1, 1)[0];
				if (0 === r$1) return "";
				const n$1 = e$1.get(), i$1 = t$1.subarray(n$1, n$1 + r$1);
				return e$1.add(r$1), _f.decode(i$1);
			}
			function Af(t$1, e$1) {
				const r$1 = pp(t$1, e$1, 1)[0] >>> 0, n$1 = !!(4 & r$1), i$1 = !!(2 & r$1), s$1 = pp(t$1, e$1, 1)[0] >>> 0, a = {};
				if (1 & r$1 && (a.nullable = !0), i$1) {
					const i$2 = {};
					if (n$1 ? (i$2.type = "logicalType", i$2.logicalType = s$1) : (i$2.type = "physicalType", i$2.physicalType = s$1), 8 & r$1) {
						const r$2 = pp(t$1, e$1, 1)[0] >>> 0;
						i$2.children = new Array(r$2);
						for (let n$2 = 0; n$2 < r$2; n$2++) i$2.children[n$2] = Af(t$1, e$1);
					}
					a.type = "complexField", a.complexField = i$2;
				} else {
					const t$2 = {};
					n$1 ? (t$2.type = "logicalType", t$2.logicalType = s$1) : (t$2.type = "physicalType", t$2.physicalType = s$1), a.type = "scalarField", a.scalarField = t$2;
				}
				return a;
			}
			function kf(t$1, e$1) {
				const r$1 = pp(t$1, e$1, 1)[0] >>> 0, n$1 = function(t$2) {
					switch (t$2) {
						case 0:
						case 1:
						case 2:
						case 3: {
							const e$2 = {};
							e$2.nullable = !!(1 & t$2), e$2.columnScope = 0;
							const r$2 = {};
							return r$2.physicalType = t$2 > 1 ? 6 : 4, r$2.type = "physicalType", e$2.scalarType = r$2, e$2.type = "scalarType", e$2;
						}
						case 4: {
							const t$3 = {
								nullable: !1,
								columnScope: 0
							};
							return t$3.type = "complexType", t$3.complexType = {
								type: "physicalType",
								physicalType: 0
							}, t$3;
						}
						case 30: {
							const t$3 = {
								nullable: !1,
								columnScope: 0
							};
							return t$3.type = "complexType", t$3.complexType = {
								type: "physicalType",
								physicalType: 1
							}, t$3;
						}
						default: return function(t$3) {
							let e$2 = null;
							switch (t$3) {
								case 10:
								case 11:
									e$2 = 0;
									break;
								case 12:
								case 13:
									e$2 = 1;
									break;
								case 14:
								case 15:
									e$2 = 2;
									break;
								case 16:
								case 17:
									e$2 = 3;
									break;
								case 18:
								case 19:
									e$2 = 4;
									break;
								case 20:
								case 21:
									e$2 = 5;
									break;
								case 22:
								case 23:
									e$2 = 6;
									break;
								case 24:
								case 25:
									e$2 = 7;
									break;
								case 26:
								case 27:
									e$2 = 8;
									break;
								case 28:
								case 29:
									e$2 = 9;
									break;
								default: return null;
							}
							const r$2 = {};
							r$2.nullable = !!(1 & t$3), r$2.columnScope = 0;
							const n$2 = { type: "physicalType" };
							return n$2.physicalType = e$2, r$2.type = "scalarType", r$2.scalarType = n$2, r$2;
						}(t$2);
					}
				}(r$1);
				if (!n$1) throw new Error(`Unsupported column type code: ${r$1}`);
				if (function(t$2) {
					return t$2 >= 10;
				}(r$1) ? n$1.name = Sf(t$1, e$1) : r$1 >= 0 && r$1 <= 3 ? n$1.name = "id" : 4 === r$1 && (n$1.name = "geometry"), function(t$2) {
					return 30 === t$2;
				}(r$1)) {
					const r$2 = pp(t$1, e$1, 1)[0] >>> 0, i$1 = n$1.complexType;
					i$1.children = new Array(r$2);
					for (let n$2 = 0; n$2 < r$2; n$2++) i$1.children[n$2] = Af(t$1, e$1);
				}
				return n$1;
			}
			function Ef(t$1, e$1) {
				const r$1 = { featureTables: [] }, n$1 = {};
				n$1.name = Sf(t$1, e$1);
				const i$1 = pp(t$1, e$1, 1)[0] >>> 0, s$1 = pp(t$1, e$1, 1)[0] >>> 0;
				n$1.columns = new Array(s$1);
				for (let r$2 = 0; r$2 < s$1; r$2++) n$1.columns[r$2] = kf(t$1, e$1);
				return r$1.featureTables.push(n$1), [r$1, i$1];
			}
			function Tf(t$1, e$1, r$1, n$1, i$1, s$1, a = !1) {
				const o$1 = e$1.scalarType.physicalType, l$1 = Cp(i$1, s$1, t$1, r$1);
				if (4 === o$1) switch (l$1) {
					case lp.FLAT: return new Hh(n$1, Tp(t$1, r$1, i$1, !1), s$1);
					case lp.SEQUENCE: {
						const e$2 = Dp(t$1, r$1, i$1);
						return new Jh(n$1, e$2[0], e$2[1], i$1.numRleValues);
					}
					case lp.CONST: return new Qh(n$1, Fp(t$1, r$1, i$1, !1), s$1);
				}
				else switch (l$1) {
					case lp.FLAT:
						if (a) return new Kh(n$1, function(t$2, e$2, r$2, n$2) {
							return function(t$3, e$3, r$3) {
								switch (e$3.logicalLevelTechnique1) {
									case rp.DELTA: return e$3.logicalLevelTechnique2 === rp.RLE && (t$3 = wp(t$3, e$3.runs, e$3.numRleValues)), function(t$4) {
										t$4[0] = t$4[0] % 2 == 1 ? (t$4[0] + 1) / -2 : t$4[0] / 2;
										const e$4 = t$4.length / 4 * 4;
										let r$4 = 1;
										if (e$4 >= 4) for (; r$4 < e$4 - 4; r$4 += 4) {
											const e$5 = t$4[r$4], n$3 = t$4[r$4 + 1], i$2 = t$4[r$4 + 2], s$2 = t$4[r$4 + 3];
											t$4[r$4] = (e$5 % 2 == 1 ? (e$5 + 1) / -2 : e$5 / 2) + t$4[r$4 - 1], t$4[r$4 + 1] = (n$3 % 2 == 1 ? (n$3 + 1) / -2 : n$3 / 2) + t$4[r$4], t$4[r$4 + 2] = (i$2 % 2 == 1 ? (i$2 + 1) / -2 : i$2 / 2) + t$4[r$4 + 1], t$4[r$4 + 3] = (s$2 % 2 == 1 ? (s$2 + 1) / -2 : s$2 / 2) + t$4[r$4 + 2];
										}
										for (; r$4 != t$4.length; ++r$4) t$4[r$4] = (t$4[r$4] % 2 == 1 ? (t$4[r$4] + 1) / -2 : t$4[r$4] / 2) + t$4[r$4 - 1];
									}(t$3), t$3;
									case rp.RLE: return function(t$4, e$4, r$4) {
										return r$4 ? function(t$5, e$5, r$5) {
											const n$3 = new Float64Array(r$5);
											let i$2 = 0;
											for (let r$6 = 0; r$6 < e$5; r$6++) {
												const s$2 = t$5[r$6];
												let a$1 = t$5[r$6 + e$5];
												a$1 = a$1 % 2 == 1 ? (a$1 + 1) / -2 : a$1 / 2, n$3.fill(a$1, i$2, i$2 + s$2), i$2 += s$2;
											}
											return n$3;
										}(t$4, e$4.runs, e$4.numRleValues) : wp(t$4, e$4.runs, e$4.numRleValues);
									}(t$3, e$3, r$3);
									case rp.NONE: return t$3;
									default: throw new Error(`The specified Logical level technique is not supported: ${e$3.logicalLevelTechnique1}`);
								}
							}(function(t$3, e$3, r$3) {
								const n$3 = new Float64Array(e$3);
								for (let i$2 = 0; i$2 < e$3; i$2++) n$3[i$2] = dp(t$3, r$3);
								return n$3;
							}(t$2, r$2.numValues, e$2), r$2, n$2);
						}(t$1, r$1, i$1, !1), s$1);
						return new Lp(n$1, Pp(t$1, r$1, i$1, !1), s$1);
					case lp.SEQUENCE: {
						const e$2 = zp(t$1, r$1, i$1);
						return new Op(n$1, e$2[0], e$2[1], i$1.numRleValues);
					}
					case lp.CONST: return new cf(n$1, Bp(t$1, r$1, i$1, !1), s$1);
				}
				throw new Error("Vector type not supported for id column.");
			}
			class If {
				constructor(t$1, e$1) {
					var r$1;
					switch (this._featureData = t$1, this.properties = this._featureData.properties || {}, null === (r$1 = this._featureData.geometry) || void 0 === r$1 ? void 0 : r$1.type) {
						case up.POINT:
						case up.MULTIPOINT:
							this.type = 1;
							break;
						case up.LINESTRING:
						case up.MULTILINESTRING:
							this.type = 2;
							break;
						case up.POLYGON:
						case up.MULTIPOLYGON:
							this.type = 3;
							break;
						default: this.type = 0;
					}
					this.extent = e$1, this.id = Number(this._featureData.id);
				}
				loadGeometry() {
					const t$1 = [];
					for (const e$1 of this._featureData.geometry.coordinates) {
						const n$1 = [];
						for (const t$2 of e$1) n$1.push(new r(t$2.x, t$2.y));
						t$1.push(n$1);
					}
					return t$1;
				}
			}
			class Mf {
				constructor(t$1) {
					this.features = [], this.featureTable = t$1, this.name = t$1.name, this.extent = t$1.extent, this.version = 2, this.features = t$1.getFeatures(), this.length = this.features.length;
				}
				feature(t$1) {
					return new If(this.features[t$1], this.extent);
				}
			}
			class Ff {
				constructor(t$1) {
					this.layers = {};
					this.layers = function(t$2, e$1, r$1 = !0) {
						const n$1 = new ep(0), i$1 = [];
						for (; n$1.get() < t$2.length;) {
							const e$2 = pp(t$2, n$1, 1)[0] >>> 0, s$1 = n$1.get() + e$2;
							if (s$1 > t$2.length) throw new Error(`Block overruns tile: ${s$1} > ${t$2.length}`);
							if (1 != pp(t$2, n$1, 1)[0] >>> 0) {
								n$1.set(s$1);
								continue;
							}
							const a = Ef(t$2, n$1), o$1 = a[1], l$1 = a[0].featureTables[0];
							let u$1 = null, c$1 = null;
							const h$1 = [];
							let p$1 = 0;
							for (const e$3 of l$1.columns) {
								const i$2 = e$3.name;
								if ("id" === i$2) {
									let s$2 = null;
									if (e$3.nullable) {
										const e$4 = kp(t$2, n$1), r$2 = n$1.get(), i$3 = hf(t$2, e$4.numValues, n$1);
										n$1.set(r$2 + e$4.byteLength), s$2 = new Ep(i$3, e$4.numValues);
									}
									const a$1 = kp(t$2, n$1);
									p$1 = a$1.decompressedCount, u$1 = Tf(t$2, e$3, n$1, i$2, a$1, s$2 ?? p$1, r$1);
								} else if ("geometry" === i$2) {
									const e$4 = pp(t$2, n$1, 1)[0];
									if (0 === p$1) {
										const e$5 = n$1.get();
										p$1 = kp(t$2, n$1).decompressedCount, n$1.set(e$5);
									}
									c$1 = sf(t$2, e$4, n$1, p$1);
								} else {
									const r$2 = wf(e$3) ? pp(t$2, n$1, 1)[0] : 1;
									if (0 === r$2 && "scalarType" === e$3.type) continue;
									const i$3 = vf(t$2, n$1, e$3, r$2, p$1);
									if (i$3) if (Array.isArray(i$3)) for (const t$3 of i$3) h$1.push(t$3);
									else h$1.push(i$3);
								}
							}
							const f$1 = new tp(l$1.name, c$1, u$1, h$1, o$1);
							i$1.push(f$1), n$1.set(s$1);
						}
						return i$1;
					}(new Uint8Array(t$1)).reduce(((t$2, e$1) => Object.assign(Object.assign({}, t$2), { [e$1.name]: new Mf(e$1) })), {});
				}
			}
			class Df {
				constructor(t$1, e$1) {
					this.feature = t$1, this.type = t$1.type, this.properties = t$1.tags ? t$1.tags : {}, this.extent = e$1, "id" in t$1 && ("string" == typeof t$1.id ? this.id = parseInt(t$1.id, 10) : "number" != typeof t$1.id || isNaN(t$1.id) || (this.id = t$1.id));
				}
				loadGeometry() {
					const t$1 = [], e$1 = 1 === this.feature.type ? [this.feature.geometry] : this.feature.geometry;
					for (const n$1 of e$1) {
						const e$2 = [];
						for (const t$2 of n$1) e$2.push(new r(t$2[0], t$2[1]));
						t$1.push(e$2);
					}
					return t$1;
				}
			}
			const zf = "_geojsonTileLayer";
			function Pf(t$1, e$1) {
				e$1.writeVarintField(15, t$1.version || 1), e$1.writeStringField(1, t$1.name || ""), e$1.writeVarintField(5, t$1.extent || 4096);
				const r$1 = {
					keys: [],
					values: [],
					keycache: {},
					valuecache: {}
				};
				for (let n$2 = 0; n$2 < t$1.length; n$2++) r$1.feature = t$1.feature(n$2), e$1.writeMessage(2, Bf, r$1);
				const n$1 = r$1.keys;
				for (const t$2 of n$1) e$1.writeStringField(3, t$2);
				const i$1 = r$1.values;
				for (const t$2 of i$1) e$1.writeMessage(4, Rf, t$2);
			}
			function Bf(t$1, e$1) {
				if (!t$1.feature) return;
				const r$1 = t$1.feature;
				void 0 !== r$1.id && e$1.writeVarintField(1, r$1.id), e$1.writeMessage(2, Vf, t$1), e$1.writeVarintField(3, r$1.type), e$1.writeMessage(4, Of, r$1);
			}
			function Vf(t$1, e$1) {
				for (const r$1 in t$1.feature?.properties) {
					let n$1 = t$1.feature.properties[r$1], i$1 = t$1.keycache[r$1];
					if (null == n$1) continue;
					void 0 === i$1 && (t$1.keys.push(r$1), i$1 = t$1.keys.length - 1, t$1.keycache[r$1] = i$1), e$1.writeVarint(i$1), "string" != typeof n$1 && "boolean" != typeof n$1 && "number" != typeof n$1 && (n$1 = JSON.stringify(n$1));
					const s$1 = typeof n$1 + ":" + n$1;
					let a = t$1.valuecache[s$1];
					void 0 === a && (t$1.values.push(n$1), a = t$1.values.length - 1, t$1.valuecache[s$1] = a), e$1.writeVarint(a);
				}
			}
			function Cf(t$1, e$1) {
				return (e$1 << 3) + (7 & t$1);
			}
			function Lf(t$1) {
				return t$1 << 1 ^ t$1 >> 31;
			}
			function Of(t$1, e$1) {
				const r$1 = t$1.loadGeometry(), n$1 = t$1.type;
				let i$1 = 0, s$1 = 0;
				for (const a of r$1) {
					let r$2 = 1;
					1 === n$1 && (r$2 = a.length), e$1.writeVarint(Cf(1, r$2));
					const o$1 = 3 === n$1 ? a.length - 1 : a.length;
					for (let t$2 = 0; t$2 < o$1; t$2++) {
						1 === t$2 && 1 !== n$1 && e$1.writeVarint(Cf(2, o$1 - 1));
						const r$3 = a[t$2].x - i$1, l$1 = a[t$2].y - s$1;
						e$1.writeVarint(Lf(r$3)), e$1.writeVarint(Lf(l$1)), i$1 += r$3, s$1 += l$1;
					}
					3 === t$1.type && e$1.writeVarint(Cf(7, 1));
				}
			}
			function Rf(t$1, e$1) {
				const r$1 = typeof t$1;
				"string" === r$1 ? e$1.writeStringField(1, t$1) : "boolean" === r$1 ? e$1.writeBooleanField(7, t$1) : "number" === r$1 && (t$1 % 1 != 0 ? e$1.writeDoubleField(3, t$1) : t$1 < 0 ? e$1.writeSVarintField(6, t$1) : e$1.writeVarintField(5, t$1));
			}
			class Nf {
				constructor(t$1, e$1) {
					this.tileID = t$1, this.x = t$1.canonical.x, this.y = t$1.canonical.y, this.z = t$1.canonical.z, this.grid = new cs(M, 16, 0), this.grid3D = new cs(M, 16, 0), this.featureIndexArray = new Na(), this.promoteId = e$1;
				}
				insert(t$1, e$1, r$1, n$1, i$1, s$1) {
					const a = this.featureIndexArray.length;
					this.featureIndexArray.emplaceBack(r$1, n$1, i$1);
					const o$1 = s$1 ? this.grid3D : this.grid;
					for (let t$2 = 0; t$2 < e$1.length; t$2++) {
						const r$2 = e$1[t$2], n$2 = [
							Infinity,
							Infinity,
							-Infinity,
							-Infinity
						];
						for (let t$3 = 0; t$3 < r$2.length; t$3++) {
							const e$2 = r$2[t$3];
							n$2[0] = Math.min(n$2[0], e$2.x), n$2[1] = Math.min(n$2[1], e$2.y), n$2[2] = Math.max(n$2[2], e$2.x), n$2[3] = Math.max(n$2[3], e$2.y);
						}
						n$2[0] < M && n$2[1] < M && n$2[2] >= 0 && n$2[3] >= 0 && o$1.insert(a, n$2[0], n$2[1], n$2[2], n$2[3]);
					}
				}
				loadVTLayers() {
					return this.vtLayers || (this.vtLayers = "mlt" !== this.encoding ? new Vu(new Tc(this.rawTileData)).layers : new Ff(this.rawTileData).layers, this.sourceLayerCoder = new Gh(this.vtLayers ? Object.keys(this.vtLayers).sort() : [zf])), this.vtLayers;
				}
				query(t$1, e$1, n$1, i$1) {
					this.loadVTLayers();
					const s$1 = t$1.params, a = M / t$1.tileSize / t$1.scale, o$1 = fi(s$1.filter, s$1.globalState), l$1 = t$1.queryGeometry, u$1 = t$1.queryPadding * a, c$1 = jh.fromPoints(l$1), h$1 = this.grid.query(c$1.minX - u$1, c$1.minY - u$1, c$1.maxX + u$1, c$1.maxY + u$1), p$1 = jh.fromPoints(t$1.cameraQueryGeometry).expandBy(u$1), f$1 = this.grid3D.query(p$1.minX, p$1.minY, p$1.maxX, p$1.maxY, ((e$2, n$2, i$2, s$2) => function(t$2, e$3, n$3, i$3, s$3) {
						for (const r$1 of t$2) if (e$3 <= r$1.x && n$3 <= r$1.y && i$3 >= r$1.x && s$3 >= r$1.y) return !0;
						const a$1 = [
							new r(e$3, n$3),
							new r(e$3, s$3),
							new r(i$3, s$3),
							new r(i$3, n$3)
						];
						if (t$2.length > 2) {
							for (const e$4 of a$1) if (tl(t$2, e$4)) return !0;
						}
						for (let e$4 = 0; e$4 < t$2.length - 1; e$4++) if (el(t$2[e$4], t$2[e$4 + 1], a$1)) return !0;
						return !1;
					}(t$1.cameraQueryGeometry, e$2 - u$1, n$2 - u$1, i$2 + u$1, s$2 + u$1)));
					for (const t$2 of f$1) h$1.push(t$2);
					h$1.sort(Uf);
					const d$1 = {};
					let y$1;
					for (let r$1 = 0; r$1 < h$1.length; r$1++) {
						const u$2 = h$1[r$1];
						if (u$2 === y$1) continue;
						y$1 = u$2;
						const c$2 = this.featureIndexArray.get(u$2);
						let p$2 = null;
						this.loadMatchingFeature(d$1, c$2.bucketIndex, c$2.sourceLayerIndex, c$2.featureIndex, o$1, s$1.layers, s$1.availableImages, e$1, n$1, i$1, ((e$2, r$2, n$2) => (p$2 || (p$2 = No(e$2)), r$2.queryIntersectsFeature({
							queryGeometry: l$1,
							feature: e$2,
							featureState: n$2,
							geometry: p$2,
							zoom: this.z,
							transform: t$1.transform,
							pixelsToTileUnits: a,
							pixelPosMatrix: t$1.pixelPosMatrix,
							unwrappedTileID: this.tileID.toUnwrapped(),
							getElevation: t$1.getElevation
						}))));
					}
					return d$1;
				}
				loadMatchingFeature(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1) {
					const h$1 = this.bucketLayerIDs[e$1];
					if (s$1 && !h$1.some(((t$2) => s$1.has(t$2)))) return;
					const p$1 = this.sourceLayerCoder.decode(r$1), f$1 = this.vtLayers[p$1].feature(n$1);
					if (i$1.needGeometry) {
						const t$2 = $o(f$1, !0);
						if (!i$1.filter(new Ps(this.tileID.overscaledZ), t$2, this.tileID.canonical)) return;
					} else if (!i$1.filter(new Ps(this.tileID.overscaledZ), f$1)) return;
					const d$1 = this.getId(f$1, p$1);
					for (let e$2 = 0; e$2 < h$1.length; e$2++) {
						const r$2 = h$1[e$2];
						if (s$1 && !s$1.has(r$2)) continue;
						const i$2 = o$1[r$2];
						if (!i$2) continue;
						let p$2 = {};
						d$1 && u$1 && (p$2 = u$1.getState(i$2.sourceLayer || zf, d$1));
						const y$1 = O({}, l$1[r$2]);
						y$1.paint = $f(y$1.paint, i$2.paint, f$1, p$2, a), y$1.layout = $f(y$1.layout, i$2.layout, f$1, p$2, a);
						const m$1 = !c$1 || c$1(f$1, i$2, p$2);
						if (!m$1) continue;
						const g$1 = new Xh(f$1, this.z, this.x, this.y, d$1);
						g$1.layer = y$1;
						let x$1 = t$1[r$2];
						void 0 === x$1 && (x$1 = t$1[r$2] = []), x$1.push({
							featureIndex: n$1,
							feature: g$1,
							intersectionZ: m$1
						});
					}
				}
				lookupSymbolFeatures(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1) {
					const l$1 = {};
					this.loadVTLayers();
					const u$1 = fi(i$1.filterSpec, i$1.globalState);
					for (const i$2 of t$1) this.loadMatchingFeature(l$1, r$1, n$1, i$2, u$1, s$1, a, o$1, e$1);
					return l$1;
				}
				hasLayer(t$1) {
					for (const e$1 of this.bucketLayerIDs) for (const r$1 of e$1) if (t$1 === r$1) return !0;
					return !1;
				}
				getId(t$1, e$1) {
					var r$1;
					let n$1 = t$1.id;
					return this.promoteId && (n$1 = t$1.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e$1]], "boolean" == typeof n$1 && (n$1 = Number(n$1)), void 0 === n$1 && !(null === (r$1 = t$1.properties) || void 0 === r$1) && r$1.cluster && this.promoteId && (n$1 = Number(t$1.properties.cluster_id))), n$1;
				}
			}
			function $f(t$1, e$1, r$1, n$1, i$1) {
				return N(t$1, ((t$2, s$1) => {
					const a = e$1 instanceof qs ? e$1.get(s$1) : null;
					return a && a.evaluate ? a.evaluate(r$1, n$1, i$1) : a;
				}));
			}
			function Uf(t$1, e$1) {
				return e$1 - t$1;
			}
			function qf(t$1, e$1, n$1, i$1, s$1) {
				const a = [];
				for (let o$1 = 0; o$1 < t$1.length; o$1++) {
					const l$1 = t$1[o$1];
					let u$1;
					for (let t$2 = 0; t$2 < l$1.length - 1; t$2++) {
						let o$2 = l$1[t$2], c$1 = l$1[t$2 + 1];
						o$2.x < e$1 && c$1.x < e$1 || (o$2.x < e$1 ? o$2 = new r(e$1, o$2.y + (e$1 - o$2.x) / (c$1.x - o$2.x) * (c$1.y - o$2.y))._round() : c$1.x < e$1 && (c$1 = new r(e$1, o$2.y + (e$1 - o$2.x) / (c$1.x - o$2.x) * (c$1.y - o$2.y))._round()), o$2.y < n$1 && c$1.y < n$1 || (o$2.y < n$1 ? o$2 = new r(o$2.x + (n$1 - o$2.y) / (c$1.y - o$2.y) * (c$1.x - o$2.x), n$1)._round() : c$1.y < n$1 && (c$1 = new r(o$2.x + (n$1 - o$2.y) / (c$1.y - o$2.y) * (c$1.x - o$2.x), n$1)._round()), o$2.x >= i$1 && c$1.x >= i$1 || (o$2.x >= i$1 ? o$2 = new r(i$1, o$2.y + (i$1 - o$2.x) / (c$1.x - o$2.x) * (c$1.y - o$2.y))._round() : c$1.x >= i$1 && (c$1 = new r(i$1, o$2.y + (i$1 - o$2.x) / (c$1.x - o$2.x) * (c$1.y - o$2.y))._round()), o$2.y >= s$1 && c$1.y >= s$1 || (o$2.y >= s$1 ? o$2 = new r(o$2.x + (s$1 - o$2.y) / (c$1.y - o$2.y) * (c$1.x - o$2.x), s$1)._round() : c$1.y >= s$1 && (c$1 = new r(o$2.x + (s$1 - o$2.y) / (c$1.y - o$2.y) * (c$1.x - o$2.x), s$1)._round()), u$1 && o$2.equals(u$1[u$1.length - 1]) || (u$1 = [o$2], a.push(u$1)), u$1.push(c$1)))));
					}
				}
				return a;
			}
			function jf(t$1, e$1, r$1, n$1, i$1) {
				switch (e$1) {
					case 1: return function(t$2, e$2, r$2, n$2) {
						const i$2 = [];
						for (const s$1 of t$2) for (const t$3 of s$1) {
							const s$2 = 0 === n$2 ? t$3.x : t$3.y;
							s$2 >= e$2 && s$2 <= r$2 && i$2.push([t$3]);
						}
						return i$2;
					}(t$1, r$1, n$1, i$1);
					case 2: return Xf(t$1, r$1, n$1, i$1, !1);
					case 3: return Xf(t$1, r$1, n$1, i$1, !0);
				}
				return [];
			}
			function Gf(t$1, e$1, n$1, i$1, s$1) {
				const a = 0 === i$1 ? Yf : Zf;
				let o$1 = [];
				const l$1 = [];
				for (let r$1 = 0; r$1 < t$1.length - 1; r$1++) {
					const u$2 = t$1[r$1], c$2 = t$1[r$1 + 1], h$1 = 0 === i$1 ? u$2.x : u$2.y, p$1 = 0 === i$1 ? c$2.x : c$2.y;
					let f$1 = !1;
					h$1 < e$1 ? p$1 > e$1 && o$1.push(a(u$2, c$2, e$1)) : h$1 > n$1 ? p$1 < n$1 && o$1.push(a(u$2, c$2, n$1)) : o$1.push(u$2), p$1 < e$1 && h$1 >= e$1 && (o$1.push(a(u$2, c$2, e$1)), f$1 = !0), p$1 > n$1 && h$1 <= n$1 && (o$1.push(a(u$2, c$2, n$1)), f$1 = !0), !s$1 && f$1 && (l$1.push(o$1), o$1 = []);
				}
				const u$1 = t$1.length - 1, c$1 = 0 === i$1 ? t$1[u$1].x : t$1[u$1].y;
				return c$1 >= e$1 && c$1 <= n$1 && o$1.push(t$1[u$1]), s$1 && o$1.length > 0 && !o$1[0].equals(o$1[o$1.length - 1]) && o$1.push(new r(o$1[0].x, o$1[0].y)), o$1.length > 0 && l$1.push(o$1), l$1;
			}
			function Xf(t$1, e$1, r$1, n$1, i$1) {
				const s$1 = [];
				for (const a of t$1) {
					const t$2 = Gf(a, e$1, r$1, n$1, i$1);
					t$2.length > 0 && s$1.push(...t$2);
				}
				return s$1;
			}
			function Yf(t$1, e$1, n$1) {
				return new r(n$1, t$1.y + (n$1 - t$1.x) / (e$1.x - t$1.x) * (e$1.y - t$1.y));
			}
			function Zf(t$1, e$1, n$1) {
				return new r(t$1.x + (n$1 - t$1.y) / (e$1.y - t$1.y) * (e$1.x - t$1.x), n$1);
			}
			ps("FeatureIndex", Nf, { omit: ["rawTileData", "sourceLayerCoder"] });
			class Hf extends r {
				constructor(t$1, e$1, r$1, n$1) {
					super(t$1, e$1), this.angle = r$1, void 0 !== n$1 && (this.segment = n$1);
				}
				clone() {
					return new Hf(this.x, this.y, this.angle, this.segment);
				}
			}
			function Kf(t$1, e$1, r$1, n$1, i$1) {
				if (void 0 === e$1.segment || 0 === r$1) return !0;
				let s$1 = e$1, a = e$1.segment + 1, o$1 = 0;
				for (; o$1 > -r$1 / 2;) {
					if (a--, a < 0) return !1;
					o$1 -= t$1[a].dist(s$1), s$1 = t$1[a];
				}
				o$1 += t$1[a].dist(t$1[a + 1]), a++;
				const l$1 = [];
				let u$1 = 0;
				for (; o$1 < r$1 / 2;) {
					const e$2 = t$1[a], r$2 = t$1[a + 1];
					if (!r$2) return !1;
					let s$2 = t$1[a - 1].angleTo(e$2) - e$2.angleTo(r$2);
					for (s$2 = Math.abs((s$2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l$1.push({
						distance: o$1,
						angleDelta: s$2
					}), u$1 += s$2; o$1 - l$1[0].distance > n$1;) u$1 -= l$1.shift().angleDelta;
					if (u$1 > i$1) return !1;
					a++, o$1 += e$2.dist(r$2);
				}
				return !0;
			}
			function Wf(t$1) {
				let e$1 = 0;
				for (let r$1 = 0; r$1 < t$1.length - 1; r$1++) e$1 += t$1[r$1].dist(t$1[r$1 + 1]);
				return e$1;
			}
			function Jf(t$1, e$1, r$1) {
				return t$1 ? .6 * e$1 * r$1 : 0;
			}
			function Qf(t$1, e$1) {
				return Math.max(t$1 ? t$1.right - t$1.left : 0, e$1 ? e$1.right - e$1.left : 0);
			}
			function td(t$1, e$1, r$1, n$1, i$1, s$1) {
				const a = Jf(r$1, i$1, s$1), o$1 = Qf(r$1, n$1) * s$1;
				let l$1 = 0;
				const u$1 = Wf(t$1) / 2;
				for (let r$2 = 0; r$2 < t$1.length - 1; r$2++) {
					const n$2 = t$1[r$2], i$2 = t$1[r$2 + 1], s$2 = n$2.dist(i$2);
					if (l$1 + s$2 > u$1) {
						const c$1 = (u$1 - l$1) / s$2, f$1 = new Hf(yr.number(n$2.x, i$2.x, c$1), yr.number(n$2.y, i$2.y, c$1), i$2.angleTo(n$2), r$2);
						return f$1._round(), !a || Kf(t$1, f$1, o$1, a, e$1) ? f$1 : void 0;
					}
					l$1 += s$2;
				}
			}
			function ed(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1) {
				const u$1 = Jf(n$1, s$1, a), c$1 = Qf(n$1, i$1), h$1 = c$1 * a, p$1 = 0 === t$1[0].x || t$1[0].x === l$1 || 0 === t$1[0].y || t$1[0].y === l$1;
				return e$1 - h$1 < e$1 / 4 && (e$1 = h$1 + e$1 / 4), rd(t$1, p$1 ? e$1 / 2 * o$1 % e$1 : (c$1 / 2 + 2 * s$1) * a * o$1 % e$1, e$1, u$1, r$1, h$1, p$1, !1, l$1);
			}
			function rd(t$1, e$1, r$1, n$1, i$1, s$1, a, o$1, l$1) {
				const u$1 = s$1 / 2, c$1 = Wf(t$1);
				let h$1 = 0, p$1 = e$1 - r$1, f$1 = [];
				for (let e$2 = 0; e$2 < t$1.length - 1; e$2++) {
					const a$1 = t$1[e$2], o$2 = t$1[e$2 + 1], d$1 = a$1.dist(o$2), y$1 = o$2.angleTo(a$1);
					for (; p$1 + r$1 < h$1 + d$1;) {
						p$1 += r$1;
						const m$1 = (p$1 - h$1) / d$1, g$1 = yr.number(a$1.x, o$2.x, m$1), x$1 = yr.number(a$1.y, o$2.y, m$1);
						if (g$1 >= 0 && g$1 < l$1 && x$1 >= 0 && x$1 < l$1 && p$1 - u$1 >= 0 && p$1 + u$1 <= c$1) {
							const r$2 = new Hf(g$1, x$1, y$1, e$2);
							r$2._round(), n$1 && !Kf(t$1, r$2, s$1, n$1, i$1) || f$1.push(r$2);
						}
					}
					h$1 += d$1;
				}
				return o$1 || f$1.length || a || (f$1 = rd(t$1, h$1 / 2, r$1, n$1, i$1, s$1, a, !0, l$1)), f$1;
			}
			function nd(t$1, e$1, n$1, i$1) {
				const s$1 = [], a = t$1.image, o$1 = a.pixelRatio, l$1 = a.paddedRect.w - 2, u$1 = a.paddedRect.h - 2;
				let c$1 = {
					x1: t$1.left,
					y1: t$1.top,
					x2: t$1.right,
					y2: t$1.bottom
				};
				const h$1 = a.stretchX || [[0, l$1]], p$1 = a.stretchY || [[0, u$1]], f$1 = (t$2, e$2) => t$2 + e$2[1] - e$2[0], d$1 = h$1.reduce(f$1, 0), y$1 = p$1.reduce(f$1, 0), m$1 = l$1 - d$1, g$1 = u$1 - y$1;
				let x$1 = 0, v$1 = d$1, b$1 = 0, w$1 = y$1, _$1 = 0, S$1 = m$1, A$1 = 0, k$1 = g$1;
				if (a.content && i$1) {
					const e$2 = a.content, r$1 = e$2[2] - e$2[0], n$2 = e$2[3] - e$2[1];
					(a.textFitWidth || a.textFitHeight) && (c$1 = eh(t$1)), x$1 = id(h$1, 0, e$2[0]), b$1 = id(p$1, 0, e$2[1]), v$1 = id(h$1, e$2[0], e$2[2]), w$1 = id(p$1, e$2[1], e$2[3]), _$1 = e$2[0] - x$1, A$1 = e$2[1] - b$1, S$1 = r$1 - v$1, k$1 = n$2 - w$1;
				}
				const E$1 = c$1.x1, T$1 = c$1.y1, I$1 = c$1.x2 - E$1, M$1 = c$1.y2 - T$1, F$1 = (t$2, i$2, s$2, l$2) => {
					const u$2 = ad(t$2.stretch - x$1, v$1, I$1, E$1), c$2 = od(t$2.fixed - _$1, S$1, t$2.stretch, d$1), h$2 = ad(i$2.stretch - b$1, w$1, M$1, T$1), p$2 = od(i$2.fixed - A$1, k$1, i$2.stretch, y$1), f$2 = ad(s$2.stretch - x$1, v$1, I$1, E$1), m$2 = od(s$2.fixed - _$1, S$1, s$2.stretch, d$1), g$2 = ad(l$2.stretch - b$1, w$1, M$1, T$1), F$2 = od(l$2.fixed - A$1, k$1, l$2.stretch, y$1), D$1 = new r(u$2, h$2), z$1 = new r(f$2, h$2), P$1 = new r(f$2, g$2), B$1 = new r(u$2, g$2), V$1 = new r(c$2 / o$1, p$2 / o$1), C$1 = new r(m$2 / o$1, F$2 / o$1), L$1 = e$1 * Math.PI / 180;
					if (L$1) {
						const t$3 = Math.sin(L$1), e$2 = Math.cos(L$1), r$1 = [
							e$2,
							-t$3,
							t$3,
							e$2
						];
						D$1._matMult(r$1), z$1._matMult(r$1), B$1._matMult(r$1), P$1._matMult(r$1);
					}
					const O$1 = t$2.stretch + t$2.fixed, R$1 = i$2.stretch + i$2.fixed;
					return {
						tl: D$1,
						tr: z$1,
						bl: B$1,
						br: P$1,
						tex: {
							x: a.paddedRect.x + 1 + O$1,
							y: a.paddedRect.y + 1 + R$1,
							w: s$2.stretch + s$2.fixed - O$1,
							h: l$2.stretch + l$2.fixed - R$1
						},
						writingMode: void 0,
						glyphOffset: [0, 0],
						sectionIndex: 0,
						pixelOffsetTL: V$1,
						pixelOffsetBR: C$1,
						minFontScaleX: S$1 / o$1 / I$1,
						minFontScaleY: k$1 / o$1 / M$1,
						isSDF: n$1
					};
				};
				if (i$1 && (a.stretchX || a.stretchY)) {
					const t$2 = sd(h$1, m$1, d$1), e$2 = sd(p$1, g$1, y$1);
					for (let r$1 = 0; r$1 < t$2.length - 1; r$1++) {
						const n$2 = t$2[r$1], i$2 = t$2[r$1 + 1];
						for (let t$3 = 0; t$3 < e$2.length - 1; t$3++) s$1.push(F$1(n$2, e$2[t$3], i$2, e$2[t$3 + 1]));
					}
				} else s$1.push(F$1({
					fixed: 0,
					stretch: -1
				}, {
					fixed: 0,
					stretch: -1
				}, {
					fixed: 0,
					stretch: l$1 + 1
				}, {
					fixed: 0,
					stretch: u$1 + 1
				}));
				return s$1;
			}
			function id(t$1, e$1, r$1) {
				let n$1 = 0;
				for (const i$1 of t$1) n$1 += Math.max(e$1, Math.min(r$1, i$1[1])) - Math.max(e$1, Math.min(r$1, i$1[0]));
				return n$1;
			}
			function sd(t$1, e$1, r$1) {
				const n$1 = [{
					fixed: -1,
					stretch: 0
				}];
				for (const [e$2, r$2] of t$1) {
					const t$2 = n$1[n$1.length - 1];
					n$1.push({
						fixed: e$2 - t$2.stretch,
						stretch: t$2.stretch
					}), n$1.push({
						fixed: e$2 - t$2.stretch,
						stretch: t$2.stretch + (r$2 - e$2)
					});
				}
				return n$1.push({
					fixed: e$1 + 1,
					stretch: r$1
				}), n$1;
			}
			function ad(t$1, e$1, r$1, n$1) {
				return t$1 / e$1 * r$1 + n$1;
			}
			function od(t$1, e$1, r$1, n$1) {
				return t$1 - e$1 * r$1 / n$1;
			}
			ps("Anchor", Hf);
			class ld {
				constructor(t$1, e$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1) {
					var h$1;
					if (this.boxStartIndex = t$1.length, u$1) {
						let t$2 = a.top, e$2 = a.bottom;
						const r$1 = a.collisionPadding;
						r$1 && (t$2 -= r$1[1], e$2 += r$1[3]);
						let n$2 = e$2 - t$2;
						n$2 > 0 && (n$2 = Math.max(10, n$2), this.circleDiameter = n$2);
					} else {
						const u$2 = (null === (h$1 = a.image) || void 0 === h$1 ? void 0 : h$1.content) && (a.image.textFitWidth || a.image.textFitHeight) ? eh(a) : {
							x1: a.left,
							y1: a.top,
							x2: a.right,
							y2: a.bottom
						};
						u$2.y1 = u$2.y1 * o$1 - l$1[0], u$2.y2 = u$2.y2 * o$1 + l$1[2], u$2.x1 = u$2.x1 * o$1 - l$1[3], u$2.x2 = u$2.x2 * o$1 + l$1[1];
						const p$1 = a.collisionPadding;
						if (p$1 && (u$2.x1 -= p$1[0] * o$1, u$2.y1 -= p$1[1] * o$1, u$2.x2 += p$1[2] * o$1, u$2.y2 += p$1[3] * o$1), c$1) {
							const t$2 = new r(u$2.x1, u$2.y1), e$2 = new r(u$2.x2, u$2.y1), n$2 = new r(u$2.x1, u$2.y2), i$2 = new r(u$2.x2, u$2.y2), s$2 = c$1 * Math.PI / 180;
							t$2._rotate(s$2), e$2._rotate(s$2), n$2._rotate(s$2), i$2._rotate(s$2), u$2.x1 = Math.min(t$2.x, e$2.x, n$2.x, i$2.x), u$2.x2 = Math.max(t$2.x, e$2.x, n$2.x, i$2.x), u$2.y1 = Math.min(t$2.y, e$2.y, n$2.y, i$2.y), u$2.y2 = Math.max(t$2.y, e$2.y, n$2.y, i$2.y);
						}
						t$1.emplaceBack(e$1.x, e$1.y, u$2.x1, u$2.y1, u$2.x2, u$2.y2, n$1, i$1, s$1);
					}
					this.boxEndIndex = t$1.length;
				}
			}
			class ud {
				constructor(t$1 = [], e$1 = (t$2, e$2) => t$2 < e$2 ? -1 : t$2 > e$2 ? 1 : 0) {
					if (this.data = t$1, this.length = this.data.length, this.compare = e$1, this.length > 0) for (let t$2 = (this.length >> 1) - 1; t$2 >= 0; t$2--) this._down(t$2);
				}
				push(t$1) {
					this.data.push(t$1), this._up(this.length++);
				}
				pop() {
					if (0 === this.length) return;
					const t$1 = this.data[0], e$1 = this.data.pop();
					return --this.length > 0 && (this.data[0] = e$1, this._down(0)), t$1;
				}
				peek() {
					return this.data[0];
				}
				_up(t$1) {
					const { data: e$1, compare: r$1 } = this, n$1 = e$1[t$1];
					for (; t$1 > 0;) {
						const i$1 = t$1 - 1 >> 1, s$1 = e$1[i$1];
						if (r$1(n$1, s$1) >= 0) break;
						e$1[t$1] = s$1, t$1 = i$1;
					}
					e$1[t$1] = n$1;
				}
				_down(t$1) {
					const { data: e$1, compare: r$1 } = this, n$1 = this.length >> 1, i$1 = e$1[t$1];
					for (; t$1 < n$1;) {
						let n$2 = 1 + (t$1 << 1);
						const s$1 = n$2 + 1;
						if (s$1 < this.length && r$1(e$1[s$1], e$1[n$2]) < 0 && (n$2 = s$1), r$1(e$1[n$2], i$1) >= 0) break;
						e$1[t$1] = e$1[n$2], t$1 = n$2;
					}
					e$1[t$1] = i$1;
				}
			}
			function cd(t$1, e$1 = 1, n$1 = !1) {
				const i$1 = jh.fromPoints(t$1[0]), s$1 = Math.min(i$1.width(), i$1.height());
				let a = s$1 / 2;
				const o$1 = new ud([], hd), { minX: l$1, minY: u$1, maxX: c$1, maxY: h$1 } = i$1;
				if (0 === s$1) return new r(l$1, u$1);
				for (let e$2 = l$1; e$2 < c$1; e$2 += s$1) for (let r$1 = u$1; r$1 < h$1; r$1 += s$1) o$1.push(new pd(e$2 + a, r$1 + a, a, t$1));
				let p$1 = function(t$2) {
					let e$2 = 0, r$1 = 0, n$2 = 0;
					const i$2 = t$2[0];
					for (let t$3 = 0, s$2 = i$2.length, a$1 = s$2 - 1; t$3 < s$2; a$1 = t$3++) {
						const s$3 = i$2[t$3], o$2 = i$2[a$1], l$2 = s$3.x * o$2.y - o$2.x * s$3.y;
						r$1 += (s$3.x + o$2.x) * l$2, n$2 += (s$3.y + o$2.y) * l$2, e$2 += 3 * l$2;
					}
					return new pd(r$1 / e$2, n$2 / e$2, 0, t$2);
				}(t$1), f$1 = o$1.length;
				for (; o$1.length;) {
					const r$1 = o$1.pop();
					(r$1.d > p$1.d || !p$1.d) && (p$1 = r$1, n$1 && console.log("found best %d after %d probes", Math.round(1e4 * r$1.d) / 1e4, f$1)), r$1.max - p$1.d <= e$1 || (a = r$1.h / 2, o$1.push(new pd(r$1.p.x - a, r$1.p.y - a, a, t$1)), o$1.push(new pd(r$1.p.x + a, r$1.p.y - a, a, t$1)), o$1.push(new pd(r$1.p.x - a, r$1.p.y + a, a, t$1)), o$1.push(new pd(r$1.p.x + a, r$1.p.y + a, a, t$1)), f$1 += 4);
				}
				return n$1 && (console.log(`num probes: ${f$1}`), console.log(`best distance: ${p$1.d}`)), p$1.p;
			}
			function hd(t$1, e$1) {
				return e$1.max - t$1.max;
			}
			function pd(t$1, e$1, n$1, i$1) {
				this.p = new r(t$1, e$1), this.h = n$1, this.d = function(t$2, e$2) {
					let r$1 = !1, n$2 = Infinity;
					for (let i$2 = 0; i$2 < e$2.length; i$2++) {
						const s$1 = e$2[i$2];
						for (let e$3 = 0, i$3 = s$1.length, a = i$3 - 1; e$3 < i$3; a = e$3++) {
							const i$4 = s$1[e$3], o$1 = s$1[a];
							i$4.y > t$2.y != o$1.y > t$2.y && t$2.x < (o$1.x - i$4.x) * (t$2.y - i$4.y) / (o$1.y - i$4.y) + i$4.x && (r$1 = !r$1), n$2 = Math.min(n$2, Jo(t$2, i$4, o$1));
						}
					}
					return (r$1 ? 1 : -1) * Math.sqrt(n$2);
				}(this.p, i$1), this.max = this.d + this.h * Math.SQRT2;
			}
			var fd;
			t.aP = void 0, (fd = t.aP || (t.aP = {}))[fd.center = 1] = "center", fd[fd.left = 2] = "left", fd[fd.right = 3] = "right", fd[fd.top = 4] = "top", fd[fd.bottom = 5] = "bottom", fd[fd["top-left"] = 6] = "top-left", fd[fd["top-right"] = 7] = "top-right", fd[fd["bottom-left"] = 8] = "bottom-left", fd[fd["bottom-right"] = 9] = "bottom-right";
			const dd = Number.POSITIVE_INFINITY;
			function yd(t$1, e$1) {
				return e$1[1] !== dd ? function(t$2, e$2, r$1) {
					let n$1 = 0, i$1 = 0;
					switch (e$2 = Math.abs(e$2), r$1 = Math.abs(r$1), t$2) {
						case "top-right":
						case "top-left":
						case "top":
							i$1 = r$1 - 7;
							break;
						case "bottom-right":
						case "bottom-left":
						case "bottom": i$1 = 7 - r$1;
					}
					switch (t$2) {
						case "top-right":
						case "bottom-right":
						case "right":
							n$1 = -e$2;
							break;
						case "top-left":
						case "bottom-left":
						case "left": n$1 = e$2;
					}
					return [n$1, i$1];
				}(t$1, e$1[0], e$1[1]) : function(t$2, e$2) {
					let r$1 = 0, n$1 = 0;
					e$2 < 0 && (e$2 = 0);
					const i$1 = e$2 / Math.SQRT2;
					switch (t$2) {
						case "top-right":
						case "top-left":
							n$1 = i$1 - 7;
							break;
						case "bottom-right":
						case "bottom-left":
							n$1 = 7 - i$1;
							break;
						case "bottom":
							n$1 = 7 - e$2;
							break;
						case "top": n$1 = e$2 - 7;
					}
					switch (t$2) {
						case "top-right":
						case "bottom-right":
							r$1 = -i$1;
							break;
						case "top-left":
						case "bottom-left":
							r$1 = i$1;
							break;
						case "left":
							r$1 = e$2;
							break;
						case "right": r$1 = -e$2;
					}
					return [r$1, n$1];
				}(t$1, e$1[0]);
			}
			function md(t$1, e$1, r$1) {
				var n$1;
				const i$1 = t$1.layout, s$1 = null === (n$1 = i$1.get("text-variable-anchor-offset")) || void 0 === n$1 ? void 0 : n$1.evaluate(e$1, {}, r$1);
				if (s$1) {
					const t$2 = s$1.values, e$2 = [];
					for (let r$2 = 0; r$2 < t$2.length; r$2 += 2) {
						const n$2 = e$2[r$2] = t$2[r$2], i$2 = t$2[r$2 + 1].map(((t$3) => t$3 * dc));
						n$2.startsWith("top") ? i$2[1] -= 7 : n$2.startsWith("bottom") && (i$2[1] += 7), e$2[r$2 + 1] = i$2;
					}
					return new Le(e$2);
				}
				const a = i$1.get("text-variable-anchor");
				if (a) {
					let n$2;
					n$2 = void 0 !== t$1._unevaluatedLayout.getValue("text-radial-offset") ? [i$1.get("text-radial-offset").evaluate(e$1, {}, r$1) * dc, dd] : i$1.get("text-offset").evaluate(e$1, {}, r$1).map(((t$2) => t$2 * dc));
					const s$2 = [];
					for (const t$2 of a) s$2.push(t$2, yd(t$2, n$2));
					return new Le(s$2);
				}
				return null;
			}
			function gd(t$1) {
				switch (t$1) {
					case "right":
					case "top-right":
					case "bottom-right": return "right";
					case "left":
					case "top-left":
					case "bottom-left": return "left";
				}
				return "center";
			}
			function xd(e$1, r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1) {
				let f$1 = a.textMaxSize.evaluate(r$1, {});
				void 0 === f$1 && (f$1 = o$1);
				const d$1 = e$1.layers[0].layout, y$1 = d$1.get("icon-offset").evaluate(r$1, {}, h$1), m$1 = bd(n$1.horizontal), g$1 = o$1 / 24, x$1 = e$1.tilePixelRatio * g$1, v$1 = e$1.tilePixelRatio * f$1 / 24, b$1 = e$1.tilePixelRatio * l$1, w$1 = e$1.tilePixelRatio * d$1.get("symbol-spacing"), _$1 = d$1.get("text-padding") * e$1.tilePixelRatio, S$1 = function(t$1, e$2, r$2, n$2 = 1) {
					const i$2 = t$1.get("icon-padding").evaluate(e$2, {}, r$2), s$2 = i$2 && i$2.values;
					return [
						s$2[0] * n$2,
						s$2[1] * n$2,
						s$2[2] * n$2,
						s$2[3] * n$2
					];
				}(d$1, r$1, h$1, e$1.tilePixelRatio), A$1 = d$1.get("text-max-angle") / 180 * Math.PI, k$1 = "viewport" !== d$1.get("text-rotation-alignment") && "point" !== d$1.get("symbol-placement"), E$1 = "map" === d$1.get("icon-rotation-alignment") && "point" !== d$1.get("symbol-placement"), T$1 = d$1.get("symbol-placement"), I$1 = w$1 / 2, F$1 = d$1.get("icon-text-fit");
				let D$1;
				i$1 && "none" !== F$1 && (e$1.allowVerticalPlacement && n$1.vertical && (D$1 = rh(i$1, n$1.vertical, F$1, d$1.get("icon-text-fit-padding"), y$1, g$1)), m$1 && (i$1 = rh(i$1, m$1, F$1, d$1.get("icon-text-fit-padding"), y$1, g$1)));
				const z$1 = h$1 ? p$1.line.getGranularityForZoomLevel(h$1.z) : 1, P$1 = (l$2, p$2) => {
					p$2.x < 0 || p$2.x >= M || p$2.y < 0 || p$2.y >= M || function(e$2, r$2, n$2, i$2, s$2, a$1, o$2, l$3, u$2, c$2, h$2, p$3, f$2, d$2, y$2, m$2, g$2, x$2, v$2, b$2, w$2, _$2, S$2, A$2, k$2) {
						const E$2 = e$2.addToLineVertexArray(r$2, n$2);
						let T$2, I$2, M$1, F$2, D$2 = 0, z$2 = 0, P$2 = 0, B$1 = 0, V$1 = -1, C$1 = -1;
						const L$1 = {};
						let O$1 = mo("");
						if (e$2.allowVerticalPlacement && i$2.vertical) {
							const t$1 = l$3.layout.get("text-rotate").evaluate(w$2, {}, A$2) + 90;
							M$1 = new ld(u$2, r$2, c$2, h$2, p$3, i$2.vertical, f$2, d$2, y$2, t$1), o$2 && (F$2 = new ld(u$2, r$2, c$2, h$2, p$3, o$2, g$2, x$2, y$2, t$1));
						}
						if (s$2) {
							const n$3 = l$3.layout.get("icon-rotate").evaluate(w$2, {}), i$3 = "none" !== l$3.layout.get("icon-text-fit"), a$2 = nd(s$2, n$3, S$2, i$3), f$3 = o$2 ? nd(o$2, n$3, S$2, i$3) : void 0;
							I$2 = new ld(u$2, r$2, c$2, h$2, p$3, s$2, g$2, x$2, !1, n$3), D$2 = 4 * a$2.length;
							const d$3 = e$2.iconSizeData;
							let y$3 = null;
							"source" === d$3.kind ? (y$3 = [nh * l$3.layout.get("icon-size").evaluate(w$2, {})], y$3[0] > ih && j(`${e$2.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : "composite" === d$3.kind && (y$3 = [nh * _$2.compositeIconSizes[0].evaluate(w$2, {}, A$2), nh * _$2.compositeIconSizes[1].evaluate(w$2, {}, A$2)], (y$3[0] > ih || y$3[1] > ih) && j(`${e$2.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), e$2.addSymbols(e$2.icon, a$2, y$3, b$2, v$2, w$2, t.az.none, r$2, E$2.lineStartIndex, E$2.lineLength, -1, A$2), V$1 = e$2.icon.placedSymbolArray.length - 1, f$3 && (z$2 = 4 * f$3.length, e$2.addSymbols(e$2.icon, f$3, y$3, b$2, v$2, w$2, t.az.vertical, r$2, E$2.lineStartIndex, E$2.lineLength, -1, A$2), C$1 = e$2.icon.placedSymbolArray.length - 1);
						}
						const R$1 = Object.keys(i$2.horizontal);
						for (const n$3 of R$1) {
							const s$3 = i$2.horizontal[n$3];
							if (!T$2) {
								O$1 = mo(s$3.text);
								T$2 = new ld(u$2, r$2, c$2, h$2, p$3, s$3, f$2, d$2, y$2, l$3.layout.get("text-rotate").evaluate(w$2, {}, A$2));
							}
							const o$3 = 1 === s$3.positionedLines.length;
							if (P$2 += vd(e$2, r$2, s$3, a$1, l$3, y$2, w$2, m$2, E$2, i$2.vertical ? t.az.horizontal : t.az.horizontalOnly, o$3 ? R$1 : [n$3], L$1, V$1, _$2, A$2), o$3) break;
						}
						i$2.vertical && (B$1 += vd(e$2, r$2, i$2.vertical, a$1, l$3, y$2, w$2, m$2, E$2, t.az.vertical, ["vertical"], L$1, C$1, _$2, A$2));
						const N$1 = T$2 ? T$2.boxStartIndex : e$2.collisionBoxArray.length, $$1 = T$2 ? T$2.boxEndIndex : e$2.collisionBoxArray.length, U$1 = M$1 ? M$1.boxStartIndex : e$2.collisionBoxArray.length, q$1 = M$1 ? M$1.boxEndIndex : e$2.collisionBoxArray.length, G$1 = I$2 ? I$2.boxStartIndex : e$2.collisionBoxArray.length, X$1 = I$2 ? I$2.boxEndIndex : e$2.collisionBoxArray.length, Y$1 = F$2 ? F$2.boxStartIndex : e$2.collisionBoxArray.length, Z$1 = F$2 ? F$2.boxEndIndex : e$2.collisionBoxArray.length;
						let H$1 = -1;
						const K$1 = (t$1, e$3) => t$1 && t$1.circleDiameter ? Math.max(t$1.circleDiameter, e$3) : e$3;
						H$1 = K$1(T$2, H$1), H$1 = K$1(M$1, H$1), H$1 = K$1(I$2, H$1), H$1 = K$1(F$2, H$1);
						const W$1 = H$1 > -1 ? 1 : 0;
						W$1 && (H$1 *= k$2 / dc), e$2.glyphOffsetArray.length >= fh.MAX_GLYPHS && j("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== w$2.sortKey && e$2.addToSortKeyRanges(e$2.symbolInstances.length, w$2.sortKey);
						const J$1 = md(l$3, w$2, A$2), [Q$1, tt$1] = function(e$3, r$3) {
							const n$3 = e$3.length, i$3 = null == r$3 ? void 0 : r$3.values;
							if ((null == i$3 ? void 0 : i$3.length) > 0) for (let r$4 = 0; r$4 < i$3.length; r$4 += 2) {
								const n$4 = i$3[r$4 + 1];
								e$3.emplaceBack(t.aP[i$3[r$4]], n$4[0], n$4[1]);
							}
							return [n$3, e$3.length];
						}(e$2.textAnchorOffsets, J$1);
						e$2.symbolInstances.emplaceBack(r$2.x, r$2.y, L$1.right >= 0 ? L$1.right : -1, L$1.center >= 0 ? L$1.center : -1, L$1.left >= 0 ? L$1.left : -1, L$1.vertical || -1, V$1, C$1, O$1, N$1, $$1, U$1, q$1, G$1, X$1, Y$1, Z$1, c$2, P$2, B$1, D$2, z$2, W$1, 0, f$2, H$1, Q$1, tt$1);
					}(e$1, p$2, l$2, n$1, i$1, s$1, D$1, e$1.layers[0], e$1.collisionBoxArray, r$1.index, r$1.sourceLayerIndex, e$1.index, x$1, [
						_$1,
						_$1,
						_$1,
						_$1
					], k$1, u$1, b$1, S$1, E$1, y$1, r$1, a, c$1, h$1, o$1);
				};
				if ("line" === T$1) for (const t$1 of qf(r$1.geometry, 0, 0, M, M)) {
					const r$2 = gu(t$1, z$1), s$2 = ed(r$2, w$1, A$1, n$1.vertical || m$1, i$1, 24, v$1, e$1.overscaling, M);
					for (const t$2 of s$2) m$1 && wd(e$1, m$1.text, I$1, t$2) || P$1(r$2, t$2);
				}
				else if ("line-center" === T$1) {
					for (const t$1 of r$1.geometry) if (t$1.length > 1) {
						const e$2 = gu(t$1, z$1), r$2 = td(e$2, A$1, n$1.vertical || m$1, i$1, 24, v$1);
						r$2 && P$1(e$2, r$2);
					}
				} else if ("Polygon" === r$1.type) for (const t$1 of tn(r$1.geometry, 0)) {
					const e$2 = cd(t$1, 16);
					P$1(gu(t$1[0], z$1, !0), new Hf(e$2.x, e$2.y, 0));
				}
				else if ("LineString" === r$1.type) for (const t$1 of r$1.geometry) {
					const e$2 = gu(t$1, z$1);
					P$1(e$2, new Hf(e$2[0].x, e$2[0].y, 0));
				}
				else if ("Point" === r$1.type) for (const t$1 of r$1.geometry) for (const e$2 of t$1) P$1([e$2], new Hf(e$2.x, e$2.y, 0));
			}
			function vd(t$1, e$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1) {
				const m$1 = function(t$2, e$2, n$2, i$2, s$2, a$1, o$2, l$2) {
					const u$2 = i$2.layout.get("text-rotate").evaluate(a$1, {}) * Math.PI / 180, c$2 = [];
					for (const t$3 of e$2.positionedLines) for (const i$3 of t$3.positionedGlyphs) {
						if (!i$3.rect) continue;
						const a$2 = i$3.rect || {};
						let h$2 = 4, p$2 = !0, f$2 = 1, d$2 = 0;
						const y$2 = (s$2 || l$2) && i$3.vertical, m$2 = i$3.metrics.advance * i$3.scale / 2;
						if (l$2 && e$2.verticalizable && (d$2 = t$3.lineOffset / 2 - (i$3.imageName ? -(dc - i$3.metrics.width * i$3.scale) / 2 : (i$3.scale - 1) * dc)), i$3.imageName) {
							const t$4 = o$2[i$3.imageName];
							p$2 = t$4.sdf, f$2 = t$4.pixelRatio, h$2 = 1 / f$2;
						}
						const g$2 = s$2 ? [i$3.x + m$2, i$3.y] : [0, 0];
						let x$2 = s$2 ? [0, 0] : [i$3.x + m$2 + n$2[0], i$3.y + n$2[1] - d$2], v$1 = [0, 0];
						y$2 && (v$1 = x$2, x$2 = [0, 0]);
						const b$1 = i$3.metrics.isDoubleResolution ? 2 : 1, w$1 = (i$3.metrics.left - h$2) * i$3.scale - m$2 + x$2[0], _$1 = (-i$3.metrics.top - h$2) * i$3.scale + x$2[1], S$1 = w$1 + a$2.w / b$1 * i$3.scale / f$2, A$1 = _$1 + a$2.h / b$1 * i$3.scale / f$2, k$1 = new r(w$1, _$1), E$1 = new r(S$1, _$1), T$1 = new r(w$1, A$1), I$1 = new r(S$1, A$1);
						if (y$2) {
							const t$4 = new r(-m$2, m$2 - -17), e$3 = -Math.PI / 2, n$3 = 12 - m$2, s$3 = new r(22 - n$3, -(i$3.imageName ? n$3 : 0)), a$3 = new r(...v$1);
							k$1._rotateAround(e$3, t$4)._add(s$3)._add(a$3), E$1._rotateAround(e$3, t$4)._add(s$3)._add(a$3), T$1._rotateAround(e$3, t$4)._add(s$3)._add(a$3), I$1._rotateAround(e$3, t$4)._add(s$3)._add(a$3);
						}
						if (u$2) {
							const t$4 = Math.sin(u$2), e$3 = Math.cos(u$2), r$1 = [
								e$3,
								-t$4,
								t$4,
								e$3
							];
							k$1._matMult(r$1), E$1._matMult(r$1), T$1._matMult(r$1), I$1._matMult(r$1);
						}
						const M$1 = new r(0, 0), F$1 = new r(0, 0);
						c$2.push({
							tl: k$1,
							tr: E$1,
							bl: T$1,
							br: I$1,
							tex: a$2,
							writingMode: e$2.writingMode,
							glyphOffset: g$2,
							sectionIndex: i$3.sectionIndex,
							isSDF: p$2,
							pixelOffsetTL: M$1,
							pixelOffsetBR: F$1,
							minFontScaleX: 0,
							minFontScaleY: 0
						});
					}
					return c$2;
				}(0, n$1, l$1, s$1, a, o$1, i$1, t$1.allowVerticalPlacement), g$1 = t$1.textSizeData;
				let x$1 = null;
				"source" === g$1.kind ? (x$1 = [nh * s$1.layout.get("text-size").evaluate(o$1, {})], x$1[0] > ih && j(`${t$1.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : "composite" === g$1.kind && (x$1 = [nh * d$1.compositeTextSizes[0].evaluate(o$1, {}, y$1), nh * d$1.compositeTextSizes[1].evaluate(o$1, {}, y$1)], (x$1[0] > ih || x$1[1] > ih) && j(`${t$1.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), t$1.addSymbols(t$1.text, m$1, x$1, l$1, a, o$1, c$1, e$1, u$1.lineStartIndex, u$1.lineLength, f$1, y$1);
				for (const e$2 of h$1) p$1[e$2] = t$1.text.placedSymbolArray.length - 1;
				return 4 * m$1.length;
			}
			function bd(t$1) {
				for (const e$1 in t$1) return t$1[e$1];
				return null;
			}
			function wd(t$1, e$1, r$1, n$1) {
				const i$1 = t$1.compareText;
				if (e$1 in i$1) {
					const t$2 = i$1[e$1];
					for (let e$2 = t$2.length - 1; e$2 >= 0; e$2--) if (n$1.dist(t$2[e$2]) < r$1) return !0;
				} else i$1[e$1] = [];
				return i$1[e$1].push(n$1), !1;
			}
			const _d = [
				Int8Array,
				Uint8Array,
				Uint8ClampedArray,
				Int16Array,
				Uint16Array,
				Int32Array,
				Uint32Array,
				Float32Array,
				Float64Array
			];
			class Sd {
				static from(t$1) {
					if (!(t$1 instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
					const [e$1, r$1] = new Uint8Array(t$1, 0, 2);
					if (219 !== e$1) throw new Error("Data does not appear to be in a KDBush format.");
					const n$1 = r$1 >> 4;
					if (1 !== n$1) throw new Error(`Got v${n$1} data when expected v1.`);
					const i$1 = _d[15 & r$1];
					if (!i$1) throw new Error("Unrecognized array type.");
					const [s$1] = new Uint16Array(t$1, 2, 1), [a] = new Uint32Array(t$1, 4, 1);
					return new Sd(a, s$1, i$1, t$1);
				}
				constructor(t$1, e$1 = 64, r$1 = Float64Array, n$1) {
					if (isNaN(t$1) || t$1 < 0) throw new Error(`Unpexpected numItems value: ${t$1}.`);
					this.numItems = +t$1, this.nodeSize = Math.min(Math.max(+e$1, 2), 65535), this.ArrayType = r$1, this.IndexArrayType = t$1 < 65536 ? Uint16Array : Uint32Array;
					const i$1 = _d.indexOf(this.ArrayType), s$1 = 2 * t$1 * this.ArrayType.BYTES_PER_ELEMENT, a = t$1 * this.IndexArrayType.BYTES_PER_ELEMENT, o$1 = (8 - a % 8) % 8;
					if (i$1 < 0) throw new Error(`Unexpected typed array class: ${r$1}.`);
					n$1 && n$1 instanceof ArrayBuffer ? (this.data = n$1, this.ids = new this.IndexArrayType(this.data, 8, t$1), this.coords = new this.ArrayType(this.data, 8 + a + o$1, 2 * t$1), this._pos = 2 * t$1, this._finished = !0) : (this.data = new ArrayBuffer(8 + s$1 + a + o$1), this.ids = new this.IndexArrayType(this.data, 8, t$1), this.coords = new this.ArrayType(this.data, 8 + a + o$1, 2 * t$1), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + i$1]), new Uint16Array(this.data, 2, 1)[0] = e$1, new Uint32Array(this.data, 4, 1)[0] = t$1);
				}
				add(t$1, e$1) {
					const r$1 = this._pos >> 1;
					return this.ids[r$1] = r$1, this.coords[this._pos++] = t$1, this.coords[this._pos++] = e$1, r$1;
				}
				finish() {
					const t$1 = this._pos >> 1;
					if (t$1 !== this.numItems) throw new Error(`Added ${t$1} items when expected ${this.numItems}.`);
					return Ad(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
				}
				range(t$1, e$1, r$1, n$1) {
					if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
					const { ids: i$1, coords: s$1, nodeSize: a } = this, o$1 = [
						0,
						i$1.length - 1,
						0
					], l$1 = [];
					for (; o$1.length;) {
						const u$1 = o$1.pop() || 0, c$1 = o$1.pop() || 0, h$1 = o$1.pop() || 0;
						if (c$1 - h$1 <= a) {
							for (let a$1 = h$1; a$1 <= c$1; a$1++) {
								const o$2 = s$1[2 * a$1], u$2 = s$1[2 * a$1 + 1];
								o$2 >= t$1 && o$2 <= r$1 && u$2 >= e$1 && u$2 <= n$1 && l$1.push(i$1[a$1]);
							}
							continue;
						}
						const p$1 = h$1 + c$1 >> 1, f$1 = s$1[2 * p$1], d$1 = s$1[2 * p$1 + 1];
						f$1 >= t$1 && f$1 <= r$1 && d$1 >= e$1 && d$1 <= n$1 && l$1.push(i$1[p$1]), (0 === u$1 ? t$1 <= f$1 : e$1 <= d$1) && (o$1.push(h$1), o$1.push(p$1 - 1), o$1.push(1 - u$1)), (0 === u$1 ? r$1 >= f$1 : n$1 >= d$1) && (o$1.push(p$1 + 1), o$1.push(c$1), o$1.push(1 - u$1));
					}
					return l$1;
				}
				within(t$1, e$1, r$1) {
					if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
					const { ids: n$1, coords: i$1, nodeSize: s$1 } = this, a = [
						0,
						n$1.length - 1,
						0
					], o$1 = [], l$1 = r$1 * r$1;
					for (; a.length;) {
						const u$1 = a.pop() || 0, c$1 = a.pop() || 0, h$1 = a.pop() || 0;
						if (c$1 - h$1 <= s$1) {
							for (let r$2 = h$1; r$2 <= c$1; r$2++) Id(i$1[2 * r$2], i$1[2 * r$2 + 1], t$1, e$1) <= l$1 && o$1.push(n$1[r$2]);
							continue;
						}
						const p$1 = h$1 + c$1 >> 1, f$1 = i$1[2 * p$1], d$1 = i$1[2 * p$1 + 1];
						Id(f$1, d$1, t$1, e$1) <= l$1 && o$1.push(n$1[p$1]), (0 === u$1 ? t$1 - r$1 <= f$1 : e$1 - r$1 <= d$1) && (a.push(h$1), a.push(p$1 - 1), a.push(1 - u$1)), (0 === u$1 ? t$1 + r$1 >= f$1 : e$1 + r$1 >= d$1) && (a.push(p$1 + 1), a.push(c$1), a.push(1 - u$1));
					}
					return o$1;
				}
			}
			function Ad(t$1, e$1, r$1, n$1, i$1, s$1) {
				if (i$1 - n$1 <= r$1) return;
				const a = n$1 + i$1 >> 1;
				kd(t$1, e$1, a, n$1, i$1, s$1), Ad(t$1, e$1, r$1, n$1, a - 1, 1 - s$1), Ad(t$1, e$1, r$1, a + 1, i$1, 1 - s$1);
			}
			function kd(t$1, e$1, r$1, n$1, i$1, s$1) {
				for (; i$1 > n$1;) {
					if (i$1 - n$1 > 600) {
						const a$1 = i$1 - n$1 + 1, o$2 = r$1 - n$1 + 1, l$2 = Math.log(a$1), u$1 = .5 * Math.exp(2 * l$2 / 3), c$1 = .5 * Math.sqrt(l$2 * u$1 * (a$1 - u$1) / a$1) * (o$2 - a$1 / 2 < 0 ? -1 : 1);
						kd(t$1, e$1, r$1, Math.max(n$1, Math.floor(r$1 - o$2 * u$1 / a$1 + c$1)), Math.min(i$1, Math.floor(r$1 + (a$1 - o$2) * u$1 / a$1 + c$1)), s$1);
					}
					const a = e$1[2 * r$1 + s$1];
					let o$1 = n$1, l$1 = i$1;
					for (Ed(t$1, e$1, n$1, r$1), e$1[2 * i$1 + s$1] > a && Ed(t$1, e$1, n$1, i$1); o$1 < l$1;) {
						for (Ed(t$1, e$1, o$1, l$1), o$1++, l$1--; e$1[2 * o$1 + s$1] < a;) o$1++;
						for (; e$1[2 * l$1 + s$1] > a;) l$1--;
					}
					e$1[2 * n$1 + s$1] === a ? Ed(t$1, e$1, n$1, l$1) : (l$1++, Ed(t$1, e$1, l$1, i$1)), l$1 <= r$1 && (n$1 = l$1 + 1), r$1 <= l$1 && (i$1 = l$1 - 1);
				}
			}
			function Ed(t$1, e$1, r$1, n$1) {
				Td(t$1, r$1, n$1), Td(e$1, 2 * r$1, 2 * n$1), Td(e$1, 2 * r$1 + 1, 2 * n$1 + 1);
			}
			function Td(t$1, e$1, r$1) {
				const n$1 = t$1[e$1];
				t$1[e$1] = t$1[r$1], t$1[r$1] = n$1;
			}
			function Id(t$1, e$1, r$1, n$1) {
				const i$1 = t$1 - r$1, s$1 = e$1 - n$1;
				return i$1 * i$1 + s$1 * s$1;
			}
			var Md;
			t.cI = void 0, (Md = t.cI || (t.cI = {})).create = "create", Md.load = "load", Md.fullLoad = "fullLoad";
			let Fd = null, Dd = [];
			const zd = 1e3 / 60, Pd = "loadTime", Bd = "fullLoadTime";
			t.$ = c, t.A = f, t.B = us, t.C = is, t.D = js, t.E = xt, t.F = function([t$1, e$1, r$1]) {
				return e$1 += 90, e$1 *= Math.PI / 180, r$1 *= Math.PI / 180, {
					x: t$1 * Math.cos(e$1) * Math.sin(r$1),
					y: t$1 * Math.sin(e$1) * Math.sin(r$1),
					z: t$1 * Math.cos(r$1)
				};
			}, t.G = yr, t.H = Ps, t.I = qc, t.J = as, t.K = function(t$1) {
				if (null == Y) {
					const e$1 = t$1.navigator ? t$1.navigator.userAgent : null;
					Y = !!t$1.safari || !(!e$1 || !(/\b(iPad|iPhone|iPod)\b/.test(e$1) || e$1.match("Safari") && !e$1.match("Chrome")));
				}
				return Y;
			}, t.L = class {
				constructor(t$1, e$1) {
					this.target = t$1, this.mapId = e$1, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new Sh((() => this.process())), this.subscription = Q(this.target, "message", ((t$2) => this.receive(t$2)), !1), this.globalScope = X(self) ? t$1 : window;
				}
				registerMessageHandler(t$1, e$1) {
					this.messageHandlers[t$1] = e$1;
				}
				unregisterMessageHandler(t$1) {
					delete this.messageHandlers[t$1];
				}
				sendAsync(t$1, e$1) {
					return new Promise(((r$1, n$1) => {
						const i$1 = Math.round(0xde0b6b3a7640000 * Math.random()).toString(36).substring(0, 10), s$1 = e$1 ? Q(e$1.signal, "abort", (() => {
							s$1?.unsubscribe(), delete this.resolveRejects[i$1];
							const e$2 = {
								id: i$1,
								type: "<cancel>",
								origin: location.origin,
								targetMapId: t$1.targetMapId,
								sourceMapId: this.mapId
							};
							this.target.postMessage(e$2);
						}), Ah) : null;
						this.resolveRejects[i$1] = {
							resolve: (t$2) => {
								s$1?.unsubscribe(), r$1(t$2);
							},
							reject: (t$2) => {
								s$1?.unsubscribe(), n$1(t$2);
							}
						};
						const a = [], o$1 = Object.assign(Object.assign({}, t$1), {
							id: i$1,
							sourceMapId: this.mapId,
							origin: location.origin,
							data: ms(t$1.data, a)
						});
						this.target.postMessage(o$1, { transfer: a });
					}));
				}
				receive(t$1) {
					const e$1 = t$1.data, r$1 = e$1.id;
					if (!("file://" !== e$1.origin && "file://" !== location.origin && "resource://android" !== e$1.origin && "resource://android" !== location.origin && e$1.origin !== location.origin || e$1.targetMapId && this.mapId !== e$1.targetMapId)) {
						if ("<cancel>" === e$1.type) {
							delete this.tasks[r$1];
							const t$2 = this.abortControllers[r$1];
							delete this.abortControllers[r$1], t$2 && t$2.abort();
							return;
						}
						if (X(self) || e$1.mustQueue) return this.tasks[r$1] = e$1, this.taskQueue.push(r$1), void this.invoker.trigger();
						this.processTask(r$1, e$1);
					}
				}
				process() {
					if (0 === this.taskQueue.length) return;
					const t$1 = this.taskQueue.shift(), e$1 = this.tasks[t$1];
					delete this.tasks[t$1], this.taskQueue.length > 0 && this.invoker.trigger(), e$1 && this.processTask(t$1, e$1);
				}
				processTask(t$1, r$1) {
					return e(this, void 0, void 0, (function* () {
						if ("<response>" === r$1.type) {
							const e$2 = this.resolveRejects[t$1];
							if (delete this.resolveRejects[t$1], !e$2) return;
							r$1.error ? e$2.reject(gs(r$1.error)) : e$2.resolve(gs(r$1.data));
							return;
						}
						if (!this.messageHandlers[r$1.type]) return void this.completeTask(t$1, /* @__PURE__ */ new Error(`Could not find a registered handler for ${r$1.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
						const e$1 = gs(r$1.data), n$1 = new AbortController();
						this.abortControllers[t$1] = n$1;
						try {
							const i$1 = yield this.messageHandlers[r$1.type](r$1.sourceMapId, e$1, n$1);
							this.completeTask(t$1, null, i$1);
						} catch (e$2) {
							this.completeTask(t$1, e$2);
						}
					}));
				}
				completeTask(t$1, e$1, r$1) {
					const n$1 = [];
					delete this.abortControllers[t$1];
					const i$1 = {
						id: t$1,
						type: "<response>",
						sourceMapId: this.mapId,
						origin: location.origin,
						error: e$1 ? ms(e$1) : null,
						data: ms(r$1, n$1)
					};
					this.target.postMessage(i$1, { transfer: n$1 });
				}
				remove() {
					this.invoker.remove(), this.subscription.unsubscribe();
				}
			}, t.M = ut, t.N = function() {
				var t$1 = new f(16);
				return f != Float32Array && (t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[4] = 0, t$1[6] = 0, t$1[7] = 0, t$1[8] = 0, t$1[9] = 0, t$1[11] = 0, t$1[12] = 0, t$1[13] = 0, t$1[14] = 0), t$1[0] = 1, t$1[5] = 1, t$1[10] = 1, t$1[15] = 1, t$1;
			}, t.O = function(t$1, e$1, r$1) {
				var n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1 = r$1[0], m$1 = r$1[1], g$1 = r$1[2];
				return e$1 === t$1 ? (t$1[12] = e$1[0] * y$1 + e$1[4] * m$1 + e$1[8] * g$1 + e$1[12], t$1[13] = e$1[1] * y$1 + e$1[5] * m$1 + e$1[9] * g$1 + e$1[13], t$1[14] = e$1[2] * y$1 + e$1[6] * m$1 + e$1[10] * g$1 + e$1[14], t$1[15] = e$1[3] * y$1 + e$1[7] * m$1 + e$1[11] * g$1 + e$1[15]) : (i$1 = e$1[1], s$1 = e$1[2], a = e$1[3], o$1 = e$1[4], l$1 = e$1[5], u$1 = e$1[6], c$1 = e$1[7], h$1 = e$1[8], p$1 = e$1[9], f$1 = e$1[10], d$1 = e$1[11], t$1[0] = n$1 = e$1[0], t$1[1] = i$1, t$1[2] = s$1, t$1[3] = a, t$1[4] = o$1, t$1[5] = l$1, t$1[6] = u$1, t$1[7] = c$1, t$1[8] = h$1, t$1[9] = p$1, t$1[10] = f$1, t$1[11] = d$1, t$1[12] = n$1 * y$1 + o$1 * m$1 + h$1 * g$1 + e$1[12], t$1[13] = i$1 * y$1 + l$1 * m$1 + p$1 * g$1 + e$1[13], t$1[14] = s$1 * y$1 + u$1 * m$1 + f$1 * g$1 + e$1[14], t$1[15] = a * y$1 + c$1 * m$1 + d$1 * g$1 + e$1[15]), t$1;
			}, t.P = r, t.Q = function(t$1, e$1, r$1) {
				var n$1 = r$1[0], i$1 = r$1[1], s$1 = r$1[2];
				return t$1[0] = e$1[0] * n$1, t$1[1] = e$1[1] * n$1, t$1[2] = e$1[2] * n$1, t$1[3] = e$1[3] * n$1, t$1[4] = e$1[4] * i$1, t$1[5] = e$1[5] * i$1, t$1[6] = e$1[6] * i$1, t$1[7] = e$1[7] * i$1, t$1[8] = e$1[8] * s$1, t$1[9] = e$1[9] * s$1, t$1[10] = e$1[10] * s$1, t$1[11] = e$1[11] * s$1, t$1[12] = e$1[12], t$1[13] = e$1[13], t$1[14] = e$1[14], t$1[15] = e$1[15], t$1;
			}, t.R = Sl, t.S = function(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2], a = e$1[3], o$1 = e$1[4], l$1 = e$1[5], u$1 = e$1[6], c$1 = e$1[7], h$1 = e$1[8], p$1 = e$1[9], f$1 = e$1[10], d$1 = e$1[11], y$1 = e$1[12], m$1 = e$1[13], g$1 = e$1[14], x$1 = e$1[15], v$1 = r$1[0], b$1 = r$1[1], w$1 = r$1[2], _$1 = r$1[3];
				return t$1[0] = v$1 * n$1 + b$1 * o$1 + w$1 * h$1 + _$1 * y$1, t$1[1] = v$1 * i$1 + b$1 * l$1 + w$1 * p$1 + _$1 * m$1, t$1[2] = v$1 * s$1 + b$1 * u$1 + w$1 * f$1 + _$1 * g$1, t$1[3] = v$1 * a + b$1 * c$1 + w$1 * d$1 + _$1 * x$1, t$1[4] = (v$1 = r$1[4]) * n$1 + (b$1 = r$1[5]) * o$1 + (w$1 = r$1[6]) * h$1 + (_$1 = r$1[7]) * y$1, t$1[5] = v$1 * i$1 + b$1 * l$1 + w$1 * p$1 + _$1 * m$1, t$1[6] = v$1 * s$1 + b$1 * u$1 + w$1 * f$1 + _$1 * g$1, t$1[7] = v$1 * a + b$1 * c$1 + w$1 * d$1 + _$1 * x$1, t$1[8] = (v$1 = r$1[8]) * n$1 + (b$1 = r$1[9]) * o$1 + (w$1 = r$1[10]) * h$1 + (_$1 = r$1[11]) * y$1, t$1[9] = v$1 * i$1 + b$1 * l$1 + w$1 * p$1 + _$1 * m$1, t$1[10] = v$1 * s$1 + b$1 * u$1 + w$1 * f$1 + _$1 * g$1, t$1[11] = v$1 * a + b$1 * c$1 + w$1 * d$1 + _$1 * x$1, t$1[12] = (v$1 = r$1[12]) * n$1 + (b$1 = r$1[13]) * o$1 + (w$1 = r$1[14]) * h$1 + (_$1 = r$1[15]) * y$1, t$1[13] = v$1 * i$1 + b$1 * l$1 + w$1 * p$1 + _$1 * m$1, t$1[14] = v$1 * s$1 + b$1 * u$1 + w$1 * f$1 + _$1 * g$1, t$1[15] = v$1 * a + b$1 * c$1 + w$1 * d$1 + _$1 * x$1, t$1;
			}, t.T = zl, t.U = function(t$1, e$1) {
				const r$1 = {};
				for (let n$1 = 0; n$1 < e$1.length; n$1++) {
					const i$1 = e$1[n$1];
					i$1 in t$1 && (r$1[i$1] = t$1[i$1]);
				}
				return r$1;
			}, t.V = Eh, t.W = L, t.X = Fh, t.Y = Mh, t.Z = at, t._ = e, t.a = st, t.a$ = b, t.a0 = h, t.a1 = K, t.a2 = Rh, t.a3 = zh, t.a4 = Ph, t.a5 = M, t.a6 = function(t$1, e$1, r$1) {
				if (!t$1) return e$1 || {};
				if (!e$1) return t$1 || {};
				const n$1 = qh(t$1), i$1 = qh(e$1);
				(function(t$2, e$2) {
					e$2.removeAll && (t$2.add.clear(), t$2.update.clear(), t$2.remove.clear(), e$2.remove.clear());
					for (const r$2 of e$2.remove) t$2.add.delete(r$2), t$2.update.delete(r$2);
					for (const [r$2, n$2] of e$2.update) {
						const i$2 = t$2.update.get(r$2);
						i$2 && (e$2.update.set(r$2, Uh(i$2, n$2)), t$2.update.delete(r$2));
					}
				})(n$1, i$1);
				const s$1 = {};
				if ((n$1.removeAll || i$1.removeAll) && (s$1.removeAll = !0), s$1.remove = new Set([...n$1.remove, ...i$1.remove]), s$1.add = new Map([...n$1.add, ...i$1.add]), s$1.update = new Map([...n$1.update, ...i$1.update]), s$1.remove.size && s$1.add.size) for (const t$2 of s$1.add.keys()) s$1.remove.delete(t$2);
				return function(t$2) {
					const e$2 = {};
					return t$2.removeAll && (e$2.removeAll = t$2.removeAll), t$2.remove && (e$2.remove = Array.from(t$2.remove)), t$2.add && (e$2.add = Array.from(t$2.add.values())), t$2.update && (e$2.update = Array.from(t$2.update.values())), e$2;
				}(s$1);
			}, t.a7 = function(t$1, e$1) {
				const r$1 = /* @__PURE__ */ new Map();
				if (null == t$1) return r$1;
				if (null == t$1.type) return r$1;
				if ("Feature" === t$1.type) {
					const n$1 = $h(t$1, e$1);
					if (null == n$1) return;
					return r$1.set(n$1, t$1), r$1;
				}
				if ("FeatureCollection" === t$1.type) {
					const n$1 = /* @__PURE__ */ new Set();
					for (const i$1 of t$1.features) {
						const t$2 = $h(i$1, e$1);
						if (null == t$2) return;
						if (n$1.has(t$2)) return;
						n$1.add(t$2), r$1.set(t$2, i$1);
					}
					return r$1;
				}
			}, t.a8 = function(t$1, e$1, r$1) {
				var n$1, i$1;
				const s$1 = [];
				if (e$1.removeAll) t$1.clear();
				else if (e$1.remove) for (const r$2 of e$1.remove) {
					const e$2 = t$1.get(r$2);
					e$2 && (s$1.push(e$2.geometry), t$1.delete(r$2));
				}
				if (e$1.add) for (const n$2 of e$1.add) {
					const e$2 = $h(n$2, r$1);
					if (null == e$2) continue;
					const i$2 = t$1.get(e$2);
					i$2 && s$1.push(i$2.geometry), s$1.push(n$2.geometry), t$1.set(e$2, n$2);
				}
				if (e$1.update) for (const r$2 of e$1.update) {
					const e$2 = t$1.get(r$2.id);
					if (!e$2) continue;
					const a = !!r$2.newGeometry, o$1 = r$2.removeAllProperties || (null === (n$1 = r$2.removeProperties) || void 0 === n$1 ? void 0 : n$1.length) > 0 || (null === (i$1 = r$2.addOrUpdateProperties) || void 0 === i$1 ? void 0 : i$1.length) > 0;
					if (!a && !o$1) continue;
					s$1.push(e$2.geometry);
					const l$1 = Object.assign({}, e$2);
					if (t$1.set(r$2.id, l$1), a && (s$1.push(r$2.newGeometry), l$1.geometry = r$2.newGeometry), o$1) {
						if (l$1.properties = r$2.removeAllProperties ? {} : Object.assign({}, l$1.properties || {}), r$2.removeProperties) for (const t$2 of r$2.removeProperties) delete l$1.properties[t$2];
						if (r$2.addOrUpdateProperties) for (const { key: t$2, value: e$3 } of r$2.addOrUpdateProperties) l$1.properties[t$2] = e$3;
					}
				}
				return s$1;
			}, t.a9 = Vh, t.aA = function(t$1, { uSize: e$1, uSizeT: r$1 }, { lowerSize: n$1, upperSize: i$1 }) {
				return "source" === t$1.kind ? n$1 / nh : "composite" === t$1.kind ? yr.number(n$1 / nh, i$1 / nh, r$1) : e$1;
			}, t.aB = function(t$1, e$1) {
				var r$1 = e$1[0], n$1 = e$1[1], i$1 = e$1[2], s$1 = e$1[3], a = e$1[4], o$1 = e$1[5], l$1 = e$1[6], u$1 = e$1[7], c$1 = e$1[8], h$1 = e$1[9], p$1 = e$1[10], f$1 = e$1[11], d$1 = e$1[12], y$1 = e$1[13], m$1 = e$1[14], g$1 = e$1[15], x$1 = r$1 * o$1 - n$1 * a, v$1 = r$1 * l$1 - i$1 * a, b$1 = r$1 * u$1 - s$1 * a, w$1 = n$1 * l$1 - i$1 * o$1, _$1 = n$1 * u$1 - s$1 * o$1, S$1 = i$1 * u$1 - s$1 * l$1, A$1 = c$1 * y$1 - h$1 * d$1, k$1 = c$1 * m$1 - p$1 * d$1, E$1 = c$1 * g$1 - f$1 * d$1, T$1 = h$1 * m$1 - p$1 * y$1, I$1 = h$1 * g$1 - f$1 * y$1, M$1 = p$1 * g$1 - f$1 * m$1, F$1 = x$1 * M$1 - v$1 * I$1 + b$1 * T$1 + w$1 * E$1 - _$1 * k$1 + S$1 * A$1;
				return F$1 ? (t$1[0] = (o$1 * M$1 - l$1 * I$1 + u$1 * T$1) * (F$1 = 1 / F$1), t$1[1] = (i$1 * I$1 - n$1 * M$1 - s$1 * T$1) * F$1, t$1[2] = (y$1 * S$1 - m$1 * _$1 + g$1 * w$1) * F$1, t$1[3] = (p$1 * _$1 - h$1 * S$1 - f$1 * w$1) * F$1, t$1[4] = (l$1 * E$1 - a * M$1 - u$1 * k$1) * F$1, t$1[5] = (r$1 * M$1 - i$1 * E$1 + s$1 * k$1) * F$1, t$1[6] = (m$1 * b$1 - d$1 * S$1 - g$1 * v$1) * F$1, t$1[7] = (c$1 * S$1 - p$1 * b$1 + f$1 * v$1) * F$1, t$1[8] = (a * I$1 - o$1 * E$1 + u$1 * A$1) * F$1, t$1[9] = (n$1 * E$1 - r$1 * I$1 - s$1 * A$1) * F$1, t$1[10] = (d$1 * _$1 - y$1 * b$1 + g$1 * x$1) * F$1, t$1[11] = (h$1 * b$1 - c$1 * _$1 - f$1 * x$1) * F$1, t$1[12] = (o$1 * k$1 - a * T$1 - l$1 * A$1) * F$1, t$1[13] = (r$1 * T$1 - n$1 * k$1 + i$1 * A$1) * F$1, t$1[14] = (y$1 * v$1 - d$1 * w$1 - m$1 * x$1) * F$1, t$1[15] = (c$1 * w$1 - h$1 * v$1 + p$1 * x$1) * F$1, t$1) : null;
			}, t.aC = T, t.aD = function(t$1) {
				var e$1 = t$1[0], r$1 = t$1[1];
				return Math.sqrt(e$1 * e$1 + r$1 * r$1);
			}, t.aE = function(t$1) {
				return t$1[0] = 0, t$1[1] = 0, t$1;
			}, t.aF = function(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] * r$1, t$1[1] = e$1[1] * r$1, t$1;
			}, t.aG = uh, t.aH = A, t.aI = function(t$1, e$1, n$1, i$1) {
				const s$1 = e$1.y - t$1.y, a = e$1.x - t$1.x, o$1 = i$1.y - n$1.y, l$1 = i$1.x - n$1.x, u$1 = o$1 * a - l$1 * s$1;
				if (0 === u$1) return null;
				const c$1 = (l$1 * (t$1.y - n$1.y) - o$1 * (t$1.x - n$1.x)) / u$1;
				return new r(t$1.x + c$1 * a, t$1.y + c$1 * s$1);
			}, t.aJ = qf, t.aK = Go, t.aL = function(t$1) {
				let e$1 = Infinity, r$1 = Infinity, n$1 = -Infinity, i$1 = -Infinity;
				for (const s$1 of t$1) e$1 = Math.min(e$1, s$1.x), r$1 = Math.min(r$1, s$1.y), n$1 = Math.max(n$1, s$1.x), i$1 = Math.max(i$1, s$1.y);
				return [
					e$1,
					r$1,
					n$1,
					i$1
				];
			}, t.aM = dc, t.aN = F, t.aO = function(t$1, e$1, r$1, n$1, i$1 = !1) {
				if (!r$1[0] && !r$1[1]) return [0, 0];
				const s$1 = i$1 ? "map" === n$1 ? -t$1.bearingInRadians : 0 : "viewport" === n$1 ? t$1.bearingInRadians : 0;
				if (s$1) {
					const t$2 = Math.sin(s$1), e$2 = Math.cos(s$1);
					r$1 = [r$1[0] * e$2 - r$1[1] * t$2, r$1[0] * t$2 + r$1[1] * e$2];
				}
				return [i$1 ? r$1[0] : F(e$1, r$1[0], t$1.zoom), i$1 ? r$1[1] : F(e$1, r$1[1], t$1.zoom)];
			}, t.aQ = ah, t.aR = gd, t.aS = Yc, t.aT = Sd, t.aU = na, t.aV = pu, t.aW = $a, t.aX = io, t.aY = to, t.aZ = et, t.a_ = Bh, t.aa = jh, t.ab = 25, t.ac = Lh, t.ad = (t$1) => {
				const e$1 = window.document.createElement("video");
				return e$1.muted = !0, new Promise(((r$1) => {
					e$1.onloadstart = () => {
						r$1(e$1);
					};
					for (const r$2 of t$1) {
						const t$2 = window.document.createElement("source");
						ft(r$2) || (e$1.crossOrigin = "Anonymous"), t$2.src = r$2, e$1.appendChild(t$2);
					}
				}));
			}, t.ae = Dt, t.af = function() {
				return R++;
			}, t.ag = Fa, t.ah = fh, t.ai = zf, t.aj = fi, t.ak = $o, t.al = Xh, t.am = function(t$1) {
				const e$1 = {};
				if (t$1.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((t$2, r$1, n$1, i$1) => {
					const s$1 = n$1 || i$1;
					return e$1[r$1] = !s$1 || s$1.toLowerCase(), "";
				})), e$1["max-age"]) {
					const t$2 = parseInt(e$1["max-age"], 10);
					isNaN(t$2) ? delete e$1["max-age"] : e$1["max-age"] = t$2;
				}
				return e$1;
			}, t.an = C, t.ao = 85.051129, t.ap = tt, t.aq = function(t$1) {
				return Math.pow(2, t$1);
			}, t.ar = y, t.as = Dh, t.at = function(t$1) {
				return Math.log(t$1) / Math.LN2;
			}, t.au = function(t$1) {
				var e$1 = t$1[0], r$1 = t$1[1];
				return e$1 * e$1 + r$1 * r$1;
			}, t.av = function(t$1) {
				if (!t$1.length) return /* @__PURE__ */ new Set();
				const e$1 = Math.max(...t$1.map(((t$2) => t$2.canonical.z)));
				let r$1 = Infinity, n$1 = -Infinity, i$1 = Infinity, s$1 = -Infinity;
				const a = [];
				for (const o$2 of t$1) {
					const { x: t$2, y: l$1, z: u$1 } = o$2.canonical, c$1 = Math.pow(2, e$1 - u$1), h$1 = t$2 * c$1, p$1 = l$1 * c$1;
					a.push({
						id: o$2,
						x: h$1,
						y: p$1
					}), h$1 < r$1 && (r$1 = h$1), h$1 > n$1 && (n$1 = h$1), p$1 < i$1 && (i$1 = p$1), p$1 > s$1 && (s$1 = p$1);
				}
				const o$1 = /* @__PURE__ */ new Set();
				for (const t$2 of a) t$2.x !== r$1 && t$2.x !== n$1 && t$2.y !== i$1 && t$2.y !== s$1 || o$1.add(t$2.id);
				return o$1;
			}, t.aw = function(t$1, e$1) {
				const r$1 = Math.abs(2 * t$1.wrap) - +(t$1.wrap < 0), n$1 = Math.abs(2 * e$1.wrap) - +(e$1.wrap < 0);
				return t$1.overscaledZ - e$1.overscaledZ || n$1 - r$1 || e$1.canonical.y - t$1.canonical.y || e$1.canonical.x - t$1.canonical.x;
			}, t.ax = class {
				constructor(t$1, e$1) {
					this.max = t$1, this.onRemove = e$1, this.reset();
				}
				reset() {
					for (const t$1 in this.data) for (const e$1 of this.data[t$1]) e$1.timeout && clearTimeout(e$1.timeout), this.onRemove(e$1.value);
					return this.data = {}, this.order = [], this;
				}
				add(t$1, e$1, r$1) {
					const n$1 = t$1.wrapped().key;
					void 0 === this.data[n$1] && (this.data[n$1] = []);
					const i$1 = {
						value: e$1,
						timeout: void 0
					};
					if (void 0 !== r$1 && (i$1.timeout = setTimeout((() => {
						this.remove(t$1, i$1);
					}), r$1)), this.data[n$1].push(i$1), this.order.push(n$1), this.order.length > this.max) {
						const t$2 = this._getAndRemoveByKey(this.order[0]);
						t$2 && this.onRemove(t$2);
					}
					return this;
				}
				has(t$1) {
					return t$1.wrapped().key in this.data;
				}
				getAndRemove(t$1) {
					return this.has(t$1) ? this._getAndRemoveByKey(t$1.wrapped().key) : null;
				}
				_getAndRemoveByKey(t$1) {
					const e$1 = this.data[t$1].shift();
					return e$1.timeout && clearTimeout(e$1.timeout), 0 === this.data[t$1].length && delete this.data[t$1], this.order.splice(this.order.indexOf(t$1), 1), e$1.value;
				}
				getByKey(t$1) {
					const e$1 = this.data[t$1];
					return e$1 ? e$1[0].value : null;
				}
				get(t$1) {
					return this.has(t$1) ? this.data[t$1.wrapped().key][0].value : null;
				}
				remove(t$1, e$1) {
					if (!this.has(t$1)) return this;
					const r$1 = t$1.wrapped().key, n$1 = void 0 === e$1 ? 0 : this.data[r$1].indexOf(e$1), i$1 = this.data[r$1][n$1];
					return this.data[r$1].splice(n$1, 1), i$1.timeout && clearTimeout(i$1.timeout), 0 === this.data[r$1].length && delete this.data[r$1], this.onRemove(i$1.value), this.order.splice(this.order.indexOf(r$1), 1), this;
				}
				setMaxSize(t$1) {
					for (this.max = t$1; this.order.length > this.max;) {
						const t$2 = this._getAndRemoveByKey(this.order[0]);
						t$2 && this.onRemove(t$2);
					}
					return this;
				}
				filter(t$1) {
					const e$1 = [];
					for (const r$1 in this.data) for (const n$1 of this.data[r$1]) t$1(n$1.value) || e$1.push(n$1);
					for (const t$2 of e$1) this.remove(t$2.value.tileID, t$2);
				}
			}, t.ay = function(t$1, e$1) {
				let r$1 = 0, n$1 = 0;
				if ("constant" === t$1.kind) n$1 = t$1.layoutSize;
				else if ("source" !== t$1.kind) {
					const { interpolationType: i$1, minZoom: s$1, maxZoom: a } = t$1, o$1 = i$1 ? C(fr.interpolationFactor(i$1, e$1, s$1, a), 0, 1) : 0;
					"camera" === t$1.kind ? n$1 = yr.number(t$1.minSize, t$1.maxSize, o$1) : r$1 = o$1;
				}
				return {
					uSizeT: r$1,
					uSize: n$1
				};
			}, t.b = Z, t.b$ = Ao, t.b0 = v, t.b1 = function(t$1) {
				var e$1 = new f(3);
				return e$1[0] = t$1[0], e$1[1] = t$1[1], e$1[2] = t$1[2], e$1;
			}, t.b2 = function(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] - r$1[0], t$1[1] = e$1[1] - r$1[1], t$1[2] = e$1[2] - r$1[2], t$1;
			}, t.b3 = function(t$1, e$1) {
				var r$1 = e$1[0], n$1 = e$1[1], i$1 = e$1[2], s$1 = r$1 * r$1 + n$1 * n$1 + i$1 * i$1;
				return s$1 > 0 && (s$1 = 1 / Math.sqrt(s$1)), t$1[0] = e$1[0] * s$1, t$1[1] = e$1[1] * s$1, t$1[2] = e$1[2] * s$1, t$1;
			}, t.b4 = w, t.b5 = function(t$1, e$1) {
				return t$1[0] * e$1[0] + t$1[1] * e$1[1] + t$1[2] * e$1[2];
			}, t.b6 = function(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] * r$1[0], t$1[1] = e$1[1] * r$1[1], t$1[2] = e$1[2] * r$1[2], t$1[3] = e$1[3] * r$1[3], t$1;
			}, t.b7 = g, t.b8 = function(t$1, e$1, r$1) {
				const n$1 = e$1[0] * r$1[0] + e$1[1] * r$1[1] + e$1[2] * r$1[2];
				return 0 === n$1 ? null : (-(t$1[0] * r$1[0] + t$1[1] * r$1[1] + t$1[2] * r$1[2]) - r$1[3]) / n$1;
			}, t.b9 = S, t.bA = function() {
				return new Float64Array(3);
			}, t.bB = E, t.bC = function(t$1, e$1, r$1) {
				var n$1 = r$1[0], i$1 = r$1[1], s$1 = r$1[2], a = r$1[3], o$1 = e$1[0], l$1 = e$1[1], u$1 = e$1[2], c$1 = i$1 * u$1 - s$1 * l$1, h$1 = s$1 * o$1 - n$1 * u$1, p$1 = n$1 * l$1 - i$1 * o$1;
				return t$1[0] = o$1 + a * (c$1 += c$1) + i$1 * (p$1 += p$1) - s$1 * (h$1 += h$1), t$1[1] = l$1 + a * h$1 + s$1 * c$1 - n$1 * p$1, t$1[2] = u$1 + a * p$1 + n$1 * h$1 - i$1 * c$1, t$1;
			}, t.bD = function(t$1, e$1, r$1) {
				const n$1 = (i$1 = [
					t$1[0],
					t$1[1],
					t$1[2],
					e$1[0],
					e$1[1],
					e$1[2],
					r$1[0],
					r$1[1],
					r$1[2]
				])[0] * ((c$1 = i$1[8]) * (a = i$1[4]) - (o$1 = i$1[5]) * (u$1 = i$1[7])) + i$1[1] * (-c$1 * (s$1 = i$1[3]) + o$1 * (l$1 = i$1[6])) + i$1[2] * (u$1 * s$1 - a * l$1);
				var i$1, s$1, a, o$1, l$1, u$1, c$1;
				if (0 === n$1) return null;
				const h$1 = w([], [
					e$1[0],
					e$1[1],
					e$1[2]
				], [
					r$1[0],
					r$1[1],
					r$1[2]
				]), p$1 = w([], [
					r$1[0],
					r$1[1],
					r$1[2]
				], [
					t$1[0],
					t$1[1],
					t$1[2]
				]), f$1 = w([], [
					t$1[0],
					t$1[1],
					t$1[2]
				], [
					e$1[0],
					e$1[1],
					e$1[2]
				]), d$1 = b([], h$1, -t$1[3]);
				return v(d$1, d$1, b([], p$1, -e$1[3])), v(d$1, d$1, b([], f$1, -r$1[3])), b(d$1, d$1, 1 / n$1), d$1;
			}, t.bE = kh, t.bF = function() {
				return new Float64Array(4);
			}, t.bG = function(t$1, e$1, r$1, n$1) {
				var i$1 = [], s$1 = [];
				return i$1[0] = e$1[0] - r$1[0], i$1[1] = e$1[1] - r$1[1], i$1[2] = e$1[2] - r$1[2], s$1[0] = i$1[0] * Math.cos(n$1) - i$1[1] * Math.sin(n$1), s$1[1] = i$1[0] * Math.sin(n$1) + i$1[1] * Math.cos(n$1), s$1[2] = i$1[2], t$1[0] = s$1[0] + r$1[0], t$1[1] = s$1[1] + r$1[1], t$1[2] = s$1[2] + r$1[2], t$1;
			}, t.bH = function(t$1, e$1, r$1, n$1) {
				var i$1 = [], s$1 = [];
				return i$1[0] = e$1[0] - r$1[0], i$1[1] = e$1[1] - r$1[1], i$1[2] = e$1[2] - r$1[2], s$1[0] = i$1[0], s$1[1] = i$1[1] * Math.cos(n$1) - i$1[2] * Math.sin(n$1), s$1[2] = i$1[1] * Math.sin(n$1) + i$1[2] * Math.cos(n$1), t$1[0] = s$1[0] + r$1[0], t$1[1] = s$1[1] + r$1[1], t$1[2] = s$1[2] + r$1[2], t$1;
			}, t.bI = function(t$1, e$1, r$1, n$1) {
				var i$1 = [], s$1 = [];
				return i$1[0] = e$1[0] - r$1[0], i$1[1] = e$1[1] - r$1[1], i$1[2] = e$1[2] - r$1[2], s$1[0] = i$1[2] * Math.sin(n$1) + i$1[0] * Math.cos(n$1), s$1[1] = i$1[1], s$1[2] = i$1[2] * Math.cos(n$1) - i$1[0] * Math.sin(n$1), t$1[0] = s$1[0] + r$1[0], t$1[1] = s$1[1] + r$1[1], t$1[2] = s$1[2] + r$1[2], t$1;
			}, t.bJ = function(t$1, e$1, r$1) {
				var n$1 = Math.sin(r$1), i$1 = Math.cos(r$1), s$1 = e$1[0], a = e$1[1], o$1 = e$1[2], l$1 = e$1[3], u$1 = e$1[8], c$1 = e$1[9], h$1 = e$1[10], p$1 = e$1[11];
				return e$1 !== t$1 && (t$1[4] = e$1[4], t$1[5] = e$1[5], t$1[6] = e$1[6], t$1[7] = e$1[7], t$1[12] = e$1[12], t$1[13] = e$1[13], t$1[14] = e$1[14], t$1[15] = e$1[15]), t$1[0] = s$1 * i$1 - u$1 * n$1, t$1[1] = a * i$1 - c$1 * n$1, t$1[2] = o$1 * i$1 - h$1 * n$1, t$1[3] = l$1 * i$1 - p$1 * n$1, t$1[8] = s$1 * n$1 + u$1 * i$1, t$1[9] = a * n$1 + c$1 * i$1, t$1[10] = o$1 * n$1 + h$1 * i$1, t$1[11] = l$1 * n$1 + p$1 * i$1, t$1;
			}, t.bK = function(t$1, e$1) {
				const r$1 = D(t$1, 360), n$1 = D(e$1, 360), i$1 = n$1 - r$1, s$1 = n$1 > r$1 ? i$1 - 360 : i$1 + 360;
				return Math.abs(i$1) < Math.abs(s$1) ? i$1 : s$1;
			}, t.bL = function(t$1) {
				return t$1[0] = 0, t$1[1] = 0, t$1[2] = 0, t$1;
			}, t.bM = function(t$1, e$1, r$1, n$1) {
				const i$1 = Math.sqrt(t$1 * t$1 + e$1 * e$1), s$1 = Math.sqrt(r$1 * r$1 + n$1 * n$1);
				t$1 /= i$1, e$1 /= i$1, r$1 /= s$1, n$1 /= s$1;
				const a = Math.acos(t$1 * r$1 + e$1 * n$1);
				return -e$1 * r$1 + t$1 * n$1 > 0 ? a : -a;
			}, t.bN = function(t$1, e$1) {
				const r$1 = D(t$1, 2 * Math.PI), n$1 = D(e$1, 2 * Math.PI);
				return Math.min(Math.abs(r$1 - n$1), Math.abs(r$1 - n$1 + 2 * Math.PI), Math.abs(r$1 - n$1 - 2 * Math.PI));
			}, t.bO = function() {
				const t$1 = {}, e$1 = vt.$version;
				for (const r$1 in vt.$root) {
					const n$1 = vt.$root[r$1];
					if (n$1.required) {
						let i$1 = null;
						i$1 = "version" === r$1 ? e$1 : "array" === n$1.type ? [] : {}, null != i$1 && (t$1[r$1] = i$1);
					}
				}
				return t$1;
			}, t.bP = ht, t.bQ = xs, t.bR = function t$1(e$1, r$1) {
				if (Array.isArray(e$1)) {
					if (!Array.isArray(r$1) || e$1.length !== r$1.length) return !1;
					for (let n$1 = 0; n$1 < e$1.length; n$1++) if (!t$1(e$1[n$1], r$1[n$1])) return !1;
					return !0;
				}
				if ("object" == typeof e$1 && null !== e$1 && null !== r$1) {
					if ("object" != typeof r$1) return !1;
					if (Object.keys(e$1).length !== Object.keys(r$1).length) return !1;
					for (const n$1 in e$1) if (!t$1(e$1[n$1], r$1[n$1])) return !1;
					return !0;
				}
				return e$1 === r$1;
			}, t.bS = function(t$1) {
				t$1 = t$1.slice();
				const e$1 = Object.create(null);
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1[t$1[r$1].id] = t$1[r$1];
				for (let r$1 = 0; r$1 < t$1.length; r$1++) "ref" in t$1[r$1] && (t$1[r$1] = wt(t$1[r$1], e$1[t$1[r$1].ref]));
				return t$1;
			}, t.bT = function(t$1, e$1) {
				if ("custom" === t$1.type) return new _h(t$1, e$1);
				switch (t$1.type) {
					case "background": return new wh(t$1, e$1);
					case "circle": return new yl(t$1, e$1);
					case "color-relief": return new Vl(t$1, e$1);
					case "fill": return new ku(t$1, e$1);
					case "fill-extrusion": return new Gu(t$1, e$1);
					case "heatmap": return new El(t$1, e$1);
					case "hillshade": return new Ml(t$1, e$1);
					case "line": return new ac(t$1, e$1);
					case "raster": return new Qs(t$1, e$1);
					case "symbol": return new xh(t$1, e$1);
				}
			}, t.bU = (t$1) => "raster" === t$1.type, t.bV = U, t.bW = function(t$1, e$1) {
				if (!t$1) return [{
					command: "setStyle",
					args: [e$1]
				}];
				let r$1 = [];
				try {
					if (!_t(t$1.version, e$1.version)) return [{
						command: "setStyle",
						args: [e$1]
					}];
					_t(t$1.center, e$1.center) || r$1.push({
						command: "setCenter",
						args: [e$1.center]
					}), _t(t$1.state, e$1.state) || r$1.push({
						command: "setGlobalState",
						args: [e$1.state]
					}), _t(t$1.centerAltitude, e$1.centerAltitude) || r$1.push({
						command: "setCenterAltitude",
						args: [e$1.centerAltitude]
					}), _t(t$1.zoom, e$1.zoom) || r$1.push({
						command: "setZoom",
						args: [e$1.zoom]
					}), _t(t$1.bearing, e$1.bearing) || r$1.push({
						command: "setBearing",
						args: [e$1.bearing]
					}), _t(t$1.pitch, e$1.pitch) || r$1.push({
						command: "setPitch",
						args: [e$1.pitch]
					}), _t(t$1.roll, e$1.roll) || r$1.push({
						command: "setRoll",
						args: [e$1.roll]
					}), _t(t$1.sprite, e$1.sprite) || r$1.push({
						command: "setSprite",
						args: [e$1.sprite]
					}), _t(t$1.glyphs, e$1.glyphs) || r$1.push({
						command: "setGlyphs",
						args: [e$1.glyphs]
					}), _t(t$1.transition, e$1.transition) || r$1.push({
						command: "setTransition",
						args: [e$1.transition]
					}), _t(t$1.light, e$1.light) || r$1.push({
						command: "setLight",
						args: [e$1.light]
					}), _t(t$1.terrain, e$1.terrain) || r$1.push({
						command: "setTerrain",
						args: [e$1.terrain]
					}), _t(t$1.sky, e$1.sky) || r$1.push({
						command: "setSky",
						args: [e$1.sky]
					}), _t(t$1.projection, e$1.projection) || r$1.push({
						command: "setProjection",
						args: [e$1.projection]
					});
					const n$1 = {}, i$1 = [];
					(function(t$2, e$2, r$2, n$2) {
						let i$2;
						for (i$2 in e$2 = e$2 || {}, t$2 = t$2 || {}) Object.prototype.hasOwnProperty.call(t$2, i$2) && (Object.prototype.hasOwnProperty.call(e$2, i$2) || kt(i$2, r$2, n$2));
						for (i$2 in e$2) Object.prototype.hasOwnProperty.call(e$2, i$2) && (Object.prototype.hasOwnProperty.call(t$2, i$2) ? _t(t$2[i$2], e$2[i$2]) || ("geojson" === t$2[i$2].type && "geojson" === e$2[i$2].type && Tt(t$2, e$2, i$2) ? St(r$2, {
							command: "setGeoJSONSourceData",
							args: [i$2, e$2[i$2].data]
						}) : Et(i$2, e$2, r$2, n$2)) : At(i$2, e$2, r$2));
					})(t$1.sources, e$1.sources, i$1, n$1);
					const s$1 = [];
					t$1.layers && t$1.layers.forEach(((t$2) => {
						"source" in t$2 && n$1[t$2.source] ? r$1.push({
							command: "removeLayer",
							args: [t$2.id]
						}) : s$1.push(t$2);
					})), r$1 = r$1.concat(i$1), function(t$2, e$2, r$2) {
						e$2 = e$2 || [];
						const n$2 = (t$2 = t$2 || []).map(Mt), i$2 = e$2.map(Mt), s$2 = t$2.reduce(Ft, {}), a = e$2.reduce(Ft, {}), o$1 = n$2.slice(), l$1 = Object.create(null);
						let u$1, c$1, h$1, p$1, f$1;
						for (let t$3 = 0, e$3 = 0; t$3 < n$2.length; t$3++) u$1 = n$2[t$3], Object.prototype.hasOwnProperty.call(a, u$1) ? e$3++ : (St(r$2, {
							command: "removeLayer",
							args: [u$1]
						}), o$1.splice(o$1.indexOf(u$1, e$3), 1));
						for (let t$3 = 0, e$3 = 0; t$3 < i$2.length; t$3++) u$1 = i$2[i$2.length - 1 - t$3], o$1[o$1.length - 1 - t$3] !== u$1 && (Object.prototype.hasOwnProperty.call(s$2, u$1) ? (St(r$2, {
							command: "removeLayer",
							args: [u$1]
						}), o$1.splice(o$1.lastIndexOf(u$1, o$1.length - e$3), 1)) : e$3++, p$1 = o$1[o$1.length - t$3], St(r$2, {
							command: "addLayer",
							args: [a[u$1], p$1]
						}), o$1.splice(o$1.length - t$3, 0, u$1), l$1[u$1] = !0);
						for (let t$3 = 0; t$3 < i$2.length; t$3++) if (u$1 = i$2[t$3], c$1 = s$2[u$1], h$1 = a[u$1], !l$1[u$1] && !_t(c$1, h$1)) if (_t(c$1.source, h$1.source) && _t(c$1["source-layer"], h$1["source-layer"]) && _t(c$1.type, h$1.type)) {
							for (f$1 in It(c$1.layout, h$1.layout, r$2, u$1, null, "setLayoutProperty"), It(c$1.paint, h$1.paint, r$2, u$1, null, "setPaintProperty"), _t(c$1.filter, h$1.filter) || St(r$2, {
								command: "setFilter",
								args: [u$1, h$1.filter]
							}), _t(c$1.minzoom, h$1.minzoom) && _t(c$1.maxzoom, h$1.maxzoom) || St(r$2, {
								command: "setLayerZoomRange",
								args: [
									u$1,
									h$1.minzoom,
									h$1.maxzoom
								]
							}), c$1) Object.prototype.hasOwnProperty.call(c$1, f$1) && "layout" !== f$1 && "paint" !== f$1 && "filter" !== f$1 && "metadata" !== f$1 && "minzoom" !== f$1 && "maxzoom" !== f$1 && (0 === f$1.indexOf("paint.") ? It(c$1[f$1], h$1[f$1], r$2, u$1, f$1.slice(6), "setPaintProperty") : _t(c$1[f$1], h$1[f$1]) || St(r$2, {
								command: "setLayerProperty",
								args: [
									u$1,
									f$1,
									h$1[f$1]
								]
							}));
							for (f$1 in h$1) Object.prototype.hasOwnProperty.call(h$1, f$1) && !Object.prototype.hasOwnProperty.call(c$1, f$1) && "layout" !== f$1 && "paint" !== f$1 && "filter" !== f$1 && "metadata" !== f$1 && "minzoom" !== f$1 && "maxzoom" !== f$1 && (0 === f$1.indexOf("paint.") ? It(c$1[f$1], h$1[f$1], r$2, u$1, f$1.slice(6), "setPaintProperty") : _t(c$1[f$1], h$1[f$1]) || St(r$2, {
								command: "setLayerProperty",
								args: [
									u$1,
									f$1,
									h$1[f$1]
								]
							}));
						} else St(r$2, {
							command: "removeLayer",
							args: [u$1]
						}), p$1 = o$1[o$1.lastIndexOf(u$1) + 1], St(r$2, {
							command: "addLayer",
							args: [h$1, p$1]
						});
					}(s$1, e$1.layers, r$1);
				} catch (t$2) {
					console.warn("Unable to compute style diff:", t$2), r$1 = [{
						command: "setStyle",
						args: [e$1]
					}];
				}
				return r$1;
			}, t.bX = function(t$1) {
				const e$1 = [], r$1 = t$1.id;
				return void 0 === r$1 && e$1.push({ message: `layers.${r$1}: missing required property "id"` }), void 0 === t$1.render && e$1.push({ message: `layers.${r$1}: missing required method "render"` }), t$1.renderingMode && "2d" !== t$1.renderingMode && "3d" !== t$1.renderingMode && e$1.push({ message: `layers.${r$1}: property "renderingMode" must be either "2d" or "3d"` }), e$1;
			}, t.bY = N, t.bZ = $, t.b_ = class extends wo {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = 0;
				}
				set(t$1) {
					this.current !== t$1 && (this.current = t$1, this.gl.uniform1i(this.location, t$1));
				}
			}, t.ba = function(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] * r$1, t$1[1] = e$1[1] * r$1, t$1[2] = e$1[2] * r$1, t$1[3] = e$1[3] * r$1, t$1;
			}, t.bb = function(t$1, e$1) {
				return t$1[0] * e$1[0] + t$1[1] * e$1[1] + t$1[2] * e$1[2] + t$1[3];
			}, t.bc = Oh, t.bd = Nh, t.be = function(t$1, e$1, r$1, n$1, i$1) {
				var s$1 = 1 / Math.tan(e$1 / 2);
				if (t$1[0] = s$1 / r$1, t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[4] = 0, t$1[5] = s$1, t$1[6] = 0, t$1[7] = 0, t$1[8] = 0, t$1[9] = 0, t$1[11] = -1, t$1[12] = 0, t$1[13] = 0, t$1[15] = 0, null != i$1 && i$1 !== Infinity) {
					var a = 1 / (n$1 - i$1);
					t$1[10] = (i$1 + n$1) * a, t$1[14] = 2 * i$1 * n$1 * a;
				} else t$1[10] = -1, t$1[14] = -2 * n$1;
				return t$1;
			}, t.bf = function(t$1) {
				var e$1 = new f(16);
				return e$1[0] = t$1[0], e$1[1] = t$1[1], e$1[2] = t$1[2], e$1[3] = t$1[3], e$1[4] = t$1[4], e$1[5] = t$1[5], e$1[6] = t$1[6], e$1[7] = t$1[7], e$1[8] = t$1[8], e$1[9] = t$1[9], e$1[10] = t$1[10], e$1[11] = t$1[11], e$1[12] = t$1[12], e$1[13] = t$1[13], e$1[14] = t$1[14], e$1[15] = t$1[15], e$1;
			}, t.bg = function(t$1, e$1, r$1) {
				var n$1 = Math.sin(r$1), i$1 = Math.cos(r$1), s$1 = e$1[0], a = e$1[1], o$1 = e$1[2], l$1 = e$1[3], u$1 = e$1[4], c$1 = e$1[5], h$1 = e$1[6], p$1 = e$1[7];
				return e$1 !== t$1 && (t$1[8] = e$1[8], t$1[9] = e$1[9], t$1[10] = e$1[10], t$1[11] = e$1[11], t$1[12] = e$1[12], t$1[13] = e$1[13], t$1[14] = e$1[14], t$1[15] = e$1[15]), t$1[0] = s$1 * i$1 + u$1 * n$1, t$1[1] = a * i$1 + c$1 * n$1, t$1[2] = o$1 * i$1 + h$1 * n$1, t$1[3] = l$1 * i$1 + p$1 * n$1, t$1[4] = u$1 * i$1 - s$1 * n$1, t$1[5] = c$1 * i$1 - a * n$1, t$1[6] = h$1 * i$1 - o$1 * n$1, t$1[7] = p$1 * i$1 - l$1 * n$1, t$1;
			}, t.bh = function(t$1, e$1, r$1) {
				var n$1 = Math.sin(r$1), i$1 = Math.cos(r$1), s$1 = e$1[4], a = e$1[5], o$1 = e$1[6], l$1 = e$1[7], u$1 = e$1[8], c$1 = e$1[9], h$1 = e$1[10], p$1 = e$1[11];
				return e$1 !== t$1 && (t$1[0] = e$1[0], t$1[1] = e$1[1], t$1[2] = e$1[2], t$1[3] = e$1[3], t$1[12] = e$1[12], t$1[13] = e$1[13], t$1[14] = e$1[14], t$1[15] = e$1[15]), t$1[4] = s$1 * i$1 + u$1 * n$1, t$1[5] = a * i$1 + c$1 * n$1, t$1[6] = o$1 * i$1 + h$1 * n$1, t$1[7] = l$1 * i$1 + p$1 * n$1, t$1[8] = u$1 * i$1 - s$1 * n$1, t$1[9] = c$1 * i$1 - a * n$1, t$1[10] = h$1 * i$1 - o$1 * n$1, t$1[11] = p$1 * i$1 - l$1 * n$1, t$1;
			}, t.bi = function() {
				const t$1 = new Float32Array(16);
				return y(t$1), t$1;
			}, t.bj = function() {
				const t$1 = new Float64Array(16);
				return y(t$1), t$1;
			}, t.bk = function() {
				return new Float64Array(16);
			}, t.bl = function(t$1, e$1, r$1) {
				const n$1 = new Float64Array(4);
				return E(n$1, t$1, e$1 - 90, r$1), n$1;
			}, t.bm = function(t$1, e$1, r$1, n$1) {
				var i$1, s$1, a, o$1, l$1, u$1 = e$1[0], c$1 = e$1[1], h$1 = e$1[2], f$1 = e$1[3], d$1 = r$1[0], y$1 = r$1[1], m$1 = r$1[2], g$1 = r$1[3];
				return (s$1 = u$1 * d$1 + c$1 * y$1 + h$1 * m$1 + f$1 * g$1) < 0 && (s$1 = -s$1, d$1 = -d$1, y$1 = -y$1, m$1 = -m$1, g$1 = -g$1), 1 - s$1 > p ? (i$1 = Math.acos(s$1), a = Math.sin(i$1), o$1 = Math.sin((1 - n$1) * i$1) / a, l$1 = Math.sin(n$1 * i$1) / a) : (o$1 = 1 - n$1, l$1 = n$1), t$1[0] = o$1 * u$1 + l$1 * d$1, t$1[1] = o$1 * c$1 + l$1 * y$1, t$1[2] = o$1 * h$1 + l$1 * m$1, t$1[3] = o$1 * f$1 + l$1 * g$1, t$1;
			}, t.bn = function(t$1) {
				const e$1 = new Float64Array(9);
				var r$1, n$1, i$1, s$1, a, o$1, l$1, u$1, c$1, h$1 = (i$1 = (n$1 = t$1)[0]) * (l$1 = i$1 + i$1), p$1 = (s$1 = n$1[1]) * l$1, f$1, d$1 = (a = n$1[2]) * l$1, y$1 = a * (u$1 = s$1 + s$1), m$1, g$1 = (o$1 = n$1[3]) * l$1, x$1 = o$1 * u$1, v$1 = o$1 * (c$1 = a + a);
				(r$1 = e$1)[0] = 1 - (f$1 = s$1 * u$1) - (m$1 = a * c$1), r$1[3] = p$1 - v$1, r$1[6] = d$1 + x$1, r$1[1] = p$1 + v$1, r$1[4] = 1 - h$1 - m$1, r$1[7] = y$1 - g$1, r$1[2] = d$1 - x$1, r$1[5] = y$1 + g$1, r$1[8] = 1 - h$1 - f$1;
				const b$1 = et(-Math.asin(C(e$1[2], -1, 1)));
				let w$1, _$1;
				return Math.hypot(e$1[5], e$1[8]) < .001 ? (w$1 = 0, _$1 = -et(Math.atan2(e$1[3], e$1[4]))) : (w$1 = et(0 === e$1[5] && 0 === e$1[8] ? 0 : Math.atan2(e$1[5], e$1[8])), _$1 = et(0 === e$1[1] && 0 === e$1[0] ? 0 : Math.atan2(e$1[1], e$1[0]))), {
					roll: w$1,
					pitch: b$1 + 90,
					bearing: _$1
				};
			}, t.bo = function(t$1, e$1) {
				return t$1.roll == e$1.roll && t$1.pitch == e$1.pitch && t$1.bearing == e$1.bearing;
			}, t.bp = Te, t.bq = _o, t.br = fu, t.bs = du, t.bt = hu, t.bu = z, t.bv = P, t.bw = Re, t.bx = function(t$1, e$1, r$1, n$1, i$1) {
				return z(n$1, i$1, C((t$1 - e$1) / (r$1 - e$1), 0, 1));
			}, t.by = function(t$1, e$1, r$1, n$1) {
				return t$1[0] = e$1[0] + r$1[0] * n$1, t$1[1] = e$1[1] + r$1[1] * n$1, t$1[2] = e$1[2] + r$1[2] * n$1, t$1;
			}, t.bz = D, t.c = ot, t.c$ = class {
				constructor(t$1) {
					this._marks = {
						start: [t$1.url, "start"].join("#"),
						end: [t$1.url, "end"].join("#"),
						measure: t$1.url.toString()
					}, performance.mark(this._marks.start);
				}
				finish() {
					performance.mark(this._marks.end);
					let t$1 = performance.getEntriesByName(this._marks.measure);
					return 0 === t$1.length && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), t$1 = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), t$1;
				}
			}, t.c0 = class extends wo {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = ko;
				}
				set(t$1) {
					if (t$1[12] !== this.current[12] || t$1[0] !== this.current[0]) return this.current = t$1, void this.gl.uniformMatrix4fv(this.location, !1, t$1);
					for (let e$1 = 1; e$1 < 16; e$1++) if (t$1[e$1] !== this.current[e$1]) {
						this.current = t$1, this.gl.uniformMatrix4fv(this.location, !1, t$1);
						break;
					}
				}
			}, t.c1 = So, t.c2 = class extends wo {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = [
						0,
						0,
						0
					];
				}
				set(t$1) {
					t$1[0] === this.current[0] && t$1[1] === this.current[1] && t$1[2] === this.current[2] || (this.current = t$1, this.gl.uniform3f(this.location, t$1[0], t$1[1], t$1[2]));
				}
			}, t.c3 = class extends wo {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = [0, 0];
				}
				set(t$1) {
					t$1[0] === this.current[0] && t$1[1] === this.current[1] || (this.current = t$1, this.gl.uniform2f(this.location, t$1[0], t$1[1]));
				}
			}, t.c4 = d, t.c5 = function(t$1, e$1) {
				var r$1 = Math.sin(e$1), n$1 = Math.cos(e$1);
				return t$1[0] = n$1, t$1[1] = r$1, t$1[2] = 0, t$1[3] = -r$1, t$1[4] = n$1, t$1[5] = 0, t$1[6] = 0, t$1[7] = 0, t$1[8] = 1, t$1;
			}, t.c6 = function(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2];
				return t$1[0] = n$1 * r$1[0] + i$1 * r$1[3] + s$1 * r$1[6], t$1[1] = n$1 * r$1[1] + i$1 * r$1[4] + s$1 * r$1[7], t$1[2] = n$1 * r$1[2] + i$1 * r$1[5] + s$1 * r$1[8], t$1;
			}, t.c7 = function(t$1, e$1, r$1, n$1, i$1, s$1, a) {
				var o$1 = 1 / (e$1 - r$1), l$1 = 1 / (n$1 - i$1), u$1 = 1 / (s$1 - a);
				return t$1[0] = -2 * o$1, t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[4] = 0, t$1[5] = -2 * l$1, t$1[6] = 0, t$1[7] = 0, t$1[8] = 0, t$1[9] = 0, t$1[10] = 2 * u$1, t$1[11] = 0, t$1[12] = (e$1 + r$1) * o$1, t$1[13] = (i$1 + n$1) * l$1, t$1[14] = (a + s$1) * u$1, t$1[15] = 1, t$1;
			}, t.c8 = class extends wo {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = new Array();
				}
				set(t$1) {
					if (t$1 != this.current) {
						this.current = t$1;
						const e$1 = new Float32Array(4 * t$1.length);
						for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1[4 * r$1] = t$1[r$1].r, e$1[4 * r$1 + 1] = t$1[r$1].g, e$1[4 * r$1 + 2] = t$1[r$1].b, e$1[4 * r$1 + 3] = t$1[r$1].a;
						this.gl.uniform4fv(this.location, e$1);
					}
				}
			}, t.c9 = class extends wo {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = new Array();
				}
				set(t$1) {
					if (t$1 != this.current) {
						this.current = t$1;
						const e$1 = new Float32Array(t$1);
						this.gl.uniform1fv(this.location, e$1);
					}
				}
			}, t.cA = function(t$1, e$1) {
				var r$1;
				if (!nt[e$1]) return !1;
				const n$1 = null == t$1 ? void 0 : t$1.target, i$1 = (null === (r$1 = null == n$1 ? void 0 : n$1.ownerDocument) || void 0 === r$1 ? void 0 : r$1.defaultView) || window;
				return t$1 instanceof i$1.MouseEvent || t$1 instanceof i$1.WheelEvent;
			}, t.cB = function(t$1, e$1) {
				return rt[e$1] && "touches" in t$1;
			}, t.cC = function(t$1) {
				return rt[t$1] || nt[t$1];
			}, t.cD = function(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1];
				return t$1[0] = r$1[0] * n$1 + r$1[4] * i$1 + r$1[12], t$1[1] = r$1[1] * n$1 + r$1[5] * i$1 + r$1[13], t$1;
			}, t.cE = function(t$1, e$1) {
				const { x: r$1, y: n$1 } = Vh.fromLngLat(e$1);
				return !(t$1 < 0 || t$1 > 25 || n$1 < 0 || n$1 >= 1 || r$1 < 0 || r$1 >= 1);
			}, t.cF = function(t$1, e$1) {
				return t$1[0] = e$1[0], t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[4] = 0, t$1[5] = e$1[1], t$1[6] = 0, t$1[7] = 0, t$1[8] = 0, t$1[9] = 0, t$1[10] = e$1[2], t$1[11] = 0, t$1[12] = 0, t$1[13] = 0, t$1[14] = 0, t$1[15] = 1, t$1;
			}, t.cG = class extends aa {}, t.cH = {
				mark(t$1) {
					performance.mark(t$1);
				},
				frame(t$1) {
					const e$1 = t$1;
					null != Fd && Dd.push(e$1 - Fd), Fd = e$1;
				},
				clearMetrics() {
					Fd = null, Dd = [], performance.clearMeasures(Pd), performance.clearMeasures(Bd);
					for (const e$1 in t.cI) performance.clearMarks(t.cI[e$1]);
				},
				getPerformanceMetrics() {
					performance.measure(Pd, t.cI.create, t.cI.load), performance.measure(Bd, t.cI.create, t.cI.fullLoad);
					const e$1 = performance.getEntriesByName(Pd)[0].duration, r$1 = performance.getEntriesByName(Bd)[0].duration, n$1 = Dd.length, i$1 = 1 / (Dd.reduce(((t$1, e$2) => t$1 + e$2), 0) / n$1 / 1e3), s$1 = Dd.filter(((t$1) => t$1 > zd)).reduce(((t$1, e$2) => t$1 + (e$2 - zd) / zd), 0);
					return {
						loadTime: e$1,
						fullLoadTime: r$1,
						fps: i$1,
						percentDroppedFrames: s$1 / (n$1 + s$1) * 100,
						totalFrames: n$1
					};
				}
			}, t.cJ = ct, t.cK = function(t$1, e$1) {
				ot.REGISTERED_PROTOCOLS[t$1] = e$1;
			}, t.cL = function(t$1) {
				delete ot.REGISTERED_PROTOCOLS[t$1];
			}, t.cM = function(t$1, e$1) {
				const r$1 = {};
				for (let n$2 = 0; n$2 < t$1.length; n$2++) {
					const i$1 = e$1 && e$1[t$1[n$2].id] || _i(t$1[n$2]);
					e$1 && (e$1[t$1[n$2].id] = i$1);
					let s$1 = r$1[i$1];
					s$1 || (s$1 = r$1[i$1] = []), s$1.push(t$1[n$2]);
				}
				const n$1 = [];
				for (const t$2 in r$1) n$1.push(r$1[t$2]);
				return n$1;
			}, t.cN = ps, t.cO = Gh, t.cP = Nf, t.cQ = jc, t.cR = function(e$1) {
				var r$1;
				e$1.bucket.createArrays(), e$1.bucket.tilePixelRatio = M / (512 * e$1.bucket.overscaling), e$1.bucket.compareText = {}, e$1.bucket.iconsNeedLinear = !1;
				const n$1 = e$1.bucket.layers[0], i$1 = n$1.layout, s$1 = n$1._unevaluatedLayout._values, a = {
					layoutIconSize: s$1["icon-size"].possiblyEvaluate(new Ps(e$1.bucket.zoom + 1), e$1.canonical),
					layoutTextSize: s$1["text-size"].possiblyEvaluate(new Ps(e$1.bucket.zoom + 1), e$1.canonical),
					textMaxSize: s$1["text-size"].possiblyEvaluate(new Ps(18))
				};
				if ("composite" === e$1.bucket.textSizeData.kind) {
					const { minZoom: t$1, maxZoom: r$2 } = e$1.bucket.textSizeData;
					a.compositeTextSizes = [s$1["text-size"].possiblyEvaluate(new Ps(t$1), e$1.canonical), s$1["text-size"].possiblyEvaluate(new Ps(r$2), e$1.canonical)];
				}
				if ("composite" === e$1.bucket.iconSizeData.kind) {
					const { minZoom: t$1, maxZoom: r$2 } = e$1.bucket.iconSizeData;
					a.compositeIconSizes = [s$1["icon-size"].possiblyEvaluate(new Ps(t$1), e$1.canonical), s$1["icon-size"].possiblyEvaluate(new Ps(r$2), e$1.canonical)];
				}
				const o$1 = i$1.get("text-line-height") * dc, l$1 = "viewport" !== i$1.get("text-rotation-alignment") && "point" !== i$1.get("symbol-placement"), u$1 = i$1.get("text-keep-upright"), c$1 = i$1.get("text-size");
				for (const s$2 of e$1.bucket.features) {
					const h$1 = i$1.get("text-font").evaluate(s$2, {}, e$1.canonical).join(","), p$1 = c$1.evaluate(s$2, {}, e$1.canonical), f$1 = a.layoutTextSize.evaluate(s$2, {}, e$1.canonical), d$1 = a.layoutIconSize.evaluate(s$2, {}, e$1.canonical), y$1 = {
						horizontal: {},
						vertical: void 0
					}, m$1 = s$2.text;
					let g$1, x$1 = [0, 0];
					if (m$1) {
						const r$2 = m$1.toString(), a$1 = i$1.get("text-letter-spacing").evaluate(s$2, {}, e$1.canonical) * dc, c$2 = Ss(r$2) ? a$1 : 0, d$2 = i$1.get("text-anchor").evaluate(s$2, {}, e$1.canonical), g$2 = md(n$1, s$2, e$1.canonical);
						if (!g$2) {
							const t$1 = i$1.get("text-radial-offset").evaluate(s$2, {}, e$1.canonical);
							x$1 = t$1 ? yd(d$2, [t$1 * dc, dd]) : i$1.get("text-offset").evaluate(s$2, {}, e$1.canonical).map(((t$2) => t$2 * dc));
						}
						let v$2 = l$1 ? "center" : i$1.get("text-justify").evaluate(s$2, {}, e$1.canonical);
						const b$2 = "point" === i$1.get("symbol-placement") ? i$1.get("text-max-width").evaluate(s$2, {}, e$1.canonical) * dc : Infinity, w$1 = () => {
							e$1.bucket.allowVerticalPlacement && _s(r$2) && (y$1.vertical = Xc(m$1, e$1.glyphMap, e$1.glyphPositions, e$1.imagePositions, h$1, b$2, o$1, d$2, "left", c$2, x$1, t.az.vertical, !0, f$1, p$1));
						};
						if (!l$1 && g$2) {
							const r$3 = /* @__PURE__ */ new Set();
							if ("auto" === v$2) for (let t$1 = 0; t$1 < g$2.values.length; t$1 += 2) r$3.add(gd(g$2.values[t$1]));
							else r$3.add(v$2);
							let n$2 = !1;
							for (const i$2 of r$3) if (!y$1.horizontal[i$2]) if (n$2) y$1.horizontal[i$2] = y$1.horizontal[0];
							else {
								const r$4 = Xc(m$1, e$1.glyphMap, e$1.glyphPositions, e$1.imagePositions, h$1, b$2, o$1, "center", i$2, c$2, x$1, t.az.horizontal, !1, f$1, p$1);
								r$4 && (y$1.horizontal[i$2] = r$4, n$2 = 1 === r$4.positionedLines.length);
							}
							w$1();
						} else {
							"auto" === v$2 && (v$2 = gd(d$2));
							const n$2 = Xc(m$1, e$1.glyphMap, e$1.glyphPositions, e$1.imagePositions, h$1, b$2, o$1, d$2, v$2, c$2, x$1, t.az.horizontal, !1, f$1, p$1);
							n$2 && (y$1.horizontal[v$2] = n$2), w$1(), _s(r$2) && l$1 && u$1 && (y$1.vertical = Xc(m$1, e$1.glyphMap, e$1.glyphPositions, e$1.imagePositions, h$1, b$2, o$1, d$2, v$2, c$2, x$1, t.az.vertical, !1, f$1, p$1));
						}
					}
					let v$1 = !1;
					if (s$2.icon && s$2.icon.name) {
						const t$1 = e$1.imageMap[s$2.icon.name];
						t$1 && (g$1 = th(e$1.imagePositions[s$2.icon.name], i$1.get("icon-offset").evaluate(s$2, {}, e$1.canonical), i$1.get("icon-anchor").evaluate(s$2, {}, e$1.canonical)), v$1 = !!t$1.sdf, void 0 === e$1.bucket.sdfIcons ? e$1.bucket.sdfIcons = v$1 : e$1.bucket.sdfIcons !== v$1 && j("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t$1.pixelRatio !== e$1.bucket.pixelRatio || 0 !== i$1.get("icon-rotate").constantOr(1)) && (e$1.bucket.iconsNeedLinear = !0));
					}
					const b$1 = bd(y$1.horizontal) || y$1.vertical;
					(r$1 = e$1.bucket).iconsInText || (r$1.iconsInText = !!b$1 && b$1.iconsInText), (b$1 || g$1) && xd(e$1.bucket, s$2, y$1, g$1, e$1.imageMap, a, f$1, d$1, x$1, v$1, e$1.canonical, e$1.subdivisionGranularity);
				}
				e$1.showCollisionBoxes && e$1.bucket.generateCollisionDebugBuffers();
			}, t.cS = wu, t.cT = Ru, t.cU = tc, t.cV = function(t$1) {
				const e$1 = new Tc();
				return function(t$2, e$2) {
					for (const r$1 in t$2.layers) e$2.writeMessage(3, Pf, t$2.layers[r$1]);
				}(t$1, e$1), e$1.finish();
			}, t.cW = function(t$1, e$1, r$1, n$1, i$1, s$1) {
				let a = jf(t$1, e$1, r$1, i$1, 0);
				return a = jf(a, e$1, n$1, s$1, 1), a;
			}, t.cX = class {
				constructor(t$1) {
					this.maxEntries = t$1, this.map = /* @__PURE__ */ new Map();
				}
				get(t$1) {
					const e$1 = this.map.get(t$1);
					return void 0 !== e$1 && (this.map.delete(t$1), this.map.set(t$1, e$1)), e$1;
				}
				set(t$1, e$1) {
					if (this.map.has(t$1)) this.map.delete(t$1);
					else if (this.map.size >= this.maxEntries) {
						const t$2 = this.map.keys().next().value;
						this.map.delete(t$2);
					}
					this.map.set(t$1, e$1);
				}
				clear() {
					this.map.clear();
				}
			}, t.cY = Vu, t.cZ = Tc, t.c_ = Ff, t.ca = class extends xa {}, t.cb = pc, t.cc = class extends ba {}, t.cd = kl, t.ce = function(t$1) {
				return t$1 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t$1) / Math.LN2));
			}, t.cf = Al, t.cg = function(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2], a = r$1[3] * n$1 + r$1[7] * i$1 + r$1[11] * s$1 + r$1[15];
				return t$1[0] = (r$1[0] * n$1 + r$1[4] * i$1 + r$1[8] * s$1 + r$1[12]) / (a = a || 1), t$1[1] = (r$1[1] * n$1 + r$1[5] * i$1 + r$1[9] * s$1 + r$1[13]) / a, t$1[2] = (r$1[2] * n$1 + r$1[6] * i$1 + r$1[10] * s$1 + r$1[14]) / a, t$1;
			}, t.ch = class extends oa {}, t.ci = class extends Ta {}, t.cj = function(t$1, e$1) {
				return t$1[0] === e$1[0] && t$1[1] === e$1[1] && t$1[2] === e$1[2] && t$1[3] === e$1[3] && t$1[4] === e$1[4] && t$1[5] === e$1[5] && t$1[6] === e$1[6] && t$1[7] === e$1[7] && t$1[8] === e$1[8] && t$1[9] === e$1[9] && t$1[10] === e$1[10] && t$1[11] === e$1[11] && t$1[12] === e$1[12] && t$1[13] === e$1[13] && t$1[14] === e$1[14] && t$1[15] === e$1[15];
			}, t.ck = function(t$1, e$1) {
				var r$1 = t$1[0], n$1 = t$1[1], i$1 = t$1[2], s$1 = t$1[3], a = t$1[4], o$1 = t$1[5], l$1 = t$1[6], u$1 = t$1[7], c$1 = t$1[8], h$1 = t$1[9], f$1 = t$1[10], d$1 = t$1[11], y$1 = t$1[12], m$1 = t$1[13], g$1 = t$1[14], x$1 = t$1[15], v$1 = e$1[0], b$1 = e$1[1], w$1 = e$1[2], _$1 = e$1[3], S$1 = e$1[4], A$1 = e$1[5], k$1 = e$1[6], E$1 = e$1[7], T$1 = e$1[8], I$1 = e$1[9], M$1 = e$1[10], F$1 = e$1[11], D$1 = e$1[12], z$1 = e$1[13], P$1 = e$1[14], B$1 = e$1[15];
				return Math.abs(r$1 - v$1) <= p * Math.max(1, Math.abs(r$1), Math.abs(v$1)) && Math.abs(n$1 - b$1) <= p * Math.max(1, Math.abs(n$1), Math.abs(b$1)) && Math.abs(i$1 - w$1) <= p * Math.max(1, Math.abs(i$1), Math.abs(w$1)) && Math.abs(s$1 - _$1) <= p * Math.max(1, Math.abs(s$1), Math.abs(_$1)) && Math.abs(a - S$1) <= p * Math.max(1, Math.abs(a), Math.abs(S$1)) && Math.abs(o$1 - A$1) <= p * Math.max(1, Math.abs(o$1), Math.abs(A$1)) && Math.abs(l$1 - k$1) <= p * Math.max(1, Math.abs(l$1), Math.abs(k$1)) && Math.abs(u$1 - E$1) <= p * Math.max(1, Math.abs(u$1), Math.abs(E$1)) && Math.abs(c$1 - T$1) <= p * Math.max(1, Math.abs(c$1), Math.abs(T$1)) && Math.abs(h$1 - I$1) <= p * Math.max(1, Math.abs(h$1), Math.abs(I$1)) && Math.abs(f$1 - M$1) <= p * Math.max(1, Math.abs(f$1), Math.abs(M$1)) && Math.abs(d$1 - F$1) <= p * Math.max(1, Math.abs(d$1), Math.abs(F$1)) && Math.abs(y$1 - D$1) <= p * Math.max(1, Math.abs(y$1), Math.abs(D$1)) && Math.abs(m$1 - z$1) <= p * Math.max(1, Math.abs(m$1), Math.abs(z$1)) && Math.abs(g$1 - P$1) <= p * Math.max(1, Math.abs(g$1), Math.abs(P$1)) && Math.abs(x$1 - B$1) <= p * Math.max(1, Math.abs(x$1), Math.abs(B$1));
			}, t.cl = function(t$1, e$1) {
				return t$1[0] = e$1[0], t$1[1] = e$1[1], t$1[2] = e$1[2], t$1[3] = e$1[3], t$1[4] = e$1[4], t$1[5] = e$1[5], t$1[6] = e$1[6], t$1[7] = e$1[7], t$1[8] = e$1[8], t$1[9] = e$1[9], t$1[10] = e$1[10], t$1[11] = e$1[11], t$1[12] = e$1[12], t$1[13] = e$1[13], t$1[14] = e$1[14], t$1[15] = e$1[15], t$1;
			}, t.cm = (t$1) => "symbol" === t$1.type, t.cn = (t$1) => "circle" === t$1.type, t.co = (t$1) => "heatmap" === t$1.type, t.cp = (t$1) => "line" === t$1.type, t.cq = (t$1) => "fill" === t$1.type, t.cr = (t$1) => "fill-extrusion" === t$1.type, t.cs = (t$1) => "hillshade" === t$1.type, t.ct = (t$1) => "color-relief" === t$1.type, t.cu = (t$1) => "background" === t$1.type, t.cv = (t$1) => "custom" === t$1.type, t.cw = B, t.cx = function(t$1, e$1, r$1) {
				if (e$1 <= 0) return t$1;
				const n$1 = 1 / e$1;
				return void 0 === r$1 || Math.abs(r$1) < 1e-10 ? Math.round(t$1 * n$1) / n$1 : (r$1 > 0 ? Math.ceil(t$1 * n$1 - 1e-9) : Math.floor(t$1 * n$1 + 1e-10)) / n$1;
			}, t.cy = function(t$1, e$1, r$1) {
				const n$1 = I(e$1.x - r$1.x, e$1.y - r$1.y), i$1 = I(t$1.x - r$1.x, t$1.y - r$1.y);
				var s$1, a;
				return et(Math.atan2(n$1[0] * i$1[1] - n$1[1] * i$1[0], (s$1 = n$1)[0] * (a = i$1)[0] + s$1[1] * a[1]));
			}, t.cz = V, t.d = ft, t.d0 = function(t$1, r$1, n$1, i$1, s$1) {
				return e(this, void 0, void 0, (function* () {
					if (h()) try {
						return yield K(t$1, r$1, n$1, i$1, s$1);
					} catch (t$2) {}
					return function(t$2, e$1, r$2, n$2, i$2) {
						const s$2 = t$2.width, a = t$2.height;
						W && J || (W = new OffscreenCanvas(s$2, a), J = W.getContext("2d", { willReadFrequently: !0 })), W.width = s$2, W.height = a, J.drawImage(t$2, 0, 0, s$2, a);
						const o$1 = J.getImageData(e$1, r$2, n$2, i$2);
						return J.clearRect(0, 0, s$2, a), o$1.data;
					}(t$1, r$1, n$1, i$1, s$1);
				}));
			}, t.d1 = Pl, t.d2 = n, t.d3 = class {
				constructor(t$1, e$1) {
					this.layers = { [zf]: this }, this.name = zf, this.version = e$1 ? e$1.version : 1, this.extent = e$1 ? e$1.extent : 4096, this.length = t$1.length, this.features = t$1;
				}
				feature(t$1) {
					return new Df(this.features[t$1], this.extent);
				}
			}, t.d4 = ni, t.d5 = zs, t.e = O, t.f = (t$1) => e(void 0, void 0, void 0, (function* () {
				if (0 === t$1.byteLength) return createImageBitmap(new ImageData(1, 1));
				const e$1 = new Blob([new Uint8Array(t$1)], { type: "image/png" });
				try {
					return createImageBitmap(e$1);
				} catch (t$2) {
					throw new Error(`Could not load image because of ${t$2.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
				}
			})), t.g = lt, t.h = (t$1) => new Promise(((e$1, r$1) => {
				const n$1 = new Image();
				n$1.onload = () => {
					e$1(n$1), URL.revokeObjectURL(n$1.src), n$1.onload = null, window.requestAnimationFrame((() => {
						n$1.src = H;
					}));
				}, n$1.onerror = () => r$1(/* @__PURE__ */ new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
				const i$1 = new Blob([new Uint8Array(t$1)], { type: "image/png" });
				n$1.src = t$1.byteLength ? URL.createObjectURL(i$1) : H;
			})), t.i = X, t.j = (t$1, e$1) => pt(O(t$1, { type: "json" }), e$1), t.k = gt, t.l = mt, t.m = pt, t.n = (t$1, e$1) => pt(O(t$1, { type: "arrayBuffer" }), e$1), t.o = function(t$1) {
				return new Tc(t$1).readFields(Rc, []);
			}, t.p = Uc, t.q = function(t$1) {
				return /[\u02EA\u02EB\u1100-\u11FF\u2E80-\u2FDF\u3000-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFE10-\uFE1F\uFE30-\uFE4F\uFF00-\uFFEF]|\uD81B[\uDFE0-\uDFFF]|[\uD81C-\uD822\uD840-\uD868\uD86A-\uD86D\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD88C][\uDC00-\uDFFF]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD1E\uDD80-\uDDF2]|\uD82B[\uDFF0-\uDFFF]|\uD82C[\uDC00-\uDEFB]|\uD83C[\uDE00-\uDEFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEAD\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD88D[\uDC00-\uDC79]/gim.test(String.fromCodePoint(t$1));
			}, t.r = _l, t.s = Q, t.t = Hs, t.u = vt, t.v = ns, t.w = j, t.x = Os, t.y = ss, t.z = Vs;
		}));
		define$1("worker", ["./shared"], (function(e) {
			class t {
				constructor(e$1, t$1) {
					this.keyCache = {}, e$1 && this.replace(e$1, t$1);
				}
				replace(e$1, t$1) {
					this._layerConfigs = {}, this._layers = {}, this.update(e$1, [], t$1);
				}
				update(t$1, o$1, s$1) {
					for (const o$2 of t$1) {
						this._layerConfigs[o$2.id] = o$2;
						const t$2 = this._layers[o$2.id] = e.bT(o$2, s$1);
						t$2._featureFilter = e.aj(t$2.filter, s$1), this.keyCache[o$2.id] && delete this.keyCache[o$2.id];
					}
					for (const e$1 of o$1) delete this.keyCache[e$1], delete this._layerConfigs[e$1], delete this._layers[e$1];
					this.familiesBySource = {};
					const i$1 = e.cM(Object.values(this._layerConfigs), this.keyCache);
					for (const t$2 of i$1) {
						const o$2 = t$2.map(((e$1) => this._layers[e$1.id])), s$2 = o$2[0];
						if (s$2.isHidden()) continue;
						const i$2 = s$2.source || "";
						let n$1 = this.familiesBySource[i$2];
						n$1 || (n$1 = this.familiesBySource[i$2] = {});
						const r$1 = s$2.sourceLayer || e.ai;
						let a$1 = n$1[r$1];
						a$1 || (a$1 = n$1[r$1] = []), a$1.push(o$2);
					}
				}
			}
			class o {
				constructor(t$1) {
					const o$1 = {}, s$1 = [];
					for (const e$1 in t$1) {
						const i$2 = t$1[e$1], n$2 = o$1[e$1] = {};
						for (const e$2 in i$2) {
							const t$2 = i$2[+e$2];
							if (!t$2 || 0 === t$2.bitmap.width || 0 === t$2.bitmap.height) continue;
							const o$2 = {
								x: 0,
								y: 0,
								w: t$2.bitmap.width + 2,
								h: t$2.bitmap.height + 2
							};
							s$1.push(o$2), n$2[e$2] = {
								rect: o$2,
								metrics: t$2.metrics
							};
						}
					}
					const { w: i$1, h: n$1 } = e.p(s$1), r$1 = new e.r({
						width: i$1 || 1,
						height: n$1 || 1
					});
					for (const s$2 in t$1) {
						const i$2 = t$1[s$2];
						for (const t$2 in i$2) {
							const n$2 = i$2[+t$2];
							if (!n$2 || 0 === n$2.bitmap.width || 0 === n$2.bitmap.height) continue;
							const a$1 = o$1[s$2][t$2].rect;
							e.r.copy(n$2.bitmap, r$1, {
								x: 0,
								y: 0
							}, {
								x: a$1.x + 1,
								y: a$1.y + 1
							}, n$2.bitmap);
						}
					}
					this.image = r$1, this.positions = o$1;
				}
			}
			e.cN("GlyphAtlas", o);
			class s {
				constructor(t$1) {
					this.tileID = new e.a2(t$1.tileID.overscaledZ, t$1.tileID.wrap, t$1.tileID.canonical.z, t$1.tileID.canonical.x, t$1.tileID.canonical.y), this.uid = t$1.uid, this.zoom = t$1.zoom, this.pixelRatio = t$1.pixelRatio, this.tileSize = t$1.tileSize, this.source = t$1.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t$1.showCollisionBoxes, this.collectResourceTiming = !!t$1.collectResourceTiming, this.returnDependencies = !!t$1.returnDependencies, this.promoteId = t$1.promoteId, this.inFlightDependencies = [];
				}
				parse(t$1, s$1, n$1, r$1, a$1) {
					return e._(this, void 0, void 0, (function* () {
						this.status = "parsing", this.data = t$1, this.collisionBoxArray = new e.ag();
						const c$1 = new e.cO(Object.keys(t$1.layers).sort()), l$1 = new e.cP(this.tileID, this.promoteId);
						l$1.bucketLayerIDs = [];
						const h$1 = {}, u$1 = {
							featureIndex: l$1,
							iconDependencies: {},
							patternDependencies: {},
							glyphDependencies: {},
							dashDependencies: {},
							availableImages: n$1,
							subdivisionGranularity: a$1
						}, d$1 = s$1.familiesBySource[this.source];
						for (const o$1 in d$1) {
							const s$2 = t$1.layers[o$1];
							if (!s$2) continue;
							1 === s$2.version && e.w(`Vector tile source "${this.source}" layer "${o$1}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
							const r$2 = c$1.encode(o$1), a$2 = [];
							for (let e$1 = 0; e$1 < s$2.length; e$1++) {
								const t$2 = s$2.feature(e$1), i$1 = l$1.getId(t$2, o$1);
								a$2.push({
									feature: t$2,
									id: i$1,
									index: e$1,
									sourceLayerIndex: r$2
								});
							}
							for (const t$2 of d$1[o$1]) {
								const o$2 = t$2[0];
								o$2.source !== this.source && e.w(`layer.source = ${o$2.source} does not equal this.source = ${this.source}`), o$2.isHidden(this.zoom, !0) || (i(t$2, this.zoom, n$1), (h$1[o$2.id] = o$2.createBucket({
									index: l$1.bucketLayerIDs.length,
									layers: t$2,
									zoom: this.zoom,
									pixelRatio: this.pixelRatio,
									overscaling: this.overscaling,
									collisionBoxArray: this.collisionBoxArray,
									sourceLayerIndex: r$2,
									sourceID: this.source
								})).populate(a$2, u$1, this.tileID.canonical), l$1.bucketLayerIDs.push(t$2.map(((e$1) => e$1.id))));
							}
						}
						const g$1 = e.bY(u$1.glyphDependencies, ((e$1) => Object.keys(e$1).map(Number)));
						this.inFlightDependencies.forEach(((e$1) => null == e$1 ? void 0 : e$1.abort())), this.inFlightDependencies = [];
						let p$1 = Promise.resolve({});
						if (Object.keys(g$1).length) {
							const e$1 = new AbortController();
							this.inFlightDependencies.push(e$1), p$1 = r$1.sendAsync({
								type: "GG",
								data: {
									stacks: g$1,
									source: this.source,
									tileID: this.tileID,
									type: "glyphs"
								}
							}, e$1);
						}
						const f$1 = Object.keys(u$1.iconDependencies);
						let m$1 = Promise.resolve({});
						if (f$1.length) {
							const e$1 = new AbortController();
							this.inFlightDependencies.push(e$1), m$1 = r$1.sendAsync({
								type: "GI",
								data: {
									icons: f$1,
									source: this.source,
									tileID: this.tileID,
									type: "icons"
								}
							}, e$1);
						}
						const y$1 = Object.keys(u$1.patternDependencies);
						let v$1 = Promise.resolve({});
						if (y$1.length) {
							const e$1 = new AbortController();
							this.inFlightDependencies.push(e$1), v$1 = r$1.sendAsync({
								type: "GI",
								data: {
									icons: y$1,
									source: this.source,
									tileID: this.tileID,
									type: "patterns"
								}
							}, e$1);
						}
						const x$1 = u$1.dashDependencies;
						let w$1 = Promise.resolve({});
						if (Object.keys(x$1).length) {
							const e$1 = new AbortController();
							this.inFlightDependencies.push(e$1), w$1 = r$1.sendAsync({
								type: "GDA",
								data: { dashes: x$1 }
							}, e$1);
						}
						const [_$1, b$1, S$1, M$1] = yield Promise.all([
							p$1,
							m$1,
							v$1,
							w$1
						]), I$1 = new o(_$1), P$1 = new e.cQ(b$1, S$1);
						for (const t$2 in h$1) {
							const o$1 = h$1[t$2];
							o$1 instanceof e.ah ? (i(o$1.layers, this.zoom, n$1), e.cR({
								bucket: o$1,
								glyphMap: _$1,
								glyphPositions: I$1.positions,
								imageMap: b$1,
								imagePositions: P$1.iconPositions,
								showCollisionBoxes: this.showCollisionBoxes,
								canonical: this.tileID.canonical,
								subdivisionGranularity: u$1.subdivisionGranularity
							})) : o$1.hasDependencies && (o$1 instanceof e.cS || o$1 instanceof e.cT || o$1 instanceof e.cU) && (i(o$1.layers, this.zoom, n$1), o$1.addFeatures(u$1, this.tileID.canonical, P$1.patternPositions, M$1));
						}
						return this.status = "done", {
							buckets: Object.values(h$1).filter(((e$1) => !e$1.isEmpty())),
							featureIndex: l$1,
							collisionBoxArray: this.collisionBoxArray,
							glyphAtlasImage: I$1.image,
							imageAtlas: P$1,
							dashPositions: M$1,
							glyphMap: this.returnDependencies ? _$1 : null,
							iconMap: this.returnDependencies ? b$1 : null,
							glyphPositions: this.returnDependencies ? I$1.positions : null
						};
					}));
				}
			}
			function i(t$1, o$1, s$1) {
				const i$1 = new e.H(o$1);
				for (const e$1 of t$1) e$1.recalculate(i$1, s$1);
			}
			class n {
				constructor(e$1, t$1, o$1, s$1, i$1) {
					this.type = e$1, this.properties = o$1 || {}, this.extent = i$1, this.pointsArray = t$1, this.id = s$1;
				}
				loadGeometry() {
					return this.pointsArray.map(((t$1) => t$1.map(((t$2) => new e.P(t$2.x, t$2.y)))));
				}
			}
			class r {
				constructor(e$1, t$1, o$1) {
					this.version = 2, this._myFeatures = e$1, this.name = t$1, this.length = e$1.length, this.extent = o$1;
				}
				feature(e$1) {
					return this._myFeatures[e$1];
				}
			}
			class a {
				constructor() {
					this.layers = {};
				}
				addLayer(e$1) {
					this.layers[e$1.name] = e$1;
				}
			}
			function c(t$1) {
				let o$1 = e.cV(t$1);
				return 0 === o$1.byteOffset && o$1.byteLength === o$1.buffer.byteLength || (o$1 = new Uint8Array(o$1)), {
					vectorTile: t$1,
					rawData: o$1.buffer
				};
			}
			function l(t$1, o$1, s$1) {
				const { extent: i$1 } = t$1, a$1 = Math.pow(2, s$1.z - o$1.z), c$1 = (s$1.x - o$1.x * a$1) * i$1, l$1 = (s$1.y - o$1.y * a$1) * i$1, h$1 = [];
				for (let o$2 = 0; o$2 < t$1.length; o$2++) {
					const s$2 = t$1.feature(o$2);
					let r$1 = s$2.loadGeometry();
					for (const e$1 of r$1) for (const t$2 of e$1) t$2.x = t$2.x * a$1 - c$1, t$2.y = t$2.y * a$1 - l$1;
					const u$1 = 128;
					r$1 = e.cW(r$1, s$2.type, -u$1, -u$1, i$1 + u$1, i$1 + u$1), 0 !== r$1.length && h$1.push(new n(s$2.type, r$1, s$2.properties, s$2.id, i$1));
				}
				return new r(h$1, t$1.name, i$1);
			}
			class h {
				constructor(t$1, o$1, s$1) {
					this.actor = t$1, this.layerIndex = o$1, this.availableImages = s$1, this.fetching = {}, this.loading = {}, this.loaded = {}, this.overzoomedTileResultCache = new e.cX(1e3);
				}
				loadVectorTile(t$1, o$1) {
					return e._(this, void 0, void 0, (function* () {
						const s$1 = yield e.n(t$1.request, o$1);
						try {
							return {
								vectorTile: "mlt" !== t$1.encoding ? new e.cY(new e.cZ(s$1.data)) : new e.c_(s$1.data),
								rawData: s$1.data,
								cacheControl: s$1.cacheControl,
								expires: s$1.expires
							};
						} catch (e$1) {
							const o$2 = new Uint8Array(s$1.data);
							let i$1 = `Unable to parse the tile at ${t$1.request.url}, `;
							throw i$1 += 31 === o$2[0] && 139 === o$2[1] ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${e$1.message}`, new Error(i$1);
						}
					}));
				}
				loadTile(t$1) {
					return e._(this, void 0, void 0, (function* () {
						const { uid: o$1, overzoomParameters: i$1 } = t$1;
						i$1 && (t$1.request = i$1.overzoomRequest);
						const n$1 = !!(t$1 && t$1.request && t$1.request.collectResourceTiming) && new e.c$(t$1.request), r$1 = new s(t$1);
						this.loading[o$1] = r$1;
						const a$1 = new AbortController();
						r$1.abort = a$1;
						try {
							const s$1 = yield this.loadVectorTile(t$1, a$1);
							if (delete this.loading[o$1], !s$1) return null;
							if (i$1) {
								const e$1 = this._getOverzoomTile(t$1, s$1.vectorTile);
								s$1.rawData = e$1.rawData, s$1.vectorTile = e$1.vectorTile;
							}
							const c$1 = s$1.rawData, l$1 = {};
							s$1.expires && (l$1.expires = s$1.expires), s$1.cacheControl && (l$1.cacheControl = s$1.cacheControl);
							const h$1 = {};
							if (n$1) {
								const e$1 = n$1.finish();
								e$1 && (h$1.resourceTiming = JSON.parse(JSON.stringify(e$1)));
							}
							r$1.vectorTile = s$1.vectorTile;
							const u$1 = r$1.parse(s$1.vectorTile, this.layerIndex, this.availableImages, this.actor, t$1.subdivisionGranularity);
							this.loaded[o$1] = r$1, this.fetching[o$1] = {
								rawTileData: c$1,
								cacheControl: l$1,
								resourceTiming: h$1
							};
							try {
								const o$2 = yield u$1;
								return e.e({
									rawTileData: c$1.slice(0),
									encoding: t$1.encoding
								}, o$2, l$1, h$1);
							} finally {
								delete this.fetching[o$1];
							}
						} catch (e$1) {
							throw delete this.loading[o$1], r$1.status = "done", this.loaded[o$1] = r$1, e$1;
						}
					}));
				}
				_getOverzoomTile(e$1, t$1) {
					const { tileID: o$1, source: s$1, overzoomParameters: i$1 } = e$1, { maxZoomTileID: n$1 } = i$1, r$1 = `${n$1.key}_${o$1.key}`, h$1 = this.overzoomedTileResultCache.get(r$1);
					if (h$1) return h$1;
					const u$1 = new a(), d$1 = this.layerIndex.familiesBySource[s$1];
					for (const e$2 in d$1) {
						const s$2 = t$1.layers[e$2];
						if (!s$2) continue;
						const i$2 = l(s$2, n$1, o$1.canonical);
						i$2.length > 0 && u$1.addLayer(i$2);
					}
					const g$1 = c(u$1);
					return this.overzoomedTileResultCache.set(r$1, g$1), g$1;
				}
				reloadTile(t$1) {
					return e._(this, void 0, void 0, (function* () {
						const o$1 = t$1.uid;
						if (!this.loaded || !this.loaded[o$1]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
						const s$1 = this.loaded[o$1];
						if (s$1.showCollisionBoxes = t$1.showCollisionBoxes, "parsing" === s$1.status) {
							const i$1 = yield s$1.parse(s$1.vectorTile, this.layerIndex, this.availableImages, this.actor, t$1.subdivisionGranularity);
							let n$1;
							if (this.fetching[o$1]) {
								const { rawTileData: s$2, cacheControl: r$1, resourceTiming: a$1 } = this.fetching[o$1];
								delete this.fetching[o$1], n$1 = e.e({
									rawTileData: s$2.slice(0),
									encoding: t$1.encoding
								}, i$1, r$1, a$1);
							} else n$1 = i$1;
							return n$1;
						}
						if ("done" === s$1.status && s$1.vectorTile) return s$1.parse(s$1.vectorTile, this.layerIndex, this.availableImages, this.actor, t$1.subdivisionGranularity);
					}));
				}
				abortTile(t$1) {
					return e._(this, void 0, void 0, (function* () {
						const e$1 = this.loading, o$1 = t$1.uid;
						e$1 && e$1[o$1] && e$1[o$1].abort && (e$1[o$1].abort.abort(), delete e$1[o$1]);
					}));
				}
				removeTile(t$1) {
					return e._(this, void 0, void 0, (function* () {
						this.loaded && this.loaded[t$1.uid] && delete this.loaded[t$1.uid];
					}));
				}
			}
			class u {
				constructor() {
					this.loaded = {};
				}
				loadTile(t$1) {
					return e._(this, void 0, void 0, (function* () {
						const { uid: o$1, encoding: s$1, rawImageData: i$1, redFactor: n$1, greenFactor: r$1, blueFactor: a$1, baseShift: c$1 } = t$1, l$1 = i$1.width + 2, h$1 = i$1.height + 2, u$1 = e.b(i$1) ? new e.R({
							width: l$1,
							height: h$1
						}, yield e.d0(i$1, -1, -1, l$1, h$1)) : i$1, d$1 = new e.d1(o$1, u$1, s$1, n$1, r$1, a$1, c$1);
						return this.loaded = this.loaded || {}, this.loaded[o$1] = d$1, d$1;
					}));
				}
				removeTile(e$1) {
					const t$1 = this.loaded, o$1 = e$1.uid;
					t$1 && t$1[o$1] && delete t$1[o$1];
				}
			}
			var d, g, p = function() {
				if (g) return d;
				function e$1(e$2, o$1) {
					if (0 !== e$2.length) {
						t$1(e$2[0], o$1);
						for (var s$1 = 1; s$1 < e$2.length; s$1++) t$1(e$2[s$1], !o$1);
					}
				}
				function t$1(e$2, t$2) {
					for (var o$1 = 0, s$1 = 0, i$1 = 0, n$1 = e$2.length, r$1 = n$1 - 1; i$1 < n$1; r$1 = i$1++) {
						var a$1 = (e$2[i$1][0] - e$2[r$1][0]) * (e$2[r$1][1] + e$2[i$1][1]), c$1 = o$1 + a$1;
						s$1 += Math.abs(o$1) >= Math.abs(a$1) ? o$1 - c$1 + a$1 : a$1 - c$1 + o$1, o$1 = c$1;
					}
					o$1 + s$1 >= 0 != !!t$2 && e$2.reverse();
				}
				return g = 1, d = function t$2(o$1, s$1) {
					var i$1, n$1 = o$1 && o$1.type;
					if ("FeatureCollection" === n$1) for (i$1 = 0; i$1 < o$1.features.length; i$1++) t$2(o$1.features[i$1], s$1);
					else if ("GeometryCollection" === n$1) for (i$1 = 0; i$1 < o$1.geometries.length; i$1++) t$2(o$1.geometries[i$1], s$1);
					else if ("Feature" === n$1) t$2(o$1.geometry, s$1);
					else if ("Polygon" === n$1) e$1(o$1.coordinates, s$1);
					else if ("MultiPolygon" === n$1) for (i$1 = 0; i$1 < o$1.coordinates.length; i$1++) e$1(o$1.coordinates[i$1], s$1);
					return o$1;
				};
			}(), f = e.d2(p);
			const m = {
				minZoom: 0,
				maxZoom: 16,
				minPoints: 2,
				radius: 40,
				extent: 512,
				nodeSize: 64,
				log: !1,
				generateId: !1,
				reduce: null,
				map: (e$1) => e$1
			}, y = Math.fround || (v = new Float32Array(1), (e$1) => (v[0] = +e$1, v[0]));
			var v;
			class x {
				constructor(e$1) {
					this.options = Object.assign(Object.create(m), e$1), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
				}
				load(e$1) {
					const { log: t$1, minZoom: o$1, maxZoom: s$1 } = this.options;
					t$1 && console.time("total time");
					const i$1 = `prepare ${e$1.length} points`;
					t$1 && console.time(i$1), this.points = e$1;
					const n$1 = [];
					for (let t$2 = 0; t$2 < e$1.length; t$2++) {
						const o$2 = e$1[t$2];
						if (!o$2.geometry) continue;
						const [s$2, i$2] = o$2.geometry.coordinates, r$2 = y(b(s$2)), a$1 = y(S(i$2));
						n$1.push(r$2, a$1, Infinity, t$2, -1, 1), this.options.reduce && n$1.push(0);
					}
					let r$1 = this.trees[s$1 + 1] = this._createTree(n$1);
					t$1 && console.timeEnd(i$1);
					for (let e$2 = s$1; e$2 >= o$1; e$2--) {
						const o$2 = +Date.now();
						r$1 = this.trees[e$2] = this._createTree(this._cluster(r$1, e$2)), t$1 && console.log("z%d: %d clusters in %dms", e$2, r$1.numItems, +Date.now() - o$2);
					}
					return t$1 && console.timeEnd("total time"), this;
				}
				getClusters(e$1, t$1) {
					let o$1 = ((e$1[0] + 180) % 360 + 360) % 360 - 180;
					const s$1 = Math.max(-90, Math.min(90, e$1[1]));
					let i$1 = 180 === e$1[2] ? 180 : ((e$1[2] + 180) % 360 + 360) % 360 - 180;
					const n$1 = Math.max(-90, Math.min(90, e$1[3]));
					if (e$1[2] - e$1[0] >= 360) o$1 = -180, i$1 = 180;
					else if (o$1 > i$1) {
						const e$2 = this.getClusters([
							o$1,
							s$1,
							180,
							n$1
						], t$1), r$2 = this.getClusters([
							-180,
							s$1,
							i$1,
							n$1
						], t$1);
						return e$2.concat(r$2);
					}
					const r$1 = this.trees[this._limitZoom(t$1)], a$1 = r$1.range(b(o$1), S(n$1), b(i$1), S(s$1)), c$1 = r$1.data, l$1 = [];
					for (const e$2 of a$1) {
						const t$2 = this.stride * e$2;
						l$1.push(c$1[t$2 + 5] > 1 ? w(c$1, t$2, this.clusterProps) : this.points[c$1[t$2 + 3]]);
					}
					return l$1;
				}
				getChildren(e$1) {
					const t$1 = this._getOriginId(e$1), o$1 = this._getOriginZoom(e$1), s$1 = "No cluster with the specified id.", i$1 = this.trees[o$1];
					if (!i$1) throw new Error(s$1);
					const n$1 = i$1.data;
					if (t$1 * this.stride >= n$1.length) throw new Error(s$1);
					const r$1 = this.options.radius / (this.options.extent * Math.pow(2, o$1 - 1)), a$1 = i$1.within(n$1[t$1 * this.stride], n$1[t$1 * this.stride + 1], r$1), c$1 = [];
					for (const t$2 of a$1) {
						const o$2 = t$2 * this.stride;
						n$1[o$2 + 4] === e$1 && c$1.push(n$1[o$2 + 5] > 1 ? w(n$1, o$2, this.clusterProps) : this.points[n$1[o$2 + 3]]);
					}
					if (0 === c$1.length) throw new Error(s$1);
					return c$1;
				}
				getLeaves(e$1, t$1, o$1) {
					const s$1 = [];
					return this._appendLeaves(s$1, e$1, t$1 = t$1 || 10, o$1 = o$1 || 0, 0), s$1;
				}
				getTile(e$1, t$1, o$1) {
					const s$1 = this.trees[this._limitZoom(e$1)], i$1 = Math.pow(2, e$1), { extent: n$1, radius: r$1 } = this.options, a$1 = r$1 / n$1, c$1 = (o$1 - a$1) / i$1, l$1 = (o$1 + 1 + a$1) / i$1, h$1 = { features: [] };
					return this._addTileFeatures(s$1.range((t$1 - a$1) / i$1, c$1, (t$1 + 1 + a$1) / i$1, l$1), s$1.data, t$1, o$1, i$1, h$1), 0 === t$1 && this._addTileFeatures(s$1.range(1 - a$1 / i$1, c$1, 1, l$1), s$1.data, i$1, o$1, i$1, h$1), t$1 === i$1 - 1 && this._addTileFeatures(s$1.range(0, c$1, a$1 / i$1, l$1), s$1.data, -1, o$1, i$1, h$1), h$1.features.length ? h$1 : null;
				}
				getClusterExpansionZoom(e$1) {
					let t$1 = this._getOriginZoom(e$1) - 1;
					for (; t$1 <= this.options.maxZoom;) {
						const o$1 = this.getChildren(e$1);
						if (t$1++, 1 !== o$1.length) break;
						e$1 = o$1[0].properties.cluster_id;
					}
					return t$1;
				}
				_appendLeaves(e$1, t$1, o$1, s$1, i$1) {
					const n$1 = this.getChildren(t$1);
					for (const t$2 of n$1) {
						const n$2 = t$2.properties;
						if (n$2 && n$2.cluster ? i$1 + n$2.point_count <= s$1 ? i$1 += n$2.point_count : i$1 = this._appendLeaves(e$1, n$2.cluster_id, o$1, s$1, i$1) : i$1 < s$1 ? i$1++ : e$1.push(t$2), e$1.length === o$1) break;
					}
					return i$1;
				}
				_createTree(t$1) {
					const o$1 = new e.aT(t$1.length / this.stride | 0, this.options.nodeSize, Float32Array);
					for (let e$1 = 0; e$1 < t$1.length; e$1 += this.stride) o$1.add(t$1[e$1], t$1[e$1 + 1]);
					return o$1.finish(), o$1.data = t$1, o$1;
				}
				_addTileFeatures(e$1, t$1, o$1, s$1, i$1, n$1) {
					for (const r$1 of e$1) {
						const e$2 = r$1 * this.stride, a$1 = t$1[e$2 + 5] > 1;
						let c$1, l$1, h$1;
						if (a$1) c$1 = _(t$1, e$2, this.clusterProps), l$1 = t$1[e$2], h$1 = t$1[e$2 + 1];
						else {
							const o$2 = this.points[t$1[e$2 + 3]];
							c$1 = o$2.properties;
							const [s$2, i$2] = o$2.geometry.coordinates;
							l$1 = b(s$2), h$1 = S(i$2);
						}
						const u$1 = {
							type: 1,
							geometry: [[Math.round(this.options.extent * (l$1 * i$1 - o$1)), Math.round(this.options.extent * (h$1 * i$1 - s$1))]],
							tags: c$1
						};
						let d$1;
						d$1 = a$1 || this.options.generateId ? t$1[e$2 + 3] : this.points[t$1[e$2 + 3]].id, void 0 !== d$1 && (u$1.id = d$1), n$1.features.push(u$1);
					}
				}
				_limitZoom(e$1) {
					return Math.max(this.options.minZoom, Math.min(Math.floor(+e$1), this.options.maxZoom + 1));
				}
				_cluster(e$1, t$1) {
					const { radius: o$1, extent: s$1, reduce: i$1, minPoints: n$1 } = this.options, r$1 = o$1 / (s$1 * Math.pow(2, t$1)), a$1 = e$1.data, c$1 = [], l$1 = this.stride;
					for (let o$2 = 0; o$2 < a$1.length; o$2 += l$1) {
						if (a$1[o$2 + 2] <= t$1) continue;
						a$1[o$2 + 2] = t$1;
						const s$2 = a$1[o$2], h$1 = a$1[o$2 + 1], u$1 = e$1.within(a$1[o$2], a$1[o$2 + 1], r$1), d$1 = a$1[o$2 + 5];
						let g$1 = d$1;
						for (const e$2 of u$1) {
							const o$3 = e$2 * l$1;
							a$1[o$3 + 2] > t$1 && (g$1 += a$1[o$3 + 5]);
						}
						if (g$1 > d$1 && g$1 >= n$1) {
							let e$2, n$2 = s$2 * d$1, r$2 = h$1 * d$1, p$1 = -1;
							const f$1 = (o$2 / l$1 << 5) + (t$1 + 1) + this.points.length;
							for (const s$3 of u$1) {
								const c$2 = s$3 * l$1;
								if (a$1[c$2 + 2] <= t$1) continue;
								a$1[c$2 + 2] = t$1;
								const h$2 = a$1[c$2 + 5];
								n$2 += a$1[c$2] * h$2, r$2 += a$1[c$2 + 1] * h$2, a$1[c$2 + 4] = f$1, i$1 && (e$2 || (e$2 = this._map(a$1, o$2, !0), p$1 = this.clusterProps.length, this.clusterProps.push(e$2)), i$1(e$2, this._map(a$1, c$2)));
							}
							a$1[o$2 + 4] = f$1, c$1.push(n$2 / g$1, r$2 / g$1, Infinity, f$1, -1, g$1), i$1 && c$1.push(p$1);
						} else {
							for (let e$2 = 0; e$2 < l$1; e$2++) c$1.push(a$1[o$2 + e$2]);
							if (g$1 > 1) for (const e$2 of u$1) {
								const o$3 = e$2 * l$1;
								if (!(a$1[o$3 + 2] <= t$1)) {
									a$1[o$3 + 2] = t$1;
									for (let e$3 = 0; e$3 < l$1; e$3++) c$1.push(a$1[o$3 + e$3]);
								}
							}
						}
					}
					return c$1;
				}
				_getOriginId(e$1) {
					return e$1 - this.points.length >> 5;
				}
				_getOriginZoom(e$1) {
					return (e$1 - this.points.length) % 32;
				}
				_map(e$1, t$1, o$1) {
					if (e$1[t$1 + 5] > 1) {
						const s$2 = this.clusterProps[e$1[t$1 + 6]];
						return o$1 ? Object.assign({}, s$2) : s$2;
					}
					const s$1 = this.points[e$1[t$1 + 3]].properties, i$1 = this.options.map(s$1);
					return o$1 && i$1 === s$1 ? Object.assign({}, i$1) : i$1;
				}
			}
			function w(e$1, t$1, o$1) {
				return {
					type: "Feature",
					id: e$1[t$1 + 3],
					properties: _(e$1, t$1, o$1),
					geometry: {
						type: "Point",
						coordinates: [(s$1 = e$1[t$1], 360 * (s$1 - .5)), M(e$1[t$1 + 1])]
					}
				};
				var s$1;
			}
			function _(e$1, t$1, o$1) {
				const s$1 = e$1[t$1 + 5], i$1 = s$1 >= 1e4 ? `${Math.round(s$1 / 1e3)}k` : s$1 >= 1e3 ? Math.round(s$1 / 100) / 10 + "k" : s$1, n$1 = e$1[t$1 + 6], r$1 = -1 === n$1 ? {} : Object.assign({}, o$1[n$1]);
				return Object.assign(r$1, {
					cluster: !0,
					cluster_id: e$1[t$1 + 3],
					point_count: s$1,
					point_count_abbreviated: i$1
				});
			}
			function b(e$1) {
				return e$1 / 360 + .5;
			}
			function S(e$1) {
				const t$1 = Math.sin(e$1 * Math.PI / 180), o$1 = .5 - .25 * Math.log((1 + t$1) / (1 - t$1)) / Math.PI;
				return o$1 < 0 ? 0 : o$1 > 1 ? 1 : o$1;
			}
			function M(e$1) {
				const t$1 = (180 - 360 * e$1) * Math.PI / 180;
				return 360 * Math.atan(Math.exp(t$1)) / Math.PI - 90;
			}
			function I(e$1, t$1, o$1, s$1) {
				let i$1 = s$1;
				const n$1 = t$1 + (o$1 - t$1 >> 1);
				let r$1, a$1 = o$1 - t$1;
				const c$1 = e$1[t$1], l$1 = e$1[t$1 + 1], h$1 = e$1[o$1], u$1 = e$1[o$1 + 1];
				for (let s$2 = t$1 + 3; s$2 < o$1; s$2 += 3) {
					const t$2 = P(e$1[s$2], e$1[s$2 + 1], c$1, l$1, h$1, u$1);
					if (t$2 > i$1) r$1 = s$2, i$1 = t$2;
					else if (t$2 === i$1) {
						const e$2 = Math.abs(s$2 - n$1);
						e$2 < a$1 && (r$1 = s$2, a$1 = e$2);
					}
				}
				i$1 > s$1 && (r$1 - t$1 > 3 && I(e$1, t$1, r$1, s$1), e$1[r$1 + 2] = i$1, o$1 - r$1 > 3 && I(e$1, r$1, o$1, s$1));
			}
			function P(e$1, t$1, o$1, s$1, i$1, n$1) {
				let r$1 = i$1 - o$1, a$1 = n$1 - s$1;
				if (0 !== r$1 || 0 !== a$1) {
					const c$1 = ((e$1 - o$1) * r$1 + (t$1 - s$1) * a$1) / (r$1 * r$1 + a$1 * a$1);
					c$1 > 1 ? (o$1 = i$1, s$1 = n$1) : c$1 > 0 && (o$1 += r$1 * c$1, s$1 += a$1 * c$1);
				}
				return r$1 = e$1 - o$1, a$1 = t$1 - s$1, r$1 * r$1 + a$1 * a$1;
			}
			function k(e$1, t$1, o$1, s$1) {
				const i$1 = {
					type: t$1,
					geom: o$1
				}, n$1 = {
					id: null == e$1 ? null : e$1,
					type: i$1.type,
					geometry: i$1.geom,
					tags: s$1,
					minX: Infinity,
					minY: Infinity,
					maxX: -Infinity,
					maxY: -Infinity
				};
				switch (i$1.type) {
					case "Point":
					case "MultiPoint":
					case "LineString":
						T(n$1, i$1.geom);
						break;
					case "Polygon":
						T(n$1, i$1.geom[0]);
						break;
					case "MultiLineString":
						for (const e$2 of i$1.geom) T(n$1, e$2);
						break;
					case "MultiPolygon": for (const e$2 of i$1.geom) T(n$1, e$2[0]);
				}
				return n$1;
			}
			function T(e$1, t$1) {
				for (let o$1 = 0; o$1 < t$1.length; o$1 += 3) e$1.minX = Math.min(e$1.minX, t$1[o$1]), e$1.minY = Math.min(e$1.minY, t$1[o$1 + 1]), e$1.maxX = Math.max(e$1.maxX, t$1[o$1]), e$1.maxY = Math.max(e$1.maxY, t$1[o$1 + 1]);
			}
			function D(e$1, t$1) {
				const o$1 = [];
				switch (e$1.type) {
					case "FeatureCollection":
						for (let s$1 = 0; s$1 < e$1.features.length; s$1++) C(o$1, e$1.features[s$1], t$1, s$1);
						break;
					case "Feature":
						C(o$1, e$1, t$1);
						break;
					default: C(o$1, {
						geometry: e$1,
						properties: void 0
					}, t$1);
				}
				return o$1;
			}
			function C(e$1, t$1, o$1, s$1) {
				if (!t$1.geometry) return;
				if ("GeometryCollection" === t$1.geometry.type) {
					for (const i$1 of t$1.geometry.geometries) C(e$1, {
						id: t$1.id,
						geometry: i$1,
						properties: t$1.properties
					}, o$1, s$1);
					return;
				}
				if (!t$1.geometry.coordinates?.length) return;
				const n$1 = Math.pow(o$1.tolerance / ((1 << o$1.maxZoom) * o$1.extent), 2);
				let r$1 = t$1.id;
				switch (o$1.promoteId ? r$1 = t$1.properties?.[o$1.promoteId] : o$1.generateId && (r$1 = s$1 || 0), t$1.geometry.type) {
					case "Point": {
						const o$2 = [];
						O(t$1.geometry.coordinates, o$2), e$1.push(k(r$1, t$1.geometry.type, o$2, t$1.properties));
						return;
					}
					case "MultiPoint": {
						const o$2 = [];
						for (const e$2 of t$1.geometry.coordinates) O(e$2, o$2);
						e$1.push(k(r$1, t$1.geometry.type, o$2, t$1.properties));
						return;
					}
					case "LineString": {
						const o$2 = [];
						z(t$1.geometry.coordinates, o$2, n$1, !1), e$1.push(k(r$1, t$1.geometry.type, o$2, t$1.properties));
						return;
					}
					case "MultiLineString": {
						if (o$1.lineMetrics) {
							for (const o$2 of t$1.geometry.coordinates) {
								const s$3 = [];
								z(o$2, s$3, n$1, !1), e$1.push(k(r$1, "LineString", s$3, t$1.properties));
							}
							return;
						}
						const s$2 = [];
						L(t$1.geometry.coordinates, s$2, n$1, !1), e$1.push(k(r$1, t$1.geometry.type, s$2, t$1.properties));
						return;
					}
					case "Polygon": {
						const o$2 = [];
						L(t$1.geometry.coordinates, o$2, n$1, !0), e$1.push(k(r$1, t$1.geometry.type, o$2, t$1.properties));
						return;
					}
					case "MultiPolygon": {
						const o$2 = [];
						for (const e$2 of t$1.geometry.coordinates) {
							const t$2 = [];
							L(e$2, t$2, n$1, !0), o$2.push(t$2);
						}
						e$1.push(k(r$1, t$1.geometry.type, o$2, t$1.properties));
						return;
					}
					default: throw new Error("Input data is not a valid GeoJSON object.");
				}
			}
			function O(e$1, t$1) {
				t$1.push(F(e$1[0]), A(e$1[1]), 0);
			}
			function z(e$1, t$1, o$1, s$1) {
				let i$1, n$1, r$1 = 0;
				for (let o$2 = 0; o$2 < e$1.length; o$2++) {
					const a$2 = F(e$1[o$2][0]), c$1 = A(e$1[o$2][1]);
					t$1.push(a$2, c$1, 0), o$2 > 0 && (r$1 += s$1 ? (i$1 * c$1 - a$2 * n$1) / 2 : Math.sqrt(Math.pow(a$2 - i$1, 2) + Math.pow(c$1 - n$1, 2))), i$1 = a$2, n$1 = c$1;
				}
				const a$1 = t$1.length - 3;
				t$1[2] = 1, o$1 > 0 && I(t$1, 0, a$1, o$1), t$1[a$1 + 2] = 1, t$1.size = Math.abs(r$1), t$1.start = 0, t$1.end = t$1.size;
			}
			function L(e$1, t$1, o$1, s$1) {
				for (let i$1 = 0; i$1 < e$1.length; i$1++) {
					const n$1 = [];
					z(e$1[i$1], n$1, o$1, s$1), t$1.push(n$1);
				}
			}
			function F(e$1) {
				return e$1 / 360 + .5;
			}
			function A(e$1) {
				const t$1 = Math.sin(e$1 * Math.PI / 180), o$1 = .5 - .25 * Math.log((1 + t$1) / (1 - t$1)) / Math.PI;
				return o$1 < 0 ? 0 : o$1 > 1 ? 1 : o$1;
			}
			function G(e$1, t$1, o$1, s$1, i$1, n$1, r$1, a$1) {
				if (s$1 /= t$1, n$1 >= (o$1 /= t$1) && r$1 < s$1) return e$1;
				if (r$1 < o$1 || n$1 >= s$1) return null;
				const c$1 = [];
				for (const t$2 of e$1) {
					const e$2 = 0 === i$1 ? t$2.minX : t$2.minY, n$2 = 0 === i$1 ? t$2.maxX : t$2.maxY;
					if (e$2 >= o$1 && n$2 < s$1) c$1.push(t$2);
					else if (!(n$2 < o$1 || e$2 >= s$1)) switch (t$2.type) {
						case "Point":
						case "MultiPoint": {
							const e$3 = [];
							if (Z(t$2.geometry, e$3, o$1, s$1, i$1), !e$3.length) continue;
							c$1.push(k(t$2.id, 3 === e$3.length ? "Point" : "MultiPoint", e$3, t$2.tags));
							continue;
						}
						case "LineString": {
							const e$3 = [];
							if (E(t$2.geometry, e$3, o$1, s$1, i$1, !1, a$1.lineMetrics), !e$3.length) continue;
							if (a$1.lineMetrics) {
								for (const o$2 of e$3) c$1.push(k(t$2.id, t$2.type, o$2, t$2.tags));
								continue;
							}
							if (e$3.length > 1) {
								c$1.push(k(t$2.id, "MultiLineString", e$3, t$2.tags));
								continue;
							}
							c$1.push(k(t$2.id, t$2.type, e$3[0], t$2.tags));
							continue;
						}
						case "MultiLineString": {
							const e$3 = [];
							if (Y(t$2.geometry, e$3, o$1, s$1, i$1, !1), !e$3.length) continue;
							if (1 === e$3.length) {
								c$1.push(k(t$2.id, "LineString", e$3[0], t$2.tags));
								continue;
							}
							c$1.push(k(t$2.id, t$2.type, e$3, t$2.tags));
							continue;
						}
						case "Polygon": {
							const e$3 = [];
							if (Y(t$2.geometry, e$3, o$1, s$1, i$1, !0), !e$3.length) continue;
							c$1.push(k(t$2.id, t$2.type, e$3, t$2.tags));
							continue;
						}
						case "MultiPolygon": {
							const e$3 = [];
							for (const n$3 of t$2.geometry) {
								const t$3 = [];
								Y(n$3, t$3, o$1, s$1, i$1, !0), t$3.length && e$3.push(t$3);
							}
							if (!e$3.length) continue;
							c$1.push(k(t$2.id, t$2.type, e$3, t$2.tags));
							continue;
						}
					}
				}
				return c$1.length ? c$1 : null;
			}
			function Z(e$1, t$1, o$1, s$1, i$1) {
				for (let n$1 = 0; n$1 < e$1.length; n$1 += 3) {
					const r$1 = e$1[n$1 + i$1];
					r$1 >= o$1 && r$1 <= s$1 && j(t$1, e$1[n$1], e$1[n$1 + 1], e$1[n$1 + 2]);
				}
			}
			function E(e$1, t$1, o$1, s$1, i$1, n$1, r$1) {
				let a$1 = R(e$1);
				const c$1 = 0 === i$1 ? N : W;
				let l$1, h$1, u$1 = e$1.start;
				for (let d$2 = 0; d$2 < e$1.length - 3; d$2 += 3) {
					const g$2 = e$1[d$2], p$2 = e$1[d$2 + 1], f$2 = e$1[d$2 + 2], m$1 = e$1[d$2 + 3], y$1 = e$1[d$2 + 4], v$1 = 0 === i$1 ? g$2 : p$2, x$1 = 0 === i$1 ? m$1 : y$1;
					let w$1 = !1;
					r$1 && (l$1 = Math.sqrt(Math.pow(g$2 - m$1, 2) + Math.pow(p$2 - y$1, 2))), v$1 < o$1 ? x$1 > o$1 && (h$1 = c$1(a$1, g$2, p$2, m$1, y$1, o$1), r$1 && (a$1.start = u$1 + l$1 * h$1)) : v$1 > s$1 ? x$1 < s$1 && (h$1 = c$1(a$1, g$2, p$2, m$1, y$1, s$1), r$1 && (a$1.start = u$1 + l$1 * h$1)) : j(a$1, g$2, p$2, f$2), x$1 < o$1 && v$1 >= o$1 && (h$1 = c$1(a$1, g$2, p$2, m$1, y$1, o$1), w$1 = !0), x$1 > s$1 && v$1 <= s$1 && (h$1 = c$1(a$1, g$2, p$2, m$1, y$1, s$1), w$1 = !0), !n$1 && w$1 && (r$1 && (a$1.end = u$1 + l$1 * h$1), t$1.push(a$1), a$1 = R(e$1)), r$1 && (u$1 += l$1);
				}
				let d$1 = e$1.length - 3;
				const g$1 = e$1[d$1], p$1 = e$1[d$1 + 1], f$1 = 0 === i$1 ? g$1 : p$1;
				f$1 >= o$1 && f$1 <= s$1 && j(a$1, g$1, p$1, e$1[d$1 + 2]), d$1 = a$1.length - 3, n$1 && d$1 >= 3 && (a$1[d$1] !== a$1[0] || a$1[d$1 + 1] !== a$1[1]) && j(a$1, a$1[0], a$1[1], a$1[2]), a$1.length && t$1.push(a$1);
			}
			function R(e$1) {
				const t$1 = [];
				return t$1.size = e$1.size, t$1.start = e$1.start, t$1.end = e$1.end, t$1;
			}
			function Y(e$1, t$1, o$1, s$1, i$1, n$1) {
				for (const r$1 of e$1) E(r$1, t$1, o$1, s$1, i$1, n$1, !1);
			}
			function j(e$1, t$1, o$1, s$1) {
				e$1.push(t$1, o$1, s$1);
			}
			function N(e$1, t$1, o$1, s$1, i$1, n$1) {
				const r$1 = (n$1 - t$1) / (s$1 - t$1);
				return j(e$1, n$1, o$1 + (i$1 - o$1) * r$1, 1), r$1;
			}
			function W(e$1, t$1, o$1, s$1, i$1, n$1) {
				const r$1 = (n$1 - o$1) / (i$1 - o$1);
				return j(e$1, t$1 + (s$1 - t$1) * r$1, n$1, 1), r$1;
			}
			function J(e$1, t$1) {
				const o$1 = t$1.buffer / t$1.extent;
				let s$1 = e$1;
				const i$1 = G(e$1, 1, -1 - o$1, o$1, 0, -1, 2, t$1), n$1 = G(e$1, 1, 1 - o$1, 2 + o$1, 0, -1, 2, t$1);
				return i$1 || n$1 ? (s$1 = G(e$1, 1, -o$1, 1 + o$1, 0, -1, 2, t$1) || [], i$1 && (s$1 = X(i$1, 1).concat(s$1)), n$1 && (s$1 = s$1.concat(X(n$1, -1))), s$1) : s$1;
			}
			function X(e$1, t$1) {
				const o$1 = [];
				for (const s$1 of e$1) switch (s$1.type) {
					case "Point":
					case "MultiPoint":
					case "LineString": {
						const e$2 = q(s$1.geometry, t$1);
						o$1.push(k(s$1.id, s$1.type, e$2, s$1.tags));
						continue;
					}
					case "MultiLineString":
					case "Polygon": {
						const e$2 = [];
						for (const o$2 of s$1.geometry) e$2.push(q(o$2, t$1));
						o$1.push(k(s$1.id, s$1.type, e$2, s$1.tags));
						continue;
					}
					case "MultiPolygon": {
						const e$2 = [];
						for (const o$2 of s$1.geometry) {
							const s$2 = [];
							for (const e$3 of o$2) s$2.push(q(e$3, t$1));
							e$2.push(s$2);
						}
						o$1.push(k(s$1.id, s$1.type, e$2, s$1.tags));
						continue;
					}
				}
				return o$1;
			}
			function q(e$1, t$1) {
				const o$1 = [];
				o$1.size = e$1.size, void 0 !== e$1.start && (o$1.start = e$1.start, o$1.end = e$1.end);
				for (let s$1 = 0; s$1 < e$1.length; s$1 += 3) o$1.push(e$1[s$1] + t$1, e$1[s$1 + 1], e$1[s$1 + 2]);
				return o$1;
			}
			function H(e$1, t$1) {
				if (e$1.transformed) return e$1;
				const o$1 = 1 << e$1.z, s$1 = e$1.x, i$1 = e$1.y;
				for (const n$1 of e$1.features) {
					if (1 === n$1.type) {
						const e$3 = [];
						for (let r$1 = 0; r$1 < n$1.geometry.length; r$1 += 2) e$3.push($(n$1.geometry[r$1], n$1.geometry[r$1 + 1], t$1, o$1, s$1, i$1));
						n$1.geometry = e$3;
						continue;
					}
					const e$2 = [];
					for (const r$1 of n$1.geometry) {
						const n$2 = [];
						for (let e$3 = 0; e$3 < r$1.length; e$3 += 2) n$2.push($(r$1[e$3], r$1[e$3 + 1], t$1, o$1, s$1, i$1));
						e$2.push(n$2);
					}
					n$1.geometry = e$2;
				}
				return e$1.transformed = !0, e$1;
			}
			function $(e$1, t$1, o$1, s$1, i$1, n$1) {
				return [Math.round(o$1 * (e$1 * s$1 - i$1)), Math.round(o$1 * (t$1 * s$1 - n$1))];
			}
			function U(e$1, t$1, o$1, s$1, i$1) {
				const n$1 = t$1 === i$1.maxZoom ? 0 : i$1.tolerance / ((1 << t$1) * i$1.extent), r$1 = {
					features: [],
					numPoints: 0,
					numSimplified: 0,
					numFeatures: e$1.length,
					source: null,
					x: o$1,
					y: s$1,
					z: t$1,
					transformed: !1,
					minX: 2,
					minY: 1,
					maxX: -1,
					maxY: 0
				};
				for (const t$2 of e$1) B(r$1, t$2, n$1, i$1);
				return r$1;
			}
			function B(e$1, t$1, o$1, s$1) {
				e$1.minX = Math.min(e$1.minX, t$1.minX), e$1.minY = Math.min(e$1.minY, t$1.minY), e$1.maxX = Math.max(e$1.maxX, t$1.maxX), e$1.maxY = Math.max(e$1.maxY, t$1.maxY);
				let i$1, n$1 = t$1.tags || null;
				switch (t$1.type) {
					case "Point":
					case "MultiPoint": {
						const o$2 = [];
						for (let s$2 = 0; s$2 < t$1.geometry.length; s$2 += 3) o$2.push(t$1.geometry[s$2], t$1.geometry[s$2 + 1]), e$1.numPoints++, e$1.numSimplified++;
						if (!o$2.length) return;
						i$1 = {
							type: 1,
							tags: n$1,
							geometry: o$2
						};
						break;
					}
					case "LineString": {
						const r$1 = [];
						if (V(r$1, t$1.geometry, e$1, o$1, !1, !1), !r$1.length) return;
						if (s$1.lineMetrics) {
							n$1 = {};
							for (const e$2 in t$1.tags) n$1[e$2] = t$1.tags[e$2];
							n$1.mapbox_clip_start = t$1.geometry.start / t$1.geometry.size, n$1.mapbox_clip_end = t$1.geometry.end / t$1.geometry.size;
						}
						i$1 = {
							type: 2,
							tags: n$1,
							geometry: r$1
						};
						break;
					}
					case "MultiLineString":
					case "Polygon": {
						const s$2 = [];
						for (let i$2 = 0; i$2 < t$1.geometry.length; i$2++) V(s$2, t$1.geometry[i$2], e$1, o$1, "Polygon" === t$1.type, 0 === i$2);
						if (!s$2.length) return;
						i$1 = {
							type: "Polygon" === t$1.type ? 3 : 2,
							tags: n$1,
							geometry: s$2
						};
						break;
					}
					case "MultiPolygon": {
						const s$2 = [];
						for (let i$2 = 0; i$2 < t$1.geometry.length; i$2++) {
							const n$2 = t$1.geometry[i$2];
							for (let t$2 = 0; t$2 < n$2.length; t$2++) V(s$2, n$2[t$2], e$1, o$1, !0, 0 === t$2);
						}
						if (!s$2.length) return;
						i$1 = {
							type: 3,
							tags: n$1,
							geometry: s$2
						};
						break;
					}
				}
				null !== t$1.id && (i$1.id = t$1.id), e$1.features.push(i$1);
			}
			function V(e$1, t$1, o$1, s$1, i$1, n$1) {
				const r$1 = s$1 * s$1;
				if (s$1 > 0 && t$1.size < (i$1 ? r$1 : s$1)) return void (o$1.numPoints += t$1.length / 3);
				const a$1 = [];
				for (let e$2 = 0; e$2 < t$1.length; e$2 += 3) (0 === s$1 || t$1[e$2 + 2] > r$1) && (o$1.numSimplified++, a$1.push(t$1[e$2], t$1[e$2 + 1])), o$1.numPoints++;
				i$1 && function(e$2, t$2) {
					let o$2 = 0;
					for (let t$3 = 0, s$2 = e$2.length, i$2 = s$2 - 2; t$3 < s$2; i$2 = t$3, t$3 += 2) o$2 += (e$2[t$3] - e$2[i$2]) * (e$2[t$3 + 1] + e$2[i$2 + 1]);
					if (o$2 > 0 === t$2) for (let t$3 = 0, o$3 = e$2.length; t$3 < o$3 / 2; t$3 += 2) {
						const s$2 = e$2[t$3], i$2 = e$2[t$3 + 1];
						e$2[t$3] = e$2[o$3 - 2 - t$3], e$2[t$3 + 1] = e$2[o$3 - 1 - t$3], e$2[o$3 - 2 - t$3] = s$2, e$2[o$3 - 1 - t$3] = i$2;
					}
				}(a$1, n$1), e$1.push(a$1);
			}
			function K(e$1, t$1, o$1) {
				const s$1 = !!t$1.newGeometry, i$1 = t$1.removeAllProperties || t$1.removeProperties?.length > 0 || t$1.addOrUpdateProperties?.length > 0;
				if (s$1) {
					let s$2 = D({
						type: "FeatureCollection",
						features: [{
							type: "Feature",
							id: e$1.id,
							geometry: t$1.newGeometry,
							properties: i$1 ? Q(e$1.tags, t$1) : e$1.tags
						}]
					}, o$1);
					return s$2 = J(s$2, o$1), s$2[0];
				}
				if (i$1) {
					const o$2 = { ...e$1 };
					return o$2.tags = Q(o$2.tags, t$1), o$2;
				}
				return null;
			}
			function Q(e$1, t$1) {
				if (t$1.removeAllProperties) return {};
				const o$1 = { ...e$1 || {} };
				if (t$1.removeProperties) for (const e$2 of t$1.removeProperties) delete o$1[e$2];
				if (t$1.addOrUpdateProperties) for (const { key: e$2, value: s$1 } of t$1.addOrUpdateProperties) o$1[e$2] = s$1;
				return o$1;
			}
			const ee = {
				maxZoom: 14,
				indexMaxZoom: 5,
				indexMaxPoints: 1e5,
				tolerance: 3,
				extent: 4096,
				buffer: 64,
				lineMetrics: !1,
				promoteId: null,
				generateId: !1,
				updateable: !1,
				debug: 0
			};
			class te {
				options;
				tiles;
				tileCoords;
				stats = {};
				total = 0;
				source;
				constructor(e$1, t$1) {
					const o$1 = (t$1 = this.options = Object.assign({}, ee, t$1)).debug;
					if (o$1 && console.time("preprocess data"), t$1.maxZoom < 0 || t$1.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
					if (t$1.promoteId && t$1.generateId) throw new Error("promoteId and generateId cannot be used together.");
					let s$1 = D(e$1, t$1);
					this.tiles = {}, this.tileCoords = [], o$1 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t$1.indexMaxZoom, t$1.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), s$1 = J(s$1, t$1), s$1.length && this.splitTile(s$1, 0, 0, 0), t$1.updateable && (this.source = s$1), o$1 && (s$1.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
				}
				splitTile(e$1, t$1, o$1, s$1, i$1, n$1, r$1) {
					const a$1 = [
						e$1,
						t$1,
						o$1,
						s$1
					], c$1 = this.options, l$1 = c$1.debug;
					for (; a$1.length;) {
						s$1 = a$1.pop(), o$1 = a$1.pop(), t$1 = a$1.pop(), e$1 = a$1.pop();
						const h$1 = 1 << t$1, u$1 = oe(t$1, o$1, s$1);
						let d$1 = this.tiles[u$1];
						if (!d$1 && (l$1 > 1 && console.time("creation"), d$1 = this.tiles[u$1] = U(e$1, t$1, o$1, s$1, c$1), this.tileCoords.push({
							z: t$1,
							x: o$1,
							y: s$1,
							id: u$1
						}), l$1)) {
							l$1 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t$1, o$1, s$1, d$1.numFeatures, d$1.numPoints, d$1.numSimplified), console.timeEnd("creation"));
							const e$2 = `z${t$1}`;
							this.stats[e$2] = (this.stats[e$2] || 0) + 1, this.total++;
						}
						if (d$1.source = e$1, null == i$1) {
							if (t$1 === c$1.indexMaxZoom || d$1.numPoints <= c$1.indexMaxPoints) continue;
						} else {
							if (t$1 === c$1.maxZoom || t$1 === i$1) continue;
							if (null != i$1) {
								const e$2 = i$1 - t$1;
								if (o$1 !== n$1 >> e$2 || s$1 !== r$1 >> e$2) continue;
							}
						}
						if (d$1.source = null, !e$1.length) continue;
						l$1 > 1 && console.time("clipping");
						const g$1 = .5 * c$1.buffer / c$1.extent, p$1 = .5 - g$1, f$1 = .5 + g$1, m$1 = 1 + g$1;
						let y$1 = null, v$1 = null, x$1 = null, w$1 = null;
						const _$1 = G(e$1, h$1, o$1 - g$1, o$1 + f$1, 0, d$1.minX, d$1.maxX, c$1), b$1 = G(e$1, h$1, o$1 + p$1, o$1 + m$1, 0, d$1.minX, d$1.maxX, c$1);
						_$1 && (y$1 = G(_$1, h$1, s$1 - g$1, s$1 + f$1, 1, d$1.minY, d$1.maxY, c$1), v$1 = G(_$1, h$1, s$1 + p$1, s$1 + m$1, 1, d$1.minY, d$1.maxY, c$1)), b$1 && (x$1 = G(b$1, h$1, s$1 - g$1, s$1 + f$1, 1, d$1.minY, d$1.maxY, c$1), w$1 = G(b$1, h$1, s$1 + p$1, s$1 + m$1, 1, d$1.minY, d$1.maxY, c$1)), l$1 > 1 && console.timeEnd("clipping"), a$1.push(y$1 || [], t$1 + 1, 2 * o$1, 2 * s$1), a$1.push(v$1 || [], t$1 + 1, 2 * o$1, 2 * s$1 + 1), a$1.push(x$1 || [], t$1 + 1, 2 * o$1 + 1, 2 * s$1), a$1.push(w$1 || [], t$1 + 1, 2 * o$1 + 1, 2 * s$1 + 1);
					}
				}
				getTile(e$1, t$1, o$1) {
					e$1 = +e$1, t$1 = +t$1, o$1 = +o$1;
					const { extent: i$1, debug: n$1 } = this.options;
					if (e$1 < 0 || e$1 > 24) return null;
					const r$1 = 1 << e$1, a$1 = oe(e$1, t$1 = t$1 + r$1 & r$1 - 1, o$1);
					if (this.tiles[a$1]) return H(this.tiles[a$1], i$1);
					n$1 > 1 && console.log("drilling down to z%d-%d-%d", e$1, t$1, o$1);
					let c$1, l$1 = e$1, h$1 = t$1, u$1 = o$1;
					for (; !c$1 && l$1 > 0;) l$1--, h$1 >>= 1, u$1 >>= 1, c$1 = this.tiles[oe(l$1, h$1, u$1)];
					return c$1?.source ? (n$1 > 1 && (console.log("found parent tile z%d-%d-%d", l$1, h$1, u$1), console.time("drilling down")), this.splitTile(c$1.source, l$1, h$1, u$1, e$1, t$1, o$1), n$1 > 1 && console.timeEnd("drilling down"), this.tiles[a$1] ? H(this.tiles[a$1], i$1) : null) : null;
				}
				invalidateTiles(e$1) {
					const t$1 = this.options, { debug: o$1 } = t$1;
					let s$1 = Infinity, i$1 = -Infinity, n$1 = Infinity, r$1 = -Infinity;
					for (const t$2 of e$1) s$1 = Math.min(s$1, t$2.minX), i$1 = Math.max(i$1, t$2.maxX), n$1 = Math.min(n$1, t$2.minY), r$1 = Math.max(r$1, t$2.maxY);
					const a$1 = t$1.buffer / t$1.extent, c$1 = /* @__PURE__ */ new Set();
					for (const t$2 in this.tiles) {
						const l$1 = this.tiles[t$2], h$1 = 1 << l$1.z, u$1 = (l$1.x - a$1) / h$1, d$1 = (l$1.x + 1 + a$1) / h$1, g$1 = (l$1.y - a$1) / h$1, p$1 = (l$1.y + 1 + a$1) / h$1;
						if (i$1 < u$1 || s$1 >= d$1 || r$1 < g$1 || n$1 >= p$1) continue;
						let f$1 = !1;
						for (const t$3 of e$1) if (t$3.maxX >= u$1 && t$3.minX < d$1 && t$3.maxY >= g$1 && t$3.minY < p$1) {
							f$1 = !0;
							break;
						}
						if (f$1) {
							if (o$1) {
								o$1 > 1 && console.log("invalidate tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", l$1.z, l$1.x, l$1.y, l$1.numFeatures, l$1.numPoints, l$1.numSimplified);
								const e$2 = `z${l$1.z}`;
								this.stats[e$2] = (this.stats[e$2] || 0) - 1, this.total--;
							}
							delete this.tiles[t$2], c$1.add(t$2);
						}
					}
					c$1.size && (this.tileCoords = this.tileCoords.filter(((e$2) => !c$1.has(e$2.id))));
				}
				updateData(e$1) {
					const t$1 = this.options, o$1 = t$1.debug;
					if (!t$1.updateable) throw new Error("to update tile geojson `updateable` option must be set to true");
					const { affected: s$1, source: i$1 } = function(e$2, t$2, o$2) {
						const s$2 = function(e$3) {
							return e$3 ? {
								removeAll: e$3.removeAll,
								remove: new Set(e$3.remove || []),
								add: new Map(e$3.add?.map(((e$4) => [e$4.id, e$4]))),
								update: new Map(e$3.update?.map(((e$4) => [e$4.id, e$4])))
							} : {
								remove: /* @__PURE__ */ new Set(),
								add: /* @__PURE__ */ new Map(),
								update: /* @__PURE__ */ new Map()
							};
						}(t$2);
						let i$2 = [];
						if (s$2.removeAll && (i$2 = e$2, e$2 = []), s$2.remove.size || s$2.add.size) {
							const t$3 = [];
							for (const o$3 of e$2) {
								const { id: e$3 } = o$3;
								(s$2.remove.has(e$3) || s$2.add.has(e$3)) && t$3.push(o$3);
							}
							if (t$3.length) {
								i$2.push(...t$3);
								const o$3 = new Set(t$3.map(((e$3) => e$3.id)));
								e$2 = e$2.filter(((e$3) => !o$3.has(e$3.id)));
							}
							if (s$2.add.size) {
								let t$4 = D({
									type: "FeatureCollection",
									features: Array.from(s$2.add.values())
								}, o$2);
								t$4 = J(t$4, o$2), i$2.push(...t$4), e$2.push(...t$4);
							}
						}
						if (s$2.update.size) for (const [t$3, n$2] of s$2.update) {
							const s$3 = e$2.findIndex(((e$3) => e$3.id === t$3));
							if (-1 === s$3) continue;
							const r$2 = e$2[s$3], a$2 = K(r$2, n$2, o$2);
							a$2 && (i$2.push(r$2, a$2), e$2[s$3] = a$2);
						}
						return {
							affected: i$2,
							source: e$2
						};
					}(this.source, e$1, t$1);
					if (!s$1.length) return;
					this.source = i$1, o$1 > 1 && (console.log("invalidating tiles"), console.time("invalidating")), this.invalidateTiles(s$1), o$1 > 1 && console.timeEnd("invalidating");
					const [n$1, r$1, a$1] = [
						0,
						0,
						0
					], c$1 = U(this.source, n$1, r$1, a$1, this.options);
					c$1.source = this.source;
					const l$1 = oe(n$1, r$1, a$1);
					if (this.tiles[l$1] = c$1, this.tileCoords.push({
						z: n$1,
						x: r$1,
						y: a$1,
						id: l$1
					}), o$1) {
						const e$2 = `z${n$1}`;
						this.stats[e$2] = (this.stats[e$2] || 0) + 1, this.total++;
					}
				}
			}
			function oe(e$1, t$1, o$1) {
				return 32 * ((1 << e$1) * o$1 + t$1) + e$1;
			}
			class se extends h {
				constructor(e$1, t$1, o$1, s$1 = ie) {
					super(e$1, t$1, o$1), this._dataUpdateable = /* @__PURE__ */ new Map(), this._createGeoJSONIndex = s$1;
				}
				loadVectorTile(t$1, o$1) {
					return e._(this, void 0, void 0, (function* () {
						const o$2 = t$1.tileID.canonical;
						if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
						const s$1 = this._geoJSONIndex.getTile(o$2.z, o$2.x, o$2.y);
						return s$1 ? c(new e.d3(s$1.features, {
							version: 2,
							extent: e.a5
						})) : null;
					}));
				}
				loadData(t$1) {
					return e._(this, void 0, void 0, (function* () {
						var o$1;
						null === (o$1 = this._pendingRequest) || void 0 === o$1 || o$1.abort();
						const s$1 = this._startPerformance(t$1);
						this._pendingRequest = new AbortController();
						try {
							(!this._pendingData || t$1.request || t$1.data || t$1.dataDiff) && (this._pendingData = this.loadAndProcessGeoJSON(t$1, this._pendingRequest));
							const e$1 = yield this._pendingData;
							this._geoJSONIndex = this._createGeoJSONIndex(e$1, t$1), this.loaded = {};
							const o$2 = {};
							return t$1.request && (o$2.data = e$1), this._finishPerformance(s$1, t$1, o$2), o$2;
						} catch (t$2) {
							if (delete this._pendingRequest, e.Z(t$2)) return { abandoned: !0 };
							throw t$2;
						}
					}));
				}
				_startPerformance(t$1) {
					var o$1;
					if (null === (o$1 = null == t$1 ? void 0 : t$1.request) || void 0 === o$1 ? void 0 : o$1.collectResourceTiming) return new e.c$(t$1.request);
				}
				_finishPerformance(e$1, t$1, o$1) {
					if (!e$1) return;
					const s$1 = e$1.finish();
					s$1 && (o$1.resourceTiming = {}, o$1.resourceTiming[t$1.source] = JSON.parse(JSON.stringify(s$1)));
				}
				getData() {
					return e._(this, void 0, void 0, (function* () {
						return this._pendingData;
					}));
				}
				reloadTile(e$1) {
					const t$1 = this.loaded;
					return t$1 && t$1[e$1.uid] ? super.reloadTile(e$1) : this.loadTile(e$1);
				}
				loadAndProcessGeoJSON(t$1, o$1) {
					return e._(this, void 0, void 0, (function* () {
						let e$1;
						if (t$1.request ? e$1 = yield this.loadGeoJSONFromUrl(t$1.request, t$1.promoteId, o$1) : t$1.data ? e$1 = this._loadGeoJSONFromObject(t$1.data, t$1.promoteId) : t$1.dataDiff && (e$1 = this._loadGeoJSONFromDiff(t$1.dataDiff, t$1.promoteId, t$1.source)), delete this._pendingRequest, "object" != typeof e$1) throw new Error(`Input data given to '${t$1.source}' is not a valid GeoJSON object.`);
						return f(e$1, !0), t$1.filter && (e$1 = this._filterGeoJSON(e$1, t$1.filter)), e$1;
					}));
				}
				loadGeoJSONFromUrl(t$1, o$1, s$1) {
					return e._(this, void 0, void 0, (function* () {
						const i$1 = yield e.j(t$1, s$1);
						return this._dataUpdateable = e.a7(i$1.data, o$1), i$1.data;
					}));
				}
				_loadGeoJSONFromObject(t$1, o$1) {
					return this._dataUpdateable = e.a7(t$1, o$1), t$1;
				}
				_loadGeoJSONFromDiff(t$1, o$1, s$1) {
					if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${s$1}`);
					e.a8(this._dataUpdateable, t$1, o$1);
					const i$1 = Array.from(this._dataUpdateable.values());
					return this._toFeatureCollection(i$1);
				}
				_filterGeoJSON(t$1, o$1) {
					const s$1 = e.d4(o$1, {
						type: "boolean",
						"property-type": "data-driven",
						overridable: !1,
						transition: !1
					});
					if ("error" === s$1.result) throw new Error(s$1.value.map(((e$1) => `${e$1.key}: ${e$1.message}`)).join(", "));
					const i$1 = t$1.features.filter(((e$1) => s$1.value.evaluate({ zoom: 0 }, e$1)));
					return this._toFeatureCollection(i$1);
				}
				_toFeatureCollection(e$1) {
					return {
						type: "FeatureCollection",
						features: e$1
					};
				}
				removeSource(t$1) {
					return e._(this, void 0, void 0, (function* () {
						this._pendingRequest && this._pendingRequest.abort();
					}));
				}
				getClusterExpansionZoom(e$1) {
					return this._geoJSONIndex.getClusterExpansionZoom(e$1.clusterId);
				}
				getClusterChildren(e$1) {
					return this._geoJSONIndex.getChildren(e$1.clusterId);
				}
				getClusterLeaves(e$1) {
					return this._geoJSONIndex.getLeaves(e$1.clusterId, e$1.limit, e$1.offset);
				}
			}
			function ie(t$1, o$1) {
				return o$1.cluster ? new x(function({ superclusterOptions: t$2, clusterProperties: o$2 }) {
					if (!o$2 || !t$2) return t$2;
					const s$1 = {}, i$1 = {}, n$1 = {
						accumulated: null,
						zoom: 0
					}, r$1 = { properties: null }, a$1 = Object.keys(o$2);
					for (const t$3 of a$1) {
						const [n$2, r$2] = o$2[t$3], a$2 = e.d4(r$2), c$1 = e.d4("string" == typeof n$2 ? [
							n$2,
							["accumulated"],
							["get", t$3]
						] : n$2);
						s$1[t$3] = a$2.value, i$1[t$3] = c$1.value;
					}
					return t$2.map = (e$1) => {
						r$1.properties = e$1;
						const t$3 = {};
						for (const e$2 of a$1) t$3[e$2] = s$1[e$2].evaluate(n$1, r$1);
						return t$3;
					}, t$2.reduce = (e$1, t$3) => {
						r$1.properties = t$3;
						for (const t$4 of a$1) n$1.accumulated = e$1[t$4], e$1[t$4] = i$1[t$4].evaluate(n$1, r$1);
					}, t$2;
				}(o$1)).load(t$1.features) : function(e$1, t$2) {
					return new te(e$1, t$2);
				}(t$1, o$1.geojsonVtOptions);
			}
			class ne {
				constructor(t$1) {
					this.self = t$1, this.actor = new e.L(t$1), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.globalStates = /* @__PURE__ */ new Map(), this.self.registerWorkerSource = (e$1, t$2) => {
						if (this.externalWorkerSourceTypes[e$1]) throw new Error(`Worker source with name "${e$1}" already registered.`);
						this.externalWorkerSourceTypes[e$1] = t$2;
					}, this.self.addProtocol = e.cK, this.self.removeProtocol = e.cL, this.self.registerRTLTextPlugin = (t$2) => {
						e.d5.setMethods(t$2);
					}, this.actor.registerMessageHandler("LDT", ((e$1, t$2) => this._getDEMWorkerSource(e$1, t$2.source).loadTile(t$2))), this.actor.registerMessageHandler("RDT", ((t$2, o$1) => e._(this, void 0, void 0, (function* () {
						this._getDEMWorkerSource(t$2, o$1.source).removeTile(o$1);
					})))), this.actor.registerMessageHandler("GCEZ", ((t$2, o$1) => e._(this, void 0, void 0, (function* () {
						return this._getWorkerSource(t$2, o$1.type, o$1.source).getClusterExpansionZoom(o$1);
					})))), this.actor.registerMessageHandler("GCC", ((t$2, o$1) => e._(this, void 0, void 0, (function* () {
						return this._getWorkerSource(t$2, o$1.type, o$1.source).getClusterChildren(o$1);
					})))), this.actor.registerMessageHandler("GCL", ((t$2, o$1) => e._(this, void 0, void 0, (function* () {
						return this._getWorkerSource(t$2, o$1.type, o$1.source).getClusterLeaves(o$1);
					})))), this.actor.registerMessageHandler("LD", ((e$1, t$2) => this._getWorkerSource(e$1, t$2.type, t$2.source).loadData(t$2))), this.actor.registerMessageHandler("GD", ((e$1, t$2) => this._getWorkerSource(e$1, t$2.type, t$2.source).getData())), this.actor.registerMessageHandler("LT", ((e$1, t$2) => this._getWorkerSource(e$1, t$2.type, t$2.source).loadTile(t$2))), this.actor.registerMessageHandler("RT", ((e$1, t$2) => this._getWorkerSource(e$1, t$2.type, t$2.source).reloadTile(t$2))), this.actor.registerMessageHandler("AT", ((e$1, t$2) => this._getWorkerSource(e$1, t$2.type, t$2.source).abortTile(t$2))), this.actor.registerMessageHandler("RMT", ((e$1, t$2) => this._getWorkerSource(e$1, t$2.type, t$2.source).removeTile(t$2))), this.actor.registerMessageHandler("RS", ((t$2, o$1) => e._(this, void 0, void 0, (function* () {
						if (!this.workerSources[t$2] || !this.workerSources[t$2][o$1.type] || !this.workerSources[t$2][o$1.type][o$1.source]) return;
						const e$1 = this.workerSources[t$2][o$1.type][o$1.source];
						delete this.workerSources[t$2][o$1.type][o$1.source], void 0 !== e$1.removeSource && e$1.removeSource(o$1);
					})))), this.actor.registerMessageHandler("RM", ((t$2) => e._(this, void 0, void 0, (function* () {
						delete this.layerIndexes[t$2], delete this.availableImages[t$2], delete this.workerSources[t$2], delete this.demWorkerSources[t$2], this.globalStates.delete(t$2);
					})))), this.actor.registerMessageHandler("SR", ((t$2, o$1) => e._(this, void 0, void 0, (function* () {
						this.referrer = o$1;
					})))), this.actor.registerMessageHandler("SRPS", ((e$1, t$2) => this._syncRTLPluginState(e$1, t$2))), this.actor.registerMessageHandler("IS", ((t$2, o$1) => e._(this, void 0, void 0, (function* () {
						this.self.importScripts(o$1);
					})))), this.actor.registerMessageHandler("SI", ((e$1, t$2) => this._setImages(e$1, t$2))), this.actor.registerMessageHandler("UL", ((t$2, o$1) => e._(this, void 0, void 0, (function* () {
						this._getLayerIndex(t$2).update(o$1.layers, o$1.removedIds, this._getGlobalState(t$2));
					})))), this.actor.registerMessageHandler("UGS", ((t$2, o$1) => e._(this, void 0, void 0, (function* () {
						const e$1 = this._getGlobalState(t$2);
						for (const t$3 in o$1) e$1[t$3] = o$1[t$3];
					})))), this.actor.registerMessageHandler("SL", ((t$2, o$1) => e._(this, void 0, void 0, (function* () {
						this._getLayerIndex(t$2).replace(o$1, this._getGlobalState(t$2));
					}))));
				}
				_getGlobalState(e$1) {
					let t$1 = this.globalStates.get(e$1);
					return t$1 || (t$1 = {}, this.globalStates.set(e$1, t$1)), t$1;
				}
				_setImages(t$1, o$1) {
					return e._(this, void 0, void 0, (function* () {
						this.availableImages[t$1] = o$1;
						for (const e$1 in this.workerSources[t$1]) {
							const s$1 = this.workerSources[t$1][e$1];
							for (const e$2 in s$1) s$1[e$2].availableImages = o$1;
						}
					}));
				}
				_syncRTLPluginState(t$1, o$1) {
					return e._(this, void 0, void 0, (function* () {
						return yield e.d5.syncState(o$1, this.self.importScripts);
					}));
				}
				_getAvailableImages(e$1) {
					let t$1 = this.availableImages[e$1];
					return t$1 || (t$1 = []), t$1;
				}
				_getLayerIndex(e$1) {
					let o$1 = this.layerIndexes[e$1];
					return o$1 || (o$1 = this.layerIndexes[e$1] = new t()), o$1;
				}
				_getWorkerSource(e$1, t$1, o$1) {
					if (this.workerSources[e$1] || (this.workerSources[e$1] = {}), this.workerSources[e$1][t$1] || (this.workerSources[e$1][t$1] = {}), !this.workerSources[e$1][t$1][o$1]) {
						const s$1 = { sendAsync: (t$2, o$2) => (t$2.targetMapId = e$1, this.actor.sendAsync(t$2, o$2)) };
						switch (t$1) {
							case "vector":
								this.workerSources[e$1][t$1][o$1] = new h(s$1, this._getLayerIndex(e$1), this._getAvailableImages(e$1));
								break;
							case "geojson":
								this.workerSources[e$1][t$1][o$1] = new se(s$1, this._getLayerIndex(e$1), this._getAvailableImages(e$1));
								break;
							default: this.workerSources[e$1][t$1][o$1] = new this.externalWorkerSourceTypes[t$1](s$1, this._getLayerIndex(e$1), this._getAvailableImages(e$1));
						}
					}
					return this.workerSources[e$1][t$1][o$1];
				}
				_getDEMWorkerSource(e$1, t$1) {
					return this.demWorkerSources[e$1] || (this.demWorkerSources[e$1] = {}), this.demWorkerSources[e$1][t$1] || (this.demWorkerSources[e$1][t$1] = new u()), this.demWorkerSources[e$1][t$1];
				}
			}
			return e.i(self) && (self.worker = new ne(self)), ne;
		}));
		define$1("index", ["exports", "./shared"], (function(e, t) {
			var i = "5.17.0";
			function a() {
				var e$1 = new t.A(4);
				return t.A != Float32Array && (e$1[1] = 0, e$1[2] = 0), e$1[0] = 1, e$1[3] = 1, e$1;
			}
			let o, r, s;
			const n = {
				frame(e$1, i$1, a$1, o$1) {
					const r$1 = o$1 || window, s$1 = r$1.requestAnimationFrame(((e$2) => {
						n$1(), i$1(e$2);
					})), { unsubscribe: n$1 } = t.s(e$1.signal, "abort", (() => {
						n$1(), r$1.cancelAnimationFrame(s$1), a$1(new t.a(e$1.signal.reason));
					}), !1);
				},
				frameAsync(e$1, t$1) {
					return new Promise(((i$1, a$1) => {
						this.frame(e$1, i$1, a$1, t$1);
					}));
				},
				getImageData(e$1, t$1 = 0) {
					return this.getImageCanvasContext(e$1).getImageData(-t$1, -t$1, e$1.width + 2 * t$1, e$1.height + 2 * t$1);
				},
				getImageCanvasContext(e$1) {
					const t$1 = window.document.createElement("canvas"), i$1 = t$1.getContext("2d", { willReadFrequently: !0 });
					if (!i$1) throw new Error("failed to create canvas 2d context");
					return t$1.width = e$1.width, t$1.height = e$1.height, i$1.drawImage(e$1, 0, 0, e$1.width, e$1.height), i$1;
				},
				resolveURL: (e$1) => (o || (o = document.createElement("a")), o.href = e$1, o.href),
				hardwareConcurrency: "undefined" != typeof navigator && navigator.hardwareConcurrency || 4,
				get prefersReducedMotion() {
					return void 0 !== s ? s : !!matchMedia && (r ??= matchMedia("(prefers-reduced-motion: reduce)"), r.matches);
				},
				set prefersReducedMotion(e$1) {
					s = e$1;
				}
			}, l = new class {
				constructor() {
					this._realTime = "undefined" != typeof performance && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), this._frozenAt = null;
				}
				getCurrentTime() {
					return null !== this._frozenAt ? this._frozenAt : this._realTime();
				}
				setNow(e$1) {
					this._frozenAt = e$1;
				}
				restoreNow() {
					this._frozenAt = null;
				}
				isFrozen() {
					return null !== this._frozenAt;
				}
			}();
			function c() {
				return l.getCurrentTime();
			}
			class h {
				static testProp(e$1) {
					if (!h.docStyle) return e$1[0];
					for (let t$1 = 0; t$1 < e$1.length; t$1++) if (e$1[t$1] in h.docStyle) return e$1[t$1];
					return e$1[0];
				}
				static create(e$1, t$1, i$1) {
					const a$1 = window.document.createElement(e$1);
					return void 0 !== t$1 && (a$1.className = t$1), i$1 && i$1.appendChild(a$1), a$1;
				}
				static createNS(e$1, t$1) {
					return window.document.createElementNS(e$1, t$1);
				}
				static disableDrag() {
					h.docStyle && h.selectProp && (h.userSelect = h.docStyle[h.selectProp], h.docStyle[h.selectProp] = "none");
				}
				static enableDrag() {
					h.docStyle && h.selectProp && (h.docStyle[h.selectProp] = h.userSelect);
				}
				static setTransform(e$1, t$1) {
					e$1.style[h.transformProp] = t$1;
				}
				static addEventListener(e$1, t$1, i$1, a$1 = {}) {
					e$1.addEventListener(t$1, i$1, "passive" in a$1 ? a$1 : a$1.capture);
				}
				static removeEventListener(e$1, t$1, i$1, a$1 = {}) {
					e$1.removeEventListener(t$1, i$1, "passive" in a$1 ? a$1 : a$1.capture);
				}
				static suppressClickInternal(e$1) {
					e$1.preventDefault(), e$1.stopPropagation(), window.removeEventListener("click", h.suppressClickInternal, !0);
				}
				static suppressClick() {
					window.addEventListener("click", h.suppressClickInternal, !0), window.setTimeout((() => {
						window.removeEventListener("click", h.suppressClickInternal, !0);
					}), 0);
				}
				static getScale(e$1) {
					const t$1 = e$1.getBoundingClientRect();
					return {
						x: t$1.width / e$1.offsetWidth || 1,
						y: t$1.height / e$1.offsetHeight || 1,
						boundingClientRect: t$1
					};
				}
				static getPoint(e$1, i$1, a$1) {
					const o$1 = i$1.boundingClientRect;
					return new t.P((a$1.clientX - o$1.left) / i$1.x - e$1.clientLeft, (a$1.clientY - o$1.top) / i$1.y - e$1.clientTop);
				}
				static mousePos(e$1, t$1) {
					const i$1 = h.getScale(e$1);
					return h.getPoint(e$1, i$1, t$1);
				}
				static touchPos(e$1, t$1) {
					const i$1 = [], a$1 = h.getScale(e$1);
					for (let o$1 = 0; o$1 < t$1.length; o$1++) i$1.push(h.getPoint(e$1, a$1, t$1[o$1]));
					return i$1;
				}
				static mouseButton(e$1) {
					return e$1.button;
				}
				static remove(e$1) {
					e$1.parentNode && e$1.parentNode.removeChild(e$1);
				}
				static sanitize(e$1) {
					const t$1 = new DOMParser().parseFromString(e$1, "text/html").body || document.createElement("body"), i$1 = t$1.querySelectorAll("script");
					for (const e$2 of i$1) e$2.remove();
					return h.clean(t$1), t$1.innerHTML;
				}
				static isPossiblyDangerous(e$1, t$1) {
					const i$1 = t$1.replace(/\s+/g, "").toLowerCase();
					return !(![
						"src",
						"href",
						"xlink:href"
					].includes(e$1) || !i$1.includes("javascript:") && !i$1.includes("data:")) || !!e$1.startsWith("on") || void 0;
				}
				static clean(e$1) {
					const t$1 = e$1.children;
					for (const e$2 of t$1) h.removeAttributes(e$2), h.clean(e$2);
				}
				static removeAttributes(e$1) {
					for (const { name: t$1, value: i$1 } of e$1.attributes) h.isPossiblyDangerous(t$1, i$1) && e$1.removeAttribute(t$1);
				}
			}
			h.docStyle = "undefined" != typeof window && window.document && window.document.documentElement.style, h.selectProp = h.testProp([
				"userSelect",
				"MozUserSelect",
				"WebkitUserSelect",
				"msUserSelect"
			]), h.transformProp = h.testProp(["transform", "WebkitTransform"]);
			const u = {
				supported: !1,
				testSupport: function(e$1) {
					!p && _ && (m ? f(e$1) : d = e$1);
				}
			};
			let d, _, p = !1, m = !1;
			function f(e$1) {
				const t$1 = e$1.createTexture();
				e$1.bindTexture(e$1.TEXTURE_2D, t$1);
				try {
					if (e$1.texImage2D(e$1.TEXTURE_2D, 0, e$1.RGBA, e$1.RGBA, e$1.UNSIGNED_BYTE, _), e$1.isContextLost()) return;
					u.supported = !0;
				} catch (e$2) {}
				e$1.deleteTexture(t$1), p = !0;
			}
			var g;
			"undefined" != typeof document && (_ = document.createElement("img"), _.onload = () => {
				d && f(d), d = null, m = !0;
			}, _.onerror = () => {
				p = !0, d = null;
			}, _.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(e$1) {
				let i$1, a$1, o$1, r$1;
				e$1.resetRequestQueue = () => {
					i$1 = [], a$1 = 0, o$1 = 0, r$1 = {};
				}, e$1.addThrottleControl = (e$2) => {
					const t$1 = o$1++;
					return r$1[t$1] = e$2, t$1;
				}, e$1.removeThrottleControl = (e$2) => {
					delete r$1[e$2], n$1();
				}, e$1.getImage = (e$2, a$2, o$2 = !0) => new Promise(((r$2, s$2) => {
					u.supported && (e$2.headers || (e$2.headers = {}), e$2.headers.accept = "image/webp,*/*"), t.e(e$2, { type: "image" }), i$1.push({
						abortController: a$2,
						requestParameters: e$2,
						supportImageRefresh: o$2,
						state: "queued",
						onError: (e$3) => {
							s$2(e$3);
						},
						onSuccess: (e$3) => {
							r$2(e$3);
						}
					}), n$1();
				}));
				const s$1 = (e$2) => t._(this, void 0, void 0, (function* () {
					e$2.state = "running";
					const { requestParameters: i$2, supportImageRefresh: o$2, onError: r$2, onSuccess: s$2, abortController: c$1 } = e$2, h$1 = !1 === o$2 && !t.i(self) && !t.g(i$2.url) && (!i$2.headers || Object.keys(i$2.headers).reduce(((e$3, t$1) => e$3 && "accept" === t$1), !0));
					a$1++;
					const u$1 = h$1 ? l$1(i$2, c$1) : t.m(i$2, c$1);
					try {
						const i$3 = yield u$1;
						delete e$2.abortController, e$2.state = "completed", i$3.data instanceof HTMLImageElement || t.b(i$3.data) ? s$2(i$3) : i$3.data && s$2({
							data: yield (d$1 = i$3.data, "function" == typeof createImageBitmap ? t.f(d$1) : t.h(d$1)),
							cacheControl: i$3.cacheControl,
							expires: i$3.expires
						});
					} catch (t$1) {
						delete e$2.abortController, r$2(t$1);
					} finally {
						a$1--, n$1();
					}
					var d$1;
				})), n$1 = () => {
					const e$2 = (() => {
						for (const e$3 of Object.keys(r$1)) if (r$1[e$3]()) return !0;
						return !1;
					})() ? t.c.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : t.c.MAX_PARALLEL_IMAGE_REQUESTS;
					for (let t$1 = a$1; t$1 < e$2 && i$1.length > 0; t$1++) {
						const e$3 = i$1.shift();
						e$3.abortController.signal.aborted ? t$1-- : s$1(e$3);
					}
				}, l$1 = (e$2, i$2) => new Promise(((a$2, o$2) => {
					const r$2 = new Image(), s$2 = e$2.url, n$2 = e$2.credentials;
					n$2 && "include" === n$2 ? r$2.crossOrigin = "use-credentials" : (n$2 && "same-origin" === n$2 || !t.d(s$2)) && (r$2.crossOrigin = "anonymous"), i$2.signal.addEventListener("abort", (() => {
						r$2.src = "", o$2(new t.a(i$2.signal.reason));
					})), r$2.fetchPriority = "high", r$2.onload = () => {
						r$2.onerror = r$2.onload = null, a$2({ data: r$2 });
					}, r$2.onerror = () => {
						r$2.onerror = r$2.onload = null, i$2.signal.aborted || o$2(/* @__PURE__ */ new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
					}, r$2.src = s$2;
				}));
			}(g || (g = {})), g.resetRequestQueue();
			class v {
				constructor(e$1) {
					this._transformRequestFn = null != e$1 ? e$1 : null;
				}
				transformRequest(e$1, t$1) {
					return this._transformRequestFn && this._transformRequestFn(e$1, t$1) || { url: e$1 };
				}
				setTransformRequest(e$1) {
					this._transformRequestFn = e$1;
				}
			}
			function x(e$1) {
				const t$1 = [];
				if ("string" == typeof e$1) t$1.push({
					id: "default",
					url: e$1
				});
				else if (e$1 && e$1.length > 0) {
					const i$1 = [];
					for (const { id: a$1, url: o$1 } of e$1) {
						const e$2 = `${a$1}${o$1}`;
						-1 === i$1.indexOf(e$2) && (i$1.push(e$2), t$1.push({
							id: a$1,
							url: o$1
						}));
					}
				}
				return t$1;
			}
			function b(e$1, t$1, i$1) {
				try {
					const a$1 = new URL(e$1);
					return a$1.pathname += `${t$1}${i$1}`, a$1.toString();
				} catch (t$2) {
					throw new Error(`Invalid sprite URL "${e$1}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
				}
			}
			function y(e$1) {
				const { userImage: t$1 } = e$1;
				return !!(t$1 && t$1.render && t$1.render()) && (e$1.data.replace(new Uint8Array(t$1.data.buffer)), !0);
			}
			class w extends t.E {
				constructor() {
					super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new t.R({
						width: 1,
						height: 1
					}), this.dirty = !0;
				}
				destroy() {
					this.atlasTexture && (this.atlasTexture.destroy(), this.atlasTexture = null);
					for (const e$1 of Object.keys(this.images)) this.removeImage(e$1);
					this.patterns = {}, this.atlasImage = new t.R({
						width: 1,
						height: 1
					}), this.dirty = !0;
				}
				isLoaded() {
					return this.loaded;
				}
				setLoaded(e$1) {
					if (this.loaded !== e$1 && (this.loaded = e$1, e$1)) {
						for (const { ids: e$2, promiseResolve: t$1 } of this.requestors) t$1(this._getImagesForIds(e$2));
						this.requestors = [];
					}
				}
				getImage(e$1) {
					const i$1 = this.images[e$1];
					if (i$1 && !i$1.data && i$1.spriteData) {
						const e$2 = i$1.spriteData;
						i$1.data = new t.R({
							width: e$2.width,
							height: e$2.height
						}, e$2.context.getImageData(e$2.x, e$2.y, e$2.width, e$2.height).data), i$1.spriteData = null;
					}
					return i$1;
				}
				addImage(e$1, t$1) {
					if (this.images[e$1]) throw new Error(`Image id ${e$1} already exist, use updateImage instead`);
					this._validate(e$1, t$1) && (this.images[e$1] = t$1);
				}
				_validate(e$1, i$1) {
					let a$1 = !0;
					const o$1 = i$1.data || i$1.spriteData;
					return this._validateStretch(i$1.stretchX, o$1 && o$1.width) || (this.fire(new t.k(/* @__PURE__ */ new Error(`Image "${e$1}" has invalid "stretchX" value`))), a$1 = !1), this._validateStretch(i$1.stretchY, o$1 && o$1.height) || (this.fire(new t.k(/* @__PURE__ */ new Error(`Image "${e$1}" has invalid "stretchY" value`))), a$1 = !1), this._validateContent(i$1.content, i$1) || (this.fire(new t.k(/* @__PURE__ */ new Error(`Image "${e$1}" has invalid "content" value`))), a$1 = !1), a$1;
				}
				_validateStretch(e$1, t$1) {
					if (!e$1) return !0;
					let i$1 = 0;
					for (const a$1 of e$1) {
						if (a$1[0] < i$1 || a$1[1] < a$1[0] || t$1 < a$1[1]) return !1;
						i$1 = a$1[1];
					}
					return !0;
				}
				_validateContent(e$1, t$1) {
					if (!e$1) return !0;
					if (4 !== e$1.length) return !1;
					const i$1 = t$1.spriteData, a$1 = i$1 && i$1.width || t$1.data.width, o$1 = i$1 && i$1.height || t$1.data.height;
					return !(e$1[0] < 0 || a$1 < e$1[0] || e$1[1] < 0 || o$1 < e$1[1] || e$1[2] < 0 || a$1 < e$1[2] || e$1[3] < 0 || o$1 < e$1[3] || e$1[2] < e$1[0] || e$1[3] < e$1[1]);
				}
				updateImage(e$1, t$1, i$1 = !0) {
					const a$1 = this.getImage(e$1);
					if (i$1 && (a$1.data.width !== t$1.data.width || a$1.data.height !== t$1.data.height)) throw new Error(`size mismatch between old image (${a$1.data.width}x${a$1.data.height}) and new image (${t$1.data.width}x${t$1.data.height}).`);
					t$1.version = a$1.version + 1, this.images[e$1] = t$1, this.updatedImages[e$1] = !0;
				}
				removeImage(e$1) {
					const t$1 = this.images[e$1];
					delete this.images[e$1], delete this.patterns[e$1], t$1.userImage && t$1.userImage.onRemove && t$1.userImage.onRemove();
				}
				listImages() {
					return Object.keys(this.images);
				}
				getImages(e$1) {
					return new Promise(((t$1, i$1) => {
						let a$1 = !0;
						if (!this.isLoaded()) for (const t$2 of e$1) this.images[t$2] || (a$1 = !1);
						this.isLoaded() || a$1 ? t$1(this._getImagesForIds(e$1)) : this.requestors.push({
							ids: e$1,
							promiseResolve: t$1
						});
					}));
				}
				_getImagesForIds(e$1) {
					const i$1 = {};
					for (const a$1 of e$1) {
						let e$2 = this.getImage(a$1);
						e$2 || (this.fire(new t.l("styleimagemissing", { id: a$1 })), e$2 = this.getImage(a$1)), e$2 ? i$1[a$1] = {
							data: e$2.data.clone(),
							pixelRatio: e$2.pixelRatio,
							sdf: e$2.sdf,
							version: e$2.version,
							stretchX: e$2.stretchX,
							stretchY: e$2.stretchY,
							content: e$2.content,
							textFitWidth: e$2.textFitWidth,
							textFitHeight: e$2.textFitHeight,
							hasRenderCallback: Boolean(e$2.userImage && e$2.userImage.render)
						} : t.w(`Image "${a$1}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
					}
					return i$1;
				}
				getPixelSize() {
					const { width: e$1, height: t$1 } = this.atlasImage;
					return {
						width: e$1,
						height: t$1
					};
				}
				getPattern(e$1) {
					const i$1 = this.patterns[e$1], a$1 = this.getImage(e$1);
					if (!a$1) return null;
					if (i$1 && i$1.position.version === a$1.version) return i$1.position;
					if (i$1) i$1.position.version = a$1.version;
					else {
						const i$2 = {
							w: a$1.data.width + 2,
							h: a$1.data.height + 2,
							x: 0,
							y: 0
						}, o$1 = new t.I(i$2, a$1);
						this.patterns[e$1] = {
							bin: i$2,
							position: o$1
						};
					}
					return this._updatePatternAtlas(), this.patterns[e$1].position;
				}
				bind(e$1) {
					const i$1 = e$1.gl;
					this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new t.T(e$1, this.atlasImage, i$1.RGBA), this.atlasTexture.bind(i$1.LINEAR, i$1.CLAMP_TO_EDGE);
				}
				_updatePatternAtlas() {
					const e$1 = [];
					for (const t$1 in this.patterns) e$1.push(this.patterns[t$1].bin);
					const { w: i$1, h: a$1 } = t.p(e$1), o$1 = this.atlasImage;
					o$1.resize({
						width: i$1 || 1,
						height: a$1 || 1
					});
					for (const e$2 in this.patterns) {
						const { bin: i$2 } = this.patterns[e$2], a$2 = i$2.x + 1, r$1 = i$2.y + 1, s$1 = this.getImage(e$2).data, n$1 = s$1.width, l$1 = s$1.height;
						t.R.copy(s$1, o$1, {
							x: 0,
							y: 0
						}, {
							x: a$2,
							y: r$1
						}, {
							width: n$1,
							height: l$1
						}), t.R.copy(s$1, o$1, {
							x: 0,
							y: l$1 - 1
						}, {
							x: a$2,
							y: r$1 - 1
						}, {
							width: n$1,
							height: 1
						}), t.R.copy(s$1, o$1, {
							x: 0,
							y: 0
						}, {
							x: a$2,
							y: r$1 + l$1
						}, {
							width: n$1,
							height: 1
						}), t.R.copy(s$1, o$1, {
							x: n$1 - 1,
							y: 0
						}, {
							x: a$2 - 1,
							y: r$1
						}, {
							width: 1,
							height: l$1
						}), t.R.copy(s$1, o$1, {
							x: 0,
							y: 0
						}, {
							x: a$2 + n$1,
							y: r$1
						}, {
							width: 1,
							height: l$1
						});
					}
					this.dirty = !0;
				}
				beginFrame() {
					this.callbackDispatchedThisFrame = {};
				}
				dispatchRenderCallbacks(e$1) {
					for (const i$1 of e$1) {
						if (this.callbackDispatchedThisFrame[i$1]) continue;
						this.callbackDispatchedThisFrame[i$1] = !0;
						const e$2 = this.getImage(i$1);
						e$2 || t.w(`Image with ID: "${i$1}" was not found`), y(e$2) && this.updateImage(i$1, e$2);
					}
				}
				cloneImages() {
					const e$1 = {};
					for (const t$1 in this.images) {
						const i$1 = this.images[t$1];
						e$1[t$1] = Object.assign(Object.assign({}, i$1), { data: i$1.data ? i$1.data.clone() : null });
					}
					return e$1;
				}
			}
			const T = 0x56bc75e2d63100000;
			function P(e$1, t$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1) {
				for (let c$1 = t$1; c$1 < t$1 + a$1; c$1++) C(e$1, i$1 * r$1 + c$1, r$1, o$1, s$1, n$1, l$1);
				for (let c$1 = i$1; c$1 < i$1 + o$1; c$1++) C(e$1, c$1 * r$1 + t$1, 1, a$1, s$1, n$1, l$1);
			}
			function C(e$1, t$1, i$1, a$1, o$1, r$1, s$1) {
				r$1[0] = 0, s$1[0] = -T, s$1[1] = T, o$1[0] = e$1[t$1];
				for (let n$1 = 1, l$1 = 0, c$1 = 0; n$1 < a$1; n$1++) {
					o$1[n$1] = e$1[t$1 + n$1 * i$1];
					const a$2 = n$1 * n$1;
					do {
						const e$2 = r$1[l$1];
						c$1 = (o$1[n$1] - o$1[e$2] + a$2 - e$2 * e$2) / (n$1 - e$2) / 2;
					} while (c$1 <= s$1[l$1] && --l$1 > -1);
					l$1++, r$1[l$1] = n$1, s$1[l$1] = c$1, s$1[l$1 + 1] = T;
				}
				for (let n$1 = 0, l$1 = 0; n$1 < a$1; n$1++) {
					for (; s$1[l$1 + 1] < n$1;) l$1++;
					const a$2 = r$1[l$1], c$1 = n$1 - a$2;
					e$1[t$1 + n$1 * i$1] = o$1[a$2] + c$1 * c$1;
				}
			}
			const I = t.v.layout_symbol["text-font"].default.join(",");
			class M {
				constructor(e$1, t$1, i$1) {
					this.requestManager = e$1, this.localIdeographFontFamily = t$1, this.entries = {}, this.lang = i$1;
				}
				setURL(e$1) {
					this.url = e$1;
				}
				getGlyphs(e$1) {
					return t._(this, void 0, void 0, (function* () {
						const t$1 = [];
						for (const i$2 in e$1) for (const a$2 of e$1[i$2]) t$1.push(this._getAndCacheGlyphsPromise(i$2, a$2));
						const i$1 = yield Promise.all(t$1), a$1 = {};
						for (const { stack: e$2, id: t$2, glyph: o$1 } of i$1) a$1[e$2] || (a$1[e$2] = {}), a$1[e$2][t$2] = o$1 && {
							id: o$1.id,
							bitmap: o$1.bitmap.clone(),
							metrics: o$1.metrics
						};
						return a$1;
					}));
				}
				_getAndCacheGlyphsPromise(e$1, i$1) {
					return t._(this, void 0, void 0, (function* () {
						let t$1 = this.entries[e$1];
						t$1 || (t$1 = this.entries[e$1] = {
							glyphs: {},
							requests: {},
							ranges: {}
						});
						let a$1 = t$1.glyphs[i$1];
						return void 0 !== a$1 ? {
							stack: e$1,
							id: i$1,
							glyph: a$1
						} : !this.url || this._charUsesLocalIdeographFontFamily(i$1) ? (a$1 = t$1.glyphs[i$1] = this._drawGlyph(t$1, e$1, i$1), {
							stack: e$1,
							id: i$1,
							glyph: a$1
						}) : yield this._downloadAndCacheRangePromise(e$1, i$1);
					}));
				}
				_downloadAndCacheRangePromise(e$1, i$1) {
					return t._(this, void 0, void 0, (function* () {
						const t$1 = this.entries[e$1], a$1 = Math.floor(i$1 / 256);
						if (t$1.ranges[a$1]) return {
							stack: e$1,
							id: i$1,
							glyph: null
						};
						if (!t$1.requests[a$1]) {
							const i$2 = M.loadGlyphRange(e$1, a$1, this.url, this.requestManager);
							t$1.requests[a$1] = i$2;
						}
						try {
							const o$1 = yield t$1.requests[a$1];
							for (const e$2 in o$1) t$1.glyphs[+e$2] = o$1[+e$2];
							return t$1.ranges[a$1] = !0, {
								stack: e$1,
								id: i$1,
								glyph: o$1[i$1] || null
							};
						} catch (o$1) {
							const r$1 = t$1.glyphs[i$1] = this._drawGlyph(t$1, e$1, i$1);
							return this._warnOnMissingGlyphRange(r$1, a$1, i$1, o$1), {
								stack: e$1,
								id: i$1,
								glyph: r$1
							};
						}
					}));
				}
				_warnOnMissingGlyphRange(e$1, i$1, a$1, o$1) {
					const r$1 = 256 * i$1, s$1 = r$1 + 255, n$1 = a$1.toString(16).padStart(4, "0").toUpperCase();
					t.w(`Unable to load glyph range ${i$1}, ${r$1}-${s$1}. Rendering codepoint U+${n$1} locally instead. ${o$1}`);
				}
				_charUsesLocalIdeographFontFamily(e$1) {
					return !!this.localIdeographFontFamily && t.q(e$1);
				}
				_drawGlyph(e$1, i$1, a$1) {
					const o$1 = i$1 === I && "" !== this.localIdeographFontFamily && this._charUsesLocalIdeographFontFamily(a$1), r$1 = o$1 ? "ideographTinySDF" : "tinySDF";
					e$1[r$1] || (e$1[r$1] = this._createTinySDF(o$1 ? this.localIdeographFontFamily : i$1));
					const s$1 = e$1[r$1].draw(String.fromCodePoint(a$1)), n$1 = /^\p{gc=Cf}+$/u.test(String.fromCodePoint(a$1));
					return {
						id: a$1,
						bitmap: new t.r({
							width: s$1.width || 60,
							height: s$1.height || 60
						}, s$1.data),
						metrics: {
							width: n$1 ? 0 : s$1.glyphWidth / 2 || 24,
							height: s$1.glyphHeight / 2 || 24,
							left: s$1.glyphLeft / 2 + .5 || 0,
							top: s$1.glyphTop / 2 - 27.5 || -8,
							advance: n$1 ? 0 : s$1.glyphAdvance / 2 || 24,
							isDoubleResolution: !0
						}
					};
				}
				_createTinySDF(e$1) {
					const t$1 = e$1 ? e$1.split(",") : [];
					t$1.push("sans-serif");
					const i$1 = t$1.map(((e$2) => /[-\w]+/.test(e$2) ? e$2 : `'${CSS.escape(e$2)}'`)).join(",");
					return new M.TinySDF({
						fontSize: 48,
						buffer: 6,
						radius: 16,
						cutoff: .25,
						fontFamily: i$1,
						fontWeight: this._fontWeight(t$1[0]),
						fontStyle: this._fontStyle(t$1[0]),
						lang: this.lang
					});
				}
				_fontStyle(e$1) {
					return /italic/i.test(e$1) ? "italic" : /oblique/i.test(e$1) ? "oblique" : "normal";
				}
				_fontWeight(e$1) {
					const t$1 = {
						thin: 100,
						hairline: 100,
						"extra light": 200,
						"ultra light": 200,
						light: 300,
						normal: 400,
						regular: 400,
						medium: 500,
						semibold: 600,
						demibold: 600,
						bold: 700,
						"extra bold": 800,
						"ultra bold": 800,
						black: 900,
						heavy: 900,
						"extra black": 950,
						"ultra black": 950
					};
					let i$1;
					for (const [a$1, o$1] of Object.entries(t$1)) new RegExp(`\\b${a$1}\\b`, "i").test(e$1) && (i$1 = `${o$1}`);
					return i$1;
				}
				destroy() {
					for (const e$1 in this.entries) {
						const t$1 = this.entries[e$1];
						t$1.tinySDF && (t$1.tinySDF = null), t$1.ideographTinySDF && (t$1.ideographTinySDF = null), t$1.glyphs = {}, t$1.requests = {}, t$1.ranges = {};
					}
					this.entries = {};
				}
			}
			M.loadGlyphRange = function(e$1, i$1, a$1, o$1) {
				return t._(this, void 0, void 0, (function* () {
					const r$1 = 256 * i$1, s$1 = r$1 + 255, n$1 = o$1.transformRequest(a$1.replace("{fontstack}", e$1).replace("{range}", `${r$1}-${s$1}`), "Glyphs"), l$1 = yield t.n(n$1, new AbortController());
					if (!l$1 || !l$1.data) throw new Error(`Could not load glyph range. range: ${i$1}, ${r$1}-${s$1}`);
					const c$1 = {};
					for (const e$2 of t.o(l$1.data)) c$1[e$2.id] = e$2;
					return c$1;
				}));
			}, M.TinySDF = class {
				constructor({ fontSize: e$1 = 24, buffer: t$1 = 3, radius: i$1 = 8, cutoff: a$1 = .25, fontFamily: o$1 = "sans-serif", fontWeight: r$1 = "normal", fontStyle: s$1 = "normal", lang: n$1 = null } = {}) {
					this.buffer = t$1, this.cutoff = a$1, this.radius = i$1, this.lang = n$1;
					const l$1 = this.size = e$1 + 4 * t$1, h$1 = this.ctx = this._createCanvas(l$1).getContext("2d", { willReadFrequently: !0 });
					h$1.font = `${s$1} ${r$1} ${e$1}px ${o$1}`, h$1.textBaseline = "alphabetic", h$1.textAlign = "left", h$1.fillStyle = "black", this.gridOuter = new Float64Array(l$1 * l$1), this.gridInner = new Float64Array(l$1 * l$1), this.f = new Float64Array(l$1), this.z = new Float64Array(l$1 + 1), this.v = new Uint16Array(l$1);
				}
				_createCanvas(e$1) {
					const t$1 = document.createElement("canvas");
					return t$1.width = t$1.height = e$1, t$1;
				}
				draw(e$1) {
					const { width: t$1, actualBoundingBoxAscent: i$1, actualBoundingBoxDescent: a$1, actualBoundingBoxLeft: o$1, actualBoundingBoxRight: r$1 } = this.ctx.measureText(e$1), s$1 = Math.ceil(i$1), n$1 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(r$1 - o$1))), l$1 = Math.min(this.size - this.buffer, s$1 + Math.ceil(a$1)), c$1 = n$1 + 2 * this.buffer, h$1 = l$1 + 2 * this.buffer, u$1 = Math.max(c$1 * h$1, 0), d$1 = new Uint8ClampedArray(u$1), _$1 = {
						data: d$1,
						width: c$1,
						height: h$1,
						glyphWidth: n$1,
						glyphHeight: l$1,
						glyphTop: s$1,
						glyphLeft: 0,
						glyphAdvance: t$1
					};
					if (0 === n$1 || 0 === l$1) return _$1;
					const { ctx: p$1, buffer: m$1, gridInner: f$1, gridOuter: g$1 } = this;
					this.lang && (p$1.lang = this.lang), p$1.clearRect(m$1, m$1, n$1, l$1), p$1.fillText(e$1, m$1, m$1 + s$1);
					const v$1 = p$1.getImageData(m$1, m$1, n$1, l$1);
					g$1.fill(T, 0, u$1), f$1.fill(0, 0, u$1);
					for (let e$2 = 0; e$2 < l$1; e$2++) for (let t$2 = 0; t$2 < n$1; t$2++) {
						const i$2 = v$1.data[4 * (e$2 * n$1 + t$2) + 3] / 255;
						if (0 === i$2) continue;
						const a$2 = (e$2 + m$1) * c$1 + t$2 + m$1;
						if (1 === i$2) g$1[a$2] = 0, f$1[a$2] = T;
						else {
							const e$3 = .5 - i$2;
							g$1[a$2] = e$3 > 0 ? e$3 * e$3 : 0, f$1[a$2] = e$3 < 0 ? e$3 * e$3 : 0;
						}
					}
					P(g$1, 0, 0, c$1, h$1, c$1, this.f, this.v, this.z), P(f$1, m$1, m$1, n$1, l$1, c$1, this.f, this.v, this.z);
					for (let e$2 = 0; e$2 < u$1; e$2++) {
						const t$2 = Math.sqrt(g$1[e$2]) - Math.sqrt(f$1[e$2]);
						d$1[e$2] = Math.round(255 - 255 * (t$2 / this.radius + this.cutoff));
					}
					return _$1;
				}
			};
			class E {
				constructor() {
					this.specification = t.u.light.position;
				}
				possiblyEvaluate(e$1, i$1) {
					return t.F(e$1.expression.evaluate(i$1));
				}
				interpolate(e$1, i$1, a$1) {
					return {
						x: t.G.number(e$1.x, i$1.x, a$1),
						y: t.G.number(e$1.y, i$1.y, a$1),
						z: t.G.number(e$1.z, i$1.z, a$1)
					};
				}
			}
			let S;
			class z extends t.E {
				constructor(e$1) {
					super(), S = S || new t.t({
						anchor: new t.D(t.u.light.anchor),
						position: new E(),
						color: new t.D(t.u.light.color),
						intensity: new t.D(t.u.light.intensity)
					}), this._transitionable = new t.x(S, void 0), this.setLight(e$1), this._transitioning = this._transitionable.untransitioned();
				}
				getLight() {
					return this._transitionable.serialize();
				}
				setLight(e$1, i$1 = {}) {
					if (!this._validate(t.y, e$1, i$1)) for (const i$2 in e$1) {
						const a$1 = e$1[i$2];
						i$2.endsWith(t.z) ? this._transitionable.setTransition(i$2.slice(0, -t.z.length), a$1) : this._transitionable.setValue(i$2, a$1);
					}
				}
				updateTransitions(e$1) {
					this._transitioning = this._transitionable.transitioned(e$1, this._transitioning);
				}
				hasTransition() {
					return this._transitioning.hasTransition();
				}
				recalculate(e$1) {
					this.properties = this._transitioning.possiblyEvaluate(e$1);
				}
				_validate(e$1, i$1, a$1) {
					return (!a$1 || !1 !== a$1.validate) && t.B(this, e$1.call(t.C, {
						value: i$1,
						style: {
							glyphs: !0,
							sprite: !0
						},
						styleSpec: t.u
					}));
				}
			}
			const R = new t.t({
				"sky-color": new t.D(t.u.sky["sky-color"]),
				"horizon-color": new t.D(t.u.sky["horizon-color"]),
				"fog-color": new t.D(t.u.sky["fog-color"]),
				"fog-ground-blend": new t.D(t.u.sky["fog-ground-blend"]),
				"horizon-fog-blend": new t.D(t.u.sky["horizon-fog-blend"]),
				"sky-horizon-blend": new t.D(t.u.sky["sky-horizon-blend"]),
				"atmosphere-blend": new t.D(t.u.sky["atmosphere-blend"])
			});
			class D extends t.E {
				constructor(e$1) {
					super(), this._transitionable = new t.x(R, void 0), this.setSky(e$1), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new t.H(0));
				}
				setSky(e$1, i$1 = {}) {
					if (!this._validate(t.J, e$1, i$1)) {
						e$1 || (e$1 = {
							"sky-color": "transparent",
							"horizon-color": "transparent",
							"fog-color": "transparent",
							"fog-ground-blend": 1,
							"atmosphere-blend": 0
						});
						for (const i$2 in e$1) {
							const a$1 = e$1[i$2];
							i$2.endsWith(t.z) ? this._transitionable.setTransition(i$2.slice(0, -t.z.length), a$1) : this._transitionable.setValue(i$2, a$1);
						}
					}
				}
				getSky() {
					return this._transitionable.serialize();
				}
				updateTransitions(e$1) {
					this._transitioning = this._transitionable.transitioned(e$1, this._transitioning);
				}
				hasTransition() {
					return this._transitioning.hasTransition();
				}
				recalculate(e$1) {
					this.properties = this._transitioning.possiblyEvaluate(e$1);
				}
				_validate(e$1, i$1, a$1 = {}) {
					return !1 !== (null == a$1 ? void 0 : a$1.validate) && t.B(this, e$1.call(t.C, t.e({
						value: i$1,
						style: {
							glyphs: !0,
							sprite: !0
						},
						styleSpec: t.u
					})));
				}
				calculateFogBlendOpacity(e$1) {
					return e$1 < 60 ? 0 : e$1 < 70 ? (e$1 - 60) / 10 : 1;
				}
			}
			class A {
				constructor(e$1, t$1) {
					this.width = e$1, this.height = t$1, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
				}
				getDash(e$1, t$1) {
					const i$1 = e$1.join(",") + String(t$1);
					return this.dashEntry[i$1] || (this.dashEntry[i$1] = this.addDash(e$1, t$1)), this.dashEntry[i$1];
				}
				getDashRanges(e$1, t$1, i$1) {
					const a$1 = [];
					let o$1 = e$1.length % 2 == 1 ? -e$1[e$1.length - 1] * i$1 : 0, r$1 = e$1[0] * i$1, s$1 = !0;
					a$1.push({
						left: o$1,
						right: r$1,
						isDash: s$1,
						zeroLength: 0 === e$1[0]
					});
					let n$1 = e$1[0];
					for (let t$2 = 1; t$2 < e$1.length; t$2++) {
						s$1 = !s$1;
						const l$1 = e$1[t$2];
						o$1 = n$1 * i$1, n$1 += l$1, r$1 = n$1 * i$1, a$1.push({
							left: o$1,
							right: r$1,
							isDash: s$1,
							zeroLength: 0 === l$1
						});
					}
					return a$1;
				}
				addRoundDash(e$1, t$1, i$1) {
					const a$1 = t$1 / 2;
					for (let t$2 = -i$1; t$2 <= i$1; t$2++) {
						const o$1 = this.width * (this.nextRow + i$1 + t$2);
						let r$1 = 0, s$1 = e$1[r$1];
						for (let n$1 = 0; n$1 < this.width; n$1++) {
							n$1 / s$1.right > 1 && (s$1 = e$1[++r$1]);
							const l$1 = Math.abs(n$1 - s$1.left), c$1 = Math.abs(n$1 - s$1.right), h$1 = Math.min(l$1, c$1);
							let u$1;
							const d$1 = t$2 / i$1 * (a$1 + 1);
							if (s$1.isDash) {
								const e$2 = a$1 - Math.abs(d$1);
								u$1 = Math.sqrt(h$1 * h$1 + e$2 * e$2);
							} else u$1 = a$1 - Math.sqrt(h$1 * h$1 + d$1 * d$1);
							this.data[o$1 + n$1] = Math.max(0, Math.min(255, u$1 + 128));
						}
					}
				}
				addRegularDash(e$1) {
					for (let t$2 = e$1.length - 1; t$2 >= 0; --t$2) {
						const i$2 = e$1[t$2], a$2 = e$1[t$2 + 1];
						i$2.zeroLength ? e$1.splice(t$2, 1) : a$2 && a$2.isDash === i$2.isDash && (a$2.left = i$2.left, e$1.splice(t$2, 1));
					}
					const t$1 = e$1[0], i$1 = e$1[e$1.length - 1];
					t$1.isDash === i$1.isDash && (t$1.left = i$1.left - this.width, i$1.right = t$1.right + this.width);
					const a$1 = this.width * this.nextRow;
					let o$1 = 0, r$1 = e$1[o$1];
					for (let t$2 = 0; t$2 < this.width; t$2++) {
						t$2 / r$1.right > 1 && (r$1 = e$1[++o$1]);
						const i$2 = Math.abs(t$2 - r$1.left), s$1 = Math.abs(t$2 - r$1.right), n$1 = Math.min(i$2, s$1);
						this.data[a$1 + t$2] = Math.max(0, Math.min(255, (r$1.isDash ? n$1 : -n$1) + 128));
					}
				}
				addDash(e$1, i$1) {
					const a$1 = i$1 ? 7 : 0, o$1 = 2 * a$1 + 1;
					if (this.nextRow + o$1 > this.height) return t.w("LineAtlas out of space"), null;
					let r$1 = 0;
					for (let t$1 = 0; t$1 < e$1.length; t$1++) r$1 += e$1[t$1];
					if (0 !== r$1) {
						const t$1 = this.width / r$1, o$2 = this.getDashRanges(e$1, this.width, t$1);
						i$1 ? this.addRoundDash(o$2, t$1, a$1) : this.addRegularDash(o$2);
					}
					const s$1 = {
						y: this.nextRow + a$1,
						height: 2 * a$1,
						width: r$1
					};
					return this.nextRow += o$1, this.dirty = !0, s$1;
				}
				bind(e$1) {
					const t$1 = e$1.gl;
					this.texture ? (t$1.bindTexture(t$1.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, t$1.texSubImage2D(t$1.TEXTURE_2D, 0, 0, 0, this.width, this.height, t$1.ALPHA, t$1.UNSIGNED_BYTE, this.data))) : (this.texture = t$1.createTexture(), t$1.bindTexture(t$1.TEXTURE_2D, this.texture), t$1.texParameteri(t$1.TEXTURE_2D, t$1.TEXTURE_WRAP_S, t$1.REPEAT), t$1.texParameteri(t$1.TEXTURE_2D, t$1.TEXTURE_WRAP_T, t$1.REPEAT), t$1.texParameteri(t$1.TEXTURE_2D, t$1.TEXTURE_MIN_FILTER, t$1.LINEAR), t$1.texParameteri(t$1.TEXTURE_2D, t$1.TEXTURE_MAG_FILTER, t$1.LINEAR), t$1.texImage2D(t$1.TEXTURE_2D, 0, t$1.ALPHA, this.width, this.height, 0, t$1.ALPHA, t$1.UNSIGNED_BYTE, this.data));
				}
			}
			const L = "maplibre_preloaded_worker_pool";
			class k {
				constructor() {
					this.active = {};
				}
				acquire(e$1) {
					if (!this.workers) for (this.workers = []; this.workers.length < k.workerCount;) this.workers.push(new Worker(t.c.WORKER_URL));
					return this.active[e$1] = !0, this.workers.slice();
				}
				release(e$1) {
					delete this.active[e$1], 0 === this.numActive() && (this.workers.forEach(((e$2) => {
						e$2.terminate();
					})), this.workers = null);
				}
				isPreloaded() {
					return !!this.active[L];
				}
				numActive() {
					return Object.keys(this.active).length;
				}
			}
			const F = Math.floor(n.hardwareConcurrency / 2);
			let B, O;
			function j() {
				return B || (B = new k()), B;
			}
			k.workerCount = t.K(globalThis) ? Math.max(Math.min(F, 3), 1) : 1;
			class N {
				constructor(e$1, i$1) {
					this.workerPool = e$1, this.actors = [], this.currentActor = 0, this.id = i$1;
					const a$1 = this.workerPool.acquire(i$1);
					for (let e$2 = 0; e$2 < a$1.length; e$2++) {
						const o$1 = new t.L(a$1[e$2], i$1);
						o$1.name = `Worker ${e$2}`, this.actors.push(o$1);
					}
					if (!this.actors.length) throw new Error("No actors found");
				}
				broadcast(e$1, t$1) {
					const i$1 = [];
					for (const a$1 of this.actors) i$1.push(a$1.sendAsync({
						type: e$1,
						data: t$1
					}));
					return Promise.all(i$1);
				}
				getActor() {
					return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
				}
				remove(e$1 = !0) {
					this.actors.forEach(((e$2) => {
						e$2.remove();
					})), this.actors = [], e$1 && this.workerPool.release(this.id);
				}
				registerMessageHandler(e$1, t$1) {
					for (const i$1 of this.actors) i$1.registerMessageHandler(e$1, t$1);
				}
				unregisterMessageHandler(e$1) {
					for (const t$1 of this.actors) t$1.unregisterMessageHandler(e$1);
				}
			}
			function Z() {
				return O || (O = new N(j(), t.M), O.registerMessageHandler("GR", ((e$1, i$1, a$1) => t.m(i$1, a$1)))), O;
			}
			function U(e$1, i$1) {
				const a$1 = t.N();
				return t.O(a$1, a$1, [
					1,
					1,
					0
				]), t.Q(a$1, a$1, [
					.5 * e$1.width,
					.5 * e$1.height,
					1
				]), e$1.calculatePosMatrix ? t.S(a$1, a$1, e$1.calculatePosMatrix(i$1.toUnwrapped())) : a$1;
			}
			function G(e$1, t$1, i$1, a$1, o$1, r$1, s$1) {
				var n$1;
				const l$1 = function(e$2, t$2, i$2) {
					if (e$2) for (const a$2 of e$2) {
						const e$3 = t$2[a$2];
						if (e$3 && e$3.source === i$2 && "fill-extrusion" === e$3.type) return !0;
					}
					else for (const e$3 in t$2) {
						const a$2 = t$2[e$3];
						if (a$2.source === i$2 && "fill-extrusion" === a$2.type) return !0;
					}
					return !1;
				}(null !== (n$1 = null == o$1 ? void 0 : o$1.layers) && void 0 !== n$1 ? n$1 : null, t$1, e$1.id), c$1 = r$1.maxPitchScaleFactor(), h$1 = e$1.tilesIn(a$1, c$1, l$1);
				h$1.sort(V);
				const u$1 = [];
				for (const a$2 of h$1) u$1.push({
					wrappedTileID: a$2.tileID.wrapped().key,
					queryResults: a$2.tile.queryRenderedFeatures(t$1, i$1, e$1.getState(), a$2.queryGeometry, a$2.cameraQueryGeometry, a$2.scale, o$1, r$1, c$1, U(r$1, a$2.tileID), s$1 ? (e$2, t$2) => s$1(a$2.tileID, e$2, t$2) : void 0)
				});
				return function(e$2, t$2) {
					for (const i$2 in e$2) for (const a$2 of e$2[i$2]) q(a$2, t$2);
					return e$2;
				}(function(e$2) {
					const t$2 = {}, i$2 = {};
					for (const a$2 of e$2) {
						const e$3 = a$2.queryResults, o$2 = a$2.wrappedTileID, r$2 = i$2[o$2] = i$2[o$2] || {};
						for (const i$3 in e$3) {
							const a$3 = e$3[i$3], o$3 = r$2[i$3] = r$2[i$3] || {}, s$2 = t$2[i$3] = t$2[i$3] || [];
							for (const e$4 of a$3) o$3[e$4.featureIndex] || (o$3[e$4.featureIndex] = !0, s$2.push(e$4));
						}
					}
					return t$2;
				}(u$1), e$1);
			}
			function V(e$1, t$1) {
				const i$1 = e$1.tileID, a$1 = t$1.tileID;
				return i$1.overscaledZ - a$1.overscaledZ || i$1.canonical.y - a$1.canonical.y || i$1.wrap - a$1.wrap || i$1.canonical.x - a$1.canonical.x;
			}
			function q(e$1, t$1) {
				const i$1 = e$1.feature, a$1 = t$1.getFeatureState(i$1.layer["source-layer"], i$1.id);
				i$1.source = i$1.layer.source, i$1.layer["source-layer"] && (i$1.sourceLayer = i$1.layer["source-layer"]), i$1.state = a$1;
			}
			function W(e$1, i$1, a$1, o$1) {
				return t._(this, void 0, void 0, (function* () {
					let r$1 = e$1;
					if (e$1.url ? r$1 = (yield t.j(i$1.transformRequest(e$1.url, "Source"), a$1)).data : yield n.frameAsync(a$1, o$1), !r$1) return null;
					const s$1 = t.U(t.e(r$1, e$1), [
						"tiles",
						"minzoom",
						"maxzoom",
						"attribution",
						"bounds",
						"scheme",
						"tileSize",
						"encoding"
					]);
					return "vector_layers" in r$1 && r$1.vector_layers && (s$1.vectorLayerIds = r$1.vector_layers.map(((e$2) => e$2.id))), s$1;
				}));
			}
			class $ {
				constructor(e$1, t$1) {
					e$1 && (t$1 ? this.setSouthWest(e$1).setNorthEast(t$1) : Array.isArray(e$1) && (4 === e$1.length ? this.setSouthWest([e$1[0], e$1[1]]).setNorthEast([e$1[2], e$1[3]]) : this.setSouthWest(e$1[0]).setNorthEast(e$1[1])));
				}
				setNorthEast(e$1) {
					return this._ne = e$1 instanceof t.V ? new t.V(e$1.lng, e$1.lat) : t.V.convert(e$1), this;
				}
				setSouthWest(e$1) {
					return this._sw = e$1 instanceof t.V ? new t.V(e$1.lng, e$1.lat) : t.V.convert(e$1), this;
				}
				extend(e$1) {
					const i$1 = this._sw, a$1 = this._ne;
					let o$1, r$1;
					if (e$1 instanceof t.V) o$1 = e$1, r$1 = e$1;
					else {
						if (!(e$1 instanceof $)) return Array.isArray(e$1) ? 4 === e$1.length || e$1.every(Array.isArray) ? this.extend($.convert(e$1)) : this.extend(t.V.convert(e$1)) : e$1 && ("lng" in e$1 || "lon" in e$1) && "lat" in e$1 ? this.extend(t.V.convert(e$1)) : this;
						if (o$1 = e$1._sw, r$1 = e$1._ne, !o$1 || !r$1) return this;
					}
					return i$1 || a$1 ? (i$1.lng = Math.min(o$1.lng, i$1.lng), i$1.lat = Math.min(o$1.lat, i$1.lat), a$1.lng = Math.max(r$1.lng, a$1.lng), a$1.lat = Math.max(r$1.lat, a$1.lat)) : (this._sw = new t.V(o$1.lng, o$1.lat), this._ne = new t.V(r$1.lng, r$1.lat)), this;
				}
				getCenter() {
					return new t.V((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
				}
				getSouthWest() {
					return this._sw;
				}
				getNorthEast() {
					return this._ne;
				}
				getNorthWest() {
					return new t.V(this.getWest(), this.getNorth());
				}
				getSouthEast() {
					return new t.V(this.getEast(), this.getSouth());
				}
				getWest() {
					return this._sw.lng;
				}
				getSouth() {
					return this._sw.lat;
				}
				getEast() {
					return this._ne.lng;
				}
				getNorth() {
					return this._ne.lat;
				}
				toArray() {
					return [this._sw.toArray(), this._ne.toArray()];
				}
				toString() {
					return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
				}
				isEmpty() {
					return !(this._sw && this._ne);
				}
				contains(e$1) {
					const { lng: i$1, lat: a$1 } = t.V.convert(e$1);
					let o$1 = this._sw.lng <= i$1 && i$1 <= this._ne.lng;
					return this._sw.lng > this._ne.lng && (o$1 = this._sw.lng >= i$1 && i$1 >= this._ne.lng), this._sw.lat <= a$1 && a$1 <= this._ne.lat && o$1;
				}
				intersects(e$1) {
					if (!((e$1 = $.convert(e$1)).getNorth() >= this.getSouth() && e$1.getSouth() <= this.getNorth())) return !1;
					const i$1 = Math.abs(this.getEast() - this.getWest()), a$1 = Math.abs(e$1.getEast() - e$1.getWest());
					if (i$1 >= 360 || a$1 >= 360) return !0;
					const o$1 = t.W(this.getWest(), -180, 180), r$1 = t.W(this.getEast(), -180, 180), s$1 = t.W(e$1.getWest(), -180, 180), n$1 = t.W(e$1.getEast(), -180, 180), l$1 = o$1 >= r$1, c$1 = s$1 >= n$1;
					return !(!l$1 || !c$1) || (l$1 ? n$1 >= o$1 || s$1 <= r$1 : c$1 ? r$1 >= s$1 || o$1 <= n$1 : s$1 <= r$1 && n$1 >= o$1);
				}
				static convert(e$1) {
					return e$1 instanceof $ ? e$1 : e$1 ? new $(e$1) : e$1;
				}
				static fromLngLat(e$1, i$1 = 0) {
					const a$1 = 360 * i$1 / 40075017, o$1 = a$1 / Math.cos(Math.PI / 180 * e$1.lat);
					return new $(new t.V(e$1.lng - o$1, e$1.lat - a$1), new t.V(e$1.lng + o$1, e$1.lat + a$1));
				}
				adjustAntiMeridian() {
					const e$1 = new t.V(this._sw.lng, this._sw.lat), i$1 = new t.V(this._ne.lng, this._ne.lat);
					return new $(e$1, e$1.lng > i$1.lng ? new t.V(i$1.lng + 360, i$1.lat) : i$1);
				}
			}
			class H {
				constructor(e$1, t$1, i$1) {
					this.bounds = $.convert(this.validateBounds(e$1)), this.minzoom = t$1 || 0, this.maxzoom = i$1 || 24;
				}
				validateBounds(e$1) {
					return Array.isArray(e$1) && 4 === e$1.length ? [
						Math.max(-180, e$1[0]),
						Math.max(-90, e$1[1]),
						Math.min(180, e$1[2]),
						Math.min(90, e$1[3])
					] : [
						-180,
						-90,
						180,
						90
					];
				}
				contains(e$1) {
					const i$1 = Math.pow(2, e$1.z), a$1 = Math.floor(t.Y(this.bounds.getWest()) * i$1), o$1 = Math.floor(t.X(this.bounds.getNorth()) * i$1), r$1 = Math.ceil(t.Y(this.bounds.getEast()) * i$1), s$1 = Math.ceil(t.X(this.bounds.getSouth()) * i$1);
					return e$1.x >= a$1 && e$1.x < r$1 && e$1.y >= o$1 && e$1.y < s$1;
				}
			}
			class X extends t.E {
				constructor(e$1, i$1, a$1, o$1) {
					if (super(), this.id = e$1, this.dispatcher = a$1, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, t.e(this, t.U(i$1, [
						"url",
						"scheme",
						"tileSize",
						"promoteId",
						"encoding"
					])), this._options = t.e({ type: "vector" }, i$1), this._collectResourceTiming = i$1.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
					this.setEventedParent(o$1);
				}
				load() {
					return t._(this, void 0, void 0, (function* () {
						this._loaded = !1, this.fire(new t.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
						try {
							const e$1 = yield W(this._options, this.map._requestManager, this._tileJSONRequest, this.map._ownerWindow);
							this._tileJSONRequest = null, this._loaded = !0, this.map.style.tileManagers[this.id].clearTiles(), e$1 && (t.e(this, e$1), e$1.bounds && (this.tileBounds = new H(e$1.bounds, this.minzoom, this.maxzoom)), this.fire(new t.l("data", {
								dataType: "source",
								sourceDataType: "metadata"
							})), this.fire(new t.l("data", {
								dataType: "source",
								sourceDataType: "content"
							})));
						} catch (e$1) {
							this._tileJSONRequest = null, this._loaded = !0, t.Z(e$1) || this.fire(new t.k(e$1));
						}
					}));
				}
				loaded() {
					return this._loaded;
				}
				hasTile(e$1) {
					return !this.tileBounds || this.tileBounds.contains(e$1.canonical);
				}
				onAdd(e$1) {
					this.map = e$1, this.load();
				}
				setSourceProperty(e$1) {
					this._tileJSONRequest && this._tileJSONRequest.abort(), e$1(), this.load();
				}
				setTiles(e$1) {
					return this.setSourceProperty((() => {
						this._options.tiles = e$1;
					})), this;
				}
				setUrl(e$1) {
					return this.setSourceProperty((() => {
						this.url = e$1, this._options.url = e$1;
					})), this;
				}
				onRemove() {
					this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
				}
				serialize() {
					return t.e({}, this._options);
				}
				loadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						const t$1 = e$1.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), i$1 = {
							request: this.map._requestManager.transformRequest(t$1, "Tile"),
							uid: e$1.uid,
							tileID: e$1.tileID,
							zoom: e$1.tileID.overscaledZ,
							tileSize: this.tileSize * e$1.tileID.overscaleFactor(),
							type: this.type,
							source: this.id,
							pixelRatio: this.map.getPixelRatio(),
							showCollisionBoxes: this.map.showCollisionBoxes,
							promoteId: this.promoteId,
							subdivisionGranularity: this.map.style.projection.subdivisionGranularity,
							encoding: this.encoding,
							overzoomParameters: this._getOverzoomParameters(e$1)
						};
						i$1.request.collectResourceTiming = this._collectResourceTiming;
						let a$1 = "RT";
						if (e$1.actor && "expired" !== e$1.state) {
							if ("loading" === e$1.state) return new Promise(((t$2, i$2) => {
								e$1.reloadPromise = {
									resolve: t$2,
									reject: i$2
								};
							}));
						} else e$1.actor = this.dispatcher.getActor(), a$1 = "LT";
						e$1.abortController = new AbortController();
						try {
							const t$2 = yield e$1.actor.sendAsync({
								type: a$1,
								data: i$1
							}, e$1.abortController);
							if (delete e$1.abortController, e$1.aborted) return;
							this._afterTileLoadWorkerResponse(e$1, t$2);
						} catch (t$2) {
							if (delete e$1.abortController, e$1.aborted) return;
							if (t$2 && 404 !== t$2.status) throw t$2;
							this._afterTileLoadWorkerResponse(e$1, null);
						}
					}));
				}
				_getOverzoomParameters(e$1) {
					if (e$1.tileID.canonical.z <= this.maxzoom) return;
					if (void 0 === this.map._zoomLevelsToOverscale) return;
					const t$1 = e$1.tileID.scaledTo(this.maxzoom).canonical, i$1 = t$1.url(this.tiles, this.map.getPixelRatio(), this.scheme);
					return {
						maxZoomTileID: t$1,
						overzoomRequest: this.map._requestManager.transformRequest(i$1, "Tile")
					};
				}
				_afterTileLoadWorkerResponse(e$1, t$1) {
					if (t$1 && t$1.resourceTiming && (e$1.resourceTiming = t$1.resourceTiming), t$1 && this.map._refreshExpiredTiles && e$1.setExpiryData(t$1), e$1.loadVectorData(t$1, this.map.painter), e$1.reloadPromise) {
						const t$2 = e$1.reloadPromise;
						e$1.reloadPromise = null, this.loadTile(e$1).then(t$2.resolve).catch(t$2.reject);
					}
				}
				abortTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.abortController && (e$1.abortController.abort(), delete e$1.abortController), e$1.actor && (yield e$1.actor.sendAsync({
							type: "AT",
							data: {
								uid: e$1.uid,
								type: this.type,
								source: this.id
							}
						}));
					}));
				}
				unloadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.unloadVectorData(), e$1.actor && (yield e$1.actor.sendAsync({
							type: "RMT",
							data: {
								uid: e$1.uid,
								type: this.type,
								source: this.id
							}
						}));
					}));
				}
				hasTransition() {
					return !1;
				}
			}
			class K extends t.E {
				constructor(e$1, i$1, a$1, o$1) {
					super(), this.id = e$1, this.dispatcher = a$1, this.setEventedParent(o$1), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = t.e({ type: "raster" }, i$1), t.e(this, t.U(i$1, [
						"url",
						"scheme",
						"tileSize"
					]));
				}
				load() {
					return t._(this, arguments, void 0, (function* (e$1 = !1) {
						this._loaded = !1, this.fire(new t.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
						try {
							const i$1 = yield W(this._options, this.map._requestManager, this._tileJSONRequest, this.map._ownerWindow);
							this._tileJSONRequest = null, this._loaded = !0, i$1 && (t.e(this, i$1), i$1.bounds && (this.tileBounds = new H(i$1.bounds, this.minzoom, this.maxzoom)), this.fire(new t.l("data", {
								dataType: "source",
								sourceDataType: "metadata"
							})), this.fire(new t.l("data", {
								dataType: "source",
								sourceDataType: "content",
								sourceDataChanged: e$1
							})));
						} catch (e$2) {
							this._tileJSONRequest = null, this._loaded = !0, t.Z(e$2) || this.fire(new t.k(e$2));
						}
					}));
				}
				loaded() {
					return this._loaded;
				}
				onAdd(e$1) {
					this.map = e$1, this.load();
				}
				onRemove() {
					this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
				}
				setSourceProperty(e$1) {
					this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e$1(), this.load(!0);
				}
				setTiles(e$1) {
					return this.setSourceProperty((() => {
						this._options.tiles = e$1;
					})), this;
				}
				setUrl(e$1) {
					return this.setSourceProperty((() => {
						this.url = e$1, this._options.url = e$1;
					})), this;
				}
				serialize() {
					return t.e({}, this._options);
				}
				hasTile(e$1) {
					return !this.tileBounds || this.tileBounds.contains(e$1.canonical);
				}
				loadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						const i$1 = e$1.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
						e$1.abortController = new AbortController();
						try {
							const a$1 = yield g.getImage(this.map._requestManager.transformRequest(i$1, "Tile"), e$1.abortController, this.map._refreshExpiredTiles);
							if (delete e$1.abortController, e$1.aborted) return void (e$1.state = "unloaded");
							if (a$1 && a$1.data) {
								this.map._refreshExpiredTiles && (a$1.cacheControl || a$1.expires) && e$1.setExpiryData({
									cacheControl: a$1.cacheControl,
									expires: a$1.expires
								});
								const i$2 = this.map.painter.context, o$1 = i$2.gl, r$1 = a$1.data;
								e$1.texture = this.map.painter.getTileTexture(r$1.width), e$1.texture ? e$1.texture.update(r$1, { useMipmap: !0 }) : (e$1.texture = new t.T(i$2, r$1, o$1.RGBA, { useMipmap: !0 }), e$1.texture.bind(o$1.LINEAR, o$1.CLAMP_TO_EDGE, o$1.LINEAR_MIPMAP_NEAREST)), e$1.state = "loaded";
							}
						} catch (t$1) {
							if (delete e$1.abortController, e$1.aborted) e$1.state = "unloaded";
							else if (t$1) throw e$1.state = "errored", t$1;
						}
					}));
				}
				abortTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.abortController && (e$1.abortController.abort(), delete e$1.abortController);
					}));
				}
				unloadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.texture && this.map.painter.saveTileTexture(e$1.texture);
					}));
				}
				hasTransition() {
					return !1;
				}
			}
			class Y extends K {
				constructor(e$1, i$1, a$1, o$1) {
					super(e$1, i$1, a$1, o$1), this.type = "raster-dem", this.maxzoom = 22, this._options = t.e({ type: "raster-dem" }, i$1), this.encoding = i$1.encoding || "mapbox", this.redFactor = i$1.redFactor, this.greenFactor = i$1.greenFactor, this.blueFactor = i$1.blueFactor, this.baseShift = i$1.baseShift;
				}
				loadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						const i$1 = e$1.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), a$1 = this.map._requestManager.transformRequest(i$1, "Tile");
						e$1.neighboringTiles = this._getNeighboringTiles(e$1.tileID), e$1.abortController = new AbortController();
						try {
							const i$2 = yield g.getImage(a$1, e$1.abortController, this.map._refreshExpiredTiles);
							if (delete e$1.abortController, e$1.aborted) return void (e$1.state = "unloaded");
							if (i$2 && i$2.data) {
								const a$2 = i$2.data;
								this.map._refreshExpiredTiles && (i$2.cacheControl || i$2.expires) && e$1.setExpiryData({
									cacheControl: i$2.cacheControl,
									expires: i$2.expires
								});
								const o$1 = t.b(a$2) && t.$() ? a$2 : yield this.readImageNow(a$2), r$1 = {
									type: this.type,
									uid: e$1.uid,
									source: this.id,
									rawImageData: o$1,
									encoding: this.encoding,
									redFactor: this.redFactor,
									greenFactor: this.greenFactor,
									blueFactor: this.blueFactor,
									baseShift: this.baseShift
								};
								if (!e$1.actor || "expired" === e$1.state) {
									e$1.actor = this.dispatcher.getActor();
									e$1.dem = yield e$1.actor.sendAsync({
										type: "LDT",
										data: r$1
									}), e$1.needsHillshadePrepare = !0, e$1.needsTerrainPrepare = !0, e$1.state = "loaded";
								}
							}
						} catch (t$1) {
							if (delete e$1.abortController, e$1.aborted) e$1.state = "unloaded";
							else if (t$1) throw e$1.state = "errored", t$1;
						}
					}));
				}
				readImageNow(e$1) {
					return t._(this, void 0, void 0, (function* () {
						if ("undefined" != typeof VideoFrame && t.a0()) {
							const i$1 = e$1.width + 2, a$1 = e$1.height + 2;
							try {
								return new t.R({
									width: i$1,
									height: a$1
								}, yield t.a1(e$1, -1, -1, i$1, a$1));
							} catch (e$2) {}
						}
						return n.getImageData(e$1, 1);
					}));
				}
				_getNeighboringTiles(e$1) {
					const i$1 = e$1.canonical, a$1 = Math.pow(2, i$1.z), o$1 = (i$1.x - 1 + a$1) % a$1, r$1 = 0 === i$1.x ? e$1.wrap - 1 : e$1.wrap, s$1 = (i$1.x + 1 + a$1) % a$1, n$1 = i$1.x + 1 === a$1 ? e$1.wrap + 1 : e$1.wrap, l$1 = {};
					return l$1[new t.a2(e$1.overscaledZ, r$1, i$1.z, o$1, i$1.y).key] = { backfilled: !1 }, l$1[new t.a2(e$1.overscaledZ, n$1, i$1.z, s$1, i$1.y).key] = { backfilled: !1 }, i$1.y > 0 && (l$1[new t.a2(e$1.overscaledZ, r$1, i$1.z, o$1, i$1.y - 1).key] = { backfilled: !1 }, l$1[new t.a2(e$1.overscaledZ, e$1.wrap, i$1.z, i$1.x, i$1.y - 1).key] = { backfilled: !1 }, l$1[new t.a2(e$1.overscaledZ, n$1, i$1.z, s$1, i$1.y - 1).key] = { backfilled: !1 }), i$1.y + 1 < a$1 && (l$1[new t.a2(e$1.overscaledZ, r$1, i$1.z, o$1, i$1.y + 1).key] = { backfilled: !1 }, l$1[new t.a2(e$1.overscaledZ, e$1.wrap, i$1.z, i$1.x, i$1.y + 1).key] = { backfilled: !1 }, l$1[new t.a2(e$1.overscaledZ, n$1, i$1.z, s$1, i$1.y + 1).key] = { backfilled: !1 }), l$1;
				}
				unloadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.demTexture && this.map.painter.saveTileTexture(e$1.demTexture), e$1.fbo && (e$1.fbo.destroy(), delete e$1.fbo), e$1.dem && delete e$1.dem, delete e$1.neighboringTiles, e$1.state = "unloaded", e$1.actor && (yield e$1.actor.sendAsync({
							type: "RDT",
							data: {
								type: this.type,
								uid: e$1.uid,
								source: this.id
							}
						}));
					}));
				}
			}
			function Q(e$1) {
				return "GeometryCollection" === e$1.type ? e$1.geometries.map(((e$2) => e$2.coordinates)).flat(Infinity) : e$1.coordinates.flat(Infinity);
			}
			function J(e$1) {
				const t$1 = new $();
				let i$1;
				switch (e$1.type) {
					case "FeatureCollection":
						i$1 = e$1.features.map(((e$2) => Q(e$2.geometry))).flat(Infinity);
						break;
					case "Feature":
						i$1 = Q(e$1.geometry);
						break;
					default: i$1 = Q(e$1);
				}
				if (0 == i$1.length) return t$1;
				for (let e$2 = 0; e$2 < i$1.length - 1; e$2 += 2) t$1.extend([i$1[e$2], i$1[e$2 + 1]]);
				return t$1;
			}
			class ee extends t.E {
				constructor(e$1, i$1, a$1, o$1) {
					super(), this.id = e$1, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._isUpdatingWorker = !1, this._pendingWorkerUpdate = { data: i$1.data }, this.actor = a$1.getActor(), this.setEventedParent(o$1), this._data = "string" == typeof i$1.data ? { url: i$1.data } : { geojson: i$1.data }, this._options = t.e({}, i$1), this._collectResourceTiming = i$1.collectResourceTiming, void 0 !== i$1.maxzoom && (this.maxzoom = i$1.maxzoom), i$1.type && (this.type = i$1.type), i$1.attribution && (this.attribution = i$1.attribution), this.promoteId = i$1.promoteId, void 0 !== i$1.clusterMaxZoom && this.maxzoom <= i$1.clusterMaxZoom && t.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${i$1.clusterMaxZoom}".`), this.workerOptions = t.e({
						source: this.id,
						cluster: i$1.cluster || !1,
						geojsonVtOptions: {
							buffer: this._pixelsToTileUnits(void 0 !== i$1.buffer ? i$1.buffer : 128),
							tolerance: this._pixelsToTileUnits(void 0 !== i$1.tolerance ? i$1.tolerance : .375),
							extent: t.a5,
							maxZoom: this.maxzoom,
							lineMetrics: i$1.lineMetrics || !1,
							generateId: i$1.generateId || !1
						},
						superclusterOptions: {
							maxZoom: this._getClusterMaxZoom(i$1.clusterMaxZoom),
							minPoints: Math.max(2, i$1.clusterMinPoints || 2),
							extent: t.a5,
							radius: this._pixelsToTileUnits(i$1.clusterRadius || 50),
							log: !1,
							generateId: i$1.generateId || !1
						},
						clusterProperties: i$1.clusterProperties,
						filter: i$1.filter
					}, i$1.workerOptions), "string" == typeof this.promoteId && (this.workerOptions.promoteId = this.promoteId);
				}
				_hasPendingWorkerUpdate() {
					return void 0 !== this._pendingWorkerUpdate.data || void 0 !== this._pendingWorkerUpdate.diff || this._pendingWorkerUpdate.optionsChanged;
				}
				_pixelsToTileUnits(e$1) {
					return e$1 * (t.a5 / this.tileSize);
				}
				_getClusterMaxZoom(e$1) {
					const i$1 = e$1 ? Math.round(e$1) : this.maxzoom - 1;
					return Number.isInteger(e$1) || void 0 === e$1 || t.w(`Integer expected for option 'clusterMaxZoom': provided value "${e$1}" rounded to "${i$1}"`), i$1;
				}
				load() {
					return t._(this, void 0, void 0, (function* () {
						yield this._updateWorkerData();
					}));
				}
				onAdd(e$1) {
					this.map = e$1, this.load();
				}
				setData(e$1, t$1) {
					this._data = "string" == typeof e$1 ? { url: e$1 } : { geojson: e$1 }, this._pendingWorkerUpdate = { data: e$1 };
					const i$1 = this._updateWorkerData();
					return t$1 ? i$1 : this;
				}
				updateData(e$1, i$1) {
					this._pendingWorkerUpdate.diff = t.a6(this._pendingWorkerUpdate.diff, e$1);
					const a$1 = this._updateWorkerData();
					return i$1 ? a$1 : this;
				}
				getData() {
					return t._(this, void 0, void 0, (function* () {
						const e$1 = t.e({ type: this.type }, this.workerOptions);
						return this.actor.sendAsync({
							type: "GD",
							data: e$1
						});
					}));
				}
				getBounds() {
					return t._(this, void 0, void 0, (function* () {
						return J(yield this.getData());
					}));
				}
				setClusterOptions(e$1) {
					return this.workerOptions.cluster = e$1.cluster, void 0 !== e$1.clusterRadius && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e$1.clusterRadius)), void 0 !== e$1.clusterMaxZoom && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e$1.clusterMaxZoom)), this._pendingWorkerUpdate.optionsChanged = !0, this._updateWorkerData(), this;
				}
				getClusterExpansionZoom(e$1) {
					return this.actor.sendAsync({
						type: "GCEZ",
						data: {
							type: this.type,
							clusterId: e$1,
							source: this.id
						}
					});
				}
				getClusterChildren(e$1) {
					return this.actor.sendAsync({
						type: "GCC",
						data: {
							type: this.type,
							clusterId: e$1,
							source: this.id
						}
					});
				}
				getClusterLeaves(e$1, t$1, i$1) {
					return this.actor.sendAsync({
						type: "GCL",
						data: {
							type: this.type,
							source: this.id,
							clusterId: e$1,
							limit: t$1,
							offset: i$1
						}
					});
				}
				_updateWorkerData() {
					return t._(this, void 0, void 0, (function* () {
						if (this._isUpdatingWorker) return;
						if (!this._hasPendingWorkerUpdate()) return void t.w(`No pending worker updates for GeoJSONSource ${this.id}.`);
						const { data: e$1, diff: i$1 } = this._pendingWorkerUpdate, a$1 = this._getLoadGeoJSONParameters(e$1, i$1);
						void 0 !== e$1 ? this._pendingWorkerUpdate.data = void 0 : i$1 && (this._pendingWorkerUpdate.diff = void 0), this._pendingWorkerUpdate.optionsChanged = void 0, yield this._dispatchWorkerUpdate(a$1);
					}));
				}
				_getLoadGeoJSONParameters(e$1, i$1) {
					const a$1 = t.e({ type: this.type }, this.workerOptions);
					return "string" == typeof e$1 ? (a$1.request = this.map._requestManager.transformRequest(n.resolveURL(e$1), "Source"), a$1.request.collectResourceTiming = this._collectResourceTiming, a$1) : void 0 !== e$1 ? (a$1.data = e$1, a$1) : i$1 ? (a$1.dataDiff = i$1, a$1) : a$1;
				}
				_dispatchWorkerUpdate(e$1) {
					return t._(this, void 0, void 0, (function* () {
						this._isUpdatingWorker = !0, this.fire(new t.l("dataloading", { dataType: "source" }));
						try {
							const i$1 = yield this.actor.sendAsync({
								type: "LD",
								data: e$1
							});
							if (this._isUpdatingWorker = !1, this._removed || i$1.abandoned) return void this.fire(new t.l("dataabort", { dataType: "source" }));
							i$1.data && (this._data = { geojson: i$1.data });
							const a$1 = this._applyDiffToSource(e$1.dataDiff), o$1 = this._getShouldReloadTileOptions(a$1), r$1 = { dataType: "source" };
							this._applyResourceTiming(r$1, i$1), this.fire(new t.l("data", Object.assign(Object.assign({}, r$1), { sourceDataType: "metadata" }))), this.fire(new t.l("data", Object.assign(Object.assign({}, r$1), {
								sourceDataType: "content",
								shouldReloadTileOptions: o$1
							})));
						} catch (e$2) {
							if (this._isUpdatingWorker = !1, this._removed) return void this.fire(new t.l("dataabort", { dataType: "source" }));
							this.fire(new t.k(e$2));
						} finally {
							this._hasPendingWorkerUpdate() && this._updateWorkerData();
						}
					}));
				}
				_applyResourceTiming(e$1, i$1) {
					var a$1;
					if (!this._collectResourceTiming) return;
					const o$1 = null === (a$1 = i$1.resourceTiming) || void 0 === a$1 ? void 0 : a$1[this.id];
					if (!o$1) return;
					const r$1 = o$1.slice(0);
					null != r$1 && r$1.length && t.e(e$1, { resourceTiming: r$1 });
				}
				_applyDiffToSource(e$1) {
					if (!e$1) return;
					const i$1 = "string" == typeof this.promoteId ? this.promoteId : void 0;
					if (!this._data.url && !this._data.updateable) {
						const e$2 = t.a7(this._data.geojson, i$1);
						if (!e$2) throw new Error(`GeoJSONSource "${this.id}": GeoJSON data is not compatible with updateData`);
						this._data = { updateable: e$2 };
					}
					if (!this._data.updateable) return;
					const a$1 = t.a8(this._data.updateable, e$1, i$1);
					return e$1.removeAll || this._options.cluster ? void 0 : a$1;
				}
				_getShouldReloadTileOptions(e$1) {
					if (e$1) return { affectedBounds: e$1.filter(Boolean).map(((e$2) => J(e$2))) };
				}
				shouldReloadTile(e$1, { affectedBounds: i$1 }) {
					if ("loading" === e$1.state) return !0;
					if ("unloaded" === e$1.state) return !1;
					const { buffer: a$1, extent: o$1 } = this.workerOptions.geojsonVtOptions, r$1 = function({ x: e$2, y: i$2, z: a$2 }, o$2 = 0) {
						const r$2 = t.a3((e$2 - o$2) / Math.pow(2, a$2)), s$1 = t.a4((i$2 + 1 + o$2) / Math.pow(2, a$2)), n$1 = t.a3((e$2 + 1 + o$2) / Math.pow(2, a$2)), l$1 = t.a4((i$2 - o$2) / Math.pow(2, a$2));
						return new $([r$2, s$1], [n$1, l$1]);
					}(e$1.tileID.canonical, a$1 / o$1);
					for (const e$2 of i$1) if (r$1.intersects(e$2)) return !0;
					return !1;
				}
				loaded() {
					return !this._isUpdatingWorker && !this._hasPendingWorkerUpdate();
				}
				loadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						const t$1 = e$1.actor ? "RT" : "LT";
						e$1.actor = this.actor;
						const i$1 = {
							type: this.type,
							uid: e$1.uid,
							tileID: e$1.tileID,
							zoom: e$1.tileID.overscaledZ,
							maxZoom: this.maxzoom,
							tileSize: this.tileSize,
							source: this.id,
							pixelRatio: this.map.getPixelRatio(),
							showCollisionBoxes: this.map.showCollisionBoxes,
							promoteId: this.promoteId,
							subdivisionGranularity: this.map.style.projection.subdivisionGranularity
						};
						e$1.abortController = new AbortController();
						const a$1 = yield this.actor.sendAsync({
							type: t$1,
							data: i$1
						}, e$1.abortController);
						delete e$1.abortController, e$1.unloadVectorData(), e$1.aborted || e$1.loadVectorData(a$1, this.map.painter, "RT" === t$1);
					}));
				}
				abortTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.abortController && (e$1.abortController.abort(), delete e$1.abortController), e$1.aborted = !0;
					}));
				}
				unloadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.unloadVectorData(), yield this.actor.sendAsync({
							type: "RMT",
							data: {
								uid: e$1.uid,
								type: this.type,
								source: this.id
							}
						});
					}));
				}
				onRemove() {
					this._removed = !0, this.actor.sendAsync({
						type: "RS",
						data: {
							type: this.type,
							source: this.id
						}
					});
				}
				serialize() {
					return t.e({}, this._options, {
						type: this.type,
						data: this._data.updateable ? {
							type: "FeatureCollection",
							features: Array.from(this._data.updateable.values())
						} : this._data.url || this._data.geojson
					});
				}
				hasTransition() {
					return !1;
				}
			}
			class te extends t.E {
				constructor(e$1, t$1, i$1, a$1) {
					super(), this.flippedWindingOrder = !1, this.id = e$1, this.dispatcher = i$1, this.coordinates = t$1.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(a$1), this.options = t$1;
				}
				load(e$1) {
					return t._(this, void 0, void 0, (function* () {
						this._loaded = !1, this.fire(new t.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
						try {
							const t$1 = yield g.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
							this._request = null, this._loaded = !0, t$1 && t$1.data && (this.image = t$1.data, e$1 && (this.coordinates = e$1), this._finishLoading());
						} catch (e$2) {
							this._request = null, this._loaded = !0, t.Z(e$2) || this.fire(new t.k(e$2));
						}
					}));
				}
				loaded() {
					return this._loaded;
				}
				updateImage(e$1) {
					return e$1.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e$1.url, this.load(e$1.coordinates).finally((() => {
						this.texture = null;
					})), this) : this;
				}
				_finishLoading() {
					this.map && (this.setCoordinates(this.coordinates), this.fire(new t.l("data", {
						dataType: "source",
						sourceDataType: "metadata"
					})));
				}
				onAdd(e$1) {
					this.map = e$1, this.load();
				}
				onRemove() {
					this._request && (this._request.abort(), this._request = null);
				}
				setCoordinates(e$1) {
					this.coordinates = e$1;
					const i$1 = e$1.map(t.a9.fromLngLat);
					var a$1;
					return this.tileID = function(e$2) {
						const i$2 = t.aa.fromPoints(e$2), a$2 = i$2.width(), o$1 = i$2.height(), r$1 = Math.max(a$2, o$1), s$1 = Math.max(0, Math.floor(-Math.log(r$1) / Math.LN2)), n$1 = Math.pow(2, s$1);
						return new t.ac(s$1, Math.floor((i$2.minX + i$2.maxX) / 2 * n$1), Math.floor((i$2.minY + i$2.maxY) / 2 * n$1));
					}(i$1), this.terrainTileRanges = this._getOverlappingTileRanges(i$1), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = i$1.map(((e$2) => this.tileID.getTilePoint(e$2)._round())), this.flippedWindingOrder = ((a$1 = this.tileCoords)[1].x - a$1[0].x) * (a$1[2].y - a$1[0].y) - (a$1[1].y - a$1[0].y) * (a$1[2].x - a$1[0].x) < 0, this.fire(new t.l("data", {
						dataType: "source",
						sourceDataType: "content"
					})), this;
				}
				prepare() {
					if (0 === Object.keys(this.tiles).length || !this.image) return;
					const e$1 = this.map.painter.context, i$1 = e$1.gl;
					this.texture || (this.texture = new t.T(e$1, this.image, i$1.RGBA), this.texture.bind(i$1.LINEAR, i$1.CLAMP_TO_EDGE));
					let a$1 = !1;
					for (const e$2 in this.tiles) {
						const t$1 = this.tiles[e$2];
						"loaded" !== t$1.state && (t$1.state = "loaded", t$1.texture = this.texture, a$1 = !0);
					}
					a$1 && this.fire(new t.l("data", {
						dataType: "source",
						sourceDataType: "idle",
						sourceId: this.id
					}));
				}
				loadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						this.tileID && this.tileID.equals(e$1.tileID.canonical) ? (this.tiles[String(e$1.tileID.wrap)] = e$1, e$1.buckets = {}) : e$1.state = "errored";
					}));
				}
				serialize() {
					return {
						type: "image",
						url: this.options.url,
						coordinates: this.coordinates
					};
				}
				hasTransition() {
					return !1;
				}
				_getOverlappingTileRanges(e$1) {
					const { minX: i$1, minY: a$1, maxX: o$1, maxY: r$1 } = t.aa.fromPoints(e$1), s$1 = {};
					for (let e$2 = 0; e$2 <= t.ab; e$2++) {
						const t$1 = Math.pow(2, e$2), n$1 = Math.floor(i$1 * t$1), l$1 = Math.floor(a$1 * t$1), c$1 = Math.floor(o$1 * t$1), h$1 = Math.floor(r$1 * t$1), u$1 = (n$1 % t$1 + t$1) % t$1, d$1 = c$1 % t$1;
						s$1[e$2] = {
							minWrap: Math.floor(n$1 / t$1),
							maxWrap: Math.floor(c$1 / t$1),
							minTileXWrapped: u$1,
							maxTileXWrapped: d$1,
							minTileY: l$1,
							maxTileY: h$1
						};
					}
					return s$1;
				}
			}
			class ie extends te {
				constructor(e$1, t$1, i$1, a$1) {
					super(e$1, t$1, i$1, a$1), this.roundZoom = !0, this.type = "video", this.options = t$1;
				}
				load() {
					return t._(this, void 0, void 0, (function* () {
						this._loaded = !1;
						const e$1 = this.options;
						this.urls = [];
						for (const t$1 of e$1.urls) this.urls.push(this.map._requestManager.transformRequest(t$1, "Source").url);
						try {
							const e$2 = yield t.ad(this.urls);
							if (this._loaded = !0, !e$2) return;
							this.video = e$2, this.video.loop = !0, this.video.addEventListener("playing", (() => {
								this.map.triggerRepaint();
							})), this.map && this.video.play(), this._finishLoading();
						} catch (e$2) {
							this.fire(new t.k(e$2));
						}
					}));
				}
				pause() {
					this.video && this.video.pause();
				}
				play() {
					this.video && this.video.play();
				}
				seek(e$1) {
					if (this.video) {
						const i$1 = this.video.seekable;
						e$1 < i$1.start(0) || e$1 > i$1.end(0) ? this.fire(new t.k(new t.ae(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i$1.start(0)} and ${i$1.end(0)}-second mark.`))) : this.video.currentTime = e$1;
					}
				}
				getVideo() {
					return this.video;
				}
				onAdd(e$1) {
					this.map || (this.map = e$1, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
				}
				prepare() {
					if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
					const e$1 = this.map.painter.context, i$1 = e$1.gl;
					this.texture ? this.video.paused || (this.texture.bind(i$1.LINEAR, i$1.CLAMP_TO_EDGE), i$1.texSubImage2D(i$1.TEXTURE_2D, 0, 0, 0, i$1.RGBA, i$1.UNSIGNED_BYTE, this.video)) : (this.texture = new t.T(e$1, this.video, i$1.RGBA), this.texture.bind(i$1.LINEAR, i$1.CLAMP_TO_EDGE));
					let a$1 = !1;
					for (const e$2 in this.tiles) {
						const t$1 = this.tiles[e$2];
						"loaded" !== t$1.state && (t$1.state = "loaded", t$1.texture = this.texture, a$1 = !0);
					}
					a$1 && this.fire(new t.l("data", {
						dataType: "source",
						sourceDataType: "idle",
						sourceId: this.id
					}));
				}
				serialize() {
					return {
						type: "video",
						urls: this.urls,
						coordinates: this.coordinates
					};
				}
				hasTransition() {
					return this.video && !this.video.paused;
				}
			}
			class ae extends te {
				constructor(e$1, i$1, a$1, o$1) {
					super(e$1, i$1, a$1, o$1), i$1.coordinates ? Array.isArray(i$1.coordinates) && 4 === i$1.coordinates.length && !i$1.coordinates.some(((e$2) => !Array.isArray(e$2) || 2 !== e$2.length || e$2.some(((e$3) => "number" != typeof e$3)))) || this.fire(new t.k(new t.ae(`sources.${e$1}`, null, "\"coordinates\" property must be an array of 4 longitude/latitude array pairs"))) : this.fire(new t.k(new t.ae(`sources.${e$1}`, null, "missing required property \"coordinates\""))), i$1.animate && "boolean" != typeof i$1.animate && this.fire(new t.k(new t.ae(`sources.${e$1}`, null, "optional \"animate\" property must be a boolean value"))), i$1.canvas ? "string" == typeof i$1.canvas || i$1.canvas instanceof HTMLCanvasElement || this.fire(new t.k(new t.ae(`sources.${e$1}`, null, "\"canvas\" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance"))) : this.fire(new t.k(new t.ae(`sources.${e$1}`, null, "missing required property \"canvas\""))), this.options = i$1, this.animate = void 0 === i$1.animate || i$1.animate;
				}
				load() {
					return t._(this, void 0, void 0, (function* () {
						this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t.k(/* @__PURE__ */ new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
							this._playing = !0, this.map.triggerRepaint();
						}, this.pause = function() {
							this._playing && (this.prepare(), this._playing = !1);
						}, this._finishLoading());
					}));
				}
				getCanvas() {
					return this.canvas;
				}
				onAdd(e$1) {
					this.map = e$1, this.load(), this.canvas && this.animate && this.play();
				}
				onRemove() {
					this.pause();
				}
				prepare() {
					let e$1 = !1;
					if (this.canvas.width !== this.width && (this.width = this.canvas.width, e$1 = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e$1 = !0), this._hasInvalidDimensions()) return;
					if (0 === Object.keys(this.tiles).length) return;
					const i$1 = this.map.painter.context, a$1 = i$1.gl;
					this.texture ? (e$1 || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : (this.texture = new t.T(i$1, this.canvas, a$1.RGBA, { premultiply: !0 }), this.texture.bind(a$1.LINEAR, a$1.CLAMP_TO_EDGE));
					let o$1 = !1;
					for (const e$2 in this.tiles) {
						const t$1 = this.tiles[e$2];
						"loaded" !== t$1.state && (t$1.state = "loaded", t$1.texture = this.texture, o$1 = !0);
					}
					o$1 && this.fire(new t.l("data", {
						dataType: "source",
						sourceDataType: "idle",
						sourceId: this.id
					}));
				}
				serialize() {
					return {
						type: "canvas",
						animate: this.animate,
						canvas: this.options.canvas,
						coordinates: this.coordinates
					};
				}
				hasTransition() {
					return this._playing;
				}
				_hasInvalidDimensions() {
					for (const e$1 of [this.canvas.width, this.canvas.height]) if (isNaN(e$1) || e$1 <= 0) return !0;
					return !1;
				}
			}
			const oe = {}, re = (e$1) => {
				switch (e$1) {
					case "geojson": return ee;
					case "image": return te;
					case "raster": return K;
					case "raster-dem": return Y;
					case "vector": return X;
					case "video": return ie;
					case "canvas": return ae;
				}
				return oe[e$1];
			}, se = "RTLPluginLoaded";
			class ne extends t.E {
				constructor() {
					super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = Z();
				}
				_syncState(e$1) {
					return this.status = e$1, this.dispatcher.broadcast("SRPS", {
						pluginStatus: e$1,
						pluginURL: this.url
					}).catch(((e$2) => {
						throw this.status = "error", e$2;
					}));
				}
				getRTLTextPluginStatus() {
					return this.status;
				}
				clearRTLTextPlugin() {
					this.status = "unavailable", this.url = null;
				}
				setRTLTextPlugin(e$1) {
					return t._(this, arguments, void 0, (function* (e$2, t$1 = !1) {
						if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
						if (this.url = n.resolveURL(e$2), !this.url) throw new Error(`requested url ${e$2} is invalid`);
						if ("unavailable" === this.status) {
							if (!t$1) return this._requestImport();
							this.status = "deferred", this._syncState(this.status);
						} else if ("requested" === this.status) return this._requestImport();
					}));
				}
				_requestImport() {
					return t._(this, void 0, void 0, (function* () {
						yield this._syncState("loading"), this.status = "loaded", this.fire(new t.l(se));
					}));
				}
				lazyLoad() {
					"unavailable" === this.status ? this.status = "requested" : "deferred" === this.status && this._requestImport();
				}
			}
			let le = null;
			function ce() {
				return le || (le = new ne()), le;
			}
			var he, ue;
			(function(e$1) {
				e$1[e$1.Base = 0] = "Base", e$1[e$1.Parent = 1] = "Parent";
			})(he || (he = {})), function(e$1) {
				e$1[e$1.Departing = 0] = "Departing", e$1[e$1.Incoming = 1] = "Incoming";
			}(ue || (ue = {}));
			class de {
				constructor(e$1, i$1) {
					this.timeAdded = 0, this.fadeEndTime = 0, this.fadeOpacity = 1, this.tileID = e$1, this.uid = t.af(), this.uses = 0, this.tileSize = i$1, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
				}
				isRenderable(e$1) {
					return this.hasData() && (!this.fadeEndTime || this.fadeOpacity > 0) && (e$1 || !this.holdingForSymbolFade());
				}
				setCrossFadeLogic({ fadingRole: e$1, fadingDirection: t$1, fadingParentID: i$1, fadeEndTime: a$1 }) {
					this.resetFadeLogic(), this.fadingRole = e$1, this.fadingDirection = t$1, this.fadingParentID = i$1, this.fadeEndTime = a$1;
				}
				setSelfFadeLogic(e$1) {
					this.resetFadeLogic(), this.selfFading = !0, this.fadeEndTime = e$1;
				}
				resetFadeLogic() {
					this.fadingRole = null, this.fadingDirection = null, this.fadingParentID = null, this.selfFading = !1, this.timeAdded = c(), this.fadeEndTime = 0, this.fadeOpacity = 1;
				}
				wasRequested() {
					return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
				}
				clearTextures(e$1) {
					this.demTexture && e$1.saveTileTexture(this.demTexture), this.demTexture = null;
				}
				loadVectorData(e$1, i$1, a$1) {
					if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e$1) {
						e$1.featureIndex && (this.latestFeatureIndex = e$1.featureIndex, e$1.rawTileData ? (this.latestRawTileData = e$1.rawTileData, this.latestFeatureIndex.rawTileData = e$1.rawTileData, this.latestFeatureIndex.encoding = e$1.encoding) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData, this.latestFeatureIndex.encoding = this.latestEncoding)), this.collisionBoxArray = e$1.collisionBoxArray, this.buckets = function(e$2, t$1) {
							const i$2 = {};
							if (!t$1) return i$2;
							for (const a$2 of e$2) {
								const e$3 = a$2.layerIds.map(((e$4) => t$1.getLayer(e$4))).filter(Boolean);
								if (0 !== e$3.length) {
									a$2.layers = e$3, a$2.stateDependentLayerIds && (a$2.stateDependentLayers = a$2.stateDependentLayerIds.map(((t$2) => e$3.filter(((e$4) => e$4.id === t$2))[0])));
									for (const t$2 of e$3) i$2[t$2.id] = a$2;
								}
							}
							return i$2;
						}(e$1.buckets, null == i$1 ? void 0 : i$1.style), this.hasSymbolBuckets = !1;
						for (const e$2 in this.buckets) {
							const i$2 = this.buckets[e$2];
							if (i$2 instanceof t.ah) {
								if (this.hasSymbolBuckets = !0, !a$1) break;
								i$2.justReloaded = !0;
							}
						}
						if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const e$2 in this.buckets) {
							const i$2 = this.buckets[e$2];
							if (i$2 instanceof t.ah && i$2.hasRTLText) {
								this.hasRTLText = !0, ce().lazyLoad();
								break;
							}
						}
						this.queryPadding = 0;
						for (const e$2 in this.buckets) {
							const t$1 = this.buckets[e$2];
							this.queryPadding = Math.max(this.queryPadding, i$1.style.getLayer(e$2).queryRadius(t$1));
						}
						e$1.imageAtlas && (this.imageAtlas = e$1.imageAtlas), e$1.glyphAtlasImage && (this.glyphAtlasImage = e$1.glyphAtlasImage), this.dashPositions = e$1.dashPositions;
					} else this.collisionBoxArray = new t.ag();
				}
				unloadVectorData() {
					for (const e$1 in this.buckets) this.buckets[e$1].destroy();
					this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.dashPositions && (this.dashPositions = null), this.latestFeatureIndex = null, this.state = "unloaded";
				}
				getBucket(e$1) {
					return this.buckets[e$1.id];
				}
				upload(e$1) {
					for (const t$1 in this.buckets) {
						const i$2 = this.buckets[t$1];
						i$2.uploadPending() && i$2.upload(e$1);
					}
					const i$1 = e$1.gl;
					this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new t.T(e$1, this.imageAtlas.image, i$1.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new t.T(e$1, this.glyphAtlasImage, i$1.ALPHA), this.glyphAtlasImage = null);
				}
				prepare(e$1) {
					this.imageAtlas && this.imageAtlas.patchUpdatedImages(e$1, this.imageAtlasTexture);
				}
				queryRenderedFeatures(e$1, t$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1, c$1, h$1) {
					return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
						queryGeometry: a$1,
						cameraQueryGeometry: o$1,
						scale: r$1,
						tileSize: this.tileSize,
						pixelPosMatrix: c$1,
						transform: n$1,
						params: s$1,
						queryPadding: this.queryPadding * l$1,
						getElevation: h$1
					}, e$1, t$1, i$1) : {};
				}
				querySourceFeatures(e$1, i$1) {
					const a$1 = this.latestFeatureIndex;
					if (!a$1 || !a$1.rawTileData) return;
					const o$1 = a$1.loadVTLayers(), r$1 = i$1 && i$1.sourceLayer ? i$1.sourceLayer : "", s$1 = o$1[t.ai] || o$1[r$1];
					if (!s$1) return;
					const n$1 = t.aj(null == i$1 ? void 0 : i$1.filter, null == i$1 ? void 0 : i$1.globalState), { z: l$1, x: c$1, y: h$1 } = this.tileID.canonical, u$1 = {
						z: l$1,
						x: c$1,
						y: h$1
					};
					for (let i$2 = 0; i$2 < s$1.length; i$2++) {
						const o$2 = s$1.feature(i$2);
						if (n$1.needGeometry) {
							const e$2 = t.ak(o$2, !0);
							if (!n$1.filter(new t.H(this.tileID.overscaledZ), e$2, this.tileID.canonical)) continue;
						} else if (!n$1.filter(new t.H(this.tileID.overscaledZ), o$2)) continue;
						const d$1 = a$1.getId(o$2, r$1), _$1 = new t.al(o$2, l$1, c$1, h$1, d$1);
						_$1.tile = u$1, e$1.push(_$1);
					}
				}
				hasData() {
					return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
				}
				patternsLoaded() {
					return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
				}
				setExpiryData(e$1) {
					const i$1 = this.expirationTime;
					if (e$1.cacheControl) {
						const i$2 = t.am(e$1.cacheControl);
						i$2["max-age"] && (this.expirationTime = Date.now() + 1e3 * i$2["max-age"]);
					} else e$1.expires && (this.expirationTime = new Date(e$1.expires).getTime());
					if (this.expirationTime) {
						const e$2 = Date.now();
						let t$1 = !1;
						if (this.expirationTime > e$2) t$1 = !1;
						else if (i$1) if (this.expirationTime < i$1) t$1 = !0;
						else {
							const a$1 = this.expirationTime - i$1;
							a$1 ? this.expirationTime = e$2 + Math.max(a$1, 3e4) : t$1 = !0;
						}
						else t$1 = !0;
						t$1 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
					}
				}
				getExpiryTimeout() {
					if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
				}
				setFeatureState(e$1, i$1) {
					if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(e$1).length) return;
					const a$1 = this.latestFeatureIndex.loadVTLayers();
					for (const o$1 in this.buckets) {
						if (!i$1.style.hasLayer(o$1)) continue;
						const r$1 = this.buckets[o$1], s$1 = r$1.layers[0].sourceLayer || t.ai, n$1 = a$1[s$1], l$1 = e$1[s$1];
						if (!n$1 || !l$1 || 0 === Object.keys(l$1).length) continue;
						r$1.update(l$1, n$1, this.imageAtlas && this.imageAtlas.patternPositions || {}, this.dashPositions || {});
						const c$1 = i$1 && i$1.style && i$1.style.getLayer(o$1);
						c$1 && (this.queryPadding = Math.max(this.queryPadding, c$1.queryRadius(r$1)));
					}
				}
				holdingForSymbolFade() {
					return void 0 !== this.symbolFadeHoldUntil;
				}
				symbolFadeFinished() {
					return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < c();
				}
				clearSymbolFadeHold() {
					this.symbolFadeHoldUntil = void 0;
				}
				setSymbolHoldDuration(e$1) {
					this.symbolFadeHoldUntil = c() + e$1;
				}
				setDependencies(e$1, t$1) {
					const i$1 = {};
					for (const e$2 of t$1) i$1[e$2] = !0;
					this.dependencies[e$1] = i$1;
				}
				hasDependency(e$1, t$1) {
					for (const i$1 of e$1) {
						const e$2 = this.dependencies[i$1];
						if (e$2) {
							for (const i$2 of t$1) if (e$2[i$2]) return !0;
						}
					}
					return !1;
				}
			}
			class _e {
				constructor() {
					this.state = {}, this.stateChanges = {}, this.deletedStates = {};
				}
				updateState(e$1, i$1, a$1) {
					const o$1 = String(i$1);
					if (this.stateChanges[e$1] = this.stateChanges[e$1] || {}, this.stateChanges[e$1][o$1] = this.stateChanges[e$1][o$1] || {}, t.e(this.stateChanges[e$1][o$1], a$1), null === this.deletedStates[e$1]) {
						this.deletedStates[e$1] = {};
						for (const t$1 in this.state[e$1]) t$1 !== o$1 && (this.deletedStates[e$1][t$1] = null);
					} else if (this.deletedStates[e$1] && null === this.deletedStates[e$1][o$1]) {
						this.deletedStates[e$1][o$1] = {};
						for (const t$1 in this.state[e$1][o$1]) a$1[t$1] || (this.deletedStates[e$1][o$1][t$1] = null);
					} else for (const t$1 in a$1) this.deletedStates[e$1] && this.deletedStates[e$1][o$1] && null === this.deletedStates[e$1][o$1][t$1] && delete this.deletedStates[e$1][o$1][t$1];
				}
				removeFeatureState(e$1, t$1, i$1) {
					if (null === this.deletedStates[e$1]) return;
					const a$1 = String(t$1);
					if (this.deletedStates[e$1] = this.deletedStates[e$1] || {}, i$1 && void 0 !== t$1) null !== this.deletedStates[e$1][a$1] && (this.deletedStates[e$1][a$1] = this.deletedStates[e$1][a$1] || {}, this.deletedStates[e$1][a$1][i$1] = null);
					else if (void 0 !== t$1) if (this.stateChanges[e$1] && this.stateChanges[e$1][a$1]) for (i$1 in this.deletedStates[e$1][a$1] = {}, this.stateChanges[e$1][a$1]) this.deletedStates[e$1][a$1][i$1] = null;
					else this.deletedStates[e$1][a$1] = null;
					else this.deletedStates[e$1] = null;
				}
				getState(e$1, i$1) {
					const a$1 = String(i$1), o$1 = t.e({}, (this.state[e$1] || {})[a$1], (this.stateChanges[e$1] || {})[a$1]);
					if (null === this.deletedStates[e$1]) return {};
					if (this.deletedStates[e$1]) {
						const t$1 = this.deletedStates[e$1][i$1];
						if (null === t$1) return {};
						for (const e$2 in t$1) delete o$1[e$2];
					}
					return o$1;
				}
				initializeTileState(e$1, t$1) {
					e$1.setFeatureState(this.state, t$1);
				}
				coalesceChanges(e$1, i$1) {
					const a$1 = {};
					for (const e$2 in this.stateChanges) {
						this.state[e$2] = this.state[e$2] || {};
						const i$2 = {};
						for (const a$2 in this.stateChanges[e$2]) this.state[e$2][a$2] || (this.state[e$2][a$2] = {}), t.e(this.state[e$2][a$2], this.stateChanges[e$2][a$2]), i$2[a$2] = this.state[e$2][a$2];
						a$1[e$2] = i$2;
					}
					for (const e$2 in this.deletedStates) {
						this.state[e$2] = this.state[e$2] || {};
						const i$2 = {};
						if (null === this.deletedStates[e$2]) for (const t$1 in this.state[e$2]) i$2[t$1] = {}, this.state[e$2][t$1] = {};
						else for (const t$1 in this.deletedStates[e$2]) {
							if (null === this.deletedStates[e$2][t$1]) this.state[e$2][t$1] = {};
							else for (const i$3 of Object.keys(this.deletedStates[e$2][t$1])) delete this.state[e$2][t$1][i$3];
							i$2[t$1] = this.state[e$2][t$1];
						}
						a$1[e$2] = a$1[e$2] || {}, t.e(a$1[e$2], i$2);
					}
					this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(a$1).length && e$1.setFeatureState(a$1, i$1);
				}
			}
			const pe = 89.25;
			function me(e$1, i$1) {
				const a$1 = t.an(i$1.lat, -t.ao, t.ao);
				return new t.P(t.Y(i$1.lng) * e$1, t.X(a$1) * e$1);
			}
			function fe(e$1, i$1) {
				return new t.a9(i$1.x / e$1, i$1.y / e$1).toLngLat();
			}
			function ge(e$1) {
				return e$1.cameraToCenterDistance * Math.min(.85 * Math.tan(t.ap(90 - e$1.pitch)), Math.tan(t.ap(pe - e$1.pitch)));
			}
			function ve(e$1, i$1) {
				const a$1 = e$1.canonical, o$1 = i$1 / t.aq(a$1.z), r$1 = a$1.x + Math.pow(2, a$1.z) * e$1.wrap, s$1 = t.ar(new Float64Array(16));
				return t.O(s$1, s$1, [
					r$1 * o$1,
					a$1.y * o$1,
					0
				]), t.Q(s$1, s$1, [
					o$1 / t.a5,
					o$1 / t.a5,
					1
				]), s$1;
			}
			function xe(e$1, i$1, a$1, o$1, r$1) {
				const s$1 = t.a9.fromLngLat(e$1, i$1), n$1 = r$1 * t.as(1, e$1.lat), { x: l$1, y: c$1, z: h$1 } = be(a$1, o$1);
				return new t.a9(s$1.x + n$1 * -l$1, s$1.y + n$1 * -c$1, s$1.z + n$1 * -h$1);
			}
			function be(e$1, i$1) {
				const a$1 = t.ap(e$1), o$1 = t.ap(i$1), r$1 = Math.cos(-a$1), s$1 = Math.sin(a$1);
				return {
					x: s$1 * Math.sin(o$1),
					y: -s$1 * Math.cos(o$1),
					z: r$1
				};
			}
			function ye(e$1, t$1, i$1) {
				const a$1 = t$1.intersectsFrustum(e$1);
				if (!i$1 || 0 === a$1) return a$1;
				const o$1 = t$1.intersectsPlane(i$1);
				return 0 === o$1 ? 0 : 2 === a$1 && 2 === o$1 ? 2 : 1;
			}
			function we(e$1, t$1, i$1) {
				let a$1 = 0;
				const o$1 = (i$1 - t$1) / 10;
				for (let r$1 = 0; r$1 < 10; r$1++) a$1 += o$1 * Math.pow(Math.cos(t$1 + (r$1 + .5) / 10 * (i$1 - t$1)), e$1);
				return a$1;
			}
			function Te(e$1, i$1) {
				return function(a$1, o$1, r$1, s$1, n$1) {
					const l$1 = 2 * ((e$1 - 1) / t.at(Math.cos(t.ap(pe - n$1)) / Math.cos(t.ap(pe))) - 1), c$1 = Math.acos(r$1 / s$1), h$1 = 2 * we(l$1 - 1, 0, t.ap(n$1 / 2)), u$1 = Math.min(t.ap(pe), c$1 + t.ap(n$1 / 2)), d$1 = we(l$1 - 1, Math.min(u$1, c$1 - t.ap(n$1 / 2)), u$1), _$1 = Math.atan(o$1 / r$1), p$1 = Math.hypot(o$1, r$1);
					let m$1 = a$1;
					return m$1 += t.at(s$1 / p$1 / Math.max(.5, Math.cos(t.ap(n$1 / 2)))), m$1 += l$1 * t.at(Math.cos(_$1)) / 2, m$1 -= t.at(Math.max(1, d$1 / h$1 / i$1)) / 2, m$1;
				};
			}
			const Pe = Te(9.314, 3);
			function Ce(e$1, i$1) {
				const a$1 = (i$1.roundZoom ? Math.round : Math.floor)(e$1.zoom + t.at(e$1.tileSize / i$1.tileSize));
				return Math.max(0, a$1);
			}
			function Ie(e$1, i$1) {
				const a$1 = e$1.getCameraFrustum(), o$1 = e$1.getClippingPlane(), r$1 = e$1.screenPointToMercatorCoordinate(e$1.getCameraPoint()), s$1 = t.a9.fromLngLat(e$1.center, e$1.elevation);
				r$1.z = s$1.z + Math.cos(e$1.pitchInRadians) * e$1.cameraToCenterDistance / e$1.worldSize;
				const n$1 = e$1.getCoveringTilesDetailsProvider(), l$1 = n$1.allowVariableZoom(e$1, i$1), c$1 = Ce(e$1, i$1), h$1 = i$1.minzoom || 0, u$1 = void 0 !== i$1.maxzoom ? i$1.maxzoom : e$1.maxZoom, d$1 = Math.min(Math.max(0, c$1), u$1), _$1 = Math.pow(2, d$1), p$1 = [
					_$1 * r$1.x,
					_$1 * r$1.y,
					0
				], m$1 = [
					_$1 * s$1.x,
					_$1 * s$1.y,
					0
				], f$1 = Math.hypot(s$1.x - r$1.x, s$1.y - r$1.y), g$1 = Math.abs(s$1.z - r$1.z), v$1 = Math.hypot(f$1, g$1), x$1 = (e$2) => ({
					zoom: 0,
					x: 0,
					y: 0,
					wrap: e$2,
					fullyVisible: !1
				}), b$1 = [], y$1 = [];
				if (e$1.renderWorldCopies && n$1.allowWorldCopies()) for (let e$2 = 1; e$2 <= 3; e$2++) b$1.push(x$1(-e$2)), b$1.push(x$1(e$2));
				for (b$1.push(x$1(0)); b$1.length > 0;) {
					const _$2 = b$1.pop(), f$2 = _$2.x, x$2 = _$2.y;
					let w$1 = _$2.fullyVisible;
					const T$1 = {
						x: f$2,
						y: x$2,
						z: _$2.zoom
					}, P$1 = n$1.getTileBoundingVolume(T$1, _$2.wrap, e$1.elevation, i$1);
					if (!w$1) {
						const e$2 = ye(a$1, P$1, o$1);
						if (0 === e$2) continue;
						w$1 = 2 === e$2;
					}
					const C$1 = n$1.distanceToTile2d(r$1.x, r$1.y, T$1, P$1);
					let I$1 = c$1;
					l$1 && (I$1 = (i$1.calculateTileZoom || Pe)(e$1.zoom + t.at(e$1.tileSize / i$1.tileSize), C$1, g$1, v$1, e$1.fov)), I$1 = (i$1.roundZoom ? Math.round : Math.floor)(I$1), I$1 = Math.max(0, I$1);
					const M$1 = Math.min(I$1, u$1);
					if (_$2.wrap = n$1.getWrap(s$1, T$1, _$2.wrap), _$2.zoom >= M$1) {
						if (_$2.zoom < h$1) continue;
						const e$2 = d$1 - _$2.zoom, a$2 = p$1[0] - .5 - (f$2 << e$2), o$2 = p$1[1] - .5 - (x$2 << e$2), r$2 = i$1.reparseOverscaled ? Math.max(_$2.zoom, I$1) : _$2.zoom;
						y$1.push({
							tileID: new t.a2(_$2.zoom === u$1 ? r$2 : _$2.zoom, _$2.wrap, _$2.zoom, f$2, x$2),
							distanceSq: t.au([m$1[0] - .5 - f$2, m$1[1] - .5 - x$2]),
							tileDistanceToCamera: Math.sqrt(a$2 * a$2 + o$2 * o$2)
						});
					} else for (let e$2 = 0; e$2 < 4; e$2++) b$1.push({
						zoom: _$2.zoom + 1,
						x: (f$2 << 1) + e$2 % 2,
						y: (x$2 << 1) + (e$2 >> 1),
						wrap: _$2.wrap,
						fullyVisible: w$1
					});
				}
				return y$1.sort(((e$2, t$1) => e$2.distanceSq - t$1.distanceSq)).map(((e$2) => e$2.tileID));
			}
			const Me = t.aa.fromPoints([new t.P(0, 0), new t.P(t.a5, t.a5)]);
			function Ee(e$1) {
				return "raster" === e$1 || "image" === e$1 || "video" === e$1;
			}
			function Se(e$1, t$1, i$1, a$1, o$1, r$1, s$1) {
				if (!t$1.hasData()) return !1;
				const { tileID: n$1, fadingRole: l$1, fadingDirection: c$1, fadingParentID: h$1 } = t$1;
				if (l$1 === he.Base && c$1 === ue.Incoming && h$1) return i$1[h$1.key] = h$1, !0;
				const u$1 = Math.max(n$1.overscaledZ - o$1, r$1);
				for (let o$2 = n$1.overscaledZ - 1; o$2 >= u$1; o$2--) {
					const r$2 = n$1.scaledTo(o$2), l$2 = e$1.getLoadedTile(r$2);
					if (l$2) return t$1.setCrossFadeLogic({
						fadingRole: he.Base,
						fadingDirection: ue.Incoming,
						fadingParentID: l$2.tileID,
						fadeEndTime: a$1 + s$1
					}), l$2.setCrossFadeLogic({
						fadingRole: he.Parent,
						fadingDirection: ue.Departing,
						fadeEndTime: a$1 + s$1
					}), i$1[r$2.key] = r$2, !0;
				}
				return !1;
			}
			function ze(e$1, t$1, i$1, a$1, o$1, r$1) {
				if (!t$1.hasData()) return !1;
				const s$1 = t$1.tileID.children(o$1);
				let n$1 = Re(e$1, t$1, s$1, i$1, a$1, o$1, r$1);
				if (n$1) return !0;
				for (const l$1 of s$1) Re(e$1, t$1, l$1.children(o$1), i$1, a$1, o$1, r$1) && (n$1 = !0);
				return n$1;
			}
			function Re(e$1, t$1, i$1, a$1, o$1, r$1, s$1) {
				if (i$1[0].overscaledZ >= r$1) return !1;
				let n$1 = !1;
				for (const r$2 of i$1) {
					const i$2 = e$1.getLoadedTile(r$2);
					if (!i$2) continue;
					const { fadingRole: l$1, fadingDirection: c$1, fadingParentID: h$1 } = i$2;
					l$1 === he.Base && c$1 === ue.Departing && h$1 || (i$2.setCrossFadeLogic({
						fadingRole: he.Base,
						fadingDirection: ue.Departing,
						fadingParentID: t$1.tileID,
						fadeEndTime: o$1 + s$1
					}), t$1.setCrossFadeLogic({
						fadingRole: he.Parent,
						fadingDirection: ue.Incoming,
						fadeEndTime: o$1 + s$1
					})), a$1[r$2.key] = r$2, n$1 = !0;
				}
				return n$1;
			}
			function De(e$1, t$1, i$1, a$1) {
				const o$1 = e$1.tileID;
				return !!e$1.selfFading || !e$1.hasData() && !!t$1.has(o$1) && (e$1.setSelfFadeLogic(i$1 + a$1), !0);
			}
			function Ae(e$1, t$1) {
				var i$1;
				e$1.needsHillshadePrepare = !0, e$1.needsTerrainPrepare = !0;
				let a$1 = t$1.tileID.canonical.x - e$1.tileID.canonical.x;
				const o$1 = t$1.tileID.canonical.y - e$1.tileID.canonical.y, r$1 = Math.pow(2, e$1.tileID.canonical.z), s$1 = t$1.tileID.key;
				0 === a$1 && 0 === o$1 || Math.abs(o$1) > 1 || (Math.abs(a$1) > 1 && (1 === Math.abs(a$1 + r$1) ? a$1 += r$1 : 1 === Math.abs(a$1 - r$1) && (a$1 -= r$1)), t$1.dem && e$1.dem && (e$1.dem.backfillBorder(t$1.dem, a$1, o$1), !(null === (i$1 = e$1.neighboringTiles) || void 0 === i$1) && i$1[s$1] && (e$1.neighboringTiles[s$1].backfilled = !0)));
			}
			class Le {
				constructor() {
					this._tiles = {};
				}
				handleWrapJump(e$1) {
					const t$1 = {};
					for (const i$1 in this._tiles) {
						const a$1 = this._tiles[i$1];
						a$1.tileID = a$1.tileID.unwrapTo(a$1.tileID.wrap + e$1), t$1[a$1.tileID.key] = a$1;
					}
					this._tiles = t$1;
				}
				setFeatureState(e$1, t$1) {
					for (const i$1 in this._tiles) this._tiles[i$1].setFeatureState(e$1, t$1);
				}
				getAllTiles() {
					return Object.values(this._tiles);
				}
				getAllIds(e$1 = !1) {
					return e$1 ? Object.values(this._tiles).map(((e$2) => e$2.tileID)).sort(t.aw).map(((e$2) => e$2.key)) : Object.keys(this._tiles);
				}
				getTileById(e$1) {
					return this._tiles[e$1];
				}
				setTile(e$1, t$1) {
					this._tiles[e$1] = t$1;
				}
				deleteTileById(e$1) {
					delete this._tiles[e$1];
				}
				getLoadedTile(e$1) {
					const t$1 = this.getTileById(e$1.key);
					return (null == t$1 ? void 0 : t$1.hasData()) ? t$1 : null;
				}
				isIdRenderable(e$1, t$1 = !1) {
					var i$1;
					return null === (i$1 = this.getTileById(e$1)) || void 0 === i$1 ? void 0 : i$1.isRenderable(t$1);
				}
				getRenderableIds(e$1 = 0, i$1) {
					const a$1 = [];
					for (const e$2 of this.getAllIds()) this.isIdRenderable(e$2, i$1) && a$1.push(this.getTileById(e$2));
					return i$1 ? a$1.sort(((i$2, a$2) => {
						const o$1 = i$2.tileID, r$1 = a$2.tileID, s$1 = new t.P(o$1.canonical.x, o$1.canonical.y)._rotate(-e$1), n$1 = new t.P(r$1.canonical.x, r$1.canonical.y)._rotate(-e$1);
						return o$1.overscaledZ - r$1.overscaledZ || n$1.y - s$1.y || n$1.x - s$1.x;
					})).map(((e$2) => e$2.tileID.key)) : a$1.map(((e$2) => e$2.tileID)).sort(t.aw).map(((e$2) => e$2.key));
				}
			}
			class ke extends t.E {
				constructor(e$1, i$1, a$1) {
					super(), this.id = e$1, this.dispatcher = a$1, this.on("data", ((e$2) => this._dataHandler(e$2))), this.on("dataloading", (() => {
						this._sourceErrored = !1;
					})), this.on("error", (() => {
						this._sourceErrored = this._source.loaded();
					})), this._source = ((e$2, t$1, i$2, a$2) => {
						const o$1 = new (re(t$1.type))(e$2, t$1, i$2, a$2);
						if (o$1.id !== e$2) throw new Error(`Expected Source id to be ${e$2} instead of ${o$1.id}`);
						return o$1;
					})(e$1, i$1, a$1, this), this._inViewTiles = new Le(), this._outOfViewCache = new t.ax(0, ((e$2) => this._unloadTile(e$2))), this._timers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._rasterFadeDuration = 0, this._maxFadingAncestorLevels = 5, this._state = new _e(), this._didEmitContent = !1, this._updated = !1;
				}
				onAdd(e$1) {
					this.map = e$1, this._maxTileCacheSize = e$1 ? e$1._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e$1 ? e$1._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e$1);
				}
				onRemove(e$1) {
					for (const e$2 of this._inViewTiles.getAllTiles()) e$2.unloadVectorData();
					this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e$1), this._inViewTiles = new Le();
				}
				loaded() {
					if (this._sourceErrored) return !0;
					if (!this._sourceLoaded) return !1;
					if (!this._source.loaded()) return !1;
					if (!(void 0 === this.used && void 0 === this.usedForTerrain || this.used || this.usedForTerrain)) return !0;
					if (!this._updated) return !1;
					for (const e$1 of this._inViewTiles.getAllTiles()) if ("loaded" !== e$1.state && "errored" !== e$1.state) return !1;
					return !0;
				}
				getSource() {
					return this._source;
				}
				getState() {
					return this._state;
				}
				pause() {
					this._paused = !0;
				}
				resume() {
					if (!this._paused) return;
					const e$1 = this._shouldReloadOnResume;
					this._paused = !1, this._shouldReloadOnResume = !1, e$1 && this.reload(), this.transform && this.update(this.transform, this.terrain);
				}
				_loadTile(e$1, i$1, a$1) {
					return t._(this, void 0, void 0, (function* () {
						try {
							yield this._source.loadTile(e$1), this._tileLoaded(e$1, i$1, a$1);
						} catch (i$2) {
							e$1.state = "errored", 404 !== i$2.status ? this._source.fire(new t.k(i$2, { tile: e$1 })) : this.update(this.transform, this.terrain);
						}
					}));
				}
				_unloadTile(e$1) {
					this._source.unloadTile && this._source.unloadTile(e$1);
				}
				_abortTile(e$1) {
					this._source.abortTile && this._source.abortTile(e$1), this._source.fire(new t.l("dataabort", {
						tile: e$1,
						coord: e$1.tileID,
						dataType: "source"
					}));
				}
				serialize() {
					return this._source.serialize();
				}
				prepare(e$1) {
					this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._inViewTiles, this.map ? this.map.painter : null);
					for (const t$1 of this._inViewTiles.getAllTiles()) t$1.upload(e$1), t$1.prepare(this.map.style.imageManager);
				}
				getIds() {
					return this._inViewTiles.getAllIds(!0);
				}
				getRenderableIds(e$1) {
					var t$1;
					return this._inViewTiles.getRenderableIds(null === (t$1 = this.transform) || void 0 === t$1 ? void 0 : t$1.bearingInRadians, e$1);
				}
				hasRenderableParent(e$1) {
					const t$1 = e$1.overscaledZ - 1;
					if (t$1 >= this._source.minzoom) {
						const i$1 = this.getLoadedTile(e$1.scaledTo(t$1));
						if (i$1) return this._inViewTiles.isIdRenderable(i$1.tileID.key);
					}
					return !1;
				}
				reload(e$1, t$1 = void 0) {
					if (this._paused) this._shouldReloadOnResume = !0;
					else {
						this._outOfViewCache.reset();
						for (const i$1 of this._inViewTiles.getAllIds()) {
							const a$1 = this._inViewTiles.getTileById(i$1);
							t$1 && !this._source.shouldReloadTile(a$1, t$1) || (e$1 ? this._reloadTile(i$1, "expired") : "errored" !== a$1.state && this._reloadTile(i$1, "reloading"));
						}
					}
				}
				_reloadTile(e$1, i$1) {
					return t._(this, void 0, void 0, (function* () {
						const t$1 = this._inViewTiles.getTileById(e$1);
						t$1 && ("loading" !== t$1.state && (t$1.state = i$1), yield this._loadTile(t$1, e$1, i$1));
					}));
				}
				_tileLoaded(e$1, i$1, a$1) {
					e$1.timeAdded = c(), e$1.selfFading && (e$1.fadeEndTime = e$1.timeAdded + this._rasterFadeDuration), "expired" === a$1 && (e$1.refreshedUponExpiration = !0), this._setTileReloadTimer(i$1, e$1), "raster-dem" === this.getSource().type && e$1.dem && function(e$2, t$1) {
						var i$2, a$2;
						const o$1 = t$1.getRenderableIds();
						for (const r$1 of o$1) {
							if (!e$2.neighboringTiles || !e$2.neighboringTiles[r$1]) continue;
							const o$2 = t$1.getTileById(r$1);
							e$2.neighboringTiles[r$1].backfilled || Ae(e$2, o$2), !(null === (a$2 = null === (i$2 = o$2.neighboringTiles) || void 0 === i$2 ? void 0 : i$2[e$2.tileID.key]) || void 0 === a$2) && a$2.backfilled || Ae(o$2, e$2);
						}
					}(e$1, this._inViewTiles), this._state.initializeTileState(e$1, this.map ? this.map.painter : null), e$1.aborted || this._source.fire(new t.l("data", {
						dataType: "source",
						tile: e$1,
						coord: e$1.tileID
					}));
				}
				getTile(e$1) {
					return this.getTileByID(e$1.key);
				}
				getTileByID(e$1) {
					return this._inViewTiles.getTileById(e$1);
				}
				_retainLoadedChildren(e$1, t$1) {
					const i$1 = this._getLoadedDescendents(t$1), a$1 = /* @__PURE__ */ new Set();
					for (const o$1 of t$1) {
						const t$2 = i$1[o$1.key];
						if (!(null == t$2 ? void 0 : t$2.length)) {
							a$1.add(o$1);
							continue;
						}
						const r$1 = o$1.overscaledZ + ke.maxOverzooming, s$1 = t$2.filter(((e$2) => e$2.tileID.overscaledZ <= r$1));
						if (!s$1.length) {
							a$1.add(o$1);
							continue;
						}
						const n$1 = Math.min(...s$1.map(((e$2) => e$2.tileID.overscaledZ))), l$1 = s$1.filter(((e$2) => e$2.tileID.overscaledZ === n$1)).map(((e$2) => e$2.tileID));
						for (const t$3 of l$1) e$1[t$3.key] = t$3;
						this._areDescendentsComplete(l$1, n$1, o$1.overscaledZ) || a$1.add(o$1);
					}
					return a$1;
				}
				_getLoadedDescendents(e$1) {
					var t$1;
					const i$1 = {};
					for (const a$1 of this._inViewTiles.getAllTiles().filter(((e$2) => e$2.hasData()))) for (const o$1 of e$1) a$1.tileID.isChildOf(o$1) && (i$1[t$1 = o$1.key] || (i$1[t$1] = [])).push(a$1);
					return i$1;
				}
				_areDescendentsComplete(e$1, t$1, i$1) {
					return 1 === e$1.length && e$1[0].isOverscaled() ? e$1[0].overscaledZ === t$1 : Math.pow(4, t$1 - i$1) === e$1.length;
				}
				getLoadedTile(e$1) {
					return this._inViewTiles.getLoadedTile(e$1);
				}
				updateCacheSize(e$1) {
					const i$1 = Math.ceil(e$1.width / this._source.tileSize) + 1, a$1 = Math.ceil(e$1.height / this._source.tileSize) + 1, o$1 = Math.floor(i$1 * a$1 * (null === this._maxTileCacheZoomLevels ? t.c.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), r$1 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, o$1) : o$1;
					this._outOfViewCache.setMaxSize(r$1);
				}
				handleWrapJump(e$1) {
					const t$1 = Math.round((e$1 - (void 0 === this._prevLng ? e$1 : this._prevLng)) / 360);
					this._prevLng = e$1, t$1 && (this._inViewTiles.handleWrapJump(t$1), this._resetTileReloadTimers());
				}
				update(e$1, i$1) {
					if (!this._sourceLoaded || this._paused) return;
					let a$1;
					this.transform = e$1, this.terrain = i$1, this.updateCacheSize(e$1), this.handleWrapJump(this.transform.center.lng), this.used || this.usedForTerrain ? this._source.tileID ? a$1 = e$1.getVisibleUnwrappedCoordinates(this._source.tileID).map(((e$2) => new t.a2(e$2.canonical.z, e$2.wrap, e$2.canonical.z, e$2.canonical.x, e$2.canonical.y))) : (a$1 = Ie(e$1, {
						tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize,
						minzoom: this._source.minzoom,
						maxzoom: "vector" === this._source.type && void 0 !== this.map._zoomLevelsToOverscale ? e$1.maxZoom - this.map._zoomLevelsToOverscale : this._source.maxzoom,
						roundZoom: !this.usedForTerrain && this._source.roundZoom,
						reparseOverscaled: this._source.reparseOverscaled,
						terrain: i$1,
						calculateTileZoom: this._source.calculateTileZoom
					}), this._source.hasTile && (a$1 = a$1.filter(((e$2) => this._source.hasTile(e$2))))) : a$1 = [], this.usedForTerrain && (a$1 = this._addTerrainIdealTiles(a$1));
					const o$1 = 0 === a$1.length && !this._updated && this._didEmitContent;
					this._updated = !0, o$1 && this.fire(new t.l("data", {
						sourceDataType: "idle",
						dataType: "source",
						sourceId: this.id
					}));
					const r$1 = Ce(e$1, this._source), s$1 = this._updateRetainedTiles(a$1, r$1), n$1 = Ee(this._source.type);
					n$1 && this._rasterFadeDuration > 0 && !i$1 && function(e$2, i$2, a$2, o$2, r$2, s$2, n$2) {
						const l$1 = c(), h$1 = t.av(i$2);
						for (const t$1 of i$2) {
							const i$3 = e$2.getTileById(t$1.key);
							i$3.fadingDirection !== ue.Departing && 0 !== i$3.fadeOpacity || i$3.resetFadeLogic(), Se(e$2, i$3, a$2, l$1, o$2, r$2, n$2) || ze(e$2, i$3, a$2, l$1, s$2, n$2) || De(i$3, h$1, l$1, n$2) || i$3.resetFadeLogic();
						}
					}(this._inViewTiles, a$1, s$1, this._maxFadingAncestorLevels, this._source.minzoom, this._source.maxzoom, this._rasterFadeDuration), n$1 ? this._cleanUpRasterTiles(s$1) : this._cleanUpVectorTiles(s$1);
				}
				_cleanUpRasterTiles(e$1) {
					for (const t$1 of this._inViewTiles.getAllIds()) e$1[t$1] || this._removeTile(t$1);
				}
				_cleanUpVectorTiles(e$1) {
					for (const t$1 of this._inViewTiles.getAllIds()) {
						const i$1 = this._inViewTiles.getTileById(t$1);
						e$1[t$1] ? i$1.clearSymbolFadeHold() : i$1.hasSymbolBuckets ? i$1.holdingForSymbolFade() ? i$1.symbolFadeFinished() && this._removeTile(t$1) : i$1.setSymbolHoldDuration(this.map._fadeDuration) : this._removeTile(t$1);
					}
				}
				_addTerrainIdealTiles(e$1) {
					const t$1 = [];
					for (const i$1 of e$1) if (i$1.canonical.z > this._source.minzoom) {
						const e$2 = i$1.scaledTo(i$1.canonical.z - 1);
						t$1.push(e$2);
						const a$1 = i$1.scaledTo(Math.max(this._source.minzoom, Math.min(i$1.canonical.z, 5)));
						t$1.push(a$1);
					}
					return e$1.concat(t$1);
				}
				releaseSymbolFadeTiles() {
					for (const e$1 of this._inViewTiles.getAllIds()) this._inViewTiles.getTileById(e$1).holdingForSymbolFade() && this._removeTile(e$1);
				}
				_updateRetainedTiles(e$1, t$1) {
					var i$1;
					const a$1 = /* @__PURE__ */ new Set();
					for (const t$2 of e$1) this._addTile(t$2).hasData() || a$1.add(t$2);
					const o$1 = e$1.reduce(((e$2, t$2) => (e$2[t$2.key] = t$2, e$2)), {}), r$1 = this._retainLoadedChildren(o$1, a$1), s$1 = {}, n$1 = Math.max(t$1 - ke.maxUnderzooming, this._source.minzoom);
					for (const e$2 of r$1) {
						let t$2 = this._inViewTiles.getTileById(e$2.key), a$2 = null == t$2 ? void 0 : t$2.wasRequested();
						for (let r$2 = e$2.overscaledZ - 1; r$2 >= n$1; --r$2) {
							const n$2 = e$2.scaledTo(r$2);
							if (s$1[n$2.key]) break;
							if (s$1[n$2.key] = !0, t$2 = this.getTile(n$2), !t$2 && a$2 && (t$2 = this._addTile(n$2)), t$2) {
								const e$3 = t$2.hasData();
								if ((e$3 || !(null === (i$1 = this.map) || void 0 === i$1 ? void 0 : i$1.cancelPendingTileRequestsWhileZooming) || a$2) && (o$1[n$2.key] = n$2), a$2 = t$2.wasRequested(), e$3) break;
							}
						}
					}
					return o$1;
				}
				_addTile(e$1) {
					let i$1 = this._inViewTiles.getTileById(e$1.key);
					if (i$1) return i$1;
					i$1 = this._outOfViewCache.getAndRemove(e$1), i$1 && (i$1.resetFadeLogic(), this._setTileReloadTimer(e$1.key, i$1), i$1.tileID = e$1, this._state.initializeTileState(i$1, this.map ? this.map.painter : null));
					const a$1 = i$1;
					return i$1 || (i$1 = new de(e$1, this._source.tileSize * e$1.overscaleFactor()), this._loadTile(i$1, e$1.key, i$1.state)), i$1.uses++, this._inViewTiles.setTile(e$1.key, i$1), a$1 || this._source.fire(new t.l("dataloading", {
						tile: i$1,
						coord: i$1.tileID,
						dataType: "source"
					})), i$1;
				}
				_setTileReloadTimer(e$1, t$1) {
					this._clearTileReloadTimer(e$1);
					const i$1 = t$1.getExpiryTimeout();
					i$1 && (this._timers[e$1] = setTimeout((() => {
						this._reloadTile(e$1, "expired"), delete this._timers[e$1];
					}), i$1));
				}
				_clearTileReloadTimer(e$1) {
					const t$1 = this._timers[e$1];
					t$1 && (clearTimeout(t$1), delete this._timers[e$1]);
				}
				_resetTileReloadTimers() {
					for (const e$1 in this._timers) clearTimeout(this._timers[e$1]), delete this._timers[e$1];
					for (const e$1 of this._inViewTiles.getAllIds()) {
						const t$1 = this._inViewTiles.getTileById(e$1);
						this._setTileReloadTimer(e$1, t$1);
					}
				}
				refreshTiles(e$1) {
					for (const t$1 of this._inViewTiles.getAllIds()) {
						const i$1 = this._inViewTiles.getTileById(t$1);
						(this._inViewTiles.isIdRenderable(t$1) || "errored" == i$1.state) && e$1.some(((e$2) => e$2.equals(i$1.tileID.canonical))) && this._reloadTile(t$1, "expired");
					}
				}
				_removeTile(e$1) {
					const t$1 = this._inViewTiles.getTileById(e$1);
					t$1 && (t$1.uses--, this._inViewTiles.deleteTileById(e$1), this._clearTileReloadTimer(e$1), t$1.uses > 0 || (t$1.hasData() && "reloading" !== t$1.state ? this._outOfViewCache.add(t$1.tileID, t$1, t$1.getExpiryTimeout()) : (t$1.aborted = !0, this._abortTile(t$1), this._unloadTile(t$1))));
				}
				_dataHandler(e$1) {
					"source" === e$1.dataType && ("metadata" !== e$1.sourceDataType ? "content" === e$1.sourceDataType && this._sourceLoaded && !this._paused && (this.reload(e$1.sourceDataChanged, e$1.shouldReloadTileOptions), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0) : this._sourceLoaded = !0);
				}
				clearTiles() {
					this._shouldReloadOnResume = !1, this._paused = !1;
					for (const e$1 of this._inViewTiles.getAllIds()) this._removeTile(e$1);
					this._outOfViewCache.reset();
				}
				tilesIn(e$1, i$1, a$1) {
					const o$1 = [], r$1 = this.transform;
					if (!r$1) return o$1;
					const s$1 = r$1.getCoveringTilesDetailsProvider().allowWorldCopies(), n$1 = a$1 ? r$1.getCameraQueryGeometry(e$1) : e$1, l$1 = (e$2) => r$1.screenPointToMercatorCoordinate(e$2, this.terrain), c$1 = this.transformBbox(e$1, l$1, !s$1), h$1 = this.transformBbox(n$1, l$1, !s$1), u$1 = this.getIds(), d$1 = t.aa.fromPoints(h$1);
					for (let e$2 = 0; e$2 < u$1.length; e$2++) {
						const a$2 = this._inViewTiles.getTileById(u$1[e$2]);
						if (a$2.holdingForSymbolFade()) continue;
						const n$2 = s$1 ? [a$2.tileID] : [a$2.tileID.unwrapTo(-1), a$2.tileID.unwrapTo(0)], l$2 = Math.pow(2, r$1.zoom - a$2.tileID.overscaledZ), _$1 = i$1 * a$2.queryPadding * t.a5 / a$2.tileSize / l$2;
						for (const e$3 of n$2) {
							const i$2 = d$1.map(((i$3) => e$3.getTilePoint(new t.a9(i$3.x, i$3.y))));
							if (i$2.expandBy(_$1), i$2.intersects(Me)) {
								const t$1 = c$1.map(((t$2) => e$3.getTilePoint(t$2))), i$3 = h$1.map(((t$2) => e$3.getTilePoint(t$2)));
								o$1.push({
									tile: a$2,
									tileID: s$1 ? e$3 : e$3.unwrapTo(0),
									queryGeometry: t$1,
									cameraQueryGeometry: i$3,
									scale: l$2
								});
							}
						}
					}
					return o$1;
				}
				transformBbox(e$1, i$1, a$1) {
					let o$1 = e$1.map(i$1);
					if (a$1) {
						const a$2 = t.aa.fromPoints(e$1);
						a$2.shrinkBy(.001 * Math.min(a$2.width(), a$2.height()));
						const r$1 = a$2.map(i$1);
						t.aa.fromPoints(o$1).covers(r$1) || (o$1 = o$1.map(((e$2) => e$2.x > .5 ? new t.a9(e$2.x - 1, e$2.y, e$2.z) : e$2)));
					}
					return o$1;
				}
				getVisibleCoordinates(e$1) {
					const t$1 = this.getRenderableIds(e$1).map(((e$2) => this._inViewTiles.getTileById(e$2).tileID));
					return this.transform && this.transform.populateCache(t$1), t$1;
				}
				hasTransition() {
					return !!this._source.hasTransition() || !(!Ee(this._source.type) || !function(e$1, t$1) {
						if (t$1 <= 0) return !1;
						const i$1 = c();
						for (const t$2 of e$1.getAllTiles()) if (t$2.fadeEndTime >= i$1) return !0;
						return !1;
					}(this._inViewTiles, this._rasterFadeDuration));
				}
				setRasterFadeDuration(e$1) {
					this._rasterFadeDuration = e$1;
				}
				setFeatureState(e$1, i$1, a$1) {
					this._state.updateState(e$1 = e$1 || t.ai, i$1, a$1);
				}
				removeFeatureState(e$1, i$1, a$1) {
					this._state.removeFeatureState(e$1 = e$1 || t.ai, i$1, a$1);
				}
				getFeatureState(e$1, i$1) {
					return this._state.getState(e$1 = e$1 || t.ai, i$1);
				}
				setDependencies(e$1, t$1, i$1) {
					const a$1 = this._inViewTiles.getTileById(e$1);
					a$1 && a$1.setDependencies(t$1, i$1);
				}
				reloadTilesForDependencies(e$1, t$1) {
					for (const i$1 of this._inViewTiles.getAllIds()) this._inViewTiles.getTileById(i$1).hasDependency(e$1, t$1) && this._reloadTile(i$1, "reloading");
					this._outOfViewCache.filter(((i$1) => !i$1.hasDependency(e$1, t$1)));
				}
				areTilesLoaded() {
					for (const e$1 of this._inViewTiles.getAllTiles()) if ("loaded" !== e$1.state && "errored" !== e$1.state) return !1;
					return !0;
				}
			}
			ke.maxUnderzooming = 10, ke.maxOverzooming = 3;
			class Fe {
				constructor(e$1, t$1) {
					this.reset(e$1, t$1);
				}
				reset(e$1, t$1) {
					this.points = e$1 || [], this._distances = [0];
					for (let e$2 = 1; e$2 < this.points.length; e$2++) this._distances[e$2] = this._distances[e$2 - 1] + this.points[e$2].dist(this.points[e$2 - 1]);
					this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t$1 || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding;
				}
				lerp(e$1) {
					if (1 === this.points.length) return this.points[0];
					e$1 = t.an(e$1, 0, 1);
					let i$1 = 1, a$1 = this._distances[i$1];
					const o$1 = e$1 * this.paddedLength + this.padding;
					for (; a$1 < o$1 && i$1 < this._distances.length;) a$1 = this._distances[++i$1];
					const r$1 = i$1 - 1, s$1 = this._distances[r$1], n$1 = a$1 - s$1, l$1 = n$1 > 0 ? (o$1 - s$1) / n$1 : 0;
					return this.points[r$1].mult(1 - l$1).add(this.points[i$1].mult(l$1));
				}
			}
			function Be(e$1, t$1) {
				let i$1 = !0;
				return "always" === e$1 || "never" !== e$1 && "never" !== t$1 || (i$1 = !1), i$1;
			}
			class Oe {
				constructor(e$1, t$1, i$1) {
					const a$1 = this.boxCells = [], o$1 = this.circleCells = [];
					this.xCellCount = Math.ceil(e$1 / i$1), this.yCellCount = Math.ceil(t$1 / i$1);
					for (let e$2 = 0; e$2 < this.xCellCount * this.yCellCount; e$2++) a$1.push([]), o$1.push([]);
					this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e$1, this.height = t$1, this.xScale = this.xCellCount / e$1, this.yScale = this.yCellCount / t$1, this.boxUid = 0, this.circleUid = 0;
				}
				keysLength() {
					return this.boxKeys.length + this.circleKeys.length;
				}
				insert(e$1, t$1, i$1, a$1, o$1) {
					this._forEachCell(t$1, i$1, a$1, o$1, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e$1), this.bboxes.push(t$1), this.bboxes.push(i$1), this.bboxes.push(a$1), this.bboxes.push(o$1);
				}
				insertCircle(e$1, t$1, i$1, a$1) {
					this._forEachCell(t$1 - a$1, i$1 - a$1, t$1 + a$1, i$1 + a$1, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e$1), this.circles.push(t$1), this.circles.push(i$1), this.circles.push(a$1);
				}
				_insertBoxCell(e$1, t$1, i$1, a$1, o$1, r$1) {
					this.boxCells[o$1].push(r$1);
				}
				_insertCircleCell(e$1, t$1, i$1, a$1, o$1, r$1) {
					this.circleCells[o$1].push(r$1);
				}
				_query(e$1, t$1, i$1, a$1, o$1, r$1, s$1) {
					if (i$1 < 0 || e$1 > this.width || a$1 < 0 || t$1 > this.height) return [];
					const n$1 = [];
					if (e$1 <= 0 && t$1 <= 0 && this.width <= i$1 && this.height <= a$1) {
						if (o$1) return [{
							key: null,
							x1: e$1,
							y1: t$1,
							x2: i$1,
							y2: a$1
						}];
						for (let e$2 = 0; e$2 < this.boxKeys.length; e$2++) n$1.push({
							key: this.boxKeys[e$2],
							x1: this.bboxes[4 * e$2],
							y1: this.bboxes[4 * e$2 + 1],
							x2: this.bboxes[4 * e$2 + 2],
							y2: this.bboxes[4 * e$2 + 3]
						});
						for (let e$2 = 0; e$2 < this.circleKeys.length; e$2++) {
							const t$2 = this.circles[3 * e$2], i$2 = this.circles[3 * e$2 + 1], a$2 = this.circles[3 * e$2 + 2];
							n$1.push({
								key: this.circleKeys[e$2],
								x1: t$2 - a$2,
								y1: i$2 - a$2,
								x2: t$2 + a$2,
								y2: i$2 + a$2
							});
						}
					} else this._forEachCell(e$1, t$1, i$1, a$1, this._queryCell, n$1, {
						hitTest: o$1,
						overlapMode: r$1,
						seenUids: {
							box: {},
							circle: {}
						}
					}, s$1);
					return n$1;
				}
				query(e$1, t$1, i$1, a$1) {
					return this._query(e$1, t$1, i$1, a$1, !1, null);
				}
				hitTest(e$1, t$1, i$1, a$1, o$1, r$1) {
					return this._query(e$1, t$1, i$1, a$1, !0, o$1, r$1).length > 0;
				}
				hitTestCircle(e$1, t$1, i$1, a$1, o$1) {
					const r$1 = e$1 - i$1, s$1 = e$1 + i$1, n$1 = t$1 - i$1, l$1 = t$1 + i$1;
					if (s$1 < 0 || r$1 > this.width || l$1 < 0 || n$1 > this.height) return !1;
					const c$1 = [];
					return this._forEachCell(r$1, n$1, s$1, l$1, this._queryCellCircle, c$1, {
						hitTest: !0,
						overlapMode: a$1,
						circle: {
							x: e$1,
							y: t$1,
							radius: i$1
						},
						seenUids: {
							box: {},
							circle: {}
						}
					}, o$1), c$1.length > 0;
				}
				_queryCell(e$1, t$1, i$1, a$1, o$1, r$1, s$1, n$1) {
					const { seenUids: l$1, hitTest: c$1, overlapMode: h$1 } = s$1, u$1 = this.boxCells[o$1];
					if (null !== u$1) {
						const o$2 = this.bboxes;
						for (const s$2 of u$1) if (!l$1.box[s$2]) {
							l$1.box[s$2] = !0;
							const u$2 = 4 * s$2, d$2 = this.boxKeys[s$2];
							if (e$1 <= o$2[u$2 + 2] && t$1 <= o$2[u$2 + 3] && i$1 >= o$2[u$2 + 0] && a$1 >= o$2[u$2 + 1] && (!n$1 || n$1(d$2)) && (!c$1 || !Be(h$1, d$2.overlapMode)) && (r$1.push({
								key: d$2,
								x1: o$2[u$2],
								y1: o$2[u$2 + 1],
								x2: o$2[u$2 + 2],
								y2: o$2[u$2 + 3]
							}), c$1)) return !0;
						}
					}
					const d$1 = this.circleCells[o$1];
					if (null !== d$1) {
						const o$2 = this.circles;
						for (const s$2 of d$1) if (!l$1.circle[s$2]) {
							l$1.circle[s$2] = !0;
							const u$2 = 3 * s$2, d$2 = this.circleKeys[s$2];
							if (this._circleAndRectCollide(o$2[u$2], o$2[u$2 + 1], o$2[u$2 + 2], e$1, t$1, i$1, a$1) && (!n$1 || n$1(d$2)) && (!c$1 || !Be(h$1, d$2.overlapMode))) {
								const e$2 = o$2[u$2], t$2 = o$2[u$2 + 1], i$2 = o$2[u$2 + 2];
								if (r$1.push({
									key: d$2,
									x1: e$2 - i$2,
									y1: t$2 - i$2,
									x2: e$2 + i$2,
									y2: t$2 + i$2
								}), c$1) return !0;
							}
						}
					}
					return !1;
				}
				_queryCellCircle(e$1, t$1, i$1, a$1, o$1, r$1, s$1, n$1) {
					const { circle: l$1, seenUids: c$1, overlapMode: h$1 } = s$1, u$1 = this.boxCells[o$1];
					if (null !== u$1) {
						const e$2 = this.bboxes;
						for (const t$2 of u$1) if (!c$1.box[t$2]) {
							c$1.box[t$2] = !0;
							const i$2 = 4 * t$2, a$2 = this.boxKeys[t$2];
							if (this._circleAndRectCollide(l$1.x, l$1.y, l$1.radius, e$2[i$2 + 0], e$2[i$2 + 1], e$2[i$2 + 2], e$2[i$2 + 3]) && (!n$1 || n$1(a$2)) && !Be(h$1, a$2.overlapMode)) return r$1.push(!0), !0;
						}
					}
					const d$1 = this.circleCells[o$1];
					if (null !== d$1) {
						const e$2 = this.circles;
						for (const t$2 of d$1) if (!c$1.circle[t$2]) {
							c$1.circle[t$2] = !0;
							const i$2 = 3 * t$2, a$2 = this.circleKeys[t$2];
							if (this._circlesCollide(e$2[i$2], e$2[i$2 + 1], e$2[i$2 + 2], l$1.x, l$1.y, l$1.radius) && (!n$1 || n$1(a$2)) && !Be(h$1, a$2.overlapMode)) return r$1.push(!0), !0;
						}
					}
				}
				_forEachCell(e$1, t$1, i$1, a$1, o$1, r$1, s$1, n$1) {
					const l$1 = this._convertToXCellCoord(e$1), c$1 = this._convertToYCellCoord(t$1), h$1 = this._convertToXCellCoord(i$1), u$1 = this._convertToYCellCoord(a$1);
					for (let d$1 = l$1; d$1 <= h$1; d$1++) for (let l$2 = c$1; l$2 <= u$1; l$2++) if (o$1.call(this, e$1, t$1, i$1, a$1, this.xCellCount * l$2 + d$1, r$1, s$1, n$1)) return;
				}
				_convertToXCellCoord(e$1) {
					return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e$1 * this.xScale)));
				}
				_convertToYCellCoord(e$1) {
					return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e$1 * this.yScale)));
				}
				_circlesCollide(e$1, t$1, i$1, a$1, o$1, r$1) {
					const s$1 = a$1 - e$1, n$1 = o$1 - t$1, l$1 = i$1 + r$1;
					return l$1 * l$1 > s$1 * s$1 + n$1 * n$1;
				}
				_circleAndRectCollide(e$1, t$1, i$1, a$1, o$1, r$1, s$1) {
					const n$1 = (r$1 - a$1) / 2, l$1 = Math.abs(e$1 - (a$1 + n$1));
					if (l$1 > n$1 + i$1) return !1;
					const c$1 = (s$1 - o$1) / 2, h$1 = Math.abs(t$1 - (o$1 + c$1));
					if (h$1 > c$1 + i$1) return !1;
					if (l$1 <= n$1 || h$1 <= c$1) return !0;
					const u$1 = l$1 - n$1, d$1 = h$1 - c$1;
					return u$1 * u$1 + d$1 * d$1 <= i$1 * i$1;
				}
			}
			function je(e$1, i$1, o$1) {
				const r$1 = t.N();
				if (!e$1) {
					const { vecSouth: e$2, vecEast: t$1 } = Ze(i$1), o$2 = a();
					o$2[0] = t$1[0], o$2[1] = t$1[1], o$2[2] = e$2[0], o$2[3] = e$2[1], s$1 = o$2, (d$1 = (l$1 = (n$1 = o$2)[0]) * (u$1 = n$1[3]) - (h$1 = n$1[2]) * (c$1 = n$1[1])) && (s$1[0] = u$1 * (d$1 = 1 / d$1), s$1[1] = -c$1 * d$1, s$1[2] = -h$1 * d$1, s$1[3] = l$1 * d$1), r$1[0] = o$2[0], r$1[1] = o$2[1], r$1[4] = o$2[2], r$1[5] = o$2[3];
				}
				var s$1, n$1, l$1, c$1, h$1, u$1, d$1;
				return t.Q(r$1, r$1, [
					1 / o$1,
					1 / o$1,
					1
				]), r$1;
			}
			function Ne(e$1, i$1, a$1, o$1) {
				if (e$1) {
					const e$2 = t.N();
					if (!i$1) {
						const { vecSouth: t$1, vecEast: i$2 } = Ze(a$1);
						e$2[0] = i$2[0], e$2[1] = i$2[1], e$2[4] = t$1[0], e$2[5] = t$1[1];
					}
					return t.Q(e$2, e$2, [
						o$1,
						o$1,
						1
					]), e$2;
				}
				return a$1.pixelsToClipSpaceMatrix;
			}
			function Ze(e$1) {
				const i$1 = Math.cos(e$1.rollInRadians), a$1 = Math.sin(e$1.rollInRadians), o$1 = Math.cos(e$1.pitchInRadians), r$1 = Math.cos(e$1.bearingInRadians), s$1 = Math.sin(e$1.bearingInRadians), n$1 = t.aC();
				n$1[0] = -r$1 * o$1 * a$1 - s$1 * i$1, n$1[1] = -s$1 * o$1 * a$1 + r$1 * i$1;
				const l$1 = t.aD(n$1);
				l$1 < 1e-9 ? t.aE(n$1) : t.aF(n$1, n$1, 1 / l$1);
				const c$1 = t.aC();
				c$1[0] = r$1 * o$1 * i$1 - s$1 * a$1, c$1[1] = s$1 * o$1 * i$1 + r$1 * a$1;
				const h$1 = t.aD(c$1);
				return h$1 < 1e-9 ? t.aE(c$1) : t.aF(c$1, c$1, 1 / h$1), {
					vecEast: c$1,
					vecSouth: n$1
				};
			}
			function Ue(e$1, i$1, a$1, o$1) {
				let r$1;
				o$1 ? (r$1 = [
					e$1,
					i$1,
					o$1(e$1, i$1),
					1
				], t.aH(r$1, r$1, a$1)) : (r$1 = [
					e$1,
					i$1,
					0,
					1
				], rt(r$1, r$1, a$1));
				const s$1 = r$1[3];
				return {
					point: new t.P(r$1[0] / s$1, r$1[1] / s$1),
					signedDistanceFromCamera: s$1,
					isOccluded: !1
				};
			}
			function Ge(e$1, t$1) {
				return .5 + e$1 / t$1 * .5;
			}
			function Ve(e$1, t$1) {
				return e$1.x >= -t$1[0] && e$1.x <= t$1[0] && e$1.y >= -t$1[1] && e$1.y <= t$1[1];
			}
			function qe(e$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$1) {
				const p$1 = a$1 ? e$1.textSizeData : e$1.iconSizeData, m$1 = t.ay(p$1, i$1.transform.zoom), f$1 = [256 / i$1.width * 2 + 1, 256 / i$1.height * 2 + 1], g$1 = a$1 ? e$1.text.dynamicLayoutVertexArray : e$1.icon.dynamicLayoutVertexArray;
				g$1.clear();
				const v$1 = e$1.lineVertexArray, x$1 = a$1 ? e$1.text.placedSymbolArray : e$1.icon.placedSymbolArray, b$1 = i$1.transform.width / i$1.transform.height;
				let y$1 = !1;
				for (let a$2 = 0; a$2 < x$1.length; a$2++) {
					const w$1 = x$1.get(a$2);
					if (w$1.hidden || w$1.writingMode === t.az.vertical && !y$1) {
						ot(w$1.numGlyphs, g$1);
						continue;
					}
					y$1 = !1;
					const T$1 = new t.P(w$1.anchorX, w$1.anchorY), P$1 = {
						getElevation: _$1,
						pitchedLabelPlaneMatrix: o$1,
						lineVertexArray: v$1,
						pitchWithMap: s$1,
						projectionCache: {
							projections: {},
							offsets: {},
							cachedAnchorPoint: void 0,
							anyProjectionOccluded: !1
						},
						transform: i$1.transform,
						tileAnchorPoint: T$1,
						unwrappedTileID: c$1,
						width: h$1,
						height: u$1,
						translation: d$1
					}, C$1 = Je(w$1.anchorX, w$1.anchorY, P$1);
					if (!Ve(C$1.point, f$1)) {
						ot(w$1.numGlyphs, g$1);
						continue;
					}
					const I$1 = Ge(i$1.transform.cameraToCenterDistance, C$1.signedDistanceFromCamera), M$1 = t.aA(p$1, m$1, w$1), E$1 = s$1 ? M$1 * i$1.transform.getPitchedTextCorrection(w$1.anchorX, w$1.anchorY, c$1) / I$1 : M$1 * I$1, S$1 = He({
						projectionContext: P$1,
						pitchedLabelPlaneMatrixInverse: r$1,
						symbol: w$1,
						fontSize: E$1,
						flip: !1,
						keepUpright: n$1,
						glyphOffsetArray: e$1.glyphOffsetArray,
						dynamicLayoutVertexArray: g$1,
						aspectRatio: b$1,
						rotateToLine: l$1
					});
					y$1 = S$1.useVertical, (S$1.notEnoughRoom || y$1 || S$1.needsFlipping && He({
						projectionContext: P$1,
						pitchedLabelPlaneMatrixInverse: r$1,
						symbol: w$1,
						fontSize: E$1,
						flip: !0,
						keepUpright: n$1,
						glyphOffsetArray: e$1.glyphOffsetArray,
						dynamicLayoutVertexArray: g$1,
						aspectRatio: b$1,
						rotateToLine: l$1
					}).notEnoughRoom) && ot(w$1.numGlyphs, g$1);
				}
				a$1 ? e$1.text.dynamicLayoutVertexBuffer.updateData(g$1) : e$1.icon.dynamicLayoutVertexBuffer.updateData(g$1);
			}
			function We(e$1, t$1, i$1, a$1, o$1, r$1, s$1, n$1) {
				const l$1 = r$1.glyphStartIndex + r$1.numGlyphs, c$1 = r$1.lineStartIndex, h$1 = r$1.lineStartIndex + r$1.lineLength, u$1 = t$1.getoffsetX(r$1.glyphStartIndex), d$1 = t$1.getoffsetX(l$1 - 1), _$1 = it(e$1 * u$1, i$1, a$1, o$1, r$1.segment, c$1, h$1, n$1, s$1);
				if (!_$1) return null;
				const p$1 = it(e$1 * d$1, i$1, a$1, o$1, r$1.segment, c$1, h$1, n$1, s$1);
				return p$1 ? n$1.projectionCache.anyProjectionOccluded ? null : {
					first: _$1,
					last: p$1
				} : null;
			}
			function $e(e$1, i$1, a$1, o$1) {
				return e$1 === t.az.horizontal && Math.abs(a$1.y - i$1.y) > Math.abs(a$1.x - i$1.x) * o$1 ? { useVertical: !0 } : (e$1 === t.az.vertical ? i$1.y < a$1.y : i$1.x > a$1.x) ? { needsFlipping: !0 } : null;
			}
			function He(e$1) {
				const { projectionContext: i$1, pitchedLabelPlaneMatrixInverse: a$1, symbol: o$1, fontSize: r$1, flip: s$1, keepUpright: n$1, glyphOffsetArray: l$1, dynamicLayoutVertexArray: c$1, aspectRatio: h$1, rotateToLine: u$1 } = e$1, d$1 = r$1 / 24, _$1 = o$1.lineOffsetX * d$1, p$1 = o$1.lineOffsetY * d$1;
				let m$1;
				if (o$1.numGlyphs > 1) {
					const e$2 = o$1.glyphStartIndex + o$1.numGlyphs, t$1 = o$1.lineStartIndex, r$2 = o$1.lineStartIndex + o$1.lineLength, c$2 = We(d$1, l$1, _$1, p$1, s$1, o$1, u$1, i$1);
					if (!c$2) return { notEnoughRoom: !0 };
					const f$1 = Qe(c$2.first.point.x, c$2.first.point.y, i$1, a$1), g$1 = Qe(c$2.last.point.x, c$2.last.point.y, i$1, a$1);
					if (n$1 && !s$1) {
						const e$3 = $e(o$1.writingMode, f$1, g$1, h$1);
						if (e$3) return e$3;
					}
					m$1 = [c$2.first];
					for (let a$2 = o$1.glyphStartIndex + 1; a$2 < e$2 - 1; a$2++) {
						const e$3 = it(d$1 * l$1.getoffsetX(a$2), _$1, p$1, s$1, o$1.segment, t$1, r$2, i$1, u$1);
						if (!e$3) return { notEnoughRoom: !0 };
						m$1.push(e$3);
					}
					m$1.push(c$2.last);
				} else {
					if (n$1 && !s$1) {
						const e$3 = Ye(i$1.tileAnchorPoint.x, i$1.tileAnchorPoint.y, i$1).point, r$2 = o$1.lineStartIndex + o$1.segment + 1, s$2 = new t.P(i$1.lineVertexArray.getx(r$2), i$1.lineVertexArray.gety(r$2)), n$2 = Ye(s$2.x, s$2.y, i$1), l$2 = n$2.signedDistanceFromCamera > 0 ? n$2.point : Xe(i$1.tileAnchorPoint, s$2, e$3, 1, i$1), c$2 = Qe(e$3.x, e$3.y, i$1, a$1), u$2 = Qe(l$2.x, l$2.y, i$1, a$1), d$2 = $e(o$1.writingMode, c$2, u$2, h$1);
						if (d$2) return d$2;
					}
					const e$2 = it(d$1 * l$1.getoffsetX(o$1.glyphStartIndex), _$1, p$1, s$1, o$1.segment, o$1.lineStartIndex, o$1.lineStartIndex + o$1.lineLength, i$1, u$1);
					if (!e$2 || i$1.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 };
					m$1 = [e$2];
				}
				for (const e$2 of m$1) t.aG(c$1, e$2.point, e$2.angle);
				return {};
			}
			function Xe(e$1, t$1, i$1, a$1, o$1) {
				const r$1 = e$1.add(e$1.sub(t$1)._unit()), s$1 = Ye(r$1.x, r$1.y, o$1).point, n$1 = i$1.sub(s$1);
				return i$1.add(n$1._mult(a$1 / n$1.mag()));
			}
			function Ke(e$1, i$1, a$1) {
				const o$1 = i$1.projectionCache;
				if (o$1.projections[e$1]) return o$1.projections[e$1];
				const r$1 = new t.P(i$1.lineVertexArray.getx(e$1), i$1.lineVertexArray.gety(e$1)), s$1 = Ye(r$1.x, r$1.y, i$1);
				if (s$1.signedDistanceFromCamera > 0) return o$1.projections[e$1] = s$1.point, o$1.anyProjectionOccluded = o$1.anyProjectionOccluded || s$1.isOccluded, s$1.point;
				const n$1 = e$1 - a$1.direction;
				return Xe(0 === a$1.distanceFromAnchor ? i$1.tileAnchorPoint : new t.P(i$1.lineVertexArray.getx(n$1), i$1.lineVertexArray.gety(n$1)), r$1, a$1.previousVertex, a$1.absOffsetX - a$1.distanceFromAnchor + 1, i$1);
			}
			function Ye(e$1, t$1, i$1) {
				const a$1 = e$1 + i$1.translation[0], o$1 = t$1 + i$1.translation[1];
				let r$1;
				return i$1.pitchWithMap ? (r$1 = Ue(a$1, o$1, i$1.pitchedLabelPlaneMatrix, i$1.getElevation), r$1.isOccluded = !1) : (r$1 = i$1.transform.projectTileCoordinates(a$1, o$1, i$1.unwrappedTileID, i$1.getElevation), r$1.point.x = (.5 * r$1.point.x + .5) * i$1.width, r$1.point.y = (.5 * -r$1.point.y + .5) * i$1.height), r$1;
			}
			function Qe(e$1, i$1, a$1, o$1) {
				if (a$1.pitchWithMap) {
					const r$1 = [
						e$1,
						i$1,
						0,
						1
					];
					return t.aH(r$1, r$1, o$1), a$1.transform.projectTileCoordinates(r$1[0] / r$1[3], r$1[1] / r$1[3], a$1.unwrappedTileID, a$1.getElevation).point;
				}
				return {
					x: e$1 / a$1.width * 2 - 1,
					y: 1 - i$1 / a$1.height * 2
				};
			}
			function Je(e$1, t$1, i$1) {
				return i$1.transform.projectTileCoordinates(e$1, t$1, i$1.unwrappedTileID, i$1.getElevation);
			}
			function et(e$1, t$1, i$1) {
				return e$1._unit()._perp()._mult(t$1 * i$1);
			}
			function tt(e$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1, c$1) {
				if (l$1.projectionCache.offsets[e$1]) return l$1.projectionCache.offsets[e$1];
				const h$1 = a$1.add(i$1);
				if (e$1 + c$1.direction < o$1 || e$1 + c$1.direction >= r$1) return l$1.projectionCache.offsets[e$1] = h$1, h$1;
				const u$1 = Ke(e$1 + c$1.direction, l$1, c$1), d$1 = et(u$1.sub(a$1), n$1, c$1.direction), _$1 = a$1.add(d$1), p$1 = u$1.add(d$1);
				return l$1.projectionCache.offsets[e$1] = t.aI(s$1, h$1, _$1, p$1) || h$1, l$1.projectionCache.offsets[e$1];
			}
			function it(e$1, t$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1) {
				const c$1 = a$1 ? e$1 - t$1 : e$1 + t$1;
				let h$1 = c$1 > 0 ? 1 : -1, u$1 = 0;
				a$1 && (h$1 *= -1, u$1 = Math.PI), h$1 < 0 && (u$1 += Math.PI);
				let d$1, _$1 = h$1 > 0 ? r$1 + o$1 : r$1 + o$1 + 1;
				n$1.projectionCache.cachedAnchorPoint ? d$1 = n$1.projectionCache.cachedAnchorPoint : (d$1 = Ye(n$1.tileAnchorPoint.x, n$1.tileAnchorPoint.y, n$1).point, n$1.projectionCache.cachedAnchorPoint = d$1);
				let p$1, m$1, f$1 = d$1, g$1 = d$1, v$1 = 0, x$1 = 0;
				const b$1 = Math.abs(c$1), y$1 = [];
				let w$1;
				for (; v$1 + x$1 <= b$1;) {
					if (_$1 += h$1, _$1 < r$1 || _$1 >= s$1) return null;
					v$1 += x$1, g$1 = f$1, m$1 = p$1;
					const e$2 = {
						absOffsetX: b$1,
						direction: h$1,
						distanceFromAnchor: v$1,
						previousVertex: g$1
					};
					if (f$1 = Ke(_$1, n$1, e$2), 0 === i$1) y$1.push(g$1), w$1 = f$1.sub(g$1);
					else {
						let t$2;
						const a$2 = f$1.sub(g$1);
						t$2 = 0 === a$2.mag() ? et(Ke(_$1 + h$1, n$1, e$2).sub(f$1), i$1, h$1) : et(a$2, i$1, h$1), m$1 || (m$1 = g$1.add(t$2)), p$1 = tt(_$1, t$2, f$1, r$1, s$1, m$1, i$1, n$1, e$2), y$1.push(m$1), w$1 = p$1.sub(m$1);
					}
					x$1 = w$1.mag();
				}
				const T$1 = w$1._mult((b$1 - v$1) / x$1)._add(m$1 || g$1), P$1 = u$1 + Math.atan2(f$1.y - g$1.y, f$1.x - g$1.x);
				return y$1.push(T$1), {
					point: T$1,
					angle: l$1 ? P$1 : 0,
					path: y$1
				};
			}
			const at = new Float32Array([
				-Infinity,
				-Infinity,
				0,
				-Infinity,
				-Infinity,
				0,
				-Infinity,
				-Infinity,
				0,
				-Infinity,
				-Infinity,
				0
			]);
			function ot(e$1, t$1) {
				for (let i$1 = 0; i$1 < e$1; i$1++) {
					const e$2 = t$1.length;
					t$1.resize(e$2 + 4), t$1.float32.set(at, 3 * e$2);
				}
			}
			function rt(e$1, t$1, i$1) {
				const a$1 = t$1[0], o$1 = t$1[1];
				return e$1[0] = i$1[0] * a$1 + i$1[4] * o$1 + i$1[12], e$1[1] = i$1[1] * a$1 + i$1[5] * o$1 + i$1[13], e$1[3] = i$1[3] * a$1 + i$1[7] * o$1 + i$1[15], e$1;
			}
			const st = 100;
			class nt {
				constructor(e$1, t$1 = new Oe(e$1.width + 200, e$1.height + 200, 25), i$1 = new Oe(e$1.width + 200, e$1.height + 200, 25)) {
					this.transform = e$1, this.grid = t$1, this.ignoredGrid = i$1, this.pitchFactor = Math.cos(e$1.pitch * Math.PI / 180) * e$1.cameraToCenterDistance, this.screenRightBoundary = e$1.width + st, this.screenBottomBoundary = e$1.height + st, this.gridRightBoundary = e$1.width + 200, this.gridBottomBoundary = e$1.height + 200, this.perspectiveRatioCutoff = .6;
				}
				placeCollisionBox(e$1, t$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1, c$1, h$1, u$1) {
					const d$1 = this.projectAndGetPerspectiveRatio(e$1.anchorPointX + n$1[0], e$1.anchorPointY + n$1[1], o$1, c$1, u$1), _$1 = i$1 * d$1.perspectiveRatio;
					let p$1;
					if (r$1 || s$1) p$1 = this._projectCollisionBox(e$1, _$1, a$1, o$1, r$1, s$1, n$1, d$1, c$1, h$1, u$1);
					else {
						const t$2 = d$1.x + (h$1 ? h$1.x * _$1 : 0), i$2 = d$1.y + (h$1 ? h$1.y * _$1 : 0);
						p$1 = {
							allPointsOccluded: !1,
							box: [
								t$2 + e$1.x1 * _$1,
								i$2 + e$1.y1 * _$1,
								t$2 + e$1.x2 * _$1,
								i$2 + e$1.y2 * _$1
							]
						};
					}
					const [m$1, f$1, g$1, v$1] = p$1.box, x$1 = r$1 ? p$1.allPointsOccluded : d$1.isOccluded;
					let b$1 = x$1;
					return b$1 || (b$1 = d$1.perspectiveRatio < this.perspectiveRatioCutoff), b$1 || (b$1 = !this.isInsideGrid(m$1, f$1, g$1, v$1)), b$1 || "always" !== t$1 && this.grid.hitTest(m$1, f$1, g$1, v$1, t$1, l$1) ? {
						box: [
							m$1,
							f$1,
							g$1,
							v$1
						],
						placeable: !1,
						offscreen: !1,
						occluded: x$1
					} : {
						box: [
							m$1,
							f$1,
							g$1,
							v$1
						],
						placeable: !0,
						offscreen: this.isOffscreen(m$1, f$1, g$1, v$1),
						occluded: x$1
					};
				}
				placeCollisionCircles(e$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$1, p$1) {
					const m$1 = [], f$1 = new t.P(i$1.anchorX, i$1.anchorY), g$1 = this.getPerspectiveRatio(f$1.x, f$1.y, s$1, p$1), v$1 = (c$1 ? r$1 * this.transform.getPitchedTextCorrection(i$1.anchorX, i$1.anchorY, s$1) / g$1 : r$1 * g$1) / t.aM, x$1 = {
						getElevation: p$1,
						pitchedLabelPlaneMatrix: n$1,
						lineVertexArray: a$1,
						pitchWithMap: c$1,
						projectionCache: {
							projections: {},
							offsets: {},
							cachedAnchorPoint: void 0,
							anyProjectionOccluded: !1
						},
						transform: this.transform,
						tileAnchorPoint: f$1,
						unwrappedTileID: s$1,
						width: this.transform.width,
						height: this.transform.height,
						translation: _$1
					}, b$1 = We(v$1, o$1, i$1.lineOffsetX * v$1, i$1.lineOffsetY * v$1, !1, i$1, !1, x$1);
					let y$1 = !1, w$1 = !1, T$1 = !0;
					if (b$1) {
						const i$2 = .5 * u$1 * g$1 + d$1, a$2 = new t.P(-100, -100), o$2 = new t.P(this.screenRightBoundary, this.screenBottomBoundary), r$2 = new Fe(), s$2 = b$1.first, n$2 = b$1.last;
						let _$2 = [];
						for (let e$2 = s$2.path.length - 1; e$2 >= 1; e$2--) _$2.push(s$2.path[e$2]);
						for (let e$2 = 1; e$2 < n$2.path.length; e$2++) _$2.push(n$2.path[e$2]);
						const p$2 = 2.5 * i$2;
						if (c$1) {
							const e$2 = this.projectPathToScreenSpace(_$2, x$1);
							_$2 = e$2.some(((e$3) => e$3.signedDistanceFromCamera <= 0)) ? [] : e$2.map(((e$3) => e$3.point));
						}
						let f$2 = [];
						if (_$2.length > 0) {
							const e$2 = _$2[0].clone(), i$3 = _$2[0].clone();
							for (let t$1 = 1; t$1 < _$2.length; t$1++) e$2.x = Math.min(e$2.x, _$2[t$1].x), e$2.y = Math.min(e$2.y, _$2[t$1].y), i$3.x = Math.max(i$3.x, _$2[t$1].x), i$3.y = Math.max(i$3.y, _$2[t$1].y);
							f$2 = e$2.x >= a$2.x && i$3.x <= o$2.x && e$2.y >= a$2.y && i$3.y <= o$2.y ? [_$2] : i$3.x < a$2.x || e$2.x > o$2.x || i$3.y < a$2.y || e$2.y > o$2.y ? [] : t.aJ([_$2], a$2.x, a$2.y, o$2.x, o$2.y);
						}
						for (const t$1 of f$2) {
							r$2.reset(t$1, .25 * i$2);
							let a$3 = 0;
							a$3 = r$2.length <= .5 * i$2 ? 1 : Math.ceil(r$2.paddedLength / p$2) + 1;
							for (let t$2 = 0; t$2 < a$3; t$2++) {
								const o$3 = t$2 / Math.max(a$3 - 1, 1), s$3 = r$2.lerp(o$3), n$3 = s$3.x + st, c$2 = s$3.y + st;
								m$1.push(n$3, c$2, i$2, 0);
								const u$2 = n$3 - i$2, d$2 = c$2 - i$2, _$3 = n$3 + i$2, p$3 = c$2 + i$2;
								if (T$1 = T$1 && this.isOffscreen(u$2, d$2, _$3, p$3), w$1 = w$1 || this.isInsideGrid(u$2, d$2, _$3, p$3), "always" !== e$1 && this.grid.hitTestCircle(n$3, c$2, i$2, e$1, h$1) && (y$1 = !0, !l$1)) return {
									circles: [],
									offscreen: !1,
									collisionDetected: y$1
								};
							}
						}
					}
					return {
						circles: !l$1 && y$1 || !w$1 || g$1 < this.perspectiveRatioCutoff ? [] : m$1,
						offscreen: T$1,
						collisionDetected: y$1
					};
				}
				projectPathToScreenSpace(e$1, i$1) {
					return function(e$2) {
						let t$1 = 0, i$2 = 0, a$1 = 0, o$1 = 0;
						for (let r$1 = 0; r$1 < e$2.length; r$1++) e$2[r$1].isOccluded ? (a$1 = r$1 + 1, o$1 = 0) : (o$1++, o$1 > i$2 && (i$2 = o$1, t$1 = a$1));
						return e$2.slice(t$1, t$1 + i$2);
					}(function(e$2, i$2) {
						const a$1 = t.N();
						return t.aB(a$1, i$2.pitchedLabelPlaneMatrix), e$2.map(((e$3) => {
							const t$1 = Ue(e$3.x, e$3.y, a$1, i$2.getElevation), o$1 = i$2.transform.projectTileCoordinates(t$1.point.x, t$1.point.y, i$2.unwrappedTileID, i$2.getElevation);
							return o$1.point.x = (.5 * o$1.point.x + .5) * i$2.width, o$1.point.y = (.5 * -o$1.point.y + .5) * i$2.height, o$1;
						}));
					}(e$1, i$1));
				}
				queryRenderedSymbols(e$1) {
					if (0 === e$1.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
					const i$1 = [], a$1 = new t.aa();
					for (const o$2 of e$1) {
						const e$2 = new t.P(o$2.x + st, o$2.y + st);
						a$1.extend(e$2), i$1.push(e$2);
					}
					const { minX: o$1, minY: r$1, maxX: s$1, maxY: n$1 } = a$1, l$1 = this.grid.query(o$1, r$1, s$1, n$1).concat(this.ignoredGrid.query(o$1, r$1, s$1, n$1)), c$1 = {}, h$1 = {};
					for (const e$2 of l$1) {
						const a$2 = e$2.key;
						if (void 0 === c$1[a$2.bucketInstanceId] && (c$1[a$2.bucketInstanceId] = {}), c$1[a$2.bucketInstanceId][a$2.featureIndex]) continue;
						const o$2 = [
							new t.P(e$2.x1, e$2.y1),
							new t.P(e$2.x2, e$2.y1),
							new t.P(e$2.x2, e$2.y2),
							new t.P(e$2.x1, e$2.y2)
						];
						t.aK(i$1, o$2) && (c$1[a$2.bucketInstanceId][a$2.featureIndex] = !0, void 0 === h$1[a$2.bucketInstanceId] && (h$1[a$2.bucketInstanceId] = []), h$1[a$2.bucketInstanceId].push(a$2.featureIndex));
					}
					return h$1;
				}
				insertCollisionBox(e$1, t$1, i$1, a$1, o$1, r$1) {
					(i$1 ? this.ignoredGrid : this.grid).insert({
						bucketInstanceId: a$1,
						featureIndex: o$1,
						collisionGroupID: r$1,
						overlapMode: t$1
					}, e$1[0], e$1[1], e$1[2], e$1[3]);
				}
				insertCollisionCircles(e$1, t$1, i$1, a$1, o$1, r$1) {
					const s$1 = i$1 ? this.ignoredGrid : this.grid, n$1 = {
						bucketInstanceId: a$1,
						featureIndex: o$1,
						collisionGroupID: r$1,
						overlapMode: t$1
					};
					for (let t$2 = 0; t$2 < e$1.length; t$2 += 4) s$1.insertCircle(n$1, e$1[t$2], e$1[t$2 + 1], e$1[t$2 + 2]);
				}
				projectAndGetPerspectiveRatio(e$1, i$1, a$1, o$1, r$1) {
					if (r$1) {
						let a$2;
						o$1 ? (a$2 = [
							e$1,
							i$1,
							o$1(e$1, i$1),
							1
						], t.aH(a$2, a$2, r$1)) : (a$2 = [
							e$1,
							i$1,
							0,
							1
						], rt(a$2, a$2, r$1));
						const s$1 = a$2[3];
						return {
							x: (a$2[0] / s$1 + 1) / 2 * this.transform.width + st,
							y: (-a$2[1] / s$1 + 1) / 2 * this.transform.height + st,
							perspectiveRatio: .5 + this.transform.cameraToCenterDistance / s$1 * .5,
							isOccluded: !1,
							signedDistanceFromCamera: s$1
						};
					}
					{
						const t$1 = this.transform.projectTileCoordinates(e$1, i$1, a$1, o$1);
						return {
							x: (t$1.point.x + 1) / 2 * this.transform.width + st,
							y: (1 - t$1.point.y) / 2 * this.transform.height + st,
							perspectiveRatio: .5 + this.transform.cameraToCenterDistance / t$1.signedDistanceFromCamera * .5,
							isOccluded: t$1.isOccluded,
							signedDistanceFromCamera: t$1.signedDistanceFromCamera
						};
					}
				}
				getPerspectiveRatio(e$1, t$1, i$1, a$1) {
					const o$1 = this.transform.projectTileCoordinates(e$1, t$1, i$1, a$1);
					return .5 + this.transform.cameraToCenterDistance / o$1.signedDistanceFromCamera * .5;
				}
				isOffscreen(e$1, t$1, i$1, a$1) {
					return i$1 < st || e$1 >= this.screenRightBoundary || a$1 < st || t$1 > this.screenBottomBoundary;
				}
				isInsideGrid(e$1, t$1, i$1, a$1) {
					return i$1 >= 0 && e$1 < this.gridRightBoundary && a$1 >= 0 && t$1 < this.gridBottomBoundary;
				}
				getViewportMatrix() {
					const e$1 = t.ar([]);
					return t.O(e$1, e$1, [
						-100,
						-100,
						0
					]), e$1;
				}
				_projectCollisionBox(e$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1, c$1, h$1, u$1) {
					let d$1 = 1, _$1 = 0, p$1 = 0, m$1 = 1;
					const f$1 = e$1.anchorPointX + n$1[0], g$1 = e$1.anchorPointY + n$1[1];
					if (s$1 && !r$1) {
						const e$2 = this.projectAndGetPerspectiveRatio(f$1 + 1, g$1, o$1, c$1, u$1), t$1 = e$2.x - l$1.x, i$2 = Math.atan((e$2.y - l$1.y) / t$1) + (t$1 < 0 ? Math.PI : 0), a$2 = Math.sin(i$2), r$2 = Math.cos(i$2);
						d$1 = r$2, _$1 = a$2, p$1 = -a$2, m$1 = r$2;
					} else if (!s$1 && r$1) {
						const e$2 = Ze(this.transform);
						d$1 = e$2.vecEast[0], _$1 = e$2.vecEast[1], p$1 = e$2.vecSouth[0], m$1 = e$2.vecSouth[1];
					}
					let v$1 = l$1.x, x$1 = l$1.y, b$1 = i$1;
					r$1 && (v$1 = f$1, x$1 = g$1, b$1 = Math.pow(2, -(this.transform.zoom - a$1.overscaledZ)), b$1 *= this.transform.getPitchedTextCorrection(f$1, g$1, o$1), h$1 || (b$1 *= t.an(.5 + l$1.signedDistanceFromCamera / this.transform.cameraToCenterDistance * .5, 0, 4))), h$1 && (v$1 += d$1 * h$1.x * b$1 + p$1 * h$1.y * b$1, x$1 += _$1 * h$1.x * b$1 + m$1 * h$1.y * b$1);
					const y$1 = e$1.x1 * b$1, w$1 = e$1.x2 * b$1, T$1 = (y$1 + w$1) / 2, P$1 = e$1.y1 * b$1, C$1 = e$1.y2 * b$1, I$1 = (P$1 + C$1) / 2, M$1 = [
						{
							offsetX: y$1,
							offsetY: P$1
						},
						{
							offsetX: T$1,
							offsetY: P$1
						},
						{
							offsetX: w$1,
							offsetY: P$1
						},
						{
							offsetX: w$1,
							offsetY: I$1
						},
						{
							offsetX: w$1,
							offsetY: C$1
						},
						{
							offsetX: T$1,
							offsetY: C$1
						},
						{
							offsetX: y$1,
							offsetY: C$1
						},
						{
							offsetX: y$1,
							offsetY: I$1
						}
					];
					let E$1 = [];
					for (const { offsetX: e$2, offsetY: i$2 } of M$1) E$1.push(new t.P(v$1 + d$1 * e$2 + p$1 * i$2, x$1 + _$1 * e$2 + m$1 * i$2));
					let S$1 = !1;
					if (r$1) {
						const e$2 = E$1.map(((e$3) => this.projectAndGetPerspectiveRatio(e$3.x, e$3.y, o$1, c$1, u$1)));
						S$1 = e$2.some(((e$3) => !e$3.isOccluded)), E$1 = e$2.map(((e$3) => new t.P(e$3.x, e$3.y)));
					} else S$1 = !0;
					return {
						box: t.aL(E$1),
						allPointsOccluded: !S$1
					};
				}
			}
			class lt {
				constructor(e$1, t$1, i$1, a$1) {
					this.opacity = e$1 ? Math.max(0, Math.min(1, e$1.opacity + (e$1.placed ? t$1 : -t$1))) : a$1 && i$1 ? 1 : 0, this.placed = i$1;
				}
				isHidden() {
					return 0 === this.opacity && !this.placed;
				}
			}
			class ct {
				constructor(e$1, t$1, i$1, a$1, o$1) {
					this.text = new lt(e$1 ? e$1.text : null, t$1, i$1, o$1), this.icon = new lt(e$1 ? e$1.icon : null, t$1, a$1, o$1);
				}
				isHidden() {
					return this.text.isHidden() && this.icon.isHidden();
				}
			}
			class ht {
				constructor(e$1, t$1, i$1) {
					this.text = e$1, this.icon = t$1, this.skipFade = i$1;
				}
			}
			class ut {
				constructor(e$1, t$1, i$1, a$1, o$1) {
					this.bucketInstanceId = e$1, this.featureIndex = t$1, this.sourceLayerIndex = i$1, this.bucketIndex = a$1, this.tileID = o$1;
				}
			}
			class dt {
				constructor(e$1) {
					this.crossSourceCollisions = e$1, this.maxGroupID = 0, this.collisionGroups = {};
				}
				get(e$1) {
					if (this.crossSourceCollisions) return {
						ID: 0,
						predicate: null
					};
					if (!this.collisionGroups[e$1]) {
						const t$1 = ++this.maxGroupID;
						this.collisionGroups[e$1] = {
							ID: t$1,
							predicate: (e$2) => e$2.collisionGroupID === t$1
						};
					}
					return this.collisionGroups[e$1];
				}
			}
			function _t(e$1, i$1, a$1, o$1, r$1) {
				const { horizontalAlign: s$1, verticalAlign: n$1 } = t.aS(e$1);
				return new t.P(-(s$1 - .5) * i$1 + o$1[0] * r$1, -(n$1 - .5) * a$1 + o$1[1] * r$1);
			}
			class pt {
				constructor(e$1, t$1, i$1, a$1, o$1) {
					this.transform = e$1.clone(), this.terrain = t$1, this.collisionIndex = new nt(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = i$1, this.retainedQueryData = {}, this.collisionGroups = new dt(a$1), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = o$1, o$1 && (o$1.prevPlacement = void 0), this.placedOrientations = {};
				}
				_getTerrainElevationFunc(e$1) {
					const t$1 = this.terrain;
					return t$1 ? (i$1, a$1) => t$1.getElevation(e$1, i$1, a$1) : null;
				}
				getBucketParts(e$1, i$1, a$1, o$1) {
					const r$1 = a$1.getBucket(i$1), s$1 = a$1.latestFeatureIndex;
					if (!r$1 || !s$1 || i$1.id !== r$1.layerIds[0]) return;
					const n$1 = a$1.collisionBoxArray, l$1 = r$1.layers[0].layout, c$1 = r$1.layers[0].paint, h$1 = Math.pow(2, this.transform.zoom - a$1.tileID.overscaledZ), u$1 = a$1.tileSize / t.a5, d$1 = a$1.tileID.toUnwrapped(), _$1 = "map" === l$1.get("text-rotation-alignment"), p$1 = t.aN(a$1, 1, this.transform.zoom), m$1 = t.aO(this.collisionIndex.transform, a$1, c$1.get("text-translate"), c$1.get("text-translate-anchor")), f$1 = t.aO(this.collisionIndex.transform, a$1, c$1.get("icon-translate"), c$1.get("icon-translate-anchor")), g$1 = je(_$1, this.transform, p$1);
					this.retainedQueryData[r$1.bucketInstanceId] = new ut(r$1.bucketInstanceId, s$1, r$1.sourceLayerIndex, r$1.index, a$1.tileID);
					const v$1 = {
						bucket: r$1,
						layout: l$1,
						translationText: m$1,
						translationIcon: f$1,
						unwrappedTileID: d$1,
						pitchedLabelPlaneMatrix: g$1,
						scale: h$1,
						textPixelRatio: u$1,
						holdingForFade: a$1.holdingForSymbolFade(),
						collisionBoxArray: n$1,
						partiallyEvaluatedTextSize: t.ay(r$1.textSizeData, this.transform.zoom),
						collisionGroup: this.collisionGroups.get(r$1.sourceID)
					};
					if (o$1) for (const t$1 of r$1.sortKeyRanges) {
						const { sortKey: i$2, symbolInstanceStart: a$2, symbolInstanceEnd: o$2 } = t$1;
						e$1.push({
							sortKey: i$2,
							symbolInstanceStart: a$2,
							symbolInstanceEnd: o$2,
							parameters: v$1
						});
					}
					else e$1.push({
						symbolInstanceStart: 0,
						symbolInstanceEnd: r$1.symbolInstances.length,
						parameters: v$1
					});
				}
				attemptAnchorPlacement(e$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$1, p$1, m$1, f$1, g$1, v$1, x$1, b$1) {
					const y$1 = t.aP[e$1.textAnchor], w$1 = [e$1.textOffset0, e$1.textOffset1], T$1 = _t(y$1, a$1, o$1, w$1, r$1), P$1 = this.collisionIndex.placeCollisionBox(i$1, d$1, l$1, c$1, h$1, n$1, s$1, f$1, u$1.predicate, x$1, T$1, b$1);
					if ((!v$1 || this.collisionIndex.placeCollisionBox(v$1, d$1, l$1, c$1, h$1, n$1, s$1, g$1, u$1.predicate, x$1, T$1, b$1).placeable) && P$1.placeable) {
						let e$2;
						if (this.prevPlacement && this.prevPlacement.variableOffsets[_$1.crossTileID] && this.prevPlacement.placements[_$1.crossTileID] && this.prevPlacement.placements[_$1.crossTileID].text && (e$2 = this.prevPlacement.variableOffsets[_$1.crossTileID].anchor), 0 === _$1.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
						return this.variableOffsets[_$1.crossTileID] = {
							textOffset: w$1,
							width: a$1,
							height: o$1,
							anchor: y$1,
							textBoxScale: r$1,
							prevAnchor: e$2
						}, this.markUsedJustification(p$1, y$1, _$1, m$1), p$1.allowVerticalPlacement && (this.markUsedOrientation(p$1, m$1, _$1), this.placedOrientations[_$1.crossTileID] = m$1), {
							shift: T$1,
							placedGlyphBoxes: P$1
						};
					}
				}
				placeLayerBucketPart(e$1, i$1, a$1) {
					const { bucket: o$1, layout: r$1, translationText: s$1, translationIcon: n$1, unwrappedTileID: l$1, pitchedLabelPlaneMatrix: c$1, textPixelRatio: h$1, holdingForFade: u$1, collisionBoxArray: d$1, partiallyEvaluatedTextSize: _$1, collisionGroup: p$1 } = e$1.parameters, m$1 = r$1.get("text-optional"), f$1 = r$1.get("icon-optional"), g$1 = t.aQ(r$1, "text-overlap", "text-allow-overlap"), v$1 = "always" === g$1, x$1 = t.aQ(r$1, "icon-overlap", "icon-allow-overlap"), b$1 = "always" === x$1, y$1 = "map" === r$1.get("text-rotation-alignment"), w$1 = "map" === r$1.get("text-pitch-alignment"), T$1 = "none" !== r$1.get("icon-text-fit"), P$1 = "viewport-y" === r$1.get("symbol-z-order"), C$1 = v$1 && (b$1 || !o$1.hasIconData() || f$1), I$1 = b$1 && (v$1 || !o$1.hasTextData() || m$1);
					!o$1.collisionArrays && d$1 && o$1.deserializeCollisionBoxes(d$1);
					const M$1 = this.retainedQueryData[o$1.bucketInstanceId].tileID, E$1 = this._getTerrainElevationFunc(M$1), S$1 = this.transform.getFastPathSimpleProjectionMatrix(M$1), z$1 = (e$2, d$2, b$2) => {
						var P$2, z$2;
						if (i$1[e$2.crossTileID]) return;
						if (u$1) return void (this.placements[e$2.crossTileID] = new ht(!1, !1, !1));
						let R$1 = !1, D$1 = !1, A$1 = !0, L$1 = null, k$1 = {
							box: null,
							placeable: !1,
							offscreen: null,
							occluded: !1
						}, F$1 = { placeable: !1 }, B$1 = null, O$1 = null, j$1 = null, N$1 = 0, Z$1 = 0, U$1 = 0;
						d$2.textFeatureIndex ? N$1 = d$2.textFeatureIndex : e$2.useRuntimeCollisionCircles && (N$1 = e$2.featureIndex), d$2.verticalTextFeatureIndex && (Z$1 = d$2.verticalTextFeatureIndex);
						const G$1 = d$2.textBox;
						if (G$1) {
							const i$2 = (i$3) => {
								let a$2 = t.az.horizontal;
								if (o$1.allowVerticalPlacement && !i$3 && this.prevPlacement) {
									const t$1 = this.prevPlacement.placedOrientations[e$2.crossTileID];
									t$1 && (this.placedOrientations[e$2.crossTileID] = t$1, a$2 = t$1, this.markUsedOrientation(o$1, a$2, e$2));
								}
								return a$2;
							}, r$2 = (i$3, a$2) => {
								if (o$1.allowVerticalPlacement && e$2.numVerticalGlyphVertices > 0 && d$2.verticalTextBox) {
									for (const e$3 of o$1.writingModes) if (e$3 === t.az.vertical ? (k$1 = a$2(), F$1 = k$1) : k$1 = i$3(), k$1 && k$1.placeable) break;
								} else k$1 = i$3();
							}, c$2 = e$2.textAnchorOffsetStartIndex, u$2 = e$2.textAnchorOffsetEndIndex;
							if (u$2 === c$2) {
								const a$2 = (t$1, i$3) => {
									const a$3 = this.collisionIndex.placeCollisionBox(t$1, g$1, h$1, M$1, l$1, w$1, y$1, s$1, p$1.predicate, E$1, void 0, S$1);
									return a$3 && a$3.placeable && (this.markUsedOrientation(o$1, i$3, e$2), this.placedOrientations[e$2.crossTileID] = i$3), a$3;
								};
								r$2((() => a$2(G$1, t.az.horizontal)), (() => {
									const i$3 = d$2.verticalTextBox;
									return o$1.allowVerticalPlacement && e$2.numVerticalGlyphVertices > 0 && i$3 ? a$2(i$3, t.az.vertical) : {
										box: null,
										offscreen: null
									};
								})), i$2(k$1 && k$1.placeable);
							} else {
								let _$2 = t.aP[null === (z$2 = null === (P$2 = this.prevPlacement) || void 0 === P$2 ? void 0 : P$2.variableOffsets[e$2.crossTileID]) || void 0 === z$2 ? void 0 : z$2.anchor];
								const m$2 = (t$1, i$3, r$3) => {
									const d$3 = t$1.x2 - t$1.x1, m$3 = t$1.y2 - t$1.y1, f$3 = e$2.textBoxScale, v$2 = T$1 && "never" === x$1 ? i$3 : null;
									let b$3 = null, P$3 = "never" === g$1 ? 1 : 2, C$2 = "never";
									_$2 && P$3++;
									for (let i$4 = 0; i$4 < P$3; i$4++) {
										for (let i$5 = c$2; i$5 < u$2; i$5++) {
											const a$2 = o$1.textAnchorOffsets.get(i$5);
											if (_$2 && a$2.textAnchor !== _$2) continue;
											const c$3 = this.attemptAnchorPlacement(a$2, t$1, d$3, m$3, f$3, y$1, w$1, h$1, M$1, l$1, p$1, C$2, e$2, o$1, r$3, s$1, n$1, v$2, E$1);
											if (c$3 && (b$3 = c$3.placedGlyphBoxes, b$3 && b$3.placeable)) return R$1 = !0, L$1 = c$3.shift, b$3;
										}
										_$2 ? _$2 = null : C$2 = g$1;
									}
									return a$1 && !b$3 && (b$3 = {
										box: this.collisionIndex.placeCollisionBox(G$1, "always", h$1, M$1, l$1, w$1, y$1, s$1, p$1.predicate, E$1, void 0, S$1).box,
										offscreen: !1,
										placeable: !1,
										occluded: !1
									}), b$3;
								};
								r$2((() => m$2(G$1, d$2.iconBox, t.az.horizontal)), (() => {
									const i$3 = d$2.verticalTextBox;
									return o$1.allowVerticalPlacement && (!k$1 || !k$1.placeable) && e$2.numVerticalGlyphVertices > 0 && i$3 ? m$2(i$3, d$2.verticalIconBox, t.az.vertical) : {
										box: null,
										occluded: !0,
										offscreen: null
									};
								})), k$1 && (R$1 = k$1.placeable, A$1 = k$1.offscreen);
								const f$2 = i$2(k$1 && k$1.placeable);
								if (!R$1 && this.prevPlacement) {
									const t$1 = this.prevPlacement.variableOffsets[e$2.crossTileID];
									t$1 && (this.variableOffsets[e$2.crossTileID] = t$1, this.markUsedJustification(o$1, t$1.anchor, e$2, f$2));
								}
							}
						}
						if (B$1 = k$1, R$1 = B$1 && B$1.placeable, A$1 = B$1 && B$1.offscreen, e$2.useRuntimeCollisionCircles && e$2.centerJustifiedTextSymbolIndex >= 0) {
							const i$2 = o$1.text.placedSymbolArray.get(e$2.centerJustifiedTextSymbolIndex), n$2 = t.aA(o$1.textSizeData, _$1, i$2), h$2 = r$1.get("text-padding");
							O$1 = this.collisionIndex.placeCollisionCircles(g$1, i$2, o$1.lineVertexArray, o$1.glyphOffsetArray, n$2, l$1, c$1, a$1, w$1, p$1.predicate, e$2.collisionCircleDiameter, h$2, s$1, E$1), O$1.circles.length && O$1.collisionDetected && !a$1 && t.w("Collisions detected, but collision boxes are not shown"), R$1 = v$1 || O$1.circles.length > 0 && !O$1.collisionDetected, A$1 = A$1 && O$1.offscreen;
						}
						if (d$2.iconFeatureIndex && (U$1 = d$2.iconFeatureIndex), d$2.iconBox) {
							const e$3 = (e$4) => this.collisionIndex.placeCollisionBox(e$4, x$1, h$1, M$1, l$1, w$1, y$1, n$1, p$1.predicate, E$1, T$1 && L$1 ? L$1 : void 0, S$1);
							F$1 && F$1.placeable && d$2.verticalIconBox ? (j$1 = e$3(d$2.verticalIconBox), D$1 = j$1.placeable) : (j$1 = e$3(d$2.iconBox), D$1 = j$1.placeable), A$1 = A$1 && j$1.offscreen;
						}
						const V$1 = m$1 || 0 === e$2.numHorizontalGlyphVertices && 0 === e$2.numVerticalGlyphVertices, q$1 = f$1 || 0 === e$2.numIconVertices;
						V$1 || q$1 ? q$1 ? V$1 || (D$1 = D$1 && R$1) : R$1 = D$1 && R$1 : D$1 = R$1 = D$1 && R$1;
						const W$1 = D$1 && j$1.placeable;
						if (R$1 && B$1.placeable && this.collisionIndex.insertCollisionBox(B$1.box, g$1, r$1.get("text-ignore-placement"), o$1.bucketInstanceId, F$1 && F$1.placeable && Z$1 ? Z$1 : N$1, p$1.ID), W$1 && this.collisionIndex.insertCollisionBox(j$1.box, x$1, r$1.get("icon-ignore-placement"), o$1.bucketInstanceId, U$1, p$1.ID), O$1 && R$1 && this.collisionIndex.insertCollisionCircles(O$1.circles, g$1, r$1.get("text-ignore-placement"), o$1.bucketInstanceId, N$1, p$1.ID), a$1 && this.storeCollisionData(o$1.bucketInstanceId, b$2, d$2, B$1, j$1, O$1), 0 === e$2.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
						if (0 === o$1.bucketInstanceId) throw new Error("bucket.bucketInstanceId can't be 0");
						this.placements[e$2.crossTileID] = new ht((R$1 || C$1) && !(null == B$1 ? void 0 : B$1.occluded), (D$1 || I$1) && !(null == j$1 ? void 0 : j$1.occluded), A$1 || o$1.justReloaded), i$1[e$2.crossTileID] = !0;
					};
					if (P$1) {
						if (0 !== e$1.symbolInstanceStart) throw new Error("bucket.bucketInstanceId should be 0");
						const t$1 = o$1.getSortedSymbolIndexes(-this.transform.bearingInRadians);
						for (let e$2 = t$1.length - 1; e$2 >= 0; --e$2) {
							const i$2 = t$1[e$2];
							z$1(o$1.symbolInstances.get(i$2), o$1.collisionArrays[i$2], i$2);
						}
					} else for (let t$1 = e$1.symbolInstanceStart; t$1 < e$1.symbolInstanceEnd; t$1++) z$1(o$1.symbolInstances.get(t$1), o$1.collisionArrays[t$1], t$1);
					o$1.justReloaded = !1;
				}
				storeCollisionData(e$1, t$1, i$1, a$1, o$1, r$1) {
					if (i$1.textBox || i$1.iconBox) {
						let r$2, s$1;
						this.collisionBoxArrays.has(e$1) ? r$2 = this.collisionBoxArrays.get(e$1) : (r$2 = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(e$1, r$2)), r$2.has(t$1) ? s$1 = r$2.get(t$1) : (s$1 = {
							text: null,
							icon: null
						}, r$2.set(t$1, s$1)), i$1.textBox && (s$1.text = a$1.box), i$1.iconBox && (s$1.icon = o$1.box);
					}
					if (r$1) {
						let t$2 = this.collisionCircleArrays[e$1];
						void 0 === t$2 && (t$2 = this.collisionCircleArrays[e$1] = []);
						for (let e$2 = 0; e$2 < r$1.circles.length; e$2 += 4) t$2.push(r$1.circles[e$2 + 0] - st), t$2.push(r$1.circles[e$2 + 1] - st), t$2.push(r$1.circles[e$2 + 2]), t$2.push(r$1.collisionDetected ? 1 : 0);
					}
				}
				markUsedJustification(e$1, i$1, a$1, o$1) {
					let r$1;
					r$1 = o$1 === t.az.vertical ? a$1.verticalPlacedTextSymbolIndex : {
						left: a$1.leftJustifiedTextSymbolIndex,
						center: a$1.centerJustifiedTextSymbolIndex,
						right: a$1.rightJustifiedTextSymbolIndex
					}[t.aR(i$1)];
					const s$1 = [
						a$1.leftJustifiedTextSymbolIndex,
						a$1.centerJustifiedTextSymbolIndex,
						a$1.rightJustifiedTextSymbolIndex,
						a$1.verticalPlacedTextSymbolIndex
					];
					for (const t$1 of s$1) t$1 >= 0 && (e$1.text.placedSymbolArray.get(t$1).crossTileID = r$1 >= 0 && t$1 !== r$1 ? 0 : a$1.crossTileID);
				}
				markUsedOrientation(e$1, i$1, a$1) {
					const o$1 = i$1 === t.az.horizontal || i$1 === t.az.horizontalOnly ? i$1 : 0, r$1 = i$1 === t.az.vertical ? i$1 : 0, s$1 = [
						a$1.leftJustifiedTextSymbolIndex,
						a$1.centerJustifiedTextSymbolIndex,
						a$1.rightJustifiedTextSymbolIndex
					];
					for (const t$1 of s$1) e$1.text.placedSymbolArray.get(t$1).placedOrientation = o$1;
					a$1.verticalPlacedTextSymbolIndex && (e$1.text.placedSymbolArray.get(a$1.verticalPlacedTextSymbolIndex).placedOrientation = r$1);
				}
				commit(e$1) {
					this.commitTime = e$1, this.zoomAtLastRecencyCheck = this.transform.zoom;
					const t$1 = this.prevPlacement;
					let i$1 = !1;
					this.prevZoomAdjustment = t$1 ? t$1.zoomAdjustment(this.transform.zoom) : 0;
					const a$1 = t$1 ? t$1.symbolFadeChange(e$1) : 1, o$1 = t$1 ? t$1.opacities : {}, r$1 = t$1 ? t$1.variableOffsets : {}, s$1 = t$1 ? t$1.placedOrientations : {};
					for (const e$2 in this.placements) {
						const t$2 = this.placements[e$2], r$2 = o$1[e$2];
						r$2 ? (this.opacities[e$2] = new ct(r$2, a$1, t$2.text, t$2.icon), i$1 = i$1 || t$2.text !== r$2.text.placed || t$2.icon !== r$2.icon.placed) : (this.opacities[e$2] = new ct(null, a$1, t$2.text, t$2.icon, t$2.skipFade), i$1 = i$1 || t$2.text || t$2.icon);
					}
					for (const e$2 in o$1) {
						const t$2 = o$1[e$2];
						if (!this.opacities[e$2]) {
							const o$2 = new ct(t$2, a$1, !1, !1);
							o$2.isHidden() || (this.opacities[e$2] = o$2, i$1 = i$1 || t$2.text.placed || t$2.icon.placed);
						}
					}
					for (const e$2 in r$1) this.variableOffsets[e$2] || !this.opacities[e$2] || this.opacities[e$2].isHidden() || (this.variableOffsets[e$2] = r$1[e$2]);
					for (const e$2 in s$1) this.placedOrientations[e$2] || !this.opacities[e$2] || this.opacities[e$2].isHidden() || (this.placedOrientations[e$2] = s$1[e$2]);
					if (t$1 && void 0 === t$1.lastPlacementChangeTime) throw new Error("Last placement time for previous placement is not defined");
					i$1 ? this.lastPlacementChangeTime = e$1 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t$1 ? t$1.lastPlacementChangeTime : e$1);
				}
				updateLayerOpacities(e$1, t$1) {
					const i$1 = {};
					for (const a$1 of t$1) {
						const t$2 = a$1.getBucket(e$1);
						t$2 && a$1.latestFeatureIndex && e$1.id === t$2.layerIds[0] && this.updateBucketOpacities(t$2, a$1.tileID, i$1, a$1.collisionBoxArray);
					}
				}
				updateBucketOpacities(e$1, i$1, a$1, o$1) {
					e$1.hasTextData() && (e$1.text.opacityVertexArray.clear(), e$1.text.hasVisibleVertices = !1), e$1.hasIconData() && (e$1.icon.opacityVertexArray.clear(), e$1.icon.hasVisibleVertices = !1), e$1.hasIconCollisionBoxData() && e$1.iconCollisionBox.collisionVertexArray.clear(), e$1.hasTextCollisionBoxData() && e$1.textCollisionBox.collisionVertexArray.clear();
					const r$1 = e$1.layers[0], s$1 = r$1.layout, n$1 = new ct(null, 0, !1, !1, !0), l$1 = s$1.get("text-allow-overlap"), c$1 = s$1.get("icon-allow-overlap"), h$1 = r$1._unevaluatedLayout.hasValue("text-variable-anchor") || r$1._unevaluatedLayout.hasValue("text-variable-anchor-offset"), u$1 = "map" === s$1.get("text-rotation-alignment"), d$1 = "map" === s$1.get("text-pitch-alignment"), _$1 = "none" !== s$1.get("icon-text-fit"), p$1 = new ct(null, 0, l$1 && (c$1 || !e$1.hasIconData() || s$1.get("icon-optional")), c$1 && (l$1 || !e$1.hasTextData() || s$1.get("text-optional")), !0);
					!e$1.collisionArrays && o$1 && (e$1.hasIconCollisionBoxData() || e$1.hasTextCollisionBoxData()) && e$1.deserializeCollisionBoxes(o$1);
					const m$1 = (e$2, t$1, i$2) => {
						for (let a$2 = 0; a$2 < t$1 / 4; a$2++) e$2.opacityVertexArray.emplaceBack(i$2);
						e$2.hasVisibleVertices = e$2.hasVisibleVertices || i$2 !== Pt;
					}, f$1 = this.collisionBoxArrays.get(e$1.bucketInstanceId);
					for (let i$2 = 0; i$2 < e$1.symbolInstances.length; i$2++) {
						const o$2 = e$1.symbolInstances.get(i$2), { numHorizontalGlyphVertices: r$2, numVerticalGlyphVertices: s$2, crossTileID: l$2 } = o$2;
						let c$2 = this.opacities[l$2];
						a$1[l$2] ? c$2 = n$1 : c$2 || (c$2 = p$1, this.opacities[l$2] = c$2), a$1[l$2] = !0;
						const g$1 = o$2.numIconVertices > 0, v$1 = this.placedOrientations[o$2.crossTileID], x$1 = v$1 === t.az.vertical, b$1 = v$1 === t.az.horizontal || v$1 === t.az.horizontalOnly;
						if (r$2 > 0 || s$2 > 0) {
							const t$1 = Tt(c$2.text);
							m$1(e$1.text, r$2, x$1 ? Pt : t$1), m$1(e$1.text, s$2, b$1 ? Pt : t$1);
							const i$3 = c$2.text.isHidden();
							[
								o$2.rightJustifiedTextSymbolIndex,
								o$2.centerJustifiedTextSymbolIndex,
								o$2.leftJustifiedTextSymbolIndex
							].forEach(((t$2) => {
								t$2 >= 0 && (e$1.text.placedSymbolArray.get(t$2).hidden = i$3 || x$1 ? 1 : 0);
							})), o$2.verticalPlacedTextSymbolIndex >= 0 && (e$1.text.placedSymbolArray.get(o$2.verticalPlacedTextSymbolIndex).hidden = i$3 || b$1 ? 1 : 0);
							const a$2 = this.variableOffsets[o$2.crossTileID];
							a$2 && this.markUsedJustification(e$1, a$2.anchor, o$2, v$1);
							const n$2 = this.placedOrientations[o$2.crossTileID];
							n$2 && (this.markUsedJustification(e$1, "left", o$2, n$2), this.markUsedOrientation(e$1, n$2, o$2));
						}
						if (g$1) {
							const t$1 = Tt(c$2.icon), i$3 = !(_$1 && o$2.verticalPlacedIconSymbolIndex && x$1);
							o$2.placedIconSymbolIndex >= 0 && (m$1(e$1.icon, o$2.numIconVertices, i$3 ? t$1 : Pt), e$1.icon.placedSymbolArray.get(o$2.placedIconSymbolIndex).hidden = c$2.icon.isHidden()), o$2.verticalPlacedIconSymbolIndex >= 0 && (m$1(e$1.icon, o$2.numVerticalIconVertices, i$3 ? Pt : t$1), e$1.icon.placedSymbolArray.get(o$2.verticalPlacedIconSymbolIndex).hidden = c$2.icon.isHidden());
						}
						const y$1 = f$1 && f$1.has(i$2) ? f$1.get(i$2) : {
							text: null,
							icon: null
						};
						if (e$1.hasIconCollisionBoxData() || e$1.hasTextCollisionBoxData()) {
							const a$2 = e$1.collisionArrays[i$2];
							if (a$2) {
								let i$3 = new t.P(0, 0);
								if (a$2.textBox || a$2.verticalTextBox) {
									let t$1 = !0;
									if (h$1) {
										const e$2 = this.variableOffsets[l$2];
										e$2 ? (i$3 = _t(e$2.anchor, e$2.width, e$2.height, e$2.textOffset, e$2.textBoxScale), u$1 && i$3._rotate(d$1 ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : t$1 = !1;
									}
									if (a$2.textBox || a$2.verticalTextBox) {
										let o$3;
										a$2.textBox && (o$3 = x$1), a$2.verticalTextBox && (o$3 = b$1), mt(e$1.textCollisionBox.collisionVertexArray, c$2.text.placed, !t$1 || o$3, y$1.text, i$3.x, i$3.y);
									}
								}
								if (a$2.iconBox || a$2.verticalIconBox) {
									const t$1 = Boolean(!b$1 && a$2.verticalIconBox);
									let o$3;
									a$2.iconBox && (o$3 = t$1), a$2.verticalIconBox && (o$3 = !t$1), mt(e$1.iconCollisionBox.collisionVertexArray, c$2.icon.placed, o$3, y$1.icon, _$1 ? i$3.x : 0, _$1 ? i$3.y : 0);
								}
							}
						}
					}
					if (e$1.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e$1.bucketInstanceId] && (this.retainedQueryData[e$1.bucketInstanceId].featureSortOrder = e$1.featureSortOrder), e$1.hasTextData() && e$1.text.opacityVertexBuffer && e$1.text.opacityVertexBuffer.updateData(e$1.text.opacityVertexArray), e$1.hasIconData() && e$1.icon.opacityVertexBuffer && e$1.icon.opacityVertexBuffer.updateData(e$1.icon.opacityVertexArray), e$1.hasIconCollisionBoxData() && e$1.iconCollisionBox.collisionVertexBuffer && e$1.iconCollisionBox.collisionVertexBuffer.updateData(e$1.iconCollisionBox.collisionVertexArray), e$1.hasTextCollisionBoxData() && e$1.textCollisionBox.collisionVertexBuffer && e$1.textCollisionBox.collisionVertexBuffer.updateData(e$1.textCollisionBox.collisionVertexArray), e$1.text.opacityVertexArray.length !== e$1.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e$1.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e$1.text.layoutVertexArray.length}) / 4`);
					if (e$1.icon.opacityVertexArray.length !== e$1.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e$1.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e$1.icon.layoutVertexArray.length}) / 4`);
					e$1.bucketInstanceId in this.collisionCircleArrays && (e$1.collisionCircleArray = this.collisionCircleArrays[e$1.bucketInstanceId], delete this.collisionCircleArrays[e$1.bucketInstanceId]);
				}
				symbolFadeChange(e$1) {
					return 0 === this.fadeDuration ? 1 : (e$1 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
				}
				zoomAdjustment(e$1) {
					return Math.max(0, (this.transform.zoom - e$1) / 1.5);
				}
				hasTransitions(e$1) {
					return this.stale || e$1 - this.lastPlacementChangeTime < this.fadeDuration;
				}
				stillRecent(e$1, t$1) {
					const i$1 = this.zoomAtLastRecencyCheck === t$1 ? 1 - this.zoomAdjustment(t$1) : 1;
					return this.zoomAtLastRecencyCheck = t$1, this.commitTime + this.fadeDuration * i$1 > e$1;
				}
				setStale() {
					this.stale = !0;
				}
			}
			function mt(e$1, t$1, i$1, a$1, o$1, r$1) {
				a$1 && 0 !== a$1.length || (a$1 = [
					0,
					0,
					0,
					0
				]);
				const s$1 = a$1[0] - st, n$1 = a$1[1] - st, l$1 = a$1[2] - st, c$1 = a$1[3] - st;
				e$1.emplaceBack(t$1 ? 1 : 0, i$1 ? 1 : 0, o$1 || 0, r$1 || 0, s$1, n$1), e$1.emplaceBack(t$1 ? 1 : 0, i$1 ? 1 : 0, o$1 || 0, r$1 || 0, l$1, n$1), e$1.emplaceBack(t$1 ? 1 : 0, i$1 ? 1 : 0, o$1 || 0, r$1 || 0, l$1, c$1), e$1.emplaceBack(t$1 ? 1 : 0, i$1 ? 1 : 0, o$1 || 0, r$1 || 0, s$1, c$1);
			}
			const ft = Math.pow(2, 25), gt = Math.pow(2, 24), vt = Math.pow(2, 17), xt = Math.pow(2, 16), bt = Math.pow(2, 9), yt = Math.pow(2, 8), wt = Math.pow(2, 1);
			function Tt(e$1) {
				if (0 === e$1.opacity && !e$1.placed) return 0;
				if (1 === e$1.opacity && e$1.placed) return 4294967295;
				const t$1 = e$1.placed ? 1 : 0, i$1 = Math.floor(127 * e$1.opacity);
				return i$1 * ft + t$1 * gt + i$1 * vt + t$1 * xt + i$1 * bt + t$1 * yt + i$1 * wt + t$1;
			}
			const Pt = 0;
			class Ct {
				constructor(e$1) {
					this._sortAcrossTiles = "viewport-y" !== e$1.layout.get("symbol-z-order") && !e$1.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
				}
				continuePlacement(e$1, t$1, i$1, a$1, o$1) {
					const r$1 = this._bucketParts;
					for (; this._currentTileIndex < e$1.length;) if (t$1.getBucketParts(r$1, a$1, e$1[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, o$1()) return !0;
					for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, r$1.sort(((e$2, t$2) => e$2.sortKey - t$2.sortKey))); this._currentPartIndex < r$1.length;) if (t$1.placeLayerBucketPart(r$1[this._currentPartIndex], this._seenCrossTileIDs, i$1), this._currentPartIndex++, o$1()) return !0;
					return !1;
				}
			}
			class It {
				constructor(e$1, t$1, i$1, a$1, o$1, r$1, s$1, n$1) {
					this.placement = new pt(e$1, t$1, r$1, s$1, n$1), this._currentPlacementIndex = i$1.length - 1, this._forceFullPlacement = a$1, this._showCollisionBoxes = o$1, this._done = !1;
				}
				isDone() {
					return this._done;
				}
				continuePlacement(e$1, t$1, i$1) {
					const a$1 = c(), o$1 = () => !this._forceFullPlacement && c() - a$1 > 2;
					for (; this._currentPlacementIndex >= 0;) {
						const a$2 = t$1[e$1[this._currentPlacementIndex]], r$1 = this.placement.collisionIndex.transform.zoom;
						if ("symbol" === a$2.type && (!a$2.minzoom || a$2.minzoom <= r$1) && (!a$2.maxzoom || a$2.maxzoom > r$1)) {
							if (this._inProgressLayer || (this._inProgressLayer = new Ct(a$2)), this._inProgressLayer.continuePlacement(i$1[a$2.source], this.placement, this._showCollisionBoxes, a$2, o$1)) return;
							delete this._inProgressLayer;
						}
						this._currentPlacementIndex--;
					}
					this._done = !0;
				}
				commit(e$1) {
					return this.placement.commit(e$1), this.placement;
				}
			}
			const Mt = 512 / t.a5 / 2;
			class Et {
				constructor(e$1, i$1, a$1) {
					this.tileID = e$1, this.bucketInstanceId = a$1, this._symbolsByKey = {};
					const o$1 = /* @__PURE__ */ new Map();
					for (let e$2 = 0; e$2 < i$1.length; e$2++) {
						const t$1 = i$1.get(e$2), a$2 = t$1.key, r$1 = o$1.get(a$2);
						r$1 ? r$1.push(t$1) : o$1.set(a$2, [t$1]);
					}
					for (const [e$2, i$2] of o$1) {
						const a$2 = {
							positions: i$2.map(((e$3) => ({
								x: Math.floor(e$3.anchorX * Mt),
								y: Math.floor(e$3.anchorY * Mt)
							}))),
							crossTileIDs: i$2.map(((e$3) => e$3.crossTileID))
						};
						if (a$2.positions.length > 128) {
							const e$3 = new t.aT(a$2.positions.length, 16, Uint16Array);
							for (const { x: t$1, y: i$3 } of a$2.positions) e$3.add(t$1, i$3);
							e$3.finish(), delete a$2.positions, a$2.index = e$3;
						}
						this._symbolsByKey[e$2] = a$2;
					}
				}
				getScaledCoordinates(e$1, i$1) {
					const { x: a$1, y: o$1, z: r$1 } = this.tileID.canonical, { x: s$1, y: n$1, z: l$1 } = i$1.canonical, c$1 = Mt / Math.pow(2, l$1 - r$1), h$1 = (n$1 * t.a5 + e$1.anchorY) * c$1, u$1 = o$1 * t.a5 * Mt;
					return {
						x: Math.floor((s$1 * t.a5 + e$1.anchorX) * c$1 - a$1 * t.a5 * Mt),
						y: Math.floor(h$1 - u$1)
					};
				}
				findMatches(e$1, t$1, i$1) {
					const a$1 = this.tileID.canonical.z < t$1.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t$1.canonical.z);
					for (let o$1 = 0; o$1 < e$1.length; o$1++) {
						const r$1 = e$1.get(o$1);
						if (r$1.crossTileID) continue;
						const s$1 = this._symbolsByKey[r$1.key];
						if (!s$1) continue;
						const n$1 = this.getScaledCoordinates(r$1, t$1);
						if (s$1.index) {
							const e$2 = s$1.index.range(n$1.x - a$1, n$1.y - a$1, n$1.x + a$1, n$1.y + a$1).sort();
							for (const t$2 of e$2) {
								const e$3 = s$1.crossTileIDs[t$2];
								if (!i$1[e$3]) {
									i$1[e$3] = !0, r$1.crossTileID = e$3;
									break;
								}
							}
						} else if (s$1.positions) for (let e$2 = 0; e$2 < s$1.positions.length; e$2++) {
							const t$2 = s$1.positions[e$2], o$2 = s$1.crossTileIDs[e$2];
							if (Math.abs(t$2.x - n$1.x) <= a$1 && Math.abs(t$2.y - n$1.y) <= a$1 && !i$1[o$2]) {
								i$1[o$2] = !0, r$1.crossTileID = o$2;
								break;
							}
						}
					}
				}
				getCrossTileIDsLists() {
					return Object.values(this._symbolsByKey).map((({ crossTileIDs: e$1 }) => e$1));
				}
			}
			class St {
				constructor() {
					this.maxCrossTileID = 0;
				}
				generate() {
					return ++this.maxCrossTileID;
				}
			}
			class zt {
				constructor() {
					this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
				}
				handleWrapJump(e$1) {
					const t$1 = Math.round((e$1 - this.lng) / 360);
					if (0 !== t$1) for (const e$2 in this.indexes) {
						const i$1 = this.indexes[e$2], a$1 = {};
						for (const e$3 in i$1) {
							const o$1 = i$1[e$3];
							o$1.tileID = o$1.tileID.unwrapTo(o$1.tileID.wrap + t$1), a$1[o$1.tileID.key] = o$1;
						}
						this.indexes[e$2] = a$1;
					}
					this.lng = e$1;
				}
				addBucket(e$1, t$1, i$1) {
					if (this.indexes[e$1.overscaledZ] && this.indexes[e$1.overscaledZ][e$1.key]) {
						if (this.indexes[e$1.overscaledZ][e$1.key].bucketInstanceId === t$1.bucketInstanceId) return !1;
						this.removeBucketCrossTileIDs(e$1.overscaledZ, this.indexes[e$1.overscaledZ][e$1.key]);
					}
					for (let e$2 = 0; e$2 < t$1.symbolInstances.length; e$2++) t$1.symbolInstances.get(e$2).crossTileID = 0;
					this.usedCrossTileIDs[e$1.overscaledZ] || (this.usedCrossTileIDs[e$1.overscaledZ] = {});
					const a$1 = this.usedCrossTileIDs[e$1.overscaledZ];
					for (const i$2 in this.indexes) {
						const o$1 = this.indexes[i$2];
						if (Number(i$2) > e$1.overscaledZ) for (const i$3 in o$1) {
							const r$1 = o$1[i$3];
							r$1.tileID.isChildOf(e$1) && r$1.findMatches(t$1.symbolInstances, e$1, a$1);
						}
						else {
							const r$1 = o$1[e$1.scaledTo(Number(i$2)).key];
							r$1 && r$1.findMatches(t$1.symbolInstances, e$1, a$1);
						}
					}
					for (let e$2 = 0; e$2 < t$1.symbolInstances.length; e$2++) {
						const o$1 = t$1.symbolInstances.get(e$2);
						o$1.crossTileID || (o$1.crossTileID = i$1.generate(), a$1[o$1.crossTileID] = !0);
					}
					return void 0 === this.indexes[e$1.overscaledZ] && (this.indexes[e$1.overscaledZ] = {}), this.indexes[e$1.overscaledZ][e$1.key] = new Et(e$1, t$1.symbolInstances, t$1.bucketInstanceId), !0;
				}
				removeBucketCrossTileIDs(e$1, t$1) {
					for (const i$1 of t$1.getCrossTileIDsLists()) for (const t$2 of i$1) delete this.usedCrossTileIDs[e$1][t$2];
				}
				removeStaleBuckets(e$1) {
					let t$1 = !1;
					for (const i$1 in this.indexes) {
						const a$1 = this.indexes[i$1];
						for (const o$1 in a$1) e$1[a$1[o$1].bucketInstanceId] || (this.removeBucketCrossTileIDs(i$1, a$1[o$1]), delete a$1[o$1], t$1 = !0);
					}
					return t$1;
				}
			}
			class Rt {
				constructor() {
					this.layerIndexes = {}, this.crossTileIDs = new St(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
				}
				addLayer(e$1, t$1, i$1) {
					let a$1 = this.layerIndexes[e$1.id];
					void 0 === a$1 && (a$1 = this.layerIndexes[e$1.id] = new zt());
					let o$1 = !1;
					const r$1 = {};
					a$1.handleWrapJump(i$1);
					for (const i$2 of t$1) {
						const t$2 = i$2.getBucket(e$1);
						t$2 && e$1.id === t$2.layerIds[0] && (t$2.bucketInstanceId || (t$2.bucketInstanceId = ++this.maxBucketInstanceId), a$1.addBucket(i$2.tileID, t$2, this.crossTileIDs) && (o$1 = !0), r$1[t$2.bucketInstanceId] = !0);
					}
					return a$1.removeStaleBuckets(r$1) && (o$1 = !0), o$1;
				}
				pruneUnusedLayers(e$1) {
					const t$1 = {};
					e$1.forEach(((e$2) => {
						t$1[e$2] = !0;
					}));
					for (const e$2 in this.layerIndexes) t$1[e$2] || delete this.layerIndexes[e$2];
				}
			}
			var Dt = "void main() {fragColor=vec4(1.0);}";
			const At = {
				prelude: Lt("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nout highp vec4 fragColor;", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c\n);}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\n#ifdef GLOBE\nif ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}\n#endif\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;"),
				projectionMercator: Lt("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"),
				projectionGlobe: Lt("", "#define GLOBE_RADIUS 6371008.8\nuniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos\n);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); \nif (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len\n);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}"),
				background: Lt("uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
				backgroundPattern: Lt("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),
				circle: Lt("in vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {\n#ifdef GLOBE\nvec3 center_vector=projectToSphere(circle_center);\n#endif\nfloat angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {\n#ifdef GLOBE\nvec4 projected_center=interpolateProjection(circle_center,center_vector,ele);\n#else\nvec4 projected_center=projectTileWithElevation(circle_center,ele);\n#endif\ncorner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}\n#ifdef GLOBE\nvec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);\n#else\ngl_Position=projectTileWithElevation(corner_position,ele);\n#endif\n} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"),
				clippingMask: Lt(Dt, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
				heatmap: Lt("uniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);\n#ifdef GLOBE\nvec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);\n#else\ngl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));\n#endif\n}"),
				heatmapTexture: Lt("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),
				collisionBox: Lt("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
				collisionCircle: Lt("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
				colorRelief: Lt("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else\n{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
				debug: Lt("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"),
				depth: Lt(Dt, "in vec2 a_pos;void main() {\n#ifdef GLOBE\ngl_Position=projectTileFor3D(a_pos,0.0);\n#else\ngl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);\n#endif\n}"),
				fill: Lt("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nfragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_fill_translate;in vec2 a_pos;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=projectTile(a_pos+u_fill_translate,a_pos);}"),
				fillOutline: Lt("in vec2 v_pos;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n}"),
				fillOutlinePattern: Lt("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n}"),
				fillPattern: Lt("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"),
				fillExtrusion: Lt("in vec4 v_color;void main() {fragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;\n#ifdef TERRAIN3D\nin vec2 a_centroid;\n#endif\nout vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;\n#ifdef GLOBE\nvec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);\n#else\ngl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);\n#endif\nfloat colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);\n#ifdef GLOBE\nmat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);\n#endif\ndirectional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"),
				fillExtrusionPattern: Lt("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;\n#ifdef TERRAIN3D\nin vec2 a_centroid;\n#endif\n#ifdef GLOBE\nout vec3 v_sphere_pos;\n#endif\nout vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;\n#ifdef GLOBE\nvec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);\n#else\ngl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);\n#endif\nvec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"),
				hillshadePrepare: Lt("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
				hillshade: Lt("uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];\n#define PI 3.141592653589793\n#define STANDARD 0\n#define COMBINED 1\n#define IGOR 2\n#define MULTIDIRECTIONAL 3\n#define BASIC 4\nfloat get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else\n{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else\n{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
				line: Lt("uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"),
				lineGradient: Lt("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"),
				linePattern: Lt("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"),
				lineSDF: Lt("uniform lowp float u_device_pixel_ratio;uniform lowp float u_lineatlas_width;uniform sampler2D u_image;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0/u_device_pixel_ratio)/min(dasharray_from.w,dasharray_to.w);alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nfloat u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}"),
				lineGradientSDF: Lt("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform sampler2D u_image_dash;uniform float u_mix;uniform lowp float u_lineatlas_width;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;in highp vec2 v_uv;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);float sdfdist_a=texture(u_image_dash,v_tex_a).a;float sdfdist_b=texture(u_image_dash,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0)/min(dasharray_from.w,dasharray_to.w);float dash_alpha=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*dash_alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;out vec2 v_tex_a;out vec2 v_tex_b;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;float texel_height=1.0/u_image_height;float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nfloat u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}"),
				raster: Lt("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;\n#ifdef GLOBE\nif (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}\n#endif\nv_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"),
				symbolIcon: Lt("uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}"),
				symbolSDF: Lt("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"),
				symbolTextAndIcon: Lt("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"),
				terrain: Lt("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"),
				terrainDepth: Lt("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"),
				terrainCoords: Lt("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"),
				projectionErrorMeasurement: Lt("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"),
				atmosphere: Lt("#ifdef GL_ES\nprecision highp float;\n#endif\nin vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758\n);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}", "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"),
				sky: Lt("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}")
			};
			function Lt(e$1, t$1) {
				const i$1 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, a$1 = t$1.match(/in ([\w]+) ([\w]+)/g), o$1 = e$1.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), r$1 = t$1.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), s$1 = r$1 ? r$1.concat(o$1) : o$1, n$1 = {};
				return {
					fragmentSource: e$1 = e$1.replace(i$1, ((e$2, t$2, i$2, a$2, o$2) => (n$1[o$2] = !0, "define" === t$2 ? `\n#ifndef HAS_UNIFORM_u_${o$2}\nin ${i$2} ${a$2} ${o$2};\n#else\nuniform ${i$2} ${a$2} u_${o$2};\n#endif\n` : `\n#ifdef HAS_UNIFORM_u_${o$2}\n    ${i$2} ${a$2} ${o$2} = u_${o$2};\n#endif\n`))),
					vertexSource: t$1 = t$1.replace(i$1, ((e$2, t$2, i$2, a$2, o$2) => {
						const r$2 = "float" === a$2 ? "vec2" : "vec4", s$2 = o$2.match(/color/) ? "color" : r$2;
						return n$1[o$2] ? "define" === t$2 ? `\n#ifndef HAS_UNIFORM_u_${o$2}\nuniform lowp float u_${o$2}_t;\nin ${i$2} ${r$2} a_${o$2};\nout ${i$2} ${a$2} ${o$2};\n#else\nuniform ${i$2} ${a$2} u_${o$2};\n#endif\n` : "vec4" === s$2 ? `\n#ifndef HAS_UNIFORM_u_${o$2}\n    ${o$2} = a_${o$2};\n#else\n    ${i$2} ${a$2} ${o$2} = u_${o$2};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${o$2}\n    ${o$2} = unpack_mix_${s$2}(a_${o$2}, u_${o$2}_t);\n#else\n    ${i$2} ${a$2} ${o$2} = u_${o$2};\n#endif\n` : "define" === t$2 ? `\n#ifndef HAS_UNIFORM_u_${o$2}\nuniform lowp float u_${o$2}_t;\nin ${i$2} ${r$2} a_${o$2};\n#else\nuniform ${i$2} ${a$2} u_${o$2};\n#endif\n` : "vec4" === s$2 ? `\n#ifndef HAS_UNIFORM_u_${o$2}\n    ${i$2} ${a$2} ${o$2} = a_${o$2};\n#else\n    ${i$2} ${a$2} ${o$2} = u_${o$2};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${o$2}\n    ${i$2} ${a$2} ${o$2} = unpack_mix_${s$2}(a_${o$2}, u_${o$2}_t);\n#else\n    ${i$2} ${a$2} ${o$2} = u_${o$2};\n#endif\n`;
					})),
					staticAttributes: a$1,
					staticUniforms: s$1
				};
			}
			class kt {
				constructor(e$1, t$1, i$1) {
					this.vertexBuffer = e$1, this.indexBuffer = t$1, this.segments = i$1;
				}
				destroy() {
					this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
				}
			}
			var Ft = t.aU([{
				name: "a_pos",
				type: "Int16",
				components: 2
			}]);
			const Bt = "#define PROJECTION_MERCATOR", Ot = "mercator";
			class jt {
				constructor() {
					this._cachedMesh = null;
				}
				get name() {
					return "mercator";
				}
				get useSubdivision() {
					return !1;
				}
				get shaderVariantName() {
					return Ot;
				}
				get shaderDefine() {
					return Bt;
				}
				get shaderPreludeCode() {
					return At.projectionMercator;
				}
				get vertexShaderPreludeCode() {
					return At.projectionMercator.vertexSource;
				}
				get subdivisionGranularity() {
					return t.aV.noSubdivision;
				}
				get useGlobeControls() {
					return !1;
				}
				get transitionState() {
					return 0;
				}
				get latitudeErrorCorrectionRadians() {
					return 0;
				}
				destroy() {}
				updateGPUdependent(e$1) {}
				getMeshFromTileID(e$1, i$1, a$1, o$1, r$1) {
					if (this._cachedMesh) return this._cachedMesh;
					const s$1 = new t.aW();
					s$1.emplaceBack(0, 0), s$1.emplaceBack(t.a5, 0), s$1.emplaceBack(0, t.a5), s$1.emplaceBack(t.a5, t.a5);
					const n$1 = e$1.createVertexBuffer(s$1, Ft.members), l$1 = t.aX.simpleSegment(0, 0, 4, 2), c$1 = new t.aY();
					c$1.emplaceBack(1, 0, 2), c$1.emplaceBack(1, 2, 3);
					return this._cachedMesh = new kt(n$1, e$1.createIndexBuffer(c$1), l$1), this._cachedMesh;
				}
				recalculate() {}
				hasTransition() {
					return !1;
				}
				setErrorQueryLatitudeDegrees(e$1) {}
			}
			class Nt {
				constructor(e$1 = 0, t$1 = 0, i$1 = 0, a$1 = 0) {
					if (isNaN(e$1) || e$1 < 0 || isNaN(t$1) || t$1 < 0 || isNaN(i$1) || i$1 < 0 || isNaN(a$1) || a$1 < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
					this.top = e$1, this.bottom = t$1, this.left = i$1, this.right = a$1;
				}
				interpolate(e$1, i$1, a$1) {
					return null != i$1.top && null != e$1.top && (this.top = t.G.number(e$1.top, i$1.top, a$1)), null != i$1.bottom && null != e$1.bottom && (this.bottom = t.G.number(e$1.bottom, i$1.bottom, a$1)), null != i$1.left && null != e$1.left && (this.left = t.G.number(e$1.left, i$1.left, a$1)), null != i$1.right && null != e$1.right && (this.right = t.G.number(e$1.right, i$1.right, a$1)), this;
				}
				getCenter(e$1, i$1) {
					const a$1 = t.an((this.left + e$1 - this.right) / 2, 0, e$1), o$1 = t.an((this.top + i$1 - this.bottom) / 2, 0, i$1);
					return new t.P(a$1, o$1);
				}
				equals(e$1) {
					return this.top === e$1.top && this.bottom === e$1.bottom && this.left === e$1.left && this.right === e$1.right;
				}
				clone() {
					return new Nt(this.top, this.bottom, this.left, this.right);
				}
				toJSON() {
					return {
						top: this.top,
						bottom: this.bottom,
						left: this.left,
						right: this.right
					};
				}
			}
			function Zt(e$1, t$1) {
				if (!e$1.renderWorldCopies || e$1.lngRange) return;
				const i$1 = t$1.lng - e$1.center.lng;
				t$1.lng += i$1 > 180 ? -360 : i$1 < -180 ? 360 : 0;
			}
			function Ut(e$1) {
				return Math.max(0, Math.floor(e$1));
			}
			class Gt {
				constructor(e$1, i$1) {
					var a$1;
					this.applyConstrain = (e$2, t$1) => null !== this._constrainOverride ? this._constrainOverride(e$2, t$1) : this._callbacks.defaultConstrain(e$2, t$1), this._callbacks = e$1, this._tileSize = 512, this._renderWorldCopies = void 0 === (null == i$1 ? void 0 : i$1.renderWorldCopies) || !!(null == i$1 ? void 0 : i$1.renderWorldCopies), this._minZoom = (null == i$1 ? void 0 : i$1.minZoom) || 0, this._maxZoom = (null == i$1 ? void 0 : i$1.maxZoom) || 22, this._minPitch = null == (null == i$1 ? void 0 : i$1.minPitch) ? 0 : null == i$1 ? void 0 : i$1.minPitch, this._maxPitch = null == (null == i$1 ? void 0 : i$1.maxPitch) ? 60 : null == i$1 ? void 0 : i$1.maxPitch, this._constrainOverride = null !== (a$1 = null == i$1 ? void 0 : i$1.constrainOverride) && void 0 !== a$1 ? a$1 : null, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new t.V(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = Ut(this._zoom), this._scale = t.aq(this._zoom), this._bearingInRadians = 0, this._fovInRadians = .6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new Nt(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0;
				}
				apply(e$1, i$1, a$1) {
					this._constrainOverride = e$1.constrainOverride, this._latRange = e$1.latRange, this._lngRange = e$1.lngRange, this._width = e$1.width, this._height = e$1.height, this._center = e$1.center, this._elevation = e$1.elevation, this._minElevationForCurrentTile = e$1.minElevationForCurrentTile, this._zoom = e$1.zoom, this._tileZoom = Ut(this._zoom), this._scale = t.aq(this._zoom), this._bearingInRadians = e$1.bearingInRadians, this._fovInRadians = e$1.fovInRadians, this._pitchInRadians = e$1.pitchInRadians, this._rollInRadians = e$1.rollInRadians, this._unmodified = e$1.unmodified, this._edgeInsets = new Nt(e$1.padding.top, e$1.padding.bottom, e$1.padding.left, e$1.padding.right), this._minZoom = e$1.minZoom, this._maxZoom = e$1.maxZoom, this._minPitch = e$1.minPitch, this._maxPitch = e$1.maxPitch, this._renderWorldCopies = e$1.renderWorldCopies, this._cameraToCenterDistance = e$1.cameraToCenterDistance, this._nearZ = e$1.nearZ, this._farZ = e$1.farZ, this._autoCalculateNearFarZ = !a$1 && e$1.autoCalculateNearFarZ, i$1 && this.constrainInternal(), this._calcMatrices();
				}
				get pixelsToClipSpaceMatrix() {
					return this._pixelsToClipSpaceMatrix;
				}
				get clipSpaceToPixelsMatrix() {
					return this._clipSpaceToPixelsMatrix;
				}
				get minElevationForCurrentTile() {
					return this._minElevationForCurrentTile;
				}
				setMinElevationForCurrentTile(e$1) {
					this._minElevationForCurrentTile = e$1;
				}
				get tileSize() {
					return this._tileSize;
				}
				get tileZoom() {
					return this._tileZoom;
				}
				get scale() {
					return this._scale;
				}
				get width() {
					return this._width;
				}
				get height() {
					return this._height;
				}
				get bearingInRadians() {
					return this._bearingInRadians;
				}
				get lngRange() {
					return this._lngRange;
				}
				get latRange() {
					return this._latRange;
				}
				get pixelsToGLUnits() {
					return this._pixelsToGLUnits;
				}
				get minZoom() {
					return this._minZoom;
				}
				setMinZoom(e$1) {
					this._minZoom !== e$1 && (this._minZoom = e$1, this.setZoom(this.applyConstrain(this._center, this.zoom).zoom));
				}
				get maxZoom() {
					return this._maxZoom;
				}
				setMaxZoom(e$1) {
					this._maxZoom !== e$1 && (this._maxZoom = e$1, this.setZoom(this.applyConstrain(this._center, this.zoom).zoom));
				}
				get minPitch() {
					return this._minPitch;
				}
				setMinPitch(e$1) {
					this._minPitch !== e$1 && (this._minPitch = e$1, this.setPitch(Math.max(this.pitch, e$1)));
				}
				get maxPitch() {
					return this._maxPitch;
				}
				setMaxPitch(e$1) {
					this._maxPitch !== e$1 && (this._maxPitch = e$1, this.setPitch(Math.min(this.pitch, e$1)));
				}
				get renderWorldCopies() {
					return this._renderWorldCopies;
				}
				setRenderWorldCopies(e$1) {
					void 0 === e$1 ? e$1 = !0 : null === e$1 && (e$1 = !1), this._renderWorldCopies = e$1;
				}
				get constrainOverride() {
					return this._constrainOverride;
				}
				setConstrainOverride(e$1) {
					void 0 === e$1 && (e$1 = null), this._constrainOverride !== e$1 && (this._constrainOverride = e$1, this.constrainInternal(), this._calcMatrices());
				}
				get worldSize() {
					return this._tileSize * this._scale;
				}
				get centerOffset() {
					return this.centerPoint._sub(this.size._div(2));
				}
				get size() {
					return new t.P(this._width, this._height);
				}
				get bearing() {
					return this._bearingInRadians / Math.PI * 180;
				}
				setBearing(e$1) {
					const i$1 = t.W(e$1, -180, 180) * Math.PI / 180;
					var o$1, r$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1;
					this._bearingInRadians !== i$1 && (this._unmodified = !1, this._bearingInRadians = i$1, this._calcMatrices(), this._rotationMatrix = a(), o$1 = this._rotationMatrix, s$1 = -this._bearingInRadians, n$1 = (r$1 = this._rotationMatrix)[0], l$1 = r$1[1], c$1 = r$1[2], h$1 = r$1[3], u$1 = Math.sin(s$1), d$1 = Math.cos(s$1), o$1[0] = n$1 * d$1 + c$1 * u$1, o$1[1] = l$1 * d$1 + h$1 * u$1, o$1[2] = n$1 * -u$1 + c$1 * d$1, o$1[3] = l$1 * -u$1 + h$1 * d$1);
				}
				get rotationMatrix() {
					return this._rotationMatrix;
				}
				get pitchInRadians() {
					return this._pitchInRadians;
				}
				get pitch() {
					return this._pitchInRadians / Math.PI * 180;
				}
				setPitch(e$1) {
					const i$1 = t.an(e$1, this.minPitch, this.maxPitch) / 180 * Math.PI;
					this._pitchInRadians !== i$1 && (this._unmodified = !1, this._pitchInRadians = i$1, this._calcMatrices());
				}
				get rollInRadians() {
					return this._rollInRadians;
				}
				get roll() {
					return this._rollInRadians / Math.PI * 180;
				}
				setRoll(e$1) {
					const t$1 = e$1 / 180 * Math.PI;
					this._rollInRadians !== t$1 && (this._unmodified = !1, this._rollInRadians = t$1, this._calcMatrices());
				}
				get fovInRadians() {
					return this._fovInRadians;
				}
				get fov() {
					return t.aZ(this._fovInRadians);
				}
				setFov(e$1) {
					e$1 = t.an(e$1, .1, 150), this.fov !== e$1 && (this._unmodified = !1, this._fovInRadians = t.ap(e$1), this._calcMatrices());
				}
				get zoom() {
					return this._zoom;
				}
				setZoom(e$1) {
					const i$1 = this.applyConstrain(this._center, e$1).zoom;
					this._zoom !== i$1 && (this._unmodified = !1, this._zoom = i$1, this._tileZoom = Math.max(0, Math.floor(i$1)), this._scale = t.aq(i$1), this.constrainInternal(), this._calcMatrices());
				}
				get center() {
					return this._center;
				}
				setCenter(e$1) {
					e$1.lat === this._center.lat && e$1.lng === this._center.lng || (this._unmodified = !1, this._center = e$1, this.constrainInternal(), this._calcMatrices());
				}
				get elevation() {
					return this._elevation;
				}
				setElevation(e$1) {
					e$1 !== this._elevation && (this._elevation = e$1, this.constrainInternal(), this._calcMatrices());
				}
				get padding() {
					return this._edgeInsets.toJSON();
				}
				setPadding(e$1) {
					this._edgeInsets.equals(e$1) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e$1, 1), this._calcMatrices());
				}
				get centerPoint() {
					return this._edgeInsets.getCenter(this._width, this._height);
				}
				get pixelsPerMeter() {
					return this._pixelPerMeter;
				}
				get unmodified() {
					return this._unmodified;
				}
				get cameraToCenterDistance() {
					return this._cameraToCenterDistance;
				}
				get nearZ() {
					return this._nearZ;
				}
				get farZ() {
					return this._farZ;
				}
				get autoCalculateNearFarZ() {
					return this._autoCalculateNearFarZ;
				}
				overrideNearFarZ(e$1, t$1) {
					this._autoCalculateNearFarZ = !1, this._nearZ = e$1, this._farZ = t$1, this._calcMatrices();
				}
				clearNearFarZOverride() {
					this._autoCalculateNearFarZ = !0, this._calcMatrices();
				}
				isPaddingEqual(e$1) {
					return this._edgeInsets.equals(e$1);
				}
				interpolatePadding(e$1, t$1, i$1) {
					this._unmodified = !1, this._edgeInsets.interpolate(e$1, t$1, i$1), this.constrainInternal(), this._calcMatrices();
				}
				resize(e$1, t$1, i$1 = !0) {
					this._width = e$1, this._height = t$1, i$1 && this.constrainInternal(), this._calcMatrices();
				}
				getMaxBounds() {
					return this._latRange && 2 === this._latRange.length && this._lngRange && 2 === this._lngRange.length ? new $([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
				}
				setMaxBounds(e$1) {
					e$1 ? (this._lngRange = [e$1.getWest(), e$1.getEast()], this._latRange = [e$1.getSouth(), e$1.getNorth()], this.constrainInternal()) : (this._lngRange = null, this._latRange = [-t.ao, t.ao]);
				}
				getCameraQueryGeometry(e$1, i$1) {
					if (1 === i$1.length) return [i$1[0], e$1];
					{
						const { minX: a$1, minY: o$1, maxX: r$1, maxY: s$1 } = t.aa.fromPoints(i$1).extend(e$1);
						return [
							new t.P(a$1, o$1),
							new t.P(r$1, o$1),
							new t.P(r$1, s$1),
							new t.P(a$1, s$1),
							new t.P(a$1, o$1)
						];
					}
				}
				constrainInternal() {
					if (!this.center || !this._width || !this._height || this._constraining) return;
					this._constraining = !0;
					const e$1 = this._unmodified, { center: t$1, zoom: i$1 } = this.applyConstrain(this.center, this.zoom);
					this.setCenter(t$1), this.setZoom(i$1), this._unmodified = e$1, this._constraining = !1;
				}
				_calcMatrices() {
					if (this._width && this._height) {
						this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
						let e$1 = t.ar(new Float64Array(16));
						t.Q(e$1, e$1, [
							this._width / 2,
							-this._height / 2,
							1
						]), t.O(e$1, e$1, [
							1,
							-1,
							0
						]), this._clipSpaceToPixelsMatrix = e$1, e$1 = t.ar(new Float64Array(16)), t.Q(e$1, e$1, [
							1,
							-1,
							1
						]), t.O(e$1, e$1, [
							-1,
							-1,
							0
						]), t.Q(e$1, e$1, [
							2 / this._width,
							2 / this._height,
							1
						]), this._pixelsToClipSpaceMatrix = e$1, this._cameraToCenterDistance = .5 / Math.tan(this.fovInRadians / 2) * this._height;
					}
					this._callbacks.calcMatrices();
				}
				calculateCenterFromCameraLngLatAlt(e$1, i$1, a$1, o$1) {
					const r$1 = void 0 !== a$1 ? a$1 : this.bearing, s$1 = o$1 = void 0 !== o$1 ? o$1 : this.pitch, { distanceToCenter: n$1, clampedElevation: l$1 } = this._distanceToCenterFromAltElevationPitch(i$1, this.elevation, s$1), { x: c$1, y: h$1 } = be(s$1, r$1), u$1 = t.a9.fromLngLat(e$1, i$1);
					let d$1, _$1, p$1 = t.a_(1, u$1.y), m$1 = 0;
					do {
						if (m$1 += 1, m$1 > 10) break;
						_$1 = n$1 / p$1, d$1 = new t.a9(u$1.x + c$1 * _$1, u$1.y + h$1 * _$1), p$1 = 1 / d$1.meterInMercatorCoordinateUnits();
					} while (Math.abs(n$1 - _$1 * p$1) > 1e-12);
					return {
						center: d$1.toLngLat(),
						elevation: l$1,
						zoom: t.at(this.height / 2 / Math.tan(this.fovInRadians / 2) / _$1 / this.tileSize)
					};
				}
				recalculateZoomAndCenter(e$1) {
					if (this.elevation - e$1 == 0) return;
					const i$1 = 1 / this.worldSize, a$1 = t.as(1, this.center.lat) * this.worldSize, o$1 = t.a9.fromLngLat(this.center, this.elevation), r$1 = o$1.x / i$1, s$1 = o$1.y / i$1, n$1 = o$1.z / i$1, l$1 = this.pitch, c$1 = this.bearing, { x: h$1, y: u$1, z: d$1 } = be(l$1, c$1), _$1 = this.cameraToCenterDistance, p$1 = r$1 + _$1 * -h$1, m$1 = s$1 + _$1 * -u$1, f$1 = n$1 + _$1 * d$1, { distanceToCenter: g$1, clampedElevation: v$1 } = this._distanceToCenterFromAltElevationPitch(f$1 / a$1, e$1, l$1), x$1 = g$1 * a$1, b$1 = new t.a9((p$1 + h$1 * x$1) * i$1, (m$1 + u$1 * x$1) * i$1, 0).toLngLat(), y$1 = t.as(1, b$1.lat), w$1 = t.at(this.height / 2 / Math.tan(this.fovInRadians / 2) / g$1 / y$1 / this.tileSize);
					this._elevation = v$1, this._center = b$1, this.setZoom(w$1);
				}
				_distanceToCenterFromAltElevationPitch(e$1, i$1, a$1) {
					const o$1 = -Math.cos(t.ap(a$1)), r$1 = e$1 - i$1;
					let s$1, n$1 = i$1;
					return o$1 * r$1 >= 0 || Math.abs(o$1) < .1 ? (s$1 = 1e4, n$1 = e$1 + s$1 * o$1) : s$1 = -r$1 / o$1, {
						distanceToCenter: s$1,
						clampedElevation: n$1
					};
				}
				getCameraPoint() {
					const e$1 = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
					return this.centerPoint.add(new t.P(e$1 * Math.sin(this.rollInRadians), e$1 * Math.cos(this.rollInRadians)));
				}
				getCameraAltitude() {
					return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
				}
				getCameraLngLat() {
					const e$1 = t.as(1, this.center.lat) * this.worldSize;
					return xe(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e$1).toLngLat();
				}
				getMercatorTileCoordinates(e$1) {
					if (!e$1) return [
						0,
						0,
						1,
						1
					];
					const i$1 = e$1.canonical.z >= 0 ? 1 << e$1.canonical.z : Math.pow(2, e$1.canonical.z);
					return [
						e$1.canonical.x / i$1,
						e$1.canonical.y / i$1,
						1 / i$1 / t.a5,
						1 / i$1 / t.a5
					];
				}
			}
			class Vt {
				constructor(e$1, i$1) {
					this.min = e$1, this.max = i$1, this.center = t.a$([], t.b0([], this.min, this.max), .5);
				}
				quadrant(e$1) {
					const i$1 = [e$1 % 2 == 0, e$1 < 2], a$1 = t.b1(this.min), o$1 = t.b1(this.max);
					for (let e$2 = 0; e$2 < i$1.length; e$2++) a$1[e$2] = i$1[e$2] ? this.min[e$2] : this.center[e$2], o$1[e$2] = i$1[e$2] ? this.center[e$2] : this.max[e$2];
					return o$1[2] = this.max[2], new Vt(a$1, o$1);
				}
				distanceX(e$1) {
					return Math.max(Math.min(this.max[0], e$1[0]), this.min[0]) - e$1[0];
				}
				distanceY(e$1) {
					return Math.max(Math.min(this.max[1], e$1[1]), this.min[1]) - e$1[1];
				}
				intersectsFrustum(e$1) {
					let t$1 = !0;
					for (let i$1 = 0; i$1 < e$1.planes.length; i$1++) {
						const a$1 = this.intersectsPlane(e$1.planes[i$1]);
						if (0 === a$1) return 0;
						1 === a$1 && (t$1 = !1);
					}
					return t$1 ? 2 : e$1.aabb.min[0] > this.max[0] || e$1.aabb.min[1] > this.max[1] || e$1.aabb.min[2] > this.max[2] || e$1.aabb.max[0] < this.min[0] || e$1.aabb.max[1] < this.min[1] || e$1.aabb.max[2] < this.min[2] ? 0 : 1;
				}
				intersectsPlane(e$1) {
					let t$1 = e$1[3], i$1 = e$1[3];
					for (let a$1 = 0; a$1 < 3; a$1++) e$1[a$1] > 0 ? (t$1 += e$1[a$1] * this.min[a$1], i$1 += e$1[a$1] * this.max[a$1]) : (i$1 += e$1[a$1] * this.min[a$1], t$1 += e$1[a$1] * this.max[a$1]);
					return t$1 >= 0 ? 2 : i$1 < 0 ? 0 : 1;
				}
			}
			class qt {
				distanceToTile2d(e$1, t$1, i$1, a$1) {
					const o$1 = a$1.distanceX([e$1, t$1]), r$1 = a$1.distanceY([e$1, t$1]);
					return Math.hypot(o$1, r$1);
				}
				getWrap(e$1, t$1, i$1) {
					return i$1;
				}
				getTileBoundingVolume(e$1, i$1, a$1, o$1) {
					var r$1, s$1;
					let n$1 = 0, l$1 = 0;
					if (null == o$1 ? void 0 : o$1.terrain) {
						const c$2 = new t.a2(e$1.z, i$1, e$1.z, e$1.x, e$1.y), h$1 = o$1.terrain.getMinMaxElevation(c$2);
						n$1 = null !== (r$1 = h$1.minElevation) && void 0 !== r$1 ? r$1 : Math.min(0, a$1), l$1 = null !== (s$1 = h$1.maxElevation) && void 0 !== s$1 ? s$1 : Math.max(0, a$1);
					}
					const c$1 = 1 << e$1.z;
					return new Vt([
						i$1 + e$1.x / c$1,
						e$1.y / c$1,
						n$1
					], [
						i$1 + (e$1.x + 1) / c$1,
						(e$1.y + 1) / c$1,
						l$1
					]);
				}
				allowVariableZoom(e$1, i$1) {
					const a$1 = e$1.fov * (Math.abs(Math.cos(e$1.rollInRadians)) * e$1.height + Math.abs(Math.sin(e$1.rollInRadians)) * e$1.width) / e$1.height, o$1 = t.an(78.5 - a$1 / 2, 0, 60);
					return !!i$1.terrain || e$1.pitch > o$1;
				}
				allowWorldCopies() {
					return !0;
				}
				prepareNextFrame() {}
			}
			class Wt {
				constructor(e$1, t$1, i$1) {
					this.points = e$1, this.planes = t$1, this.aabb = i$1;
				}
				static fromInvProjectionMatrix(e$1, i$1 = 1, a$1 = 0, o$1, r$1) {
					const s$1 = r$1 ? [
						[
							6,
							5,
							4
						],
						[
							0,
							1,
							2
						],
						[
							0,
							3,
							7
						],
						[
							2,
							1,
							5
						],
						[
							3,
							2,
							6
						],
						[
							0,
							4,
							5
						]
					] : [
						[
							0,
							1,
							2
						],
						[
							6,
							5,
							4
						],
						[
							0,
							3,
							7
						],
						[
							2,
							1,
							5
						],
						[
							3,
							2,
							6
						],
						[
							0,
							4,
							5
						]
					], n$1 = Math.pow(2, a$1), l$1 = [
						[
							-1,
							1,
							-1,
							1
						],
						[
							1,
							1,
							-1,
							1
						],
						[
							1,
							-1,
							-1,
							1
						],
						[
							-1,
							-1,
							-1,
							1
						],
						[
							-1,
							1,
							1,
							1
						],
						[
							1,
							1,
							1,
							1
						],
						[
							1,
							-1,
							1,
							1
						],
						[
							-1,
							-1,
							1,
							1
						]
					].map(((a$2) => function(e$2, i$2, a$3, o$2) {
						const r$2 = t.aH([], e$2, i$2), s$2 = 1 / r$2[3] / a$3 * o$2;
						return t.b6(r$2, r$2, [
							s$2,
							s$2,
							1 / r$2[3],
							s$2
						]);
					}(a$2, e$1, i$1, n$1)));
					o$1 && function(e$2, i$2, a$2, o$2) {
						const r$2 = o$2 ? 4 : 0, s$2 = o$2 ? 0 : 4;
						let n$2 = 0;
						const l$2 = [], c$2 = [];
						for (let i$3 = 0; i$3 < 4; i$3++) {
							const a$3 = t.b2([], e$2[i$3 + s$2], e$2[i$3 + r$2]), o$3 = t.b7(a$3);
							t.a$(a$3, a$3, 1 / o$3), l$2.push(o$3), c$2.push(a$3);
						}
						for (let i$3 = 0; i$3 < 4; i$3++) {
							const o$3 = t.b8(e$2[i$3 + r$2], c$2[i$3], a$2);
							n$2 = null !== o$3 && o$3 >= 0 ? Math.max(n$2, o$3) : Math.max(n$2, l$2[i$3]);
						}
						const h$2 = function(e$3, i$3) {
							const a$3 = t.b2([], e$3[i$3[0]], e$3[i$3[1]]), o$3 = t.b2([], e$3[i$3[2]], e$3[i$3[1]]), r$3 = [
								0,
								0,
								0,
								0
							];
							return t.b3(r$3, t.b4([], a$3, o$3)), r$3[3] = -t.b5(r$3, e$3[i$3[0]]), r$3;
						}(e$2, i$2), u$2 = function(e$3, i$3) {
							const a$3 = t.b9(e$3), o$3 = t.ba([], e$3, 1 / a$3), r$3 = t.b2([], i$3, t.a$([], o$3, t.b5(i$3, o$3))), s$3 = t.b9(r$3);
							if (s$3 > 0) {
								const e$4 = Math.sqrt(1 - o$3[3] * o$3[3]), a$4 = t.a$([], o$3, -o$3[3]), n$3 = t.b0([], a$4, t.a$([], r$3, e$4 / s$3));
								return t.bb(i$3, n$3);
							}
							return null;
						}(a$2, h$2);
						if (null !== u$2) {
							const e$3 = u$2 / t.b5(c$2[0], h$2);
							n$2 = Math.min(n$2, e$3);
						}
						for (let t$1 = 0; t$1 < 4; t$1++) {
							const i$3 = Math.min(n$2, l$2[t$1]);
							e$2[t$1 + s$2] = [
								e$2[t$1 + r$2][0] + c$2[t$1][0] * i$3,
								e$2[t$1 + r$2][1] + c$2[t$1][1] * i$3,
								e$2[t$1 + r$2][2] + c$2[t$1][2] * i$3,
								1
							];
						}
					}(l$1, s$1[0], o$1, r$1);
					const c$1 = s$1.map(((e$2) => {
						const i$2 = t.b2([], l$1[e$2[0]], l$1[e$2[1]]), a$2 = t.b2([], l$1[e$2[2]], l$1[e$2[1]]), o$2 = t.b3([], t.b4([], i$2, a$2)), r$2 = -t.b5(o$2, l$1[e$2[1]]);
						return o$2.concat(r$2);
					})), h$1 = [
						Number.POSITIVE_INFINITY,
						Number.POSITIVE_INFINITY,
						Number.POSITIVE_INFINITY
					], u$1 = [
						Number.NEGATIVE_INFINITY,
						Number.NEGATIVE_INFINITY,
						Number.NEGATIVE_INFINITY
					];
					for (const e$2 of l$1) for (let t$1 = 0; t$1 < 3; t$1++) h$1[t$1] = Math.min(h$1[t$1], e$2[t$1]), u$1[t$1] = Math.max(u$1[t$1], e$2[t$1]);
					return new Wt(l$1, c$1, new Vt(h$1, u$1));
				}
			}
			class $t {
				get pixelsToClipSpaceMatrix() {
					return this._helper.pixelsToClipSpaceMatrix;
				}
				get clipSpaceToPixelsMatrix() {
					return this._helper.clipSpaceToPixelsMatrix;
				}
				get pixelsToGLUnits() {
					return this._helper.pixelsToGLUnits;
				}
				get centerOffset() {
					return this._helper.centerOffset;
				}
				get size() {
					return this._helper.size;
				}
				get rotationMatrix() {
					return this._helper.rotationMatrix;
				}
				get centerPoint() {
					return this._helper.centerPoint;
				}
				get pixelsPerMeter() {
					return this._helper.pixelsPerMeter;
				}
				setMinZoom(e$1) {
					this._helper.setMinZoom(e$1);
				}
				setMaxZoom(e$1) {
					this._helper.setMaxZoom(e$1);
				}
				setMinPitch(e$1) {
					this._helper.setMinPitch(e$1);
				}
				setMaxPitch(e$1) {
					this._helper.setMaxPitch(e$1);
				}
				setRenderWorldCopies(e$1) {
					this._helper.setRenderWorldCopies(e$1);
				}
				setBearing(e$1) {
					this._helper.setBearing(e$1);
				}
				setPitch(e$1) {
					this._helper.setPitch(e$1);
				}
				setRoll(e$1) {
					this._helper.setRoll(e$1);
				}
				setFov(e$1) {
					this._helper.setFov(e$1);
				}
				setZoom(e$1) {
					this._helper.setZoom(e$1);
				}
				setCenter(e$1) {
					this._helper.setCenter(e$1);
				}
				setElevation(e$1) {
					this._helper.setElevation(e$1);
				}
				setMinElevationForCurrentTile(e$1) {
					this._helper.setMinElevationForCurrentTile(e$1);
				}
				setPadding(e$1) {
					this._helper.setPadding(e$1);
				}
				interpolatePadding(e$1, t$1, i$1) {
					return this._helper.interpolatePadding(e$1, t$1, i$1);
				}
				isPaddingEqual(e$1) {
					return this._helper.isPaddingEqual(e$1);
				}
				resize(e$1, t$1, i$1 = !0) {
					this._helper.resize(e$1, t$1, i$1);
				}
				getMaxBounds() {
					return this._helper.getMaxBounds();
				}
				setMaxBounds(e$1) {
					this._helper.setMaxBounds(e$1);
				}
				setConstrainOverride(e$1) {
					this._helper.setConstrainOverride(e$1);
				}
				overrideNearFarZ(e$1, t$1) {
					this._helper.overrideNearFarZ(e$1, t$1);
				}
				clearNearFarZOverride() {
					this._helper.clearNearFarZOverride();
				}
				getCameraQueryGeometry(e$1) {
					return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e$1);
				}
				get tileSize() {
					return this._helper.tileSize;
				}
				get tileZoom() {
					return this._helper.tileZoom;
				}
				get scale() {
					return this._helper.scale;
				}
				get worldSize() {
					return this._helper.worldSize;
				}
				get width() {
					return this._helper.width;
				}
				get height() {
					return this._helper.height;
				}
				get lngRange() {
					return this._helper.lngRange;
				}
				get latRange() {
					return this._helper.latRange;
				}
				get minZoom() {
					return this._helper.minZoom;
				}
				get maxZoom() {
					return this._helper.maxZoom;
				}
				get zoom() {
					return this._helper.zoom;
				}
				get center() {
					return this._helper.center;
				}
				get minPitch() {
					return this._helper.minPitch;
				}
				get maxPitch() {
					return this._helper.maxPitch;
				}
				get pitch() {
					return this._helper.pitch;
				}
				get pitchInRadians() {
					return this._helper.pitchInRadians;
				}
				get roll() {
					return this._helper.roll;
				}
				get rollInRadians() {
					return this._helper.rollInRadians;
				}
				get bearing() {
					return this._helper.bearing;
				}
				get bearingInRadians() {
					return this._helper.bearingInRadians;
				}
				get fov() {
					return this._helper.fov;
				}
				get fovInRadians() {
					return this._helper.fovInRadians;
				}
				get elevation() {
					return this._helper.elevation;
				}
				get minElevationForCurrentTile() {
					return this._helper.minElevationForCurrentTile;
				}
				get padding() {
					return this._helper.padding;
				}
				get unmodified() {
					return this._helper.unmodified;
				}
				get renderWorldCopies() {
					return this._helper.renderWorldCopies;
				}
				get cameraToCenterDistance() {
					return this._helper.cameraToCenterDistance;
				}
				get constrainOverride() {
					return this._helper.constrainOverride;
				}
				get nearZ() {
					return this._helper.nearZ;
				}
				get farZ() {
					return this._helper.farZ;
				}
				get autoCalculateNearFarZ() {
					return this._helper.autoCalculateNearFarZ;
				}
				setTransitionState(e$1, t$1) {}
				constructor(e$1) {
					this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this.defaultConstrain = (e$2, i$1) => {
						i$1 = t.an(+i$1, this.minZoom, this.maxZoom);
						const a$1 = {
							center: new t.V(e$2.lng, e$2.lat),
							zoom: i$1
						};
						let o$1 = this._helper._lngRange;
						if (!this._helper._renderWorldCopies && null === o$1) {
							const e$3 = 179.9999999999;
							o$1 = [-e$3, e$3];
						}
						const r$1 = this.tileSize * t.aq(a$1.zoom);
						let s$1 = 0, n$1 = r$1, l$1 = 0, c$1 = r$1, h$1 = 0, u$1 = 0;
						const { x: d$1, y: _$1 } = this.size;
						if (this._helper._latRange) {
							const e$3 = this._helper._latRange;
							s$1 = t.X(e$3[1]) * r$1, n$1 = t.X(e$3[0]) * r$1, n$1 - s$1 < _$1 && (h$1 = _$1 / (n$1 - s$1));
						}
						o$1 && (l$1 = t.W(t.Y(o$1[0]) * r$1, 0, r$1), c$1 = t.W(t.Y(o$1[1]) * r$1, 0, r$1), c$1 < l$1 && (c$1 += r$1), c$1 - l$1 < d$1 && (u$1 = d$1 / (c$1 - l$1)));
						const { x: p$1, y: m$1 } = me(r$1, e$2);
						let f$1, g$1;
						const v$1 = Math.max(u$1 || 0, h$1 || 0);
						if (v$1) return a$1.center = fe(r$1, new t.P(u$1 ? (c$1 + l$1) / 2 : p$1, h$1 ? (n$1 + s$1) / 2 : m$1)).wrap(), a$1.zoom += t.at(v$1), a$1;
						if (this._helper._latRange) {
							const e$3 = _$1 / 2;
							m$1 - e$3 < s$1 && (g$1 = s$1 + e$3), m$1 + e$3 > n$1 && (g$1 = n$1 - e$3);
						}
						if (o$1) {
							const e$3 = (l$1 + c$1) / 2;
							let i$2 = p$1;
							this._helper._renderWorldCopies && (i$2 = t.W(p$1, e$3 - r$1 / 2, e$3 + r$1 / 2));
							const a$2 = d$1 / 2;
							i$2 - a$2 < l$1 && (f$1 = l$1 + a$2), i$2 + a$2 > c$1 && (f$1 = c$1 - a$2);
						}
						if (void 0 !== f$1 || void 0 !== g$1) a$1.center = fe(r$1, new t.P(null != f$1 ? f$1 : p$1, null != g$1 ? g$1 : m$1)).wrap();
						return a$1;
					}, this.applyConstrain = (e$2, t$1) => this._helper.applyConstrain(e$2, t$1), this._helper = new Gt({
						calcMatrices: () => {
							this._calcMatrices();
						},
						defaultConstrain: (e$2, t$1) => this.defaultConstrain(e$2, t$1)
					}, e$1), this._coveringTilesDetailsProvider = new qt();
				}
				clone() {
					const e$1 = new $t();
					return e$1.apply(this, !1), e$1;
				}
				apply(e$1, t$1, i$1) {
					this._helper.apply(e$1, t$1, i$1);
				}
				get cameraPosition() {
					return this._cameraPosition;
				}
				get projectionMatrix() {
					return this._projectionMatrix;
				}
				get modelViewProjectionMatrix() {
					return this._viewProjMatrix;
				}
				get inverseProjectionMatrix() {
					return this._invProjMatrix;
				}
				get mercatorMatrix() {
					return this._mercatorMatrix;
				}
				getVisibleUnwrappedCoordinates(e$1) {
					const i$1 = [new t.bc(0, e$1)];
					if (this._helper._renderWorldCopies) {
						const a$1 = this.screenPointToMercatorCoordinate(new t.P(0, 0)), o$1 = this.screenPointToMercatorCoordinate(new t.P(this._helper._width, 0)), r$1 = this.screenPointToMercatorCoordinate(new t.P(this._helper._width, this._helper._height)), s$1 = this.screenPointToMercatorCoordinate(new t.P(0, this._helper._height)), n$1 = Math.floor(Math.min(a$1.x, o$1.x, r$1.x, s$1.x)), l$1 = Math.floor(Math.max(a$1.x, o$1.x, r$1.x, s$1.x)), c$1 = 1;
						for (let a$2 = n$1 - c$1; a$2 <= l$1 + c$1; a$2++) 0 !== a$2 && i$1.push(new t.bc(a$2, e$1));
					}
					return i$1;
				}
				getCameraFrustum() {
					return Wt.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
				}
				getClippingPlane() {
					return null;
				}
				getCoveringTilesDetailsProvider() {
					return this._coveringTilesDetailsProvider;
				}
				recalculateZoomAndCenter(e$1) {
					const t$1 = this.screenPointToLocation(this.centerPoint, e$1), i$1 = e$1 ? e$1.getElevationForLngLatZoom(t$1, this._helper._tileZoom) : 0;
					this._helper.recalculateZoomAndCenter(i$1);
				}
				setLocationAtPoint(e$1, i$1) {
					const a$1 = t.as(this.elevation, this.center.lat), o$1 = this.screenPointToMercatorCoordinateAtZ(i$1, a$1), r$1 = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, a$1), s$1 = t.a9.fromLngLat(e$1), n$1 = new t.a9(s$1.x - (o$1.x - r$1.x), s$1.y - (o$1.y - r$1.y));
					this.setCenter(null == n$1 ? void 0 : n$1.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
				}
				locationToScreenPoint(e$1, i$1) {
					return i$1 ? this.coordinatePoint(t.a9.fromLngLat(e$1), i$1.getElevationForLngLat(e$1, this), this._pixelMatrix3D) : this.coordinatePoint(t.a9.fromLngLat(e$1));
				}
				screenPointToLocation(e$1, t$1) {
					var i$1;
					return null === (i$1 = this.screenPointToMercatorCoordinate(e$1, t$1)) || void 0 === i$1 ? void 0 : i$1.toLngLat();
				}
				screenPointToMercatorCoordinate(e$1, t$1) {
					if (t$1) {
						const i$1 = t$1.pointCoordinate(e$1);
						if (null != i$1) return i$1;
					}
					return this.screenPointToMercatorCoordinateAtZ(e$1);
				}
				screenPointToMercatorCoordinateAtZ(e$1, i$1) {
					const a$1 = i$1 || 0, o$1 = [
						e$1.x,
						e$1.y,
						0,
						1
					], r$1 = [
						e$1.x,
						e$1.y,
						1,
						1
					];
					t.aH(o$1, o$1, this._pixelMatrixInverse), t.aH(r$1, r$1, this._pixelMatrixInverse);
					const s$1 = o$1[3], n$1 = r$1[3], l$1 = o$1[1] / s$1, c$1 = r$1[1] / n$1, h$1 = o$1[2] / s$1, u$1 = r$1[2] / n$1, d$1 = h$1 === u$1 ? 0 : (a$1 - h$1) / (u$1 - h$1);
					return new t.a9(t.G.number(o$1[0] / s$1, r$1[0] / n$1, d$1) / this.worldSize, t.G.number(l$1, c$1, d$1) / this.worldSize, a$1);
				}
				coordinatePoint(e$1, i$1 = 0, a$1 = this._pixelMatrix) {
					const o$1 = [
						e$1.x * this.worldSize,
						e$1.y * this.worldSize,
						i$1,
						1
					];
					return t.aH(o$1, o$1, a$1), new t.P(o$1[0] / o$1[3], o$1[1] / o$1[3]);
				}
				getBounds() {
					const e$1 = Math.max(0, this._helper._height / 2 - ge(this));
					return new $().extend(this.screenPointToLocation(new t.P(0, e$1))).extend(this.screenPointToLocation(new t.P(this._helper._width, e$1))).extend(this.screenPointToLocation(new t.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new t.P(0, this._helper._height)));
				}
				isPointOnMapSurface(e$1, t$1) {
					return t$1 ? null != t$1.pointCoordinate(e$1) : e$1.y > this.height / 2 - ge(this);
				}
				calculatePosMatrix(e$1, i$1 = !1, a$1) {
					var o$1;
					const r$1 = null !== (o$1 = e$1.key) && void 0 !== o$1 ? o$1 : t.bd(e$1.wrap, e$1.canonical.z, e$1.canonical.z, e$1.canonical.x, e$1.canonical.y), s$1 = i$1 ? this._alignedPosMatrixCache : this._posMatrixCache;
					if (s$1.has(r$1)) {
						const e$2 = s$1.get(r$1);
						return a$1 ? e$2.f32 : e$2.f64;
					}
					const n$1 = ve(e$1, this.worldSize);
					t.S(n$1, i$1 ? this._alignedProjMatrix : this._viewProjMatrix, n$1);
					const l$1 = {
						f64: n$1,
						f32: new Float32Array(n$1)
					};
					return s$1.set(r$1, l$1), a$1 ? l$1.f32 : l$1.f64;
				}
				calculateFogMatrix(e$1) {
					const i$1 = e$1.key, a$1 = this._fogMatrixCacheF32;
					if (a$1.has(i$1)) return a$1.get(i$1);
					const o$1 = ve(e$1, this.worldSize);
					return t.S(o$1, this._fogMatrix, o$1), a$1.set(i$1, new Float32Array(o$1)), a$1.get(i$1);
				}
				calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, a$1) {
					return this._helper.calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, a$1);
				}
				_calculateNearFarZIfNeeded(e$1, i$1, a$1) {
					if (!this._helper.autoCalculateNearFarZ) return;
					const o$1 = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), r$1 = e$1 - o$1 * this._helper._pixelPerMeter / Math.cos(i$1), s$1 = o$1 < 0 ? r$1 : e$1, n$1 = Math.PI / 2 + this.pitchInRadians, l$1 = t.ap(this.fov) * (Math.abs(Math.cos(t.ap(this.roll))) * this.height + Math.abs(Math.sin(t.ap(this.roll))) * this.width) / this.height * (.5 + a$1.y / this.height), c$1 = Math.sin(l$1) * s$1 / Math.sin(t.an(Math.PI - n$1 - l$1, .01, Math.PI - .01)), h$1 = ge(this), u$1 = Math.atan(h$1 / this._helper.cameraToCenterDistance), d$1 = t.ap(.75), _$1 = u$1 > d$1 ? 2 * u$1 * (.5 + a$1.y / (2 * h$1)) : d$1, p$1 = Math.sin(_$1) * s$1 / Math.sin(t.an(Math.PI - n$1 - _$1, .01, Math.PI - .01)), m$1 = Math.min(c$1, p$1);
					this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - i$1) * m$1 + s$1), this._helper._nearZ = this._helper._height / 50;
				}
				_calcMatrices() {
					if (!this._helper._height) return;
					const e$1 = this.centerOffset, i$1 = me(this.worldSize, this.center), a$1 = i$1.x, o$1 = i$1.y;
					this._helper._pixelPerMeter = t.as(1, this.center.lat) * this.worldSize;
					const r$1 = t.ap(Math.min(this.pitch, pe)), s$1 = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(r$1));
					let n$1;
					this._calculateNearFarZIfNeeded(s$1, r$1, e$1), n$1 = new Float64Array(16), t.be(n$1, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), t.aB(this._invProjMatrix, n$1), n$1[8] = 2 * -e$1.x / this._helper._width, n$1[9] = 2 * e$1.y / this._helper._height, this._projectionMatrix = t.bf(n$1), t.Q(n$1, n$1, [
						1,
						-1,
						1
					]), t.O(n$1, n$1, [
						0,
						0,
						-this._helper.cameraToCenterDistance
					]), t.bg(n$1, n$1, -this.rollInRadians), t.bh(n$1, n$1, this.pitchInRadians), t.bg(n$1, n$1, -this.bearingInRadians), t.O(n$1, n$1, [
						-a$1,
						-o$1,
						0
					]), this._mercatorMatrix = t.Q([], n$1, [
						this.worldSize,
						this.worldSize,
						this.worldSize
					]), t.Q(n$1, n$1, [
						1,
						1,
						this._helper._pixelPerMeter
					]), this._pixelMatrix = t.S(new Float64Array(16), this.clipSpaceToPixelsMatrix, n$1), t.O(n$1, n$1, [
						0,
						0,
						-this.elevation
					]), this._viewProjMatrix = n$1, this._invViewProjMatrix = t.aB([], n$1);
					const l$1 = [
						0,
						0,
						-1,
						1
					];
					t.aH(l$1, l$1, this._invViewProjMatrix), this._cameraPosition = [
						l$1[0] / l$1[3],
						l$1[1] / l$1[3],
						l$1[2] / l$1[3]
					], this._fogMatrix = new Float64Array(16), t.be(this._fogMatrix, this.fovInRadians, this.width / this.height, s$1, this._helper._farZ), this._fogMatrix[8] = 2 * -e$1.x / this.width, this._fogMatrix[9] = 2 * e$1.y / this.height, t.Q(this._fogMatrix, this._fogMatrix, [
						1,
						-1,
						1
					]), t.O(this._fogMatrix, this._fogMatrix, [
						0,
						0,
						-this.cameraToCenterDistance
					]), t.bg(this._fogMatrix, this._fogMatrix, -this.rollInRadians), t.bh(this._fogMatrix, this._fogMatrix, this.pitchInRadians), t.bg(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), t.O(this._fogMatrix, this._fogMatrix, [
						-a$1,
						-o$1,
						0
					]), t.Q(this._fogMatrix, this._fogMatrix, [
						1,
						1,
						this._helper._pixelPerMeter
					]), t.O(this._fogMatrix, this._fogMatrix, [
						0,
						0,
						-this.elevation
					]), this._pixelMatrix3D = t.S(new Float64Array(16), this.clipSpaceToPixelsMatrix, n$1);
					const c$1 = this._helper._width % 2 / 2, h$1 = this._helper._height % 2 / 2, u$1 = Math.cos(this.bearingInRadians), d$1 = Math.sin(-this.bearingInRadians), _$1 = a$1 - Math.round(a$1) + u$1 * c$1 + d$1 * h$1, p$1 = o$1 - Math.round(o$1) + u$1 * h$1 + d$1 * c$1, m$1 = new Float64Array(n$1);
					if (t.O(m$1, m$1, [
						_$1 > .5 ? _$1 - 1 : _$1,
						p$1 > .5 ? p$1 - 1 : p$1,
						0
					]), this._alignedProjMatrix = m$1, n$1 = t.aB(new Float64Array(16), this._pixelMatrix), !n$1) throw new Error("failed to invert matrix");
					this._pixelMatrixInverse = n$1, this._clearMatrixCaches();
				}
				_clearMatrixCaches() {
					this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
				}
				maxPitchScaleFactor() {
					if (!this._pixelMatrixInverse) return 1;
					const e$1 = this.screenPointToMercatorCoordinate(new t.P(0, 0)), i$1 = [
						e$1.x * this.worldSize,
						e$1.y * this.worldSize,
						0,
						1
					];
					return t.aH(i$1, i$1, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
				}
				getCameraPoint() {
					return this._helper.getCameraPoint();
				}
				getCameraAltitude() {
					return this._helper.getCameraAltitude();
				}
				getCameraLngLat() {
					const e$1 = t.as(1, this.center.lat) * this.worldSize;
					return xe(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e$1).toLngLat();
				}
				lngLatToCameraDepth(e$1, i$1) {
					const a$1 = t.a9.fromLngLat(e$1), o$1 = [
						a$1.x * this.worldSize,
						a$1.y * this.worldSize,
						i$1,
						1
					];
					return t.aH(o$1, o$1, this._viewProjMatrix), o$1[2] / o$1[3];
				}
				getProjectionData(e$1) {
					const { overscaledTileID: i$1, aligned: a$1, applyTerrainMatrix: o$1 } = e$1, r$1 = this._helper.getMercatorTileCoordinates(i$1), s$1 = i$1 ? this.calculatePosMatrix(i$1, a$1, !0) : null;
					let n$1;
					return n$1 = i$1 && i$1.terrainRttPosMatrix32f && o$1 ? i$1.terrainRttPosMatrix32f : s$1 || t.bi(), {
						mainMatrix: n$1,
						tileMercatorCoords: r$1,
						clippingPlane: [
							0,
							0,
							0,
							0
						],
						projectionTransition: 0,
						fallbackMatrix: n$1
					};
				}
				isLocationOccluded(e$1) {
					return !1;
				}
				getPixelScale() {
					return 1;
				}
				getCircleRadiusCorrection() {
					return 1;
				}
				getPitchedTextCorrection(e$1, t$1, i$1) {
					return 1;
				}
				transformLightDirection(e$1) {
					return t.b1(e$1);
				}
				getRayDirectionFromPixel(e$1) {
					throw new Error("Not implemented.");
				}
				projectTileCoordinates(e$1, i$1, a$1, o$1) {
					const r$1 = this.calculatePosMatrix(a$1);
					let s$1;
					o$1 ? (s$1 = [
						e$1,
						i$1,
						o$1(e$1, i$1),
						1
					], t.aH(s$1, s$1, r$1)) : (s$1 = [
						e$1,
						i$1,
						0,
						1
					], rt(s$1, s$1, r$1));
					const n$1 = s$1[3];
					return {
						point: new t.P(s$1[0] / n$1, s$1[1] / n$1),
						signedDistanceFromCamera: n$1,
						isOccluded: !1
					};
				}
				populateCache(e$1) {
					for (const t$1 of e$1) this.calculatePosMatrix(t$1);
				}
				getMatrixForModel(e$1, i$1) {
					const a$1 = t.a9.fromLngLat(e$1, i$1), o$1 = a$1.meterInMercatorCoordinateUnits(), r$1 = t.bj();
					return t.O(r$1, r$1, [
						a$1.x,
						a$1.y,
						a$1.z
					]), t.bg(r$1, r$1, Math.PI), t.bh(r$1, r$1, Math.PI / 2), t.Q(r$1, r$1, [
						-o$1,
						o$1,
						o$1
					]), r$1;
				}
				getProjectionDataForCustomLayer(e$1 = !0) {
					const i$1 = new t.a2(0, 0, 0, 0, 0), a$1 = this.getProjectionData({
						overscaledTileID: i$1,
						applyGlobeMatrix: e$1
					}), o$1 = ve(i$1, this.worldSize);
					t.S(o$1, this._viewProjMatrix, o$1), a$1.tileMercatorCoords = [
						0,
						0,
						1,
						1
					];
					const r$1 = [
						t.a5,
						t.a5,
						this.worldSize / this._helper.pixelsPerMeter
					], s$1 = t.bk();
					return t.Q(s$1, o$1, r$1), a$1.fallbackMatrix = s$1, a$1.mainMatrix = s$1, a$1;
				}
				getFastPathSimpleProjectionMatrix(e$1) {
					return this.calculatePosMatrix(e$1);
				}
			}
			function Ht() {
				t.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
			}
			function Xt(e$1) {
				if (e$1.useSlerp) if (e$1.k < 1) {
					const i$1 = t.bl(e$1.startEulerAngles.roll, e$1.startEulerAngles.pitch, e$1.startEulerAngles.bearing), a$1 = t.bl(e$1.endEulerAngles.roll, e$1.endEulerAngles.pitch, e$1.endEulerAngles.bearing), o$1 = new Float64Array(4);
					t.bm(o$1, i$1, a$1, e$1.k);
					const r$1 = t.bn(o$1);
					e$1.tr.setRoll(r$1.roll), e$1.tr.setPitch(r$1.pitch), e$1.tr.setBearing(r$1.bearing);
				} else e$1.tr.setRoll(e$1.endEulerAngles.roll), e$1.tr.setPitch(e$1.endEulerAngles.pitch), e$1.tr.setBearing(e$1.endEulerAngles.bearing);
				else e$1.tr.setRoll(t.G.number(e$1.startEulerAngles.roll, e$1.endEulerAngles.roll, e$1.k)), e$1.tr.setPitch(t.G.number(e$1.startEulerAngles.pitch, e$1.endEulerAngles.pitch, e$1.k)), e$1.tr.setBearing(t.G.number(e$1.startEulerAngles.bearing, e$1.endEulerAngles.bearing, e$1.k));
			}
			function Kt(e$1, i$1, a$1, o$1, r$1) {
				const s$1 = r$1.padding, n$1 = me(r$1.worldSize, a$1.getNorthWest()), l$1 = me(r$1.worldSize, a$1.getNorthEast()), c$1 = me(r$1.worldSize, a$1.getSouthEast()), h$1 = me(r$1.worldSize, a$1.getSouthWest()), u$1 = t.ap(-o$1), d$1 = n$1.rotate(u$1), _$1 = l$1.rotate(u$1), p$1 = c$1.rotate(u$1), m$1 = h$1.rotate(u$1), f$1 = new t.P(Math.max(d$1.x, _$1.x, m$1.x, p$1.x), Math.max(d$1.y, _$1.y, m$1.y, p$1.y)), g$1 = new t.P(Math.min(d$1.x, _$1.x, m$1.x, p$1.x), Math.min(d$1.y, _$1.y, m$1.y, p$1.y)), v$1 = f$1.sub(g$1), x$1 = (r$1.width - (s$1.left + s$1.right + i$1.left + i$1.right)) / v$1.x, b$1 = (r$1.height - (s$1.top + s$1.bottom + i$1.top + i$1.bottom)) / v$1.y;
				if (b$1 < 0 || x$1 < 0) return void Ht();
				const y$1 = Math.min(t.at(r$1.scale * Math.min(x$1, b$1)), e$1.maxZoom), w$1 = t.P.convert(e$1.offset), T$1 = new t.P((i$1.left - i$1.right) / 2, (i$1.top - i$1.bottom) / 2).rotate(t.ap(o$1)), P$1 = w$1.add(T$1).mult(r$1.scale / t.aq(y$1));
				return {
					center: fe(r$1.worldSize, n$1.add(c$1).div(2).sub(P$1)),
					zoom: y$1,
					bearing: o$1
				};
			}
			class Yt {
				get useGlobeControls() {
					return !1;
				}
				handlePanInertia(e$1, t$1) {
					const i$1 = e$1.mag(), a$1 = Math.abs(ge(t$1));
					return {
						easingOffset: e$1.mult(Math.min(.75 * a$1 / i$1, 1)),
						easingCenter: t$1.center
					};
				}
				handleMapControlsRollPitchBearingZoom(e$1, t$1) {
					e$1.bearingDelta && t$1.setBearing(t$1.bearing + e$1.bearingDelta), e$1.pitchDelta && t$1.setPitch(t$1.pitch + e$1.pitchDelta), e$1.rollDelta && t$1.setRoll(t$1.roll + e$1.rollDelta), e$1.zoomDelta && t$1.setZoom(t$1.zoom + e$1.zoomDelta);
				}
				handleMapControlsPan(e$1, t$1, i$1) {
					e$1.around.distSqr(t$1.centerPoint) < .01 || t$1.setLocationAtPoint(i$1, e$1.around);
				}
				cameraForBoxAndBearing(e$1, t$1, i$1, a$1, o$1) {
					return Kt(e$1, t$1, i$1, a$1, o$1);
				}
				handleJumpToCenterZoom(e$1, i$1) {
					e$1.zoom !== (void 0 !== i$1.zoom ? +i$1.zoom : e$1.zoom) && e$1.setZoom(+i$1.zoom), void 0 !== i$1.center && e$1.setCenter(t.V.convert(i$1.center));
				}
				handleEaseTo(e$1, i$1) {
					const a$1 = e$1.zoom, o$1 = e$1.padding, r$1 = {
						roll: e$1.roll,
						pitch: e$1.pitch,
						bearing: e$1.bearing
					}, s$1 = {
						roll: void 0 === i$1.roll ? e$1.roll : i$1.roll,
						pitch: void 0 === i$1.pitch ? e$1.pitch : i$1.pitch,
						bearing: void 0 === i$1.bearing ? e$1.bearing : i$1.bearing
					}, n$1 = void 0 !== i$1.zoom, l$1 = !e$1.isPaddingEqual(i$1.padding);
					let c$1 = !1;
					const h$1 = n$1 ? +i$1.zoom : e$1.zoom;
					let u$1 = e$1.centerPoint.add(i$1.offsetAsPoint);
					const d$1 = e$1.screenPointToLocation(u$1), { center: _$1, zoom: p$1 } = e$1.applyConstrain(t.V.convert(i$1.center || d$1), null != h$1 ? h$1 : a$1);
					Zt(e$1, _$1);
					const m$1 = me(e$1.worldSize, d$1), f$1 = me(e$1.worldSize, _$1).sub(m$1), g$1 = t.aq(p$1 - a$1);
					return c$1 = p$1 !== a$1, {
						easeFunc: (n$2) => {
							if (c$1 && e$1.setZoom(t.G.number(a$1, p$1, n$2)), t.bo(r$1, s$1) || Xt({
								startEulerAngles: r$1,
								endEulerAngles: s$1,
								tr: e$1,
								k: n$2,
								useSlerp: r$1.roll != s$1.roll
							}), l$1 && (e$1.interpolatePadding(o$1, i$1.padding, n$2), u$1 = e$1.centerPoint.add(i$1.offsetAsPoint)), i$1.around) e$1.setLocationAtPoint(i$1.around, i$1.aroundPoint);
							else {
								const i$2 = t.aq(e$1.zoom - a$1), o$2 = p$1 > a$1 ? Math.min(2, g$1) : Math.max(.5, g$1), r$2 = Math.pow(o$2, 1 - n$2), s$2 = fe(e$1.worldSize, m$1.add(f$1.mult(n$2 * r$2)).mult(i$2));
								e$1.setLocationAtPoint(e$1.renderWorldCopies ? s$2.wrap() : s$2, u$1);
							}
						},
						isZooming: c$1,
						elevationCenter: _$1
					};
				}
				handleFlyTo(e$1, i$1) {
					const a$1 = void 0 !== i$1.zoom, o$1 = e$1.zoom, r$1 = e$1.applyConstrain(t.V.convert(i$1.center || i$1.locationAtOffset), a$1 ? +i$1.zoom : o$1), s$1 = r$1.center, n$1 = r$1.zoom;
					Zt(e$1, s$1);
					const l$1 = me(e$1.worldSize, i$1.locationAtOffset), c$1 = me(e$1.worldSize, s$1).sub(l$1), h$1 = c$1.mag(), u$1 = t.aq(n$1 - o$1);
					let d$1;
					if (void 0 !== i$1.minZoom) {
						const a$2 = Math.min(+i$1.minZoom, o$1, n$1), r$2 = e$1.applyConstrain(s$1, a$2).zoom;
						d$1 = t.aq(r$2 - o$1);
					}
					return {
						easeFunc: (i$2, a$2, r$2, h$2) => {
							e$1.setZoom(1 === i$2 ? n$1 : o$1 + t.at(a$2));
							const u$2 = 1 === i$2 ? s$1 : fe(e$1.worldSize, l$1.add(c$1.mult(r$2)).mult(a$2));
							e$1.setLocationAtPoint(e$1.renderWorldCopies ? u$2.wrap() : u$2, h$2);
						},
						scaleOfZoom: u$1,
						targetCenter: s$1,
						scaleOfMinZoom: d$1,
						pixelPathLength: h$1
					};
				}
			}
			class Qt {
				constructor(e$1, t$1, i$1) {
					this.blendFunction = e$1, this.blendColor = t$1, this.mask = i$1;
				}
			}
			Qt.Replace = [1, 0], Qt.disabled = new Qt(Qt.Replace, t.bp.transparent, [
				!1,
				!1,
				!1,
				!1
			]), Qt.unblended = new Qt(Qt.Replace, t.bp.transparent, [
				!0,
				!0,
				!0,
				!0
			]), Qt.alphaBlended = new Qt([1, 771], t.bp.transparent, [
				!0,
				!0,
				!0,
				!0
			]);
			const Jt = 2305;
			class ei {
				constructor(e$1, t$1, i$1) {
					this.enable = e$1, this.mode = t$1, this.frontFace = i$1;
				}
			}
			ei.disabled = new ei(!1, 1029, Jt), ei.backCCW = new ei(!0, 1029, Jt), ei.frontCCW = new ei(!0, 1028, Jt);
			class ti {
				constructor(e$1, t$1, i$1) {
					this.func = e$1, this.mask = t$1, this.range = i$1;
				}
			}
			ti.ReadOnly = !1, ti.ReadWrite = !0, ti.disabled = new ti(519, ti.ReadOnly, [0, 1]);
			const ii = 7680;
			class ai {
				constructor(e$1, t$1, i$1, a$1, o$1, r$1) {
					this.test = e$1, this.ref = t$1, this.mask = i$1, this.fail = a$1, this.depthFail = o$1, this.pass = r$1;
				}
			}
			ai.disabled = new ai({
				func: 519,
				mask: 0
			}, 0, 0, ii, ii, ii);
			const oi = /* @__PURE__ */ new WeakMap();
			function ri(e$1) {
				var t$1;
				if (oi.has(e$1)) return oi.get(e$1);
				{
					const i$1 = null === (t$1 = e$1.getParameter(e$1.VERSION)) || void 0 === t$1 ? void 0 : t$1.startsWith("WebGL 2.0");
					return oi.set(e$1, i$1), i$1;
				}
			}
			class si {
				get awaitingQuery() {
					return !!this._readbackQueue;
				}
				constructor(e$1) {
					this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e$1;
					const i$1 = e$1.context, a$1 = i$1.gl;
					this._texFormat = a$1.RGBA, this._texType = a$1.UNSIGNED_BYTE;
					const o$1 = new t.aW();
					o$1.emplaceBack(-1, -1), o$1.emplaceBack(2, -1), o$1.emplaceBack(-1, 2);
					const r$1 = new t.aY();
					r$1.emplaceBack(0, 1, 2), this._fullscreenTriangle = new kt(i$1.createVertexBuffer(o$1, Ft.members), i$1.createIndexBuffer(r$1), t.aX.simpleSegment(0, 0, o$1.length, r$1.length)), this._resultBuffer = new Uint8Array(4), i$1.activeTexture.set(a$1.TEXTURE1);
					const s$1 = a$1.createTexture();
					a$1.bindTexture(a$1.TEXTURE_2D, s$1), a$1.texParameteri(a$1.TEXTURE_2D, a$1.TEXTURE_WRAP_S, a$1.CLAMP_TO_EDGE), a$1.texParameteri(a$1.TEXTURE_2D, a$1.TEXTURE_WRAP_T, a$1.CLAMP_TO_EDGE), a$1.texParameteri(a$1.TEXTURE_2D, a$1.TEXTURE_MIN_FILTER, a$1.NEAREST), a$1.texParameteri(a$1.TEXTURE_2D, a$1.TEXTURE_MAG_FILTER, a$1.NEAREST), a$1.texImage2D(a$1.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = i$1.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(s$1), ri(a$1) && (this._pbo = a$1.createBuffer(), a$1.bindBuffer(a$1.PIXEL_PACK_BUFFER, this._pbo), a$1.bufferData(a$1.PIXEL_PACK_BUFFER, 4, a$1.STREAM_READ), a$1.bindBuffer(a$1.PIXEL_PACK_BUFFER, null));
				}
				destroy() {
					const e$1 = this._cachedRenderContext.context.gl;
					this._fullscreenTriangle.destroy(), this._fbo.destroy(), e$1.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
				}
				updateErrorLoop(e$1, t$1) {
					const i$1 = this._updateCount;
					return this._readbackQueue ? i$1 >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : i$1 >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e$1, t$1), this._updateCount++, this._measuredError;
				}
				_bindFramebuffer() {
					const e$1 = this._cachedRenderContext.context, t$1 = e$1.gl;
					e$1.activeTexture.set(t$1.TEXTURE1), t$1.bindTexture(t$1.TEXTURE_2D, this._fbo.colorAttachment.get()), e$1.bindFramebuffer.set(this._fbo.framebuffer);
				}
				_renderErrorTexture(e$1, i$1) {
					const a$1 = this._cachedRenderContext.context, o$1 = a$1.gl;
					if (this._bindFramebuffer(), a$1.viewport.set([
						0,
						0,
						this._texWidth,
						this._texHeight
					]), a$1.clear({ color: t.bp.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(a$1, o$1.TRIANGLES, ti.disabled, ai.disabled, Qt.unblended, ei.disabled, ((e$2, t$1) => ({
						u_input: e$2,
						u_output_expected: t$1
					}))(e$1, i$1), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && ri(o$1)) {
						o$1.bindBuffer(o$1.PIXEL_PACK_BUFFER, this._pbo), o$1.readBuffer(o$1.COLOR_ATTACHMENT0), o$1.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), o$1.bindBuffer(o$1.PIXEL_PACK_BUFFER, null);
						const e$2 = o$1.fenceSync(o$1.SYNC_GPU_COMMANDS_COMPLETE, 0);
						o$1.flush(), this._readbackQueue = {
							frameNumberIssued: this._updateCount,
							sync: e$2
						};
					} else this._readbackQueue = {
						frameNumberIssued: this._updateCount,
						sync: null
					};
				}
				_tryReadback() {
					const e$1 = this._cachedRenderContext.context.gl;
					if (this._pbo && this._readbackQueue && ri(e$1)) {
						const i$1 = e$1.clientWaitSync(this._readbackQueue.sync, 0, 0);
						if (i$1 === e$1.WAIT_FAILED) return t.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
						if (i$1 === e$1.TIMEOUT_EXPIRED) return;
						e$1.bindBuffer(e$1.PIXEL_PACK_BUFFER, this._pbo), e$1.getBufferSubData(e$1.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e$1.bindBuffer(e$1.PIXEL_PACK_BUFFER, null);
					} else this._bindFramebuffer(), e$1.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
					this._readbackQueue = null, this._measuredError = si._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
				}
				static _parseRGBA8float(e$1) {
					let t$1 = 0;
					return t$1 += e$1[0] / 256, t$1 += e$1[1] / 65536, t$1 += e$1[2] / 16777216, e$1[3] < 127 && (t$1 = -t$1), t$1 / 128;
				}
			}
			const ni = t.a5 / 128;
			function li(e$1, i$1) {
				const a$1 = void 0 !== e$1.granularity ? Math.max(e$1.granularity, 1) : 1, o$1 = a$1 + (e$1.generateBorders ? 2 : 0), r$1 = a$1 + (e$1.extendToNorthPole || e$1.generateBorders ? 1 : 0) + (e$1.extendToSouthPole || e$1.generateBorders ? 1 : 0), s$1 = o$1 + 1, n$1 = r$1 + 1, l$1 = e$1.generateBorders ? -1 : 0, c$1 = e$1.generateBorders || e$1.extendToNorthPole ? -1 : 0, h$1 = a$1 + (e$1.generateBorders ? 1 : 0), u$1 = a$1 + (e$1.generateBorders || e$1.extendToSouthPole ? 1 : 0), d$1 = s$1 * n$1, _$1 = o$1 * r$1 * 6, p$1 = s$1 * n$1 > 65536;
				if (p$1 && "16bit" === i$1) throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
				const m$1 = p$1 || "32bit" === i$1, f$1 = new Int16Array(2 * d$1);
				let g$1 = 0;
				for (let i$2 = c$1; i$2 <= u$1; i$2++) for (let o$2 = l$1; o$2 <= h$1; o$2++) {
					let r$2 = o$2 / a$1 * t.a5;
					-1 === o$2 && (r$2 = -ni), o$2 === a$1 + 1 && (r$2 = t.a5 + ni);
					let s$2 = i$2 / a$1 * t.a5;
					-1 === i$2 && (s$2 = e$1.extendToNorthPole ? t.br : -ni), i$2 === a$1 + 1 && (s$2 = e$1.extendToSouthPole ? t.bs : t.a5 + ni), f$1[g$1++] = r$2, f$1[g$1++] = s$2;
				}
				const v$1 = m$1 ? new Uint32Array(_$1) : new Uint16Array(_$1);
				let x$1 = 0;
				for (let e$2 = 0; e$2 < r$1; e$2++) for (let t$1 = 0; t$1 < o$1; t$1++) {
					const i$2 = t$1 + 1 + e$2 * s$1, a$2 = t$1 + (e$2 + 1) * s$1, o$2 = t$1 + 1 + (e$2 + 1) * s$1;
					v$1[x$1++] = t$1 + e$2 * s$1, v$1[x$1++] = a$2, v$1[x$1++] = i$2, v$1[x$1++] = i$2, v$1[x$1++] = a$2, v$1[x$1++] = o$2;
				}
				return {
					vertices: f$1.buffer.slice(0),
					indices: v$1.buffer.slice(0),
					uses32bitIndices: m$1
				};
			}
			const ci = new t.aV({
				fill: new t.bt(128, 2),
				line: new t.bt(512, 0),
				tile: new t.bt(128, 32),
				stencil: new t.bt(128, 1),
				circle: 3
			});
			class hi {
				constructor() {
					this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
				}
				get name() {
					return "vertical-perspective";
				}
				get transitionState() {
					return 1;
				}
				get useSubdivision() {
					return !0;
				}
				get shaderVariantName() {
					return "globe";
				}
				get shaderDefine() {
					return "#define GLOBE";
				}
				get shaderPreludeCode() {
					return At.projectionGlobe;
				}
				get vertexShaderPreludeCode() {
					return At.projectionMercator.vertexSource;
				}
				get subdivisionGranularity() {
					return ci;
				}
				get useGlobeControls() {
					return !0;
				}
				get latitudeErrorCorrectionRadians() {
					return this._errorCorrectionUsable;
				}
				destroy() {
					this._errorMeasurement && this._errorMeasurement.destroy();
				}
				updateGPUdependent(e$1) {
					this._errorMeasurement || (this._errorMeasurement = new si(e$1));
					const i$1 = t.X(this._errorQueryLatitudeDegrees), a$1 = 2 * Math.atan(Math.exp(Math.PI - i$1 * Math.PI * 2)) - .5 * Math.PI, o$1 = this._errorMeasurement.updateErrorLoop(i$1, a$1), r$1 = c();
					o$1 !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = o$1, this._errorMeasurementLastChangeTime = r$1);
					const s$1 = Math.min(Math.max((r$1 - this._errorMeasurementLastChangeTime) / 1e3 / .5, 0), 1);
					this._errorCorrectionUsable = t.bu(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, t.bv(s$1));
				}
				_getMeshKey(e$1) {
					return `${e$1.granularity.toString(36)}_${e$1.generateBorders ? "b" : ""}${e$1.extendToNorthPole ? "n" : ""}${e$1.extendToSouthPole ? "s" : ""}`;
				}
				getMeshFromTileID(e$1, t$1, i$1, a$1, o$1) {
					const r$1 = ("stencil" === o$1 ? ci.stencil : ci.tile).getGranularityForZoomLevel(t$1.z);
					return this._getMesh(e$1, {
						granularity: r$1,
						generateBorders: i$1,
						extendToNorthPole: 0 === t$1.y && a$1,
						extendToSouthPole: t$1.y === (1 << t$1.z) - 1 && a$1
					});
				}
				_getMesh(e$1, i$1) {
					const a$1 = this._getMeshKey(i$1);
					if (a$1 in this._tileMeshCache) return this._tileMeshCache[a$1];
					const o$1 = function(e$2, i$2) {
						const a$2 = li(i$2, "16bit"), o$2 = t.aW.deserialize({
							arrayBuffer: a$2.vertices,
							length: a$2.vertices.byteLength / 2 / 2
						}), r$1 = t.aY.deserialize({
							arrayBuffer: a$2.indices,
							length: a$2.indices.byteLength / 2 / 3
						});
						return new kt(e$2.createVertexBuffer(o$2, Ft.members), e$2.createIndexBuffer(r$1), t.aX.simpleSegment(0, 0, o$2.length, r$1.length));
					}(e$1, i$1);
					return this._tileMeshCache[a$1] = o$1, o$1;
				}
				recalculate(e$1) {}
				hasTransition() {
					const e$1 = c();
					let t$1 = !1;
					return t$1 = t$1 || (e$1 - this._errorMeasurementLastChangeTime) / 1e3 < .7, t$1 = t$1 || this._errorMeasurement && this._errorMeasurement.awaitingQuery, t$1;
				}
				setErrorQueryLatitudeDegrees(e$1) {
					this._errorQueryLatitudeDegrees = e$1;
				}
			}
			const ui = new t.t({ type: new t.D(t.u.projection.type) });
			class di extends t.E {
				constructor(e$1) {
					super(), this._transitionable = new t.x(ui, void 0), this.setProjection(e$1), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new t.H(0)), this._mercatorProjection = new jt(), this._verticalPerspectiveProjection = new hi();
				}
				get transitionState() {
					const e$1 = this.properties.get("type");
					if ("string" == typeof e$1 && "mercator" === e$1) return 0;
					if ("string" == typeof e$1 && "vertical-perspective" === e$1) return 1;
					if (e$1 instanceof t.bw) {
						if ("vertical-perspective" === e$1.from && "mercator" === e$1.to) return 1 - e$1.transition;
						if ("mercator" === e$1.from && "vertical-perspective" === e$1.to) return e$1.transition;
					}
					return 1;
				}
				get useGlobeRendering() {
					return this.transitionState > 0;
				}
				get latitudeErrorCorrectionRadians() {
					return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
				}
				get currentProjection() {
					return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
				}
				get name() {
					return "globe";
				}
				get useSubdivision() {
					return this.currentProjection.useSubdivision;
				}
				get shaderVariantName() {
					return this.currentProjection.shaderVariantName;
				}
				get shaderDefine() {
					return this.currentProjection.shaderDefine;
				}
				get shaderPreludeCode() {
					return this.currentProjection.shaderPreludeCode;
				}
				get vertexShaderPreludeCode() {
					return this.currentProjection.vertexShaderPreludeCode;
				}
				get subdivisionGranularity() {
					return this.currentProjection.subdivisionGranularity;
				}
				get useGlobeControls() {
					return this.transitionState > 0;
				}
				destroy() {
					this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
				}
				updateGPUdependent(e$1) {
					this._mercatorProjection.updateGPUdependent(e$1), this._verticalPerspectiveProjection.updateGPUdependent(e$1);
				}
				getMeshFromTileID(e$1, t$1, i$1, a$1, o$1) {
					return this.currentProjection.getMeshFromTileID(e$1, t$1, i$1, a$1, o$1);
				}
				setProjection(e$1) {
					this._transitionable.setValue("type", (null == e$1 ? void 0 : e$1.type) || "mercator");
				}
				updateTransitions(e$1) {
					this._transitioning = this._transitionable.transitioned(e$1, this._transitioning);
				}
				hasTransition() {
					return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
				}
				recalculate(e$1) {
					this.properties = this._transitioning.possiblyEvaluate(e$1);
				}
				setErrorQueryLatitudeDegrees(e$1) {
					this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e$1), this._mercatorProjection.setErrorQueryLatitudeDegrees(e$1);
				}
			}
			function _i(e$1) {
				const t$1 = fi(e$1.worldSize, e$1.center.lat);
				return 2 * Math.PI * t$1;
			}
			function pi(e$1, i$1, a$1, o$1, r$1) {
				const s$1 = 1 / (1 << r$1), n$1 = i$1 / t.a5 * s$1 + o$1 * s$1, l$1 = t.bz((e$1 / t.a5 * s$1 + a$1 * s$1) * Math.PI * 2 + Math.PI, 2 * Math.PI), c$1 = 2 * Math.atan(Math.exp(Math.PI - n$1 * Math.PI * 2)) - .5 * Math.PI, h$1 = Math.cos(c$1), u$1 = new Float64Array(3);
				return u$1[0] = Math.sin(l$1) * h$1, u$1[1] = Math.sin(c$1), u$1[2] = Math.cos(l$1) * h$1, u$1;
			}
			function mi(e$1) {
				return function(e$2, t$1) {
					const i$1 = Math.cos(t$1), a$1 = new Float64Array(3);
					return a$1[0] = Math.sin(e$2) * i$1, a$1[1] = Math.sin(t$1), a$1[2] = Math.cos(e$2) * i$1, a$1;
				}(e$1.lng * Math.PI / 180, e$1.lat * Math.PI / 180);
			}
			function fi(e$1, t$1) {
				return e$1 / (2 * Math.PI) / Math.cos(t$1 * Math.PI / 180);
			}
			function gi(e$1) {
				const i$1 = Math.asin(e$1[1]) / Math.PI * 180, a$1 = Math.sqrt(e$1[0] * e$1[0] + e$1[2] * e$1[2]);
				if (a$1 > 1e-6) {
					const o$1 = e$1[0] / a$1, r$1 = Math.acos(e$1[2] / a$1), s$1 = (o$1 > 0 ? r$1 : -r$1) / Math.PI * 180;
					return new t.V(t.W(s$1, -180, 180), i$1);
				}
				return new t.V(0, i$1);
			}
			function vi(e$1) {
				return Math.cos(e$1 * Math.PI / 180);
			}
			function xi(e$1, i$1) {
				const a$1 = vi(e$1), o$1 = vi(i$1);
				return t.at(o$1 / a$1);
			}
			function bi(e$1, i$1) {
				const a$1 = e$1.rotate(i$1.bearingInRadians), o$1 = i$1.zoom + xi(i$1.center.lat, 0), r$1 = t.bu(1 / vi(i$1.center.lat), 1 / vi(Math.min(Math.abs(i$1.center.lat), 60)), t.bx(o$1, 7, 3, 0, 1)), s$1 = 360 / _i({
					worldSize: i$1.worldSize,
					center: { lat: i$1.center.lat }
				});
				return new t.V(i$1.center.lng - a$1.x * s$1 * r$1, t.an(i$1.center.lat + a$1.y * s$1, -t.ao, t.ao));
			}
			function yi(e$1) {
				const t$1 = .5 * e$1, i$1 = Math.sin(t$1), a$1 = Math.cos(t$1);
				return Math.log(i$1 + a$1) - Math.log(a$1 - i$1);
			}
			function wi(e$1, i$1, a$1, o$1) {
				const r$1 = e$1.lat + a$1 * o$1;
				if (Math.abs(a$1) > 1) {
					const s$1 = (Math.sign(e$1.lat + a$1) !== Math.sign(e$1.lat) ? -Math.abs(e$1.lat) : Math.abs(e$1.lat)) * Math.PI / 180, n$1 = Math.abs(e$1.lat + a$1) * Math.PI / 180, l$1 = yi(s$1 + o$1 * (n$1 - s$1)), c$1 = yi(s$1), h$1 = yi(n$1);
					return new t.V(e$1.lng + i$1 * ((l$1 - c$1) / (h$1 - c$1)), r$1);
				}
				return new t.V(e$1.lng + i$1 * o$1, r$1);
			}
			class Ti {
				constructor(e$1) {
					this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = !1, this._boundingVolumeFactory = e$1;
				}
				swapBuffers() {
					if (!this._hadAnyChanges) return;
					const e$1 = this._cachePrevious;
					this._cachePrevious = this._cache, this._cache = e$1, this._cache.clear(), this._hadAnyChanges = !1;
				}
				getTileBoundingVolume(e$1, t$1, i$1, a$1) {
					const o$1 = `${e$1.z}_${e$1.x}_${e$1.y}_${(null == a$1 ? void 0 : a$1.terrain) ? "t" : ""}`, r$1 = this._cache.get(o$1);
					if (r$1) return r$1;
					const s$1 = this._cachePrevious.get(o$1);
					if (s$1) return this._cache.set(o$1, s$1), s$1;
					const n$1 = this._boundingVolumeFactory(e$1, t$1, i$1, a$1);
					return this._cache.set(o$1, n$1), this._hadAnyChanges = !0, n$1;
				}
			}
			class Pi {
				constructor(e$1, t$1, i$1, a$1) {
					this.min = i$1, this.max = a$1, this.points = e$1, this.planes = t$1;
				}
				static fromAabb(e$1, t$1) {
					const i$1 = [];
					for (let a$1 = 0; a$1 < 8; a$1++) i$1.push([
						1 & ~a$1 ? e$1[0] : t$1[0],
						1 == (a$1 >> 1 & 1) ? t$1[1] : e$1[1],
						1 == (a$1 >> 2 & 1) ? t$1[2] : e$1[2]
					]);
					return new Pi(i$1, [
						[
							-1,
							0,
							0,
							t$1[0]
						],
						[
							1,
							0,
							0,
							-e$1[0]
						],
						[
							0,
							-1,
							0,
							t$1[1]
						],
						[
							0,
							1,
							0,
							-e$1[1]
						],
						[
							0,
							0,
							-1,
							t$1[2]
						],
						[
							0,
							0,
							1,
							-e$1[2]
						]
					], e$1, t$1);
				}
				static fromCenterSizeAngles(e$1, i$1, a$1) {
					const o$1 = t.bB([], a$1[0], a$1[1], a$1[2]), r$1 = t.bC([], [
						i$1[0],
						0,
						0
					], o$1), s$1 = t.bC([], [
						0,
						i$1[1],
						0
					], o$1), n$1 = t.bC([], [
						0,
						0,
						i$1[2]
					], o$1), l$1 = [...e$1], c$1 = [...e$1];
					for (let t$1 = 0; t$1 < 8; t$1++) for (let i$2 = 0; i$2 < 3; i$2++) {
						const a$2 = e$1[i$2] + r$1[i$2] * (1 & ~t$1 ? -1 : 1) + s$1[i$2] * (1 == (t$1 >> 1 & 1) ? 1 : -1) + n$1[i$2] * (1 == (t$1 >> 2 & 1) ? 1 : -1);
						l$1[i$2] = Math.min(l$1[i$2], a$2), c$1[i$2] = Math.max(c$1[i$2], a$2);
					}
					const h$1 = [];
					for (let i$2 = 0; i$2 < 8; i$2++) {
						const a$2 = [...e$1];
						t.b0(a$2, a$2, t.a$([], r$1, 1 & ~i$2 ? -1 : 1)), t.b0(a$2, a$2, t.a$([], s$1, 1 == (i$2 >> 1 & 1) ? 1 : -1)), t.b0(a$2, a$2, t.a$([], n$1, 1 == (i$2 >> 2 & 1) ? 1 : -1)), h$1.push(a$2);
					}
					return new Pi(h$1, [
						[...r$1, -t.b5(r$1, h$1[0])],
						[...s$1, -t.b5(s$1, h$1[0])],
						[...n$1, -t.b5(n$1, h$1[0])],
						[
							-r$1[0],
							-r$1[1],
							-r$1[2],
							-t.b5(r$1, h$1[7])
						],
						[
							-s$1[0],
							-s$1[1],
							-s$1[2],
							-t.b5(s$1, h$1[7])
						],
						[
							-n$1[0],
							-n$1[1],
							-n$1[2],
							-t.b5(n$1, h$1[7])
						]
					], l$1, c$1);
				}
				intersectsFrustum(e$1) {
					let t$1 = !0;
					const i$1 = this.points.length, a$1 = this.planes.length, o$1 = e$1.planes.length, r$1 = e$1.points.length;
					for (let a$2 = 0; a$2 < o$1; a$2++) {
						const o$2 = e$1.planes[a$2];
						let r$2 = 0;
						for (let e$2 = 0; e$2 < i$1; e$2++) {
							const t$2 = this.points[e$2];
							o$2[0] * t$2[0] + o$2[1] * t$2[1] + o$2[2] * t$2[2] + o$2[3] >= 0 && r$2++;
						}
						if (0 === r$2) return 0;
						r$2 < i$1 && (t$1 = !1);
					}
					if (t$1) return 2;
					for (let t$2 = 0; t$2 < a$1; t$2++) {
						const i$2 = this.planes[t$2];
						let a$2 = 0;
						for (let t$3 = 0; t$3 < r$1; t$3++) {
							const o$2 = e$1.points[t$3];
							i$2[0] * o$2[0] + i$2[1] * o$2[1] + i$2[2] * o$2[2] + i$2[3] >= 0 && a$2++;
						}
						if (0 === a$2) return 0;
					}
					return 1;
				}
				intersectsPlane(e$1) {
					const t$1 = this.points.length;
					let i$1 = 0;
					for (let a$1 = 0; a$1 < t$1; a$1++) {
						const t$2 = this.points[a$1];
						e$1[0] * t$2[0] + e$1[1] * t$2[1] + e$1[2] * t$2[2] + e$1[3] >= 0 && i$1++;
					}
					return i$1 === t$1 ? 2 : 0 === i$1 ? 0 : 1;
				}
			}
			function Ci(e$1, t$1, i$1) {
				const a$1 = e$1 - t$1;
				return a$1 < 0 ? -a$1 : Math.max(0, a$1 - i$1);
			}
			function Ii(e$1, t$1, i$1, a$1, o$1) {
				const r$1 = e$1 - i$1;
				let s$1;
				return s$1 = r$1 < 0 ? Math.min(-r$1, 1 + r$1 - o$1) : r$1 > 1 ? Math.min(Math.max(r$1 - o$1, 0), 1 - r$1) : 0, Math.max(s$1, Ci(t$1, a$1, o$1));
			}
			class Mi {
				constructor() {
					this._boundingVolumeCache = new Ti(this._computeTileBoundingVolume);
				}
				prepareNextFrame() {
					this._boundingVolumeCache.swapBuffers();
				}
				distanceToTile2d(e$1, t$1, i$1, a$1) {
					const o$1 = 1 << i$1.z, r$1 = 1 / o$1, s$1 = i$1.x / o$1, n$1 = i$1.y / o$1;
					let l$1 = 2;
					return l$1 = Math.min(l$1, Ii(e$1, t$1, s$1, n$1, r$1)), l$1 = Math.min(l$1, Ii(e$1, t$1, s$1 + .5, -n$1 - r$1, r$1)), l$1 = Math.min(l$1, Ii(e$1, t$1, s$1 + .5, 2 - n$1 - r$1, r$1)), l$1;
				}
				getWrap(e$1, t$1, i$1) {
					const a$1 = 1 << t$1.z, o$1 = 1 / a$1, r$1 = t$1.x / a$1, s$1 = Ci(e$1.x, r$1, o$1), n$1 = Ci(e$1.x, r$1 - 1, o$1), l$1 = Ci(e$1.x, r$1 + 1, o$1), c$1 = Math.min(s$1, n$1, l$1);
					return c$1 === l$1 ? 1 : c$1 === n$1 ? -1 : 0;
				}
				allowVariableZoom(e$1, t$1) {
					return Ce(e$1, t$1) > 4;
				}
				allowWorldCopies() {
					return !1;
				}
				getTileBoundingVolume(e$1, t$1, i$1, a$1) {
					return this._boundingVolumeCache.getTileBoundingVolume(e$1, t$1, i$1, a$1);
				}
				_computeTileBoundingVolume(e$1, i$1, a$1, o$1) {
					var r$1, s$1;
					let n$1 = 0, l$1 = 0;
					if (null == o$1 ? void 0 : o$1.terrain) {
						const c$1 = new t.a2(e$1.z, i$1, e$1.z, e$1.x, e$1.y), h$1 = o$1.terrain.getMinMaxElevation(c$1);
						n$1 = null !== (r$1 = h$1.minElevation) && void 0 !== r$1 ? r$1 : Math.min(0, a$1), l$1 = null !== (s$1 = h$1.maxElevation) && void 0 !== s$1 ? s$1 : Math.max(0, a$1);
					}
					if (n$1 /= t.bE, l$1 /= t.bE, n$1 += 1, l$1 += 1, e$1.z <= 0) return Pi.fromAabb([
						-l$1,
						-l$1,
						-l$1
					], [
						l$1,
						l$1,
						l$1
					]);
					if (1 === e$1.z) return Pi.fromAabb([
						0 === e$1.x ? -l$1 : 0,
						0 === e$1.y ? 0 : -l$1,
						-l$1
					], [
						0 === e$1.x ? 0 : l$1,
						0 === e$1.y ? l$1 : 0,
						l$1
					]);
					{
						const i$2 = [
							pi(0, 0, e$1.x, e$1.y, e$1.z),
							pi(t.a5, 0, e$1.x, e$1.y, e$1.z),
							pi(t.a5, t.a5, e$1.x, e$1.y, e$1.z),
							pi(0, t.a5, e$1.x, e$1.y, e$1.z)
						], a$2 = [];
						for (const e$2 of i$2) a$2.push(t.a$([], e$2, l$1));
						if (l$1 !== n$1) for (const e$2 of i$2) a$2.push(t.a$([], e$2, n$1));
						0 === e$1.y && a$2.push([
							0,
							1,
							0
						]), e$1.y === (1 << e$1.z) - 1 && a$2.push([
							0,
							-1,
							0
						]);
						const o$2 = [
							1,
							1,
							1
						], r$2 = [
							-1,
							-1,
							-1
						];
						for (const e$2 of a$2) for (let t$1 = 0; t$1 < 3; t$1++) o$2[t$1] = Math.min(o$2[t$1], e$2[t$1]), r$2[t$1] = Math.max(r$2[t$1], e$2[t$1]);
						const s$2 = pi(t.a5 / 2, t.a5 / 2, e$1.x, e$1.y, e$1.z), c$1 = t.b4([], [
							0,
							1,
							0
						], s$2);
						t.b3(c$1, c$1);
						const h$1 = t.b4([], s$2, c$1);
						t.b3(h$1, h$1);
						const u$1 = t.b4([], i$2[2], i$2[1]);
						t.b3(u$1, u$1);
						const d$1 = t.b4([], i$2[0], i$2[3]);
						t.b3(d$1, d$1), a$2.push(t.a$([], s$2, l$1)), e$1.y >= (1 << e$1.z) / 2 && a$2.push(t.a$([], pi(t.a5 / 2, 0, e$1.x, e$1.y, e$1.z), l$1)), e$1.y < (1 << e$1.z) / 2 && a$2.push(t.a$([], pi(t.a5 / 2, t.a5, e$1.x, e$1.y, e$1.z), l$1));
						const _$1 = Ei(s$2, a$2), p$1 = Ei(h$1, a$2), m$1 = [
							-s$2[0],
							-s$2[1],
							-s$2[2],
							_$1.max
						], f$1 = [
							s$2[0],
							s$2[1],
							s$2[2],
							-_$1.min
						], g$1 = [
							-h$1[0],
							-h$1[1],
							-h$1[2],
							p$1.max
						], v$1 = [
							h$1[0],
							h$1[1],
							h$1[2],
							-p$1.min
						], x$1 = [...u$1, 0], b$1 = [...d$1, 0], y$1 = [];
						return 0 === e$1.y ? y$1.push(t.bD(b$1, x$1, m$1), t.bD(b$1, x$1, f$1)) : y$1.push(t.bD(g$1, x$1, m$1), t.bD(g$1, x$1, f$1), t.bD(g$1, b$1, m$1), t.bD(g$1, b$1, f$1)), e$1.y === (1 << e$1.z) - 1 ? y$1.push(t.bD(b$1, x$1, m$1), t.bD(b$1, x$1, f$1)) : y$1.push(t.bD(v$1, x$1, m$1), t.bD(v$1, x$1, f$1), t.bD(v$1, b$1, m$1), t.bD(v$1, b$1, f$1)), new Pi(y$1, [
							m$1,
							f$1,
							g$1,
							v$1,
							x$1,
							b$1
						], o$2, r$2);
					}
				}
			}
			function Ei(e$1, i$1) {
				let a$1 = Infinity, o$1 = -Infinity;
				for (const r$1 of i$1) {
					const i$2 = t.b5(e$1, r$1);
					a$1 = Math.min(a$1, i$2), o$1 = Math.max(o$1, i$2);
				}
				return {
					min: a$1,
					max: o$1
				};
			}
			class Si {
				get pixelsToClipSpaceMatrix() {
					return this._helper.pixelsToClipSpaceMatrix;
				}
				get clipSpaceToPixelsMatrix() {
					return this._helper.clipSpaceToPixelsMatrix;
				}
				get pixelsToGLUnits() {
					return this._helper.pixelsToGLUnits;
				}
				get centerOffset() {
					return this._helper.centerOffset;
				}
				get size() {
					return this._helper.size;
				}
				get rotationMatrix() {
					return this._helper.rotationMatrix;
				}
				get centerPoint() {
					return this._helper.centerPoint;
				}
				get pixelsPerMeter() {
					return this._helper.pixelsPerMeter;
				}
				setMinZoom(e$1) {
					this._helper.setMinZoom(e$1);
				}
				setMaxZoom(e$1) {
					this._helper.setMaxZoom(e$1);
				}
				setMinPitch(e$1) {
					this._helper.setMinPitch(e$1);
				}
				setMaxPitch(e$1) {
					this._helper.setMaxPitch(e$1);
				}
				setRenderWorldCopies(e$1) {
					this._helper.setRenderWorldCopies(e$1);
				}
				setBearing(e$1) {
					this._helper.setBearing(e$1);
				}
				setPitch(e$1) {
					this._helper.setPitch(e$1);
				}
				setRoll(e$1) {
					this._helper.setRoll(e$1);
				}
				setFov(e$1) {
					this._helper.setFov(e$1);
				}
				setZoom(e$1) {
					this._helper.setZoom(e$1);
				}
				setCenter(e$1) {
					this._helper.setCenter(e$1);
				}
				setElevation(e$1) {
					this._helper.setElevation(e$1);
				}
				setMinElevationForCurrentTile(e$1) {
					this._helper.setMinElevationForCurrentTile(e$1);
				}
				setPadding(e$1) {
					this._helper.setPadding(e$1);
				}
				interpolatePadding(e$1, t$1, i$1) {
					return this._helper.interpolatePadding(e$1, t$1, i$1);
				}
				isPaddingEqual(e$1) {
					return this._helper.isPaddingEqual(e$1);
				}
				resize(e$1, t$1) {
					this._helper.resize(e$1, t$1);
				}
				getMaxBounds() {
					return this._helper.getMaxBounds();
				}
				setMaxBounds(e$1) {
					this._helper.setMaxBounds(e$1);
				}
				setConstrainOverride(e$1) {
					this._helper.setConstrainOverride(e$1);
				}
				overrideNearFarZ(e$1, t$1) {
					this._helper.overrideNearFarZ(e$1, t$1);
				}
				clearNearFarZOverride() {
					this._helper.clearNearFarZOverride();
				}
				getCameraQueryGeometry(e$1) {
					return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e$1);
				}
				get tileSize() {
					return this._helper.tileSize;
				}
				get tileZoom() {
					return this._helper.tileZoom;
				}
				get scale() {
					return this._helper.scale;
				}
				get worldSize() {
					return this._helper.worldSize;
				}
				get width() {
					return this._helper.width;
				}
				get height() {
					return this._helper.height;
				}
				get lngRange() {
					return this._helper.lngRange;
				}
				get latRange() {
					return this._helper.latRange;
				}
				get minZoom() {
					return this._helper.minZoom;
				}
				get maxZoom() {
					return this._helper.maxZoom;
				}
				get zoom() {
					return this._helper.zoom;
				}
				get center() {
					return this._helper.center;
				}
				get minPitch() {
					return this._helper.minPitch;
				}
				get maxPitch() {
					return this._helper.maxPitch;
				}
				get pitch() {
					return this._helper.pitch;
				}
				get pitchInRadians() {
					return this._helper.pitchInRadians;
				}
				get roll() {
					return this._helper.roll;
				}
				get rollInRadians() {
					return this._helper.rollInRadians;
				}
				get bearing() {
					return this._helper.bearing;
				}
				get bearingInRadians() {
					return this._helper.bearingInRadians;
				}
				get fov() {
					return this._helper.fov;
				}
				get fovInRadians() {
					return this._helper.fovInRadians;
				}
				get elevation() {
					return this._helper.elevation;
				}
				get minElevationForCurrentTile() {
					return this._helper.minElevationForCurrentTile;
				}
				get padding() {
					return this._helper.padding;
				}
				get unmodified() {
					return this._helper.unmodified;
				}
				get renderWorldCopies() {
					return this._helper.renderWorldCopies;
				}
				get constrainOverride() {
					return this._helper.constrainOverride;
				}
				get nearZ() {
					return this._helper.nearZ;
				}
				get farZ() {
					return this._helper.farZ;
				}
				get autoCalculateNearFarZ() {
					return this._helper.autoCalculateNearFarZ;
				}
				setTransitionState(e$1) {}
				constructor(e$1) {
					this._cachedClippingPlane = t.bF(), this._projectionMatrix = t.bj(), this._globeViewProjMatrix32f = t.bi(), this._globeViewProjMatrixNoCorrection = t.bj(), this._globeViewProjMatrixNoCorrectionInverted = t.bj(), this._globeProjMatrixInverted = t.bj(), this._cameraPosition = t.bA(), this._globeLatitudeErrorCorrectionRadians = 0, this.defaultConstrain = (e$2, i$1) => {
						const a$1 = t.an(e$2.lat, -t.ao, t.ao), o$1 = t.an(+i$1, this.minZoom + xi(0, a$1), this.maxZoom);
						return {
							center: new t.V(e$2.lng, a$1),
							zoom: o$1
						};
					}, this.applyConstrain = (e$2, t$1) => this._helper.applyConstrain(e$2, t$1), this._helper = new Gt({
						calcMatrices: () => {
							this._calcMatrices();
						},
						defaultConstrain: (e$2, t$1) => this.defaultConstrain(e$2, t$1)
					}, e$1), this._coveringTilesDetailsProvider = new Mi();
				}
				clone() {
					const e$1 = new Si();
					return e$1.apply(this, !1), e$1;
				}
				apply(e$1, t$1, i$1) {
					this._globeLatitudeErrorCorrectionRadians = i$1 || 0, this._helper.apply(e$1, t$1);
				}
				get projectionMatrix() {
					return this._projectionMatrix;
				}
				get modelViewProjectionMatrix() {
					return this._globeViewProjMatrixNoCorrection;
				}
				get inverseProjectionMatrix() {
					return this._globeProjMatrixInverted;
				}
				get cameraPosition() {
					const e$1 = t.bA();
					return e$1[0] = this._cameraPosition[0], e$1[1] = this._cameraPosition[1], e$1[2] = this._cameraPosition[2], e$1;
				}
				get cameraToCenterDistance() {
					return this._helper.cameraToCenterDistance;
				}
				getProjectionData(e$1) {
					const { overscaledTileID: t$1, applyGlobeMatrix: i$1 } = e$1, a$1 = this._helper.getMercatorTileCoordinates(t$1);
					return {
						mainMatrix: this._globeViewProjMatrix32f,
						tileMercatorCoords: a$1,
						clippingPlane: this._cachedClippingPlane,
						projectionTransition: i$1 ? 1 : 0,
						fallbackMatrix: this._globeViewProjMatrix32f
					};
				}
				_computeClippingPlane(e$1) {
					const i$1 = this.pitchInRadians, a$1 = this.cameraToCenterDistance / e$1, o$1 = Math.sin(i$1) * a$1, r$1 = Math.cos(i$1) * a$1 + 1, s$1 = 1 / Math.sqrt(o$1 * o$1 + r$1 * r$1) * 1;
					let n$1 = -o$1, l$1 = r$1;
					const c$1 = Math.sqrt(n$1 * n$1 + l$1 * l$1);
					n$1 /= c$1, l$1 /= c$1;
					const h$1 = [
						0,
						n$1,
						l$1
					];
					t.bG(h$1, h$1, [
						0,
						0,
						0
					], -this.bearingInRadians), t.bH(h$1, h$1, [
						0,
						0,
						0
					], -1 * this.center.lat * Math.PI / 180), t.bI(h$1, h$1, [
						0,
						0,
						0
					], this.center.lng * Math.PI / 180);
					const u$1 = 1 / t.b7(h$1);
					return t.a$(h$1, h$1, u$1), [...h$1, -s$1 * u$1];
				}
				isLocationOccluded(e$1) {
					return !this.isSurfacePointVisible(mi(e$1));
				}
				transformLightDirection(e$1) {
					const i$1 = this._helper._center.lng * Math.PI / 180, a$1 = this._helper._center.lat * Math.PI / 180, o$1 = Math.cos(a$1), r$1 = [
						Math.sin(i$1) * o$1,
						Math.sin(a$1),
						Math.cos(i$1) * o$1
					], s$1 = [
						r$1[2],
						0,
						-r$1[0]
					], n$1 = [
						0,
						0,
						0
					];
					t.b4(n$1, s$1, r$1), t.b3(s$1, s$1), t.b3(n$1, n$1);
					const l$1 = [
						0,
						0,
						0
					];
					return t.b3(l$1, [
						s$1[0] * e$1[0] + n$1[0] * e$1[1] + r$1[0] * e$1[2],
						s$1[1] * e$1[0] + n$1[1] * e$1[1] + r$1[1] * e$1[2],
						s$1[2] * e$1[0] + n$1[2] * e$1[1] + r$1[2] * e$1[2]
					]), l$1;
				}
				getPixelScale() {
					return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
				}
				getCircleRadiusCorrection() {
					return Math.cos(this._helper._center.lat * Math.PI / 180);
				}
				getPitchedTextCorrection(e$1, i$1, a$1) {
					const o$1 = function(e$2, i$2, a$2) {
						const o$2 = 1 / (1 << a$2.z);
						return new t.a9(e$2 / t.a5 * o$2 + a$2.x * o$2, i$2 / t.a5 * o$2 + a$2.y * o$2);
					}(e$1, i$1, a$1.canonical), r$1 = (s$1 = o$1.y, [t.bz(o$1.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - s$1 * Math.PI * 2)) - .5 * Math.PI]);
					var s$1;
					return this.getCircleRadiusCorrection() / Math.cos(r$1[1]);
				}
				projectTileCoordinates(e$1, i$1, a$1, o$1) {
					const r$1 = a$1.canonical, s$1 = pi(e$1, i$1, r$1.x, r$1.y, r$1.z), n$1 = 1 + (o$1 ? o$1(e$1, i$1) : 0) / t.bE, l$1 = [
						s$1[0] * n$1,
						s$1[1] * n$1,
						s$1[2] * n$1,
						1
					];
					t.aH(l$1, l$1, this._globeViewProjMatrixNoCorrection);
					const c$1 = this._cachedClippingPlane, h$1 = c$1[0] * s$1[0] + c$1[1] * s$1[1] + c$1[2] * s$1[2] + c$1[3] < 0;
					return {
						point: new t.P(l$1[0] / l$1[3], l$1[1] / l$1[3]),
						signedDistanceFromCamera: l$1[3],
						isOccluded: h$1
					};
				}
				_calcMatrices() {
					if (!this._helper._width || !this._helper._height) return;
					const e$1 = fi(this.worldSize, this.center.lat), i$1 = t.bk(), a$1 = t.bk();
					this._helper.autoCalculateNearFarZ && (this._helper._nearZ = .5, this._helper._farZ = this.cameraToCenterDistance + 2 * e$1), t.be(i$1, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
					const o$1 = this.centerOffset;
					i$1[8] = 2 * -o$1.x / this._helper._width, i$1[9] = 2 * o$1.y / this._helper._height, this._projectionMatrix = t.bf(i$1), this._globeProjMatrixInverted = t.bk(), t.aB(this._globeProjMatrixInverted, i$1), t.O(i$1, i$1, [
						0,
						0,
						-this.cameraToCenterDistance
					]), t.bg(i$1, i$1, this.rollInRadians), t.bh(i$1, i$1, -this.pitchInRadians), t.bg(i$1, i$1, this.bearingInRadians), t.O(i$1, i$1, [
						0,
						0,
						-e$1
					]);
					const r$1 = t.bA();
					r$1[0] = e$1, r$1[1] = e$1, r$1[2] = e$1, t.bh(a$1, i$1, this.center.lat * Math.PI / 180), t.bJ(a$1, a$1, -this.center.lng * Math.PI / 180), t.Q(a$1, a$1, r$1), this._globeViewProjMatrixNoCorrection = a$1, t.bh(i$1, i$1, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), t.bJ(i$1, i$1, -this.center.lng * Math.PI / 180), t.Q(i$1, i$1, r$1), this._globeViewProjMatrix32f = new Float32Array(i$1), this._globeViewProjMatrixNoCorrectionInverted = t.bk(), t.aB(this._globeViewProjMatrixNoCorrectionInverted, a$1);
					const s$1 = t.bA();
					this._cameraPosition = t.bA(), this._cameraPosition[2] = this.cameraToCenterDistance / e$1, t.bG(this._cameraPosition, this._cameraPosition, s$1, -this.rollInRadians), t.bH(this._cameraPosition, this._cameraPosition, s$1, this.pitchInRadians), t.bG(this._cameraPosition, this._cameraPosition, s$1, -this.bearingInRadians), t.b0(this._cameraPosition, this._cameraPosition, [
						0,
						0,
						1
					]), t.bH(this._cameraPosition, this._cameraPosition, s$1, -this.center.lat * Math.PI / 180), t.bI(this._cameraPosition, this._cameraPosition, s$1, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e$1);
					const n$1 = t.bf(this._globeViewProjMatrixNoCorrectionInverted);
					t.Q(n$1, n$1, [
						1,
						1,
						-1
					]), this._cachedFrustum = Wt.fromInvProjectionMatrix(n$1, 1, 0, this._cachedClippingPlane, !0);
				}
				calculateFogMatrix(e$1) {
					t.w("calculateFogMatrix is not supported on globe projection.");
					const i$1 = t.bk();
					return t.ar(i$1), i$1;
				}
				getVisibleUnwrappedCoordinates(e$1) {
					return [new t.bc(0, e$1)];
				}
				getCameraFrustum() {
					return this._cachedFrustum;
				}
				getClippingPlane() {
					return this._cachedClippingPlane;
				}
				getCoveringTilesDetailsProvider() {
					return this._coveringTilesDetailsProvider;
				}
				recalculateZoomAndCenter(e$1) {
					e$1 && t.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
				}
				maxPitchScaleFactor() {
					return 1;
				}
				getCameraPoint() {
					return this._helper.getCameraPoint();
				}
				getCameraAltitude() {
					return this._helper.getCameraAltitude();
				}
				getCameraLngLat() {
					return this._helper.getCameraLngLat();
				}
				lngLatToCameraDepth(e$1, i$1) {
					if (!this._globeViewProjMatrixNoCorrection) return 1;
					const a$1 = mi(e$1);
					t.a$(a$1, a$1, 1 + i$1 / t.bE);
					const o$1 = t.bF();
					return t.aH(o$1, [
						a$1[0],
						a$1[1],
						a$1[2],
						1
					], this._globeViewProjMatrixNoCorrection), o$1[2] / o$1[3];
				}
				populateCache(e$1) {}
				getBounds() {
					const e$1 = .5 * this.width, i$1 = .5 * this.height, a$1 = [
						new t.P(0, 0),
						new t.P(e$1, 0),
						new t.P(this.width, 0),
						new t.P(this.width, i$1),
						new t.P(this.width, this.height),
						new t.P(e$1, this.height),
						new t.P(0, this.height),
						new t.P(0, i$1)
					], o$1 = [];
					for (const e$2 of a$1) o$1.push(this.unprojectScreenPoint(e$2));
					let r$1 = 0, s$1 = 0, n$1 = 0, l$1 = 0;
					const c$1 = this.center;
					for (const e$2 of o$1) {
						const i$2 = t.bK(c$1.lng, e$2.lng), a$2 = t.bK(c$1.lat, e$2.lat);
						i$2 < s$1 && (s$1 = i$2), i$2 > r$1 && (r$1 = i$2), a$2 < l$1 && (l$1 = a$2), a$2 > n$1 && (n$1 = a$2);
					}
					const h$1 = [
						c$1.lng + s$1,
						c$1.lat + l$1,
						c$1.lng + r$1,
						c$1.lat + n$1
					];
					return this.isSurfacePointOnScreen([
						0,
						1,
						0
					]) && (h$1[3] = 90, h$1[0] = -180, h$1[2] = 180), this.isSurfacePointOnScreen([
						0,
						-1,
						0
					]) && (h$1[1] = -90, h$1[0] = -180, h$1[2] = 180), new $(h$1);
				}
				calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, a$1) {
					return this._helper.calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, a$1);
				}
				setLocationAtPoint(e$1, i$1) {
					const a$1 = mi(this.unprojectScreenPoint(i$1)), o$1 = mi(e$1), r$1 = t.bA();
					t.bL(r$1);
					const s$1 = t.bA();
					t.bI(s$1, a$1, r$1, -this.center.lng * Math.PI / 180), t.bH(s$1, s$1, r$1, this.center.lat * Math.PI / 180);
					const n$1 = o$1[0] * o$1[0] + o$1[2] * o$1[2], l$1 = s$1[0] * s$1[0];
					if (n$1 < l$1) return;
					const c$1 = Math.sqrt(n$1 - l$1), h$1 = -c$1, u$1 = t.bM(o$1[0], o$1[2], s$1[0], c$1), d$1 = t.bM(o$1[0], o$1[2], s$1[0], h$1), _$1 = t.bA();
					t.bI(_$1, o$1, r$1, -u$1);
					const p$1 = t.bM(_$1[1], _$1[2], s$1[1], s$1[2]), m$1 = t.bA();
					t.bI(m$1, o$1, r$1, -d$1);
					const f$1 = t.bM(m$1[1], m$1[2], s$1[1], s$1[2]), g$1 = .5 * Math.PI, v$1 = p$1 >= -g$1 && p$1 <= g$1, x$1 = f$1 >= -g$1 && f$1 <= g$1;
					let b$1, y$1;
					if (v$1 && x$1) {
						const e$2 = this.center.lng * Math.PI / 180, i$2 = this.center.lat * Math.PI / 180;
						t.bN(u$1, e$2) + t.bN(p$1, i$2) < t.bN(d$1, e$2) + t.bN(f$1, i$2) ? (b$1 = u$1, y$1 = p$1) : (b$1 = d$1, y$1 = f$1);
					} else if (v$1) b$1 = u$1, y$1 = p$1;
					else {
						if (!x$1) return;
						b$1 = d$1, y$1 = f$1;
					}
					const w$1 = b$1 / Math.PI * 180, T$1 = y$1 / Math.PI * 180, P$1 = this.center.lat;
					this.setCenter(new t.V(w$1, t.an(T$1, -90, 90))), this.setZoom(this.zoom + xi(P$1, this.center.lat));
				}
				locationToScreenPoint(e$1, i$1) {
					const a$1 = mi(e$1);
					if (i$1) {
						const o$1 = i$1.getElevationForLngLatZoom(e$1, this._helper._tileZoom);
						t.a$(a$1, a$1, 1 + o$1 / t.bE);
					}
					return this._projectSurfacePointToScreen(a$1);
				}
				_projectSurfacePointToScreen(e$1) {
					const i$1 = t.bF();
					return t.aH(i$1, [...e$1, 1], this._globeViewProjMatrixNoCorrection), i$1[0] /= i$1[3], i$1[1] /= i$1[3], new t.P((.5 * i$1[0] + .5) * this.width, (.5 * -i$1[1] + .5) * this.height);
				}
				screenPointToMercatorCoordinate(e$1, i$1) {
					if (i$1) {
						const t$1 = i$1.pointCoordinate(e$1);
						if (t$1) return t$1;
					}
					return t.a9.fromLngLat(this.unprojectScreenPoint(e$1));
				}
				screenPointToLocation(e$1, t$1) {
					var i$1;
					return null === (i$1 = this.screenPointToMercatorCoordinate(e$1, t$1)) || void 0 === i$1 ? void 0 : i$1.toLngLat();
				}
				isPointOnMapSurface(e$1, t$1) {
					const i$1 = this._cameraPosition, a$1 = this.getRayDirectionFromPixel(e$1);
					return !!this.rayPlanetIntersection(i$1, a$1);
				}
				getRayDirectionFromPixel(e$1) {
					const i$1 = t.bF();
					i$1[0] = e$1.x / this.width * 2 - 1, i$1[1] = -1 * (e$1.y / this.height * 2 - 1), i$1[2] = 1, i$1[3] = 1, t.aH(i$1, i$1, this._globeViewProjMatrixNoCorrectionInverted), i$1[0] /= i$1[3], i$1[1] /= i$1[3], i$1[2] /= i$1[3];
					const a$1 = t.bA();
					a$1[0] = i$1[0] - this._cameraPosition[0], a$1[1] = i$1[1] - this._cameraPosition[1], a$1[2] = i$1[2] - this._cameraPosition[2];
					const o$1 = t.bA();
					return t.b3(o$1, a$1), o$1;
				}
				isSurfacePointVisible(e$1) {
					const t$1 = this._cachedClippingPlane;
					return t$1[0] * e$1[0] + t$1[1] * e$1[1] + t$1[2] * e$1[2] + t$1[3] >= 0;
				}
				isSurfacePointOnScreen(e$1) {
					if (!this.isSurfacePointVisible(e$1)) return !1;
					const i$1 = t.bF();
					return t.aH(i$1, [...e$1, 1], this._globeViewProjMatrixNoCorrection), i$1[0] /= i$1[3], i$1[1] /= i$1[3], i$1[2] /= i$1[3], i$1[0] > -1 && i$1[0] < 1 && i$1[1] > -1 && i$1[1] < 1 && i$1[2] > -1 && i$1[2] < 1;
				}
				rayPlanetIntersection(e$1, i$1) {
					const a$1 = t.b5(e$1, i$1), o$1 = t.bA(), r$1 = t.bA();
					t.a$(r$1, i$1, a$1), t.b2(o$1, e$1, r$1);
					const s$1 = 1 - t.b5(o$1, o$1);
					if (s$1 < 0) return null;
					const n$1 = t.b5(e$1, e$1) - 1, l$1 = -a$1 + (a$1 < 0 ? 1 : -1) * Math.sqrt(s$1), c$1 = n$1 / l$1, h$1 = l$1;
					return {
						tMin: Math.min(c$1, h$1),
						tMax: Math.max(c$1, h$1)
					};
				}
				unprojectScreenPoint(e$1) {
					const i$1 = this._cameraPosition, a$1 = this.getRayDirectionFromPixel(e$1), o$1 = this.rayPlanetIntersection(i$1, a$1);
					if (o$1) {
						const e$2 = t.bA();
						t.b0(e$2, i$1, [
							a$1[0] * o$1.tMin,
							a$1[1] * o$1.tMin,
							a$1[2] * o$1.tMin
						]);
						const r$2 = t.bA();
						return t.b3(r$2, e$2), gi(r$2);
					}
					const r$1 = this._cachedClippingPlane, s$1 = r$1[0] * a$1[0] + r$1[1] * a$1[1] + r$1[2] * a$1[2], n$1 = -t.bb(r$1, i$1) / s$1, l$1 = t.bA();
					if (n$1 > 0) t.b0(l$1, i$1, [
						a$1[0] * n$1,
						a$1[1] * n$1,
						a$1[2] * n$1
					]);
					else {
						const e$2 = t.bA();
						t.b0(e$2, i$1, [
							2 * a$1[0],
							2 * a$1[1],
							2 * a$1[2]
						]);
						const o$2 = t.bb(this._cachedClippingPlane, e$2);
						t.b2(l$1, e$2, [
							this._cachedClippingPlane[0] * o$2,
							this._cachedClippingPlane[1] * o$2,
							this._cachedClippingPlane[2] * o$2
						]);
					}
					const c$1 = function(e$2) {
						const i$2 = t.bA();
						return i$2[0] = e$2[0] * -e$2[3], i$2[1] = e$2[1] * -e$2[3], i$2[2] = e$2[2] * -e$2[3], {
							center: i$2,
							radius: Math.sqrt(1 - e$2[3] * e$2[3])
						};
					}(r$1);
					return gi(function(e$2, i$2, a$2) {
						const o$2 = t.bA();
						t.b2(o$2, a$2, e$2);
						const r$2 = t.bA();
						return t.by(r$2, e$2, o$2, i$2 / t.b9(o$2)), r$2;
					}(c$1.center, c$1.radius, l$1));
				}
				getMatrixForModel(e$1, i$1) {
					const a$1 = t.V.convert(e$1), o$1 = 1 / t.bE, r$1 = t.bj();
					return t.bJ(r$1, r$1, a$1.lng / 180 * Math.PI), t.bh(r$1, r$1, -a$1.lat / 180 * Math.PI), t.O(r$1, r$1, [
						0,
						0,
						1 + i$1 / t.bE
					]), t.bh(r$1, r$1, .5 * Math.PI), t.Q(r$1, r$1, [
						o$1,
						o$1,
						o$1
					]), r$1;
				}
				getProjectionDataForCustomLayer(e$1 = !0) {
					const i$1 = this.getProjectionData({
						overscaledTileID: new t.a2(0, 0, 0, 0, 0),
						applyGlobeMatrix: e$1
					});
					return i$1.tileMercatorCoords = [
						0,
						0,
						1,
						1
					], i$1;
				}
				getFastPathSimpleProjectionMatrix(e$1) {}
			}
			class zi {
				get pixelsToClipSpaceMatrix() {
					return this._helper.pixelsToClipSpaceMatrix;
				}
				get clipSpaceToPixelsMatrix() {
					return this._helper.clipSpaceToPixelsMatrix;
				}
				get pixelsToGLUnits() {
					return this._helper.pixelsToGLUnits;
				}
				get centerOffset() {
					return this._helper.centerOffset;
				}
				get size() {
					return this._helper.size;
				}
				get rotationMatrix() {
					return this._helper.rotationMatrix;
				}
				get centerPoint() {
					return this._helper.centerPoint;
				}
				get pixelsPerMeter() {
					return this._helper.pixelsPerMeter;
				}
				setMinZoom(e$1) {
					this._helper.setMinZoom(e$1);
				}
				setMaxZoom(e$1) {
					this._helper.setMaxZoom(e$1);
				}
				setMinPitch(e$1) {
					this._helper.setMinPitch(e$1);
				}
				setMaxPitch(e$1) {
					this._helper.setMaxPitch(e$1);
				}
				setRenderWorldCopies(e$1) {
					this._helper.setRenderWorldCopies(e$1);
				}
				setBearing(e$1) {
					this._helper.setBearing(e$1);
				}
				setPitch(e$1) {
					this._helper.setPitch(e$1);
				}
				setRoll(e$1) {
					this._helper.setRoll(e$1);
				}
				setFov(e$1) {
					this._helper.setFov(e$1);
				}
				setZoom(e$1) {
					this._helper.setZoom(e$1);
				}
				setCenter(e$1) {
					this._helper.setCenter(e$1);
				}
				setElevation(e$1) {
					this._helper.setElevation(e$1);
				}
				setMinElevationForCurrentTile(e$1) {
					this._helper.setMinElevationForCurrentTile(e$1);
				}
				setPadding(e$1) {
					this._helper.setPadding(e$1);
				}
				interpolatePadding(e$1, t$1, i$1) {
					return this._helper.interpolatePadding(e$1, t$1, i$1);
				}
				isPaddingEqual(e$1) {
					return this._helper.isPaddingEqual(e$1);
				}
				resize(e$1, t$1, i$1 = !0) {
					this._helper.resize(e$1, t$1, i$1);
				}
				getMaxBounds() {
					return this._helper.getMaxBounds();
				}
				setMaxBounds(e$1) {
					this._helper.setMaxBounds(e$1);
				}
				setConstrainOverride(e$1) {
					this._helper.setConstrainOverride(e$1);
				}
				overrideNearFarZ(e$1, t$1) {
					this._helper.overrideNearFarZ(e$1, t$1);
				}
				clearNearFarZOverride() {
					this._helper.clearNearFarZOverride();
				}
				getCameraQueryGeometry(e$1) {
					return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e$1);
				}
				get tileSize() {
					return this._helper.tileSize;
				}
				get tileZoom() {
					return this._helper.tileZoom;
				}
				get scale() {
					return this._helper.scale;
				}
				get worldSize() {
					return this._helper.worldSize;
				}
				get width() {
					return this._helper.width;
				}
				get height() {
					return this._helper.height;
				}
				get lngRange() {
					return this._helper.lngRange;
				}
				get latRange() {
					return this._helper.latRange;
				}
				get minZoom() {
					return this._helper.minZoom;
				}
				get maxZoom() {
					return this._helper.maxZoom;
				}
				get zoom() {
					return this._helper.zoom;
				}
				get center() {
					return this._helper.center;
				}
				get minPitch() {
					return this._helper.minPitch;
				}
				get maxPitch() {
					return this._helper.maxPitch;
				}
				get pitch() {
					return this._helper.pitch;
				}
				get pitchInRadians() {
					return this._helper.pitchInRadians;
				}
				get roll() {
					return this._helper.roll;
				}
				get rollInRadians() {
					return this._helper.rollInRadians;
				}
				get bearing() {
					return this._helper.bearing;
				}
				get bearingInRadians() {
					return this._helper.bearingInRadians;
				}
				get fov() {
					return this._helper.fov;
				}
				get fovInRadians() {
					return this._helper.fovInRadians;
				}
				get elevation() {
					return this._helper.elevation;
				}
				get minElevationForCurrentTile() {
					return this._helper.minElevationForCurrentTile;
				}
				get padding() {
					return this._helper.padding;
				}
				get unmodified() {
					return this._helper.unmodified;
				}
				get renderWorldCopies() {
					return this._helper.renderWorldCopies;
				}
				get cameraToCenterDistance() {
					return this._helper.cameraToCenterDistance;
				}
				get constrainOverride() {
					return this._helper.constrainOverride;
				}
				get nearZ() {
					return this._helper.nearZ;
				}
				get farZ() {
					return this._helper.farZ;
				}
				get autoCalculateNearFarZ() {
					return this._helper.autoCalculateNearFarZ;
				}
				get isGlobeRendering() {
					return this._globeness > 0;
				}
				setTransitionState(e$1, t$1) {
					this._globeness = e$1, this._globeLatitudeErrorCorrectionRadians = t$1, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame();
				}
				get currentTransform() {
					return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
				}
				constructor(e$1) {
					this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this.defaultConstrain = (e$2, t$1) => this.currentTransform.defaultConstrain(e$2, t$1), this.applyConstrain = (e$2, t$1) => this._helper.applyConstrain(e$2, t$1), this._helper = new Gt({
						calcMatrices: () => {
							this._calcMatrices();
						},
						defaultConstrain: (e$2, t$1) => this.defaultConstrain(e$2, t$1)
					}, e$1), this._globeness = 1, this._mercatorTransform = new $t(), this._verticalPerspectiveTransform = new Si();
				}
				clone() {
					const e$1 = new zi();
					return e$1._globeness = this._globeness, e$1._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e$1.apply(this, !1), e$1;
				}
				apply(e$1, t$1) {
					this._helper.apply(e$1, t$1), this._mercatorTransform.apply(this, !1), this._verticalPerspectiveTransform.apply(this, !1, this._globeLatitudeErrorCorrectionRadians);
				}
				get projectionMatrix() {
					return this.currentTransform.projectionMatrix;
				}
				get modelViewProjectionMatrix() {
					return this.currentTransform.modelViewProjectionMatrix;
				}
				get inverseProjectionMatrix() {
					return this.currentTransform.inverseProjectionMatrix;
				}
				get cameraPosition() {
					return this.currentTransform.cameraPosition;
				}
				getProjectionData(e$1) {
					const t$1 = this._mercatorTransform.getProjectionData(e$1), i$1 = this._verticalPerspectiveTransform.getProjectionData(e$1);
					return {
						mainMatrix: this.isGlobeRendering ? i$1.mainMatrix : t$1.mainMatrix,
						clippingPlane: i$1.clippingPlane,
						tileMercatorCoords: i$1.tileMercatorCoords,
						projectionTransition: e$1.applyGlobeMatrix ? this._globeness : 0,
						fallbackMatrix: t$1.fallbackMatrix
					};
				}
				isLocationOccluded(e$1) {
					return this.currentTransform.isLocationOccluded(e$1);
				}
				transformLightDirection(e$1) {
					return this.currentTransform.transformLightDirection(e$1);
				}
				getPixelScale() {
					return t.bu(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
				}
				getCircleRadiusCorrection() {
					return t.bu(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
				}
				getPitchedTextCorrection(e$1, i$1, a$1) {
					const o$1 = this._mercatorTransform.getPitchedTextCorrection(e$1, i$1, a$1), r$1 = this._verticalPerspectiveTransform.getPitchedTextCorrection(e$1, i$1, a$1);
					return t.bu(o$1, r$1, this._globeness);
				}
				projectTileCoordinates(e$1, t$1, i$1, a$1) {
					return this.currentTransform.projectTileCoordinates(e$1, t$1, i$1, a$1);
				}
				_calcMatrices() {
					this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, !1, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
				}
				calculateFogMatrix(e$1) {
					return this.currentTransform.calculateFogMatrix(e$1);
				}
				getVisibleUnwrappedCoordinates(e$1) {
					return this.currentTransform.getVisibleUnwrappedCoordinates(e$1);
				}
				getCameraFrustum() {
					return this.currentTransform.getCameraFrustum();
				}
				getClippingPlane() {
					return this.currentTransform.getClippingPlane();
				}
				getCoveringTilesDetailsProvider() {
					return this.currentTransform.getCoveringTilesDetailsProvider();
				}
				recalculateZoomAndCenter(e$1) {
					this._mercatorTransform.recalculateZoomAndCenter(e$1), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e$1);
				}
				maxPitchScaleFactor() {
					return this._mercatorTransform.maxPitchScaleFactor();
				}
				getCameraPoint() {
					return this._helper.getCameraPoint();
				}
				getCameraAltitude() {
					return this._helper.getCameraAltitude();
				}
				getCameraLngLat() {
					return this._helper.getCameraLngLat();
				}
				lngLatToCameraDepth(e$1, t$1) {
					return this.currentTransform.lngLatToCameraDepth(e$1, t$1);
				}
				populateCache(e$1) {
					this._mercatorTransform.populateCache(e$1), this._verticalPerspectiveTransform.populateCache(e$1);
				}
				getBounds() {
					return this.currentTransform.getBounds();
				}
				calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, a$1) {
					return this._helper.calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, a$1);
				}
				setLocationAtPoint(e$1, t$1) {
					if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e$1, t$1), void this.apply(this._mercatorTransform, !1);
					this._verticalPerspectiveTransform.setLocationAtPoint(e$1, t$1), this.apply(this._verticalPerspectiveTransform, !1);
				}
				locationToScreenPoint(e$1, t$1) {
					return this.currentTransform.locationToScreenPoint(e$1, t$1);
				}
				screenPointToMercatorCoordinate(e$1, t$1) {
					return this.currentTransform.screenPointToMercatorCoordinate(e$1, t$1);
				}
				screenPointToLocation(e$1, t$1) {
					return this.currentTransform.screenPointToLocation(e$1, t$1);
				}
				isPointOnMapSurface(e$1, t$1) {
					return this.currentTransform.isPointOnMapSurface(e$1, t$1);
				}
				getRayDirectionFromPixel(e$1) {
					return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e$1);
				}
				getMatrixForModel(e$1, t$1) {
					return this.currentTransform.getMatrixForModel(e$1, t$1);
				}
				getProjectionDataForCustomLayer(e$1 = !0) {
					const t$1 = this._mercatorTransform.getProjectionDataForCustomLayer(e$1);
					if (!this.isGlobeRendering) return t$1;
					const i$1 = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e$1);
					return i$1.fallbackMatrix = t$1.mainMatrix, i$1;
				}
				getFastPathSimpleProjectionMatrix(e$1) {
					return this.currentTransform.getFastPathSimpleProjectionMatrix(e$1);
				}
			}
			class Ri {
				get useGlobeControls() {
					return !0;
				}
				handlePanInertia(e$1, i$1) {
					const a$1 = bi(e$1, i$1);
					return Math.abs(a$1.lng - i$1.center.lng) > 180 && (a$1.lng = i$1.center.lng + 179.5 * Math.sign(a$1.lng - i$1.center.lng)), {
						easingCenter: a$1,
						easingOffset: new t.P(0, 0)
					};
				}
				handleMapControlsRollPitchBearingZoom(e$1, i$1) {
					const a$1 = e$1.around, o$1 = i$1.screenPointToLocation(a$1);
					e$1.bearingDelta && i$1.setBearing(i$1.bearing + e$1.bearingDelta), e$1.pitchDelta && i$1.setPitch(i$1.pitch + e$1.pitchDelta), e$1.rollDelta && i$1.setRoll(i$1.roll + e$1.rollDelta);
					const r$1 = i$1.zoom;
					e$1.zoomDelta && i$1.setZoom(i$1.zoom + e$1.zoomDelta);
					const s$1 = i$1.zoom - r$1;
					if (0 === s$1) return;
					const n$1 = t.bK(i$1.center.lng, o$1.lng), l$1 = n$1 / (Math.abs(n$1 / 180) + 1), c$1 = t.bK(i$1.center.lat, o$1.lat), h$1 = i$1.getRayDirectionFromPixel(a$1), u$1 = i$1.cameraPosition, d$1 = -1 * t.b5(u$1, h$1), _$1 = t.bA();
					t.b0(_$1, u$1, [
						h$1[0] * d$1,
						h$1[1] * d$1,
						h$1[2] * d$1
					]);
					const p$1 = t.b7(_$1) - 1, m$1 = Math.exp(.5 * -Math.max(p$1 - .3, 0)), f$1 = fi(i$1.worldSize, i$1.center.lat) / Math.min(i$1.width, i$1.height), g$1 = t.bx(f$1, .9, .5, 1, .25), v$1 = (1 - t.aq(-s$1)) * Math.min(m$1, g$1), x$1 = i$1.center.lat, b$1 = i$1.zoom, y$1 = new t.V(i$1.center.lng + l$1 * v$1, t.an(i$1.center.lat + c$1 * v$1, -t.ao, t.ao));
					i$1.setLocationAtPoint(o$1, a$1);
					const w$1 = i$1.center, T$1 = t.bx(Math.abs(n$1), 45, 85, 0, 1), P$1 = t.bx(f$1, .75, .35, 0, 1), C$1 = Math.pow(Math.max(T$1, P$1), .25), I$1 = t.bK(w$1.lng, y$1.lng), M$1 = t.bK(w$1.lat, y$1.lat);
					i$1.setCenter(new t.V(w$1.lng + I$1 * C$1, w$1.lat + M$1 * C$1).wrap()), i$1.setZoom(b$1 + xi(x$1, i$1.center.lat));
				}
				handleMapControlsPan(e$1, t$1, i$1) {
					if (!e$1.panDelta) return;
					const a$1 = t$1.center.lat, o$1 = t$1.zoom;
					t$1.setCenter(bi(e$1.panDelta, t$1).wrap()), t$1.setZoom(o$1 + xi(a$1, t$1.center.lat));
				}
				cameraForBoxAndBearing(e$1, i$1, a$1, o$1, r$1) {
					const s$1 = Kt(e$1, i$1, a$1, o$1, r$1), n$1 = i$1.left / r$1.width * 2 - 1, l$1 = (r$1.width - i$1.right) / r$1.width * 2 - 1, c$1 = i$1.top / r$1.height * -2 + 1, h$1 = (r$1.height - i$1.bottom) / r$1.height * -2 + 1, u$1 = t.bK(a$1.getWest(), a$1.getEast()) < 0, d$1 = u$1 ? a$1.getEast() : a$1.getWest(), _$1 = u$1 ? a$1.getWest() : a$1.getEast(), p$1 = Math.max(a$1.getNorth(), a$1.getSouth()), m$1 = Math.min(a$1.getNorth(), a$1.getSouth()), f$1 = d$1 + .5 * t.bK(d$1, _$1), g$1 = p$1 + .5 * t.bK(p$1, m$1), v$1 = r$1.clone();
					v$1.setCenter(s$1.center), v$1.setBearing(s$1.bearing), v$1.setPitch(0), v$1.setRoll(0), v$1.setZoom(s$1.zoom);
					const x$1 = v$1.modelViewProjectionMatrix, b$1 = [
						mi(a$1.getNorthWest()),
						mi(a$1.getNorthEast()),
						mi(a$1.getSouthWest()),
						mi(a$1.getSouthEast()),
						mi(new t.V(_$1, g$1)),
						mi(new t.V(d$1, g$1)),
						mi(new t.V(f$1, p$1)),
						mi(new t.V(f$1, m$1))
					], y$1 = mi(s$1.center);
					let w$1 = Number.POSITIVE_INFINITY;
					for (const e$2 of b$1) n$1 < 0 && (w$1 = Ri.getLesserNonNegativeNonNull(w$1, Ri.solveVectorScale(e$2, y$1, x$1, "x", n$1))), l$1 > 0 && (w$1 = Ri.getLesserNonNegativeNonNull(w$1, Ri.solveVectorScale(e$2, y$1, x$1, "x", l$1))), c$1 > 0 && (w$1 = Ri.getLesserNonNegativeNonNull(w$1, Ri.solveVectorScale(e$2, y$1, x$1, "y", c$1))), h$1 < 0 && (w$1 = Ri.getLesserNonNegativeNonNull(w$1, Ri.solveVectorScale(e$2, y$1, x$1, "y", h$1)));
					if (Number.isFinite(w$1) && 0 !== w$1) return s$1.zoom = v$1.zoom + t.at(w$1), s$1;
					Ht();
				}
				handleJumpToCenterZoom(e$1, i$1) {
					const a$1 = e$1.center.lat, o$1 = e$1.applyConstrain(i$1.center ? t.V.convert(i$1.center) : e$1.center, e$1.zoom).center;
					e$1.setCenter(o$1.wrap());
					const r$1 = void 0 !== i$1.zoom ? +i$1.zoom : e$1.zoom + xi(a$1, o$1.lat);
					e$1.zoom !== r$1 && e$1.setZoom(r$1);
				}
				handleEaseTo(e$1, i$1) {
					const a$1 = e$1.zoom, o$1 = e$1.center, r$1 = e$1.padding, s$1 = {
						roll: e$1.roll,
						pitch: e$1.pitch,
						bearing: e$1.bearing
					}, n$1 = {
						roll: void 0 === i$1.roll ? e$1.roll : i$1.roll,
						pitch: void 0 === i$1.pitch ? e$1.pitch : i$1.pitch,
						bearing: void 0 === i$1.bearing ? e$1.bearing : i$1.bearing
					}, l$1 = void 0 !== i$1.zoom, c$1 = !e$1.isPaddingEqual(i$1.padding);
					let h$1 = !1;
					const u$1 = i$1.center ? t.V.convert(i$1.center) : o$1, d$1 = e$1.applyConstrain(u$1, a$1).center;
					Zt(e$1, d$1);
					const _$1 = e$1.clone();
					_$1.setCenter(d$1), _$1.setZoom(l$1 ? +i$1.zoom : a$1 + xi(o$1.lat, u$1.lat)), _$1.setBearing(i$1.bearing);
					const p$1 = new t.P(t.an(e$1.centerPoint.x + i$1.offsetAsPoint.x, 0, e$1.width), t.an(e$1.centerPoint.y + i$1.offsetAsPoint.y, 0, e$1.height));
					_$1.setLocationAtPoint(d$1, p$1);
					const m$1 = (i$1.offset && i$1.offsetAsPoint.mag()) > 0 ? _$1.center : d$1, f$1 = l$1 ? +i$1.zoom : a$1 + xi(o$1.lat, m$1.lat), g$1 = a$1 + xi(o$1.lat, 0), v$1 = f$1 + xi(m$1.lat, 0), x$1 = t.bK(o$1.lng, m$1.lng), b$1 = t.bK(o$1.lat, m$1.lat), y$1 = t.aq(v$1 - g$1);
					return h$1 = f$1 !== a$1, {
						easeFunc: (a$2) => {
							if (t.bo(s$1, n$1) || Xt({
								startEulerAngles: s$1,
								endEulerAngles: n$1,
								tr: e$1,
								k: a$2,
								useSlerp: s$1.roll != n$1.roll
							}), c$1 && e$1.interpolatePadding(r$1, i$1.padding, a$2), i$1.around) t.w("Easing around a point is not supported under globe projection."), e$1.setLocationAtPoint(i$1.around, i$1.aroundPoint);
							else {
								const t$1 = v$1 > g$1 ? Math.min(2, y$1) : Math.max(.5, y$1), r$2 = wi(o$1, x$1, b$1, a$2 * Math.pow(t$1, 1 - a$2));
								e$1.setCenter(r$2.wrap());
							}
							if (h$1) {
								const i$2 = t.G.number(g$1, v$1, a$2) + xi(0, e$1.center.lat);
								e$1.setZoom(i$2);
							}
						},
						isZooming: h$1,
						elevationCenter: m$1
					};
				}
				handleFlyTo(e$1, i$1) {
					const a$1 = void 0 !== i$1.zoom, o$1 = e$1.center, r$1 = e$1.zoom, s$1 = e$1.padding, n$1 = !e$1.isPaddingEqual(i$1.padding), l$1 = e$1.applyConstrain(t.V.convert(i$1.center || i$1.locationAtOffset), r$1).center, c$1 = a$1 ? +i$1.zoom : e$1.zoom + xi(e$1.center.lat, l$1.lat), h$1 = e$1.clone();
					h$1.setCenter(l$1), h$1.setZoom(c$1), h$1.setBearing(i$1.bearing);
					const u$1 = new t.P(t.an(e$1.centerPoint.x + i$1.offsetAsPoint.x, 0, e$1.width), t.an(e$1.centerPoint.y + i$1.offsetAsPoint.y, 0, e$1.height));
					h$1.setLocationAtPoint(l$1, u$1);
					const d$1 = h$1.center;
					Zt(e$1, d$1);
					const _$1 = function(e$2, i$2, a$2) {
						const o$2 = mi(i$2), r$2 = mi(a$2), s$2 = t.b5(o$2, r$2), n$2 = Math.acos(s$2), l$2 = _i(e$2);
						return n$2 / (2 * Math.PI) * l$2;
					}(e$1, o$1, d$1), p$1 = r$1 + xi(o$1.lat, 0), m$1 = c$1 + xi(d$1.lat, 0), f$1 = t.aq(m$1 - p$1);
					let g$1;
					if ("number" == typeof i$1.minZoom) {
						const a$2 = +i$1.minZoom + xi(d$1.lat, 0), o$2 = Math.min(a$2, p$1, m$1) + xi(0, d$1.lat), r$2 = e$1.applyConstrain(d$1, o$2).zoom + xi(d$1.lat, 0);
						g$1 = t.aq(r$2 - p$1);
					}
					const v$1 = t.bK(o$1.lng, d$1.lng), x$1 = t.bK(o$1.lat, d$1.lat);
					return {
						easeFunc: (a$2, r$2, l$2, h$2) => {
							const u$2 = wi(o$1, v$1, x$1, l$2);
							n$1 && e$1.interpolatePadding(s$1, i$1.padding, a$2);
							const _$2 = 1 === a$2 ? d$1 : u$2;
							e$1.setCenter(_$2.wrap());
							const m$2 = p$1 + t.at(r$2);
							e$1.setZoom(1 === a$2 ? c$1 : m$2 + xi(0, _$2.lat));
						},
						scaleOfZoom: f$1,
						targetCenter: d$1,
						scaleOfMinZoom: g$1,
						pixelPathLength: _$1
					};
				}
				static solveVectorScale(e$1, t$1, i$1, a$1, o$1) {
					const r$1 = "x" === a$1 ? [
						i$1[0],
						i$1[4],
						i$1[8],
						i$1[12]
					] : [
						i$1[1],
						i$1[5],
						i$1[9],
						i$1[13]
					], s$1 = [
						i$1[3],
						i$1[7],
						i$1[11],
						i$1[15]
					], n$1 = e$1[0] * r$1[0] + e$1[1] * r$1[1] + e$1[2] * r$1[2], l$1 = e$1[0] * s$1[0] + e$1[1] * s$1[1] + e$1[2] * s$1[2], c$1 = t$1[0] * r$1[0] + t$1[1] * r$1[1] + t$1[2] * r$1[2], h$1 = t$1[0] * s$1[0] + t$1[1] * s$1[1] + t$1[2] * s$1[2];
					return c$1 + o$1 * l$1 === n$1 + o$1 * h$1 || s$1[3] * (n$1 - c$1) + r$1[3] * (h$1 - l$1) + n$1 * h$1 == c$1 * l$1 ? null : (c$1 + r$1[3] - o$1 * h$1 - o$1 * s$1[3]) / (c$1 - n$1 - o$1 * h$1 + o$1 * l$1);
				}
				static getLesserNonNegativeNonNull(e$1, t$1) {
					return null !== t$1 && t$1 >= 0 && t$1 < e$1 ? t$1 : e$1;
				}
			}
			class Di {
				constructor(e$1) {
					this._globe = e$1, this._mercatorCameraHelper = new Yt(), this._verticalPerspectiveCameraHelper = new Ri();
				}
				get useGlobeControls() {
					return this._globe.useGlobeRendering;
				}
				get currentHelper() {
					return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
				}
				handlePanInertia(e$1, t$1) {
					return this.currentHelper.handlePanInertia(e$1, t$1);
				}
				handleMapControlsRollPitchBearingZoom(e$1, t$1) {
					return this.currentHelper.handleMapControlsRollPitchBearingZoom(e$1, t$1);
				}
				handleMapControlsPan(e$1, t$1, i$1) {
					this.currentHelper.handleMapControlsPan(e$1, t$1, i$1);
				}
				cameraForBoxAndBearing(e$1, t$1, i$1, a$1, o$1) {
					return this.currentHelper.cameraForBoxAndBearing(e$1, t$1, i$1, a$1, o$1);
				}
				handleJumpToCenterZoom(e$1, t$1) {
					this.currentHelper.handleJumpToCenterZoom(e$1, t$1);
				}
				handleEaseTo(e$1, t$1) {
					return this.currentHelper.handleEaseTo(e$1, t$1);
				}
				handleFlyTo(e$1, t$1) {
					return this.currentHelper.handleFlyTo(e$1, t$1);
				}
			}
			const Ai = (e$1, i$1) => t.B(e$1, i$1 && i$1.filter(((e$2) => "source.canvas" !== e$2.identifier))), Li = t.bO();
			class ki extends t.E {
				constructor(e$1, i$1 = {}) {
					var a$1, o$1;
					super(), this._rtlPluginLoaded = () => {
						for (const e$2 in this.tileManagers) {
							const t$1 = this.tileManagers[e$2].getSource().type;
							"vector" !== t$1 && "geojson" !== t$1 || this.tileManagers[e$2].reload();
						}
					}, this.map = e$1, this.dispatcher = new N(j(), e$1._getMapId()), this.dispatcher.registerMessageHandler("GG", ((e$2, t$1) => this.getGlyphs(e$2, t$1))), this.dispatcher.registerMessageHandler("GI", ((e$2, t$1) => this.getImages(e$2, t$1))), this.dispatcher.registerMessageHandler("GDA", ((e$2, t$1) => this.getDashes(e$2, t$1))), this.imageManager = new w(), this.imageManager.setEventedParent(this);
					const r$1 = (null === (a$1 = e$1._container) || void 0 === a$1 ? void 0 : a$1.lang) || "undefined" != typeof document && (null === (o$1 = document.documentElement) || void 0 === o$1 ? void 0 : o$1.lang) || void 0;
					this.glyphManager = new M(e$1._requestManager, i$1.localIdeographFontFamily, r$1), this.lineAtlas = new A(256, 512), this.crossTileSymbolIndex = new Rt(), this._setInitialValues(), this._resetUpdates(), this.dispatcher.broadcast("SR", t.bP()), ce().on(se, this._rtlPluginLoaded), this.on("data", ((e$2) => {
						if ("source" !== e$2.dataType || "metadata" !== e$2.sourceDataType) return;
						const t$1 = this.tileManagers[e$2.sourceId];
						if (!t$1) return;
						const i$2 = t$1.getSource();
						if (i$2 && i$2.vectorLayerIds) for (const e$3 in this._layers) {
							const t$2 = this._layers[e$3];
							t$2.source === i$2.id && this._validateLayer(t$2);
						}
					}));
				}
				_setInitialValues() {
					var e$1;
					this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.tileManagers = {}, this.zoomHistory = new t.bQ(), this._availableImages = [], this._globalState = {}, this._serializedLayers = {}, this.stylesheet = null, this.light = null, this.sky = null, this.projection && (this.projection.destroy(), delete this.projection), this._loaded = !1, this._changed = !1, this._updatedLayers = {}, this._updatedSources = {}, this._changedImages = {}, this._glyphsDidChange = !1, this._updatedPaintProps = {}, this._layerOrderChanged = !1, this.crossTileSymbolIndex = new ((null === (e$1 = this.crossTileSymbolIndex) || void 0 === e$1 ? void 0 : e$1.constructor) || Object)(), this.pauseablePlacement = void 0, this.placement = void 0, this.z = 0;
				}
				setGlobalStateProperty(e$1, i$1) {
					var a$1, o$1, r$1;
					this._checkLoaded();
					const s$1 = null === i$1 ? null !== (r$1 = null === (o$1 = null === (a$1 = this.stylesheet.state) || void 0 === a$1 ? void 0 : a$1[e$1]) || void 0 === o$1 ? void 0 : o$1.default) && void 0 !== r$1 ? r$1 : null : i$1;
					if (t.bR(s$1, this._globalState[e$1])) return this;
					this._globalState[e$1] = s$1, this._applyGlobalStateChanges([e$1]);
				}
				getGlobalState() {
					return this._globalState;
				}
				setGlobalState(e$1) {
					this._checkLoaded();
					const i$1 = [];
					for (const a$1 in e$1) !t.bR(this._globalState[a$1], e$1[a$1].default) && (i$1.push(a$1), this._globalState[a$1] = e$1[a$1].default);
					this._applyGlobalStateChanges(i$1);
				}
				_applyGlobalStateChanges(e$1) {
					if (0 === e$1.length) return;
					const t$1 = /* @__PURE__ */ new Set(), i$1 = {};
					for (const a$1 of e$1) {
						i$1[a$1] = this._globalState[a$1];
						for (const e$2 in this._layers) {
							const i$2 = this._layers[e$2], o$1 = i$2.getLayoutAffectingGlobalStateRefs(), r$1 = i$2.getPaintAffectingGlobalStateRefs(), s$1 = i$2.getVisibilityAffectingGlobalStateRefs();
							if (o$1.has(a$1) && t$1.add(i$2.source), r$1.has(a$1)) for (const { name: e$3, value: t$2 } of r$1.get(a$1)) this._updatePaintProperty(i$2, e$3, t$2);
							null != s$1 && s$1.has(a$1) && (i$2.recalculateVisibility(), this._updateLayer(i$2));
						}
					}
					this.dispatcher.broadcast("UGS", i$1);
					for (const e$2 in this.tileManagers) t$1.has(e$2) && (this._reloadSource(e$2), this._changed = !0);
				}
				loadURL(e$1, i$1 = {}, a$1) {
					this.fire(new t.l("dataloading", { dataType: "style" })), i$1.validate = "boolean" != typeof i$1.validate || i$1.validate;
					const o$1 = this.map._requestManager.transformRequest(e$1, "Style");
					this._loadStyleRequest = new AbortController();
					const r$1 = this._loadStyleRequest;
					t.j(o$1, this._loadStyleRequest).then(((e$2) => {
						this._loadStyleRequest = null, this._load(e$2.data, i$1, a$1);
					})).catch(((e$2) => {
						this._loadStyleRequest = null, e$2 && !r$1.signal.aborted && this.fire(new t.k(e$2));
					}));
				}
				loadJSON(e$1, i$1 = {}, a$1) {
					this.fire(new t.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), n.frameAsync(this._frameRequest, this.map._ownerWindow).then((() => {
						this._frameRequest = null, i$1.validate = !1 !== i$1.validate, this._load(e$1, i$1, a$1);
					})).catch((() => {}));
				}
				loadEmpty() {
					this.fire(new t.l("dataloading", { dataType: "style" })), this._load(Li, { validate: !1 });
				}
				_load(e$1, i$1, a$1) {
					var o$1, r$1;
					let s$1 = i$1.transformStyle ? i$1.transformStyle(a$1, e$1) : e$1;
					if (!i$1.validate || !Ai(this, t.C(s$1))) {
						s$1 = Object.assign({}, s$1), this._loaded = !0, this.stylesheet = s$1;
						for (const e$2 in s$1.sources) this.addSource(e$2, s$1.sources[e$2], { validate: !1 });
						s$1.sprite ? this._loadSprite(s$1.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(s$1.glyphs), this._createLayers(), this.light = new z(this.stylesheet.light), this._setProjectionInternal((null === (o$1 = this.stylesheet.projection) || void 0 === o$1 ? void 0 : o$1.type) || "mercator"), this.sky = new D(this.stylesheet.sky), this.map.setTerrain(null !== (r$1 = this.stylesheet.terrain) && void 0 !== r$1 ? r$1 : null), this.fire(new t.l("data", { dataType: "style" })), this.fire(new t.l("style.load"));
					}
				}
				_createLayers() {
					var e$1, i$1, a$1;
					const o$1 = t.bS(this.stylesheet.layers);
					this.setGlobalState(null !== (e$1 = this.stylesheet.state) && void 0 !== e$1 ? e$1 : null), this.dispatcher.broadcast("SL", o$1), this._order = o$1.map(((e$2) => e$2.id)), this._layers = {}, this._serializedLayers = null;
					for (const e$2 of o$1) {
						const o$2 = t.bT(e$2, this._globalState);
						if (o$2.setEventedParent(this, { layer: { id: e$2.id } }), this._layers[e$2.id] = o$2, t.bU(o$2) && this.tileManagers[o$2.source]) {
							const t$1 = null !== (a$1 = null === (i$1 = e$2.paint) || void 0 === i$1 ? void 0 : i$1["raster-fade-duration"]) && void 0 !== a$1 ? a$1 : o$2.paint.get("raster-fade-duration");
							this.tileManagers[o$2.source].setRasterFadeDuration(t$1);
						}
					}
				}
				_loadSprite(e$1, i$1 = !1, a$1 = void 0) {
					this.imageManager.setLoaded(!1);
					const o$1 = new AbortController();
					let r$1;
					this._spriteRequest = o$1, function(e$2, i$2, a$2, o$2) {
						return t._(this, void 0, void 0, (function* () {
							const r$2 = x(e$2), s$1 = a$2 > 1 ? "@2x" : "", l$1 = {}, c$1 = {};
							for (const { id: e$3, url: a$3 } of r$2) {
								const r$3 = i$2.transformRequest(b(a$3, s$1, ".json"), "SpriteJSON");
								l$1[e$3] = t.j(r$3, o$2);
								const n$1 = i$2.transformRequest(b(a$3, s$1, ".png"), "SpriteImage");
								c$1[e$3] = g.getImage(n$1, o$2);
							}
							return yield Promise.all([...Object.values(l$1), ...Object.values(c$1)]), function(e$3, i$3) {
								return t._(this, void 0, void 0, (function* () {
									const t$1 = {};
									for (const a$3 in e$3) {
										t$1[a$3] = {};
										const o$3 = n.getImageCanvasContext((yield i$3[a$3]).data), r$3 = (yield e$3[a$3]).data;
										for (const e$4 in r$3) {
											const { width: i$4, height: s$2, x: n$1, y: l$2, sdf: c$2, pixelRatio: h$1, stretchX: u$1, stretchY: d$1, content: _$1, textFitWidth: p$1, textFitHeight: m$1 } = r$3[e$4];
											t$1[a$3][e$4] = {
												data: null,
												pixelRatio: h$1,
												sdf: c$2,
												stretchX: u$1,
												stretchY: d$1,
												content: _$1,
												textFitWidth: p$1,
												textFitHeight: m$1,
												spriteData: {
													width: i$4,
													height: s$2,
													x: n$1,
													y: l$2,
													context: o$3
												}
											};
										}
									}
									return t$1;
								}));
							}(l$1, c$1);
						}));
					}(e$1, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then(((e$2) => {
						if (this._spriteRequest = null, e$2) for (const t$1 in e$2) {
							this._spritesImagesIds[t$1] = [];
							const a$2 = this._spritesImagesIds[t$1] ? this._spritesImagesIds[t$1].filter(((t$2) => !(t$2 in e$2))) : [];
							for (const e$3 of a$2) this.imageManager.removeImage(e$3), this._changedImages[e$3] = !0;
							for (const a$3 in e$2[t$1]) {
								const o$2 = "default" === t$1 ? a$3 : `${t$1}:${a$3}`;
								this._spritesImagesIds[t$1].push(o$2), o$2 in this.imageManager.images ? this.imageManager.updateImage(o$2, e$2[t$1][a$3], !1) : this.imageManager.addImage(o$2, e$2[t$1][a$3]), i$1 && (this._changedImages[o$2] = !0);
							}
						}
					})).catch(((e$2) => {
						this._spriteRequest = null, r$1 = e$2, o$1.signal.aborted || this.fire(new t.k(r$1));
					})).finally((() => {
						this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), i$1 && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" })), a$1 && a$1(r$1);
					}));
				}
				_unloadSprite() {
					for (const e$1 of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e$1), this._changedImages[e$1] = !0;
					this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" }));
				}
				_validateLayer(e$1) {
					const i$1 = this.tileManagers[e$1.source];
					if (!i$1) return;
					const a$1 = e$1.sourceLayer;
					if (!a$1) return;
					const o$1 = i$1.getSource();
					("geojson" === o$1.type || o$1.vectorLayerIds && -1 === o$1.vectorLayerIds.indexOf(a$1)) && this.fire(new t.k(/* @__PURE__ */ new Error(`Source layer "${a$1}" does not exist on source "${o$1.id}" as specified by style layer "${e$1.id}".`)));
				}
				loaded() {
					if (!this._loaded) return !1;
					if (Object.keys(this._updatedSources).length) return !1;
					for (const e$1 in this.tileManagers) if (!this.tileManagers[e$1].loaded()) return !1;
					return !!this.imageManager.isLoaded();
				}
				_serializeByIds(e$1, i$1 = !1) {
					const a$1 = this._serializedAllLayers();
					if (!e$1 || 0 === e$1.length) return Object.values(i$1 ? t.bV(a$1) : a$1);
					const o$1 = [];
					for (const r$1 of e$1) if (a$1[r$1]) {
						const e$2 = i$1 ? t.bV(a$1[r$1]) : a$1[r$1];
						o$1.push(e$2);
					}
					return o$1;
				}
				_serializedAllLayers() {
					let e$1 = this._serializedLayers;
					if (e$1) return e$1;
					e$1 = this._serializedLayers = {};
					const t$1 = Object.keys(this._layers);
					for (const i$1 of t$1) {
						const t$2 = this._layers[i$1];
						"custom" !== t$2.type && (e$1[i$1] = t$2.serialize());
					}
					return e$1;
				}
				hasTransitions() {
					var e$1, t$1, i$1;
					if (null === (e$1 = this.light) || void 0 === e$1 ? void 0 : e$1.hasTransition()) return !0;
					if (null === (t$1 = this.sky) || void 0 === t$1 ? void 0 : t$1.hasTransition()) return !0;
					if (null === (i$1 = this.projection) || void 0 === i$1 ? void 0 : i$1.hasTransition()) return !0;
					for (const e$2 in this.tileManagers) if (this.tileManagers[e$2].hasTransition()) return !0;
					for (const e$2 in this._layers) if (this._layers[e$2].hasTransition()) return !0;
					return !1;
				}
				_checkLoaded() {
					if (!this._loaded) throw new Error("Style is not done loading.");
				}
				update(e$1) {
					if (!this._loaded) return;
					const i$1 = this._changed;
					if (i$1) {
						const t$1 = Object.keys(this._updatedLayers), i$2 = Object.keys(this._removedLayers);
						(t$1.length || i$2.length) && this._updateWorkerLayers(t$1, i$2);
						for (const e$2 in this._updatedSources) {
							const t$2 = this._updatedSources[e$2];
							if ("reload" === t$2) this._reloadSource(e$2);
							else {
								if ("clear" !== t$2) throw new Error(`Invalid action ${t$2}`);
								this._clearSource(e$2);
							}
						}
						this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
						for (const t$2 in this._updatedPaintProps) this._layers[t$2].updateTransitions(e$1);
						this.light.updateTransitions(e$1), this.sky.updateTransitions(e$1), this._resetUpdates();
					}
					const a$1 = {};
					for (const e$2 in this.tileManagers) {
						const t$1 = this.tileManagers[e$2];
						a$1[e$2] = t$1.used, t$1.used = !1;
					}
					for (const t$1 of this._order) {
						const i$2 = this._layers[t$1];
						i$2.recalculate(e$1, this._availableImages), !i$2.isHidden(e$1.zoom) && i$2.source && (this.tileManagers[i$2.source].used = !0);
					}
					for (const e$2 in a$1) {
						const i$2 = this.tileManagers[e$2];
						!!a$1[e$2] != !!i$2.used && i$2.fire(new t.l("data", {
							sourceDataType: "visibility",
							dataType: "source",
							sourceId: e$2
						}));
					}
					this.light.recalculate(e$1), this.sky.recalculate(e$1), this.projection.recalculate(e$1), this.z = e$1.zoom, i$1 && this.fire(new t.l("data", { dataType: "style" }));
				}
				_updateTilesForChangedImages() {
					const e$1 = Object.keys(this._changedImages);
					if (e$1.length) {
						for (const t$1 in this.tileManagers) this.tileManagers[t$1].reloadTilesForDependencies(["icons", "patterns"], e$1);
						this._changedImages = {};
					}
				}
				_updateTilesForChangedGlyphs() {
					if (this._glyphsDidChange) {
						for (const e$1 in this.tileManagers) this.tileManagers[e$1].reloadTilesForDependencies(["glyphs"], [""]);
						this._glyphsDidChange = !1;
					}
				}
				_updateWorkerLayers(e$1, t$1) {
					this.dispatcher.broadcast("UL", {
						layers: this._serializeByIds(e$1, !1),
						removedIds: t$1
					});
				}
				_resetUpdates() {
					this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1;
				}
				setState(e$1, i$1 = {}) {
					var a$1;
					this._checkLoaded();
					const o$1 = this.serialize();
					if (e$1 = i$1.transformStyle ? i$1.transformStyle(o$1, e$1) : e$1, (null === (a$1 = i$1.validate) || void 0 === a$1 || a$1) && Ai(this, t.C(e$1))) return !1;
					(e$1 = t.bV(e$1)).layers = t.bS(e$1.layers);
					const r$1 = t.bW(o$1, e$1), s$1 = this._getOperationsToPerform(r$1);
					if (s$1.unimplemented.length > 0) throw new Error(`Unimplemented: ${s$1.unimplemented.join(", ")}.`);
					if (0 === s$1.operations.length) return !1;
					for (const e$2 of s$1.operations) e$2();
					return this.stylesheet = e$1, this._serializedLayers = null, this.fire(new t.l("style.load", { style: this })), !0;
				}
				_getOperationsToPerform(e$1) {
					const t$1 = [], i$1 = [];
					for (const a$1 of e$1) switch (a$1.command) {
						case "setCenter":
						case "setZoom":
						case "setBearing":
						case "setPitch":
						case "setRoll": continue;
						case "addLayer":
							t$1.push((() => this.addLayer.apply(this, a$1.args)));
							break;
						case "removeLayer":
							t$1.push((() => this.removeLayer.apply(this, a$1.args)));
							break;
						case "setPaintProperty":
							t$1.push((() => this.setPaintProperty.apply(this, a$1.args)));
							break;
						case "setLayoutProperty":
							t$1.push((() => this.setLayoutProperty.apply(this, a$1.args)));
							break;
						case "setFilter":
							t$1.push((() => this.setFilter.apply(this, a$1.args)));
							break;
						case "addSource":
							t$1.push((() => this.addSource.apply(this, a$1.args)));
							break;
						case "removeSource":
							t$1.push((() => this.removeSource.apply(this, a$1.args)));
							break;
						case "setLayerZoomRange":
							t$1.push((() => this.setLayerZoomRange.apply(this, a$1.args)));
							break;
						case "setLight":
							t$1.push((() => this.setLight.apply(this, a$1.args)));
							break;
						case "setGeoJSONSourceData":
							t$1.push((() => this.setGeoJSONSourceData.apply(this, a$1.args)));
							break;
						case "setGlyphs":
							t$1.push((() => this.setGlyphs.apply(this, a$1.args)));
							break;
						case "setSprite":
							t$1.push((() => this.setSprite.apply(this, a$1.args)));
							break;
						case "setTerrain":
							t$1.push((() => this.map.setTerrain.apply(this, a$1.args)));
							break;
						case "setSky":
							t$1.push((() => this.setSky.apply(this, a$1.args)));
							break;
						case "setProjection":
							this.setProjection.apply(this, a$1.args);
							break;
						case "setGlobalState":
							t$1.push((() => this.setGlobalState.apply(this, a$1.args)));
							break;
						case "setTransition":
							t$1.push((() => {}));
							break;
						default: i$1.push(a$1.command);
					}
					return {
						operations: t$1,
						unimplemented: i$1
					};
				}
				addImage(e$1, i$1) {
					if (this.getImage(e$1)) return this.fire(new t.k(/* @__PURE__ */ new Error(`An image named "${e$1}" already exists.`)));
					this.imageManager.addImage(e$1, i$1), this._afterImageUpdated(e$1);
				}
				updateImage(e$1, t$1) {
					this.imageManager.updateImage(e$1, t$1);
				}
				getImage(e$1) {
					return this.imageManager.getImage(e$1);
				}
				removeImage(e$1) {
					if (!this.getImage(e$1)) return this.fire(new t.k(/* @__PURE__ */ new Error(`An image named "${e$1}" does not exist.`)));
					this.imageManager.removeImage(e$1), this._afterImageUpdated(e$1);
				}
				_afterImageUpdated(e$1) {
					this._availableImages = this.imageManager.listImages(), this._changedImages[e$1] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" }));
				}
				listImages() {
					return this._checkLoaded(), this.imageManager.listImages();
				}
				addSource(e$1, i$1, a$1 = {}) {
					if (this._checkLoaded(), void 0 !== this.tileManagers[e$1]) throw new Error(`Source "${e$1}" already exists.`);
					if (!i$1.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i$1).join(", ")}.`);
					if ([
						"vector",
						"raster",
						"geojson",
						"video",
						"image"
					].indexOf(i$1.type) >= 0 && this._validate(t.C.source, `sources.${e$1}`, i$1, null, a$1)) return;
					this.map && this.map._collectResourceTiming && (i$1.collectResourceTiming = !0);
					const o$1 = this.tileManagers[e$1] = new ke(e$1, i$1, this.dispatcher);
					o$1.style = this, o$1.setEventedParent(this, (() => ({
						isSourceLoaded: o$1.loaded(),
						source: o$1.serialize(),
						sourceId: e$1
					}))), o$1.onAdd(this.map), this._changed = !0;
				}
				removeSource(e$1) {
					if (this._checkLoaded(), void 0 === this.tileManagers[e$1]) throw new Error("There is no source with this ID");
					for (const i$2 in this._layers) if (this._layers[i$2].source === e$1) return this.fire(new t.k(/* @__PURE__ */ new Error(`Source "${e$1}" cannot be removed while layer "${i$2}" is using it.`)));
					const i$1 = this.tileManagers[e$1];
					delete this.tileManagers[e$1], delete this._updatedSources[e$1], i$1.fire(new t.l("data", {
						sourceDataType: "metadata",
						dataType: "source",
						sourceId: e$1
					})), i$1.setEventedParent(null), i$1.onRemove(this.map), this._changed = !0;
				}
				setGeoJSONSourceData(e$1, t$1) {
					if (this._checkLoaded(), void 0 === this.tileManagers[e$1]) throw new Error(`There is no source with this ID=${e$1}`);
					const i$1 = this.tileManagers[e$1].getSource();
					if ("geojson" !== i$1.type) throw new Error(`geojsonSource.type is ${i$1.type}, which is !== 'geojson`);
					i$1.setData(t$1), this._changed = !0;
				}
				getSource(e$1) {
					return this.tileManagers[e$1] && this.tileManagers[e$1].getSource();
				}
				addLayer(e$1, i$1, a$1 = {}) {
					this._checkLoaded();
					const o$1 = e$1.id;
					if (this.getLayer(o$1)) return void this.fire(new t.k(/* @__PURE__ */ new Error(`Layer "${o$1}" already exists on this map.`)));
					let r$1;
					if ("custom" === e$1.type) {
						if (Ai(this, t.bX(e$1))) return;
						r$1 = t.bT(e$1, this._globalState);
					} else {
						if ("source" in e$1 && "object" == typeof e$1.source && (this.addSource(o$1, e$1.source), e$1 = t.bV(e$1), e$1 = t.e(e$1, { source: o$1 })), this._validate(t.C.layer, `layers.${o$1}`, e$1, { arrayIndex: -1 }, a$1)) return;
						r$1 = t.bT(e$1, this._globalState), this._validateLayer(r$1), r$1.setEventedParent(this, { layer: { id: o$1 } });
					}
					const s$1 = i$1 ? this._order.indexOf(i$1) : this._order.length;
					if (i$1 && -1 === s$1) this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot add layer "${o$1}" before non-existing layer "${i$1}".`)));
					else {
						if (this._order.splice(s$1, 0, o$1), this._layerOrderChanged = !0, this._layers[o$1] = r$1, this._removedLayers[o$1] && r$1.source && "custom" !== r$1.type) {
							const e$2 = this._removedLayers[o$1];
							delete this._removedLayers[o$1], e$2.type !== r$1.type ? this._updatedSources[r$1.source] = "clear" : (this._updatedSources[r$1.source] = "reload", this.tileManagers[r$1.source].pause());
						}
						this._updateLayer(r$1), r$1.onAdd && r$1.onAdd(this.map);
					}
				}
				moveLayer(e$1, i$1) {
					if (this._checkLoaded(), this._changed = !0, !this._layers[e$1]) return void this.fire(new t.k(/* @__PURE__ */ new Error(`The layer '${e$1}' does not exist in the map's style and cannot be moved.`)));
					if (e$1 === i$1) return;
					const a$1 = this._order.indexOf(e$1);
					this._order.splice(a$1, 1);
					const o$1 = i$1 ? this._order.indexOf(i$1) : this._order.length;
					i$1 && -1 === o$1 ? this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot move layer "${e$1}" before non-existing layer "${i$1}".`))) : (this._order.splice(o$1, 0, e$1), this._layerOrderChanged = !0);
				}
				removeLayer(e$1) {
					this._checkLoaded();
					const i$1 = this._layers[e$1];
					if (!i$1) return void this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot remove non-existing layer "${e$1}".`)));
					i$1.setEventedParent(null);
					const a$1 = this._order.indexOf(e$1);
					this._order.splice(a$1, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e$1] = i$1, delete this._layers[e$1], this._serializedLayers && delete this._serializedLayers[e$1], delete this._updatedLayers[e$1], delete this._updatedPaintProps[e$1], i$1.onRemove && i$1.onRemove(this.map);
				}
				getLayer(e$1) {
					return this._layers[e$1];
				}
				getLayersOrder() {
					return [...this._order];
				}
				hasLayer(e$1) {
					return e$1 in this._layers;
				}
				setLayerZoomRange(e$1, i$1, a$1) {
					this._checkLoaded();
					const o$1 = this.getLayer(e$1);
					o$1 ? o$1.minzoom === i$1 && o$1.maxzoom === a$1 || (null != i$1 && (o$1.minzoom = i$1), null != a$1 && (o$1.maxzoom = a$1), this._updateLayer(o$1)) : this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot set the zoom range of non-existing layer "${e$1}".`)));
				}
				setFilter(e$1, i$1, a$1 = {}) {
					this._checkLoaded();
					const o$1 = this.getLayer(e$1);
					if (o$1) {
						if (!t.bR(o$1.filter, i$1)) return null == i$1 ? (o$1.setFilter(void 0), void this._updateLayer(o$1)) : void (this._validate(t.C.filter, `layers.${o$1.id}.filter`, i$1, null, a$1) || (o$1.setFilter(t.bV(i$1)), this._updateLayer(o$1)));
					} else this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot filter non-existing layer "${e$1}".`)));
				}
				getFilter(e$1) {
					return t.bV(this.getLayer(e$1).filter);
				}
				setLayoutProperty(e$1, i$1, a$1, o$1 = {}) {
					this._checkLoaded();
					const r$1 = this.getLayer(e$1);
					r$1 ? t.bR(r$1.getLayoutProperty(i$1), a$1) || (r$1.setLayoutProperty(i$1, a$1, o$1), this._updateLayer(r$1)) : this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot style non-existing layer "${e$1}".`)));
				}
				getLayoutProperty(e$1, i$1) {
					const a$1 = this.getLayer(e$1);
					if (a$1) return a$1.getLayoutProperty(i$1);
					this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot get style of non-existing layer "${e$1}".`)));
				}
				setPaintProperty(e$1, i$1, a$1, o$1 = {}) {
					this._checkLoaded();
					const r$1 = this.getLayer(e$1);
					r$1 ? t.bR(r$1.getPaintProperty(i$1), a$1) || this._updatePaintProperty(r$1, i$1, a$1, o$1) : this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot style non-existing layer "${e$1}".`)));
				}
				_updatePaintProperty(e$1, i$1, a$1, o$1 = {}) {
					e$1.setPaintProperty(i$1, a$1, o$1) && this._updateLayer(e$1), t.bU(e$1) && "raster-fade-duration" === i$1 && this.tileManagers[e$1.source].setRasterFadeDuration(a$1), this._changed = !0, this._updatedPaintProps[e$1.id] = !0, this._serializedLayers = null;
				}
				getPaintProperty(e$1, t$1) {
					return this.getLayer(e$1).getPaintProperty(t$1);
				}
				setFeatureState(e$1, i$1) {
					this._checkLoaded();
					const a$1 = e$1.source, o$1 = e$1.sourceLayer, r$1 = this.tileManagers[a$1];
					if (void 0 === r$1) return void this.fire(new t.k(/* @__PURE__ */ new Error(`The source '${a$1}' does not exist in the map's style.`)));
					const s$1 = r$1.getSource().type;
					"geojson" === s$1 && o$1 ? this.fire(new t.k(/* @__PURE__ */ new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== s$1 || o$1 ? (void 0 === e$1.id && this.fire(new t.k(/* @__PURE__ */ new Error("The feature id parameter must be provided."))), r$1.setFeatureState(o$1, e$1.id, i$1)) : this.fire(new t.k(/* @__PURE__ */ new Error("The sourceLayer parameter must be provided for vector source types.")));
				}
				removeFeatureState(e$1, i$1) {
					this._checkLoaded();
					const a$1 = e$1.source, o$1 = this.tileManagers[a$1];
					if (void 0 === o$1) return void this.fire(new t.k(/* @__PURE__ */ new Error(`The source '${a$1}' does not exist in the map's style.`)));
					const r$1 = o$1.getSource().type, s$1 = "vector" === r$1 ? e$1.sourceLayer : void 0;
					"vector" !== r$1 || s$1 ? i$1 && "string" != typeof e$1.id && "number" != typeof e$1.id ? this.fire(new t.k(/* @__PURE__ */ new Error("A feature id is required to remove its specific state property."))) : o$1.removeFeatureState(s$1, e$1.id, i$1) : this.fire(new t.k(/* @__PURE__ */ new Error("The sourceLayer parameter must be provided for vector source types.")));
				}
				getFeatureState(e$1) {
					this._checkLoaded();
					const i$1 = e$1.source, a$1 = e$1.sourceLayer, o$1 = this.tileManagers[i$1];
					if (void 0 !== o$1) return "vector" !== o$1.getSource().type || a$1 ? (void 0 === e$1.id && this.fire(new t.k(/* @__PURE__ */ new Error("The feature id parameter must be provided."))), o$1.getFeatureState(a$1, e$1.id)) : void this.fire(new t.k(/* @__PURE__ */ new Error("The sourceLayer parameter must be provided for vector source types.")));
					this.fire(new t.k(/* @__PURE__ */ new Error(`The source '${i$1}' does not exist in the map's style.`)));
				}
				getTransition() {
					return t.e({
						duration: 300,
						delay: 0
					}, this.stylesheet && this.stylesheet.transition);
				}
				serialize() {
					if (!this._loaded) return;
					const e$1 = t.bY(this.tileManagers, ((e$2) => e$2.serialize())), i$1 = this._serializeByIds(this._order, !0), a$1 = this.map.getTerrain() || void 0, o$1 = this.stylesheet;
					return t.bZ({
						version: o$1.version,
						name: o$1.name,
						metadata: o$1.metadata,
						light: o$1.light,
						sky: o$1.sky,
						center: o$1.center,
						zoom: o$1.zoom,
						bearing: o$1.bearing,
						pitch: o$1.pitch,
						sprite: o$1.sprite,
						glyphs: o$1.glyphs,
						transition: o$1.transition,
						projection: o$1.projection,
						sources: e$1,
						layers: i$1,
						terrain: a$1
					}, ((e$2) => void 0 !== e$2));
				}
				_updateLayer(e$1) {
					this._updatedLayers[e$1.id] = !0, e$1.source && !this._updatedSources[e$1.source] && "raster" !== this.tileManagers[e$1.source].getSource().type && (this._updatedSources[e$1.source] = "reload", this.tileManagers[e$1.source].pause()), this._serializedLayers = null, this._changed = !0;
				}
				_flattenAndSortRenderedFeatures(e$1) {
					const t$1 = (e$2) => "fill-extrusion" === this._layers[e$2].type, i$1 = {}, a$1 = [];
					for (let o$2 = this._order.length - 1; o$2 >= 0; o$2--) {
						const r$1 = this._order[o$2];
						if (t$1(r$1)) {
							i$1[r$1] = o$2;
							for (const t$2 of e$1) {
								const e$2 = t$2[r$1];
								if (e$2) for (const t$3 of e$2) a$1.push(t$3);
							}
						}
					}
					a$1.sort(((e$2, t$2) => t$2.intersectionZ - e$2.intersectionZ));
					const o$1 = [];
					for (let r$1 = this._order.length - 1; r$1 >= 0; r$1--) {
						const s$1 = this._order[r$1];
						if (t$1(s$1)) for (let e$2 = a$1.length - 1; e$2 >= 0; e$2--) {
							const t$2 = a$1[e$2].feature;
							if (i$1[t$2.layer.id] < r$1) break;
							o$1.push(t$2), a$1.pop();
						}
						else for (const t$2 of e$1) {
							const e$2 = t$2[s$1];
							if (e$2) for (const t$3 of e$2) o$1.push(t$3.feature);
						}
					}
					return o$1;
				}
				queryRenderedFeatures(e$1, i$1, a$1) {
					i$1 && i$1.filter && this._validate(t.C.filter, "queryRenderedFeatures.filter", i$1.filter, null, i$1);
					const o$1 = {};
					if (i$1 && i$1.layers) {
						if (!(Array.isArray(i$1.layers) || i$1.layers instanceof Set)) return this.fire(new t.k(/* @__PURE__ */ new Error("parameters.layers must be an Array or a Set of strings"))), [];
						for (const e$2 of i$1.layers) {
							const i$2 = this._layers[e$2];
							if (!i$2) return this.fire(new t.k(/* @__PURE__ */ new Error(`The layer '${e$2}' does not exist in the map's style and cannot be queried for features.`))), [];
							o$1[i$2.source] = !0;
						}
					}
					const r$1 = [];
					i$1.availableImages = this._availableImages;
					const s$1 = this._serializedAllLayers(), n$1 = i$1.layers instanceof Set ? i$1.layers : Array.isArray(i$1.layers) ? new Set(i$1.layers) : null, l$1 = Object.assign(Object.assign({}, i$1), {
						layers: n$1,
						globalState: this._globalState
					});
					for (const t$1 in this.tileManagers) i$1.layers && !o$1[t$1] || r$1.push(G(this.tileManagers[t$1], this._layers, s$1, e$1, l$1, a$1, this.map.terrain ? (e$2, t$2, i$2) => this.map.terrain.getElevation(e$2, t$2, i$2) : void 0));
					return this.placement && r$1.push(function(e$2, t$1, i$2, a$2, o$2, r$2, s$2) {
						const n$2 = {}, l$2 = r$2.queryRenderedSymbols(a$2), c$1 = [];
						for (const e$3 of Object.keys(l$2).map(Number)) c$1.push(s$2[e$3]);
						c$1.sort(V);
						for (const i$3 of c$1) {
							const a$3 = i$3.featureIndex.lookupSymbolFeatures(l$2[i$3.bucketInstanceId], t$1, i$3.bucketIndex, i$3.sourceLayerIndex, {
								filterSpec: o$2.filter,
								globalState: o$2.globalState
							}, o$2.layers, o$2.availableImages, e$2);
							for (const e$3 in a$3) {
								const t$2 = n$2[e$3] = n$2[e$3] || [], o$3 = a$3[e$3];
								o$3.sort(((e$4, t$3) => {
									const a$4 = i$3.featureSortOrder;
									if (a$4) {
										const i$4 = a$4.indexOf(e$4.featureIndex);
										return a$4.indexOf(t$3.featureIndex) - i$4;
									}
									return t$3.featureIndex - e$4.featureIndex;
								}));
								for (const e$4 of o$3) t$2.push(e$4);
							}
						}
						return function(e$3, t$2, i$3) {
							for (const a$3 in e$3) for (const o$3 of e$3[a$3]) q(o$3, i$3[t$2[a$3].source]);
							return e$3;
						}(n$2, e$2, i$2);
					}(this._layers, s$1, this.tileManagers, e$1, l$1, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(r$1);
				}
				querySourceFeatures(e$1, i$1) {
					null != i$1 && i$1.filter && this._validate(t.C.filter, "querySourceFeatures.filter", i$1.filter, null, i$1);
					const a$1 = this.tileManagers[e$1];
					return a$1 ? function(e$2, t$1) {
						const i$2 = e$2.getRenderableIds().map(((t$2) => e$2.getTileByID(t$2))), a$2 = [], o$1 = {};
						for (let e$3 = 0; e$3 < i$2.length; e$3++) {
							const r$1 = i$2[e$3], s$1 = r$1.tileID.canonical.key;
							o$1[s$1] || (o$1[s$1] = !0, r$1.querySourceFeatures(a$2, t$1));
						}
						return a$2;
					}(a$1, i$1 ? Object.assign(Object.assign({}, i$1), { globalState: this._globalState }) : { globalState: this._globalState }) : [];
				}
				getLight() {
					return this.light.getLight();
				}
				setLight(e$1, i$1 = {}) {
					this._checkLoaded();
					const a$1 = this.light.getLight();
					let o$1 = !1;
					for (const i$2 in e$1) if (!t.bR(e$1[i$2], a$1[i$2])) {
						o$1 = !0;
						break;
					}
					if (!o$1) return;
					const r$1 = {
						now: c(),
						transition: t.e({
							duration: 300,
							delay: 0
						}, this.stylesheet.transition)
					};
					this.light.setLight(e$1, i$1), this.light.updateTransitions(r$1);
				}
				getProjection() {
					var e$1;
					return null === (e$1 = this.stylesheet) || void 0 === e$1 ? void 0 : e$1.projection;
				}
				setProjection(e$1) {
					if (this._checkLoaded(), this.projection) {
						if (this.projection.name === e$1.type) return;
						this.projection.destroy(), delete this.projection;
					}
					this.stylesheet.projection = e$1, this._setProjectionInternal(e$1.type);
				}
				getSky() {
					var e$1;
					return null === (e$1 = this.stylesheet) || void 0 === e$1 ? void 0 : e$1.sky;
				}
				setSky(e$1, i$1 = {}) {
					this._checkLoaded();
					const a$1 = this.getSky();
					let o$1 = !1;
					if (!e$1 && !a$1) return;
					if (e$1 && !a$1) o$1 = !0;
					else if (!e$1 && a$1) o$1 = !0;
					else for (const i$2 in e$1) if (!t.bR(e$1[i$2], a$1[i$2])) {
						o$1 = !0;
						break;
					}
					if (!o$1) return;
					const r$1 = {
						now: c(),
						transition: t.e({
							duration: 300,
							delay: 0
						}, this.stylesheet.transition)
					};
					this.stylesheet.sky = e$1, this.sky.setSky(e$1, i$1), this.sky.updateTransitions(r$1);
				}
				_setProjectionInternal(e$1) {
					const i$1 = function(e$2, i$2) {
						const a$1 = { constrainOverride: i$2 };
						if (Array.isArray(e$2)) {
							const t$1 = new di({ type: e$2 });
							return {
								projection: t$1,
								transform: new zi(a$1),
								cameraHelper: new Di(t$1)
							};
						}
						switch (e$2) {
							case "mercator": return {
								projection: new jt(),
								transform: new $t(a$1),
								cameraHelper: new Yt()
							};
							case "globe": {
								const e$3 = new di({ type: [
									"interpolate",
									["linear"],
									["zoom"],
									11,
									"vertical-perspective",
									12,
									"mercator"
								] });
								return {
									projection: e$3,
									transform: new zi(a$1),
									cameraHelper: new Di(e$3)
								};
							}
							case "vertical-perspective": return {
								projection: new hi(),
								transform: new Si(a$1),
								cameraHelper: new Ri()
							};
							default: return t.w(`Unknown projection name: ${e$2}. Falling back to mercator projection.`), {
								projection: new jt(),
								transform: new $t(a$1),
								cameraHelper: new Yt()
							};
						}
					}(e$1, this.map.transformConstrain);
					this.projection = i$1.projection, this.map.migrateProjection(i$1.transform, i$1.cameraHelper);
					for (const e$2 in this.tileManagers) this.tileManagers[e$2].reload();
				}
				_validate(e$1, i$1, a$1, o$1, r$1 = {}) {
					return (!r$1 || !1 !== r$1.validate) && Ai(this, e$1.call(t.C, t.e({
						key: i$1,
						style: this.serialize(),
						value: a$1,
						styleSpec: t.u
					}, o$1)));
				}
				_remove(e$1 = !0) {
					this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), ce().off(se, this._rtlPluginLoaded);
					for (const e$2 in this._layers) this._layers[e$2].setEventedParent(null);
					for (const e$2 in this.tileManagers) {
						const t$1 = this.tileManagers[e$2];
						t$1.setEventedParent(null), t$1.onRemove(this.map);
					}
					this.imageManager.setEventedParent(null), this.setEventedParent(null), e$1 && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e$1);
				}
				_clearSource(e$1) {
					this.tileManagers[e$1].clearTiles();
				}
				_reloadSource(e$1) {
					this.tileManagers[e$1].resume(), this.tileManagers[e$1].reload();
				}
				_updateSources(e$1) {
					for (const t$1 in this.tileManagers) this.tileManagers[t$1].update(e$1, this.map.terrain);
				}
				_generateCollisionBoxes() {
					for (const e$1 in this.tileManagers) this._reloadSource(e$1);
				}
				_updatePlacement(e$1, t$1, i$1, a$1, o$1 = !1) {
					let r$1 = !1, s$1 = !1;
					const n$1 = {};
					for (const t$2 of this._order) {
						const i$2 = this._layers[t$2];
						if ("symbol" !== i$2.type) continue;
						if (!n$1[i$2.source]) {
							const e$2 = this.tileManagers[i$2.source];
							n$1[i$2.source] = e$2.getRenderableIds(!0).map(((t$3) => e$2.getTileByID(t$3))).sort(((e$3, t$3) => t$3.tileID.overscaledZ - e$3.tileID.overscaledZ || (e$3.tileID.isLessThan(t$3.tileID) ? -1 : 1)));
						}
						const a$2 = this.crossTileSymbolIndex.addLayer(i$2, n$1[i$2.source], e$1.center.lng);
						r$1 = r$1 || a$2;
					}
					if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((o$1 = o$1 || this._layerOrderChanged || 0 === i$1) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(c(), e$1.zoom)) && (this.pauseablePlacement = new It(e$1, this.map.terrain, this._order, o$1, t$1, i$1, a$1, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, n$1), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(c()), s$1 = !0), r$1 && this.pauseablePlacement.placement.setStale()), s$1 || r$1) for (const e$2 of this._order) {
						const t$2 = this._layers[e$2];
						"symbol" === t$2.type && this.placement.updateLayerOpacities(t$2, n$1[t$2.source]);
					}
					return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(c());
				}
				_releaseSymbolFadeTiles() {
					for (const e$1 in this.tileManagers) this.tileManagers[e$1].releaseSymbolFadeTiles();
				}
				getImages(e$1, i$1) {
					return t._(this, void 0, void 0, (function* () {
						const e$2 = yield this.imageManager.getImages(i$1.icons);
						this._updateTilesForChangedImages();
						const t$1 = this.tileManagers[i$1.source];
						return t$1 && t$1.setDependencies(i$1.tileID.key, i$1.type, i$1.icons), e$2;
					}));
				}
				getGlyphs(e$1, i$1) {
					return t._(this, void 0, void 0, (function* () {
						const e$2 = yield this.glyphManager.getGlyphs(i$1.stacks), t$1 = this.tileManagers[i$1.source];
						return t$1 && t$1.setDependencies(i$1.tileID.key, i$1.type, [""]), e$2;
					}));
				}
				getGlyphsUrl() {
					return this.stylesheet.glyphs || null;
				}
				setGlyphs(e$1, i$1 = {}) {
					this._checkLoaded(), e$1 && this._validate(t.C.glyphs, "glyphs", e$1, null, i$1) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = e$1, this.glyphManager.entries = {}, this.glyphManager.setURL(e$1));
				}
				getDashes(e$1, i$1) {
					return t._(this, void 0, void 0, (function* () {
						const e$2 = {};
						for (const [t$1, a$1] of Object.entries(i$1.dashes)) e$2[t$1] = this.lineAtlas.getDash(a$1.dasharray, a$1.round);
						return e$2;
					}));
				}
				addSprite(e$1, i$1, a$1 = {}, o$1) {
					this._checkLoaded();
					const r$1 = [{
						id: e$1,
						url: i$1
					}], s$1 = [...x(this.stylesheet.sprite), ...r$1];
					this._validate(t.C.sprite, "sprite", s$1, null, a$1) || (this.stylesheet.sprite = s$1, this._loadSprite(r$1, !0, o$1));
				}
				removeSprite(e$1) {
					this._checkLoaded();
					const i$1 = x(this.stylesheet.sprite);
					if (i$1.find(((t$1) => t$1.id === e$1))) {
						if (this._spritesImagesIds[e$1]) for (const t$1 of this._spritesImagesIds[e$1]) this.imageManager.removeImage(t$1), this._changedImages[t$1] = !0;
						i$1.splice(i$1.findIndex(((t$1) => t$1.id === e$1)), 1), this.stylesheet.sprite = i$1.length > 0 ? i$1 : void 0, delete this._spritesImagesIds[e$1], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" }));
					} else this.fire(new t.k(/* @__PURE__ */ new Error(`Sprite "${e$1}" doesn't exists on this map.`)));
				}
				getSprite() {
					return x(this.stylesheet.sprite);
				}
				setSprite(e$1, i$1 = {}, a$1) {
					this._checkLoaded(), e$1 && this._validate(t.C.sprite, "sprite", e$1, null, i$1) || (this.stylesheet.sprite = e$1, e$1 ? this._loadSprite(e$1, !0, a$1) : (this._unloadSprite(), a$1 && a$1(null)));
				}
				destroy() {
					this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null);
					for (const e$1 in this.tileManagers) {
						const t$1 = this.tileManagers[e$1];
						t$1.setEventedParent(null), t$1.onRemove(this.map);
					}
					this.tileManagers = {}, this.imageManager && (this.imageManager.setEventedParent(null), this.imageManager.destroy(), this._availableImages = [], this._spritesImagesIds = {}), this.glyphManager && this.glyphManager.destroy();
					for (const e$1 in this._layers) {
						const t$1 = this._layers[e$1];
						t$1.setEventedParent(null), t$1.onRemove && t$1.onRemove(this.map);
					}
					this._setInitialValues(), this.setEventedParent(null), this.dispatcher.unregisterMessageHandler("GG"), this.dispatcher.unregisterMessageHandler("GI"), this.dispatcher.unregisterMessageHandler("GDA"), this.dispatcher.remove(!0), this._listeners = {}, this._oneTimeListeners = {};
				}
			}
			var Fi = t.aU([{
				name: "a_pos",
				type: "Int16",
				components: 2
			}, {
				name: "a_texture_pos",
				type: "Int16",
				components: 2
			}]);
			class Bi {
				constructor() {
					this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
				}
				bind(e$1, t$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1) {
					this.context = e$1;
					let c$1 = this.boundPaintVertexBuffers.length !== a$1.length;
					for (let e$2 = 0; !c$1 && e$2 < a$1.length; e$2++) this.boundPaintVertexBuffers[e$2] !== a$1[e$2] && (c$1 = !0);
					!this.vao || this.boundProgram !== t$1 || this.boundLayoutVertexBuffer !== i$1 || c$1 || this.boundIndexBuffer !== o$1 || this.boundVertexOffset !== r$1 || this.boundDynamicVertexBuffer !== s$1 || this.boundDynamicVertexBuffer2 !== n$1 || this.boundDynamicVertexBuffer3 !== l$1 ? this.freshBind(t$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1) : (e$1.bindVertexArray.set(this.vao), s$1 && s$1.bind(), o$1 && o$1.dynamicDraw && o$1.bind(), n$1 && n$1.bind(), l$1 && l$1.bind());
				}
				freshBind(e$1, t$1, i$1, a$1, o$1, r$1, s$1, n$1) {
					const l$1 = e$1.numAttributes, c$1 = this.context, h$1 = c$1.gl;
					this.vao && this.destroy(), this.vao = c$1.createVertexArray(), c$1.bindVertexArray.set(this.vao), this.boundProgram = e$1, this.boundLayoutVertexBuffer = t$1, this.boundPaintVertexBuffers = i$1, this.boundIndexBuffer = a$1, this.boundVertexOffset = o$1, this.boundDynamicVertexBuffer = r$1, this.boundDynamicVertexBuffer2 = s$1, this.boundDynamicVertexBuffer3 = n$1, t$1.enableAttributes(h$1, e$1);
					for (const t$2 of i$1) t$2.enableAttributes(h$1, e$1);
					r$1 && r$1.enableAttributes(h$1, e$1), s$1 && s$1.enableAttributes(h$1, e$1), n$1 && n$1.enableAttributes(h$1, e$1), t$1.bind(), t$1.setVertexAttribPointers(h$1, e$1, o$1);
					for (const t$2 of i$1) t$2.bind(), t$2.setVertexAttribPointers(h$1, e$1, o$1);
					r$1 && (r$1.bind(), r$1.setVertexAttribPointers(h$1, e$1, o$1)), a$1 && a$1.bind(), s$1 && (s$1.bind(), s$1.setVertexAttribPointers(h$1, e$1, o$1)), n$1 && (n$1.bind(), n$1.setVertexAttribPointers(h$1, e$1, o$1)), c$1.currentNumAttributes = l$1;
				}
				destroy() {
					this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
				}
			}
			const Oi = (e$1, i$1, a$1, o$1, r$1) => ({
				u_texture: 0,
				u_ele_delta: e$1,
				u_fog_matrix: i$1,
				u_fog_color: a$1 ? a$1.properties.get("fog-color") : t.bp.white,
				u_fog_ground_blend: a$1 ? a$1.properties.get("fog-ground-blend") : 1,
				u_fog_ground_blend_opacity: r$1 ? 0 : a$1 ? a$1.calculateFogBlendOpacity(o$1) : 0,
				u_horizon_color: a$1 ? a$1.properties.get("horizon-color") : t.bp.white,
				u_horizon_fog_blend: a$1 ? a$1.properties.get("horizon-fog-blend") : 1,
				u_is_globe_mode: r$1 ? 1 : 0
			}), ji = {
				mainMatrix: "u_projection_matrix",
				tileMercatorCoords: "u_projection_tile_mercator_coords",
				clippingPlane: "u_projection_clipping_plane",
				projectionTransition: "u_projection_transition",
				fallbackMatrix: "u_projection_fallback_matrix"
			};
			function Ni(e$1) {
				const t$1 = [];
				for (let i$1 = 0; i$1 < e$1.length; i$1++) {
					if (null === e$1[i$1]) continue;
					const a$1 = e$1[i$1].split(" ");
					t$1.push(a$1.pop());
				}
				return t$1;
			}
			class Zi {
				constructor(e$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1, c$1 = []) {
					const h$1 = e$1.gl;
					this.program = h$1.createProgram();
					const u$1 = Ni(i$1.staticAttributes), d$1 = a$1 ? a$1.getBinderAttributes() : [], _$1 = u$1.concat(d$1), p$1 = At.prelude.staticUniforms ? Ni(At.prelude.staticUniforms) : [], m$1 = n$1.staticUniforms ? Ni(n$1.staticUniforms) : [], f$1 = i$1.staticUniforms ? Ni(i$1.staticUniforms) : [], g$1 = a$1 ? a$1.getBinderUniforms() : [], v$1 = p$1.concat(m$1).concat(f$1).concat(g$1), x$1 = [];
					for (const e$2 of v$1) x$1.indexOf(e$2) < 0 && x$1.push(e$2);
					const b$1 = a$1 ? a$1.defines() : [];
					ri(h$1) && b$1.unshift("#version 300 es"), r$1 && b$1.push("#define OVERDRAW_INSPECTOR;"), s$1 && b$1.push("#define TERRAIN3D;"), l$1 && b$1.push(l$1), c$1 && b$1.push(...c$1);
					let y$1 = b$1.concat(At.prelude.fragmentSource, n$1.fragmentSource, i$1.fragmentSource).join("\n"), w$1 = b$1.concat(At.prelude.vertexSource, n$1.vertexSource, i$1.vertexSource).join("\n");
					ri(h$1) || (y$1 = function(e$2) {
						return e$2.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
					}(y$1), w$1 = function(e$2) {
						return e$2.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
					}(w$1));
					const T$1 = h$1.createShader(h$1.FRAGMENT_SHADER);
					if (h$1.isContextLost()) return void (this.failedToCreate = !0);
					if (h$1.shaderSource(T$1, y$1), h$1.compileShader(T$1), !h$1.getShaderParameter(T$1, h$1.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${h$1.getShaderInfoLog(T$1)}`);
					h$1.attachShader(this.program, T$1);
					const P$1 = h$1.createShader(h$1.VERTEX_SHADER);
					if (h$1.isContextLost()) return void (this.failedToCreate = !0);
					if (h$1.shaderSource(P$1, w$1), h$1.compileShader(P$1), !h$1.getShaderParameter(P$1, h$1.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${h$1.getShaderInfoLog(P$1)}`);
					h$1.attachShader(this.program, P$1), this.attributes = {};
					const C$1 = {};
					this.numAttributes = _$1.length;
					for (let e$2 = 0; e$2 < this.numAttributes; e$2++) _$1[e$2] && (h$1.bindAttribLocation(this.program, e$2, _$1[e$2]), this.attributes[_$1[e$2]] = e$2);
					if (h$1.linkProgram(this.program), !h$1.getProgramParameter(this.program, h$1.LINK_STATUS)) throw new Error(`Program failed to link: ${h$1.getProgramInfoLog(this.program)}`);
					h$1.deleteShader(P$1), h$1.deleteShader(T$1);
					for (let e$2 = 0; e$2 < x$1.length; e$2++) {
						const t$1 = x$1[e$2];
						if (t$1 && !C$1[t$1]) {
							const e$3 = h$1.getUniformLocation(this.program, t$1);
							e$3 && (C$1[t$1] = e$3);
						}
					}
					this.fixedUniforms = o$1(e$1, C$1), this.terrainUniforms = ((e$2, i$2) => ({
						u_depth: new t.b_(e$2, i$2.u_depth),
						u_terrain: new t.b_(e$2, i$2.u_terrain),
						u_terrain_dim: new t.bq(e$2, i$2.u_terrain_dim),
						u_terrain_matrix: new t.c0(e$2, i$2.u_terrain_matrix),
						u_terrain_unpack: new t.c1(e$2, i$2.u_terrain_unpack),
						u_terrain_exaggeration: new t.bq(e$2, i$2.u_terrain_exaggeration)
					}))(e$1, C$1), this.projectionUniforms = ((e$2, i$2) => ({
						u_projection_matrix: new t.c0(e$2, i$2.u_projection_matrix),
						u_projection_tile_mercator_coords: new t.c1(e$2, i$2.u_projection_tile_mercator_coords),
						u_projection_clipping_plane: new t.c1(e$2, i$2.u_projection_clipping_plane),
						u_projection_transition: new t.bq(e$2, i$2.u_projection_transition),
						u_projection_fallback_matrix: new t.c0(e$2, i$2.u_projection_fallback_matrix)
					}))(e$1, C$1), this.binderUniforms = a$1 ? a$1.getUniforms(e$1, C$1) : [];
				}
				draw(e$1, t$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$1, p$1, m$1, f$1, g$1, v$1) {
					const x$1 = e$1.gl;
					if (this.failedToCreate) return;
					if (e$1.program.set(this.program), e$1.setDepthMode(i$1), e$1.setStencilMode(a$1), e$1.setColorMode(o$1), e$1.setCullFace(r$1), n$1) {
						e$1.activeTexture.set(x$1.TEXTURE2), x$1.bindTexture(x$1.TEXTURE_2D, n$1.depthTexture), e$1.activeTexture.set(x$1.TEXTURE3), x$1.bindTexture(x$1.TEXTURE_2D, n$1.texture);
						for (const e$2 in this.terrainUniforms) this.terrainUniforms[e$2].set(n$1[e$2]);
					}
					if (l$1) for (const e$2 in l$1) this.projectionUniforms[ji[e$2]].set(l$1[e$2]);
					if (s$1) for (const e$2 in this.fixedUniforms) this.fixedUniforms[e$2].set(s$1[e$2]);
					m$1 && m$1.setUniforms(e$1, this.binderUniforms, _$1, { zoom: p$1 });
					let b$1 = 0;
					switch (t$1) {
						case x$1.LINES:
							b$1 = 2;
							break;
						case x$1.TRIANGLES:
							b$1 = 3;
							break;
						case x$1.LINE_STRIP: b$1 = 1;
					}
					for (const i$2 of d$1.get()) {
						const a$2 = i$2.vaos || (i$2.vaos = {});
						(a$2[c$1] || (a$2[c$1] = new Bi())).bind(e$1, this, h$1, m$1 ? m$1.getPaintVertexBuffers() : [], u$1, i$2.vertexOffset, f$1, g$1, v$1), x$1.drawElements(t$1, i$2.primitiveLength * b$1, x$1.UNSIGNED_SHORT, i$2.primitiveOffset * b$1 * 2);
					}
				}
			}
			function Ui(e$1, i$1, a$1) {
				const o$1 = 1 / t.aN(a$1, 1, i$1.transform.tileZoom), r$1 = Math.pow(2, a$1.tileID.overscaledZ), s$1 = a$1.tileSize * Math.pow(2, i$1.transform.tileZoom) / r$1, n$1 = s$1 * (a$1.tileID.canonical.x + a$1.tileID.wrap * r$1), l$1 = s$1 * a$1.tileID.canonical.y;
				return {
					u_image: 0,
					u_texsize: a$1.imageAtlasTexture.size,
					u_scale: [
						o$1,
						e$1.fromScale,
						e$1.toScale
					],
					u_fade: e$1.t,
					u_pixel_coord_upper: [n$1 >> 16, l$1 >> 16],
					u_pixel_coord_lower: [65535 & n$1, 65535 & l$1]
				};
			}
			const Gi = (e$1, i$1, a$1, o$1) => {
				const r$1 = e$1.style.light, s$1 = r$1.properties.get("position"), n$1 = [
					s$1.x,
					s$1.y,
					s$1.z
				], l$1 = t.c4();
				"viewport" === r$1.properties.get("anchor") && t.c5(l$1, e$1.transform.bearingInRadians), t.c6(n$1, n$1, l$1);
				const c$1 = e$1.transform.transformLightDirection(n$1), h$1 = r$1.properties.get("color");
				return {
					u_lightpos: n$1,
					u_lightpos_globe: c$1,
					u_lightintensity: r$1.properties.get("intensity"),
					u_lightcolor: [
						h$1.r,
						h$1.g,
						h$1.b
					],
					u_vertical_gradient: +i$1,
					u_opacity: a$1,
					u_fill_translate: o$1
				};
			}, Vi = (e$1, i$1, a$1, o$1, r$1, s$1, n$1) => t.e(Gi(e$1, i$1, a$1, o$1), Ui(s$1, e$1, n$1), { u_height_factor: -Math.pow(2, r$1.overscaledZ) / n$1.tileSize / 8 }), qi = (e$1, i$1, a$1, o$1) => t.e(Ui(i$1, e$1, a$1), { u_fill_translate: o$1 }), Wi = (e$1, t$1) => ({
				u_world: e$1,
				u_fill_translate: t$1
			}), $i = (e$1, i$1, a$1, o$1, r$1) => t.e(qi(e$1, i$1, a$1, r$1), { u_world: o$1 }), Hi = (e$1, i$1, a$1, o$1, r$1) => {
				const s$1 = e$1.transform;
				let n$1, l$1, c$1 = 0;
				if ("map" === a$1.paint.get("circle-pitch-alignment")) {
					const e$2 = t.aN(i$1, 1, s$1.zoom);
					n$1 = !0, l$1 = [e$2, e$2], c$1 = e$2 / (t.a5 * Math.pow(2, i$1.tileID.overscaledZ)) * 2 * Math.PI * r$1;
				} else n$1 = !1, l$1 = s$1.pixelsToGLUnits;
				return {
					u_camera_to_center_distance: s$1.cameraToCenterDistance,
					u_scale_with_map: +("map" === a$1.paint.get("circle-pitch-scale")),
					u_pitch_with_map: +n$1,
					u_device_pixel_ratio: e$1.pixelRatio,
					u_extrude_scale: l$1,
					u_globe_extrude_scale: c$1,
					u_translate: o$1
				};
			}, Xi = (e$1) => ({ u_pixel_extrude_scale: [1 / e$1.width, 1 / e$1.height] }), Ki = (e$1) => ({ u_viewport_size: [e$1.width, e$1.height] }), Yi = (e$1, t$1 = 1) => ({
				u_color: e$1,
				u_overlay: 0,
				u_overlay_scale: t$1
			}), Qi = (e$1, i$1, a$1, o$1) => {
				const r$1 = t.aN(e$1, 1, i$1) / (t.a5 * Math.pow(2, e$1.tileID.overscaledZ)) * 2 * Math.PI * o$1;
				return {
					u_extrude_scale: t.aN(e$1, 1, i$1),
					u_intensity: a$1,
					u_globe_extrude_scale: r$1
				};
			}, Ji = (e$1, i$1, a$1, o$1) => {
				const r$1 = t.N();
				t.c7(r$1, 0, e$1.width, e$1.height, 0, 0, 1);
				const s$1 = e$1.context.gl;
				return {
					u_matrix: r$1,
					u_world: [s$1.drawingBufferWidth, s$1.drawingBufferHeight],
					u_image: a$1,
					u_color_ramp: o$1,
					u_opacity: i$1.paint.get("heatmap-opacity")
				};
			}, ea = (e$1, t$1, i$1) => {
				const a$1 = i$1.paint.get("hillshade-accent-color");
				let o$1;
				switch (i$1.paint.get("hillshade-method")) {
					case "basic":
						o$1 = 4;
						break;
					case "combined":
						o$1 = 1;
						break;
					case "igor":
						o$1 = 2;
						break;
					case "multidirectional":
						o$1 = 3;
						break;
					default: o$1 = 0;
				}
				const r$1 = i$1.getIlluminationProperties();
				for (let t$2 = 0; t$2 < r$1.directionRadians.length; t$2++) "viewport" === i$1.paint.get("hillshade-illumination-anchor") && (r$1.directionRadians[t$2] += e$1.transform.bearingInRadians);
				return {
					u_image: 0,
					u_latrange: ia(0, t$1.tileID),
					u_exaggeration: i$1.paint.get("hillshade-exaggeration"),
					u_altitudes: r$1.altitudeRadians,
					u_azimuths: r$1.directionRadians,
					u_accent: a$1,
					u_method: o$1,
					u_highlights: r$1.highlightColor,
					u_shadows: r$1.shadowColor
				};
			}, ta = (e$1, i$1) => {
				const a$1 = i$1.stride, o$1 = t.N();
				return t.c7(o$1, 0, t.a5, -t.a5, 0, 0, 1), t.O(o$1, o$1, [
					0,
					-t.a5,
					0
				]), {
					u_matrix: o$1,
					u_image: 1,
					u_dimension: [a$1, a$1],
					u_zoom: e$1.overscaledZ,
					u_unpack: i$1.getUnpackVector()
				};
			};
			function ia(e$1, i$1) {
				const a$1 = Math.pow(2, i$1.canonical.z), o$1 = i$1.canonical.y;
				return [new t.a9(0, o$1 / a$1).toLngLat().lat, new t.a9(0, (o$1 + 1) / a$1).toLngLat().lat];
			}
			const aa = (e$1, t$1, i$1 = 0) => ({
				u_image: 0,
				u_unpack: t$1.getUnpackVector(),
				u_dimension: [t$1.stride, t$1.stride],
				u_elevation_stops: 1,
				u_color_stops: 4,
				u_color_ramp_size: i$1,
				u_opacity: e$1.paint.get("color-relief-opacity")
			}), oa = (e$1, i$1, a$1, o$1) => {
				const r$1 = e$1.transform;
				return {
					u_translation: ha(e$1, i$1, a$1),
					u_ratio: o$1 / t.aN(i$1, 1, r$1.zoom),
					u_device_pixel_ratio: e$1.pixelRatio,
					u_units_to_pixels: [1 / r$1.pixelsToGLUnits[0], 1 / r$1.pixelsToGLUnits[1]]
				};
			}, ra = (e$1, i$1, a$1, o$1, r$1) => t.e(oa(e$1, i$1, a$1, o$1), {
				u_image: 0,
				u_image_height: r$1
			}), sa = (e$1, i$1, a$1, o$1, r$1) => {
				const s$1 = e$1.transform, n$1 = ca(i$1, s$1);
				return {
					u_translation: ha(e$1, i$1, a$1),
					u_texsize: i$1.imageAtlasTexture.size,
					u_ratio: o$1 / t.aN(i$1, 1, s$1.zoom),
					u_device_pixel_ratio: e$1.pixelRatio,
					u_image: 0,
					u_scale: [
						n$1,
						r$1.fromScale,
						r$1.toScale
					],
					u_fade: r$1.t,
					u_units_to_pixels: [1 / s$1.pixelsToGLUnits[0], 1 / s$1.pixelsToGLUnits[1]]
				};
			}, na = (e$1, i$1, a$1, o$1, r$1) => {
				const s$1 = ca(i$1, e$1.transform);
				return t.e(oa(e$1, i$1, a$1, o$1), {
					u_tileratio: s$1,
					u_crossfade_from: r$1.fromScale,
					u_crossfade_to: r$1.toScale,
					u_image: 0,
					u_mix: r$1.t,
					u_lineatlas_width: e$1.lineAtlas.width,
					u_lineatlas_height: e$1.lineAtlas.height
				});
			}, la = (e$1, i$1, a$1, o$1, r$1, s$1) => {
				const n$1 = ca(i$1, e$1.transform);
				return t.e(oa(e$1, i$1, a$1, o$1), {
					u_image: 0,
					u_image_height: s$1,
					u_tileratio: n$1,
					u_crossfade_from: r$1.fromScale,
					u_crossfade_to: r$1.toScale,
					u_image_dash: 1,
					u_mix: r$1.t,
					u_lineatlas_width: e$1.lineAtlas.width,
					u_lineatlas_height: e$1.lineAtlas.height
				});
			};
			function ca(e$1, i$1) {
				return 1 / t.aN(e$1, 1, i$1.tileZoom);
			}
			function ha(e$1, i$1, a$1) {
				return t.aO(e$1.transform, i$1, a$1.paint.get("line-translate"), a$1.paint.get("line-translate-anchor"));
			}
			const ua = (e$1, t$1, i$1, a$1, o$1) => {
				return {
					u_tl_parent: e$1,
					u_scale_parent: t$1,
					u_buffer_scale: 1,
					u_fade_t: i$1.mix,
					u_opacity: i$1.opacity * a$1.paint.get("raster-opacity"),
					u_image0: 0,
					u_image1: 1,
					u_brightness_low: a$1.paint.get("raster-brightness-min"),
					u_brightness_high: a$1.paint.get("raster-brightness-max"),
					u_saturation_factor: (s$1 = a$1.paint.get("raster-saturation"), s$1 > 0 ? 1 - 1 / (1.001 - s$1) : -s$1),
					u_contrast_factor: (r$1 = a$1.paint.get("raster-contrast"), r$1 > 0 ? 1 / (1 - r$1) : 1 + r$1),
					u_spin_weights: da(a$1.paint.get("raster-hue-rotate")),
					u_coords_top: [
						o$1[0].x,
						o$1[0].y,
						o$1[1].x,
						o$1[1].y
					],
					u_coords_bottom: [
						o$1[3].x,
						o$1[3].y,
						o$1[2].x,
						o$1[2].y
					]
				};
				var r$1, s$1;
			};
			function da(e$1) {
				e$1 *= Math.PI / 180;
				const t$1 = Math.sin(e$1), i$1 = Math.cos(e$1);
				return [
					(2 * i$1 + 1) / 3,
					(-Math.sqrt(3) * t$1 - i$1 + 1) / 3,
					(Math.sqrt(3) * t$1 - i$1 + 1) / 3
				];
			}
			const _a = (e$1, t$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1) => {
				const _$1 = s$1.transform;
				return {
					u_is_size_zoom_constant: +("constant" === e$1 || "source" === e$1),
					u_is_size_feature_constant: +("constant" === e$1 || "camera" === e$1),
					u_size_t: t$1 ? t$1.uSizeT : 0,
					u_size: t$1 ? t$1.uSize : 0,
					u_camera_to_center_distance: _$1.cameraToCenterDistance,
					u_pitch: _$1.pitch / 360 * 2 * Math.PI,
					u_rotate_symbol: +i$1,
					u_aspect_ratio: _$1.width / _$1.height,
					u_fade_change: s$1.options.fadeDuration ? s$1.symbolFadeChange : 1,
					u_label_plane_matrix: n$1,
					u_coord_matrix: l$1,
					u_is_text: +h$1,
					u_pitch_with_map: +a$1,
					u_is_along_line: o$1,
					u_is_variable_anchor: r$1,
					u_texsize: u$1,
					u_texture: 0,
					u_translation: c$1,
					u_pitched_scale: d$1
				};
			}, pa = (e$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$1, p$1) => {
				const m$1 = n$1.transform;
				return t.e(_a(e$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, p$1), {
					u_gamma_scale: o$1 ? Math.cos(m$1.pitch * Math.PI / 180) * m$1.cameraToCenterDistance : 1,
					u_device_pixel_ratio: n$1.pixelRatio,
					u_is_halo: 1
				});
			}, ma = (e$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$1) => t.e(pa(e$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1, c$1, h$1, !0, u$1, 0, _$1), {
				u_texsize_icon: d$1,
				u_texture_icon: 1
			}), fa = (e$1, t$1) => ({
				u_opacity: e$1,
				u_color: t$1
			}), ga = (e$1, i$1, a$1, o$1, r$1) => t.e(function(e$2, i$2, a$2, o$2) {
				const r$2 = a$2.imageManager.getPattern(e$2.from.toString()), s$1 = a$2.imageManager.getPattern(e$2.to.toString()), { width: n$1, height: l$1 } = a$2.imageManager.getPixelSize(), c$1 = Math.pow(2, o$2.tileID.overscaledZ), h$1 = o$2.tileSize * Math.pow(2, a$2.transform.tileZoom) / c$1, u$1 = h$1 * (o$2.tileID.canonical.x + o$2.tileID.wrap * c$1), d$1 = h$1 * o$2.tileID.canonical.y;
				return {
					u_image: 0,
					u_pattern_tl_a: r$2.tl,
					u_pattern_br_a: r$2.br,
					u_pattern_tl_b: s$1.tl,
					u_pattern_br_b: s$1.br,
					u_texsize: [n$1, l$1],
					u_mix: i$2.t,
					u_pattern_size_a: r$2.displaySize,
					u_pattern_size_b: s$1.displaySize,
					u_scale_a: i$2.fromScale,
					u_scale_b: i$2.toScale,
					u_tile_units_to_pixels: 1 / t.aN(o$2, 1, a$2.transform.tileZoom),
					u_pixel_coord_upper: [u$1 >> 16, d$1 >> 16],
					u_pixel_coord_lower: [65535 & u$1, 65535 & d$1]
				};
			}(a$1, r$1, i$1, o$1), { u_opacity: e$1 }), va = (e$1, t$1) => {}, xa = {
				fillExtrusion: (e$1, i$1) => ({
					u_lightpos: new t.c2(e$1, i$1.u_lightpos),
					u_lightpos_globe: new t.c2(e$1, i$1.u_lightpos_globe),
					u_lightintensity: new t.bq(e$1, i$1.u_lightintensity),
					u_lightcolor: new t.c2(e$1, i$1.u_lightcolor),
					u_vertical_gradient: new t.bq(e$1, i$1.u_vertical_gradient),
					u_opacity: new t.bq(e$1, i$1.u_opacity),
					u_fill_translate: new t.c3(e$1, i$1.u_fill_translate)
				}),
				fillExtrusionPattern: (e$1, i$1) => ({
					u_lightpos: new t.c2(e$1, i$1.u_lightpos),
					u_lightpos_globe: new t.c2(e$1, i$1.u_lightpos_globe),
					u_lightintensity: new t.bq(e$1, i$1.u_lightintensity),
					u_lightcolor: new t.c2(e$1, i$1.u_lightcolor),
					u_vertical_gradient: new t.bq(e$1, i$1.u_vertical_gradient),
					u_height_factor: new t.bq(e$1, i$1.u_height_factor),
					u_opacity: new t.bq(e$1, i$1.u_opacity),
					u_fill_translate: new t.c3(e$1, i$1.u_fill_translate),
					u_image: new t.b_(e$1, i$1.u_image),
					u_texsize: new t.c3(e$1, i$1.u_texsize),
					u_pixel_coord_upper: new t.c3(e$1, i$1.u_pixel_coord_upper),
					u_pixel_coord_lower: new t.c3(e$1, i$1.u_pixel_coord_lower),
					u_scale: new t.c2(e$1, i$1.u_scale),
					u_fade: new t.bq(e$1, i$1.u_fade)
				}),
				fill: (e$1, i$1) => ({ u_fill_translate: new t.c3(e$1, i$1.u_fill_translate) }),
				fillPattern: (e$1, i$1) => ({
					u_image: new t.b_(e$1, i$1.u_image),
					u_texsize: new t.c3(e$1, i$1.u_texsize),
					u_pixel_coord_upper: new t.c3(e$1, i$1.u_pixel_coord_upper),
					u_pixel_coord_lower: new t.c3(e$1, i$1.u_pixel_coord_lower),
					u_scale: new t.c2(e$1, i$1.u_scale),
					u_fade: new t.bq(e$1, i$1.u_fade),
					u_fill_translate: new t.c3(e$1, i$1.u_fill_translate)
				}),
				fillOutline: (e$1, i$1) => ({
					u_world: new t.c3(e$1, i$1.u_world),
					u_fill_translate: new t.c3(e$1, i$1.u_fill_translate)
				}),
				fillOutlinePattern: (e$1, i$1) => ({
					u_world: new t.c3(e$1, i$1.u_world),
					u_image: new t.b_(e$1, i$1.u_image),
					u_texsize: new t.c3(e$1, i$1.u_texsize),
					u_pixel_coord_upper: new t.c3(e$1, i$1.u_pixel_coord_upper),
					u_pixel_coord_lower: new t.c3(e$1, i$1.u_pixel_coord_lower),
					u_scale: new t.c2(e$1, i$1.u_scale),
					u_fade: new t.bq(e$1, i$1.u_fade),
					u_fill_translate: new t.c3(e$1, i$1.u_fill_translate)
				}),
				circle: (e$1, i$1) => ({
					u_camera_to_center_distance: new t.bq(e$1, i$1.u_camera_to_center_distance),
					u_scale_with_map: new t.b_(e$1, i$1.u_scale_with_map),
					u_pitch_with_map: new t.b_(e$1, i$1.u_pitch_with_map),
					u_extrude_scale: new t.c3(e$1, i$1.u_extrude_scale),
					u_device_pixel_ratio: new t.bq(e$1, i$1.u_device_pixel_ratio),
					u_globe_extrude_scale: new t.bq(e$1, i$1.u_globe_extrude_scale),
					u_translate: new t.c3(e$1, i$1.u_translate)
				}),
				collisionBox: (e$1, i$1) => ({ u_pixel_extrude_scale: new t.c3(e$1, i$1.u_pixel_extrude_scale) }),
				collisionCircle: (e$1, i$1) => ({ u_viewport_size: new t.c3(e$1, i$1.u_viewport_size) }),
				debug: (e$1, i$1) => ({
					u_color: new t.b$(e$1, i$1.u_color),
					u_overlay: new t.b_(e$1, i$1.u_overlay),
					u_overlay_scale: new t.bq(e$1, i$1.u_overlay_scale)
				}),
				depth: va,
				clippingMask: va,
				heatmap: (e$1, i$1) => ({
					u_extrude_scale: new t.bq(e$1, i$1.u_extrude_scale),
					u_intensity: new t.bq(e$1, i$1.u_intensity),
					u_globe_extrude_scale: new t.bq(e$1, i$1.u_globe_extrude_scale)
				}),
				heatmapTexture: (e$1, i$1) => ({
					u_matrix: new t.c0(e$1, i$1.u_matrix),
					u_world: new t.c3(e$1, i$1.u_world),
					u_image: new t.b_(e$1, i$1.u_image),
					u_color_ramp: new t.b_(e$1, i$1.u_color_ramp),
					u_opacity: new t.bq(e$1, i$1.u_opacity)
				}),
				hillshade: (e$1, i$1) => ({
					u_image: new t.b_(e$1, i$1.u_image),
					u_latrange: new t.c3(e$1, i$1.u_latrange),
					u_exaggeration: new t.bq(e$1, i$1.u_exaggeration),
					u_altitudes: new t.c9(e$1, i$1.u_altitudes),
					u_azimuths: new t.c9(e$1, i$1.u_azimuths),
					u_accent: new t.b$(e$1, i$1.u_accent),
					u_method: new t.b_(e$1, i$1.u_method),
					u_shadows: new t.c8(e$1, i$1.u_shadows),
					u_highlights: new t.c8(e$1, i$1.u_highlights)
				}),
				hillshadePrepare: (e$1, i$1) => ({
					u_matrix: new t.c0(e$1, i$1.u_matrix),
					u_image: new t.b_(e$1, i$1.u_image),
					u_dimension: new t.c3(e$1, i$1.u_dimension),
					u_zoom: new t.bq(e$1, i$1.u_zoom),
					u_unpack: new t.c1(e$1, i$1.u_unpack)
				}),
				colorRelief: (e$1, i$1) => ({
					u_image: new t.b_(e$1, i$1.u_image),
					u_unpack: new t.c1(e$1, i$1.u_unpack),
					u_dimension: new t.c3(e$1, i$1.u_dimension),
					u_elevation_stops: new t.b_(e$1, i$1.u_elevation_stops),
					u_color_stops: new t.b_(e$1, i$1.u_color_stops),
					u_color_ramp_size: new t.b_(e$1, i$1.u_color_ramp_size),
					u_opacity: new t.bq(e$1, i$1.u_opacity)
				}),
				line: (e$1, i$1) => ({
					u_translation: new t.c3(e$1, i$1.u_translation),
					u_ratio: new t.bq(e$1, i$1.u_ratio),
					u_device_pixel_ratio: new t.bq(e$1, i$1.u_device_pixel_ratio),
					u_units_to_pixels: new t.c3(e$1, i$1.u_units_to_pixels)
				}),
				lineGradient: (e$1, i$1) => ({
					u_translation: new t.c3(e$1, i$1.u_translation),
					u_ratio: new t.bq(e$1, i$1.u_ratio),
					u_device_pixel_ratio: new t.bq(e$1, i$1.u_device_pixel_ratio),
					u_units_to_pixels: new t.c3(e$1, i$1.u_units_to_pixels),
					u_image: new t.b_(e$1, i$1.u_image),
					u_image_height: new t.bq(e$1, i$1.u_image_height)
				}),
				linePattern: (e$1, i$1) => ({
					u_translation: new t.c3(e$1, i$1.u_translation),
					u_texsize: new t.c3(e$1, i$1.u_texsize),
					u_ratio: new t.bq(e$1, i$1.u_ratio),
					u_device_pixel_ratio: new t.bq(e$1, i$1.u_device_pixel_ratio),
					u_image: new t.b_(e$1, i$1.u_image),
					u_units_to_pixels: new t.c3(e$1, i$1.u_units_to_pixels),
					u_scale: new t.c2(e$1, i$1.u_scale),
					u_fade: new t.bq(e$1, i$1.u_fade)
				}),
				lineSDF: (e$1, i$1) => ({
					u_translation: new t.c3(e$1, i$1.u_translation),
					u_ratio: new t.bq(e$1, i$1.u_ratio),
					u_device_pixel_ratio: new t.bq(e$1, i$1.u_device_pixel_ratio),
					u_units_to_pixels: new t.c3(e$1, i$1.u_units_to_pixels),
					u_image: new t.b_(e$1, i$1.u_image),
					u_mix: new t.bq(e$1, i$1.u_mix),
					u_tileratio: new t.bq(e$1, i$1.u_tileratio),
					u_crossfade_from: new t.bq(e$1, i$1.u_crossfade_from),
					u_crossfade_to: new t.bq(e$1, i$1.u_crossfade_to),
					u_lineatlas_width: new t.bq(e$1, i$1.u_lineatlas_width),
					u_lineatlas_height: new t.bq(e$1, i$1.u_lineatlas_height)
				}),
				lineGradientSDF: (e$1, i$1) => ({
					u_translation: new t.c3(e$1, i$1.u_translation),
					u_ratio: new t.bq(e$1, i$1.u_ratio),
					u_device_pixel_ratio: new t.bq(e$1, i$1.u_device_pixel_ratio),
					u_units_to_pixels: new t.c3(e$1, i$1.u_units_to_pixels),
					u_image: new t.b_(e$1, i$1.u_image),
					u_image_height: new t.bq(e$1, i$1.u_image_height),
					u_tileratio: new t.bq(e$1, i$1.u_tileratio),
					u_crossfade_from: new t.bq(e$1, i$1.u_crossfade_from),
					u_crossfade_to: new t.bq(e$1, i$1.u_crossfade_to),
					u_image_dash: new t.b_(e$1, i$1.u_image_dash),
					u_mix: new t.bq(e$1, i$1.u_mix),
					u_lineatlas_width: new t.bq(e$1, i$1.u_lineatlas_width),
					u_lineatlas_height: new t.bq(e$1, i$1.u_lineatlas_height)
				}),
				raster: (e$1, i$1) => ({
					u_tl_parent: new t.c3(e$1, i$1.u_tl_parent),
					u_scale_parent: new t.bq(e$1, i$1.u_scale_parent),
					u_buffer_scale: new t.bq(e$1, i$1.u_buffer_scale),
					u_fade_t: new t.bq(e$1, i$1.u_fade_t),
					u_opacity: new t.bq(e$1, i$1.u_opacity),
					u_image0: new t.b_(e$1, i$1.u_image0),
					u_image1: new t.b_(e$1, i$1.u_image1),
					u_brightness_low: new t.bq(e$1, i$1.u_brightness_low),
					u_brightness_high: new t.bq(e$1, i$1.u_brightness_high),
					u_saturation_factor: new t.bq(e$1, i$1.u_saturation_factor),
					u_contrast_factor: new t.bq(e$1, i$1.u_contrast_factor),
					u_spin_weights: new t.c2(e$1, i$1.u_spin_weights),
					u_coords_top: new t.c1(e$1, i$1.u_coords_top),
					u_coords_bottom: new t.c1(e$1, i$1.u_coords_bottom)
				}),
				symbolIcon: (e$1, i$1) => ({
					u_is_size_zoom_constant: new t.b_(e$1, i$1.u_is_size_zoom_constant),
					u_is_size_feature_constant: new t.b_(e$1, i$1.u_is_size_feature_constant),
					u_size_t: new t.bq(e$1, i$1.u_size_t),
					u_size: new t.bq(e$1, i$1.u_size),
					u_camera_to_center_distance: new t.bq(e$1, i$1.u_camera_to_center_distance),
					u_pitch: new t.bq(e$1, i$1.u_pitch),
					u_rotate_symbol: new t.b_(e$1, i$1.u_rotate_symbol),
					u_aspect_ratio: new t.bq(e$1, i$1.u_aspect_ratio),
					u_fade_change: new t.bq(e$1, i$1.u_fade_change),
					u_label_plane_matrix: new t.c0(e$1, i$1.u_label_plane_matrix),
					u_coord_matrix: new t.c0(e$1, i$1.u_coord_matrix),
					u_is_text: new t.b_(e$1, i$1.u_is_text),
					u_pitch_with_map: new t.b_(e$1, i$1.u_pitch_with_map),
					u_is_along_line: new t.b_(e$1, i$1.u_is_along_line),
					u_is_variable_anchor: new t.b_(e$1, i$1.u_is_variable_anchor),
					u_texsize: new t.c3(e$1, i$1.u_texsize),
					u_texture: new t.b_(e$1, i$1.u_texture),
					u_translation: new t.c3(e$1, i$1.u_translation),
					u_pitched_scale: new t.bq(e$1, i$1.u_pitched_scale)
				}),
				symbolSDF: (e$1, i$1) => ({
					u_is_size_zoom_constant: new t.b_(e$1, i$1.u_is_size_zoom_constant),
					u_is_size_feature_constant: new t.b_(e$1, i$1.u_is_size_feature_constant),
					u_size_t: new t.bq(e$1, i$1.u_size_t),
					u_size: new t.bq(e$1, i$1.u_size),
					u_camera_to_center_distance: new t.bq(e$1, i$1.u_camera_to_center_distance),
					u_pitch: new t.bq(e$1, i$1.u_pitch),
					u_rotate_symbol: new t.b_(e$1, i$1.u_rotate_symbol),
					u_aspect_ratio: new t.bq(e$1, i$1.u_aspect_ratio),
					u_fade_change: new t.bq(e$1, i$1.u_fade_change),
					u_label_plane_matrix: new t.c0(e$1, i$1.u_label_plane_matrix),
					u_coord_matrix: new t.c0(e$1, i$1.u_coord_matrix),
					u_is_text: new t.b_(e$1, i$1.u_is_text),
					u_pitch_with_map: new t.b_(e$1, i$1.u_pitch_with_map),
					u_is_along_line: new t.b_(e$1, i$1.u_is_along_line),
					u_is_variable_anchor: new t.b_(e$1, i$1.u_is_variable_anchor),
					u_texsize: new t.c3(e$1, i$1.u_texsize),
					u_texture: new t.b_(e$1, i$1.u_texture),
					u_gamma_scale: new t.bq(e$1, i$1.u_gamma_scale),
					u_device_pixel_ratio: new t.bq(e$1, i$1.u_device_pixel_ratio),
					u_is_halo: new t.b_(e$1, i$1.u_is_halo),
					u_translation: new t.c3(e$1, i$1.u_translation),
					u_pitched_scale: new t.bq(e$1, i$1.u_pitched_scale)
				}),
				symbolTextAndIcon: (e$1, i$1) => ({
					u_is_size_zoom_constant: new t.b_(e$1, i$1.u_is_size_zoom_constant),
					u_is_size_feature_constant: new t.b_(e$1, i$1.u_is_size_feature_constant),
					u_size_t: new t.bq(e$1, i$1.u_size_t),
					u_size: new t.bq(e$1, i$1.u_size),
					u_camera_to_center_distance: new t.bq(e$1, i$1.u_camera_to_center_distance),
					u_pitch: new t.bq(e$1, i$1.u_pitch),
					u_rotate_symbol: new t.b_(e$1, i$1.u_rotate_symbol),
					u_aspect_ratio: new t.bq(e$1, i$1.u_aspect_ratio),
					u_fade_change: new t.bq(e$1, i$1.u_fade_change),
					u_label_plane_matrix: new t.c0(e$1, i$1.u_label_plane_matrix),
					u_coord_matrix: new t.c0(e$1, i$1.u_coord_matrix),
					u_is_text: new t.b_(e$1, i$1.u_is_text),
					u_pitch_with_map: new t.b_(e$1, i$1.u_pitch_with_map),
					u_is_along_line: new t.b_(e$1, i$1.u_is_along_line),
					u_is_variable_anchor: new t.b_(e$1, i$1.u_is_variable_anchor),
					u_texsize: new t.c3(e$1, i$1.u_texsize),
					u_texsize_icon: new t.c3(e$1, i$1.u_texsize_icon),
					u_texture: new t.b_(e$1, i$1.u_texture),
					u_texture_icon: new t.b_(e$1, i$1.u_texture_icon),
					u_gamma_scale: new t.bq(e$1, i$1.u_gamma_scale),
					u_device_pixel_ratio: new t.bq(e$1, i$1.u_device_pixel_ratio),
					u_is_halo: new t.b_(e$1, i$1.u_is_halo),
					u_translation: new t.c3(e$1, i$1.u_translation),
					u_pitched_scale: new t.bq(e$1, i$1.u_pitched_scale)
				}),
				background: (e$1, i$1) => ({
					u_opacity: new t.bq(e$1, i$1.u_opacity),
					u_color: new t.b$(e$1, i$1.u_color)
				}),
				backgroundPattern: (e$1, i$1) => ({
					u_opacity: new t.bq(e$1, i$1.u_opacity),
					u_image: new t.b_(e$1, i$1.u_image),
					u_pattern_tl_a: new t.c3(e$1, i$1.u_pattern_tl_a),
					u_pattern_br_a: new t.c3(e$1, i$1.u_pattern_br_a),
					u_pattern_tl_b: new t.c3(e$1, i$1.u_pattern_tl_b),
					u_pattern_br_b: new t.c3(e$1, i$1.u_pattern_br_b),
					u_texsize: new t.c3(e$1, i$1.u_texsize),
					u_mix: new t.bq(e$1, i$1.u_mix),
					u_pattern_size_a: new t.c3(e$1, i$1.u_pattern_size_a),
					u_pattern_size_b: new t.c3(e$1, i$1.u_pattern_size_b),
					u_scale_a: new t.bq(e$1, i$1.u_scale_a),
					u_scale_b: new t.bq(e$1, i$1.u_scale_b),
					u_pixel_coord_upper: new t.c3(e$1, i$1.u_pixel_coord_upper),
					u_pixel_coord_lower: new t.c3(e$1, i$1.u_pixel_coord_lower),
					u_tile_units_to_pixels: new t.bq(e$1, i$1.u_tile_units_to_pixels)
				}),
				terrain: (e$1, i$1) => ({
					u_texture: new t.b_(e$1, i$1.u_texture),
					u_ele_delta: new t.bq(e$1, i$1.u_ele_delta),
					u_fog_matrix: new t.c0(e$1, i$1.u_fog_matrix),
					u_fog_color: new t.b$(e$1, i$1.u_fog_color),
					u_fog_ground_blend: new t.bq(e$1, i$1.u_fog_ground_blend),
					u_fog_ground_blend_opacity: new t.bq(e$1, i$1.u_fog_ground_blend_opacity),
					u_horizon_color: new t.b$(e$1, i$1.u_horizon_color),
					u_horizon_fog_blend: new t.bq(e$1, i$1.u_horizon_fog_blend),
					u_is_globe_mode: new t.bq(e$1, i$1.u_is_globe_mode)
				}),
				terrainDepth: (e$1, i$1) => ({ u_ele_delta: new t.bq(e$1, i$1.u_ele_delta) }),
				terrainCoords: (e$1, i$1) => ({
					u_texture: new t.b_(e$1, i$1.u_texture),
					u_terrain_coords_id: new t.bq(e$1, i$1.u_terrain_coords_id),
					u_ele_delta: new t.bq(e$1, i$1.u_ele_delta)
				}),
				projectionErrorMeasurement: (e$1, i$1) => ({
					u_input: new t.bq(e$1, i$1.u_input),
					u_output_expected: new t.bq(e$1, i$1.u_output_expected)
				}),
				atmosphere: (e$1, i$1) => ({
					u_sun_pos: new t.c2(e$1, i$1.u_sun_pos),
					u_atmosphere_blend: new t.bq(e$1, i$1.u_atmosphere_blend),
					u_globe_position: new t.c2(e$1, i$1.u_globe_position),
					u_globe_radius: new t.bq(e$1, i$1.u_globe_radius),
					u_inv_proj_matrix: new t.c0(e$1, i$1.u_inv_proj_matrix)
				}),
				sky: (e$1, i$1) => ({
					u_sky_color: new t.b$(e$1, i$1.u_sky_color),
					u_horizon_color: new t.b$(e$1, i$1.u_horizon_color),
					u_horizon: new t.c3(e$1, i$1.u_horizon),
					u_horizon_normal: new t.c3(e$1, i$1.u_horizon_normal),
					u_sky_horizon_blend: new t.bq(e$1, i$1.u_sky_horizon_blend),
					u_sky_blend: new t.bq(e$1, i$1.u_sky_blend)
				})
			};
			class ba {
				constructor(e$1, t$1, i$1) {
					this.context = e$1;
					const a$1 = e$1.gl;
					this.buffer = a$1.createBuffer(), this.dynamicDraw = Boolean(i$1), this.context.unbindVAO(), e$1.bindElementBuffer.set(this.buffer), a$1.bufferData(a$1.ELEMENT_ARRAY_BUFFER, t$1.arrayBuffer, this.dynamicDraw ? a$1.DYNAMIC_DRAW : a$1.STATIC_DRAW), this.dynamicDraw || delete t$1.arrayBuffer;
				}
				bind() {
					this.context.bindElementBuffer.set(this.buffer);
				}
				updateData(e$1) {
					const t$1 = this.context.gl;
					if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
					this.context.unbindVAO(), this.bind(), t$1.bufferSubData(t$1.ELEMENT_ARRAY_BUFFER, 0, e$1.arrayBuffer);
				}
				destroy() {
					this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
				}
			}
			const ya = {
				Int8: "BYTE",
				Uint8: "UNSIGNED_BYTE",
				Int16: "SHORT",
				Uint16: "UNSIGNED_SHORT",
				Int32: "INT",
				Uint32: "UNSIGNED_INT",
				Float32: "FLOAT"
			};
			class wa {
				constructor(e$1, t$1, i$1, a$1) {
					this.length = t$1.length, this.attributes = i$1, this.itemSize = t$1.bytesPerElement, this.dynamicDraw = a$1, this.context = e$1;
					const o$1 = e$1.gl;
					this.buffer = o$1.createBuffer(), e$1.bindVertexBuffer.set(this.buffer), o$1.bufferData(o$1.ARRAY_BUFFER, t$1.arrayBuffer, this.dynamicDraw ? o$1.DYNAMIC_DRAW : o$1.STATIC_DRAW), this.dynamicDraw || delete t$1.arrayBuffer;
				}
				bind() {
					this.context.bindVertexBuffer.set(this.buffer);
				}
				updateData(e$1) {
					if (e$1.length !== this.length) throw new Error(`Length of new data is ${e$1.length}, which doesn't match current length of ${this.length}`);
					const t$1 = this.context.gl;
					this.bind(), t$1.bufferSubData(t$1.ARRAY_BUFFER, 0, e$1.arrayBuffer);
				}
				enableAttributes(e$1, t$1) {
					for (let i$1 = 0; i$1 < this.attributes.length; i$1++) {
						const a$1 = t$1.attributes[this.attributes[i$1].name];
						void 0 !== a$1 && e$1.enableVertexAttribArray(a$1);
					}
				}
				setVertexAttribPointers(e$1, t$1, i$1) {
					for (let a$1 = 0; a$1 < this.attributes.length; a$1++) {
						const o$1 = this.attributes[a$1], r$1 = t$1.attributes[o$1.name];
						void 0 !== r$1 && e$1.vertexAttribPointer(r$1, o$1.components, e$1[ya[o$1.type]], !1, this.itemSize, o$1.offset + this.itemSize * (i$1 || 0));
					}
				}
				destroy() {
					this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
				}
			}
			class Ta {
				constructor(e$1) {
					this.gl = e$1.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
				}
				get() {
					return this.current;
				}
				set(e$1) {}
				getDefault() {
					return this.default;
				}
				setDefault() {
					this.set(this.default);
				}
			}
			class Pa extends Ta {
				getDefault() {
					return t.bp.transparent;
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1.r !== t$1.r || e$1.g !== t$1.g || e$1.b !== t$1.b || e$1.a !== t$1.a || this.dirty) && (this.gl.clearColor(e$1.r, e$1.g, e$1.b, e$1.a), this.current = e$1, this.dirty = !1);
				}
			}
			class Ca extends Ta {
				getDefault() {
					return 1;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.clearDepth(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Ia extends Ta {
				getDefault() {
					return 0;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.clearStencil(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Ma extends Ta {
				getDefault() {
					return [
						!0,
						!0,
						!0,
						!0
					];
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1[0] !== t$1[0] || e$1[1] !== t$1[1] || e$1[2] !== t$1[2] || e$1[3] !== t$1[3] || this.dirty) && (this.gl.colorMask(e$1[0], e$1[1], e$1[2], e$1[3]), this.current = e$1, this.dirty = !1);
				}
			}
			class Ea extends Ta {
				getDefault() {
					return !0;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.depthMask(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Sa extends Ta {
				getDefault() {
					return 255;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.stencilMask(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class za extends Ta {
				getDefault() {
					return {
						func: this.gl.ALWAYS,
						ref: 0,
						mask: 255
					};
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1.func !== t$1.func || e$1.ref !== t$1.ref || e$1.mask !== t$1.mask || this.dirty) && (this.gl.stencilFunc(e$1.func, e$1.ref, e$1.mask), this.current = e$1, this.dirty = !1);
				}
			}
			class Ra extends Ta {
				getDefault() {
					const e$1 = this.gl;
					return [
						e$1.KEEP,
						e$1.KEEP,
						e$1.KEEP
					];
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1[0] !== t$1[0] || e$1[1] !== t$1[1] || e$1[2] !== t$1[2] || this.dirty) && (this.gl.stencilOp(e$1[0], e$1[1], e$1[2]), this.current = e$1, this.dirty = !1);
				}
			}
			class Da extends Ta {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					e$1 ? t$1.enable(t$1.STENCIL_TEST) : t$1.disable(t$1.STENCIL_TEST), this.current = e$1, this.dirty = !1;
				}
			}
			class Aa extends Ta {
				getDefault() {
					return [0, 1];
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1[0] !== t$1[0] || e$1[1] !== t$1[1] || this.dirty) && (this.gl.depthRange(e$1[0], e$1[1]), this.current = e$1, this.dirty = !1);
				}
			}
			class La extends Ta {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					e$1 ? t$1.enable(t$1.DEPTH_TEST) : t$1.disable(t$1.DEPTH_TEST), this.current = e$1, this.dirty = !1;
				}
			}
			class ka extends Ta {
				getDefault() {
					return this.gl.LESS;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.depthFunc(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Fa extends Ta {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					e$1 ? t$1.enable(t$1.BLEND) : t$1.disable(t$1.BLEND), this.current = e$1, this.dirty = !1;
				}
			}
			class Ba extends Ta {
				getDefault() {
					const e$1 = this.gl;
					return [e$1.ONE, e$1.ZERO];
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1[0] !== t$1[0] || e$1[1] !== t$1[1] || this.dirty) && (this.gl.blendFunc(e$1[0], e$1[1]), this.current = e$1, this.dirty = !1);
				}
			}
			class Oa extends Ta {
				getDefault() {
					return t.bp.transparent;
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1.r !== t$1.r || e$1.g !== t$1.g || e$1.b !== t$1.b || e$1.a !== t$1.a || this.dirty) && (this.gl.blendColor(e$1.r, e$1.g, e$1.b, e$1.a), this.current = e$1, this.dirty = !1);
				}
			}
			class ja extends Ta {
				getDefault() {
					return this.gl.FUNC_ADD;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.blendEquation(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Na extends Ta {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					e$1 ? t$1.enable(t$1.CULL_FACE) : t$1.disable(t$1.CULL_FACE), this.current = e$1, this.dirty = !1;
				}
			}
			class Za extends Ta {
				getDefault() {
					return this.gl.BACK;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.cullFace(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Ua extends Ta {
				getDefault() {
					return this.gl.CCW;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.frontFace(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Ga extends Ta {
				getDefault() {
					return null;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.useProgram(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Va extends Ta {
				getDefault() {
					return this.gl.TEXTURE0;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.activeTexture(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class qa extends Ta {
				getDefault() {
					const e$1 = this.gl;
					return [
						0,
						0,
						e$1.drawingBufferWidth,
						e$1.drawingBufferHeight
					];
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1[0] !== t$1[0] || e$1[1] !== t$1[1] || e$1[2] !== t$1[2] || e$1[3] !== t$1[3] || this.dirty) && (this.gl.viewport(e$1[0], e$1[1], e$1[2], e$1[3]), this.current = e$1, this.dirty = !1);
				}
			}
			class Wa extends Ta {
				getDefault() {
					return null;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.bindFramebuffer(t$1.FRAMEBUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class $a extends Ta {
				getDefault() {
					return null;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.bindRenderbuffer(t$1.RENDERBUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Ha extends Ta {
				getDefault() {
					return null;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.bindTexture(t$1.TEXTURE_2D, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Xa extends Ta {
				getDefault() {
					return null;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.bindBuffer(t$1.ARRAY_BUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Ka extends Ta {
				getDefault() {
					return null;
				}
				set(e$1) {
					const t$1 = this.gl;
					t$1.bindBuffer(t$1.ELEMENT_ARRAY_BUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Ya extends Ta {
				getDefault() {
					return null;
				}
				set(e$1) {
					var t$1;
					if (e$1 === this.current && !this.dirty) return;
					const i$1 = this.gl;
					ri(i$1) ? i$1.bindVertexArray(e$1) : null === (t$1 = i$1.getExtension("OES_vertex_array_object")) || void 0 === t$1 || t$1.bindVertexArrayOES(e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Qa extends Ta {
				getDefault() {
					return 4;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.pixelStorei(t$1.UNPACK_ALIGNMENT, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Ja extends Ta {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.pixelStorei(t$1.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class eo extends Ta {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.pixelStorei(t$1.UNPACK_FLIP_Y_WEBGL, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class to extends Ta {
				constructor(e$1, t$1) {
					super(e$1), this.context = e$1, this.parent = t$1;
				}
				getDefault() {
					return null;
				}
			}
			class io extends to {
				setDirty() {
					this.dirty = !0;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					this.context.bindFramebuffer.set(this.parent);
					const t$1 = this.gl;
					t$1.framebufferTexture2D(t$1.FRAMEBUFFER, t$1.COLOR_ATTACHMENT0, t$1.TEXTURE_2D, e$1, 0), this.current = e$1, this.dirty = !1;
				}
			}
			class ao extends to {
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					this.context.bindFramebuffer.set(this.parent);
					const t$1 = this.gl;
					t$1.framebufferRenderbuffer(t$1.FRAMEBUFFER, t$1.DEPTH_ATTACHMENT, t$1.RENDERBUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class oo extends to {
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					this.context.bindFramebuffer.set(this.parent);
					const t$1 = this.gl;
					t$1.framebufferRenderbuffer(t$1.FRAMEBUFFER, t$1.DEPTH_STENCIL_ATTACHMENT, t$1.RENDERBUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			const ro = "Framebuffer is not complete";
			class so {
				constructor(e$1, t$1, i$1, a$1, o$1) {
					this.context = e$1, this.width = t$1, this.height = i$1;
					const r$1 = e$1.gl, s$1 = this.framebuffer = r$1.createFramebuffer();
					if (this.colorAttachment = new io(e$1, s$1), a$1) this.depthAttachment = o$1 ? new oo(e$1, s$1) : new ao(e$1, s$1);
					else if (o$1) throw new Error("Stencil cannot be set without depth");
					if (r$1.checkFramebufferStatus(r$1.FRAMEBUFFER) !== r$1.FRAMEBUFFER_COMPLETE) throw new Error(ro);
				}
				destroy() {
					const e$1 = this.context.gl, t$1 = this.colorAttachment.get();
					if (t$1 && e$1.deleteTexture(t$1), this.depthAttachment) {
						const t$2 = this.depthAttachment.get();
						t$2 && e$1.deleteRenderbuffer(t$2);
					}
					e$1.deleteFramebuffer(this.framebuffer);
				}
			}
			class no {
				constructor(e$1) {
					var t$1, i$1;
					if (this.gl = e$1, this.clearColor = new Pa(this), this.clearDepth = new Ca(this), this.clearStencil = new Ia(this), this.colorMask = new Ma(this), this.depthMask = new Ea(this), this.stencilMask = new Sa(this), this.stencilFunc = new za(this), this.stencilOp = new Ra(this), this.stencilTest = new Da(this), this.depthRange = new Aa(this), this.depthTest = new La(this), this.depthFunc = new ka(this), this.blend = new Fa(this), this.blendFunc = new Ba(this), this.blendColor = new Oa(this), this.blendEquation = new ja(this), this.cullFace = new Na(this), this.cullFaceSide = new Za(this), this.frontFace = new Ua(this), this.program = new Ga(this), this.activeTexture = new Va(this), this.viewport = new qa(this), this.bindFramebuffer = new Wa(this), this.bindRenderbuffer = new $a(this), this.bindTexture = new Ha(this), this.bindVertexBuffer = new Xa(this), this.bindElementBuffer = new Ka(this), this.bindVertexArray = new Ya(this), this.pixelStoreUnpack = new Qa(this), this.pixelStoreUnpackPremultiplyAlpha = new Ja(this), this.pixelStoreUnpackFlipY = new eo(this), this.extTextureFilterAnisotropic = e$1.getExtension("EXT_texture_filter_anisotropic") || e$1.getExtension("MOZ_EXT_texture_filter_anisotropic") || e$1.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e$1.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e$1.getParameter(e$1.MAX_TEXTURE_SIZE), ri(e$1)) {
						this.HALF_FLOAT = e$1.HALF_FLOAT;
						const a$1 = e$1.getExtension("EXT_color_buffer_half_float");
						this.RGBA16F = null !== (t$1 = e$1.RGBA16F) && void 0 !== t$1 ? t$1 : null == a$1 ? void 0 : a$1.RGBA16F_EXT, this.RGB16F = null !== (i$1 = e$1.RGB16F) && void 0 !== i$1 ? i$1 : null == a$1 ? void 0 : a$1.RGB16F_EXT, e$1.getExtension("EXT_color_buffer_float");
					} else {
						e$1.getExtension("EXT_color_buffer_half_float"), e$1.getExtension("OES_texture_half_float_linear");
						const t$2 = e$1.getExtension("OES_texture_half_float");
						this.HALF_FLOAT = null == t$2 ? void 0 : t$2.HALF_FLOAT_OES;
					}
				}
				setDefault() {
					this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
				}
				setDirty() {
					this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
				}
				createIndexBuffer(e$1, t$1) {
					return new ba(this, e$1, t$1);
				}
				createVertexBuffer(e$1, t$1, i$1) {
					return new wa(this, e$1, t$1, i$1);
				}
				createRenderbuffer(e$1, t$1, i$1) {
					const a$1 = this.gl, o$1 = a$1.createRenderbuffer();
					return this.bindRenderbuffer.set(o$1), a$1.renderbufferStorage(a$1.RENDERBUFFER, e$1, t$1, i$1), this.bindRenderbuffer.set(null), o$1;
				}
				createFramebuffer(e$1, t$1, i$1, a$1) {
					return new so(this, e$1, t$1, i$1, a$1);
				}
				clear({ color: e$1, depth: t$1, stencil: i$1 }) {
					const a$1 = this.gl;
					let o$1 = 0;
					e$1 && (o$1 |= a$1.COLOR_BUFFER_BIT, this.clearColor.set(e$1), this.colorMask.set([
						!0,
						!0,
						!0,
						!0
					])), void 0 !== t$1 && (o$1 |= a$1.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t$1), this.depthMask.set(!0)), void 0 !== i$1 && (o$1 |= a$1.STENCIL_BUFFER_BIT, this.clearStencil.set(i$1), this.stencilMask.set(255)), a$1.clear(o$1);
				}
				setCullFace(e$1) {
					!1 === e$1.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e$1.mode), this.frontFace.set(e$1.frontFace));
				}
				setDepthMode(e$1) {
					e$1.func !== this.gl.ALWAYS || e$1.mask ? (this.depthTest.set(!0), this.depthFunc.set(e$1.func), this.depthMask.set(e$1.mask), this.depthRange.set(e$1.range)) : this.depthTest.set(!1);
				}
				setStencilMode(e$1) {
					e$1.test.func !== this.gl.ALWAYS || e$1.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e$1.mask), this.stencilOp.set([
						e$1.fail,
						e$1.depthFail,
						e$1.pass
					]), this.stencilFunc.set({
						func: e$1.test.func,
						ref: e$1.ref,
						mask: e$1.test.mask
					})) : this.stencilTest.set(!1);
				}
				setColorMode(e$1) {
					t.bR(e$1.blendFunction, Qt.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e$1.blendFunction), this.blendColor.set(e$1.blendColor)), this.colorMask.set(e$1.mask);
				}
				createVertexArray() {
					var e$1;
					return ri(this.gl) ? this.gl.createVertexArray() : null === (e$1 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === e$1 ? void 0 : e$1.createVertexArrayOES();
				}
				deleteVertexArray(e$1) {
					var t$1;
					return ri(this.gl) ? this.gl.deleteVertexArray(e$1) : null === (t$1 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === t$1 ? void 0 : t$1.deleteVertexArrayOES(e$1);
				}
				unbindVAO() {
					this.bindVertexArray.set(null);
				}
			}
			let lo;
			function co(e$1, i$1, a$1, o$1, r$1) {
				const s$1 = e$1.context, n$1 = e$1.transform, l$1 = s$1.gl, c$1 = e$1.useProgram("collisionBox"), h$1 = [];
				let u$1 = 0, d$1 = 0;
				for (let t$1 = 0; t$1 < o$1.length; t$1++) {
					const _$2 = o$1[t$1], p$2 = i$1.getTile(_$2).getBucket(a$1);
					if (!p$2) continue;
					const m$2 = r$1 ? p$2.textCollisionBox : p$2.iconCollisionBox, f$2 = p$2.collisionCircleArray;
					f$2.length > 0 && (h$1.push({
						circleArray: f$2,
						circleOffset: d$1,
						coord: _$2
					}), u$1 += f$2.length / 4, d$1 = u$1), m$2 && c$1.draw(s$1, l$1.LINES, ti.disabled, ai.disabled, e$1.colorModeForRenderPass(), ei.disabled, Xi(e$1.transform), e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(_$2), n$1.getProjectionData({
						overscaledTileID: _$2,
						applyGlobeMatrix: !0,
						applyTerrainMatrix: !0
					}), a$1.id, m$2.layoutVertexBuffer, m$2.indexBuffer, m$2.segments, null, e$1.transform.zoom, null, null, m$2.collisionVertexBuffer);
				}
				if (!r$1 || !h$1.length) return;
				const _$1 = e$1.useProgram("collisionCircle"), p$1 = new t.ca();
				p$1.resize(4 * u$1), p$1._trim();
				let m$1 = 0;
				for (const e$2 of h$1) for (let t$1 = 0; t$1 < e$2.circleArray.length / 4; t$1++) {
					const i$2 = 4 * t$1, a$2 = e$2.circleArray[i$2 + 0], o$2 = e$2.circleArray[i$2 + 1], r$2 = e$2.circleArray[i$2 + 2], s$2 = e$2.circleArray[i$2 + 3];
					p$1.emplace(m$1++, a$2, o$2, r$2, s$2, 0), p$1.emplace(m$1++, a$2, o$2, r$2, s$2, 1), p$1.emplace(m$1++, a$2, o$2, r$2, s$2, 2), p$1.emplace(m$1++, a$2, o$2, r$2, s$2, 3);
				}
				(!lo || lo.length < 2 * u$1) && (lo = function(e$2) {
					const i$2 = 2 * e$2, a$2 = new t.cc();
					a$2.resize(i$2), a$2._trim();
					for (let e$3 = 0; e$3 < i$2; e$3++) {
						const t$1 = 6 * e$3;
						a$2.uint16[t$1 + 0] = 4 * e$3 + 0, a$2.uint16[t$1 + 1] = 4 * e$3 + 1, a$2.uint16[t$1 + 2] = 4 * e$3 + 2, a$2.uint16[t$1 + 3] = 4 * e$3 + 2, a$2.uint16[t$1 + 4] = 4 * e$3 + 3, a$2.uint16[t$1 + 5] = 4 * e$3 + 0;
					}
					return a$2;
				}(u$1));
				const f$1 = s$1.createIndexBuffer(lo, !0), g$1 = s$1.createVertexBuffer(p$1, t.cb.members, !0);
				for (const i$2 of h$1) {
					const o$2 = Ki(e$1.transform);
					_$1.draw(s$1, l$1.TRIANGLES, ti.disabled, ai.disabled, e$1.colorModeForRenderPass(), ei.disabled, o$2, e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(i$2.coord), null, a$1.id, g$1, f$1, t.aX.simpleSegment(0, 2 * i$2.circleOffset, i$2.circleArray.length, i$2.circleArray.length / 2), null, e$1.transform.zoom, null, null, null);
				}
				g$1.destroy(), f$1.destroy();
			}
			const ho = t.ar(new Float32Array(16));
			function uo(e$1, i$1, a$1, o$1, r$1, s$1) {
				const { horizontalAlign: n$1, verticalAlign: l$1 } = t.aS(e$1);
				return new t.P((-(n$1 - .5) * i$1 / r$1 + o$1[0]) * s$1, (-(l$1 - .5) * a$1 / r$1 + o$1[1]) * s$1);
			}
			function _o(e$1, i$1, a$1, o$1, r$1, s$1) {
				const n$1 = i$1.tileAnchorPoint.add(new t.P(i$1.translation[0], i$1.translation[1]));
				if (i$1.pitchWithMap) {
					let e$2 = o$1.mult(s$1);
					a$1 || (e$2 = e$2.rotate(-r$1));
					const t$1 = n$1.add(e$2);
					return Ue(t$1.x, t$1.y, i$1.pitchedLabelPlaneMatrix, i$1.getElevation).point;
				}
				if (a$1) {
					const t$1 = Ye(i$1.tileAnchorPoint.x + 1, i$1.tileAnchorPoint.y, i$1).point.sub(e$1), a$2 = Math.atan(t$1.y / t$1.x) + (t$1.x < 0 ? Math.PI : 0);
					return e$1.add(o$1.rotate(a$2));
				}
				return e$1.add(o$1);
			}
			function po(e$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1) {
				const _$1 = e$1.text.placedSymbolArray, p$1 = e$1.text.dynamicLayoutVertexArray, m$1 = e$1.icon.dynamicLayoutVertexArray, f$1 = {};
				p$1.clear();
				for (let m$2 = 0; m$2 < _$1.length; m$2++) {
					const g$1 = _$1.get(m$2), v$1 = g$1.hidden || !g$1.crossTileID || e$1.allowVerticalPlacement && !g$1.placedOrientation ? null : o$1[g$1.crossTileID];
					if (v$1) {
						const o$2 = new t.P(g$1.anchorX, g$1.anchorY), _$2 = {
							getElevation: d$1,
							width: r$1.width,
							height: r$1.height,
							pitchedLabelPlaneMatrix: s$1,
							pitchWithMap: a$1,
							transform: r$1,
							tileAnchorPoint: o$2,
							translation: h$1,
							unwrappedTileID: u$1
						}, m$3 = a$1 ? Je(o$2.x, o$2.y, _$2) : Ye(o$2.x, o$2.y, _$2), x$1 = Ge(r$1.cameraToCenterDistance, m$3.signedDistanceFromCamera);
						let b$1 = t.aA(e$1.textSizeData, l$1, g$1) * x$1 / t.aM;
						a$1 && (b$1 *= e$1.tilePixelRatio / n$1);
						const { width: y$1, height: w$1, anchor: T$1, textOffset: P$1, textBoxScale: C$1 } = v$1, I$1 = uo(T$1, y$1, w$1, P$1, C$1, b$1), M$1 = r$1.getPitchedTextCorrection(o$2.x + h$1[0], o$2.y + h$1[1], u$1), E$1 = _o(m$3.point, _$2, i$1, I$1, -r$1.bearingInRadians, M$1), S$1 = e$1.allowVerticalPlacement && g$1.placedOrientation === t.az.vertical ? Math.PI / 2 : 0;
						for (let e$2 = 0; e$2 < g$1.numGlyphs; e$2++) t.aG(p$1, E$1, S$1);
						c$1 && g$1.associatedIconIndex >= 0 && (f$1[g$1.associatedIconIndex] = {
							shiftedAnchor: E$1,
							angle: S$1
						});
					} else ot(g$1.numGlyphs, p$1);
				}
				if (c$1) {
					m$1.clear();
					const i$2 = e$1.icon.placedSymbolArray;
					for (let e$2 = 0; e$2 < i$2.length; e$2++) {
						const a$2 = i$2.get(e$2);
						if (a$2.hidden) ot(a$2.numGlyphs, m$1);
						else {
							const i$3 = f$1[e$2];
							if (i$3) for (let e$3 = 0; e$3 < a$2.numGlyphs; e$3++) t.aG(m$1, i$3.shiftedAnchor, i$3.angle);
							else ot(a$2.numGlyphs, m$1);
						}
					}
					e$1.icon.dynamicLayoutVertexBuffer.updateData(m$1);
				}
				e$1.text.dynamicLayoutVertexBuffer.updateData(p$1);
			}
			function mo(e$1, t$1, i$1) {
				return i$1.iconsInText && t$1 ? "symbolTextAndIcon" : e$1 ? "symbolSDF" : "symbolIcon";
			}
			function fo(e$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$1) {
				const p$1 = e$1.context, m$1 = p$1.gl, f$1 = e$1.transform, g$1 = "map" === l$1, v$1 = "map" === c$1, x$1 = "viewport" !== l$1 && "point" !== a$1.layout.get("symbol-placement"), b$1 = g$1 && !v$1 && !x$1, y$1 = !a$1.layout.get("symbol-sort-key").isConstant();
				let w$1 = !1;
				const T$1 = e$1.getDepthModeForSublayer(0, ti.ReadOnly), P$1 = a$1._unevaluatedLayout.hasValue("text-variable-anchor") || a$1._unevaluatedLayout.hasValue("text-variable-anchor-offset"), C$1 = [], I$1 = f$1.getCircleRadiusCorrection();
				for (const l$2 of o$1) {
					const o$2 = i$1.getTile(l$2), c$2 = o$2.getBucket(a$1);
					if (!c$2) continue;
					const u$2 = r$1 ? c$2.text : c$2.icon;
					if (!u$2 || !u$2.segments.get().length || !u$2.hasVisibleVertices) continue;
					const d$2 = u$2.programConfigurations.get(a$1.id), p$2 = r$1 || c$2.sdfIcons, T$2 = r$1 ? c$2.textSizeData : c$2.iconSizeData, M$1 = v$1 || 0 !== f$1.pitch, E$1 = e$1.useProgram(mo(p$2, r$1, c$2), d$2), S$1 = t.ay(T$2, f$1.zoom), z$1 = e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(l$2);
					let R$1, D$1, A$1, L$1, k$1 = [0, 0], F$1 = null;
					if (r$1) D$1 = o$2.glyphAtlasTexture, A$1 = m$1.LINEAR, R$1 = o$2.glyphAtlasTexture.size, c$2.iconsInText && (k$1 = o$2.imageAtlasTexture.size, F$1 = o$2.imageAtlasTexture, L$1 = M$1 || e$1.options.rotating || e$1.options.zooming || "composite" === T$2.kind || "camera" === T$2.kind ? m$1.LINEAR : m$1.NEAREST);
					else {
						const t$1 = 1 !== a$1.layout.get("icon-size").constantOr(0) || c$2.iconsNeedLinear;
						D$1 = o$2.imageAtlasTexture, A$1 = p$2 || e$1.options.rotating || e$1.options.zooming || t$1 || M$1 ? m$1.LINEAR : m$1.NEAREST, R$1 = o$2.imageAtlasTexture.size;
					}
					const B$1 = t.aN(o$2, 1, e$1.transform.zoom), O$1 = je(g$1, e$1.transform, B$1), j$1 = t.N();
					t.aB(j$1, O$1);
					const N$1 = Ne(v$1, g$1, e$1.transform, B$1), Z$1 = t.aO(f$1, o$2, s$1, n$1), U$1 = f$1.getProjectionData({
						overscaledTileID: l$2,
						applyGlobeMatrix: !_$1,
						applyTerrainMatrix: !0
					}), G$1 = P$1 && c$2.hasTextData(), V$1 = "none" !== a$1.layout.get("icon-text-fit") && G$1 && c$2.hasIconData();
					if (x$1) {
						const t$1 = e$1.style.map.terrain ? (t$2, i$2) => e$1.style.map.terrain.getElevation(l$2, t$2, i$2) : null;
						qe(c$2, e$1, r$1, O$1, j$1, v$1, h$1, "map" === a$1.layout.get("text-rotation-alignment"), l$2.toUnwrapped(), f$1.width, f$1.height, Z$1, t$1);
					}
					const q$1 = r$1 && P$1 || V$1, W$1 = x$1 || q$1 ? ho : v$1 ? O$1 : e$1.transform.clipSpaceToPixelsMatrix, $$1 = p$2 && 0 !== a$1.paint.get(r$1 ? "text-halo-width" : "icon-halo-width").constantOr(1);
					let H$1;
					H$1 = p$2 ? c$2.iconsInText ? ma(T$2.kind, S$1, b$1, v$1, x$1, q$1, e$1, W$1, N$1, Z$1, R$1, k$1, I$1) : pa(T$2.kind, S$1, b$1, v$1, x$1, q$1, e$1, W$1, N$1, Z$1, r$1, R$1, 0, I$1) : _a(T$2.kind, S$1, b$1, v$1, x$1, q$1, e$1, W$1, N$1, Z$1, r$1, R$1, I$1);
					const X$1 = {
						program: E$1,
						buffers: u$2,
						uniformValues: H$1,
						projectionData: U$1,
						atlasTexture: D$1,
						atlasTextureIcon: F$1,
						atlasInterpolation: A$1,
						atlasInterpolationIcon: L$1,
						isSDF: p$2,
						hasHalo: $$1
					};
					if (y$1 && c$2.canOverlap) {
						w$1 = !0;
						const e$2 = u$2.segments.get();
						for (const i$2 of e$2) C$1.push({
							segments: new t.aX([i$2]),
							sortKey: i$2.sortKey,
							state: X$1,
							terrainData: z$1
						});
					} else C$1.push({
						segments: u$2.segments,
						sortKey: 0,
						state: X$1,
						terrainData: z$1
					});
				}
				w$1 && C$1.sort(((e$2, t$1) => e$2.sortKey - t$1.sortKey));
				for (const t$1 of C$1) {
					const i$2 = t$1.state;
					if (p$1.activeTexture.set(m$1.TEXTURE0), i$2.atlasTexture.bind(i$2.atlasInterpolation, m$1.CLAMP_TO_EDGE), i$2.atlasTextureIcon && (p$1.activeTexture.set(m$1.TEXTURE1), i$2.atlasTextureIcon && i$2.atlasTextureIcon.bind(i$2.atlasInterpolationIcon, m$1.CLAMP_TO_EDGE)), i$2.isSDF) {
						const o$2 = i$2.uniformValues;
						i$2.hasHalo && (o$2.u_is_halo = 1, go(i$2.buffers, t$1.segments, a$1, e$1, i$2.program, T$1, u$1, d$1, o$2, i$2.projectionData, t$1.terrainData)), o$2.u_is_halo = 0;
					}
					go(i$2.buffers, t$1.segments, a$1, e$1, i$2.program, T$1, u$1, d$1, i$2.uniformValues, i$2.projectionData, t$1.terrainData);
				}
			}
			function go(e$1, t$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1, c$1, h$1) {
				const u$1 = a$1.context;
				o$1.draw(u$1, u$1.gl.TRIANGLES, r$1, s$1, n$1, ei.backCCW, l$1, h$1, c$1, i$1.id, e$1.layoutVertexBuffer, e$1.indexBuffer, t$1, i$1.paint, a$1.transform.zoom, e$1.programConfigurations.get(i$1.id), e$1.dynamicLayoutVertexBuffer, e$1.opacityVertexBuffer);
			}
			function vo(e$1, i$1, a$1, o$1, r$1) {
				const s$1 = e$1.context, n$1 = s$1.gl, l$1 = ai.disabled, c$1 = new Qt([n$1.ONE, n$1.ONE], t.bp.transparent, [
					!0,
					!0,
					!0,
					!0
				]), h$1 = i$1.getBucket(a$1);
				if (!h$1) return;
				const u$1 = o$1.key;
				let d$1 = a$1.heatmapFbos.get(u$1);
				d$1 || (d$1 = bo(s$1, i$1.tileSize, i$1.tileSize), a$1.heatmapFbos.set(u$1, d$1)), s$1.bindFramebuffer.set(d$1.framebuffer), s$1.viewport.set([
					0,
					0,
					i$1.tileSize,
					i$1.tileSize
				]), s$1.clear({ color: t.bp.transparent });
				const _$1 = h$1.programConfigurations.get(a$1.id), p$1 = e$1.useProgram("heatmap", _$1, !r$1), m$1 = e$1.transform.getProjectionData({
					overscaledTileID: i$1.tileID,
					applyGlobeMatrix: !0,
					applyTerrainMatrix: !0
				}), f$1 = e$1.style.map.terrain.getTerrainData(o$1);
				p$1.draw(s$1, n$1.TRIANGLES, ti.disabled, l$1, c$1, ei.disabled, Qi(i$1, e$1.transform.zoom, a$1.paint.get("heatmap-intensity"), 1), f$1, m$1, a$1.id, h$1.layoutVertexBuffer, h$1.indexBuffer, h$1.segments, a$1.paint, e$1.transform.zoom, _$1);
			}
			function xo(e$1, t$1, i$1, a$1, o$1) {
				const r$1 = e$1.context, s$1 = r$1.gl, n$1 = e$1.transform;
				r$1.setColorMode(e$1.colorModeForRenderPass());
				const l$1 = yo(r$1, t$1), c$1 = i$1.key, h$1 = t$1.heatmapFbos.get(c$1);
				if (!h$1) return;
				r$1.activeTexture.set(s$1.TEXTURE0), s$1.bindTexture(s$1.TEXTURE_2D, h$1.colorAttachment.get()), r$1.activeTexture.set(s$1.TEXTURE1), l$1.bind(s$1.LINEAR, s$1.CLAMP_TO_EDGE);
				const u$1 = n$1.getProjectionData({
					overscaledTileID: i$1,
					applyTerrainMatrix: o$1,
					applyGlobeMatrix: !a$1
				});
				e$1.useProgram("heatmapTexture").draw(r$1, s$1.TRIANGLES, ti.disabled, ai.disabled, e$1.colorModeForRenderPass(), ei.disabled, Ji(e$1, t$1, 0, 1), null, u$1, t$1.id, e$1.rasterBoundsBuffer, e$1.quadTriangleIndexBuffer, e$1.rasterBoundsSegments, t$1.paint, n$1.zoom), h$1.destroy(), t$1.heatmapFbos.delete(c$1);
			}
			function bo(e$1, t$1, i$1) {
				var a$1, o$1;
				const r$1 = e$1.gl, s$1 = r$1.createTexture();
				r$1.bindTexture(r$1.TEXTURE_2D, s$1), r$1.texParameteri(r$1.TEXTURE_2D, r$1.TEXTURE_WRAP_S, r$1.CLAMP_TO_EDGE), r$1.texParameteri(r$1.TEXTURE_2D, r$1.TEXTURE_WRAP_T, r$1.CLAMP_TO_EDGE), r$1.texParameteri(r$1.TEXTURE_2D, r$1.TEXTURE_MIN_FILTER, r$1.LINEAR), r$1.texParameteri(r$1.TEXTURE_2D, r$1.TEXTURE_MAG_FILTER, r$1.LINEAR);
				const n$1 = null !== (a$1 = e$1.HALF_FLOAT) && void 0 !== a$1 ? a$1 : r$1.UNSIGNED_BYTE, l$1 = null !== (o$1 = e$1.RGBA16F) && void 0 !== o$1 ? o$1 : r$1.RGBA;
				r$1.texImage2D(r$1.TEXTURE_2D, 0, l$1, t$1, i$1, 0, r$1.RGBA, n$1, null);
				const c$1 = e$1.createFramebuffer(t$1, i$1, !1, !1);
				return c$1.colorAttachment.set(s$1), c$1;
			}
			function yo(e$1, i$1) {
				return i$1.colorRampTexture || (i$1.colorRampTexture = new t.T(e$1, i$1.colorRamp, e$1.gl.RGBA)), i$1.colorRampTexture;
			}
			function wo(e$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1) {
				let c$1 = 256;
				if (r$1.stepInterpolant) {
					const o$2 = i$1.getSource().maxzoom, r$2 = n$1.canonical.z === o$2 ? Math.ceil(1 << e$1.transform.maxZoom - n$1.canonical.z) : 1;
					c$1 = t.an(t.ce(s$1.maxLineLength / t.a5 * 1024 * r$2), 256, a$1.maxTextureSize);
				}
				return l$1.gradient = t.cf({
					expression: r$1.gradientExpression(),
					evaluationKey: "lineProgress",
					resolution: c$1,
					image: l$1.gradient || void 0,
					clips: s$1.lineClipsArray
				}), l$1.texture ? l$1.texture.update(l$1.gradient) : l$1.texture = new t.T(a$1, l$1.gradient, o$1.RGBA), l$1.version = r$1.gradientVersion, l$1.texture;
			}
			function To(e$1, t$1, i$1, a$1, o$1) {
				e$1.activeTexture.set(t$1.TEXTURE0), i$1.imageAtlasTexture.bind(t$1.LINEAR, t$1.CLAMP_TO_EDGE), a$1.updatePaintBuffers(o$1);
			}
			function Po(e$1, t$1, i$1, a$1, o$1, r$1) {
				(o$1 || e$1.lineAtlas.dirty) && (t$1.activeTexture.set(i$1.TEXTURE0), e$1.lineAtlas.bind(t$1)), a$1.updatePaintBuffers(r$1);
			}
			function Co(e$1, t$1, i$1, a$1, o$1, r$1, s$1) {
				const n$1 = r$1.gradients[o$1.id];
				let l$1 = n$1.texture;
				o$1.gradientVersion !== n$1.version && (l$1 = wo(e$1, t$1, i$1, a$1, o$1, r$1, s$1, n$1)), i$1.activeTexture.set(a$1.TEXTURE0), l$1.bind(o$1.stepInterpolant ? a$1.NEAREST : a$1.LINEAR, a$1.CLAMP_TO_EDGE);
			}
			function Io(e$1, t$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1) {
				const c$1 = r$1.gradients[o$1.id];
				let h$1 = c$1.texture;
				o$1.gradientVersion !== c$1.version && (h$1 = wo(e$1, t$1, i$1, a$1, o$1, r$1, s$1, c$1)), i$1.activeTexture.set(a$1.TEXTURE0), h$1.bind(o$1.stepInterpolant ? a$1.NEAREST : a$1.LINEAR, a$1.CLAMP_TO_EDGE), i$1.activeTexture.set(a$1.TEXTURE1), e$1.lineAtlas.bind(i$1), n$1.updatePaintBuffers(l$1);
			}
			function Mo(e$1, t$1, i$1, a$1, o$1) {
				if (!i$1 || !a$1 || !a$1.imageAtlas) return;
				const r$1 = a$1.imageAtlas.patternPositions;
				let s$1 = r$1[i$1.to.toString()], n$1 = r$1[i$1.from.toString()];
				if (!s$1 && n$1 && (s$1 = n$1), !n$1 && s$1 && (n$1 = s$1), !s$1 || !n$1) {
					const e$2 = o$1.getPaintProperty(t$1);
					s$1 = r$1[e$2], n$1 = r$1[e$2];
				}
				s$1 && n$1 && e$1.setConstantPatternPositions(s$1, n$1);
			}
			function Eo(e$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1) {
				const c$1 = e$1.context.gl, h$1 = "fill-pattern", u$1 = a$1.paint.get(h$1), d$1 = u$1 && u$1.constantOr(1), _$1 = a$1.getCrossfadeParameters();
				let p$1, m$1, f$1, g$1, v$1;
				const x$1 = e$1.transform, b$1 = a$1.paint.get("fill-translate"), y$1 = a$1.paint.get("fill-translate-anchor");
				n$1 ? (m$1 = d$1 && !a$1.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", p$1 = c$1.LINES) : (m$1 = d$1 ? "fillPattern" : "fill", p$1 = c$1.TRIANGLES);
				const w$1 = u$1.constantOr(null);
				for (const u$2 of o$1) {
					const o$2 = i$1.getTile(u$2);
					if (d$1 && !o$2.patternsLoaded()) continue;
					const T$1 = o$2.getBucket(a$1);
					if (!T$1) continue;
					const P$1 = T$1.programConfigurations.get(a$1.id), C$1 = e$1.useProgram(m$1, P$1), I$1 = e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(u$2);
					d$1 && (e$1.context.activeTexture.set(c$1.TEXTURE0), o$2.imageAtlasTexture.bind(c$1.LINEAR, c$1.CLAMP_TO_EDGE), P$1.updatePaintBuffers(_$1)), Mo(P$1, h$1, w$1, o$2, a$1);
					const M$1 = x$1.getProjectionData({
						overscaledTileID: u$2,
						applyGlobeMatrix: !l$1,
						applyTerrainMatrix: !0
					}), E$1 = t.aO(x$1, o$2, b$1, y$1);
					if (n$1) {
						g$1 = T$1.indexBuffer2, v$1 = T$1.segments2;
						const t$1 = [c$1.drawingBufferWidth, c$1.drawingBufferHeight];
						f$1 = "fillOutlinePattern" === m$1 && d$1 ? $i(e$1, _$1, o$2, t$1, E$1) : Wi(t$1, E$1);
					} else g$1 = T$1.indexBuffer, v$1 = T$1.segments, f$1 = d$1 ? qi(e$1, _$1, o$2, E$1) : { u_fill_translate: E$1 };
					const S$1 = e$1.stencilModeForClipping(u$2);
					C$1.draw(e$1.context, p$1, r$1, S$1, s$1, ei.backCCW, f$1, I$1, M$1, a$1.id, T$1.layoutVertexBuffer, g$1, v$1, a$1.paint, e$1.transform.zoom, P$1);
				}
			}
			function So(e$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1) {
				const c$1 = e$1.context, h$1 = c$1.gl, u$1 = "fill-extrusion-pattern", d$1 = a$1.paint.get(u$1), _$1 = d$1.constantOr(1), p$1 = a$1.getCrossfadeParameters(), m$1 = a$1.paint.get("fill-extrusion-opacity"), f$1 = d$1.constantOr(null), g$1 = e$1.transform;
				for (const d$2 of o$1) {
					const o$2 = i$1.getTile(d$2), v$1 = o$2.getBucket(a$1);
					if (!v$1) continue;
					const x$1 = e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(d$2), b$1 = v$1.programConfigurations.get(a$1.id), y$1 = e$1.useProgram(_$1 ? "fillExtrusionPattern" : "fillExtrusion", b$1);
					_$1 && (e$1.context.activeTexture.set(h$1.TEXTURE0), o$2.imageAtlasTexture.bind(h$1.LINEAR, h$1.CLAMP_TO_EDGE), b$1.updatePaintBuffers(p$1));
					const w$1 = g$1.getProjectionData({
						overscaledTileID: d$2,
						applyGlobeMatrix: !l$1,
						applyTerrainMatrix: !0
					});
					Mo(b$1, u$1, f$1, o$2, a$1);
					const T$1 = t.aO(g$1, o$2, a$1.paint.get("fill-extrusion-translate"), a$1.paint.get("fill-extrusion-translate-anchor")), P$1 = a$1.paint.get("fill-extrusion-vertical-gradient"), C$1 = _$1 ? Vi(e$1, P$1, m$1, T$1, d$2, p$1, o$2) : Gi(e$1, P$1, m$1, T$1);
					y$1.draw(c$1, c$1.gl.TRIANGLES, r$1, s$1, n$1, ei.backCCW, C$1, x$1, w$1, a$1.id, v$1.layoutVertexBuffer, v$1.indexBuffer, v$1.segments, a$1.paint, e$1.transform.zoom, b$1, e$1.style.map.terrain && v$1.centroidVertexBuffer);
				}
			}
			function zo(e$1, t$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1) {
				var c$1;
				const h$1 = e$1.style.projection, u$1 = e$1.context, d$1 = e$1.transform, _$1 = u$1.gl, p$1 = [`#define NUM_ILLUMINATION_SOURCES ${i$1.paint.get("hillshade-highlight-color").values.length}`], m$1 = e$1.useProgram("hillshade", null, !1, p$1), f$1 = !e$1.options.moving;
				for (const p$2 of a$1) {
					const a$2 = t$1.getTile(p$2), g$1 = a$2.fbo;
					if (!g$1) continue;
					const v$1 = h$1.getMeshFromTileID(u$1, p$2.canonical, n$1, !0, "raster"), x$1 = null === (c$1 = e$1.style.map.terrain) || void 0 === c$1 ? void 0 : c$1.getTerrainData(p$2);
					u$1.activeTexture.set(_$1.TEXTURE0), _$1.bindTexture(_$1.TEXTURE_2D, g$1.colorAttachment.get());
					const b$1 = d$1.getProjectionData({
						overscaledTileID: p$2,
						aligned: f$1,
						applyGlobeMatrix: !l$1,
						applyTerrainMatrix: !0
					});
					m$1.draw(u$1, _$1.TRIANGLES, r$1, o$1[p$2.overscaledZ], s$1, ei.backCCW, ea(e$1, a$2, i$1), x$1, b$1, i$1.id, v$1.vertexBuffer, v$1.indexBuffer, v$1.segments);
				}
			}
			function Ro(e$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1, c$1) {
				var h$1;
				const u$1 = e$1.style.projection, d$1 = e$1.context, _$1 = e$1.transform, p$1 = d$1.gl, m$1 = e$1.useProgram("colorRelief"), f$1 = !e$1.options.moving;
				let g$1 = !0, v$1 = 0;
				for (const x$1 of o$1) {
					const o$2 = i$1.getTile(x$1), b$1 = o$2.dem;
					if (g$1) {
						const e$2 = p$1.getParameter(p$1.MAX_TEXTURE_SIZE), { elevationTexture: t$1, colorTexture: i$2 } = a$1.getColorRampTextures(d$1, e$2, b$1.getUnpackVector());
						d$1.activeTexture.set(p$1.TEXTURE1), t$1.bind(p$1.NEAREST, p$1.CLAMP_TO_EDGE), d$1.activeTexture.set(p$1.TEXTURE4), i$2.bind(p$1.LINEAR, p$1.CLAMP_TO_EDGE), g$1 = !1, v$1 = t$1.size[0];
					}
					if (!b$1 || !b$1.data) continue;
					const y$1 = b$1.stride, w$1 = b$1.getPixels();
					if (d$1.activeTexture.set(p$1.TEXTURE0), d$1.pixelStoreUnpackPremultiplyAlpha.set(!1), o$2.demTexture = o$2.demTexture || e$1.getTileTexture(y$1), o$2.demTexture) {
						const e$2 = o$2.demTexture;
						e$2.update(w$1, { premultiply: !1 }), e$2.bind(p$1.LINEAR, p$1.CLAMP_TO_EDGE);
					} else o$2.demTexture = new t.T(d$1, w$1, p$1.RGBA, { premultiply: !1 }), o$2.demTexture.bind(p$1.LINEAR, p$1.CLAMP_TO_EDGE);
					const T$1 = u$1.getMeshFromTileID(d$1, x$1.canonical, l$1, !0, "raster"), P$1 = null === (h$1 = e$1.style.map.terrain) || void 0 === h$1 ? void 0 : h$1.getTerrainData(x$1), C$1 = _$1.getProjectionData({
						overscaledTileID: x$1,
						aligned: f$1,
						applyGlobeMatrix: !c$1,
						applyTerrainMatrix: !0
					});
					m$1.draw(d$1, p$1.TRIANGLES, s$1, r$1[x$1.overscaledZ], n$1, ei.backCCW, aa(a$1, o$2.dem, v$1), P$1, C$1, a$1.id, T$1.vertexBuffer, T$1.indexBuffer, T$1.segments);
				}
			}
			const Do = [
				new t.P(0, 0),
				new t.P(t.a5, 0),
				new t.P(t.a5, t.a5),
				new t.P(0, t.a5)
			];
			function Ao(e$1, t$1, i$1, a$1, o$1, r$1, s$1, n$1, l$1 = !1, c$1 = !1) {
				const h$1 = a$1[a$1.length - 1].overscaledZ, u$1 = e$1.context, d$1 = u$1.gl, _$1 = e$1.useProgram("raster"), p$1 = e$1.transform, m$1 = e$1.style.projection, f$1 = e$1.colorModeForRenderPass(), g$1 = !e$1.options.moving, v$1 = i$1.paint.get("raster-opacity"), x$1 = i$1.paint.get("raster-resampling"), b$1 = i$1.paint.get("raster-fade-duration"), y$1 = !!e$1.style.map.terrain;
				for (const w$1 of a$1) {
					const a$2 = e$1.getDepthModeForSublayer(w$1.overscaledZ - h$1, 1 === v$1 ? ti.ReadWrite : ti.ReadOnly, d$1.LESS), T$1 = t$1.getTile(w$1), P$1 = "nearest" === x$1 ? d$1.NEAREST : d$1.LINEAR;
					u$1.activeTexture.set(d$1.TEXTURE0), T$1.texture.bind(P$1, d$1.CLAMP_TO_EDGE, d$1.LINEAR_MIPMAP_NEAREST), u$1.activeTexture.set(d$1.TEXTURE1);
					const { parentTile: C$1, parentScaleBy: I$1, parentTopLeft: M$1, fadeValues: E$1 } = Lo(T$1, t$1, b$1, y$1);
					T$1.fadeOpacity = E$1.tileOpacity, C$1 ? (C$1.fadeOpacity = E$1.parentTileOpacity, C$1.texture.bind(P$1, d$1.CLAMP_TO_EDGE, d$1.LINEAR_MIPMAP_NEAREST)) : T$1.texture.bind(P$1, d$1.CLAMP_TO_EDGE, d$1.LINEAR_MIPMAP_NEAREST), T$1.texture.useMipmap && u$1.extTextureFilterAnisotropic && e$1.transform.pitch > 20 && d$1.texParameterf(d$1.TEXTURE_2D, u$1.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, u$1.extTextureFilterAnisotropicMax);
					const S$1 = e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(w$1), z$1 = p$1.getProjectionData({
						overscaledTileID: w$1,
						aligned: g$1,
						applyGlobeMatrix: !c$1,
						applyTerrainMatrix: !0
					}), R$1 = ua(M$1, I$1, E$1.fadeMix, i$1, n$1), D$1 = m$1.getMeshFromTileID(u$1, w$1.canonical, r$1, s$1, "raster");
					_$1.draw(u$1, d$1.TRIANGLES, a$2, o$1 ? o$1[w$1.overscaledZ] : ai.disabled, f$1, l$1 ? ei.frontCCW : ei.backCCW, R$1, S$1, z$1, i$1.id, D$1.vertexBuffer, D$1.indexBuffer, D$1.segments);
				}
			}
			function Lo(e$1, i$1, a$1, o$1) {
				const r$1 = {
					parentTile: null,
					parentScaleBy: 1,
					parentTopLeft: [0, 0],
					fadeValues: {
						tileOpacity: 1,
						parentTileOpacity: 1,
						fadeMix: {
							opacity: 1,
							mix: 0
						}
					}
				};
				if (0 === a$1 || o$1) return r$1;
				if (e$1.fadingParentID) {
					const o$2 = i$1.getLoadedTile(e$1.fadingParentID);
					if (!o$2) return r$1;
					const s$1 = Math.pow(2, o$2.tileID.overscaledZ - e$1.tileID.overscaledZ);
					return {
						parentTile: o$2,
						parentScaleBy: s$1,
						parentTopLeft: [e$1.tileID.canonical.x * s$1 % 1, e$1.tileID.canonical.y * s$1 % 1],
						fadeValues: function(e$2, i$2, a$2) {
							const o$3 = c(), r$2 = (o$3 - i$2.timeAdded) / a$2, s$2 = e$2.fadingDirection === ue.Incoming, n$1 = t.an((o$3 - e$2.timeAdded) / a$2, 0, 1), l$1 = t.an(1 - r$2, 0, 1), h$1 = s$2 ? n$1 : l$1;
							return {
								tileOpacity: h$1,
								parentTileOpacity: s$2 ? l$1 : n$1,
								fadeMix: {
									opacity: 1,
									mix: 1 - h$1
								}
							};
						}(e$1, o$2, a$1)
					};
				}
				if (e$1.selfFading) return {
					parentTile: null,
					parentScaleBy: 1,
					parentTopLeft: [0, 0],
					fadeValues: function(e$2, i$2) {
						const a$2 = (c() - e$2.timeAdded) / i$2, o$2 = t.an(a$2, 0, 1);
						return {
							tileOpacity: o$2,
							fadeMix: {
								opacity: o$2,
								mix: 0
							}
						};
					}(e$1, a$1)
				};
				return r$1;
			}
			const ko = new t.bp(1, 0, 0, 1), Fo = new t.bp(0, 1, 0, 1), Bo = new t.bp(0, 0, 1, 1), Oo = new t.bp(1, 0, 1, 1), jo = new t.bp(0, 1, 1, 1);
			function No(e$1, t$1, i$1, a$1) {
				Uo(e$1, 0, t$1 + i$1 / 2, e$1.transform.width, i$1, a$1);
			}
			function Zo(e$1, t$1, i$1, a$1) {
				Uo(e$1, t$1 - i$1 / 2, 0, i$1, e$1.transform.height, a$1);
			}
			function Uo(e$1, t$1, i$1, a$1, o$1, r$1) {
				const s$1 = e$1.context, n$1 = s$1.gl;
				n$1.enable(n$1.SCISSOR_TEST), n$1.scissor(t$1 * e$1.pixelRatio, i$1 * e$1.pixelRatio, a$1 * e$1.pixelRatio, o$1 * e$1.pixelRatio), s$1.clear({ color: r$1 }), n$1.disable(n$1.SCISSOR_TEST);
			}
			function Go(e$1, i$1, a$1) {
				const o$1 = e$1.context, r$1 = o$1.gl, s$1 = e$1.useProgram("debug"), n$1 = ti.disabled, l$1 = ai.disabled, c$1 = e$1.colorModeForRenderPass(), h$1 = "$debug", u$1 = e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(a$1);
				o$1.activeTexture.set(r$1.TEXTURE0);
				const d$1 = i$1.getTileByID(a$1.key).latestRawTileData, _$1 = Math.floor((d$1 && d$1.byteLength || 0) / 1024), p$1 = i$1.getTile(a$1).tileSize, m$1 = 512 / Math.min(p$1, 512) * (a$1.overscaledZ / e$1.transform.zoom) * .5;
				let f$1 = a$1.canonical.toString();
				a$1.overscaledZ !== a$1.canonical.z && (f$1 += ` => ${a$1.overscaledZ}`), function(e$2, t$1) {
					e$2.initDebugOverlayCanvas();
					const i$2 = e$2.debugOverlayCanvas, a$2 = e$2.context.gl, o$2 = e$2.debugOverlayCanvas.getContext("2d");
					o$2.clearRect(0, 0, i$2.width, i$2.height), o$2.shadowColor = "white", o$2.shadowBlur = 2, o$2.lineWidth = 1.5, o$2.strokeStyle = "white", o$2.textBaseline = "top", o$2.font = "bold 36px Open Sans, sans-serif", o$2.fillText(t$1, 5, 5), o$2.strokeText(t$1, 5, 5), e$2.debugOverlayTexture.update(i$2), e$2.debugOverlayTexture.bind(a$2.LINEAR, a$2.CLAMP_TO_EDGE);
				}(e$1, `${f$1} ${_$1}kB`);
				const g$1 = e$1.transform.getProjectionData({
					overscaledTileID: a$1,
					applyGlobeMatrix: !0,
					applyTerrainMatrix: !0
				});
				s$1.draw(o$1, r$1.TRIANGLES, n$1, l$1, Qt.alphaBlended, ei.disabled, Yi(t.bp.transparent, m$1), null, g$1, h$1, e$1.debugBuffer, e$1.quadTriangleIndexBuffer, e$1.debugSegments), s$1.draw(o$1, r$1.LINE_STRIP, n$1, l$1, c$1, ei.disabled, Yi(t.bp.red), u$1, g$1, h$1, e$1.debugBuffer, e$1.tileBorderIndexBuffer, e$1.debugSegments);
			}
			function Vo(e$1, t$1, i$1, a$1) {
				const { isRenderingGlobe: o$1 } = a$1, r$1 = e$1.context, s$1 = r$1.gl, n$1 = e$1.transform, l$1 = e$1.colorModeForRenderPass(), c$1 = e$1.getDepthModeFor3D(), h$1 = e$1.useProgram("terrain");
				r$1.bindFramebuffer.set(null), r$1.viewport.set([
					0,
					0,
					e$1.width,
					e$1.height
				]);
				for (const a$2 of i$1) {
					const i$2 = t$1.getTerrainMesh(a$2.tileID), u$1 = e$1.renderToTexture.getTexture(a$2), d$1 = t$1.getTerrainData(a$2.tileID);
					r$1.activeTexture.set(s$1.TEXTURE0), s$1.bindTexture(s$1.TEXTURE_2D, u$1.texture);
					const m$1 = Oi(t$1.getMeshFrameDelta(n$1.zoom), n$1.calculateFogMatrix(a$2.tileID.toUnwrapped()), e$1.style.sky, n$1.pitch, o$1), f$1 = n$1.getProjectionData({
						overscaledTileID: a$2.tileID,
						applyTerrainMatrix: !1,
						applyGlobeMatrix: !0
					});
					h$1.draw(r$1, s$1.TRIANGLES, c$1, ai.disabled, l$1, ei.backCCW, m$1, d$1, f$1, "terrain", i$2.vertexBuffer, i$2.indexBuffer, i$2.segments);
				}
			}
			function qo(e$1, i$1) {
				if (!i$1.mesh) {
					const a$1 = new t.aW();
					a$1.emplaceBack(-1, -1), a$1.emplaceBack(1, -1), a$1.emplaceBack(1, 1), a$1.emplaceBack(-1, 1);
					const o$1 = new t.aY();
					o$1.emplaceBack(0, 1, 2), o$1.emplaceBack(0, 2, 3), i$1.mesh = new kt(e$1.createVertexBuffer(a$1, Ft.members), e$1.createIndexBuffer(o$1), t.aX.simpleSegment(0, 0, a$1.length, o$1.length));
				}
				return i$1.mesh;
			}
			class Wo {
				constructor(e$1, i$1) {
					this.context = new no(e$1), this.transform = i$1, this._tileTextures = {}, this.terrainFacilitator = {
						dirty: !0,
						matrix: t.ar(new Float64Array(16)),
						renderTime: 0
					}, this.setup(), this.numSublayers = ke.maxOverzooming + ke.maxUnderzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Rt();
				}
				resize(e$1, t$1, i$1) {
					if (this.width = Math.floor(e$1 * i$1), this.height = Math.floor(t$1 * i$1), this.pixelRatio = i$1, this.context.viewport.set([
						0,
						0,
						this.width,
						this.height
					]), this.style) for (const e$2 of this.style._order) this.style._layers[e$2].resize();
				}
				setup() {
					const e$1 = this.context, i$1 = new t.aW();
					i$1.emplaceBack(0, 0), i$1.emplaceBack(t.a5, 0), i$1.emplaceBack(0, t.a5), i$1.emplaceBack(t.a5, t.a5), this.tileExtentBuffer = e$1.createVertexBuffer(i$1, Ft.members), this.tileExtentSegments = t.aX.simpleSegment(0, 0, 4, 2);
					const a$1 = new t.aW();
					a$1.emplaceBack(0, 0), a$1.emplaceBack(t.a5, 0), a$1.emplaceBack(0, t.a5), a$1.emplaceBack(t.a5, t.a5), this.debugBuffer = e$1.createVertexBuffer(a$1, Ft.members), this.debugSegments = t.aX.simpleSegment(0, 0, 4, 5);
					const o$1 = new t.ch();
					o$1.emplaceBack(0, 0, 0, 0), o$1.emplaceBack(t.a5, 0, t.a5, 0), o$1.emplaceBack(0, t.a5, 0, t.a5), o$1.emplaceBack(t.a5, t.a5, t.a5, t.a5), this.rasterBoundsBuffer = e$1.createVertexBuffer(o$1, Fi.members), this.rasterBoundsSegments = t.aX.simpleSegment(0, 0, 4, 2);
					const r$1 = new t.aW();
					r$1.emplaceBack(0, 0), r$1.emplaceBack(t.a5, 0), r$1.emplaceBack(0, t.a5), r$1.emplaceBack(t.a5, t.a5), this.rasterBoundsBufferPosOnly = e$1.createVertexBuffer(r$1, Ft.members), this.rasterBoundsSegmentsPosOnly = t.aX.simpleSegment(0, 0, 4, 5);
					const s$1 = new t.aW();
					s$1.emplaceBack(0, 0), s$1.emplaceBack(1, 0), s$1.emplaceBack(0, 1), s$1.emplaceBack(1, 1), this.viewportBuffer = e$1.createVertexBuffer(s$1, Ft.members), this.viewportSegments = t.aX.simpleSegment(0, 0, 4, 2);
					const n$1 = new t.ci();
					n$1.emplaceBack(0), n$1.emplaceBack(1), n$1.emplaceBack(3), n$1.emplaceBack(2), n$1.emplaceBack(0), this.tileBorderIndexBuffer = e$1.createIndexBuffer(n$1);
					const l$1 = new t.aY();
					l$1.emplaceBack(1, 0, 2), l$1.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e$1.createIndexBuffer(l$1);
					const c$1 = this.context.gl;
					this.stencilClearMode = new ai({
						func: c$1.ALWAYS,
						mask: 0
					}, 0, 255, c$1.ZERO, c$1.ZERO, c$1.ZERO), this.tileExtentMesh = new kt(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
				}
				clearStencil() {
					const e$1 = this.context, i$1 = e$1.gl;
					this.nextStencilID = 1, this.currentStencilSource = void 0;
					const a$1 = t.N();
					t.c7(a$1, 0, this.width, this.height, 0, 0, 1), t.Q(a$1, a$1, [
						i$1.drawingBufferWidth,
						i$1.drawingBufferHeight,
						0
					]);
					const o$1 = {
						mainMatrix: a$1,
						tileMercatorCoords: [
							0,
							0,
							1,
							1
						],
						clippingPlane: [
							0,
							0,
							0,
							0
						],
						projectionTransition: 0,
						fallbackMatrix: a$1
					};
					this.useProgram("clippingMask", null, !0).draw(e$1, i$1.TRIANGLES, ti.disabled, this.stencilClearMode, Qt.disabled, ei.disabled, null, null, o$1, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
				}
				_renderTileClippingMasks(e$1, t$1, i$1) {
					if (this.currentStencilSource === e$1.source || !e$1.isTileClipped() || !t$1 || !t$1.length) return;
					this.currentStencilSource = e$1.source, this.nextStencilID + t$1.length > 256 && this.clearStencil();
					const a$1 = this.context;
					a$1.setColorMode(Qt.disabled), a$1.setDepthMode(ti.disabled);
					const o$1 = {};
					for (const e$2 of t$1) o$1[e$2.key] = this.nextStencilID++;
					this._renderTileMasks(o$1, t$1, i$1, !0), this._renderTileMasks(o$1, t$1, i$1, !1), this._tileClippingMaskIDs = o$1;
				}
				_renderTileMasks(e$1, t$1, i$1, a$1) {
					const o$1 = this.context, r$1 = o$1.gl, s$1 = this.style.projection, n$1 = this.transform, l$1 = this.useProgram("clippingMask");
					for (const c$1 of t$1) {
						const t$2 = e$1[c$1.key], h$1 = this.style.map.terrain && this.style.map.terrain.getTerrainData(c$1), u$1 = s$1.getMeshFromTileID(this.context, c$1.canonical, a$1, !0, "stencil"), d$1 = n$1.getProjectionData({
							overscaledTileID: c$1,
							applyGlobeMatrix: !i$1,
							applyTerrainMatrix: !0
						});
						l$1.draw(o$1, r$1.TRIANGLES, ti.disabled, new ai({
							func: r$1.ALWAYS,
							mask: 0
						}, t$2, 255, r$1.KEEP, r$1.KEEP, r$1.REPLACE), Qt.disabled, i$1 ? ei.disabled : ei.backCCW, null, h$1, d$1, "$clipping", u$1.vertexBuffer, u$1.indexBuffer, u$1.segments);
					}
				}
				_renderTilesDepthBuffer() {
					const e$1 = this.context, t$1 = e$1.gl, i$1 = this.style.projection, a$1 = this.transform, o$1 = this.useProgram("depth"), r$1 = this.getDepthModeFor3D(), s$1 = Ie(a$1, { tileSize: a$1.tileSize });
					for (const n$1 of s$1) {
						const s$2 = this.style.map.terrain && this.style.map.terrain.getTerrainData(n$1), l$1 = i$1.getMeshFromTileID(this.context, n$1.canonical, !0, !0, "raster"), c$1 = a$1.getProjectionData({
							overscaledTileID: n$1,
							applyGlobeMatrix: !0,
							applyTerrainMatrix: !0
						});
						o$1.draw(e$1, t$1.TRIANGLES, r$1, ai.disabled, Qt.disabled, ei.backCCW, null, s$2, c$1, "$clipping", l$1.vertexBuffer, l$1.indexBuffer, l$1.segments);
					}
				}
				stencilModeFor3D() {
					this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
					const e$1 = this.nextStencilID++, t$1 = this.context.gl;
					return new ai({
						func: t$1.NOTEQUAL,
						mask: 255
					}, e$1, 255, t$1.KEEP, t$1.KEEP, t$1.REPLACE);
				}
				stencilModeForClipping(e$1) {
					const t$1 = this.context.gl;
					return new ai({
						func: t$1.EQUAL,
						mask: 255
					}, this._tileClippingMaskIDs[e$1.key], 0, t$1.KEEP, t$1.KEEP, t$1.REPLACE);
				}
				getStencilConfigForOverlapAndUpdateStencilID(e$1) {
					const t$1 = this.context.gl, i$1 = e$1.sort(((e$2, t$2) => t$2.overscaledZ - e$2.overscaledZ)), a$1 = i$1[i$1.length - 1].overscaledZ, o$1 = i$1[0].overscaledZ - a$1 + 1;
					if (o$1 > 1) {
						this.currentStencilSource = void 0, this.nextStencilID + o$1 > 256 && this.clearStencil();
						const e$2 = {};
						for (let i$2 = 0; i$2 < o$1; i$2++) e$2[i$2 + a$1] = new ai({
							func: t$1.GEQUAL,
							mask: 255
						}, i$2 + this.nextStencilID, 255, t$1.KEEP, t$1.KEEP, t$1.REPLACE);
						return this.nextStencilID += o$1, [e$2, i$1];
					}
					return [{ [a$1]: ai.disabled }, i$1];
				}
				stencilConfigForOverlapTwoPass(e$1) {
					const t$1 = this.context.gl, i$1 = e$1.sort(((e$2, t$2) => t$2.overscaledZ - e$2.overscaledZ)), a$1 = i$1[i$1.length - 1].overscaledZ, o$1 = i$1[0].overscaledZ - a$1 + 1;
					if (this.clearStencil(), o$1 > 1) {
						const e$2 = {}, r$1 = {};
						for (let i$2 = 0; i$2 < o$1; i$2++) e$2[i$2 + a$1] = new ai({
							func: t$1.GREATER,
							mask: 255
						}, o$1 + 1 + i$2, 255, t$1.KEEP, t$1.KEEP, t$1.REPLACE), r$1[i$2 + a$1] = new ai({
							func: t$1.GREATER,
							mask: 255
						}, 1 + i$2, 255, t$1.KEEP, t$1.KEEP, t$1.REPLACE);
						return this.nextStencilID = 2 * o$1 + 1, [
							e$2,
							r$1,
							i$1
						];
					}
					return this.nextStencilID = 3, [
						{ [a$1]: new ai({
							func: t$1.GREATER,
							mask: 255
						}, 2, 255, t$1.KEEP, t$1.KEEP, t$1.REPLACE) },
						{ [a$1]: new ai({
							func: t$1.GREATER,
							mask: 255
						}, 1, 255, t$1.KEEP, t$1.KEEP, t$1.REPLACE) },
						i$1
					];
				}
				colorModeForRenderPass() {
					const e$1 = this.context.gl;
					if (this._showOverdrawInspector) {
						const i$1 = 1 / 8;
						return new Qt([e$1.CONSTANT_COLOR, e$1.ONE], new t.bp(i$1, i$1, i$1, 0), [
							!0,
							!0,
							!0,
							!0
						]);
					}
					return "opaque" === this.renderPass ? Qt.unblended : Qt.alphaBlended;
				}
				getDepthModeForSublayer(e$1, t$1, i$1) {
					if (!this.opaquePassEnabledForLayer()) return ti.disabled;
					const a$1 = 1 - ((1 + this.currentLayer) * this.numSublayers + e$1) * this.depthEpsilon;
					return new ti(i$1 || this.context.gl.LEQUAL, t$1, [a$1, a$1]);
				}
				getDepthModeFor3D() {
					return new ti(this.context.gl.LEQUAL, ti.ReadWrite, this.depthRangeFor3D);
				}
				opaquePassEnabledForLayer() {
					return this.currentLayer < this.opaquePassCutoff;
				}
				render(e$1, i$1) {
					var a$1, o$1;
					this.style = e$1, this.options = i$1, this.lineAtlas = e$1.lineAtlas, this.imageManager = e$1.imageManager, this.glyphManager = e$1.glyphManager, this.symbolFadeChange = e$1.placement.symbolFadeChange(c()), this.imageManager.beginFrame();
					const r$1 = this.style._order, s$1 = this.style.tileManagers, n$1 = {}, l$1 = {}, h$1 = {}, u$1 = {
						isRenderingToTexture: !1,
						isRenderingGlobe: (null === (a$1 = e$1.projection) || void 0 === a$1 ? void 0 : a$1.transitionState) > 0
					};
					for (const e$2 in s$1) {
						const t$1 = s$1[e$2];
						t$1.used && t$1.prepare(this.context), n$1[e$2] = t$1.getVisibleCoordinates(!1), l$1[e$2] = n$1[e$2].slice().reverse(), h$1[e$2] = t$1.getVisibleCoordinates(!0).reverse();
					}
					this.opaquePassCutoff = Infinity;
					for (let e$2 = 0; e$2 < r$1.length; e$2++) if (this.style._layers[r$1[e$2]].is3D()) {
						this.opaquePassCutoff = e$2;
						break;
					}
					this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
					for (const e$2 of r$1) {
						const t$1 = this.style._layers[e$2];
						if (!t$1.hasOffscreenPass() || t$1.isHidden(this.transform.zoom)) continue;
						const i$2 = l$1[t$1.source];
						("custom" === t$1.type || i$2.length) && this.renderLayer(this, s$1[t$1.source], t$1, i$2, u$1);
					}
					if (null === (o$1 = this.style.projection) || void 0 === o$1 || o$1.updateGPUdependent({
						context: this.context,
						useProgram: (e$2) => this.useProgram(e$2)
					}), this.context.viewport.set([
						0,
						0,
						this.width,
						this.height
					]), this.context.bindFramebuffer.set(null), this.context.clear({
						color: i$1.showOverdrawInspector ? t.bp.black : t.bp.transparent,
						depth: 1
					}), this.clearStencil(), this.style.sky && function(e$2, t$1) {
						const i$2 = e$2.context, a$2 = i$2.gl, o$2 = ((e$3, t$2, i$3) => {
							const a$3 = Math.cos(t$2.rollInRadians), o$3 = Math.sin(t$2.rollInRadians), r$3 = ge(t$2), s$3 = t$2.getProjectionData({
								overscaledTileID: null,
								applyGlobeMatrix: !0,
								applyTerrainMatrix: !0
							}).projectionTransition;
							return {
								u_sky_color: e$3.properties.get("sky-color"),
								u_horizon_color: e$3.properties.get("horizon-color"),
								u_horizon: [(t$2.width / 2 - r$3 * o$3) * i$3, (t$2.height / 2 + r$3 * a$3) * i$3],
								u_horizon_normal: [-o$3, a$3],
								u_sky_horizon_blend: e$3.properties.get("sky-horizon-blend") * t$2.height / 2 * i$3,
								u_sky_blend: s$3
							};
						})(t$1, e$2.style.map.transform, e$2.pixelRatio), r$2 = new ti(a$2.LEQUAL, ti.ReadWrite, [0, 1]), s$2 = ai.disabled, n$2 = e$2.colorModeForRenderPass(), l$2 = e$2.useProgram("sky"), c$1 = qo(i$2, t$1);
						l$2.draw(i$2, a$2.TRIANGLES, r$2, s$2, n$2, ei.disabled, o$2, null, void 0, "sky", c$1.vertexBuffer, c$1.indexBuffer, c$1.segments);
					}(this, this.style.sky), this._showOverdrawInspector = i$1.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e$1._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = r$1.length - 1; this.currentLayer >= 0; this.currentLayer--) {
						const e$2 = this.style._layers[r$1[this.currentLayer]], t$1 = s$1[e$2.source], i$2 = n$1[e$2.source];
						this._renderTileClippingMasks(e$2, i$2, !1), this.renderLayer(this, t$1, e$2, i$2, u$1);
					}
					this.renderPass = "translucent";
					let d$1 = !1;
					for (this.currentLayer = 0; this.currentLayer < r$1.length; this.currentLayer++) {
						const e$2 = this.style._layers[r$1[this.currentLayer]], t$1 = s$1[e$2.source];
						if (this.renderToTexture && this.renderToTexture.renderLayer(e$2, u$1)) continue;
						this.opaquePassEnabledForLayer() || d$1 || (d$1 = !0, u$1.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
						const i$2 = ("symbol" === e$2.type ? h$1 : l$1)[e$2.source];
						this._renderTileClippingMasks(e$2, n$1[e$2.source], !!this.renderToTexture), this.renderLayer(this, t$1, e$2, i$2, u$1);
					}
					if (u$1.isRenderingGlobe && function(e$2, i$2, a$2) {
						const o$2 = e$2.context, r$2 = o$2.gl, s$2 = e$2.useProgram("atmosphere"), n$2 = new ti(r$2.LEQUAL, ti.ReadOnly, [0, 1]), l$2 = e$2.transform, c$1 = function(e$3, i$3) {
							const a$3 = e$3.properties.get("position"), o$3 = [
								-a$3.x,
								-a$3.y,
								-a$3.z
							], r$3 = t.ar(new Float64Array(16));
							return "map" === e$3.properties.get("anchor") && (t.bg(r$3, r$3, i$3.rollInRadians), t.bh(r$3, r$3, -i$3.pitchInRadians), t.bg(r$3, r$3, i$3.bearingInRadians), t.bh(r$3, r$3, i$3.center.lat * Math.PI / 180), t.bJ(r$3, r$3, -i$3.center.lng * Math.PI / 180)), t.cg(o$3, o$3, r$3), o$3;
						}(a$2, e$2.transform), h$2 = l$2.getProjectionData({
							overscaledTileID: null,
							applyGlobeMatrix: !0,
							applyTerrainMatrix: !0
						}), u$2 = i$2.properties.get("atmosphere-blend") * h$2.projectionTransition;
						if (0 === u$2) return;
						const d$2 = fi(l$2.worldSize, l$2.center.lat), _$1 = l$2.inverseProjectionMatrix, p$1 = new Float64Array(4);
						p$1[3] = 1, t.aH(p$1, p$1, l$2.modelViewProjectionMatrix), p$1[0] /= p$1[3], p$1[1] /= p$1[3], p$1[2] /= p$1[3], p$1[3] = 1, t.aH(p$1, p$1, _$1), p$1[0] /= p$1[3], p$1[1] /= p$1[3], p$1[2] /= p$1[3], p$1[3] = 1;
						const m$1 = ((e$3, t$1, i$3, a$3, o$3) => ({
							u_sun_pos: e$3,
							u_atmosphere_blend: t$1,
							u_globe_position: i$3,
							u_globe_radius: a$3,
							u_inv_proj_matrix: o$3
						}))(c$1, u$2, [
							p$1[0],
							p$1[1],
							p$1[2]
						], d$2, _$1), f$1 = qo(o$2, i$2);
						s$2.draw(o$2, r$2.TRIANGLES, n$2, ai.disabled, Qt.alphaBlended, ei.disabled, m$1, null, null, "atmosphere", f$1.vertexBuffer, f$1.indexBuffer, f$1.segments);
					}(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
						const e$2 = function(e$3, t$1) {
							let i$2 = null;
							const a$2 = Object.values(e$3._layers).flatMap(((i$3) => i$3.source && !i$3.isHidden(t$1) ? [e$3.tileManagers[i$3.source]] : [])), o$2 = a$2.filter(((e$4) => "vector" === e$4.getSource().type)), r$2 = a$2.filter(((e$4) => "vector" !== e$4.getSource().type)), s$2 = (e$4) => {
								(!i$2 || i$2.getSource().maxzoom < e$4.getSource().maxzoom) && (i$2 = e$4);
							};
							return o$2.forEach(((e$4) => s$2(e$4))), i$2 || r$2.forEach(((e$4) => s$2(e$4))), i$2;
						}(this.style, this.transform.zoom);
						e$2 && function(e$3, t$1, i$2) {
							for (let a$2 = 0; a$2 < i$2.length; a$2++) Go(e$3, t$1, i$2[a$2]);
						}(this, e$2, e$2.getVisibleCoordinates());
					}
					this.options.showPadding && function(e$2) {
						const t$1 = e$2.transform.padding;
						No(e$2, e$2.transform.height - (t$1.top || 0), 3, ko), No(e$2, t$1.bottom || 0, 3, Fo), Zo(e$2, t$1.left || 0, 3, Bo), Zo(e$2, e$2.transform.width - (t$1.right || 0), 3, Oo);
						const i$2 = e$2.transform.centerPoint;
						(function(e$3, t$2, i$3, a$2) {
							Uo(e$3, t$2 - 1, i$3 - 10, 2, 20, a$2), Uo(e$3, t$2 - 10, i$3 - 1, 20, 2, a$2);
						})(e$2, i$2.x, e$2.transform.height - i$2.y, jo);
					}(this), this.context.setDefault();
				}
				maybeDrawDepthAndCoords(e$1) {
					if (!this.style || !this.style.map || !this.style.map.terrain) return;
					const i$1 = this.terrainFacilitator.matrix, a$1 = this.transform.modelViewProjectionMatrix;
					let o$1 = this.terrainFacilitator.dirty;
					o$1 || (o$1 = e$1 ? !t.cj(i$1, a$1) : !t.ck(i$1, a$1)), o$1 || (o$1 = this.style.map.terrain.tileManager.anyTilesAfterTime(this.terrainFacilitator.renderTime)), o$1 && (t.cl(i$1, a$1), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function(e$2, i$2) {
						const a$2 = e$2.context, o$2 = a$2.gl, r$1 = e$2.transform, s$1 = Qt.unblended, n$1 = new ti(o$2.LEQUAL, ti.ReadWrite, [0, 1]), l$1 = i$2.tileManager.getRenderableTiles(), c$1 = e$2.useProgram("terrainDepth");
						a$2.bindFramebuffer.set(i$2.getFramebuffer("depth").framebuffer), a$2.viewport.set([
							0,
							0,
							e$2.width / devicePixelRatio,
							e$2.height / devicePixelRatio
						]), a$2.clear({
							color: t.bp.transparent,
							depth: 1
						});
						for (const e$3 of l$1) {
							const t$1 = i$2.getTerrainMesh(e$3.tileID), l$2 = i$2.getTerrainData(e$3.tileID), h$1 = r$1.getProjectionData({
								overscaledTileID: e$3.tileID,
								applyTerrainMatrix: !1,
								applyGlobeMatrix: !0
							}), u$1 = { u_ele_delta: i$2.getMeshFrameDelta(r$1.zoom) };
							c$1.draw(a$2, o$2.TRIANGLES, n$1, ai.disabled, s$1, ei.backCCW, u$1, l$2, h$1, "terrain", t$1.vertexBuffer, t$1.indexBuffer, t$1.segments);
						}
						a$2.bindFramebuffer.set(null), a$2.viewport.set([
							0,
							0,
							e$2.width,
							e$2.height
						]);
					}(this, this.style.map.terrain), function(e$2, i$2) {
						const a$2 = e$2.context, o$2 = a$2.gl, r$1 = e$2.transform, s$1 = Qt.unblended, n$1 = new ti(o$2.LEQUAL, ti.ReadWrite, [0, 1]), l$1 = i$2.getCoordsTexture(), c$1 = i$2.tileManager.getRenderableTiles(), h$1 = e$2.useProgram("terrainCoords");
						a$2.bindFramebuffer.set(i$2.getFramebuffer("coords").framebuffer), a$2.viewport.set([
							0,
							0,
							e$2.width / devicePixelRatio,
							e$2.height / devicePixelRatio
						]), a$2.clear({
							color: t.bp.transparent,
							depth: 1
						}), i$2.coordsIndex = [];
						for (const e$3 of c$1) {
							const t$1 = i$2.getTerrainMesh(e$3.tileID), c$2 = i$2.getTerrainData(e$3.tileID);
							a$2.activeTexture.set(o$2.TEXTURE0), o$2.bindTexture(o$2.TEXTURE_2D, l$1.texture);
							const u$1 = {
								u_terrain_coords_id: (255 - i$2.coordsIndex.length) / 255,
								u_texture: 0,
								u_ele_delta: i$2.getMeshFrameDelta(r$1.zoom)
							}, d$1 = r$1.getProjectionData({
								overscaledTileID: e$3.tileID,
								applyTerrainMatrix: !1,
								applyGlobeMatrix: !0
							});
							h$1.draw(a$2, o$2.TRIANGLES, n$1, ai.disabled, s$1, ei.backCCW, u$1, c$2, d$1, "terrain", t$1.vertexBuffer, t$1.indexBuffer, t$1.segments), i$2.coordsIndex.push(e$3.tileID.key);
						}
						a$2.bindFramebuffer.set(null), a$2.viewport.set([
							0,
							0,
							e$2.width,
							e$2.height
						]);
					}(this, this.style.map.terrain));
				}
				renderLayer(e$1, i$1, a$1, o$1, r$1) {
					a$1.isHidden(this.transform.zoom) || ("background" === a$1.type || "custom" === a$1.type || (o$1 || []).length) && (this.id = a$1.id, t.cm(a$1) ? function(e$2, i$2, a$2, o$2, r$2, s$1) {
						if ("translucent" !== e$2.renderPass) return;
						const { isRenderingToTexture: n$1 } = s$1, l$1 = ai.disabled, c$1 = e$2.colorModeForRenderPass();
						(a$2._unevaluatedLayout.hasValue("text-variable-anchor") || a$2._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(e$3, i$3, a$3, o$3, r$3, s$2, n$2, l$2, c$2) {
							const h$1 = i$3.transform, u$1 = i$3.style.map.terrain, d$1 = "map" === r$3, _$1 = "map" === s$2;
							for (const r$4 of e$3) {
								const e$4 = o$3.getTile(r$4), s$3 = e$4.getBucket(a$3);
								if (!s$3 || !s$3.text || !s$3.text.segments.get().length) continue;
								const p$1 = t.ay(s$3.textSizeData, h$1.zoom), m$1 = t.aN(e$4, 1, i$3.transform.zoom), f$1 = je(d$1, i$3.transform, m$1), g$1 = "none" !== a$3.layout.get("icon-text-fit") && s$3.hasIconData();
								if (p$1) {
									const i$4 = Math.pow(2, h$1.zoom - e$4.tileID.overscaledZ), a$4 = u$1 ? (e$5, t$1) => u$1.getElevation(r$4, e$5, t$1) : null;
									po(s$3, d$1, _$1, c$2, h$1, f$1, i$4, p$1, g$1, t.aO(h$1, e$4, n$2, l$2), r$4.toUnwrapped(), a$4);
								}
							}
						}(o$2, e$2, a$2, i$2, a$2.layout.get("text-rotation-alignment"), a$2.layout.get("text-pitch-alignment"), a$2.paint.get("text-translate"), a$2.paint.get("text-translate-anchor"), r$2), 0 !== a$2.paint.get("icon-opacity").constantOr(1) && fo(e$2, i$2, a$2, o$2, !1, a$2.paint.get("icon-translate"), a$2.paint.get("icon-translate-anchor"), a$2.layout.get("icon-rotation-alignment"), a$2.layout.get("icon-pitch-alignment"), a$2.layout.get("icon-keep-upright"), l$1, c$1, n$1), 0 !== a$2.paint.get("text-opacity").constantOr(1) && fo(e$2, i$2, a$2, o$2, !0, a$2.paint.get("text-translate"), a$2.paint.get("text-translate-anchor"), a$2.layout.get("text-rotation-alignment"), a$2.layout.get("text-pitch-alignment"), a$2.layout.get("text-keep-upright"), l$1, c$1, n$1), i$2.map.showCollisionBoxes && (co(e$2, i$2, a$2, o$2, !0), co(e$2, i$2, a$2, o$2, !1));
					}(e$1, i$1, a$1, o$1, this.style.placement.variableOffsets, r$1) : t.cn(a$1) ? function(e$2, i$2, a$2, o$2, r$2) {
						if ("translucent" !== e$2.renderPass) return;
						const { isRenderingToTexture: s$1 } = r$2, n$1 = a$2.paint.get("circle-opacity"), l$1 = a$2.paint.get("circle-stroke-width"), c$1 = a$2.paint.get("circle-stroke-opacity"), h$1 = !a$2.layout.get("circle-sort-key").isConstant();
						if (0 === n$1.constantOr(1) && (0 === l$1.constantOr(1) || 0 === c$1.constantOr(1))) return;
						const u$1 = e$2.context, d$1 = u$1.gl, _$1 = e$2.transform, p$1 = e$2.getDepthModeForSublayer(0, ti.ReadOnly), m$1 = ai.disabled, f$1 = e$2.colorModeForRenderPass(), g$1 = [], v$1 = _$1.getCircleRadiusCorrection();
						for (let r$3 = 0; r$3 < o$2.length; r$3++) {
							const n$2 = o$2[r$3], l$2 = i$2.getTile(n$2), c$2 = l$2.getBucket(a$2);
							if (!c$2) continue;
							const u$2 = a$2.paint.get("circle-translate"), d$2 = a$2.paint.get("circle-translate-anchor"), p$2 = t.aO(_$1, l$2, u$2, d$2), m$2 = c$2.programConfigurations.get(a$2.id), f$2 = e$2.useProgram("circle", m$2), x$1 = c$2.layoutVertexBuffer, b$1 = c$2.indexBuffer, y$1 = e$2.style.map.terrain && e$2.style.map.terrain.getTerrainData(n$2), w$1 = {
								programConfiguration: m$2,
								program: f$2,
								layoutVertexBuffer: x$1,
								indexBuffer: b$1,
								uniformValues: Hi(e$2, l$2, a$2, p$2, v$1),
								terrainData: y$1,
								projectionData: _$1.getProjectionData({
									overscaledTileID: n$2,
									applyGlobeMatrix: !s$1,
									applyTerrainMatrix: !0
								})
							};
							if (h$1) {
								const e$3 = c$2.segments.get();
								for (const i$3 of e$3) g$1.push({
									segments: new t.aX([i$3]),
									sortKey: i$3.sortKey,
									state: w$1
								});
							} else g$1.push({
								segments: c$2.segments,
								sortKey: 0,
								state: w$1
							});
						}
						h$1 && g$1.sort(((e$3, t$1) => e$3.sortKey - t$1.sortKey));
						for (const t$1 of g$1) {
							const { programConfiguration: i$3, program: o$3, layoutVertexBuffer: r$3, indexBuffer: s$2, uniformValues: n$2, terrainData: l$2, projectionData: c$2 } = t$1.state;
							o$3.draw(u$1, d$1.TRIANGLES, p$1, m$1, f$1, ei.backCCW, n$2, l$2, c$2, a$2.id, r$3, s$2, t$1.segments, a$2.paint, e$2.transform.zoom, i$3);
						}
					}(e$1, i$1, a$1, o$1, r$1) : t.co(a$1) ? function(e$2, i$2, a$2, o$2, r$2) {
						if (0 === a$2.paint.get("heatmap-opacity")) return;
						const s$1 = e$2.context, { isRenderingToTexture: n$1, isRenderingGlobe: l$1 } = r$2;
						if (e$2.style.map.terrain) {
							for (const t$1 of o$2) {
								const o$3 = i$2.getTile(t$1);
								i$2.hasRenderableParent(t$1) || ("offscreen" === e$2.renderPass ? vo(e$2, o$3, a$2, t$1, l$1) : "translucent" === e$2.renderPass && xo(e$2, a$2, t$1, n$1, l$1));
							}
							s$1.viewport.set([
								0,
								0,
								e$2.width,
								e$2.height
							]);
						} else "offscreen" === e$2.renderPass ? function(e$3, i$3, a$3, o$3) {
							const r$3 = e$3.context, s$2 = r$3.gl, n$2 = e$3.transform, l$2 = ai.disabled, c$1 = new Qt([s$2.ONE, s$2.ONE], t.bp.transparent, [
								!0,
								!0,
								!0,
								!0
							]);
							(function(e$4, i$4, a$4) {
								const o$4 = e$4.gl;
								e$4.activeTexture.set(o$4.TEXTURE1), e$4.viewport.set([
									0,
									0,
									i$4.width / 4,
									i$4.height / 4
								]);
								let r$4 = a$4.heatmapFbos.get(t.cd);
								r$4 ? (o$4.bindTexture(o$4.TEXTURE_2D, r$4.colorAttachment.get()), e$4.bindFramebuffer.set(r$4.framebuffer)) : (r$4 = bo(e$4, i$4.width / 4, i$4.height / 4), a$4.heatmapFbos.set(t.cd, r$4));
							})(r$3, e$3, a$3), r$3.clear({ color: t.bp.transparent });
							for (let t$1 = 0; t$1 < o$3.length; t$1++) {
								const h$1 = o$3[t$1];
								if (i$3.hasRenderableParent(h$1)) continue;
								const u$1 = i$3.getTile(h$1), d$1 = u$1.getBucket(a$3);
								if (!d$1) continue;
								const _$1 = d$1.programConfigurations.get(a$3.id), p$1 = e$3.useProgram("heatmap", _$1), m$1 = n$2.getProjectionData({
									overscaledTileID: h$1,
									applyGlobeMatrix: !0,
									applyTerrainMatrix: !1
								}), f$1 = n$2.getCircleRadiusCorrection();
								p$1.draw(r$3, s$2.TRIANGLES, ti.disabled, l$2, c$1, ei.backCCW, Qi(u$1, n$2.zoom, a$3.paint.get("heatmap-intensity"), f$1), null, m$1, a$3.id, d$1.layoutVertexBuffer, d$1.indexBuffer, d$1.segments, a$3.paint, n$2.zoom, _$1);
							}
							r$3.viewport.set([
								0,
								0,
								e$3.width,
								e$3.height
							]);
						}(e$2, i$2, a$2, o$2) : "translucent" === e$2.renderPass && function(e$3, i$3) {
							const a$3 = e$3.context, o$3 = a$3.gl;
							a$3.setColorMode(e$3.colorModeForRenderPass());
							const r$3 = i$3.heatmapFbos.get(t.cd);
							r$3 && (a$3.activeTexture.set(o$3.TEXTURE0), o$3.bindTexture(o$3.TEXTURE_2D, r$3.colorAttachment.get()), a$3.activeTexture.set(o$3.TEXTURE1), yo(a$3, i$3).bind(o$3.LINEAR, o$3.CLAMP_TO_EDGE), e$3.useProgram("heatmapTexture").draw(a$3, o$3.TRIANGLES, ti.disabled, ai.disabled, e$3.colorModeForRenderPass(), ei.disabled, Ji(e$3, i$3, 0, 1), null, null, i$3.id, e$3.viewportBuffer, e$3.quadTriangleIndexBuffer, e$3.viewportSegments, i$3.paint, e$3.transform.zoom));
						}(e$2, a$2);
					}(e$1, i$1, a$1, o$1, r$1) : t.cp(a$1) ? function(e$2, t$1, i$2, a$2, o$2) {
						if ("translucent" !== e$2.renderPass) return;
						const { isRenderingToTexture: r$2 } = o$2, s$1 = i$2.paint.get("line-opacity"), n$1 = i$2.paint.get("line-width");
						if (0 === s$1.constantOr(1) || 0 === n$1.constantOr(1)) return;
						const l$1 = e$2.getDepthModeForSublayer(0, ti.ReadOnly), c$1 = e$2.colorModeForRenderPass(), h$1 = i$2.paint.get("line-dasharray"), u$1 = h$1.constantOr(1), d$1 = i$2.paint.get("line-pattern"), _$1 = d$1.constantOr(1), p$1 = i$2.paint.get("line-gradient"), m$1 = i$2.getCrossfadeParameters();
						let f$1;
						f$1 = _$1 ? "linePattern" : u$1 && p$1 ? "lineGradientSDF" : u$1 ? "lineSDF" : p$1 ? "lineGradient" : "line";
						const g$1 = e$2.context, v$1 = g$1.gl, x$1 = e$2.transform;
						let b$1 = !0;
						for (const o$3 of a$2) {
							const a$3 = t$1.getTile(o$3);
							if (_$1 && !a$3.patternsLoaded()) continue;
							const s$2 = a$3.getBucket(i$2);
							if (!s$2) continue;
							const n$2 = s$2.programConfigurations.get(i$2.id), y$1 = e$2.context.program.get(), w$1 = e$2.useProgram(f$1, n$2), T$1 = b$1 || w$1.program !== y$1, P$1 = e$2.style.map.terrain && e$2.style.map.terrain.getTerrainData(o$3), C$1 = d$1.constantOr(null), I$1 = h$1 && h$1.constantOr(null);
							if (C$1 && a$3.imageAtlas) {
								const e$3 = a$3.imageAtlas, t$2 = e$3.patternPositions[C$1.to.toString()], i$3 = e$3.patternPositions[C$1.from.toString()];
								t$2 && i$3 && n$2.setConstantPatternPositions(t$2, i$3);
							} else if (I$1) {
								const t$2 = "round" === i$2.layout.get("line-cap"), a$4 = e$2.lineAtlas.getDash(I$1.to, t$2), o$4 = e$2.lineAtlas.getDash(I$1.from, t$2);
								n$2.setConstantDashPositions(a$4, o$4);
							}
							const M$1 = x$1.getProjectionData({
								overscaledTileID: o$3,
								applyGlobeMatrix: !r$2,
								applyTerrainMatrix: !0
							}), E$1 = x$1.getPixelScale();
							let S$1;
							_$1 ? (S$1 = sa(e$2, a$3, i$2, E$1, m$1), To(g$1, v$1, a$3, n$2, m$1)) : u$1 && p$1 ? (S$1 = la(e$2, a$3, i$2, E$1, m$1, s$2.lineClipsArray.length), Io(e$2, t$1, g$1, v$1, i$2, s$2, o$3, n$2, m$1)) : u$1 ? (S$1 = na(e$2, a$3, i$2, E$1, m$1), Po(e$2, g$1, v$1, n$2, T$1, m$1)) : p$1 ? (S$1 = ra(e$2, a$3, i$2, E$1, s$2.lineClipsArray.length), Co(e$2, t$1, g$1, v$1, i$2, s$2, o$3)) : S$1 = oa(e$2, a$3, i$2, E$1);
							const z$1 = e$2.stencilModeForClipping(o$3);
							w$1.draw(g$1, v$1.TRIANGLES, l$1, z$1, c$1, ei.disabled, S$1, P$1, M$1, i$2.id, s$2.layoutVertexBuffer, s$2.indexBuffer, s$2.segments, i$2.paint, e$2.transform.zoom, n$2, s$2.layoutVertexBuffer2), b$1 = !1;
						}
					}(e$1, i$1, a$1, o$1, r$1) : t.cq(a$1) ? function(e$2, i$2, a$2, o$2, r$2) {
						const s$1 = a$2.paint.get("fill-color"), n$1 = a$2.paint.get("fill-opacity");
						if (0 === n$1.constantOr(1)) return;
						const { isRenderingToTexture: l$1 } = r$2, c$1 = e$2.colorModeForRenderPass(), h$1 = a$2.paint.get("fill-pattern"), u$1 = e$2.opaquePassEnabledForLayer() && !h$1.constantOr(1) && 1 === s$1.constantOr(t.bp.transparent).a && 1 === n$1.constantOr(0) ? "opaque" : "translucent";
						if (e$2.renderPass === u$1) Eo(e$2, i$2, a$2, o$2, e$2.getDepthModeForSublayer(1, "opaque" === e$2.renderPass ? ti.ReadWrite : ti.ReadOnly), c$1, !1, l$1);
						if ("translucent" === e$2.renderPass && a$2.paint.get("fill-antialias")) Eo(e$2, i$2, a$2, o$2, e$2.getDepthModeForSublayer(a$2.getPaintProperty("fill-outline-color") ? 2 : 0, ti.ReadOnly), c$1, !0, l$1);
					}(e$1, i$1, a$1, o$1, r$1) : t.cr(a$1) ? function(e$2, t$1, i$2, a$2, o$2) {
						const r$2 = i$2.paint.get("fill-extrusion-opacity");
						if (0 === r$2) return;
						const { isRenderingToTexture: s$1 } = o$2;
						if ("translucent" === e$2.renderPass) {
							const o$3 = new ti(e$2.context.gl.LEQUAL, ti.ReadWrite, e$2.depthRangeFor3D);
							if (1 !== r$2 || i$2.paint.get("fill-extrusion-pattern").constantOr(1)) So(e$2, t$1, i$2, a$2, o$3, ai.disabled, Qt.disabled, s$1), So(e$2, t$1, i$2, a$2, o$3, e$2.stencilModeFor3D(), e$2.colorModeForRenderPass(), s$1);
							else {
								const r$3 = e$2.colorModeForRenderPass();
								So(e$2, t$1, i$2, a$2, o$3, ai.disabled, r$3, s$1);
							}
						}
					}(e$1, i$1, a$1, o$1, r$1) : t.cs(a$1) ? function(e$2, i$2, a$2, o$2, r$2) {
						if ("offscreen" !== e$2.renderPass && "translucent" !== e$2.renderPass) return;
						const { isRenderingToTexture: s$1 } = r$2, n$1 = e$2.context, l$1 = e$2.style.projection.useSubdivision, c$1 = e$2.getDepthModeForSublayer(0, ti.ReadOnly), h$1 = e$2.colorModeForRenderPass();
						if ("offscreen" === e$2.renderPass) (function(e$3, i$3, a$3, o$3, r$3, s$2, n$2) {
							const l$2 = e$3.context, c$2 = l$2.gl;
							for (const h$2 of a$3) {
								const a$4 = i$3.getTile(h$2), u$1 = a$4.dem;
								if (!u$1 || !u$1.data) continue;
								if (!a$4.needsHillshadePrepare) continue;
								const d$1 = u$1.dim, _$1 = u$1.stride, p$1 = u$1.getPixels();
								if (l$2.activeTexture.set(c$2.TEXTURE1), l$2.pixelStoreUnpackPremultiplyAlpha.set(!1), a$4.demTexture = a$4.demTexture || e$3.getTileTexture(_$1), a$4.demTexture) {
									const e$4 = a$4.demTexture;
									e$4.update(p$1, { premultiply: !1 }), e$4.bind(c$2.NEAREST, c$2.CLAMP_TO_EDGE);
								} else a$4.demTexture = new t.T(l$2, p$1, c$2.RGBA, { premultiply: !1 }), a$4.demTexture.bind(c$2.NEAREST, c$2.CLAMP_TO_EDGE);
								l$2.activeTexture.set(c$2.TEXTURE0);
								let m$1 = a$4.fbo;
								if (!m$1) {
									const e$4 = new t.T(l$2, {
										width: d$1,
										height: d$1,
										data: null
									}, c$2.RGBA);
									e$4.bind(c$2.LINEAR, c$2.CLAMP_TO_EDGE), m$1 = a$4.fbo = l$2.createFramebuffer(d$1, d$1, !0, !1), m$1.colorAttachment.set(e$4.texture);
								}
								l$2.bindFramebuffer.set(m$1.framebuffer), l$2.viewport.set([
									0,
									0,
									d$1,
									d$1
								]), e$3.useProgram("hillshadePrepare").draw(l$2, c$2.TRIANGLES, r$3, s$2, n$2, ei.disabled, ta(a$4.tileID, u$1), null, null, o$3.id, e$3.rasterBoundsBuffer, e$3.quadTriangleIndexBuffer, e$3.rasterBoundsSegments), a$4.needsHillshadePrepare = !1;
							}
						})(e$2, i$2, o$2, a$2, c$1, ai.disabled, h$1), n$1.viewport.set([
							0,
							0,
							e$2.width,
							e$2.height
						]);
						else if ("translucent" === e$2.renderPass) if (l$1) {
							const [t$1, r$3, n$2] = e$2.stencilConfigForOverlapTwoPass(o$2);
							zo(e$2, i$2, a$2, n$2, t$1, c$1, h$1, !1, s$1), zo(e$2, i$2, a$2, n$2, r$3, c$1, h$1, !0, s$1);
						} else {
							const [t$1, r$3] = e$2.getStencilConfigForOverlapAndUpdateStencilID(o$2);
							zo(e$2, i$2, a$2, r$3, t$1, c$1, h$1, !1, s$1);
						}
					}(e$1, i$1, a$1, o$1, r$1) : t.ct(a$1) ? function(e$2, t$1, i$2, a$2, o$2) {
						if ("translucent" !== e$2.renderPass) return;
						if (!a$2.length) return;
						const { isRenderingToTexture: r$2 } = o$2, s$1 = e$2.style.projection.useSubdivision, n$1 = e$2.getDepthModeForSublayer(0, ti.ReadOnly), l$1 = e$2.colorModeForRenderPass();
						if (s$1) {
							const [o$3, s$2, c$1] = e$2.stencilConfigForOverlapTwoPass(a$2);
							Ro(e$2, t$1, i$2, c$1, o$3, n$1, l$1, !1, r$2), Ro(e$2, t$1, i$2, c$1, s$2, n$1, l$1, !0, r$2);
						} else {
							const [o$3, s$2] = e$2.getStencilConfigForOverlapAndUpdateStencilID(a$2);
							Ro(e$2, t$1, i$2, s$2, o$3, n$1, l$1, !1, r$2);
						}
					}(e$1, i$1, a$1, o$1, r$1) : t.bU(a$1) ? function(e$2, t$1, i$2, a$2, o$2) {
						if ("translucent" !== e$2.renderPass) return;
						if (0 === i$2.paint.get("raster-opacity")) return;
						if (!a$2.length) return;
						const { isRenderingToTexture: r$2 } = o$2, s$1 = t$1.getSource(), n$1 = e$2.style.projection.useSubdivision;
						if (s$1 instanceof te) Ao(e$2, t$1, i$2, a$2, null, !1, !1, s$1.tileCoords, s$1.flippedWindingOrder, r$2);
						else if (n$1) {
							const [o$3, s$2, n$2] = e$2.stencilConfigForOverlapTwoPass(a$2);
							Ao(e$2, t$1, i$2, n$2, o$3, !1, !0, Do, !1, r$2), Ao(e$2, t$1, i$2, n$2, s$2, !0, !0, Do, !1, r$2);
						} else {
							const [o$3, s$2] = e$2.getStencilConfigForOverlapAndUpdateStencilID(a$2);
							Ao(e$2, t$1, i$2, s$2, o$3, !1, !0, Do, !1, r$2);
						}
					}(e$1, i$1, a$1, o$1, r$1) : t.cu(a$1) ? function(e$2, t$1, i$2, a$2, o$2) {
						const r$2 = i$2.paint.get("background-color"), s$1 = i$2.paint.get("background-opacity");
						if (0 === s$1) return;
						const { isRenderingToTexture: n$1 } = o$2, l$1 = e$2.context, c$1 = l$1.gl, h$1 = e$2.style.projection, u$1 = e$2.transform, d$1 = u$1.tileSize, _$1 = i$2.paint.get("background-pattern");
						if (e$2.isPatternMissing(_$1)) return;
						const p$1 = !_$1 && 1 === r$2.a && 1 === s$1 && e$2.opaquePassEnabledForLayer() ? "opaque" : "translucent";
						if (e$2.renderPass !== p$1) return;
						const m$1 = ai.disabled, f$1 = e$2.getDepthModeForSublayer(0, "opaque" === p$1 ? ti.ReadWrite : ti.ReadOnly), g$1 = e$2.colorModeForRenderPass(), v$1 = e$2.useProgram(_$1 ? "backgroundPattern" : "background"), x$1 = a$2 || Ie(u$1, {
							tileSize: d$1,
							terrain: e$2.style.map.terrain
						});
						_$1 && (l$1.activeTexture.set(c$1.TEXTURE0), e$2.imageManager.bind(e$2.context));
						const b$1 = i$2.getCrossfadeParameters();
						for (const t$2 of x$1) {
							const a$3 = u$1.getProjectionData({
								overscaledTileID: t$2,
								applyGlobeMatrix: !n$1,
								applyTerrainMatrix: !0
							}), o$3 = _$1 ? ga(s$1, e$2, _$1, {
								tileID: t$2,
								tileSize: d$1
							}, b$1) : fa(s$1, r$2), p$2 = e$2.style.map.terrain && e$2.style.map.terrain.getTerrainData(t$2), x$2 = h$1.getMeshFromTileID(l$1, t$2.canonical, !1, !0, "raster");
							v$1.draw(l$1, c$1.TRIANGLES, f$1, m$1, g$1, ei.backCCW, o$3, p$2, a$3, i$2.id, x$2.vertexBuffer, x$2.indexBuffer, x$2.segments);
						}
					}(e$1, 0, a$1, o$1, r$1) : t.cv(a$1) && function(e$2, t$1, i$2, a$2) {
						const { isRenderingGlobe: o$2 } = a$2, r$2 = e$2.context, s$1 = i$2.implementation, n$1 = e$2.style.projection, l$1 = e$2.transform, c$1 = l$1.getProjectionDataForCustomLayer(o$2), h$1 = {
							farZ: l$1.farZ,
							nearZ: l$1.nearZ,
							fov: l$1.fov * Math.PI / 180,
							modelViewProjectionMatrix: l$1.modelViewProjectionMatrix,
							projectionMatrix: l$1.projectionMatrix,
							shaderData: {
								variantName: n$1.shaderVariantName,
								vertexShaderPrelude: `const float PI = 3.141592653589793;\nuniform mat4 u_projection_matrix;\n${n$1.shaderPreludeCode.vertexSource}`,
								define: n$1.shaderDefine
							},
							defaultProjectionData: c$1
						}, u$1 = s$1.renderingMode ? s$1.renderingMode : "2d";
						if ("offscreen" === e$2.renderPass) {
							const t$2 = s$1.prerender;
							t$2 && (e$2.setCustomLayerDefaults(), r$2.setColorMode(e$2.colorModeForRenderPass()), t$2.call(s$1, r$2.gl, h$1), r$2.setDirty(), e$2.setBaseState());
						} else if ("translucent" === e$2.renderPass) {
							e$2.setCustomLayerDefaults(), r$2.setColorMode(e$2.colorModeForRenderPass()), r$2.setStencilMode(ai.disabled);
							const t$2 = "3d" === u$1 ? e$2.getDepthModeFor3D() : e$2.getDepthModeForSublayer(0, ti.ReadOnly);
							r$2.setDepthMode(t$2), s$1.render(r$2.gl, h$1), r$2.setDirty(), e$2.setBaseState(), r$2.bindFramebuffer.set(null);
						}
					}(e$1, 0, a$1, r$1));
				}
				saveTileTexture(e$1) {
					const t$1 = this._tileTextures[e$1.size[0]];
					t$1 ? t$1.push(e$1) : this._tileTextures[e$1.size[0]] = [e$1];
				}
				getTileTexture(e$1) {
					const t$1 = this._tileTextures[e$1];
					return t$1 && t$1.length > 0 ? t$1.pop() : null;
				}
				isPatternMissing(e$1) {
					if (!e$1) return !1;
					if (!e$1.from || !e$1.to) return !0;
					const t$1 = this.imageManager.getPattern(e$1.from.toString()), i$1 = this.imageManager.getPattern(e$1.to.toString());
					return !t$1 || !i$1;
				}
				useProgram(e$1, t$1, i$1 = !1, a$1 = []) {
					this.cache = this.cache || {};
					const o$1 = !!this.style.map.terrain, r$1 = this.style.projection, s$1 = i$1 ? At.projectionMercator : r$1.shaderPreludeCode, n$1 = i$1 ? Bt : r$1.shaderDefine, l$1 = e$1 + (t$1 ? t$1.cacheKey : "") + `/${i$1 ? Ot : r$1.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (o$1 ? "/terrain" : "") + (a$1 ? `/${a$1.join("/")}` : "");
					return this.cache[l$1] || (this.cache[l$1] = new Zi(this.context, At[e$1], t$1, xa[e$1], this._showOverdrawInspector, o$1, s$1, n$1, a$1)), this.cache[l$1];
				}
				setCustomLayerDefaults() {
					this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
				}
				setBaseState() {
					const e$1 = this.context.gl;
					this.context.cullFace.set(!1), this.context.viewport.set([
						0,
						0,
						this.width,
						this.height
					]), this.context.blendEquation.set(e$1.FUNC_ADD);
				}
				initDebugOverlayCanvas() {
					this.debugOverlayCanvas ?? (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new t.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
				}
				destroy() {
					var e$1, t$1;
					if (this._tileTextures) {
						for (const e$2 in this._tileTextures) {
							const t$2 = this._tileTextures[e$2];
							if (t$2) for (const e$3 of t$2) e$3.destroy();
						}
						this._tileTextures = {};
					}
					if (this.tileExtentBuffer && this.tileExtentBuffer.destroy(), this.debugBuffer && this.debugBuffer.destroy(), this.rasterBoundsBuffer && this.rasterBoundsBuffer.destroy(), this.rasterBoundsBufferPosOnly && this.rasterBoundsBufferPosOnly.destroy(), this.viewportBuffer && this.viewportBuffer.destroy(), this.tileBorderIndexBuffer && this.tileBorderIndexBuffer.destroy(), this.quadTriangleIndexBuffer && this.quadTriangleIndexBuffer.destroy(), this.tileExtentMesh && (null === (e$1 = this.tileExtentMesh.vertexBuffer) || void 0 === e$1 || e$1.destroy()), this.tileExtentMesh && (null === (t$1 = this.tileExtentMesh.indexBuffer) || void 0 === t$1 || t$1.destroy()), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this.cache) {
						for (const e$2 in this.cache) {
							const t$2 = this.cache[e$2];
							t$2 && t$2.program && this.context.gl.deleteProgram(t$2.program);
						}
						this.cache = {};
					}
					this.context && this.context.setDefault();
				}
				overLimit() {
					const { drawingBufferWidth: e$1, drawingBufferHeight: t$1 } = this.context.gl;
					return this.width !== e$1 || this.height !== t$1;
				}
			}
			function $o(e$1, t$1) {
				let i$1, a$1 = !1, o$1 = null, r$1 = null;
				const s$1 = () => {
					o$1 = null, a$1 && (e$1.apply(r$1, i$1), o$1 = setTimeout(s$1, t$1), a$1 = !1);
				};
				return (...e$2) => (a$1 = !0, r$1 = this, i$1 = e$2, o$1 || s$1(), o$1);
			}
			class Ho {
				constructor(e$1) {
					this._getCurrentHash = () => {
						const e$2 = window.location.hash.replace("#", "");
						if (this._hashName) {
							let t$1;
							return e$2.split("&").map(((e$3) => e$3.split("="))).forEach(((e$3) => {
								e$3[0] === this._hashName && (t$1 = e$3);
							})), (t$1 && t$1[1] || "").split("/");
						}
						return e$2.split("/");
					}, this._onHashChange = () => {
						const e$2 = this._getCurrentHash();
						if (!this._isValidHash(e$2)) return !1;
						const t$1 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(e$2[3] || 0) : this._map.getBearing();
						return this._map.jumpTo({
							center: [+e$2[2], +e$2[1]],
							zoom: +e$2[0],
							bearing: t$1,
							pitch: +(e$2[4] || 0)
						}), !0;
					}, this._updateHashUnthrottled = () => {
						const e$2 = window.location.href.replace(/(#.*)?$/, this.getHashString());
						window.history.replaceState(window.history.state, null, e$2);
					}, this._removeHash = () => {
						const e$2 = this._getCurrentHash();
						if (0 === e$2.length) return;
						const t$1 = e$2.join("/");
						let i$1 = t$1;
						i$1.split("&").length > 0 && (i$1 = i$1.split("&")[0]), this._hashName && (i$1 = `${this._hashName}=${t$1}`);
						let a$1 = window.location.hash.replace(i$1, "");
						a$1.startsWith("#&") ? a$1 = a$1.slice(0, 1) + a$1.slice(2) : "#" === a$1 && (a$1 = "");
						let o$1 = window.location.href.replace(/(#.+)?$/, a$1);
						o$1 = o$1.replace("&&", "&"), window.history.replaceState(window.history.state, null, o$1);
					}, this._updateHash = $o(this._updateHashUnthrottled, 300), this._hashName = e$1 && encodeURIComponent(e$1);
				}
				addTo(e$1) {
					return this._map = e$1, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
				}
				remove() {
					return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
				}
				getHashString(e$1) {
					const t$1 = this._map.getCenter(), i$1 = Math.round(100 * this._map.getZoom()) / 100, a$1 = Math.ceil((i$1 * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10), o$1 = Math.pow(10, a$1), r$1 = Math.round(t$1.lng * o$1) / o$1, s$1 = Math.round(t$1.lat * o$1) / o$1, n$1 = this._map.getBearing(), l$1 = this._map.getPitch();
					let c$1 = "";
					if (c$1 += e$1 ? `/${r$1}/${s$1}/${i$1}` : `${i$1}/${s$1}/${r$1}`, (n$1 || l$1) && (c$1 += "/" + Math.round(10 * n$1) / 10), l$1 && (c$1 += `/${Math.round(l$1)}`), this._hashName) {
						const e$2 = this._hashName;
						let t$2 = !1;
						const i$2 = window.location.hash.slice(1).split("&").map(((i$3) => {
							const a$2 = i$3.split("=")[0];
							return a$2 === e$2 ? (t$2 = !0, `${a$2}=${c$1}`) : i$3;
						})).filter(((e$3) => e$3));
						return t$2 || i$2.push(`${e$2}=${c$1}`), `#${i$2.join("&")}`;
					}
					return `#${c$1}`;
				}
				_isValidHash(e$1) {
					if (e$1.length < 3 || e$1.some(isNaN)) return !1;
					try {
						new t.V(+e$1[2], +e$1[1]);
					} catch (e$2) {
						return !1;
					}
					const i$1 = +e$1[0], a$1 = +(e$1[3] || 0), o$1 = +(e$1[4] || 0);
					return i$1 >= this._map.getMinZoom() && i$1 <= this._map.getMaxZoom() && a$1 >= -180 && a$1 <= 180 && o$1 >= this._map.getMinPitch() && o$1 <= this._map.getMaxPitch();
				}
			}
			const Xo = {
				linearity: .3,
				easing: t.cw(0, 0, .3, 1)
			}, Ko = t.e({
				deceleration: 2500,
				maxSpeed: 1400
			}, Xo), Yo = t.e({
				deceleration: 20,
				maxSpeed: 1400
			}, Xo), Qo = t.e({
				deceleration: 1e3,
				maxSpeed: 360
			}, Xo), Jo = t.e({
				deceleration: 1e3,
				maxSpeed: 90
			}, Xo), er = t.e({
				deceleration: 1e3,
				maxSpeed: 360
			}, Xo);
			class tr {
				constructor(e$1) {
					this._map = e$1, this.clear();
				}
				clear() {
					this._inertiaBuffer = [];
				}
				record(e$1) {
					this._drainInertiaBuffer(), this._inertiaBuffer.push({
						time: c(),
						settings: e$1
					});
				}
				_drainInertiaBuffer() {
					const e$1 = this._inertiaBuffer, t$1 = c();
					for (; e$1.length > 0 && t$1 - e$1[0].time > 160;) e$1.shift();
				}
				_onMoveEnd(e$1) {
					if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
					const i$1 = {
						zoom: 0,
						bearing: 0,
						pitch: 0,
						roll: 0,
						pan: new t.P(0, 0),
						pinchAround: void 0,
						around: void 0
					};
					for (const { settings: e$2 } of this._inertiaBuffer) i$1.zoom += e$2.zoomDelta || 0, i$1.bearing += e$2.bearingDelta || 0, i$1.pitch += e$2.pitchDelta || 0, i$1.roll += e$2.rollDelta || 0, e$2.panDelta && i$1.pan._add(e$2.panDelta), e$2.around && (i$1.around = e$2.around), e$2.pinchAround && (i$1.pinchAround = e$2.pinchAround);
					const a$1 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, o$1 = {};
					if (i$1.pan.mag()) {
						const r$1 = ar(i$1.pan.mag(), a$1, t.e({}, Ko, e$1 || {})), s$1 = i$1.pan.mult(r$1.amount / i$1.pan.mag()), n$1 = this._map.cameraHelper.handlePanInertia(s$1, this._map.transform);
						o$1.center = n$1.easingCenter, o$1.offset = n$1.easingOffset, ir(o$1, r$1);
					}
					if (i$1.zoom) {
						const e$2 = ar(i$1.zoom, a$1, Yo);
						o$1.zoom = t.cx(this._map.transform.zoom + e$2.amount, this._map.getZoomSnap(), e$2.amount), ir(o$1, e$2);
					}
					if (i$1.bearing) {
						const e$2 = ar(i$1.bearing, a$1, Qo);
						o$1.bearing = this._map.transform.bearing + t.an(e$2.amount, -179, 179), ir(o$1, e$2);
					}
					if (i$1.pitch) {
						const e$2 = ar(i$1.pitch, a$1, Jo);
						o$1.pitch = this._map.transform.pitch + e$2.amount, ir(o$1, e$2);
					}
					if (i$1.roll) {
						const e$2 = ar(i$1.roll, a$1, er);
						o$1.roll = this._map.transform.roll + t.an(e$2.amount, -179, 179), ir(o$1, e$2);
					}
					if (o$1.zoom || o$1.bearing) {
						const e$2 = void 0 === i$1.pinchAround ? i$1.around : i$1.pinchAround;
						o$1.around = e$2 ? this._map.unproject(e$2) : this._map.getCenter();
					}
					return this.clear(), t.e(o$1, { noMoveStart: !0 });
				}
			}
			function ir(e$1, t$1) {
				(!e$1.duration || e$1.duration < t$1.duration) && (e$1.duration = t$1.duration, e$1.easing = t$1.easing);
			}
			function ar(e$1, i$1, a$1) {
				const { maxSpeed: o$1, linearity: r$1, deceleration: s$1 } = a$1, n$1 = t.an(e$1 * r$1 / (i$1 / 1e3), -o$1, o$1), l$1 = Math.abs(n$1) / (s$1 * r$1);
				return {
					easing: a$1.easing,
					duration: 1e3 * l$1,
					amount: n$1 * (l$1 / 2)
				};
			}
			class or extends t.l {
				preventDefault() {
					this._defaultPrevented = !0;
				}
				get defaultPrevented() {
					return this._defaultPrevented;
				}
				constructor(e$1, i$1, a$1, o$1 = {}) {
					a$1 = a$1 instanceof MouseEvent ? a$1 : new MouseEvent(e$1, a$1);
					const r$1 = h.mousePos(i$1.getCanvas(), a$1), s$1 = i$1.unproject(r$1);
					super(e$1, t.e({
						point: r$1,
						lngLat: s$1,
						originalEvent: a$1
					}, o$1)), this._defaultPrevented = !1, this.target = i$1;
				}
			}
			class rr extends t.l {
				preventDefault() {
					this._defaultPrevented = !0;
				}
				get defaultPrevented() {
					return this._defaultPrevented;
				}
				constructor(e$1, i$1, a$1) {
					const o$1 = "touchend" === e$1 ? a$1.changedTouches : a$1.touches, r$1 = h.touchPos(i$1.getCanvasContainer(), o$1), s$1 = r$1.map(((e$2) => i$1.unproject(e$2))), n$1 = r$1.reduce(((e$2, t$1, i$2, a$2) => e$2.add(t$1.div(a$2.length))), new t.P(0, 0));
					super(e$1, {
						points: r$1,
						point: n$1,
						lngLats: s$1,
						lngLat: i$1.unproject(n$1),
						originalEvent: a$1
					}), this._defaultPrevented = !1;
				}
			}
			class sr extends t.l {
				preventDefault() {
					this._defaultPrevented = !0;
				}
				get defaultPrevented() {
					return this._defaultPrevented;
				}
				constructor(e$1, t$1, i$1) {
					super(e$1, { originalEvent: i$1 }), this._defaultPrevented = !1;
				}
			}
			class nr {
				constructor(e$1, t$1) {
					this._map = e$1, this._clickTolerance = t$1.clickTolerance;
				}
				reset() {
					delete this._mousedownPos;
				}
				wheel(e$1) {
					return this._firePreventable(new sr(e$1.type, this._map, e$1));
				}
				mousedown(e$1, t$1) {
					return this._mousedownPos = t$1, this._firePreventable(new or(e$1.type, this._map, e$1));
				}
				mouseup(e$1) {
					this._map.fire(new or(e$1.type, this._map, e$1));
				}
				click(e$1, t$1) {
					this._mousedownPos && this._mousedownPos.dist(t$1) >= this._clickTolerance || this._map.fire(new or(e$1.type, this._map, e$1));
				}
				dblclick(e$1) {
					return this._firePreventable(new or(e$1.type, this._map, e$1));
				}
				mouseover(e$1) {
					this._map.fire(new or(e$1.type, this._map, e$1));
				}
				mouseout(e$1) {
					this._map.fire(new or(e$1.type, this._map, e$1));
				}
				touchstart(e$1) {
					return this._firePreventable(new rr(e$1.type, this._map, e$1));
				}
				touchmove(e$1) {
					this._map.fire(new rr(e$1.type, this._map, e$1));
				}
				touchend(e$1) {
					this._map.fire(new rr(e$1.type, this._map, e$1));
				}
				touchcancel(e$1) {
					this._map.fire(new rr(e$1.type, this._map, e$1));
				}
				_firePreventable(e$1) {
					if (this._map.fire(e$1), e$1.defaultPrevented) return {};
				}
				isEnabled() {
					return !0;
				}
				isActive() {
					return !1;
				}
				enable() {}
				disable() {}
			}
			class lr {
				constructor(e$1) {
					this._map = e$1;
				}
				reset() {
					this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
				}
				mousemove(e$1) {
					this._map.fire(new or(e$1.type, this._map, e$1));
				}
				mousedown() {
					this._delayContextMenu = !0, this._ignoreContextMenu = !1;
				}
				mouseup() {
					this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new or("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
				}
				contextmenu(e$1) {
					this._delayContextMenu ? this._contextMenuEvent = e$1 : this._ignoreContextMenu || this._map.fire(new or(e$1.type, this._map, e$1)), this._map.listens("contextmenu") && e$1.preventDefault();
				}
				isEnabled() {
					return !0;
				}
				isActive() {
					return !1;
				}
				enable() {}
				disable() {}
			}
			class cr {
				constructor(e$1) {
					this._map = e$1;
				}
				get transform() {
					return this._map._requestedCameraState || this._map.transform;
				}
				get center() {
					return {
						lng: this.transform.center.lng,
						lat: this.transform.center.lat
					};
				}
				get zoom() {
					return this.transform.zoom;
				}
				get pitch() {
					return this.transform.pitch;
				}
				get bearing() {
					return this.transform.bearing;
				}
				unproject(e$1) {
					return this.transform.screenPointToLocation(t.P.convert(e$1), this._map.terrain);
				}
			}
			class hr {
				constructor(e$1, t$1) {
					this._map = e$1, this._tr = new cr(e$1), this._el = e$1.getCanvasContainer(), this._container = e$1.getContainer(), this._clickTolerance = t$1.clickTolerance || 1;
				}
				isEnabled() {
					return !!this._enabled;
				}
				isActive() {
					return !!this._active;
				}
				enable() {
					this.isEnabled() || (this._enabled = !0);
				}
				disable() {
					this.isEnabled() && (this._enabled = !1);
				}
				mousedown(e$1, t$1) {
					this.isEnabled() && e$1.shiftKey && 0 === e$1.button && (h.disableDrag(), this._startPos = this._lastPos = t$1, this._active = !0);
				}
				mousemoveWindow(e$1, t$1) {
					if (!this._active) return;
					const i$1 = t$1;
					if (this._lastPos.equals(i$1) || !this._box && i$1.dist(this._startPos) < this._clickTolerance) return;
					const a$1 = this._startPos;
					this._lastPos = i$1, this._box || (this._box = h.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e$1));
					const o$1 = Math.min(a$1.x, i$1.x), r$1 = Math.max(a$1.x, i$1.x), s$1 = Math.min(a$1.y, i$1.y), n$1 = Math.max(a$1.y, i$1.y);
					h.setTransform(this._box, `translate(${o$1}px,${s$1}px)`), this._box.style.width = r$1 - o$1 + "px", this._box.style.height = n$1 - s$1 + "px";
				}
				mouseupWindow(e$1, i$1) {
					if (!this._active) return;
					if (0 !== e$1.button) return;
					const a$1 = this._startPos, o$1 = i$1;
					if (this.reset(), h.suppressClick(), a$1.x !== o$1.x || a$1.y !== o$1.y) return this._map.fire(new t.l("boxzoomend", { originalEvent: e$1 })), { cameraAnimation: (e$2) => e$2.fitScreenCoordinates(a$1, o$1, this._tr.bearing, { linear: !0 }) };
					this._fireEvent("boxzoomcancel", e$1);
				}
				keydown(e$1) {
					this._active && 27 === e$1.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e$1));
				}
				reset() {
					this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (h.remove(this._box), this._box = null), h.enableDrag(), delete this._startPos, delete this._lastPos;
				}
				_fireEvent(e$1, i$1) {
					return this._map.fire(new t.l(e$1, { originalEvent: i$1 }));
				}
			}
			function ur(e$1, t$1) {
				if (e$1.length !== t$1.length) throw new Error(`The number of touches and points are not equal - touches ${e$1.length}, points ${t$1.length}`);
				const i$1 = {};
				for (let a$1 = 0; a$1 < e$1.length; a$1++) i$1[e$1[a$1].identifier] = t$1[a$1];
				return i$1;
			}
			class dr {
				constructor(e$1) {
					this.reset(), this.numTouches = e$1.numTouches;
				}
				reset() {
					delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
				}
				touchstart(e$1, i$1, a$1) {
					(this.centroid || a$1.length > this.numTouches) && (this.aborted = !0), this.aborted || (void 0 === this.startTime && (this.startTime = e$1.timeStamp), a$1.length === this.numTouches && (this.centroid = function(e$2) {
						const i$2 = new t.P(0, 0);
						for (const t$1 of e$2) i$2._add(t$1);
						return i$2.div(e$2.length);
					}(i$1), this.touches = ur(a$1, i$1)));
				}
				touchmove(e$1, t$1, i$1) {
					if (this.aborted || !this.centroid) return;
					const a$1 = ur(i$1, t$1);
					for (const e$2 in this.touches) {
						const t$2 = a$1[e$2];
						(!t$2 || t$2.dist(this.touches[e$2]) > 30) && (this.aborted = !0);
					}
				}
				touchend(e$1, t$1, i$1) {
					if ((!this.centroid || e$1.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === i$1.length) {
						const e$2 = !this.aborted && this.centroid;
						if (this.reset(), e$2) return e$2;
					}
				}
			}
			class _r {
				constructor(e$1) {
					this.singleTap = new dr(e$1), this.numTaps = e$1.numTaps, this.reset();
				}
				reset() {
					this.lastTime = Infinity, delete this.lastTap, this.count = 0, this.singleTap.reset();
				}
				touchstart(e$1, t$1, i$1) {
					this.singleTap.touchstart(e$1, t$1, i$1);
				}
				touchmove(e$1, t$1, i$1) {
					this.singleTap.touchmove(e$1, t$1, i$1);
				}
				touchend(e$1, t$1, i$1) {
					const a$1 = this.singleTap.touchend(e$1, t$1, i$1);
					if (a$1) {
						const t$2 = e$1.timeStamp - this.lastTime < 500, i$2 = !this.lastTap || this.lastTap.dist(a$1) < 30;
						if (t$2 && i$2 || this.reset(), this.count++, this.lastTime = e$1.timeStamp, this.lastTap = a$1, this.count === this.numTaps) return this.reset(), a$1;
					}
				}
			}
			class pr {
				constructor(e$1) {
					this._tr = new cr(e$1), this._zoomIn = new _r({
						numTouches: 1,
						numTaps: 2
					}), this._zoomOut = new _r({
						numTouches: 2,
						numTaps: 1
					}), this.reset();
				}
				reset() {
					this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
				}
				touchstart(e$1, t$1, i$1) {
					this._zoomIn.touchstart(e$1, t$1, i$1), this._zoomOut.touchstart(e$1, t$1, i$1);
				}
				touchmove(e$1, t$1, i$1) {
					this._zoomIn.touchmove(e$1, t$1, i$1), this._zoomOut.touchmove(e$1, t$1, i$1);
				}
				touchend(e$1, i$1, a$1) {
					const o$1 = this._zoomIn.touchend(e$1, i$1, a$1), r$1 = this._zoomOut.touchend(e$1, i$1, a$1), s$1 = this._tr;
					return o$1 ? (this._active = !0, e$1.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (i$2) => i$2.easeTo({
						duration: 300,
						zoom: t.cx(s$1.zoom + 1, i$2.getZoomSnap()),
						around: s$1.unproject(o$1)
					}, { originalEvent: e$1 }) }) : r$1 ? (this._active = !0, e$1.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (i$2) => i$2.easeTo({
						duration: 300,
						zoom: t.cx(s$1.zoom - 1, i$2.getZoomSnap()),
						around: s$1.unproject(r$1)
					}, { originalEvent: e$1 }) }) : void 0;
				}
				touchcancel() {
					this.reset();
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
			}
			class mr {
				constructor(e$1) {
					this._enabled = !!e$1.enable, this._moveStateManager = e$1.moveStateManager, this._clickTolerance = e$1.clickTolerance || 1, this._moveFunction = e$1.move, this._activateOnStart = !!e$1.activateOnStart, e$1.assignEvents(this), this.reset();
				}
				reset(e$1) {
					this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(e$1);
				}
				_move(...e$1) {
					const t$1 = this._moveFunction(...e$1);
					if (t$1.bearingDelta || t$1.pitchDelta || t$1.rollDelta || t$1.around || t$1.panDelta) return this._active = !0, t$1;
				}
				dragStart(e$1, t$1) {
					this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e$1) && (this._moveStateManager.startMove(e$1), this._lastPoint = Array.isArray(t$1) ? t$1[0] : t$1, this._activateOnStart && this._lastPoint && (this._active = !0));
				}
				dragMove(e$1, t$1) {
					if (!this.isEnabled()) return;
					const i$1 = this._lastPoint;
					if (!i$1) return;
					if (e$1.preventDefault(), !this._moveStateManager.isValidMoveEvent(e$1)) return void this.reset(e$1);
					const a$1 = Array.isArray(t$1) ? t$1[0] : t$1;
					return !this._moved && a$1.dist(i$1) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = a$1, this._move(i$1, a$1));
				}
				dragEnd(e$1) {
					this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e$1) && (this._moved && h.suppressClick(), this.reset(e$1));
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
				getClickTolerance() {
					return this._clickTolerance;
				}
			}
			const fr = 0, gr = 2, vr = {
				[fr]: 1,
				[gr]: 2
			};
			class xr {
				constructor(e$1) {
					this._correctEvent = e$1.checkCorrectEvent;
				}
				startMove(e$1) {
					this._eventButton = h.mouseButton(e$1);
				}
				endMove(e$1) {
					delete this._eventButton;
				}
				isValidStartEvent(e$1) {
					return this._correctEvent(e$1);
				}
				isValidMoveEvent(e$1) {
					return !function(e$2, t$1) {
						const i$1 = vr[t$1];
						return void 0 === e$2.buttons || (e$2.buttons & i$1) !== i$1;
					}(e$1, this._eventButton);
				}
				isValidEndEvent(e$1) {
					return h.mouseButton(e$1) === this._eventButton;
				}
			}
			class br {
				constructor() {
					this._firstTouch = void 0;
				}
				_isOneFingerTouch(e$1) {
					return 1 === e$1.targetTouches.length;
				}
				_isSameTouchEvent(e$1) {
					return e$1.targetTouches[0].identifier === this._firstTouch;
				}
				startMove(e$1) {
					this._firstTouch = e$1.targetTouches[0].identifier;
				}
				endMove(e$1) {
					delete this._firstTouch;
				}
				isValidStartEvent(e$1) {
					return this._isOneFingerTouch(e$1);
				}
				isValidMoveEvent(e$1) {
					return this._isOneFingerTouch(e$1) && this._isSameTouchEvent(e$1);
				}
				isValidEndEvent(e$1) {
					return this._isOneFingerTouch(e$1) && this._isSameTouchEvent(e$1);
				}
			}
			class yr {
				constructor(e$1 = new xr({ checkCorrectEvent: () => !0 }), t$1 = new br()) {
					this.mouseMoveStateManager = e$1, this.oneFingerTouchMoveStateManager = t$1;
				}
				_executeRelevantHandler(e$1, t$1, i$1) {
					return e$1 instanceof MouseEvent ? t$1(e$1) : "undefined" != typeof TouchEvent && e$1 instanceof TouchEvent ? i$1(e$1) : void 0;
				}
				startMove(e$1) {
					this._executeRelevantHandler(e$1, ((e$2) => this.mouseMoveStateManager.startMove(e$2)), ((e$2) => this.oneFingerTouchMoveStateManager.startMove(e$2)));
				}
				endMove(e$1) {
					this._executeRelevantHandler(e$1, ((e$2) => this.mouseMoveStateManager.endMove(e$2)), ((e$2) => this.oneFingerTouchMoveStateManager.endMove(e$2)));
				}
				isValidStartEvent(e$1) {
					return this._executeRelevantHandler(e$1, ((e$2) => this.mouseMoveStateManager.isValidStartEvent(e$2)), ((e$2) => this.oneFingerTouchMoveStateManager.isValidStartEvent(e$2)));
				}
				isValidMoveEvent(e$1) {
					return this._executeRelevantHandler(e$1, ((e$2) => this.mouseMoveStateManager.isValidMoveEvent(e$2)), ((e$2) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(e$2)));
				}
				isValidEndEvent(e$1) {
					return this._executeRelevantHandler(e$1, ((e$2) => this.mouseMoveStateManager.isValidEndEvent(e$2)), ((e$2) => this.oneFingerTouchMoveStateManager.isValidEndEvent(e$2)));
				}
			}
			const wr = (e$1) => {
				e$1.mousedown = e$1.dragStart, e$1.mousemoveWindow = e$1.dragMove, e$1.mouseup = e$1.dragEnd, e$1.contextmenu = (e$2) => {
					e$2.preventDefault();
				};
			};
			class Tr {
				constructor(e$1, t$1) {
					this._clickTolerance = e$1.clickTolerance || 1, this._map = t$1, this.reset();
				}
				reset() {
					this._active = !1, this._touches = {}, this._sum = new t.P(0, 0);
				}
				_shouldBePrevented(e$1) {
					return e$1 < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
				}
				touchstart(e$1, t$1, i$1) {
					return this._calculateTransform(e$1, t$1, i$1);
				}
				touchmove(e$1, t$1, i$1) {
					if (this._active) {
						if (!this._shouldBePrevented(i$1.length)) return e$1.preventDefault(), this._calculateTransform(e$1, t$1, i$1);
						this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e$1);
					}
				}
				touchend(e$1, t$1, i$1) {
					this._calculateTransform(e$1, t$1, i$1), this._active && this._shouldBePrevented(i$1.length) && this.reset();
				}
				touchcancel() {
					this.reset();
				}
				_calculateTransform(e$1, i$1, a$1) {
					a$1.length > 0 && (this._active = !0);
					const o$1 = ur(a$1, i$1), r$1 = new t.P(0, 0), s$1 = new t.P(0, 0);
					let n$1 = 0;
					for (const e$2 in o$1) {
						const t$1 = o$1[e$2], i$2 = this._touches[e$2];
						i$2 && (r$1._add(t$1), s$1._add(t$1.sub(i$2)), n$1++, o$1[e$2] = t$1);
					}
					if (this._touches = o$1, this._shouldBePrevented(n$1) || !s$1.mag()) return;
					const l$1 = s$1.div(n$1);
					return this._sum._add(l$1), this._sum.mag() < this._clickTolerance ? void 0 : {
						around: r$1.div(n$1),
						panDelta: l$1
					};
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
			}
			class Pr {
				constructor() {
					this.reset();
				}
				reset() {
					this._active = !1, delete this._firstTwoTouches;
				}
				touchstart(e$1, t$1, i$1) {
					this._firstTwoTouches || i$1.length < 2 || (this._firstTwoTouches = [i$1[0].identifier, i$1[1].identifier], this._start([t$1[0], t$1[1]]));
				}
				touchmove(e$1, t$1, i$1) {
					if (!this._firstTwoTouches) return;
					e$1.preventDefault();
					const [a$1, o$1] = this._firstTwoTouches, r$1 = Cr(i$1, t$1, a$1), s$1 = Cr(i$1, t$1, o$1);
					if (!r$1 || !s$1) return;
					const n$1 = this._aroundCenter ? null : r$1.add(s$1).div(2);
					return this._move([r$1, s$1], n$1, e$1);
				}
				touchend(e$1, t$1, i$1) {
					if (!this._firstTwoTouches) return;
					const [a$1, o$1] = this._firstTwoTouches, r$1 = Cr(i$1, t$1, a$1), s$1 = Cr(i$1, t$1, o$1);
					r$1 && s$1 || (this._active && h.suppressClick(), this.reset());
				}
				touchcancel() {
					this.reset();
				}
				enable(e$1) {
					this._enabled = !0, this._aroundCenter = !!e$1 && "center" === e$1.around;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return !!this._enabled;
				}
				isActive() {
					return !!this._active;
				}
			}
			function Cr(e$1, t$1, i$1) {
				for (let a$1 = 0; a$1 < e$1.length; a$1++) if (e$1[a$1].identifier === i$1) return t$1[a$1];
			}
			function Ir(e$1, t$1) {
				return Math.log(e$1 / t$1) / Math.LN2;
			}
			class Mr extends Pr {
				reset() {
					super.reset(), delete this._distance, delete this._startDistance;
				}
				_start(e$1) {
					this._startDistance = this._distance = e$1[0].dist(e$1[1]);
				}
				_move(e$1, t$1) {
					const i$1 = this._distance;
					if (this._distance = e$1[0].dist(e$1[1]), this._active || !(Math.abs(Ir(this._distance, this._startDistance)) < .1)) return this._active = !0, {
						zoomDelta: Ir(this._distance, i$1),
						pinchAround: t$1
					};
				}
			}
			function Er(e$1, t$1) {
				return 180 * e$1.angleWith(t$1) / Math.PI;
			}
			class Sr extends Pr {
				reset() {
					super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
				}
				_start(e$1) {
					this._startVector = this._vector = e$1[0].sub(e$1[1]), this._minDiameter = e$1[0].dist(e$1[1]);
				}
				_move(e$1, t$1, i$1) {
					const a$1 = this._vector;
					if (this._vector = e$1[0].sub(e$1[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, {
						bearingDelta: Er(this._vector, a$1),
						pinchAround: t$1
					};
				}
				_isBelowThreshold(e$1) {
					this._minDiameter = Math.min(this._minDiameter, e$1.mag());
					const t$1 = 25 / (Math.PI * this._minDiameter) * 360, i$1 = Er(e$1, this._startVector);
					return Math.abs(i$1) < t$1;
				}
			}
			function zr(e$1) {
				return Math.abs(e$1.y) > Math.abs(e$1.x);
			}
			class Rr extends Pr {
				constructor(e$1) {
					super(), this._currentTouchCount = 0, this._map = e$1;
				}
				reset() {
					super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
				}
				touchstart(e$1, t$1, i$1) {
					super.touchstart(e$1, t$1, i$1), this._currentTouchCount = i$1.length;
				}
				_start(e$1) {
					this._lastPoints = e$1, zr(e$1[0].sub(e$1[1])) && (this._valid = !1);
				}
				_move(e$1, t$1, i$1) {
					if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
					const a$1 = e$1[0].sub(this._lastPoints[0]), o$1 = e$1[1].sub(this._lastPoints[1]);
					return this._valid = this.gestureBeginsVertically(a$1, o$1, i$1.timeStamp), this._valid ? (this._lastPoints = e$1, this._active = !0, { pitchDelta: (a$1.y + o$1.y) / 2 * -.5 }) : void 0;
				}
				gestureBeginsVertically(e$1, t$1, i$1) {
					if (void 0 !== this._valid) return this._valid;
					const a$1 = e$1.mag() >= 2, o$1 = t$1.mag() >= 2;
					if (!a$1 && !o$1) return;
					if (!a$1 || !o$1) return void 0 === this._firstMove && (this._firstMove = i$1), i$1 - this._firstMove < 100 && void 0;
					const r$1 = e$1.y > 0 == t$1.y > 0;
					return zr(e$1) && zr(t$1) && r$1;
				}
			}
			const Dr = {
				panStep: 100,
				bearingStep: 15,
				pitchStep: 10
			};
			class Ar {
				constructor(e$1) {
					this._tr = new cr(e$1);
					const t$1 = Dr;
					this._panStep = t$1.panStep, this._bearingStep = t$1.bearingStep, this._pitchStep = t$1.pitchStep, this._rotationDisabled = !1;
				}
				reset() {
					this._active = !1;
				}
				keydown(e$1) {
					if (e$1.altKey || e$1.ctrlKey || e$1.metaKey) return;
					let i$1 = 0, a$1 = 0, o$1 = 0, r$1 = 0, s$1 = 0;
					switch (e$1.keyCode) {
						case 61:
						case 107:
						case 171:
						case 187:
							i$1 = 1;
							break;
						case 189:
						case 109:
						case 173:
							i$1 = -1;
							break;
						case 37:
							e$1.shiftKey ? a$1 = -1 : (e$1.preventDefault(), r$1 = -1);
							break;
						case 39:
							e$1.shiftKey ? a$1 = 1 : (e$1.preventDefault(), r$1 = 1);
							break;
						case 38:
							e$1.shiftKey ? o$1 = 1 : (e$1.preventDefault(), s$1 = -1);
							break;
						case 40:
							e$1.shiftKey ? o$1 = -1 : (e$1.preventDefault(), s$1 = 1);
							break;
						default: return;
					}
					return this._rotationDisabled && (a$1 = 0, o$1 = 0), { cameraAnimation: (n$1) => {
						const l$1 = this._tr;
						n$1.easeTo({
							duration: 300,
							easeId: "keyboardHandler",
							easing: Lr,
							zoom: i$1 ? t.cx(l$1.zoom + i$1 * (e$1.shiftKey ? 2 : 1), n$1.getZoomSnap()) : l$1.zoom,
							bearing: l$1.bearing + a$1 * this._bearingStep,
							pitch: l$1.pitch + o$1 * this._pitchStep,
							offset: [-r$1 * this._panStep, -s$1 * this._panStep],
							center: l$1.center
						}, { originalEvent: e$1 });
					} };
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
				disableRotation() {
					this._rotationDisabled = !0;
				}
				enableRotation() {
					this._rotationDisabled = !1;
				}
			}
			function Lr(e$1) {
				return e$1 * (2 - e$1);
			}
			const kr = 4.000244140625, Fr = 1 / 450;
			class Br {
				constructor(e$1, t$1) {
					this._onTimeout = (e$2) => {
						this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e$2);
					}, this._map = e$1, this._tr = new cr(e$1), this._triggerRenderFrame = t$1, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = Fr;
				}
				setZoomRate(e$1) {
					this._defaultZoomRate = e$1;
				}
				setWheelZoomRate(e$1) {
					this._wheelZoomRate = e$1;
				}
				isEnabled() {
					return !!this._enabled;
				}
				isActive() {
					return !!this._active || void 0 !== this._finishTimeout;
				}
				isZooming() {
					return !!this._zooming;
				}
				enable(e$1) {
					this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e$1 && "center" === e$1.around);
				}
				disable() {
					this.isEnabled() && (this._enabled = !1);
				}
				_shouldBePrevented(e$1) {
					return !!this._map.cooperativeGestures.isEnabled() && !(e$1.ctrlKey || this._map.cooperativeGestures.isBypassed(e$1));
				}
				wheel(e$1) {
					if (!this.isEnabled()) return;
					if (this._shouldBePrevented(e$1)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e$1);
					let t$1 = e$1.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e$1.deltaY : e$1.deltaY;
					const i$1 = c(), a$1 = i$1 - (this._lastWheelEventTime || 0);
					this._lastWheelEventTime = i$1, 0 !== t$1 && t$1 % kr == 0 ? this._type = "wheel" : 0 !== t$1 && Math.abs(t$1) < 4 ? this._type = "trackpad" : a$1 > 400 ? (this._type = null, this._lastValue = t$1, this._timeout = setTimeout(this._onTimeout, 40, e$1)) : this._type || (this._type = Math.abs(a$1 * t$1) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, t$1 += this._lastValue)), e$1.shiftKey && t$1 && (t$1 /= 4), this._type && (this._lastWheelEvent = e$1, this._delta -= t$1, this._active || this._start(e$1)), e$1.preventDefault();
				}
				_start(e$1) {
					if (!this._delta) return;
					this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
					const i$1 = h.mousePos(this._map.getCanvas(), e$1), a$1 = this._tr;
					this._aroundPoint = this._aroundCenter ? a$1.transform.locationToScreenPoint(t.V.convert(a$1.center)) : i$1, this._frameId || (this._frameId = !0, this._triggerRenderFrame());
				}
				renderFrame() {
					if (!this._frameId) return;
					if (this._frameId = null, !this.isActive()) return;
					const e$1 = this._tr.transform;
					if ("number" == typeof this._lastExpectedZoom) {
						const t$1 = e$1.zoom - this._lastExpectedZoom;
						"number" == typeof this._startZoom && (this._startZoom += t$1), "number" == typeof this._targetZoom && (this._targetZoom += t$1);
					}
					if (0 !== this._delta) {
						const i$2 = "wheel" === this._type && Math.abs(this._delta) > kr ? this._wheelZoomRate : this._defaultZoomRate;
						let a$2 = 2 / (1 + Math.exp(-Math.abs(this._delta * i$2)));
						this._delta < 0 && 0 !== a$2 && (a$2 = 1 / a$2);
						const o$2 = "number" != typeof this._targetZoom ? e$1.scale : t.aq(this._targetZoom), r$2 = e$1.applyConstrain(e$1.getCameraLngLat(), t.at(o$2 * a$2)).zoom, s$2 = this._map.getZoomSnap();
						if ("wheel" === this._type && s$2 > 0) {
							const i$3 = t.cx(e$1.zoom, s$2);
							this._targetZoom = t.cx(r$2, s$2, r$2 - i$3);
						} else this._targetZoom = r$2;
						"wheel" === this._type && (this._startZoom = e$1.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
					}
					const i$1 = "number" != typeof this._targetZoom ? e$1.zoom : this._targetZoom, a$1 = this._startZoom, o$1 = this._easing;
					let r$1, s$1 = !1;
					if ("wheel" === this._type && a$1 && o$1) {
						const e$2 = c() - this._lastWheelEventTime, n$1 = Math.min((e$2 + 5) / 200, 1), l$1 = o$1(n$1);
						r$1 = t.G.number(a$1, i$1, l$1), n$1 < 1 ? this._frameId || (this._frameId = !0) : s$1 = !0;
					} else r$1 = i$1, s$1 = !0;
					return this._active = !0, s$1 && (this._active = !1, this._finishTimeout = setTimeout((() => {
						this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
					}), 200)), this._lastExpectedZoom = r$1, {
						noInertia: !0,
						needsRenderFrame: !s$1,
						zoomDelta: r$1 - e$1.zoom,
						around: this._aroundPoint,
						originalEvent: this._lastWheelEvent
					};
				}
				_smoothOutEasing(e$1) {
					let i$1 = t.cz;
					if (this._prevEase) {
						const e$2 = this._prevEase, a$1 = (c() - e$2.start) / e$2.duration, o$1 = e$2.easing(a$1 + .01) - e$2.easing(a$1), r$1 = .27 / Math.sqrt(o$1 * o$1 + 1e-4) * .01, s$1 = Math.sqrt(.0729 - r$1 * r$1);
						i$1 = t.cw(r$1, s$1, .25, 1);
					}
					return this._prevEase = {
						start: c(),
						duration: e$1,
						easing: i$1
					}, i$1;
				}
				reset() {
					this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
				}
			}
			class Or {
				constructor(e$1, t$1) {
					this._clickZoom = e$1, this._tapZoom = t$1;
				}
				enable() {
					this._clickZoom.enable(), this._tapZoom.enable();
				}
				disable() {
					this._clickZoom.disable(), this._tapZoom.disable();
				}
				isEnabled() {
					return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
				}
				isActive() {
					return this._clickZoom.isActive() || this._tapZoom.isActive();
				}
			}
			class jr {
				constructor(e$1) {
					this._tr = new cr(e$1), this.reset();
				}
				reset() {
					this._active = !1;
				}
				dblclick(e$1, i$1) {
					return e$1.preventDefault(), { cameraAnimation: (a$1) => {
						a$1.easeTo({
							duration: 300,
							zoom: t.cx(this._tr.zoom + (e$1.shiftKey ? -1 : 1), a$1.getZoomSnap()),
							around: this._tr.unproject(i$1)
						}, { originalEvent: e$1 });
					} };
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
			}
			class Nr {
				constructor() {
					this._tap = new _r({
						numTouches: 1,
						numTaps: 1
					}), this.reset();
				}
				reset() {
					this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
				}
				touchstart(e$1, t$1, i$1) {
					if (!this._swipePoint) if (this._tapTime) {
						const a$1 = t$1[0], o$1 = e$1.timeStamp - this._tapTime < 500, r$1 = this._tapPoint.dist(a$1) < 30;
						o$1 && r$1 ? i$1.length > 0 && (this._swipePoint = a$1, this._swipeTouch = i$1[0].identifier) : this.reset();
					} else this._tap.touchstart(e$1, t$1, i$1);
				}
				touchmove(e$1, t$1, i$1) {
					if (this._tapTime) {
						if (this._swipePoint) {
							if (i$1[0].identifier !== this._swipeTouch) return;
							const a$1 = t$1[0], o$1 = a$1.y - this._swipePoint.y;
							return this._swipePoint = a$1, e$1.preventDefault(), this._active = !0, { zoomDelta: o$1 / 128 };
						}
					} else this._tap.touchmove(e$1, t$1, i$1);
				}
				touchend(e$1, t$1, i$1) {
					if (this._tapTime) this._swipePoint && 0 === i$1.length && this.reset();
					else {
						const a$1 = this._tap.touchend(e$1, t$1, i$1);
						a$1 && (this._tapTime = e$1.timeStamp, this._tapPoint = a$1);
					}
				}
				touchcancel() {
					this.reset();
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
			}
			class Zr {
				constructor(e$1, t$1, i$1) {
					this._el = e$1, this._mousePan = t$1, this._touchPan = i$1;
				}
				enable(e$1) {
					this._inertiaOptions = e$1 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
				}
				disable() {
					this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
				}
				isEnabled() {
					return this._mousePan.isEnabled() && this._touchPan.isEnabled();
				}
				isActive() {
					return this._mousePan.isActive() || this._touchPan.isActive();
				}
			}
			class Ur {
				constructor(e$1, t$1, i$1, a$1) {
					this._pitchWithRotate = e$1.pitchWithRotate, this._rollEnabled = e$1.rollEnabled, this._mouseRotate = t$1, this._mousePitch = i$1, this._mouseRoll = a$1;
				}
				enable() {
					this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
				}
				disable() {
					this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
				}
				isEnabled() {
					return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
				}
				isActive() {
					return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
				}
			}
			class Gr {
				constructor(e$1, t$1, i$1, a$1) {
					this._el = e$1, this._touchZoom = t$1, this._touchRotate = i$1, this._tapDragZoom = a$1, this._rotationDisabled = !1, this._enabled = !0;
				}
				enable(e$1) {
					this._touchZoom.enable(e$1), this._rotationDisabled || this._touchRotate.enable(e$1), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
				}
				disable() {
					this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
				}
				isEnabled() {
					return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
				}
				isActive() {
					return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
				}
				disableRotation() {
					this._rotationDisabled = !0, this._touchRotate.disable();
				}
				enableRotation() {
					this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
				}
			}
			class Vr {
				constructor(e$1, t$1) {
					this._bypassKey = -1 !== navigator.userAgent.indexOf("Mac") ? "metaKey" : "ctrlKey", this._map = e$1, this._options = t$1, this._enabled = !1;
				}
				isActive() {
					return !1;
				}
				reset() {}
				_setupUI() {
					if (this._container) return;
					const e$1 = this._map.getCanvasContainer();
					e$1.classList.add("maplibregl-cooperative-gestures"), this._container = h.create("div", "maplibregl-cooperative-gesture-screen", e$1);
					let t$1 = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
					"metaKey" === this._bypassKey && (t$1 = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
					const i$1 = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), a$1 = document.createElement("div");
					a$1.className = "maplibregl-desktop-message", a$1.textContent = t$1, this._container.appendChild(a$1);
					const o$1 = document.createElement("div");
					o$1.className = "maplibregl-mobile-message", o$1.textContent = i$1, this._container.appendChild(o$1), this._container.setAttribute("aria-hidden", "true");
				}
				_destroyUI() {
					this._container && (h.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
				}
				enable() {
					this._setupUI(), this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this._destroyUI();
				}
				isEnabled() {
					return this._enabled;
				}
				isBypassed(e$1) {
					return e$1[this._bypassKey];
				}
				notifyGestureBlocked(e$1, i$1) {
					this._enabled && (this._map.fire(new t.l("cooperativegestureprevented", {
						gestureType: e$1,
						originalEvent: i$1
					})), this._container.classList.add("maplibregl-show"), setTimeout((() => {
						this._container.classList.remove("maplibregl-show");
					}), 100));
				}
			}
			const qr = (e$1) => e$1.zoom || e$1.drag || e$1.roll || e$1.pitch || e$1.rotate;
			class Wr extends t.l {}
			function $r(e$1) {
				return e$1.panDelta && e$1.panDelta.mag() || e$1.zoomDelta || e$1.bearingDelta || e$1.pitchDelta || e$1.rollDelta;
			}
			class Hr {
				get _ownerDocument() {
					var e$1;
					return (null === (e$1 = this._el) || void 0 === e$1 ? void 0 : e$1.ownerDocument) || document;
				}
				get _ownerWindow() {
					var e$1, t$1;
					return (null === (t$1 = null === (e$1 = this._el) || void 0 === e$1 ? void 0 : e$1.ownerDocument) || void 0 === t$1 ? void 0 : t$1.defaultView) || window;
				}
				constructor(e$1, i$1) {
					this.handleWindowEvent = (e$2) => {
						this.handleEvent(e$2, `${e$2.type}Window`);
					}, this.handleEvent = (e$2, i$2) => {
						if ("blur" === e$2.type) return void this.stop(!0);
						this._updatingCamera = !0;
						const a$2 = "renderFrame" === e$2.type ? void 0 : e$2, o$1 = { needsRenderFrame: !1 }, r$1 = {}, s$1 = {};
						for (const { handlerName: n$2, handler: l$2, allowed: c$1 } of this._handlers) {
							if (!l$2.isEnabled()) continue;
							let u$1;
							if (this._blockedByActive(s$1, c$1, n$2)) l$2.reset();
							else if (l$2[i$2 || e$2.type]) {
								if (t.cA(e$2, i$2 || e$2.type)) {
									const t$1 = h.mousePos(this._map.getCanvas(), e$2);
									u$1 = l$2[i$2 || e$2.type](e$2, t$1);
								} else if (t.cB(e$2, i$2 || e$2.type)) {
									const t$1 = this._getMapTouches(e$2.touches), a$3 = h.touchPos(this._map.getCanvas(), t$1);
									u$1 = l$2[i$2 || e$2.type](e$2, a$3, t$1);
								} else t.cC(i$2 || e$2.type) || (u$1 = l$2[i$2 || e$2.type](e$2));
								this.mergeHandlerResult(o$1, r$1, u$1, n$2, a$2), u$1 && u$1.needsRenderFrame && this._triggerRenderFrame();
							}
							(u$1 || l$2.isActive()) && (s$1[n$2] = l$2);
						}
						const n$1 = {};
						for (const e$3 in this._previousActiveHandlers) s$1[e$3] || (n$1[e$3] = a$2);
						this._previousActiveHandlers = s$1, (Object.keys(n$1).length || $r(o$1)) && (this._changes.push([
							o$1,
							r$1,
							n$1
						]), this._triggerRenderFrame()), (Object.keys(s$1).length || $r(o$1)) && this._map._stop(!0), this._updatingCamera = !1;
						const { cameraAnimation: l$1 } = o$1;
						l$1 && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], l$1(this._map));
					}, this._map = e$1, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new tr(e$1), this._bearingSnap = i$1.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(i$1);
					const a$1 = this._el;
					this._listeners = [
						[
							a$1,
							"touchstart",
							{ passive: !0 }
						],
						[
							a$1,
							"touchmove",
							{ passive: !1 }
						],
						[
							a$1,
							"touchend",
							void 0
						],
						[
							a$1,
							"touchcancel",
							void 0
						],
						[
							a$1,
							"mousedown",
							void 0
						],
						[
							a$1,
							"mousemove",
							void 0
						],
						[
							a$1,
							"mouseup",
							void 0
						],
						[
							this._ownerDocument,
							"mousemove",
							{ capture: !0 }
						],
						[
							this._ownerDocument,
							"mouseup",
							void 0
						],
						[
							a$1,
							"mouseover",
							void 0
						],
						[
							a$1,
							"mouseout",
							void 0
						],
						[
							a$1,
							"dblclick",
							void 0
						],
						[
							a$1,
							"click",
							void 0
						],
						[
							a$1,
							"keydown",
							{ capture: !1 }
						],
						[
							a$1,
							"keyup",
							void 0
						],
						[
							a$1,
							"wheel",
							{ passive: !1 }
						],
						[
							a$1,
							"contextmenu",
							void 0
						],
						[
							this._ownerWindow,
							"blur",
							void 0
						]
					];
					for (const [e$2, t$1, i$2] of this._listeners) h.addEventListener(e$2, t$1, e$2 === this._ownerDocument ? this.handleWindowEvent : this.handleEvent, i$2);
				}
				destroy() {
					for (const [e$1, t$1, i$1] of this._listeners) h.removeEventListener(e$1, t$1, e$1 === this._ownerDocument ? this.handleWindowEvent : this.handleEvent, i$1);
				}
				_addDefaultHandlers(e$1) {
					const i$1 = this._map, a$1 = i$1.getCanvasContainer();
					this._add("mapEvent", new nr(i$1, e$1));
					const o$1 = i$1.boxZoom = new hr(i$1, e$1);
					this._add("boxZoom", o$1), e$1.interactive && e$1.boxZoom && o$1.enable();
					const r$1 = i$1.cooperativeGestures = new Vr(i$1, e$1.cooperativeGestures);
					this._add("cooperativeGestures", r$1), e$1.cooperativeGestures && r$1.enable();
					const s$1 = new pr(i$1), n$1 = new jr(i$1);
					i$1.doubleClickZoom = new Or(n$1, s$1), this._add("tapZoom", s$1), this._add("clickZoom", n$1), e$1.interactive && e$1.doubleClickZoom && i$1.doubleClickZoom.enable();
					const l$1 = new Nr();
					this._add("tapDragZoom", l$1);
					const c$1 = i$1.touchPitch = new Rr(i$1);
					this._add("touchPitch", c$1), e$1.interactive && e$1.touchPitch && i$1.touchPitch.enable(e$1.touchPitch);
					const u$1 = () => i$1.project(i$1.getCenter()), d$1 = function({ enable: e$2, clickTolerance: i$2, aroundCenter: a$2 = !0, minPixelCenterThreshold: o$2 = 100, rotateDegreesPerPixelMoved: r$2 = .8 }, s$2) {
						return new mr({
							clickTolerance: i$2,
							move: (e$3, i$3) => {
								const n$2 = s$2();
								if (a$2 && Math.abs(n$2.y - e$3.y) > o$2) return { bearingDelta: t.cy(new t.P(e$3.x, i$3.y), i$3, n$2) };
								let l$2 = (i$3.x - e$3.x) * r$2;
								return a$2 && i$3.y < n$2.y && (l$2 = -l$2), { bearingDelta: l$2 };
							},
							moveStateManager: new xr({ checkCorrectEvent: (e$3) => 0 === h.mouseButton(e$3) && e$3.ctrlKey || 2 === h.mouseButton(e$3) && !e$3.ctrlKey }),
							enable: e$2,
							assignEvents: wr
						});
					}(e$1, u$1), _$1 = function({ enable: e$2, clickTolerance: t$1, pitchDegreesPerPixelMoved: i$2 = -.5 }) {
						return new mr({
							clickTolerance: t$1,
							move: (e$3, t$2) => ({ pitchDelta: (t$2.y - e$3.y) * i$2 }),
							moveStateManager: new xr({ checkCorrectEvent: (e$3) => 0 === h.mouseButton(e$3) && e$3.ctrlKey || 2 === h.mouseButton(e$3) }),
							enable: e$2,
							assignEvents: wr
						});
					}(e$1), p$1 = function({ enable: e$2, clickTolerance: t$1, rollDegreesPerPixelMoved: i$2 = .3 }, a$2) {
						return new mr({
							clickTolerance: t$1,
							move: (e$3, t$2) => {
								const o$2 = a$2();
								let r$2 = (t$2.x - e$3.x) * i$2;
								return t$2.y < o$2.y && (r$2 = -r$2), { rollDelta: r$2 };
							},
							moveStateManager: new xr({ checkCorrectEvent: (e$3) => 2 === h.mouseButton(e$3) && e$3.ctrlKey }),
							enable: e$2,
							assignEvents: wr
						});
					}(e$1, u$1);
					i$1.dragRotate = new Ur(e$1, d$1, _$1, p$1), this._add("mouseRotate", d$1, ["mousePitch"]), this._add("mousePitch", _$1, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", p$1, ["mousePitch"]), e$1.interactive && e$1.dragRotate && i$1.dragRotate.enable();
					const m$1 = function({ enable: e$2, clickTolerance: t$1 }) {
						return new mr({
							clickTolerance: t$1,
							move: (e$3, t$2) => ({
								around: t$2,
								panDelta: t$2.sub(e$3)
							}),
							activateOnStart: !0,
							moveStateManager: new xr({ checkCorrectEvent: (e$3) => 0 === h.mouseButton(e$3) && !e$3.ctrlKey }),
							enable: e$2,
							assignEvents: wr
						});
					}(e$1), f$1 = new Tr(e$1, i$1);
					i$1.dragPan = new Zr(a$1, m$1, f$1), this._add("mousePan", m$1), this._add("touchPan", f$1, ["touchZoom", "touchRotate"]), e$1.interactive && e$1.dragPan && i$1.dragPan.enable(e$1.dragPan);
					const g$1 = new Sr(), v$1 = new Mr();
					i$1.touchZoomRotate = new Gr(a$1, v$1, g$1, l$1), this._add("touchRotate", g$1, ["touchPan", "touchZoom"]), this._add("touchZoom", v$1, ["touchPan", "touchRotate"]), e$1.interactive && e$1.touchZoomRotate && i$1.touchZoomRotate.enable(e$1.touchZoomRotate), this._add("blockableMapEvent", new lr(i$1));
					const x$1 = i$1.scrollZoom = new Br(i$1, (() => this._triggerRenderFrame()));
					this._add("scrollZoom", x$1, ["mousePan"]), e$1.interactive && e$1.scrollZoom && i$1.scrollZoom.enable(e$1.scrollZoom);
					const b$1 = i$1.keyboard = new Ar(i$1);
					this._add("keyboard", b$1), e$1.interactive && e$1.keyboard && i$1.keyboard.enable();
				}
				_add(e$1, t$1, i$1) {
					this._handlers.push({
						handlerName: e$1,
						handler: t$1,
						allowed: i$1
					}), this._handlersById[e$1] = t$1;
				}
				stop(e$1) {
					if (!this._updatingCamera) {
						for (const { handler: e$2 } of this._handlers) e$2.reset();
						this._inertia.clear(), this._fireEvents({}, {}, e$1), this._changes = [];
					}
				}
				isActive() {
					for (const { handler: e$1 } of this._handlers) if (e$1.isActive()) return !0;
					return !1;
				}
				isZooming() {
					return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
				}
				isRotating() {
					return !!this._eventsInProgress.rotate;
				}
				isMoving() {
					return Boolean(qr(this._eventsInProgress)) || this.isZooming();
				}
				_blockedByActive(e$1, t$1, i$1) {
					for (const a$1 in e$1) if (a$1 !== i$1 && (!t$1 || t$1.indexOf(a$1) < 0)) return !0;
					return !1;
				}
				_getMapTouches(e$1) {
					const t$1 = [];
					for (const i$1 of e$1) this._el.contains(i$1.target) && t$1.push(i$1);
					return t$1;
				}
				mergeHandlerResult(e$1, i$1, a$1, o$1, r$1) {
					if (!a$1) return;
					t.e(e$1, a$1);
					const s$1 = {
						handlerName: o$1,
						originalEvent: a$1.originalEvent || r$1
					};
					void 0 !== a$1.zoomDelta && (i$1.zoom = s$1), void 0 !== a$1.panDelta && (i$1.drag = s$1), void 0 !== a$1.rollDelta && (i$1.roll = s$1), void 0 !== a$1.pitchDelta && (i$1.pitch = s$1), void 0 !== a$1.bearingDelta && (i$1.rotate = s$1);
				}
				_applyChanges() {
					const e$1 = {}, i$1 = {}, a$1 = {};
					for (const [o$1, r$1, s$1] of this._changes) o$1.panDelta && (e$1.panDelta = (e$1.panDelta || new t.P(0, 0))._add(o$1.panDelta)), o$1.zoomDelta && (e$1.zoomDelta = (e$1.zoomDelta || 0) + o$1.zoomDelta), o$1.bearingDelta && (e$1.bearingDelta = (e$1.bearingDelta || 0) + o$1.bearingDelta), o$1.pitchDelta && (e$1.pitchDelta = (e$1.pitchDelta || 0) + o$1.pitchDelta), o$1.rollDelta && (e$1.rollDelta = (e$1.rollDelta || 0) + o$1.rollDelta), void 0 !== o$1.around && (e$1.around = o$1.around), void 0 !== o$1.pinchAround && (e$1.pinchAround = o$1.pinchAround), o$1.noInertia && (e$1.noInertia = o$1.noInertia), t.e(i$1, r$1), t.e(a$1, s$1);
					this._updateMapTransform(e$1, i$1, a$1), this._changes = [];
				}
				_updateMapTransform(e$1, t$1, i$1) {
					const a$1 = this._map, o$1 = a$1._getTransformForUpdate(), r$1 = a$1.terrain;
					if (!($r(e$1) || r$1 && this._terrainMovement)) return this._fireEvents(t$1, i$1, !0);
					a$1._stop(!0);
					let { panDelta: s$1, zoomDelta: n$1, bearingDelta: l$1, pitchDelta: c$1, rollDelta: h$1, around: u$1, pinchAround: d$1 } = e$1;
					void 0 !== d$1 && (u$1 = d$1), u$1 = u$1 || a$1.transform.centerPoint, r$1 && !o$1.isPointOnMapSurface(u$1) && (u$1 = o$1.centerPoint);
					const _$1 = {
						panDelta: s$1,
						zoomDelta: n$1,
						rollDelta: h$1,
						pitchDelta: c$1,
						bearingDelta: l$1,
						around: u$1
					};
					this._map.cameraHelper.useGlobeControls && !o$1.isPointOnMapSurface(u$1) && (u$1 = o$1.centerPoint);
					const p$1 = u$1.distSqr(o$1.centerPoint) < .01 ? o$1.center : o$1.screenPointToLocation(s$1 ? u$1.sub(s$1) : u$1);
					this._handleMapControls({
						terrain: r$1,
						tr: o$1,
						deltasForHelper: _$1,
						preZoomAroundLoc: p$1,
						combinedEventsInProgress: t$1,
						panDelta: s$1
					}), a$1._applyUpdatedTransform(o$1), this._map._update(), e$1.noInertia || this._inertia.record(e$1), this._fireEvents(t$1, i$1, !0);
				}
				_handleMapControls({ terrain: e$1, tr: t$1, deltasForHelper: i$1, preZoomAroundLoc: a$1, combinedEventsInProgress: o$1, panDelta: r$1 }) {
					const s$1 = this._map.cameraHelper;
					if (s$1.handleMapControlsRollPitchBearingZoom(i$1, t$1), e$1) return s$1.useGlobeControls ? (this._terrainMovement || !o$1.drag && !o$1.zoom || (this._terrainMovement = !0, this._map._elevationFreeze = !0), void s$1.handleMapControlsPan(i$1, t$1, a$1)) : this._terrainMovement || !o$1.drag && !o$1.zoom ? void (o$1.drag && this._terrainMovement && r$1 ? t$1.setCenter(t$1.screenPointToLocation(t$1.centerPoint.sub(r$1))) : s$1.handleMapControlsPan(i$1, t$1, a$1)) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, void s$1.handleMapControlsPan(i$1, t$1, a$1));
					s$1.handleMapControlsPan(i$1, t$1, a$1);
				}
				_fireEvents(e$1, i$1, a$1) {
					const o$1 = qr(this._eventsInProgress), r$1 = qr(e$1), s$1 = {};
					for (const t$1 in e$1) {
						const { originalEvent: i$2 } = e$1[t$1];
						this._eventsInProgress[t$1] || (s$1[`${t$1}start`] = i$2), this._eventsInProgress[t$1] = e$1[t$1];
					}
					!o$1 && r$1 && this._fireEvent("movestart", r$1.originalEvent);
					for (const e$2 in s$1) this._fireEvent(e$2, s$1[e$2]);
					r$1 && this._fireEvent("move", r$1.originalEvent);
					for (const t$1 in e$1) {
						const { originalEvent: i$2 } = e$1[t$1];
						this._fireEvent(t$1, i$2);
					}
					const l$1 = {};
					let c$1;
					for (const e$2 in this._eventsInProgress) {
						const { handlerName: t$1, originalEvent: a$2 } = this._eventsInProgress[e$2];
						this._handlersById[t$1].isActive() || (delete this._eventsInProgress[e$2], c$1 = i$1[t$1] || a$2, l$1[`${e$2}end`] = c$1);
					}
					for (const e$2 in l$1) this._fireEvent(e$2, l$1[e$2]);
					const h$1 = qr(this._eventsInProgress), u$1 = (o$1 || r$1) && !h$1;
					if (u$1 && this._terrainMovement) {
						this._map._elevationFreeze = !1, this._terrainMovement = !1;
						const e$2 = this._map._getTransformForUpdate();
						this._map.getCenterClampedToGround() && e$2.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(e$2);
					}
					if (a$1 && u$1) {
						this._updatingCamera = !0;
						const e$2 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i$2 = (e$3) => 0 !== e$3 && -this._bearingSnap < e$3 && e$3 < this._bearingSnap;
						!e$2 || !e$2.essential && n.prefersReducedMotion ? (this._map.fire(new t.l("moveend", { originalEvent: c$1 })), i$2(this._map.getBearing()) && this._map.resetNorth()) : (i$2(e$2.bearing || this._map.getBearing()) && (e$2.bearing = 0), e$2.freezeElevation = !0, this._map.easeTo(e$2, { originalEvent: c$1 })), this._updatingCamera = !1;
					}
				}
				_fireEvent(e$1, i$1) {
					this._map.fire(new t.l(e$1, i$1 ? { originalEvent: i$1 } : {}));
				}
				_requestFrame() {
					return this._map.triggerRepaint(), this._map._renderTaskQueue.add(((e$1) => {
						delete this._frameId, this.handleEvent(new Wr("renderFrame", { timeStamp: e$1 })), this._applyChanges();
					}));
				}
				_triggerRenderFrame() {
					void 0 === this._frameId && (this._frameId = this._requestFrame());
				}
			}
			class Xr extends t.E {
				constructor(e$1, t$1, i$1) {
					super(), this._renderFrameCallback = () => {
						const e$2 = Math.min((c() - this._easeStart) / this._easeOptions.duration, 1);
						this._onEaseFrame(this._easeOptions.easing(e$2)), e$2 < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
					}, this._moving = !1, this._zooming = !1, this.transform = e$1, this._bearingSnap = i$1.bearingSnap, this._zoomSnap = i$1.zoomSnap, this.cameraHelper = t$1, this.on("moveend", (() => {
						delete this._requestedCameraState;
					}));
				}
				migrateProjection(e$1, t$1) {
					e$1.apply(this.transform, !0), this.transform = e$1, this.cameraHelper = t$1;
				}
				getCenter() {
					return new t.V(this.transform.center.lng, this.transform.center.lat);
				}
				setCenter(e$1, t$1) {
					return this.jumpTo({ center: e$1 }, t$1);
				}
				getCenterElevation() {
					return this.transform.elevation;
				}
				setCenterElevation(e$1, t$1) {
					return this.jumpTo({ elevation: e$1 }, t$1), this;
				}
				getCenterClampedToGround() {
					return this._centerClampedToGround;
				}
				setCenterClampedToGround(e$1) {
					this._centerClampedToGround = e$1;
				}
				panBy(e$1, i$1, a$1) {
					return e$1 = t.P.convert(e$1).mult(-1), this.panTo(this.transform.center, t.e({ offset: e$1 }, i$1), a$1);
				}
				panTo(e$1, i$1, a$1) {
					return this.easeTo(t.e({ center: e$1 }, i$1), a$1);
				}
				getZoom() {
					return this.transform.zoom;
				}
				setZoom(e$1, t$1) {
					return this.jumpTo({ zoom: e$1 }, t$1), this;
				}
				zoomTo(e$1, i$1, a$1) {
					return this.easeTo(t.e({ zoom: e$1 }, i$1), a$1);
				}
				zoomIn(e$1, i$1) {
					return this.zoomTo(t.cx(this.getZoom() + 1, this._zoomSnap), e$1, i$1), this;
				}
				zoomOut(e$1, i$1) {
					return this.zoomTo(t.cx(this.getZoom() - 1, this._zoomSnap), e$1, i$1), this;
				}
				getVerticalFieldOfView() {
					return this.transform.fov;
				}
				setVerticalFieldOfView(e$1, i$1) {
					return e$1 != this.transform.fov && (this.transform.setFov(e$1), this.fire(new t.l("movestart", i$1)).fire(new t.l("move", i$1)).fire(new t.l("moveend", i$1))), this;
				}
				getBearing() {
					return this.transform.bearing;
				}
				setZoomSnap(e$1) {
					return this._zoomSnap = e$1, this;
				}
				getZoomSnap() {
					return this._zoomSnap;
				}
				setBearing(e$1, t$1) {
					return this.jumpTo({ bearing: e$1 }, t$1), this;
				}
				getPadding() {
					return this.transform.padding;
				}
				setPadding(e$1, t$1) {
					return this.jumpTo({ padding: e$1 }, t$1), this;
				}
				rotateTo(e$1, i$1, a$1) {
					return this.easeTo(t.e({ bearing: e$1 }, i$1), a$1);
				}
				resetNorth(e$1, i$1) {
					return this.rotateTo(0, t.e({ duration: 1e3 }, e$1), i$1), this;
				}
				resetNorthPitch(e$1, i$1) {
					return this.easeTo(t.e({
						bearing: 0,
						pitch: 0,
						roll: 0,
						duration: 1e3
					}, e$1), i$1), this;
				}
				snapToNorth(e$1, t$1) {
					return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e$1, t$1) : this;
				}
				getPitch() {
					return this.transform.pitch;
				}
				setPitch(e$1, t$1) {
					return this.jumpTo({ pitch: e$1 }, t$1), this;
				}
				getRoll() {
					return this.transform.roll;
				}
				setRoll(e$1, t$1) {
					return this.jumpTo({ roll: e$1 }, t$1), this;
				}
				cameraForBounds(e$1, t$1) {
					e$1 = $.convert(e$1).adjustAntiMeridian();
					const i$1 = t$1 && t$1.bearing || 0;
					return this._cameraForBoxAndBearing(e$1.getNorthWest(), e$1.getSouthEast(), i$1, t$1);
				}
				_cameraForBoxAndBearing(e$1, i$1, a$1, o$1) {
					const r$1 = {
						top: 0,
						bottom: 0,
						right: 0,
						left: 0
					};
					if ("number" == typeof (o$1 = t.e({
						padding: r$1,
						offset: [0, 0],
						maxZoom: this.transform.maxZoom
					}, o$1)).padding) {
						const e$2 = o$1.padding;
						o$1.padding = {
							top: e$2,
							bottom: e$2,
							right: e$2,
							left: e$2
						};
					}
					const s$1 = t.e(r$1, o$1.padding);
					o$1.padding = s$1;
					const n$1 = this.transform, l$1 = new $(e$1, i$1);
					return this.cameraHelper.cameraForBoxAndBearing(o$1, s$1, l$1, a$1, n$1);
				}
				fitBounds(e$1, t$1, i$1) {
					return this._fitInternal(this.cameraForBounds(e$1, t$1), t$1, i$1);
				}
				fitScreenCoordinates(e$1, i$1, a$1, o$1, r$1) {
					return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(t.P.convert(e$1)), this.transform.screenPointToLocation(t.P.convert(i$1)), a$1, o$1), o$1, r$1);
				}
				_fitInternal(e$1, i$1, a$1) {
					return e$1 ? (delete (i$1 = t.e(e$1, i$1)).padding, i$1.linear ? this.easeTo(i$1, a$1) : this.flyTo(i$1, a$1)) : this;
				}
				jumpTo(e$1, i$1) {
					this.stop();
					const a$1 = this._getTransformForUpdate();
					let o$1 = !1, r$1 = !1, s$1 = !1;
					const n$1 = a$1.zoom;
					this.cameraHelper.handleJumpToCenterZoom(a$1, e$1);
					const l$1 = a$1.zoom !== n$1;
					return "elevation" in e$1 && a$1.elevation !== +e$1.elevation && a$1.setElevation(+e$1.elevation), "bearing" in e$1 && a$1.bearing !== +e$1.bearing && (o$1 = !0, a$1.setBearing(+e$1.bearing)), "pitch" in e$1 && a$1.pitch !== +e$1.pitch && (r$1 = !0, a$1.setPitch(+e$1.pitch)), "roll" in e$1 && a$1.roll !== +e$1.roll && (s$1 = !0, a$1.setRoll(+e$1.roll)), null == e$1.padding || a$1.isPaddingEqual(e$1.padding) || a$1.setPadding(e$1.padding), this._applyUpdatedTransform(a$1), this.fire(new t.l("movestart", i$1)).fire(new t.l("move", i$1)), l$1 && this.fire(new t.l("zoomstart", i$1)).fire(new t.l("zoom", i$1)).fire(new t.l("zoomend", i$1)), o$1 && this.fire(new t.l("rotatestart", i$1)).fire(new t.l("rotate", i$1)).fire(new t.l("rotateend", i$1)), r$1 && this.fire(new t.l("pitchstart", i$1)).fire(new t.l("pitch", i$1)).fire(new t.l("pitchend", i$1)), s$1 && this.fire(new t.l("rollstart", i$1)).fire(new t.l("roll", i$1)).fire(new t.l("rollend", i$1)), this.fire(new t.l("moveend", i$1));
				}
				calculateCameraOptionsFromTo(e$1, i$1, a$1, o$1 = 0) {
					const r$1 = t.a9.fromLngLat(e$1, i$1), s$1 = t.a9.fromLngLat(a$1, o$1), n$1 = s$1.x - r$1.x, l$1 = s$1.y - r$1.y, c$1 = s$1.z - r$1.z, h$1 = Math.hypot(n$1, l$1, c$1);
					if (0 === h$1) throw new Error("Can't calculate camera options with same From and To");
					const u$1 = Math.hypot(n$1, l$1), d$1 = t.at(this.transform.cameraToCenterDistance / h$1 / this.transform.tileSize), _$1 = 180 * Math.atan2(n$1, -l$1) / Math.PI;
					let p$1 = 180 * Math.acos(u$1 / h$1) / Math.PI;
					return p$1 = c$1 < 0 ? 90 - p$1 : 90 + p$1, {
						center: s$1.toLngLat(),
						elevation: o$1,
						zoom: d$1,
						pitch: p$1,
						bearing: _$1
					};
				}
				calculateCameraOptionsFromCameraLngLatAltRotation(e$1, t$1, i$1, a$1, o$1) {
					const r$1 = this.transform.calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, a$1);
					return {
						center: r$1.center,
						elevation: r$1.elevation,
						zoom: r$1.zoom,
						bearing: i$1,
						pitch: a$1,
						roll: o$1
					};
				}
				easeTo(e$1, i$1) {
					this._stop(!1, e$1.easeId), (!1 === (e$1 = t.e({
						offset: [0, 0],
						duration: 500,
						easing: t.cz
					}, e$1)).animate || !e$1.essential && n.prefersReducedMotion) && (e$1.duration = 0);
					const a$1 = this._getTransformForUpdate(), o$1 = this.getBearing(), r$1 = a$1.pitch, s$1 = a$1.roll, l$1 = "bearing" in e$1 ? this._normalizeBearing(e$1.bearing, o$1) : o$1, c$1 = "pitch" in e$1 ? +e$1.pitch : r$1, h$1 = "roll" in e$1 ? this._normalizeBearing(e$1.roll, s$1) : s$1, u$1 = "padding" in e$1 ? e$1.padding : a$1.padding, d$1 = t.P.convert(e$1.offset);
					let _$1, p$1;
					e$1.around && (_$1 = t.V.convert(e$1.around), p$1 = a$1.locationToScreenPoint(_$1));
					const m$1 = {
						moving: this._moving,
						zooming: this._zooming,
						rotating: this._rotating,
						pitching: this._pitching,
						rolling: this._rolling
					}, f$1 = this.cameraHelper.handleEaseTo(a$1, {
						bearing: l$1,
						pitch: c$1,
						roll: h$1,
						padding: u$1,
						around: _$1,
						aroundPoint: p$1,
						offsetAsPoint: d$1,
						offset: e$1.offset,
						zoom: e$1.zoom,
						center: e$1.center
					});
					return this._rotating = this._rotating || o$1 !== l$1, this._pitching = this._pitching || c$1 !== r$1, this._rolling = this._rolling || h$1 !== s$1, this._padding = !a$1.isPaddingEqual(u$1), this._zooming = this._zooming || f$1.isZooming, this._easeId = e$1.easeId, this._prepareEase(i$1, e$1.noMoveStart, m$1), this.terrain && this._prepareElevation(f$1.elevationCenter), this._ease(((t$1) => {
						f$1.easeFunc(t$1), this.terrain && !e$1.freezeElevation && this._updateElevation(t$1), this._applyUpdatedTransform(a$1), this._fireMoveEvents(i$1);
					}), ((t$1) => {
						this.terrain && e$1.freezeElevation && this._finalizeElevation(), this._afterEase(i$1, t$1);
					}), e$1), this;
				}
				_prepareEase(e$1, i$1, a$1 = {}) {
					this._moving = !0, i$1 || a$1.moving || this.fire(new t.l("movestart", e$1)), this._zooming && !a$1.zooming && this.fire(new t.l("zoomstart", e$1)), this._rotating && !a$1.rotating && this.fire(new t.l("rotatestart", e$1)), this._pitching && !a$1.pitching && this.fire(new t.l("pitchstart", e$1)), this._rolling && !a$1.rolling && this.fire(new t.l("rollstart", e$1));
				}
				_prepareElevation(e$1) {
					this._elevationCenter = e$1, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e$1, this.transform.tileZoom), this._elevationFreeze = !0;
				}
				_updateElevation(e$1) {
					void 0 !== this._elevationStart && void 0 !== this._elevationCenter || this._prepareElevation(this.transform.center), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
					const i$1 = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
					if (e$1 < 1 && i$1 !== this._elevationTarget) {
						const t$1 = this._elevationTarget - this._elevationStart;
						this._elevationStart += e$1 * (t$1 - (i$1 - (t$1 * e$1 + this._elevationStart)) / (1 - e$1)), this._elevationTarget = i$1;
					}
					this.transform.setElevation(t.G.number(this._elevationStart, this._elevationTarget, e$1));
				}
				_finalizeElevation() {
					this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
				}
				_getTransformForUpdate() {
					return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
				}
				_elevateCameraIfInsideTerrain(e$1) {
					if (!this.terrain && e$1.elevation >= 0 && e$1.pitch <= 90) return {};
					const t$1 = e$1.getCameraLngLat(), i$1 = e$1.getCameraAltitude(), a$1 = this.terrain ? this.terrain.getElevationForLngLatZoom(t$1, e$1.zoom) : 0;
					if (i$1 < a$1) {
						const i$2 = this.calculateCameraOptionsFromTo(t$1, a$1, e$1.center, e$1.elevation);
						return {
							pitch: i$2.pitch,
							zoom: i$2.zoom
						};
					}
					return {};
				}
				_applyUpdatedTransform(e$1) {
					const t$1 = [];
					if (t$1.push(((e$2) => this._elevateCameraIfInsideTerrain(e$2))), this.transformCameraUpdate && t$1.push(((e$2) => this.transformCameraUpdate(e$2))), !t$1.length) return;
					const i$1 = e$1.clone();
					for (const e$2 of t$1) {
						const t$2 = i$1.clone(), { center: a$1, zoom: o$1, roll: r$1, pitch: s$1, bearing: n$1, elevation: l$1 } = e$2(t$2);
						a$1 && t$2.setCenter(a$1), void 0 !== l$1 && t$2.setElevation(l$1), void 0 !== o$1 && t$2.setZoom(o$1), void 0 !== r$1 && t$2.setRoll(r$1), void 0 !== s$1 && t$2.setPitch(s$1), void 0 !== n$1 && t$2.setBearing(n$1), i$1.apply(t$2, !1);
					}
					this.transform.apply(i$1, !1);
				}
				_fireMoveEvents(e$1) {
					this.fire(new t.l("move", e$1)), this._zooming && this.fire(new t.l("zoom", e$1)), this._rotating && this.fire(new t.l("rotate", e$1)), this._pitching && this.fire(new t.l("pitch", e$1)), this._rolling && this.fire(new t.l("roll", e$1));
				}
				_afterEase(e$1, i$1) {
					if (this._easeId && i$1 && this._easeId === i$1) return;
					delete this._easeId;
					const a$1 = this._zooming, o$1 = this._rotating, r$1 = this._pitching, s$1 = this._rolling;
					this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, a$1 && this.fire(new t.l("zoomend", e$1)), o$1 && this.fire(new t.l("rotateend", e$1)), r$1 && this.fire(new t.l("pitchend", e$1)), s$1 && this.fire(new t.l("rollend", e$1)), this.fire(new t.l("moveend", e$1));
				}
				flyTo(e$1, i$1) {
					if (!e$1.essential && n.prefersReducedMotion) {
						const a$2 = t.U(e$1, [
							"center",
							"zoom",
							"bearing",
							"pitch",
							"roll",
							"elevation",
							"padding"
						]);
						return this.jumpTo(a$2, i$1);
					}
					this.stop(), e$1 = t.e({
						offset: [0, 0],
						speed: 1.2,
						curve: 1.42,
						easing: t.cz
					}, e$1);
					const a$1 = this._getTransformForUpdate(), o$1 = a$1.bearing, r$1 = a$1.pitch, s$1 = a$1.roll, l$1 = a$1.padding, c$1 = "bearing" in e$1 ? this._normalizeBearing(e$1.bearing, o$1) : o$1, h$1 = "pitch" in e$1 ? +e$1.pitch : r$1, u$1 = "roll" in e$1 ? this._normalizeBearing(e$1.roll, s$1) : s$1, d$1 = "padding" in e$1 ? e$1.padding : a$1.padding, _$1 = t.P.convert(e$1.offset);
					let p$1 = a$1.centerPoint.add(_$1);
					const m$1 = a$1.screenPointToLocation(p$1), f$1 = this.cameraHelper.handleFlyTo(a$1, {
						bearing: c$1,
						pitch: h$1,
						roll: u$1,
						padding: d$1,
						locationAtOffset: m$1,
						offsetAsPoint: _$1,
						center: e$1.center,
						minZoom: e$1.minZoom,
						zoom: e$1.zoom
					});
					let g$1 = e$1.curve;
					const v$1 = Math.max(a$1.width, a$1.height), x$1 = v$1 / f$1.scaleOfZoom, b$1 = f$1.pixelPathLength;
					"number" == typeof f$1.scaleOfMinZoom && (g$1 = Math.sqrt(v$1 / f$1.scaleOfMinZoom / b$1 * 2));
					const y$1 = g$1 * g$1;
					function w$1(e$2) {
						const t$1 = (x$1 * x$1 - v$1 * v$1 + (e$2 ? -1 : 1) * y$1 * y$1 * b$1 * b$1) / (2 * (e$2 ? x$1 : v$1) * y$1 * b$1);
						return Math.log(Math.sqrt(t$1 * t$1 + 1) - t$1);
					}
					function T$1(e$2) {
						return (Math.exp(e$2) - Math.exp(-e$2)) / 2;
					}
					function P$1(e$2) {
						return (Math.exp(e$2) + Math.exp(-e$2)) / 2;
					}
					const C$1 = w$1(!1);
					let I$1 = function(e$2) {
						return P$1(C$1) / P$1(C$1 + g$1 * e$2);
					}, M$1 = function(e$2) {
						return v$1 * ((P$1(C$1) * (T$1(t$1 = C$1 + g$1 * e$2) / P$1(t$1)) - T$1(C$1)) / y$1) / b$1;
						var t$1;
					}, E$1 = (w$1(!0) - C$1) / g$1;
					if (Math.abs(b$1) < 2e-6 || !isFinite(E$1)) {
						if (Math.abs(v$1 - x$1) < 1e-6) return this.easeTo(e$1, i$1);
						const t$1 = x$1 < v$1 ? -1 : 1;
						E$1 = Math.abs(Math.log(x$1 / v$1)) / g$1, M$1 = () => 0, I$1 = (e$2) => Math.exp(t$1 * g$1 * e$2);
					}
					return e$1.duration = "duration" in e$1 ? +e$1.duration : 1e3 * E$1 / ("screenSpeed" in e$1 ? +e$1.screenSpeed / g$1 : +e$1.speed), e$1.maxDuration && e$1.duration > e$1.maxDuration && (e$1.duration = 0), this._zooming = !0, this._rotating = o$1 !== c$1, this._pitching = h$1 !== r$1, this._rolling = u$1 !== s$1, this._padding = !a$1.isPaddingEqual(d$1), this._prepareEase(i$1, !1), this.terrain && this._prepareElevation(f$1.targetCenter), this._ease(((n$1) => {
						const m$2 = n$1 * E$1, g$2 = 1 / I$1(m$2), v$2 = M$1(m$2);
						this._rotating && a$1.setBearing(t.G.number(o$1, c$1, n$1)), this._pitching && a$1.setPitch(t.G.number(r$1, h$1, n$1)), this._rolling && a$1.setRoll(t.G.number(s$1, u$1, n$1)), this._padding && (a$1.interpolatePadding(l$1, d$1, n$1), p$1 = a$1.centerPoint.add(_$1)), f$1.easeFunc(n$1, g$2, v$2, p$1), this.terrain && !e$1.freezeElevation && this._updateElevation(n$1), this._applyUpdatedTransform(a$1), this._fireMoveEvents(i$1);
					}), (() => {
						this.terrain && e$1.freezeElevation && this._finalizeElevation(), this._afterEase(i$1);
					}), e$1), this;
				}
				isEasing() {
					return !!this._easeFrameId;
				}
				stop() {
					return this._stop();
				}
				_stop(e$1, t$1) {
					var i$1;
					if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
						const e$2 = this._onEaseEnd;
						delete this._onEaseEnd, e$2.call(this, t$1);
					}
					return e$1 || null === (i$1 = this.handlers) || void 0 === i$1 || i$1.stop(!1), this;
				}
				_ease(e$1, t$1, i$1) {
					!1 === i$1.animate || 0 === i$1.duration ? (e$1(1), t$1()) : (this._easeStart = c(), this._easeOptions = i$1, this._onEaseFrame = e$1, this._onEaseEnd = t$1, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
				}
				_normalizeBearing(e$1, i$1) {
					e$1 = t.W(e$1, -180, 180);
					const a$1 = Math.abs(e$1 - i$1);
					return Math.abs(e$1 - 360 - i$1) < a$1 && (e$1 -= 360), Math.abs(e$1 + 360 - i$1) < a$1 && (e$1 += 360), e$1;
				}
				queryTerrainElevation(e$1) {
					return this.terrain ? this.terrain.getElevationForLngLat(t.V.convert(e$1), this.transform) : null;
				}
			}
			const Kr = {
				compact: !0,
				customAttribution: "<a href=\"https://maplibre.org/\" target=\"_blank\">MapLibre</a>"
			};
			class Yr {
				constructor(e$1 = Kr) {
					this._toggleAttribution = () => {
						this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
					}, this._updateData = (e$2) => {
						!e$2 || "metadata" !== e$2.sourceDataType && "visibility" !== e$2.sourceDataType && "style" !== e$2.dataType && "terrain" !== e$2.type || this._updateAttributions();
					}, this._updateCompact = () => {
						this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? !1 === this._compact ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
					}, this._updateCompactMinimize = () => {
						this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
					}, this.options = e$1;
				}
				getDefaultPosition() {
					return "bottom-right";
				}
				onAdd(e$1) {
					return this._map = e$1, this._compact = this.options.compact, this._container = h.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = h.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = h.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
				}
				onRemove() {
					h.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
				}
				_setElementTitle(e$1, t$1) {
					const i$1 = this._map._getUIString(`AttributionControl.${t$1}`);
					e$1.title = i$1, e$1.setAttribute("aria-label", i$1);
				}
				_updateAttributions() {
					if (!this._map.style) return;
					let e$1 = [];
					if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e$1 = e$1.concat(this.options.customAttribution.map(((e$2) => "string" != typeof e$2 ? "" : e$2))) : "string" == typeof this.options.customAttribution && e$1.push(this.options.customAttribution)), this._map.style.stylesheet) {
						const e$2 = this._map.style.stylesheet;
						this.styleOwner = e$2.owner, this.styleId = e$2.id;
					}
					const t$1 = this._map.style.tileManagers;
					for (const i$2 in t$1) {
						const a$1 = t$1[i$2];
						if (a$1.used || a$1.usedForTerrain) {
							const t$2 = a$1.getSource();
							t$2.attribution && e$1.indexOf(t$2.attribution) < 0 && e$1.push(t$2.attribution);
						}
					}
					e$1 = e$1.filter(((e$2) => String(e$2).trim())), e$1.sort(((e$2, t$2) => e$2.length - t$2.length)), e$1 = e$1.filter(((t$2, i$2) => {
						for (let a$1 = i$2 + 1; a$1 < e$1.length; a$1++) if (e$1[a$1].indexOf(t$2) >= 0) return !1;
						return !0;
					}));
					const i$1 = e$1.join(" | ");
					i$1 !== this._attribHTML && (this._attribHTML = i$1, e$1.length ? (this._innerContainer.innerHTML = h.sanitize(i$1), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
				}
			}
			class Qr {
				constructor(e$1 = {}) {
					this._updateCompact = () => {
						const e$2 = this._container.children;
						if (e$2.length) {
							const t$1 = e$2[0];
							this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? !1 !== this._compact && t$1.classList.add("maplibregl-compact") : t$1.classList.remove("maplibregl-compact");
						}
					}, this.options = e$1;
				}
				getDefaultPosition() {
					return "bottom-left";
				}
				onAdd(e$1) {
					this._map = e$1, this._compact = this.options && this.options.compact, this._container = h.create("div", "maplibregl-ctrl");
					const t$1 = h.create("a", "maplibregl-ctrl-logo");
					return t$1.target = "_blank", t$1.rel = "noopener nofollow", t$1.href = "https://maplibre.org/", t$1.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t$1.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t$1), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
				}
				onRemove() {
					h.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
				}
			}
			class Jr {
				constructor() {
					this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
				}
				add(e$1) {
					const t$1 = ++this._id;
					return this._queue.push({
						callback: e$1,
						id: t$1,
						cancelled: !1
					}), t$1;
				}
				remove(e$1) {
					const t$1 = this._currentlyRunning, i$1 = t$1 ? this._queue.concat(t$1) : this._queue;
					for (const t$2 of i$1) if (t$2.id === e$1) return void (t$2.cancelled = !0);
				}
				run(e$1 = 0) {
					if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
					const t$1 = this._currentlyRunning = this._queue;
					this._queue = [];
					for (const i$1 of t$1) if (!i$1.cancelled && (i$1.callback(e$1), this._cleared)) break;
					this._cleared = !1, this._currentlyRunning = !1;
				}
				clear() {
					this._currentlyRunning && (this._cleared = !0), this._queue = [];
				}
			}
			var es = t.aU([{
				name: "a_pos3d",
				type: "Int16",
				components: 3
			}]);
			class ts extends t.E {
				constructor(e$1) {
					super(), this._lastTilesetChange = c(), this.tileManager = e$1, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e$1._source.tileSize * 2 ** this.deltaZoom, e$1.usedForTerrain = !0, e$1.tileSize = this.tileSize;
				}
				destruct() {
					this.tileManager.usedForTerrain = !1, this.tileManager.tileSize = null;
				}
				getSource() {
					return this.tileManager._source;
				}
				update(e$1, i$1) {
					this.tileManager.update(e$1, i$1), this._renderableTilesKeys = [];
					const a$1 = {};
					for (const o$1 of Ie(e$1, {
						tileSize: this.tileSize,
						minzoom: this.minzoom,
						maxzoom: this.maxzoom,
						reparseOverscaled: !1,
						terrain: i$1,
						calculateTileZoom: this.tileManager._source.calculateTileZoom
					})) a$1[o$1.key] = !0, this._renderableTilesKeys.push(o$1.key), this._tiles[o$1.key] || (o$1.terrainRttPosMatrix32f = new Float64Array(16), t.c7(o$1.terrainRttPosMatrix32f, 0, t.a5, t.a5, 0, 0, 1), this._tiles[o$1.key] = new de(o$1, this.tileSize), this._lastTilesetChange = c());
					for (const e$2 in this._tiles) a$1[e$2] || delete this._tiles[e$2];
				}
				freeRtt(e$1) {
					for (const t$1 in this._tiles) {
						const i$1 = this._tiles[t$1];
						(!e$1 || i$1.tileID.equals(e$1) || i$1.tileID.isChildOf(e$1) || e$1.isChildOf(i$1.tileID)) && (i$1.rtt = []);
					}
				}
				getRenderableTiles() {
					return this._renderableTilesKeys.map(((e$1) => this.getTileByID(e$1)));
				}
				getTileByID(e$1) {
					return this._tiles[e$1];
				}
				getTerrainCoords(e$1, t$1) {
					return t$1 ? this._getTerrainCoordsForTileRanges(e$1, t$1) : this._getTerrainCoordsForRegularTile(e$1);
				}
				_getTerrainCoordsForRegularTile(e$1) {
					const i$1 = {};
					for (const a$1 of this._renderableTilesKeys) {
						const o$1 = this._tiles[a$1].tileID, r$1 = e$1.clone(), s$1 = t.bk();
						if (o$1.canonical.equals(e$1.canonical)) t.c7(s$1, 0, t.a5, t.a5, 0, 0, 1);
						else if (o$1.canonical.isChildOf(e$1.canonical)) {
							const i$2 = o$1.canonical.z - e$1.canonical.z, a$2 = o$1.canonical.x - (o$1.canonical.x >> i$2 << i$2), r$2 = o$1.canonical.y - (o$1.canonical.y >> i$2 << i$2), n$1 = t.a5 >> i$2;
							t.c7(s$1, 0, n$1, n$1, 0, 0, 1), t.O(s$1, s$1, [
								-a$2 * n$1,
								-r$2 * n$1,
								0
							]);
						} else {
							if (!e$1.canonical.isChildOf(o$1.canonical)) continue;
							{
								const i$2 = e$1.canonical.z - o$1.canonical.z, a$2 = e$1.canonical.x - (e$1.canonical.x >> i$2 << i$2), r$2 = e$1.canonical.y - (e$1.canonical.y >> i$2 << i$2), n$1 = t.a5 >> i$2;
								t.c7(s$1, 0, t.a5, t.a5, 0, 0, 1), t.O(s$1, s$1, [
									a$2 * n$1,
									r$2 * n$1,
									0
								]), t.Q(s$1, s$1, [
									1 / 2 ** i$2,
									1 / 2 ** i$2,
									0
								]);
							}
						}
						r$1.terrainRttPosMatrix32f = new Float32Array(s$1), i$1[a$1] = r$1;
					}
					return i$1;
				}
				_getTerrainCoordsForTileRanges(e$1, i$1) {
					const a$1 = {};
					for (const o$1 of this._renderableTilesKeys) {
						const r$1 = this._tiles[o$1].tileID;
						if (!this._isWithinTileRanges(r$1, i$1)) continue;
						const s$1 = e$1.clone(), n$1 = t.bk();
						if (r$1.canonical.z === e$1.canonical.z) {
							const i$2 = e$1.canonical.x - r$1.canonical.x + e$1.wrap * (1 << e$1.canonical.z), a$2 = e$1.canonical.y - r$1.canonical.y;
							t.c7(n$1, 0, t.a5, t.a5, 0, 0, 1), t.O(n$1, n$1, [
								i$2 * t.a5,
								a$2 * t.a5,
								0
							]);
						} else if (r$1.canonical.z > e$1.canonical.z) {
							const i$2 = r$1.canonical.z - e$1.canonical.z, a$2 = r$1.canonical.x - (r$1.canonical.x >> i$2 << i$2) + e$1.wrap * (1 << r$1.canonical.z), o$2 = r$1.canonical.y - (r$1.canonical.y >> i$2 << i$2), s$2 = e$1.canonical.x - (r$1.canonical.x >> i$2), l$1 = e$1.canonical.y - (r$1.canonical.y >> i$2), c$1 = t.a5 >> i$2;
							t.c7(n$1, 0, c$1, c$1, 0, 0, 1), t.O(n$1, n$1, [
								-a$2 * c$1 + s$2 * t.a5,
								-o$2 * c$1 + l$1 * t.a5,
								0
							]);
						} else {
							const i$2 = e$1.canonical.z - r$1.canonical.z, a$2 = e$1.canonical.x - (e$1.canonical.x >> i$2 << i$2) + e$1.wrap * (1 << e$1.canonical.z), o$2 = e$1.canonical.y - (e$1.canonical.y >> i$2 << i$2), s$2 = (e$1.canonical.x >> i$2) - r$1.canonical.x, l$1 = (e$1.canonical.y >> i$2) - r$1.canonical.y, c$1 = t.a5 << i$2;
							t.c7(n$1, 0, c$1, c$1, 0, 0, 1), t.O(n$1, n$1, [
								a$2 * t.a5 + s$2 * c$1,
								o$2 * t.a5 + l$1 * c$1,
								0
							]);
						}
						s$1.terrainRttPosMatrix32f = new Float32Array(n$1), a$1[o$1] = s$1;
					}
					return a$1;
				}
				getSourceTile(e$1, t$1) {
					const i$1 = this.tileManager._source;
					let a$1 = e$1.overscaledZ - this.deltaZoom;
					if (a$1 > i$1.maxzoom && (a$1 = i$1.maxzoom), a$1 < i$1.minzoom) return;
					this._sourceTileCache[e$1.key] || (this._sourceTileCache[e$1.key] = e$1.scaledTo(a$1).key);
					let o$1 = this.findTileInCaches(this._sourceTileCache[e$1.key]);
					if (!(null == o$1 ? void 0 : o$1.dem) && t$1) for (; a$1 >= i$1.minzoom && !(null == o$1 ? void 0 : o$1.dem);) o$1 = this.findTileInCaches(e$1.scaledTo(a$1--).key);
					return o$1;
				}
				findTileInCaches(e$1) {
					let t$1 = this.tileManager.getTileByID(e$1);
					return t$1 || (t$1 = this.tileManager._outOfViewCache.getByKey(e$1), t$1);
				}
				anyTilesAfterTime(e$1 = Date.now()) {
					return this._lastTilesetChange >= e$1;
				}
				_isWithinTileRanges(e$1, t$1) {
					const i$1 = t$1[e$1.canonical.z];
					return !!i$1 && (e$1.wrap > i$1.minWrap || e$1.wrap < i$1.maxWrap || e$1.canonical.x >= i$1.minTileXWrapped && e$1.canonical.x <= i$1.maxTileXWrapped && e$1.canonical.y >= i$1.minTileY && e$1.canonical.y <= i$1.maxTileY);
				}
			}
			class is {
				constructor(e$1, t$1, i$1) {
					this._meshCache = {}, this.painter = e$1, this.tileManager = new ts(t$1), this.options = i$1, this.exaggeration = "number" == typeof i$1.exaggeration ? i$1.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
				}
				getDEMElevation(e$1, i$1, a$1, o$1 = t.a5) {
					var r$1;
					if (!(i$1 >= 0 && i$1 < o$1 && a$1 >= 0 && a$1 < o$1)) return 0;
					const s$1 = this.getTerrainData(e$1), n$1 = null === (r$1 = s$1.tile) || void 0 === r$1 ? void 0 : r$1.dem;
					if (!n$1) return 0;
					const l$1 = t.cD([], [i$1 / o$1 * t.a5, a$1 / o$1 * t.a5], s$1.u_terrain_matrix), c$1 = [l$1[0] * n$1.dim, l$1[1] * n$1.dim], h$1 = Math.floor(c$1[0]), u$1 = Math.floor(c$1[1]), d$1 = c$1[0] - h$1, _$1 = c$1[1] - u$1;
					return n$1.get(h$1, u$1) * (1 - d$1) * (1 - _$1) + n$1.get(h$1 + 1, u$1) * d$1 * (1 - _$1) + n$1.get(h$1, u$1 + 1) * (1 - d$1) * _$1 + n$1.get(h$1 + 1, u$1 + 1) * d$1 * _$1;
				}
				getElevationForLngLatZoom(e$1, i$1) {
					if (!t.cE(i$1, e$1.wrap())) return 0;
					const { tileID: a$1, mercatorX: o$1, mercatorY: r$1 } = this._getOverscaledTileIDFromLngLatZoom(e$1, i$1);
					return this.getElevation(a$1, o$1 % t.a5, r$1 % t.a5, t.a5);
				}
				getElevationForLngLat(e$1, t$1) {
					const i$1 = Ie(t$1, {
						maxzoom: this.tileManager.maxzoom,
						minzoom: this.tileManager.minzoom,
						tileSize: 512,
						terrain: this
					});
					let a$1 = 0;
					for (const e$2 of i$1) e$2.canonical.z > a$1 && (a$1 = Math.min(e$2.canonical.z, this.tileManager.maxzoom));
					return this.getElevationForLngLatZoom(e$1, a$1);
				}
				getElevation(e$1, i$1, a$1, o$1 = t.a5) {
					return this.getDEMElevation(e$1, i$1, a$1, o$1) * this.exaggeration;
				}
				getTerrainData(e$1) {
					if (!this._emptyDemTexture) {
						const e$2 = this.painter.context, i$2 = new t.R({
							width: 1,
							height: 1
						}, new Uint8Array(4));
						this._emptyDepthTexture = new t.T(e$2, i$2, e$2.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [
							0,
							0,
							0,
							0
						], this._emptyDemTexture = new t.T(e$2, new t.R({
							width: 1,
							height: 1
						}), e$2.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(e$2.gl.NEAREST, e$2.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = t.ar([]);
					}
					const i$1 = this.tileManager.getSourceTile(e$1, !0);
					if (i$1 && i$1.dem && (!i$1.demTexture || i$1.needsTerrainPrepare)) {
						const e$2 = this.painter.context;
						i$1.demTexture = this.painter.getTileTexture(i$1.dem.stride), i$1.demTexture ? i$1.demTexture.update(i$1.dem.getPixels(), { premultiply: !1 }) : i$1.demTexture = new t.T(e$2, i$1.dem.getPixels(), e$2.gl.RGBA, { premultiply: !1 }), i$1.demTexture.bind(e$2.gl.NEAREST, e$2.gl.CLAMP_TO_EDGE), i$1.needsTerrainPrepare = !1;
					}
					const a$1 = i$1 && i$1.toString() + i$1.tileID.key + e$1.key;
					if (a$1 && !this._demMatrixCache[a$1]) {
						const a$2 = this.tileManager.getSource().maxzoom;
						let o$1 = e$1.canonical.z - i$1.tileID.canonical.z;
						e$1.overscaledZ > e$1.canonical.z && (e$1.canonical.z >= a$2 ? o$1 = e$1.canonical.z - a$2 : t.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
						const r$1 = e$1.canonical.x - (e$1.canonical.x >> o$1 << o$1), s$1 = e$1.canonical.y - (e$1.canonical.y >> o$1 << o$1), n$1 = t.cF(new Float64Array(16), [
							1 / (t.a5 << o$1),
							1 / (t.a5 << o$1),
							0
						]);
						t.O(n$1, n$1, [
							r$1 * t.a5,
							s$1 * t.a5,
							0
						]), this._demMatrixCache[e$1.key] = {
							matrix: n$1,
							coord: e$1
						};
					}
					return {
						u_depth: 2,
						u_terrain: 3,
						u_terrain_dim: i$1 && i$1.dem && i$1.dem.dim || 1,
						u_terrain_matrix: a$1 ? this._demMatrixCache[e$1.key].matrix : this._emptyDemMatrix,
						u_terrain_unpack: i$1 && i$1.dem && i$1.dem.getUnpackVector() || this._emptyDemUnpack,
						u_terrain_exaggeration: this.exaggeration,
						texture: (i$1 && i$1.demTexture || this._emptyDemTexture).texture,
						depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture,
						tile: i$1
					};
				}
				getFramebuffer(e$1) {
					const i$1 = this.painter, a$1 = i$1.width / devicePixelRatio, o$1 = i$1.height / devicePixelRatio;
					return !this._fbo || this._fbo.width === a$1 && this._fbo.height === o$1 || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new t.T(i$1.context, {
						width: a$1,
						height: o$1,
						data: null
					}, i$1.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(i$1.context.gl.NEAREST, i$1.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new t.T(i$1.context, {
						width: a$1,
						height: o$1,
						data: null
					}, i$1.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(i$1.context.gl.NEAREST, i$1.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = i$1.context.createFramebuffer(a$1, o$1, !0, !1), this._fbo.depthAttachment.set(i$1.context.createRenderbuffer(i$1.context.gl.DEPTH_COMPONENT16, a$1, o$1))), this._fbo.colorAttachment.set("coords" === e$1 ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
				}
				getCoordsTexture() {
					const e$1 = this.painter.context;
					if (this._coordsTexture) return this._coordsTexture;
					const i$1 = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
					for (let e$2 = 0, t$1 = 0; e$2 < this._coordsTextureSize; e$2++) for (let a$2 = 0; a$2 < this._coordsTextureSize; a$2++, t$1 += 4) i$1[t$1 + 0] = 255 & a$2, i$1[t$1 + 1] = 255 & e$2, i$1[t$1 + 2] = a$2 >> 8 << 4 | e$2 >> 8, i$1[t$1 + 3] = 0;
					const a$1 = new t.R({
						width: this._coordsTextureSize,
						height: this._coordsTextureSize
					}, new Uint8Array(i$1.buffer)), o$1 = new t.T(e$1, a$1, e$1.gl.RGBA, { premultiply: !1 });
					return o$1.bind(e$1.gl.NEAREST, e$1.gl.CLAMP_TO_EDGE), this._coordsTexture = o$1, o$1;
				}
				pointCoordinate(e$1) {
					this.painter.maybeDrawDepthAndCoords(!0);
					const i$1 = new Uint8Array(4), a$1 = this.painter.context, o$1 = a$1.gl, r$1 = Math.round(e$1.x * this.painter.pixelRatio / devicePixelRatio), s$1 = Math.round(e$1.y * this.painter.pixelRatio / devicePixelRatio), n$1 = Math.round(this.painter.height / devicePixelRatio);
					a$1.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), o$1.readPixels(r$1, n$1 - s$1 - 1, 1, 1, o$1.RGBA, o$1.UNSIGNED_BYTE, i$1), a$1.bindFramebuffer.set(null);
					const l$1 = i$1[0] + (i$1[2] >> 4 << 8), c$1 = i$1[1] + ((15 & i$1[2]) << 8), h$1 = this.coordsIndex[255 - i$1[3]], u$1 = h$1 && this.tileManager.getTileByID(h$1);
					if (!u$1) return null;
					const d$1 = this._coordsTextureSize, _$1 = (1 << u$1.tileID.canonical.z) * d$1;
					return new t.a9((u$1.tileID.canonical.x * d$1 + l$1) / _$1 + u$1.tileID.wrap, (u$1.tileID.canonical.y * d$1 + c$1) / _$1, this.getElevation(u$1.tileID, l$1, c$1, d$1));
				}
				depthAtPoint(e$1) {
					const t$1 = new Uint8Array(4), i$1 = this.painter.context, a$1 = i$1.gl;
					return i$1.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), a$1.readPixels(e$1.x, this.painter.height / devicePixelRatio - e$1.y - 1, 1, 1, a$1.RGBA, a$1.UNSIGNED_BYTE, t$1), i$1.bindFramebuffer.set(null), (t$1[0] / 16777216 + t$1[1] / 65536 + t$1[2] / 256 + t$1[3]) / 256;
				}
				getTerrainMesh(e$1) {
					var i$1;
					const a$1 = (null === (i$1 = this.painter.style.projection) || void 0 === i$1 ? void 0 : i$1.transitionState) > 0, o$1 = a$1 && 0 === e$1.canonical.y, r$1 = a$1 && e$1.canonical.y === (1 << e$1.canonical.z) - 1, s$1 = `m_${o$1 ? "n" : ""}_${r$1 ? "s" : ""}`;
					if (this._meshCache[s$1]) return this._meshCache[s$1];
					const n$1 = this.painter.context, l$1 = new t.cG(), c$1 = new t.aY(), h$1 = this.meshSize, u$1 = t.a5 / h$1, d$1 = h$1 * h$1;
					for (let e$2 = 0; e$2 <= h$1; e$2++) for (let t$1 = 0; t$1 <= h$1; t$1++) l$1.emplaceBack(t$1 * u$1, e$2 * u$1, 0);
					for (let e$2 = 0; e$2 < d$1; e$2 += h$1 + 1) for (let t$1 = 0; t$1 < h$1; t$1++) c$1.emplaceBack(t$1 + e$2, h$1 + t$1 + e$2 + 1, h$1 + t$1 + e$2 + 2), c$1.emplaceBack(t$1 + e$2, h$1 + t$1 + e$2 + 2, t$1 + e$2 + 1);
					const _$1 = l$1.length, p$1 = _$1 + (h$1 + 1), m$1 = (h$1 + 1) * h$1, f$1 = o$1 ? t.br : 0, g$1 = o$1 ? 0 : 1, v$1 = r$1 ? t.bs : t.a5, x$1 = r$1 ? 0 : 1;
					for (let e$2 = 0; e$2 <= h$1; e$2++) l$1.emplaceBack(e$2 * u$1, f$1, g$1);
					for (let e$2 = 0; e$2 <= h$1; e$2++) l$1.emplaceBack(e$2 * u$1, v$1, x$1);
					for (let e$2 = 0; e$2 < h$1; e$2++) c$1.emplaceBack(m$1 + e$2, p$1 + e$2, p$1 + e$2 + 1), c$1.emplaceBack(m$1 + e$2, p$1 + e$2 + 1, m$1 + e$2 + 1), c$1.emplaceBack(0 + e$2, _$1 + e$2 + 1, _$1 + e$2), c$1.emplaceBack(0 + e$2, 0 + e$2 + 1, _$1 + e$2 + 1);
					const b$1 = l$1.length, y$1 = b$1 + 2 * (h$1 + 1);
					for (const e$2 of [0, 1]) for (let i$2 = 0; i$2 <= h$1; i$2++) for (const a$2 of [0, 1]) l$1.emplaceBack(e$2 * t.a5, i$2 * u$1, a$2);
					for (let e$2 = 0; e$2 < 2 * h$1; e$2 += 2) c$1.emplaceBack(b$1 + e$2, b$1 + e$2 + 1, b$1 + e$2 + 3), c$1.emplaceBack(b$1 + e$2, b$1 + e$2 + 3, b$1 + e$2 + 2), c$1.emplaceBack(y$1 + e$2, y$1 + e$2 + 3, y$1 + e$2 + 1), c$1.emplaceBack(y$1 + e$2, y$1 + e$2 + 2, y$1 + e$2 + 3);
					const w$1 = new kt(n$1.createVertexBuffer(l$1, es.members), n$1.createIndexBuffer(c$1), t.aX.simpleSegment(0, 0, l$1.length, c$1.length));
					return this._meshCache[s$1] = w$1, w$1;
				}
				getMeshFrameDelta(e$1) {
					return 2 * Math.PI * t.bE / Math.pow(2, Math.max(e$1, 0)) / 5;
				}
				getMinTileElevationForLngLatZoom(e$1, i$1) {
					var a$1;
					if (!t.cE(i$1, e$1.wrap())) return 0;
					const { tileID: o$1 } = this._getOverscaledTileIDFromLngLatZoom(e$1, i$1);
					return null !== (a$1 = this.getMinMaxElevation(o$1).minElevation) && void 0 !== a$1 ? a$1 : 0;
				}
				getMinMaxElevation(e$1) {
					const t$1 = this.getTerrainData(e$1).tile, i$1 = {
						minElevation: null,
						maxElevation: null
					};
					return t$1 && t$1.dem && (i$1.minElevation = t$1.dem.min * this.exaggeration, i$1.maxElevation = t$1.dem.max * this.exaggeration), i$1;
				}
				_getOverscaledTileIDFromLngLatZoom(e$1, i$1) {
					const a$1 = t.a9.fromLngLat(e$1.wrap()), o$1 = (1 << i$1) * t.a5, r$1 = a$1.x * o$1, s$1 = a$1.y * o$1, n$1 = Math.floor(r$1 / t.a5), l$1 = Math.floor(s$1 / t.a5);
					return {
						tileID: new t.a2(i$1, 0, i$1, n$1, l$1),
						mercatorX: r$1,
						mercatorY: s$1
					};
				}
			}
			class as {
				constructor(e$1, t$1, i$1) {
					this._context = e$1, this._size = t$1, this._tileSize = i$1, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
				}
				destruct() {
					for (const e$1 of this._objects) e$1.texture.destroy(), e$1.fbo.destroy();
				}
				_createObject(e$1) {
					const i$1 = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), a$1 = new t.T(this._context, {
						width: this._tileSize,
						height: this._tileSize,
						data: null
					}, this._context.gl.RGBA);
					return a$1.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), i$1.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), i$1.colorAttachment.set(a$1.texture), {
						id: e$1,
						fbo: i$1,
						texture: a$1,
						stamp: -1,
						inUse: !1
					};
				}
				getObjectForId(e$1) {
					return this._objects[e$1];
				}
				useObject(e$1) {
					e$1.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter(((t$1) => e$1.id !== t$1)), this._recentlyUsed.push(e$1.id);
				}
				stampObject(e$1) {
					e$1.stamp = ++this._stamp;
				}
				getOrCreateFreeObject() {
					for (const e$2 of this._recentlyUsed) if (!this._objects[e$2].inUse) return this._objects[e$2];
					if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
					const e$1 = this._createObject(this._objects.length);
					return this._objects.push(e$1), e$1;
				}
				freeObject(e$1) {
					e$1.inUse = !1;
				}
				freeAllObjects() {
					for (const e$1 of this._objects) this.freeObject(e$1);
				}
				isFull() {
					return !(this._objects.length < this._size) && !1 === this._objects.some(((e$1) => !e$1.inUse));
				}
			}
			const os = {
				background: !0,
				fill: !0,
				line: !0,
				raster: !0,
				hillshade: !0,
				"color-relief": !0
			};
			class rs {
				constructor(e$1, t$1) {
					this.painter = e$1, this.terrain = t$1, this.pool = new as(e$1.context, 30, t$1.tileManager.tileSize * t$1.qualityFactor);
				}
				destruct() {
					this.pool.destruct();
				}
				getTexture(e$1) {
					return this.pool.getObjectForId(e$1.rtt[this._stacks.length - 1].id).texture;
				}
				prepareForRender(e$1, t$1) {
					this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.tileManager.getRenderableTiles(), this._renderableLayerIds = e$1._order.filter(((i$1) => !e$1._layers[i$1].isHidden(t$1))), this._coordsAscending = {};
					for (const t$2 in e$1.tileManagers) {
						this._coordsAscending[t$2] = {};
						const i$1 = e$1.tileManagers[t$2].getVisibleCoordinates(), a$1 = e$1.tileManagers[t$2].getSource(), o$1 = a$1 instanceof te ? a$1.terrainTileRanges : null;
						for (const e$2 of i$1) {
							const i$2 = this.terrain.tileManager.getTerrainCoords(e$2, o$1);
							for (const e$3 in i$2) this._coordsAscending[t$2][e$3] || (this._coordsAscending[t$2][e$3] = []), this._coordsAscending[t$2][e$3].push(i$2[e$3]);
						}
					}
					this._coordsAscendingStr = {};
					for (const t$2 of e$1._order) {
						const i$1 = e$1._layers[t$2], a$1 = i$1.source;
						if (os[i$1.type] && !this._coordsAscendingStr[a$1]) {
							this._coordsAscendingStr[a$1] = {};
							for (const e$2 in this._coordsAscending[a$1]) this._coordsAscendingStr[a$1][e$2] = this._coordsAscending[a$1][e$2].map(((e$3) => e$3.key)).sort().join();
						}
					}
					for (const e$2 of this._renderableTiles) for (const t$2 in this._coordsAscendingStr) {
						const i$1 = this._coordsAscendingStr[t$2][e$2.tileID.key];
						i$1 && i$1 !== e$2.rttCoords[t$2] && (e$2.rtt = []);
					}
				}
				renderLayer(e$1, i$1) {
					if (e$1.isHidden(this.painter.transform.zoom)) return !1;
					const a$1 = Object.assign(Object.assign({}, i$1), { isRenderingToTexture: !0 }), o$1 = e$1.type, r$1 = this.painter, s$1 = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e$1.id;
					if (os[o$1] && (this._prevType && os[this._prevType] || this._stacks.push([]), this._prevType = o$1, this._stacks[this._stacks.length - 1].push(e$1.id), !s$1)) return !0;
					if (os[this._prevType] || os[o$1] && s$1) {
						this._prevType = o$1;
						const e$2 = this._stacks.length - 1, i$2 = this._stacks[e$2] || [];
						for (const o$2 of this._renderableTiles) {
							if (this.pool.isFull() && (Vo(this.painter, this.terrain, this._rttTiles, a$1), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(o$2), o$2.rtt[e$2]) {
								const t$1 = this.pool.getObjectForId(o$2.rtt[e$2].id);
								if (t$1.stamp === o$2.rtt[e$2].stamp) {
									this.pool.useObject(t$1);
									continue;
								}
							}
							const s$2 = this.pool.getOrCreateFreeObject();
							this.pool.useObject(s$2), this.pool.stampObject(s$2), o$2.rtt[e$2] = {
								id: s$2.id,
								stamp: s$2.stamp
							}, r$1.context.bindFramebuffer.set(s$2.fbo.framebuffer), r$1.context.clear({
								color: t.bp.transparent,
								stencil: 0
							}), r$1.currentStencilSource = void 0;
							for (let e$3 = 0; e$3 < i$2.length; e$3++) {
								const t$1 = r$1.style._layers[i$2[e$3]], n$1 = t$1.source ? this._coordsAscending[t$1.source][o$2.tileID.key] : [o$2.tileID];
								r$1.context.viewport.set([
									0,
									0,
									s$2.fbo.width,
									s$2.fbo.height
								]), r$1._renderTileClippingMasks(t$1, n$1, !0), r$1.renderLayer(r$1, r$1.style.tileManagers[t$1.source], t$1, n$1, a$1), t$1.source && (o$2.rttCoords[t$1.source] = this._coordsAscendingStr[t$1.source][o$2.tileID.key]);
							}
						}
						return Vo(this.painter, this.terrain, this._rttTiles, a$1), this._rttTiles = [], this.pool.freeAllObjects(), os[o$1];
					}
					return !1;
				}
			}
			const ss = {
				"AttributionControl.ToggleAttribution": "Toggle attribution",
				"AttributionControl.MapFeedback": "Map feedback",
				"FullscreenControl.Enter": "Enter fullscreen",
				"FullscreenControl.Exit": "Exit fullscreen",
				"GeolocateControl.FindMyLocation": "Find my location",
				"GeolocateControl.LocationNotAvailable": "Location not available",
				"LogoControl.Title": "MapLibre logo",
				"Map.Title": "Map",
				"Marker.Title": "Map marker",
				"NavigationControl.ResetBearing": "Reset bearing to north",
				"NavigationControl.ZoomIn": "Zoom in",
				"NavigationControl.ZoomOut": "Zoom out",
				"Popup.Close": "Close popup",
				"ScaleControl.Feet": "ft",
				"ScaleControl.Meters": "m",
				"ScaleControl.Kilometers": "km",
				"ScaleControl.Miles": "mi",
				"ScaleControl.NauticalMiles": "nm",
				"GlobeControl.Enable": "Enable globe",
				"GlobeControl.Disable": "Disable globe",
				"TerrainControl.Enable": "Enable terrain",
				"TerrainControl.Disable": "Disable terrain",
				"CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map",
				"CooperativeGesturesHandler.MacHelpText": "Use  + scroll to zoom the map",
				"CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map"
			}, ns = i, ls = {
				hash: !1,
				interactive: !0,
				bearingSnap: 7,
				zoomSnap: 0,
				attributionControl: Kr,
				maplibreLogo: !1,
				refreshExpiredTiles: !0,
				canvasContextAttributes: {
					antialias: !1,
					preserveDrawingBuffer: !1,
					powerPreference: "high-performance",
					failIfMajorPerformanceCaveat: !1,
					desynchronized: !1,
					contextType: void 0
				},
				scrollZoom: !0,
				minZoom: -2,
				maxZoom: 22,
				minPitch: 0,
				maxPitch: 60,
				boxZoom: !0,
				dragRotate: !0,
				dragPan: !0,
				keyboard: !0,
				doubleClickZoom: !0,
				touchZoomRotate: !0,
				touchPitch: !0,
				cooperativeGestures: !1,
				trackResize: !0,
				center: [0, 0],
				elevation: 0,
				zoom: 0,
				bearing: 0,
				pitch: 0,
				roll: 0,
				renderWorldCopies: !0,
				maxTileCacheSize: null,
				maxTileCacheZoomLevels: t.c.MAX_TILE_CACHE_ZOOM_LEVELS,
				transformRequest: null,
				transformCameraUpdate: null,
				transformConstrain: null,
				fadeDuration: 300,
				crossSourceCollisions: !0,
				clickTolerance: 3,
				localIdeographFontFamily: "sans-serif",
				pitchWithRotate: !0,
				rollEnabled: !1,
				reduceMotion: void 0,
				validateStyle: !0,
				maxCanvasSize: [4096, 4096],
				cancelPendingTileRequestsWhileZooming: !0,
				centerClampedToGround: !0,
				experimentalZoomLevelsToOverscale: void 0
			}, cs = {
				showCompass: !0,
				showZoom: !0,
				visualizePitch: !1,
				visualizeRoll: !0
			};
			class hs {
				constructor(e$1, i$1, a$1 = !1) {
					this.mousedown = (e$2) => {
						this.startMove(e$2, h.mousePos(this.element, e$2)), h.addEventListener(window, "mousemove", this.mousemove), h.addEventListener(window, "mouseup", this.mouseup);
					}, this.mousemove = (e$2) => {
						this.move(e$2, h.mousePos(this.element, e$2));
					}, this.mouseup = (e$2) => {
						this._rotatePitchHandler.dragEnd(e$2), this.offTemp();
					}, this.touchstart = (e$2) => {
						1 !== e$2.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = h.touchPos(this.element, e$2.targetTouches)[0], this.startMove(e$2, this._startPos), h.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), h.addEventListener(window, "touchend", this.touchend));
					}, this.touchmove = (e$2) => {
						1 !== e$2.targetTouches.length ? this.reset() : (this._lastPos = h.touchPos(this.element, e$2.targetTouches)[0], this.move(e$2, this._lastPos));
					}, this.touchend = (e$2) => {
						0 === e$2.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
					}, this.reset = () => {
						this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
					}, this._clickTolerance = 10, this.element = i$1;
					this._rotatePitchHandler = new mr({
						clickTolerance: 3,
						move: (e$2, o$1) => {
							const r$1 = i$1.getBoundingClientRect(), s$1 = new t.P((r$1.bottom - r$1.top) / 2, (r$1.right - r$1.left) / 2);
							return {
								bearingDelta: t.cy(new t.P(e$2.x, o$1.y), o$1, s$1),
								pitchDelta: a$1 ? -.5 * (o$1.y - e$2.y) : void 0
							};
						},
						moveStateManager: new yr(),
						enable: !0,
						assignEvents: () => {}
					}), this.map = e$1, h.addEventListener(i$1, "mousedown", this.mousedown), h.addEventListener(i$1, "touchstart", this.touchstart, { passive: !1 }), h.addEventListener(i$1, "touchcancel", this.reset);
				}
				startMove(e$1, t$1) {
					this._rotatePitchHandler.dragStart(e$1, t$1), h.disableDrag();
				}
				move(e$1, t$1) {
					const i$1 = this.map, { bearingDelta: a$1, pitchDelta: o$1 } = this._rotatePitchHandler.dragMove(e$1, t$1) || {};
					a$1 && i$1.setBearing(i$1.getBearing() + a$1), o$1 && i$1.setPitch(i$1.getPitch() + o$1);
				}
				off() {
					const e$1 = this.element;
					h.removeEventListener(e$1, "mousedown", this.mousedown), h.removeEventListener(e$1, "touchstart", this.touchstart, { passive: !1 }), h.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), h.removeEventListener(window, "touchend", this.touchend), h.removeEventListener(e$1, "touchcancel", this.reset), this.offTemp();
				}
				offTemp() {
					h.enableDrag(), h.removeEventListener(window, "mousemove", this.mousemove), h.removeEventListener(window, "mouseup", this.mouseup), h.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), h.removeEventListener(window, "touchend", this.touchend);
				}
			}
			let us;
			function ds(e$1, i$1, a$1, o$1 = !1) {
				if (o$1 || !a$1.getCoveringTilesDetailsProvider().allowWorldCopies()) return null == e$1 ? void 0 : e$1.wrap();
				const r$1 = new t.V(e$1.lng, e$1.lat);
				if (e$1 = new t.V(e$1.lng, e$1.lat), i$1) {
					const o$2 = new t.V(e$1.lng - 360, e$1.lat), r$2 = new t.V(e$1.lng + 360, e$1.lat), s$1 = a$1.locationToScreenPoint(e$1).distSqr(i$1);
					a$1.locationToScreenPoint(o$2).distSqr(i$1) < s$1 ? e$1 = o$2 : a$1.locationToScreenPoint(r$2).distSqr(i$1) < s$1 && (e$1 = r$2);
				}
				for (; Math.abs(e$1.lng - a$1.center.lng) > 180;) {
					const t$1 = a$1.locationToScreenPoint(e$1);
					if (t$1.x >= 0 && t$1.y >= 0 && t$1.x <= a$1.width && t$1.y <= a$1.height) break;
					e$1.lng > a$1.center.lng ? e$1.lng -= 360 : e$1.lng += 360;
				}
				return e$1.lng !== r$1.lng && a$1.isPointOnMapSurface(a$1.locationToScreenPoint(e$1)) ? e$1 : r$1;
			}
			const _s = {
				center: "translate(-50%,-50%)",
				top: "translate(-50%,0)",
				"top-left": "translate(0,0)",
				"top-right": "translate(-100%,0)",
				bottom: "translate(-50%,-100%)",
				"bottom-left": "translate(0,-100%)",
				"bottom-right": "translate(-100%,-100%)",
				left: "translate(0,-50%)",
				right: "translate(-100%,-50%)"
			};
			function ps(e$1, t$1, i$1) {
				const a$1 = e$1.classList;
				for (const e$2 in _s) a$1.remove(`maplibregl-${i$1}-anchor-${e$2}`);
				a$1.add(`maplibregl-${i$1}-anchor-${t$1}`);
			}
			class ms extends t.E {
				constructor(e$1) {
					if (super(), this._onKeyPress = (e$2) => {
						const t$1 = e$2.code, i$1 = e$2.charCode || e$2.keyCode;
						"Space" !== t$1 && "Enter" !== t$1 && 32 !== i$1 && 13 !== i$1 || this.togglePopup();
					}, this._onMapClick = (e$2) => {
						const t$1 = e$2.originalEvent.target, i$1 = this._element;
						this._popup && (t$1 === i$1 || i$1.contains(t$1)) && this.togglePopup();
					}, this._update = (e$2) => {
						if (!this._map) return;
						const t$1 = this._map.loaded() && !this._map.isMoving();
						("terrain" === (null == e$2 ? void 0 : e$2.type) || "render" === (null == e$2 ? void 0 : e$2.type) && !t$1) && this._map.once("render", this._update), this._lngLat = ds(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
						let i$1 = "";
						"viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? i$1 = `rotateZ(${this._rotation}deg)` : "map" === this._rotationAlignment && (i$1 = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
						let a$1 = "";
						"viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? a$1 = "rotateX(0deg)" : "map" === this._pitchAlignment && (a$1 = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || e$2 && "moveend" !== e$2.type || (this._pos = this._pos.round()), h.setTransform(this._element, `${_s[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${a$1} ${i$1}`), n.frameAsync(new AbortController(), this._map._ownerWindow).then((() => {
							this._updateOpacity(e$2 && "moveend" === e$2.type);
						})).catch((() => {}));
					}, this._onMove = (e$2) => {
						if (!this._isDragging) {
							const t$1 = this._clickTolerance || this._map._clickTolerance;
							this._isDragging = e$2.point.dist(this._pointerdownPos) >= t$1;
						}
						this._isDragging && (this._pos = e$2.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new t.l("dragstart"))), this.fire(new t.l("drag")));
					}, this._onUp = () => {
						this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new t.l("dragend")), this._state = "inactive";
					}, this._addDragHandler = (e$2) => {
						this._element.contains(e$2.originalEvent.target) && (e$2.preventDefault(), this._positionDelta = e$2.point.sub(this._pos).add(this._offset), this._pointerdownPos = e$2.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
					}, this._anchor = e$1 && e$1.anchor || "center", this._color = e$1 && e$1.color || "#3FB1CE", this._scale = e$1 && e$1.scale || 1, this._draggable = e$1 && e$1.draggable || !1, this._clickTolerance = e$1 && e$1.clickTolerance || 0, this._subpixelPositioning = e$1 && e$1.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = e$1 && e$1.rotation || 0, this._rotationAlignment = e$1 && e$1.rotationAlignment || "auto", this._pitchAlignment = e$1 && e$1.pitchAlignment && "auto" !== e$1.pitchAlignment ? e$1.pitchAlignment : this._rotationAlignment, this.setOpacity(null == e$1 ? void 0 : e$1.opacity, null == e$1 ? void 0 : e$1.opacityWhenCovered), e$1 && e$1.element) this._element = e$1.element, this._offset = t.P.convert(e$1 && e$1.offset || [0, 0]);
					else {
						this._defaultMarker = !0, this._element = h.create("div");
						const i$1 = h.createNS("http://www.w3.org/2000/svg", "svg"), a$1 = 41, o$1 = 27;
						i$1.setAttributeNS(null, "display", "block"), i$1.setAttributeNS(null, "height", `${a$1}px`), i$1.setAttributeNS(null, "width", `${o$1}px`), i$1.setAttributeNS(null, "viewBox", `0 0 ${o$1} ${a$1}`);
						const r$1 = h.createNS("http://www.w3.org/2000/svg", "g");
						r$1.setAttributeNS(null, "stroke", "none"), r$1.setAttributeNS(null, "stroke-width", "1"), r$1.setAttributeNS(null, "fill", "none"), r$1.setAttributeNS(null, "fill-rule", "evenodd");
						const s$1 = h.createNS("http://www.w3.org/2000/svg", "g");
						s$1.setAttributeNS(null, "fill-rule", "nonzero");
						const n$1 = h.createNS("http://www.w3.org/2000/svg", "g");
						n$1.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), n$1.setAttributeNS(null, "fill", "#000000");
						for (const e$2 of [
							{
								rx: "10.5",
								ry: "5.25002273"
							},
							{
								rx: "10.5",
								ry: "5.25002273"
							},
							{
								rx: "9.5",
								ry: "4.77275007"
							},
							{
								rx: "8.5",
								ry: "4.29549936"
							},
							{
								rx: "7.5",
								ry: "3.81822308"
							},
							{
								rx: "6.5",
								ry: "3.34094679"
							},
							{
								rx: "5.5",
								ry: "2.86367051"
							},
							{
								rx: "4.5",
								ry: "2.38636864"
							}
						]) {
							const t$1 = h.createNS("http://www.w3.org/2000/svg", "ellipse");
							t$1.setAttributeNS(null, "opacity", "0.04"), t$1.setAttributeNS(null, "cx", "10.5"), t$1.setAttributeNS(null, "cy", "5.80029008"), t$1.setAttributeNS(null, "rx", e$2.rx), t$1.setAttributeNS(null, "ry", e$2.ry), n$1.appendChild(t$1);
						}
						const c$1 = h.createNS("http://www.w3.org/2000/svg", "g");
						c$1.setAttributeNS(null, "fill", this._color);
						const u$1 = h.createNS("http://www.w3.org/2000/svg", "path");
						u$1.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), c$1.appendChild(u$1);
						const d$1 = h.createNS("http://www.w3.org/2000/svg", "g");
						d$1.setAttributeNS(null, "opacity", "0.25"), d$1.setAttributeNS(null, "fill", "#000000");
						const _$1 = h.createNS("http://www.w3.org/2000/svg", "path");
						_$1.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), d$1.appendChild(_$1);
						const p$1 = h.createNS("http://www.w3.org/2000/svg", "g");
						p$1.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), p$1.setAttributeNS(null, "fill", "#FFFFFF");
						const m$1 = h.createNS("http://www.w3.org/2000/svg", "g");
						m$1.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
						const f$1 = h.createNS("http://www.w3.org/2000/svg", "circle");
						f$1.setAttributeNS(null, "fill", "#000000"), f$1.setAttributeNS(null, "opacity", "0.25"), f$1.setAttributeNS(null, "cx", "5.5"), f$1.setAttributeNS(null, "cy", "5.5"), f$1.setAttributeNS(null, "r", "5.4999962");
						const g$1 = h.createNS("http://www.w3.org/2000/svg", "circle");
						g$1.setAttributeNS(null, "fill", "#FFFFFF"), g$1.setAttributeNS(null, "cx", "5.5"), g$1.setAttributeNS(null, "cy", "5.5"), g$1.setAttributeNS(null, "r", "5.4999962"), m$1.appendChild(f$1), m$1.appendChild(g$1), s$1.appendChild(n$1), s$1.appendChild(c$1), s$1.appendChild(d$1), s$1.appendChild(p$1), s$1.appendChild(m$1), i$1.appendChild(s$1), i$1.setAttributeNS(null, "height", a$1 * this._scale + "px"), i$1.setAttributeNS(null, "width", o$1 * this._scale + "px"), this._element.appendChild(i$1), this._offset = t.P.convert(e$1 && e$1.offset || [0, -14]);
					}
					if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", ((e$2) => {
						e$2.preventDefault();
					})), this._element.addEventListener("mousedown", ((e$2) => {
						e$2.preventDefault();
					})), ps(this._element, this._anchor, "marker"), e$1 && e$1.className) for (const t$1 of e$1.className.split(" ")) this._element.classList.add(t$1);
					this._popup = null;
				}
				addTo(e$1) {
					return this.remove(), this._map = e$1, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e$1._getUIString("Marker.Title")), this._element.hasAttribute("role") || this._element.setAttribute("role", "button"), e$1.getCanvasContainer().appendChild(this._element), e$1.on("move", this._update), e$1.on("moveend", this._update), e$1.on("terrain", this._update), e$1.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
				}
				remove() {
					return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), h.remove(this._element), this._popup && this._popup.remove(), this;
				}
				getLngLat() {
					return this._lngLat;
				}
				setLngLat(e$1) {
					return this._lngLat = t.V.convert(e$1), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
				}
				getElement() {
					return this._element;
				}
				setPopup(e$1) {
					if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e$1) {
						if (!("offset" in e$1.options)) {
							const t$1 = 38.1, i$1 = 13.5, a$1 = Math.abs(i$1) / Math.SQRT2;
							e$1.options.offset = this._defaultMarker ? {
								top: [0, 0],
								"top-left": [0, 0],
								"top-right": [0, 0],
								bottom: [0, -t$1],
								"bottom-left": [a$1, -1 * (t$1 - i$1 + a$1)],
								"bottom-right": [-a$1, -1 * (t$1 - i$1 + a$1)],
								left: [i$1, -1 * (t$1 - i$1)],
								right: [-i$1, -1 * (t$1 - i$1)]
							} : this._offset;
						}
						this._popup = e$1, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
					}
					return this;
				}
				setSubpixelPositioning(e$1) {
					return this._subpixelPositioning = e$1, this;
				}
				getPopup() {
					return this._popup;
				}
				togglePopup() {
					const e$1 = this._popup;
					return this._element.style.opacity === this._opacityWhenCovered ? this : e$1 ? (e$1.isOpen() ? e$1.remove() : (e$1.setLngLat(this._lngLat), e$1.addTo(this._map)), this) : this;
				}
				_updateOpacity(e$1 = !1) {
					var i$1, a$1;
					const o$1 = null === (i$1 = this._map) || void 0 === i$1 ? void 0 : i$1.terrain, r$1 = this._map.transform.isLocationOccluded(this._lngLat);
					if (!o$1 || r$1) {
						const e$2 = r$1 ? this._opacityWhenCovered : this._opacity;
						this._element.style.opacity !== e$2 && (this._element.style.opacity = e$2);
						return;
					}
					if (e$1) this._opacityTimeout = null;
					else {
						if (this._opacityTimeout) return;
						this._opacityTimeout = setTimeout((() => {
							this._opacityTimeout = null;
						}), 100);
					}
					const s$1 = this._map, n$1 = s$1.terrain.depthAtPoint(this._pos), l$1 = s$1.terrain.getElevationForLngLat(this._lngLat, s$1.transform);
					if (s$1.transform.lngLatToCameraDepth(this._lngLat, l$1) - n$1 < .006) return void (this._element.style.opacity = this._opacity);
					const c$1 = -this._offset.y / s$1.transform.pixelsPerMeter, h$1 = Math.sin(s$1.getPitch() * Math.PI / 180) * c$1, u$1 = s$1.terrain.depthAtPoint(new t.P(this._pos.x, this._pos.y - this._offset.y)), d$1 = s$1.transform.lngLatToCameraDepth(this._lngLat, l$1 + h$1) - u$1 > .006;
					!(null === (a$1 = this._popup) || void 0 === a$1) && a$1.isOpen() && d$1 && this._popup.remove(), this._element.style.opacity = d$1 ? this._opacityWhenCovered : this._opacity;
				}
				getOffset() {
					return this._offset;
				}
				setOffset(e$1) {
					return this._offset = t.P.convert(e$1), this._update(), this;
				}
				addClassName(e$1) {
					this._element.classList.add(e$1);
				}
				removeClassName(e$1) {
					this._element.classList.remove(e$1);
				}
				toggleClassName(e$1) {
					return this._element.classList.toggle(e$1);
				}
				setDraggable(e$1) {
					return this._draggable = !!e$1, this._map && (e$1 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
				}
				isDraggable() {
					return this._draggable;
				}
				setRotation(e$1) {
					return this._rotation = e$1 || 0, this._update(), this;
				}
				getRotation() {
					return this._rotation;
				}
				setRotationAlignment(e$1) {
					return this._rotationAlignment = e$1 || "auto", this._update(), this;
				}
				getRotationAlignment() {
					return this._rotationAlignment;
				}
				setPitchAlignment(e$1) {
					return this._pitchAlignment = e$1 && "auto" !== e$1 ? e$1 : this._rotationAlignment, this._update(), this;
				}
				getPitchAlignment() {
					return this._pitchAlignment;
				}
				setOpacity(e$1, t$1) {
					return (void 0 === this._opacity || void 0 === e$1 && void 0 === t$1) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), void 0 !== e$1 && (this._opacity = e$1), void 0 !== t$1 && (this._opacityWhenCovered = t$1), this._map && this._updateOpacity(!0), this;
				}
			}
			const fs = {
				positionOptions: {
					enableHighAccuracy: !1,
					maximumAge: 0,
					timeout: 6e3
				},
				fitBoundsOptions: { maxZoom: 15 },
				trackUserLocation: !1,
				showAccuracyCircle: !0,
				showUserLocation: !0
			};
			let gs = 0, vs = !1;
			const xs = {
				maxWidth: 100,
				unit: "metric"
			};
			function bs(e$1, t$1, i$1) {
				const a$1 = i$1 && i$1.maxWidth || 100, o$1 = e$1._container.clientHeight / 2, r$1 = e$1._container.clientWidth / 2, s$1 = e$1.unproject([r$1 - a$1 / 2, o$1]), n$1 = e$1.unproject([r$1 + a$1 / 2, o$1]), l$1 = Math.round(e$1.project(n$1).x - e$1.project(s$1).x), c$1 = Math.min(a$1, l$1, e$1._container.clientWidth), h$1 = s$1.distanceTo(n$1);
				if (i$1 && "imperial" === i$1.unit) {
					const i$2 = 3.2808 * h$1;
					i$2 > 5280 ? ys(t$1, c$1, i$2 / 5280, e$1._getUIString("ScaleControl.Miles")) : ys(t$1, c$1, i$2, e$1._getUIString("ScaleControl.Feet"));
				} else i$1 && "nautical" === i$1.unit ? ys(t$1, c$1, h$1 / 1852, e$1._getUIString("ScaleControl.NauticalMiles")) : h$1 >= 1e3 ? ys(t$1, c$1, h$1 / 1e3, e$1._getUIString("ScaleControl.Kilometers")) : ys(t$1, c$1, h$1, e$1._getUIString("ScaleControl.Meters"));
			}
			function ys(e$1, t$1, i$1, a$1) {
				const o$1 = function(e$2) {
					const t$2 = Math.pow(10, `${Math.floor(e$2)}`.length - 1);
					let i$2 = e$2 / t$2;
					return i$2 = i$2 >= 10 ? 10 : i$2 >= 5 ? 5 : i$2 >= 3 ? 3 : i$2 >= 2 ? 2 : i$2 >= 1 ? 1 : function(e$3) {
						const t$3 = Math.pow(10, Math.ceil(-Math.log(e$3) / Math.LN10));
						return Math.round(e$3 * t$3) / t$3;
					}(i$2), t$2 * i$2;
				}(i$1);
				e$1.style.width = t$1 * (o$1 / i$1) + "px", e$1.innerHTML = `${o$1}&nbsp;${a$1}`;
			}
			const ws = {
				closeButton: !0,
				closeOnClick: !0,
				focusAfterOpen: !0,
				className: "",
				maxWidth: "240px",
				subpixelPositioning: !1,
				locationOccludedOpacity: void 0,
				padding: void 0
			}, Ts = [
				"a[href]",
				"[tabindex]:not([tabindex='-1'])",
				"[contenteditable]:not([contenteditable='false'])",
				"button:not([disabled])",
				"input:not([disabled])",
				"select:not([disabled])",
				"textarea:not([disabled])"
			].join(", ");
			function Ps(e$1) {
				if (e$1) {
					if ("number" == typeof e$1) {
						const i$1 = Math.round(Math.abs(e$1) / Math.SQRT2);
						return {
							center: new t.P(0, 0),
							top: new t.P(0, e$1),
							"top-left": new t.P(i$1, i$1),
							"top-right": new t.P(-i$1, i$1),
							bottom: new t.P(0, -e$1),
							"bottom-left": new t.P(i$1, -i$1),
							"bottom-right": new t.P(-i$1, -i$1),
							left: new t.P(e$1, 0),
							right: new t.P(-e$1, 0)
						};
					}
					if (e$1 instanceof t.P || Array.isArray(e$1)) {
						const i$1 = t.P.convert(e$1);
						return {
							center: i$1,
							top: i$1,
							"top-left": i$1,
							"top-right": i$1,
							bottom: i$1,
							"bottom-left": i$1,
							"bottom-right": i$1,
							left: i$1,
							right: i$1
						};
					}
					return {
						center: t.P.convert(e$1.center || [0, 0]),
						top: t.P.convert(e$1.top || [0, 0]),
						"top-left": t.P.convert(e$1["top-left"] || [0, 0]),
						"top-right": t.P.convert(e$1["top-right"] || [0, 0]),
						bottom: t.P.convert(e$1.bottom || [0, 0]),
						"bottom-left": t.P.convert(e$1["bottom-left"] || [0, 0]),
						"bottom-right": t.P.convert(e$1["bottom-right"] || [0, 0]),
						left: t.P.convert(e$1.left || [0, 0]),
						right: t.P.convert(e$1.right || [0, 0])
					};
				}
				return Ps(new t.P(0, 0));
			}
			const Cs = i;
			e.AJAXError = t.cJ, e.Event = t.l, e.Evented = t.E, e.LngLat = t.V, e.MercatorCoordinate = t.a9, e.Point = t.P, e.addProtocol = t.cK, e.config = t.c, e.removeProtocol = t.cL, e.AttributionControl = Yr, e.BoxZoomHandler = hr, e.CanvasSource = ae, e.CooperativeGesturesHandler = Vr, e.DoubleClickZoomHandler = Or, e.DragPanHandler = Zr, e.DragRotateHandler = Ur, e.EdgeInsets = Nt, e.FullscreenControl = class extends t.E {
				constructor(e$1 = {}) {
					super(), this._onFullscreenChange = () => {
						var e$2;
						let t$1 = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
						for (; null === (e$2 = null == t$1 ? void 0 : t$1.shadowRoot) || void 0 === e$2 ? void 0 : e$2.fullscreenElement;) t$1 = t$1.shadowRoot.fullscreenElement;
						t$1 === this._container !== this._fullscreen && this._handleFullscreenChange();
					}, this._onClickFullscreen = () => {
						this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
					}, this._fullscreen = !1, e$1 && e$1.container && (e$1.container instanceof HTMLElement ? this._container = e$1.container : t.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
				}
				onAdd(e$1) {
					return this._map = e$1, this._container || (this._container = this._map.getContainer()), this._controlContainer = h.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
				}
				onRemove() {
					h.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
				}
				_setupUI() {
					const e$1 = this._fullscreenButton = h.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
					h.create("span", "maplibregl-ctrl-icon", e$1).setAttribute("aria-hidden", "true"), e$1.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
				}
				_updateTitle() {
					const e$1 = this._getTitle();
					this._fullscreenButton.setAttribute("aria-label", e$1), this._fullscreenButton.title = e$1;
				}
				_getTitle() {
					return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
				}
				_isFullscreen() {
					return this._fullscreen;
				}
				_handleFullscreenChange() {
					this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new t.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new t.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
				}
				_exitFullscreen() {
					window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
				}
				_requestFullscreen() {
					this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
				}
				_togglePseudoFullScreen() {
					this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
				}
			}, e.GeoJSONSource = ee, e.GeolocateControl = class extends t.E {
				constructor(e$1) {
					super(), this._onSuccess = (e$2) => {
						if (this._map) {
							if (this._isOutOfMapMaxBounds(e$2)) return this._setErrorState(), this.fire(new t.l("outofmaxbounds", e$2)), this._updateMarker(), void this._finish();
							if (this.options.trackUserLocation) switch (this._lastKnownPosition = e$2, this._watchState) {
								case "WAITING_ACTIVE":
								case "ACTIVE_LOCK":
								case "ACTIVE_ERROR":
									this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
									break;
								case "BACKGROUND":
								case "BACKGROUND_ERROR":
									this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
									break;
								default: throw new Error(`Unexpected watchState ${this._watchState}`);
							}
							this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e$2), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e$2), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new t.l("geolocate", e$2)), this._finish();
						}
					}, this._updateCamera = (e$2) => {
						const i$1 = new t.V(e$2.coords.longitude, e$2.coords.latitude), a$1 = e$2.coords.accuracy, o$1 = this._map.getBearing(), r$1 = t.e({ bearing: o$1 }, this.options.fitBoundsOptions), s$1 = $.fromLngLat(i$1, a$1);
						this._map.fitBounds(s$1, r$1, { geolocateSource: !0 });
					}, this._updateMarker = (e$2) => {
						if (e$2) {
							const i$1 = new t.V(e$2.coords.longitude, e$2.coords.latitude);
							this._accuracyCircleMarker.setLngLat(i$1).addTo(this._map), this._userLocationDotMarker.setLngLat(i$1).addTo(this._map), this._accuracy = e$2.coords.accuracy, this._updateCircleRadiusIfNeeded();
						} else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
					}, this._onUpdate = () => {
						this._updateCircleRadiusIfNeeded();
					}, this._onError = (e$2) => {
						if (this._map) {
							if (1 === e$2.code) {
								this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
								const e$3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
								this._geolocateButton.title = e$3, this._geolocateButton.setAttribute("aria-label", e$3), void 0 !== this._geolocationWatchID && this._clearWatch();
							} else {
								if (3 === e$2.code && vs) return;
								this._setErrorState();
							}
							"OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new t.l("error", e$2)), this._finish();
						}
					}, this._finish = () => {
						this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
					}, this._setupUI = () => {
						this._map && (this._container.addEventListener("contextmenu", ((e$2) => e$2.preventDefault())), this._geolocateButton = h.create("button", "maplibregl-ctrl-geolocate", this._container), h.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0);
					}, this._finishSetupUI = (e$2) => {
						if (this._map) {
							if (!1 === e$2) {
								t.w("Geolocation support is not available so the GeolocateControl will be disabled.");
								const e$3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
								this._geolocateButton.disabled = !0, this._geolocateButton.title = e$3, this._geolocateButton.setAttribute("aria-label", e$3);
							} else {
								const e$3 = this._map._getUIString("GeolocateControl.FindMyLocation");
								this._geolocateButton.disabled = !1, this._geolocateButton.title = e$3, this._geolocateButton.setAttribute("aria-label", e$3);
							}
							this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = h.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new ms({ element: this._dotElement }), this._circleElement = h.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new ms({
								element: this._circleElement,
								pitchAlignment: "map"
							}), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onUpdate), this._map.on("move", this._onUpdate), this._map.on("rotate", this._onUpdate), this._map.on("pitch", this._onUpdate)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", ((e$3) => {
								const i$1 = (null == e$3 ? void 0 : e$3[0]) instanceof ResizeObserverEntry;
								e$3.geolocateSource || "ACTIVE_LOCK" !== this._watchState || i$1 || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new t.l("trackuserlocationend")), this.fire(new t.l("userlocationlostfocus")));
							}));
						}
					}, this.options = t.e({}, fs, e$1);
				}
				onAdd(e$1) {
					return this._map = e$1, this._container = h.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function() {
						return t._(this, arguments, void 0, (function* (e$2 = !1) {
							if (void 0 !== us && !e$2) return us;
							if (void 0 === window.navigator.permissions) return us = !!window.navigator.geolocation, us;
							try {
								us = "denied" !== (yield window.navigator.permissions.query({ name: "geolocation" })).state;
							} catch (e$3) {
								us = !!window.navigator.geolocation;
							}
							return us;
						}));
					}().then(((e$2) => this._finishSetupUI(e$2))), this._container;
				}
				onRemove() {
					void 0 !== this._geolocationWatchID && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), h.remove(this._container), this._map.off("zoom", this._onUpdate), this._map.off("move", this._onUpdate), this._map.off("rotate", this._onUpdate), this._map.off("pitch", this._onUpdate), this._map = void 0, gs = 0, vs = !1;
				}
				_isOutOfMapMaxBounds(e$1) {
					const t$1 = this._map.getMaxBounds(), i$1 = e$1.coords;
					return t$1 && (i$1.longitude < t$1.getWest() || i$1.longitude > t$1.getEast() || i$1.latitude < t$1.getSouth() || i$1.latitude > t$1.getNorth());
				}
				_setErrorState() {
					switch (this._watchState) {
						case "WAITING_ACTIVE":
							this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
							break;
						case "ACTIVE_LOCK":
							this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
							break;
						case "BACKGROUND":
							this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
							break;
						case "ACTIVE_ERROR":
						case "BACKGROUND_ERROR":
						case "OFF":
						case void 0: break;
						default: throw new Error(`Unexpected watchState ${this._watchState}`);
					}
				}
				_updateCircleRadiusIfNeeded() {
					const e$1 = this._userLocationDotMarker.getLngLat();
					if (!(this.options.showUserLocation && this.options.showAccuracyCircle && this._accuracy && e$1)) return;
					const t$1 = this._map.project(e$1), i$1 = this._map.unproject([t$1.x + 100, t$1.y]), a$1 = e$1.distanceTo(i$1) / 100, o$1 = 2 * this._accuracy / a$1;
					this._circleElement.style.width = `${o$1.toFixed(2)}px`, this._circleElement.style.height = `${o$1.toFixed(2)}px`;
				}
				trigger() {
					if (!this._setup) return t.w("Geolocate control triggered before added to a map"), !1;
					if (this.options.trackUserLocation) {
						switch (this._watchState) {
							case "OFF":
								this._watchState = "WAITING_ACTIVE", this.fire(new t.l("trackuserlocationstart"));
								break;
							case "WAITING_ACTIVE":
							case "ACTIVE_LOCK":
							case "ACTIVE_ERROR":
							case "BACKGROUND_ERROR":
								gs--, vs = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new t.l("trackuserlocationend"));
								break;
							case "BACKGROUND":
								this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t.l("trackuserlocationstart")), this.fire(new t.l("userlocationfocus"));
								break;
							default: throw new Error(`Unexpected watchState ${this._watchState}`);
						}
						switch (this._watchState) {
							case "WAITING_ACTIVE":
								this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
								break;
							case "ACTIVE_LOCK":
								this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
								break;
							case "OFF": break;
							default: throw new Error(`Unexpected watchState ${this._watchState}`);
						}
						if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();
						else if (void 0 === this._geolocationWatchID) {
							let e$1;
							this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), gs++, gs > 1 ? (e$1 = {
								maximumAge: 6e5,
								timeout: 0
							}, vs = !0) : (e$1 = this.options.positionOptions, vs = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, e$1);
						}
					} else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
					return !0;
				}
				_clearWatch() {
					window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
				}
			}, e.GlobeControl = class {
				constructor() {
					this._toggleProjection = () => {
						var e$1;
						const t$1 = null === (e$1 = this._map.getProjection()) || void 0 === e$1 ? void 0 : e$1.type;
						this._map.setProjection("mercator" !== t$1 && t$1 ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
					}, this._updateGlobeIcon = () => {
						var e$1;
						this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), "globe" === (null === (e$1 = this._map.getProjection()) || void 0 === e$1 ? void 0 : e$1.type) ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
					};
				}
				onAdd(e$1) {
					return this._map = e$1, this._container = h.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = h.create("button", "maplibregl-ctrl-globe", this._container), h.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
				}
				onRemove() {
					h.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
				}
			}, e.Hash = Ho, e.ImageSource = te, e.KeyboardHandler = Ar, e.LngLatBounds = $, e.LogoControl = Qr, e.Map = class extends Xr {
				get _ownerWindow() {
					var e$1, t$1;
					return (null === (t$1 = null === (e$1 = this._container) || void 0 === e$1 ? void 0 : e$1.ownerDocument) || void 0 === t$1 ? void 0 : t$1.defaultView) || window;
				}
				constructor(e$1) {
					var i$1, a$1;
					t.cH.mark(t.cI.create);
					const o$1 = Object.assign(Object.assign(Object.assign({}, ls), e$1), { canvasContextAttributes: Object.assign(Object.assign({}, ls.canvasContextAttributes), e$1.canvasContextAttributes) });
					if (null != o$1.minZoom && null != o$1.maxZoom && o$1.minZoom > o$1.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
					if (null != o$1.minPitch && null != o$1.maxPitch && o$1.minPitch > o$1.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
					if (null != o$1.minPitch && o$1.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
					if (null != o$1.maxPitch && o$1.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
					const r$1 = new $t(), s$1 = new Yt();
					void 0 !== o$1.minZoom && r$1.setMinZoom(o$1.minZoom), void 0 !== o$1.maxZoom && r$1.setMaxZoom(o$1.maxZoom), void 0 !== o$1.minPitch && r$1.setMinPitch(o$1.minPitch), void 0 !== o$1.maxPitch && r$1.setMaxPitch(o$1.maxPitch), void 0 !== o$1.renderWorldCopies && r$1.setRenderWorldCopies(o$1.renderWorldCopies), null !== o$1.transformConstrain && r$1.setConstrainOverride(o$1.transformConstrain), super(r$1, s$1, {
						bearingSnap: o$1.bearingSnap,
						zoomSnap: o$1.zoomSnap
					}), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new Jr(), this._controls = [], this._mapId = t.af(), this._lostContextStyle = {
						style: null,
						images: null
					}, this._contextLost = (e$2) => {
						e$2.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.painter.destroy();
						for (const e$3 of Object.values(this.style._layers)) if ("custom" === e$3.type && console.warn(`Custom layer with id '${e$3.id}' cannot be restored after WebGL context loss. You will need to re-add it manually after context restoration.`), e$3._listeners) for (const [t$1] of Object.entries(e$3._listeners)) console.warn(`Custom layer with id '${e$3.id}' had event listeners for event '${t$1}' which cannot be restored after WebGL context loss. You will need to re-add them manually after context restoration.`);
						this._lostContextStyle = this._getStyleAndImages(), this.style.destroy(), this.style = null, this.fire(new t.l("webglcontextlost", { originalEvent: e$2 }));
					}, this._contextRestored = (e$2) => {
						this._lostContextStyle.style && this.setStyle(this._lostContextStyle.style, { diff: !1 }), this._lostContextStyle.images && (this.style.imageManager.images = this._lostContextStyle.images), this._lostContextStyle = {
							style: null,
							images: null
						}, this._setupPainter(), this.resize(), this._update(), this._resizeInternal(), this.fire(new t.l("webglcontextrestored", { originalEvent: e$2 }));
					}, this._onMapScroll = (e$2) => {
						if (e$2.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
					}, this._onWindowOnline = () => {
						this._update();
					}, this._interactive = o$1.interactive, this._maxTileCacheSize = o$1.maxTileCacheSize, this._maxTileCacheZoomLevels = o$1.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, o$1.canvasContextAttributes), this._trackResize = !0 === o$1.trackResize, this._bearingSnap = o$1.bearingSnap, this._zoomSnap = o$1.zoomSnap, this._centerClampedToGround = o$1.centerClampedToGround, this._refreshExpiredTiles = !0 === o$1.refreshExpiredTiles, this._fadeDuration = o$1.fadeDuration, this._crossSourceCollisions = !0 === o$1.crossSourceCollisions, this._collectResourceTiming = !0 === o$1.collectResourceTiming, this._locale = Object.assign(Object.assign({}, ss), o$1.locale), this._clickTolerance = o$1.clickTolerance, this._overridePixelRatio = o$1.pixelRatio, this._maxCanvasSize = o$1.maxCanvasSize, this._zoomLevelsToOverscale = o$1.experimentalZoomLevelsToOverscale, this.transformCameraUpdate = o$1.transformCameraUpdate, this.transformConstrain = o$1.transformConstrain, this.cancelPendingTileRequestsWhileZooming = !0 === o$1.cancelPendingTileRequestsWhileZooming, void 0 !== o$1.reduceMotion && (n.prefersReducedMotion = o$1.reduceMotion), this._imageQueueHandle = g.addThrottleControl((() => this.isMoving())), this._requestManager = new v(o$1.transformRequest), this._container = this._resolveContainer(o$1.container), o$1.maxBounds && this.setMaxBounds(o$1.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(!1))), this.on("moveend", (() => this._update(!1))), this.on("zoom", (() => this._update(!0))), this.on("terrain", (() => {
						this.painter.terrainFacilitator.dirty = !0, this._update(!0);
					})), this.once("idle", (() => {
						this._idleTriggered = !0;
					})), "undefined" != typeof window && (this._ownerWindow.addEventListener("online", this._onWindowOnline, !1), this._setupResizeObserver()), this.handlers = new Hr(this, o$1), this._hash = o$1.hash && new Ho("string" == typeof o$1.hash && o$1.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({
						center: o$1.center,
						elevation: o$1.elevation,
						zoom: o$1.zoom,
						bearing: o$1.bearing,
						pitch: o$1.pitch,
						roll: o$1.roll
					}), o$1.bounds && (this.resize(), this.fitBounds(o$1.bounds, t.e({}, o$1.fitBoundsOptions, { duration: 0 }))));
					const l$1 = "string" == typeof o$1.style || !("globe" === (null === (a$1 = null === (i$1 = o$1.style) || void 0 === i$1 ? void 0 : i$1.projection) || void 0 === a$1 ? void 0 : a$1.type));
					this.resize(null, l$1), this._localIdeographFontFamily = o$1.localIdeographFontFamily, this._validateStyle = o$1.validateStyle, o$1.style && this.setStyle(o$1.style, { localIdeographFontFamily: o$1.localIdeographFontFamily }), o$1.attributionControl && this.addControl(new Yr("boolean" == typeof o$1.attributionControl ? void 0 : o$1.attributionControl)), o$1.maplibreLogo && this.addControl(new Qr(), o$1.logoPosition), this.on("style.load", (() => {
						if (l$1 || this._resizeTransform(), this.transform.unmodified) {
							const e$2 = t.U(this.style.stylesheet, [
								"center",
								"zoom",
								"bearing",
								"pitch",
								"roll"
							]);
							this.jumpTo(e$2);
						}
					})), this.on("data", ((e$2) => {
						this._update("style" === e$2.dataType), this.fire(new t.l(`${e$2.dataType}data`, e$2));
					})), this.on("dataloading", ((e$2) => {
						this.fire(new t.l(`${e$2.dataType}dataloading`, e$2));
					})), this.on("dataabort", ((e$2) => {
						this.fire(new t.l("sourcedataabort", e$2));
					}));
				}
				_getMapId() {
					return this._mapId;
				}
				setGlobalStateProperty(e$1, t$1) {
					return this.style.setGlobalStateProperty(e$1, t$1), this._update(!0);
				}
				getGlobalState() {
					return this.style.getGlobalState();
				}
				addControl(e$1, i$1) {
					if (void 0 === i$1 && (i$1 = e$1.getDefaultPosition ? e$1.getDefaultPosition() : "top-right"), !e$1 || !e$1.onAdd) return this.fire(new t.k(/* @__PURE__ */ new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
					const a$1 = e$1.onAdd(this);
					this._controls.push(e$1);
					const o$1 = this._controlPositions[i$1];
					return -1 !== i$1.indexOf("bottom") ? o$1.insertBefore(a$1, o$1.firstChild) : o$1.appendChild(a$1), this;
				}
				removeControl(e$1) {
					if (!e$1 || !e$1.onRemove) return this.fire(new t.k(/* @__PURE__ */ new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
					const i$1 = this._controls.indexOf(e$1);
					return i$1 > -1 && this._controls.splice(i$1, 1), e$1.onRemove(this), this;
				}
				hasControl(e$1) {
					return this._controls.indexOf(e$1) > -1;
				}
				coveringTiles(e$1) {
					return Ie(this.transform, e$1);
				}
				calculateCameraOptionsFromTo(e$1, t$1, i$1, a$1) {
					return null == a$1 && this.terrain && (a$1 = this.terrain.getElevationForLngLat(i$1, this.transform)), super.calculateCameraOptionsFromTo(e$1, t$1, i$1, a$1);
				}
				resize(e$1, i$1 = !0) {
					if (null !== this._lostContextStyle.style) return this;
					this._resizeInternal(i$1);
					const a$1 = !this._moving;
					return a$1 && (this.stop(), this.fire(new t.l("movestart", e$1)).fire(new t.l("move", e$1))), this.fire(new t.l("resize", e$1)), a$1 && this.fire(new t.l("moveend", e$1)), this;
				}
				_resizeInternal(e$1 = !0) {
					const [t$1, i$1] = this._containerDimensions(), a$1 = this._getClampedPixelRatio(t$1, i$1);
					if (this._resizeCanvas(t$1, i$1, a$1), this.painter.resize(t$1, i$1, a$1), this.painter.overLimit()) {
						const e$2 = this.painter.context.gl;
						this._maxCanvasSize = [e$2.drawingBufferWidth, e$2.drawingBufferHeight];
						const a$2 = this._getClampedPixelRatio(t$1, i$1);
						this._resizeCanvas(t$1, i$1, a$2), this.painter.resize(t$1, i$1, a$2);
					}
					this._resizeTransform(e$1);
				}
				_resizeTransform(e$1 = !0) {
					var t$1;
					const [i$1, a$1] = this._containerDimensions();
					this.transform.resize(i$1, a$1, e$1), null === (t$1 = this._requestedCameraState) || void 0 === t$1 || t$1.resize(i$1, a$1, e$1);
				}
				_getClampedPixelRatio(e$1, t$1) {
					const { 0: i$1, 1: a$1 } = this._maxCanvasSize, o$1 = this.getPixelRatio(), r$1 = e$1 * o$1, s$1 = t$1 * o$1;
					return Math.min(r$1 > i$1 ? i$1 / r$1 : 1, s$1 > a$1 ? a$1 / s$1 : 1) * o$1;
				}
				getPixelRatio() {
					var e$1;
					return null !== (e$1 = this._overridePixelRatio) && void 0 !== e$1 ? e$1 : devicePixelRatio;
				}
				setPixelRatio(e$1) {
					this._overridePixelRatio = e$1, this.resize();
				}
				getBounds() {
					return this.transform.getBounds();
				}
				getMaxBounds() {
					return this.transform.getMaxBounds();
				}
				setMaxBounds(e$1) {
					return this.transform.setMaxBounds($.convert(e$1)), this._update();
				}
				setMinZoom(e$1) {
					if ((e$1 = null == e$1 ? -2 : e$1) >= -2 && e$1 <= this.transform.maxZoom) {
						const i$1 = this.transform.zoom, a$1 = this._getTransformForUpdate();
						return a$1.setMinZoom(e$1), this._applyUpdatedTransform(a$1), this._update(), i$1 !== this.transform.zoom && this.fire(new t.l("zoomstart")).fire(new t.l("zoom")).fire(new t.l("zoomend")).fire(new t.l("movestart")).fire(new t.l("move")).fire(new t.l("moveend")), this;
					}
					throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
				}
				getMinZoom() {
					return this.transform.minZoom;
				}
				setMaxZoom(e$1) {
					if ((e$1 = null == e$1 ? 22 : e$1) >= this.transform.minZoom) {
						const i$1 = this.transform.zoom, a$1 = this._getTransformForUpdate();
						return a$1.setMaxZoom(e$1), this._applyUpdatedTransform(a$1), this._update(), i$1 !== this.transform.zoom && this.fire(new t.l("zoomstart")).fire(new t.l("zoom")).fire(new t.l("zoomend")).fire(new t.l("movestart")).fire(new t.l("move")).fire(new t.l("moveend")), this;
					}
					throw new Error("maxZoom must be greater than the current minZoom");
				}
				getMaxZoom() {
					return this.transform.maxZoom;
				}
				setMinPitch(e$1) {
					if ((e$1 = null == e$1 ? 0 : e$1) < 0) throw new Error("minPitch must be greater than or equal to 0");
					if (e$1 >= 0 && e$1 <= this.transform.maxPitch) {
						const i$1 = this.transform.pitch, a$1 = this._getTransformForUpdate();
						return a$1.setMinPitch(e$1), this._applyUpdatedTransform(a$1), this._update(), i$1 !== this.transform.pitch && this.fire(new t.l("pitchstart")).fire(new t.l("pitch")).fire(new t.l("pitchend")).fire(new t.l("movestart")).fire(new t.l("move")).fire(new t.l("moveend")), this;
					}
					throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
				}
				getMinPitch() {
					return this.transform.minPitch;
				}
				setMaxPitch(e$1) {
					if ((e$1 = null == e$1 ? 60 : e$1) > 180) throw new Error("maxPitch must be less than or equal to 180");
					if (e$1 >= this.transform.minPitch) {
						const i$1 = this.transform.pitch, a$1 = this._getTransformForUpdate();
						return a$1.setMaxPitch(e$1), this._applyUpdatedTransform(a$1), this._update(), i$1 !== this.transform.pitch && this.fire(new t.l("pitchstart")).fire(new t.l("pitch")).fire(new t.l("pitchend")).fire(new t.l("movestart")).fire(new t.l("move")).fire(new t.l("moveend")), this;
					}
					throw new Error("maxPitch must be greater than the current minPitch");
				}
				getMaxPitch() {
					return this.transform.maxPitch;
				}
				getRenderWorldCopies() {
					return this.transform.renderWorldCopies;
				}
				setRenderWorldCopies(e$1) {
					return this.transform.setRenderWorldCopies(e$1), this._update();
				}
				setTransformConstrain(e$1) {
					return this.transform.setConstrainOverride(e$1), this._update();
				}
				project(e$1) {
					return this.transform.locationToScreenPoint(t.V.convert(e$1), this.style && this.terrain);
				}
				unproject(e$1) {
					return this.transform.screenPointToLocation(t.P.convert(e$1), this.terrain);
				}
				isMoving() {
					var e$1;
					return this._moving || (null === (e$1 = this.handlers) || void 0 === e$1 ? void 0 : e$1.isMoving());
				}
				isZooming() {
					var e$1;
					return this._zooming || (null === (e$1 = this.handlers) || void 0 === e$1 ? void 0 : e$1.isZooming());
				}
				isRotating() {
					var e$1;
					return this._rotating || (null === (e$1 = this.handlers) || void 0 === e$1 ? void 0 : e$1.isRotating());
				}
				_createDelegatedListener(e$1, t$1, i$1) {
					if ("mouseenter" === e$1 || "mouseover" === e$1) {
						let a$1 = !1;
						const o$1 = (o$2) => {
							const r$1 = t$1.filter(((e$2) => this.getLayer(e$2))), s$1 = 0 !== r$1.length ? this.queryRenderedFeatures(o$2.point, { layers: r$1 }) : [];
							s$1.length ? a$1 || (a$1 = !0, i$1.call(this, new or(e$1, this, o$2.originalEvent, { features: s$1 }))) : a$1 = !1;
						};
						return {
							layers: t$1,
							listener: i$1,
							delegates: {
								mousemove: o$1,
								mouseout: () => {
									a$1 = !1;
								}
							}
						};
					}
					if ("mouseleave" === e$1 || "mouseout" === e$1) {
						let a$1 = !1;
						const o$1 = (o$2) => {
							const r$2 = t$1.filter(((e$2) => this.getLayer(e$2)));
							(0 !== r$2.length ? this.queryRenderedFeatures(o$2.point, { layers: r$2 }) : []).length ? a$1 = !0 : a$1 && (a$1 = !1, i$1.call(this, new or(e$1, this, o$2.originalEvent)));
						}, r$1 = (t$2) => {
							a$1 && (a$1 = !1, i$1.call(this, new or(e$1, this, t$2.originalEvent)));
						};
						return {
							layers: t$1,
							listener: i$1,
							delegates: {
								mousemove: o$1,
								mouseout: r$1
							}
						};
					}
					{
						const a$1 = (e$2) => {
							const a$2 = t$1.filter(((e$3) => this.getLayer(e$3))), o$1 = 0 !== a$2.length ? this.queryRenderedFeatures(e$2.point, { layers: a$2 }) : [];
							o$1.length && (e$2.features = o$1, i$1.call(this, e$2), delete e$2.features);
						};
						return {
							layers: t$1,
							listener: i$1,
							delegates: { [e$1]: a$1 }
						};
					}
				}
				_saveDelegatedListener(e$1, t$1) {
					this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e$1] = this._delegatedListeners[e$1] || [], this._delegatedListeners[e$1].push(t$1);
				}
				_removeDelegatedListener(e$1, t$1, i$1) {
					if (!this._delegatedListeners || !this._delegatedListeners[e$1]) return;
					const a$1 = this._delegatedListeners[e$1];
					for (let e$2 = 0; e$2 < a$1.length; e$2++) {
						const o$1 = a$1[e$2];
						if (o$1.listener === i$1 && o$1.layers.length === t$1.length && o$1.layers.every(((e$3) => t$1.includes(e$3)))) {
							for (const e$3 in o$1.delegates) this.off(e$3, o$1.delegates[e$3]);
							a$1.splice(e$2, 1);
							return;
						}
					}
				}
				on(e$1, t$1, i$1) {
					if (void 0 === i$1) return super.on(e$1, t$1);
					const a$1 = "string" == typeof t$1 ? [t$1] : t$1, o$1 = this._createDelegatedListener(e$1, a$1, i$1);
					this._saveDelegatedListener(e$1, o$1);
					for (const e$2 in o$1.delegates) this.on(e$2, o$1.delegates[e$2]);
					return { unsubscribe: () => {
						this._removeDelegatedListener(e$1, a$1, i$1);
					} };
				}
				once(e$1, t$1, i$1) {
					if (void 0 === i$1) return super.once(e$1, t$1);
					const a$1 = "string" == typeof t$1 ? [t$1] : t$1, o$1 = this._createDelegatedListener(e$1, a$1, i$1);
					for (const t$2 in o$1.delegates) {
						const r$1 = o$1.delegates[t$2];
						o$1.delegates[t$2] = (...t$3) => {
							this._removeDelegatedListener(e$1, a$1, i$1), r$1(...t$3);
						};
					}
					this._saveDelegatedListener(e$1, o$1);
					for (const e$2 in o$1.delegates) this.once(e$2, o$1.delegates[e$2]);
					return this;
				}
				off(e$1, t$1, i$1) {
					return void 0 === i$1 ? super.off(e$1, t$1) : (this._removeDelegatedListener(e$1, "string" == typeof t$1 ? [t$1] : t$1, i$1), this);
				}
				queryRenderedFeatures(e$1, i$1) {
					if (!this.style) return [];
					let a$1;
					const o$1 = e$1 instanceof t.P || Array.isArray(e$1), r$1 = o$1 ? e$1 : [[0, 0], [this.transform.width, this.transform.height]];
					if (i$1 = i$1 || (o$1 ? {} : e$1) || {}, r$1 instanceof t.P || "number" == typeof r$1[0]) a$1 = [t.P.convert(r$1)];
					else {
						const e$2 = t.P.convert(r$1[0]), i$2 = t.P.convert(r$1[1]);
						a$1 = [
							e$2,
							new t.P(i$2.x, e$2.y),
							i$2,
							new t.P(e$2.x, i$2.y),
							e$2
						];
					}
					return this.style.queryRenderedFeatures(a$1, i$1, this.transform);
				}
				querySourceFeatures(e$1, t$1) {
					return this.style.querySourceFeatures(e$1, t$1);
				}
				setStyle(e$1, i$1) {
					return !1 !== (i$1 = t.e({}, {
						localIdeographFontFamily: this._localIdeographFontFamily,
						validate: this._validateStyle
					}, i$1)).diff && i$1.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e$1 ? (this._diffStyle(e$1, i$1), this) : (this._localIdeographFontFamily = i$1.localIdeographFontFamily, this._updateStyle(e$1, i$1));
				}
				setTransformRequest(e$1) {
					return this._requestManager.setTransformRequest(e$1), this;
				}
				_getUIString(e$1) {
					const t$1 = this._locale[e$1];
					if (null == t$1) throw new Error(`Missing UI string '${e$1}'`);
					return t$1;
				}
				_updateStyle(e$1, t$1) {
					var i$1, a$1;
					if (t$1.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(e$1, t$1)));
					const o$1 = this.style && t$1.transformStyle ? this.style.serialize() : void 0;
					return this.style && (this.style.setEventedParent(null), this.style._remove(!e$1)), e$1 ? (this.style = new ki(this, t$1 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof e$1 ? this.style.loadURL(e$1, t$1, o$1) : this.style.loadJSON(e$1, t$1, o$1), this) : (null === (a$1 = null === (i$1 = this.style) || void 0 === i$1 ? void 0 : i$1.projection) || void 0 === a$1 || a$1.destroy(), delete this.style, this);
				}
				_lazyInitEmptyStyle() {
					this.style || (this.style = new ki(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
				}
				_diffStyle(e$1, i$1) {
					if ("string" == typeof e$1) {
						const a$1 = this._requestManager.transformRequest(e$1, "Style");
						t.j(a$1, new AbortController()).then(((e$2) => {
							this._updateDiff(e$2.data, i$1);
						})).catch(((e$2) => {
							e$2 && this.fire(new t.k(e$2));
						}));
					} else "object" == typeof e$1 && this._updateDiff(e$1, i$1);
				}
				_updateDiff(e$1, i$1) {
					try {
						this.style.setState(e$1, i$1) && this._update(!0);
					} catch (a$1) {
						t.w(`Unable to perform style diff: ${a$1.message || a$1.error || a$1}.  Rebuilding the style from scratch.`), this._updateStyle(e$1, i$1);
					}
				}
				getStyle() {
					if (this.style) return this.style.serialize();
				}
				_getStyleAndImages() {
					return this.style ? {
						style: this.style.serialize(),
						images: this.style.imageManager.cloneImages()
					} : {
						style: null,
						images: {}
					};
				}
				isStyleLoaded() {
					return this.style ? this.style.loaded() : t.w("There is no style added to the map.");
				}
				addSource(e$1, t$1) {
					return this._lazyInitEmptyStyle(), this.style.addSource(e$1, t$1), this._update(!0);
				}
				isSourceLoaded(e$1) {
					const i$1 = this.style && this.style.tileManagers[e$1];
					if (void 0 !== i$1) return i$1.loaded();
					this.fire(new t.k(/* @__PURE__ */ new Error(`There is no tile manager with ID '${e$1}'`)));
				}
				setTerrain(e$1) {
					if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), e$1) {
						const i$1 = this.style.tileManagers[e$1.source];
						if (!i$1) throw new Error(`cannot load terrain, because there exists no source with ID: ${e$1.source}`);
						null === this.terrain && i$1.reload();
						for (const i$2 in this.style._layers) {
							const a$1 = this.style._layers[i$2];
							"hillshade" === a$1.type && a$1.source === e$1.source && t.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), "color-relief" === a$1.type && a$1.source === e$1.source && t.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
						}
						this.terrain = new is(this.painter, i$1, e$1), this.painter.renderToTexture = new rs(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (t$1) => {
							var i$2;
							"style" === t$1.dataType ? this.terrain.tileManager.freeRtt() : "source" === t$1.dataType && t$1.tile && (t$1.sourceId !== e$1.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), "image" === (null === (i$2 = t$1.source) || void 0 === i$2 ? void 0 : i$2.type) ? this.terrain.tileManager.freeRtt() : this.terrain.tileManager.freeRtt(t$1.tile.tileID));
						}, this.style.on("data", this._terrainDataCallback);
					} else this.terrain && this.terrain.tileManager.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
					return this.fire(new t.l("terrain", { terrain: e$1 })), this;
				}
				getTerrain() {
					var e$1, t$1;
					return null !== (t$1 = null === (e$1 = this.terrain) || void 0 === e$1 ? void 0 : e$1.options) && void 0 !== t$1 ? t$1 : null;
				}
				areTilesLoaded() {
					const e$1 = this.style && this.style.tileManagers;
					for (const t$1 of Object.values(e$1)) if (!t$1.areTilesLoaded()) return !1;
					return !0;
				}
				removeSource(e$1) {
					return this.style.removeSource(e$1), this._update(!0);
				}
				getSource(e$1) {
					return this.style.getSource(e$1);
				}
				setSourceTileLodParams(e$1, t$1, i$1) {
					if (i$1) {
						const a$1 = this.getSource(i$1);
						if (!a$1) throw new Error(`There is no source with ID "${i$1}", cannot set LOD parameters`);
						a$1.calculateTileZoom = Te(Math.max(1, e$1), Math.max(1, t$1));
					} else for (const i$2 in this.style.tileManagers) this.style.tileManagers[i$2].getSource().calculateTileZoom = Te(Math.max(1, e$1), Math.max(1, t$1));
					return this._update(!0), this;
				}
				refreshTiles(e$1, i$1) {
					const a$1 = this.style.tileManagers[e$1];
					if (!a$1) throw new Error(`There is no tile manager with ID "${e$1}", cannot refresh tile`);
					void 0 === i$1 ? a$1.reload(!0) : a$1.refreshTiles(i$1.map(((e$2) => new t.ac(e$2.z, e$2.x, e$2.y))));
				}
				addImage(e$1, i$1, a$1 = {}) {
					const { pixelRatio: o$1 = 1, sdf: r$1 = !1, stretchX: s$1, stretchY: l$1, content: c$1, textFitWidth: h$1, textFitHeight: u$1 } = a$1;
					if (this._lazyInitEmptyStyle(), !(i$1 instanceof HTMLImageElement || t.b(i$1))) {
						if (void 0 === i$1.width || void 0 === i$1.height) return this.fire(new t.k(/* @__PURE__ */ new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
						{
							const { width: a$2, height: n$1, data: d$1 } = i$1, _$1 = i$1;
							return this.style.addImage(e$1, {
								data: new t.R({
									width: a$2,
									height: n$1
								}, new Uint8Array(d$1)),
								pixelRatio: o$1,
								stretchX: s$1,
								stretchY: l$1,
								content: c$1,
								textFitWidth: h$1,
								textFitHeight: u$1,
								sdf: r$1,
								version: 0,
								userImage: _$1
							}), _$1.onAdd && _$1.onAdd(this, e$1), this;
						}
					}
					{
						const { width: a$2, height: d$1, data: _$1 } = n.getImageData(i$1);
						this.style.addImage(e$1, {
							data: new t.R({
								width: a$2,
								height: d$1
							}, _$1),
							pixelRatio: o$1,
							stretchX: s$1,
							stretchY: l$1,
							content: c$1,
							textFitWidth: h$1,
							textFitHeight: u$1,
							sdf: r$1,
							version: 0
						});
					}
				}
				updateImage(e$1, i$1) {
					const a$1 = this.style.getImage(e$1);
					if (!a$1) return this.fire(new t.k(/* @__PURE__ */ new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
					const { width: r$1, height: s$1, data: l$1 } = i$1 instanceof HTMLImageElement || t.b(i$1) ? n.getImageData(i$1) : i$1;
					if (void 0 === r$1 || void 0 === s$1) return this.fire(new t.k(/* @__PURE__ */ new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
					if (r$1 !== a$1.data.width || s$1 !== a$1.data.height) return this.fire(new t.k(/* @__PURE__ */ new Error("The width and height of the updated image must be that same as the previous version of the image")));
					const c$1 = !(i$1 instanceof HTMLImageElement || t.b(i$1));
					return a$1.data.replace(l$1, c$1), this.style.updateImage(e$1, a$1), this;
				}
				getImage(e$1) {
					return this.style.getImage(e$1);
				}
				hasImage(e$1) {
					return e$1 ? !!this.style.getImage(e$1) : (this.fire(new t.k(/* @__PURE__ */ new Error("Missing required image id"))), !1);
				}
				removeImage(e$1) {
					this.style.removeImage(e$1);
				}
				loadImage(e$1) {
					return g.getImage(this._requestManager.transformRequest(e$1, "Image"), new AbortController());
				}
				listImages() {
					return this.style.listImages();
				}
				addLayer(e$1, t$1) {
					return this._lazyInitEmptyStyle(), this.style.addLayer(e$1, t$1), this._update(!0);
				}
				moveLayer(e$1, t$1) {
					return this.style.moveLayer(e$1, t$1), this._update(!0);
				}
				removeLayer(e$1) {
					return this.style.removeLayer(e$1), this._update(!0);
				}
				getLayer(e$1) {
					return this.style.getLayer(e$1);
				}
				getLayersOrder() {
					return this.style.getLayersOrder();
				}
				setLayerZoomRange(e$1, t$1, i$1) {
					return this.style.setLayerZoomRange(e$1, t$1, i$1), this._update(!0);
				}
				setFilter(e$1, t$1, i$1 = {}) {
					return this.style.setFilter(e$1, t$1, i$1), this._update(!0);
				}
				getFilter(e$1) {
					return this.style.getFilter(e$1);
				}
				setPaintProperty(e$1, t$1, i$1, a$1 = {}) {
					return this.style.setPaintProperty(e$1, t$1, i$1, a$1), this._update(!0);
				}
				getPaintProperty(e$1, t$1) {
					return this.style.getPaintProperty(e$1, t$1);
				}
				setLayoutProperty(e$1, t$1, i$1, a$1 = {}) {
					return this.style.setLayoutProperty(e$1, t$1, i$1, a$1), this._update(!0);
				}
				getLayoutProperty(e$1, t$1) {
					return this.style.getLayoutProperty(e$1, t$1);
				}
				setGlyphs(e$1, t$1 = {}) {
					return this._lazyInitEmptyStyle(), this.style.setGlyphs(e$1, t$1), this._update(!0);
				}
				getGlyphs() {
					return this.style.getGlyphsUrl();
				}
				addSprite(e$1, t$1, i$1 = {}) {
					return this._lazyInitEmptyStyle(), this.style.addSprite(e$1, t$1, i$1, ((e$2) => {
						e$2 || this._update(!0);
					})), this;
				}
				removeSprite(e$1) {
					return this._lazyInitEmptyStyle(), this.style.removeSprite(e$1), this._update(!0);
				}
				getSprite() {
					return this.style.getSprite();
				}
				setSprite(e$1, t$1 = {}) {
					return this._lazyInitEmptyStyle(), this.style.setSprite(e$1, t$1, ((e$2) => {
						e$2 || this._update(!0);
					})), this;
				}
				setLight(e$1, t$1 = {}) {
					return this._lazyInitEmptyStyle(), this.style.setLight(e$1, t$1), this._update(!0);
				}
				getLight() {
					return this.style.getLight();
				}
				setSky(e$1, t$1 = {}) {
					return this._lazyInitEmptyStyle(), this.style.setSky(e$1, t$1), this._update(!0);
				}
				getSky() {
					return this.style.getSky();
				}
				setFeatureState(e$1, t$1) {
					return this.style.setFeatureState(e$1, t$1), this._update();
				}
				removeFeatureState(e$1, t$1) {
					return this.style.removeFeatureState(e$1, t$1), this._update();
				}
				getFeatureState(e$1) {
					return this.style.getFeatureState(e$1);
				}
				getContainer() {
					return this._container;
				}
				getCanvasContainer() {
					return this._canvasContainer;
				}
				getCanvas() {
					return this._canvas;
				}
				_containerDimensions() {
					let e$1 = 0, t$1 = 0;
					return this._container && (e$1 = this._container.clientWidth || 400, t$1 = this._container.clientHeight || 300), [e$1, t$1];
				}
				_setupResizeObserver() {
					var e$1;
					let t$1 = !1;
					const i$1 = $o(((e$2) => {
						this._trackResize && !this._removed && (this.resize(e$2), this.redraw());
					}), 50);
					this._resizeObserver = new (null !== (e$1 = this._ownerWindow.ResizeObserver) && void 0 !== e$1 ? e$1 : ResizeObserver)(((e$2) => {
						t$1 ? i$1(e$2) : t$1 = !0;
					})), this._resizeObserver.observe(this._container);
				}
				_resolveContainer(e$1) {
					if ("string" == typeof e$1) {
						const t$1 = document.getElementById(e$1);
						if (!t$1) throw new Error(`Container '${e$1}' not found.`);
						return t$1;
					}
					if (e$1 instanceof HTMLElement) return e$1;
					if (e$1 && "object" == typeof e$1 && 1 === e$1.nodeType) return e$1;
					throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
				}
				_setupContainer() {
					const e$1 = this._container;
					e$1.classList.add("maplibregl-map");
					const t$1 = this._canvasContainer = h.create("div", "maplibregl-canvas-container", e$1);
					this._interactive && t$1.classList.add("maplibregl-interactive"), this._canvas = h.create("canvas", "maplibregl-canvas", t$1), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
					const i$1 = this._containerDimensions(), a$1 = this._getClampedPixelRatio(i$1[0], i$1[1]);
					this._resizeCanvas(i$1[0], i$1[1], a$1);
					const o$1 = this._controlContainer = h.create("div", "maplibregl-control-container", e$1), r$1 = this._controlPositions = {};
					[
						"top-left",
						"top-right",
						"bottom-left",
						"bottom-right"
					].forEach(((e$2) => {
						r$1[e$2] = h.create("div", `maplibregl-ctrl-${e$2} `, o$1);
					})), this._container.addEventListener("scroll", this._onMapScroll, !1);
				}
				_resizeCanvas(e$1, t$1, i$1) {
					this._canvas.width = Math.floor(i$1 * e$1), this._canvas.height = Math.floor(i$1 * t$1), this._canvas.style.width = `${e$1}px`, this._canvas.style.height = `${t$1}px`;
				}
				_setupPainter() {
					const e$1 = Object.assign(Object.assign({}, this._canvasContextAttributes), {
						alpha: !0,
						depth: !0,
						stencil: !0,
						premultipliedAlpha: !0
					});
					let t$1 = null;
					this._canvas.addEventListener("webglcontextcreationerror", ((i$2) => {
						t$1 = { requestedAttributes: e$1 }, i$2 && (t$1.statusMessage = i$2.statusMessage, t$1.type = i$2.type);
					}), { once: !0 });
					let i$1 = null;
					if (i$1 = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, e$1) : this._canvas.getContext("webgl2", e$1) || this._canvas.getContext("webgl", e$1), !i$1) {
						const e$2 = "Failed to initialize WebGL";
						throw t$1 ? (t$1.message = e$2, new Error(JSON.stringify(t$1))) : new Error(e$2);
					}
					this.painter = new Wo(i$1, this.transform), u.testSupport(i$1);
				}
				migrateProjection(e$1, i$1) {
					super.migrateProjection(e$1, i$1), this.painter.transform = e$1, this.fire(new t.l("projectiontransition", { newProjection: this.style.projection.name }));
				}
				loaded() {
					return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
				}
				_update(e$1) {
					return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || e$1, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
				}
				_requestRenderFrame(e$1) {
					return this._update(), this._renderTaskQueue.add(e$1);
				}
				_cancelRenderFrame(e$1) {
					this._renderTaskQueue.remove(e$1);
				}
				_render(e$1) {
					var i$1, a$1, o$1, r$1, s$1;
					const n$1 = this._idleTriggered ? this._fadeDuration : 0, l$1 = (null === (i$1 = this.style.projection) || void 0 === i$1 ? void 0 : i$1.transitionState) > 0;
					if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e$1), this._removed) return;
					let h$1 = !1;
					if (this.style && this._styleDirty) {
						this._styleDirty = !1;
						const e$2 = this.transform.zoom, i$2 = c();
						this.style.zoomHistory.update(e$2, i$2);
						const a$2 = new t.H(e$2, {
							now: i$2,
							fadeDuration: n$1,
							zoomHistory: this.style.zoomHistory,
							transition: this.style.getTransition()
						}), o$2 = a$2.crossFadingFactor();
						1 === o$2 && o$2 === this._crossFadingFactor || (h$1 = !0, this._crossFadingFactor = o$2), this.style.update(a$2);
					}
					const u$1 = (null === (a$1 = this.style.projection) || void 0 === a$1 ? void 0 : a$1.transitionState) > 0 !== l$1;
					null === (o$1 = this.style.projection) || void 0 === o$1 || o$1.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState(null === (r$1 = this.style.projection) || void 0 === r$1 ? void 0 : r$1.transitionState, null === (s$1 = this.style.projection) || void 0 === s$1 ? void 0 : s$1.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || u$1) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.tileManager.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, n$1, this._crossSourceCollisions, u$1), this.painter.render(this.style, {
						showTileBoundaries: this.showTileBoundaries,
						showOverdrawInspector: this._showOverdrawInspector,
						rotating: this.isRotating(),
						zooming: this.isZooming(),
						moving: this.isMoving(),
						fadeDuration: n$1,
						showPadding: this.showPadding
					}), this.fire(new t.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, t.cH.mark(t.cI.load), this.fire(new t.l("load"))), this.style && (this.style.hasTransitions() || h$1) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
					const d$1 = this._sourcesDirty || this._styleDirty || this._placementDirty;
					return d$1 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t.l("idle")), !this._loaded || this._fullyLoaded || d$1 || (this._fullyLoaded = !0, t.cH.mark(t.cI.fullLoad)), this;
				}
				redraw() {
					return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
				}
				remove() {
					var e$1;
					this._hash && this._hash.remove();
					for (const e$2 of this._controls) e$2.onRemove(this);
					this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), "undefined" != typeof window && this._ownerWindow.removeEventListener("online", this._onWindowOnline, !1), g.removeThrottleControl(this._imageQueueHandle), null === (e$1 = this._resizeObserver) || void 0 === e$1 || e$1.disconnect();
					const i$1 = this.painter.context.gl.getExtension("WEBGL_lose_context");
					null != i$1 && i$1.loseContext && i$1.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), h.remove(this._canvasContainer), h.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), t.cH.clearMetrics(), this._removed = !0, this.fire(new t.l("remove"));
				}
				triggerRepaint() {
					this.style && !this._frameRequest && (this._frameRequest = new AbortController(), n.frame(this._frameRequest, ((e$1) => {
						t.cH.frame(e$1), this._frameRequest = null;
						try {
							this._render(e$1);
						} catch (e$2) {
							if (!t.Z(e$2) && !function(e$3) {
								return e$3.message === ro;
							}(e$2)) throw e$2;
						}
					}), (() => {}), this._ownerWindow));
				}
				get showTileBoundaries() {
					return !!this._showTileBoundaries;
				}
				set showTileBoundaries(e$1) {
					this._showTileBoundaries !== e$1 && (this._showTileBoundaries = e$1, this._update());
				}
				get showPadding() {
					return !!this._showPadding;
				}
				set showPadding(e$1) {
					this._showPadding !== e$1 && (this._showPadding = e$1, this._update());
				}
				get showCollisionBoxes() {
					return !!this._showCollisionBoxes;
				}
				set showCollisionBoxes(e$1) {
					this._showCollisionBoxes !== e$1 && (this._showCollisionBoxes = e$1, e$1 ? this.style._generateCollisionBoxes() : this._update());
				}
				get showOverdrawInspector() {
					return !!this._showOverdrawInspector;
				}
				set showOverdrawInspector(e$1) {
					this._showOverdrawInspector !== e$1 && (this._showOverdrawInspector = e$1, this._update());
				}
				get repaint() {
					return !!this._repaint;
				}
				set repaint(e$1) {
					this._repaint !== e$1 && (this._repaint = e$1, this.triggerRepaint());
				}
				get vertices() {
					return !!this._vertices;
				}
				set vertices(e$1) {
					this._vertices = e$1, this._update();
				}
				get version() {
					return ns;
				}
				getCameraTargetElevation() {
					return this.transform.elevation;
				}
				getProjection() {
					return this.style.getProjection();
				}
				setProjection(e$1) {
					return this._lazyInitEmptyStyle(), this.style.setProjection(e$1), this._update(!0);
				}
			}, e.MapMouseEvent = or, e.MapTouchEvent = rr, e.MapWheelEvent = sr, e.Marker = ms, e.NavigationControl = class {
				constructor(e$1) {
					this._updateZoomButtons = () => {
						const e$2 = this._map.getZoom(), t$1 = e$2 === this._map.getMaxZoom(), i$1 = e$2 === this._map.getMinZoom();
						this._zoomInButton.disabled = t$1, this._zoomOutButton.disabled = i$1, this._zoomInButton.setAttribute("aria-disabled", t$1.toString()), this._zoomOutButton.setAttribute("aria-disabled", i$1.toString());
					}, this._rotateCompassArrow = () => {
						this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), .5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), .5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
					}, this._setButtonTitle = (e$2, t$1) => {
						const i$1 = this._map._getUIString(`NavigationControl.${t$1}`);
						e$2.title = i$1, e$2.setAttribute("aria-label", i$1);
					}, this.options = t.e({}, cs, e$1), this._container = h.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", ((e$2) => e$2.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", ((e$2) => this._map.zoomIn({}, { originalEvent: e$2 }))), h.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", ((e$2) => this._map.zoomOut({}, { originalEvent: e$2 }))), h.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", ((e$2) => {
						this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e$2 }) : this._map.resetNorth({}, { originalEvent: e$2 });
					})), this._compassIcon = h.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
				}
				onAdd(e$1) {
					return this._map = e$1, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new hs(this._map, this._compass, this.options.visualizePitch)), this._container;
				}
				onRemove() {
					h.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
				}
				_createButton(e$1, t$1) {
					const i$1 = h.create("button", e$1, this._container);
					return i$1.type = "button", i$1.addEventListener("click", t$1), i$1;
				}
			}, e.Popup = class extends t.E {
				constructor(e$1) {
					super(), this._updateOpacity = () => {
						void 0 !== this.options.locationOccludedOpacity && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "");
					}, this.remove = () => (this._content && h.remove(this._content), this._container && (h.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new t.l("close"))), this), this._onMouseUp = (e$2) => {
						this._update(e$2.point);
					}, this._onMouseMove = (e$2) => {
						this._update(e$2.point);
					}, this._onDrag = (e$2) => {
						this._update(e$2.point);
					}, this._update = (e$2) => {
						if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
						if (!this._container) {
							if (this._container = h.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = h.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const e$3 of this.options.className.split(" ")) this._container.classList.add(e$3);
							this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
						}
						if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = ds(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e$2) return;
						const t$1 = this._flatPos = this._pos = this._trackPointer && e$2 ? e$2 : this._map.project(this._lngLat);
						this._map.terrain && (this._flatPos = this._trackPointer && e$2 ? e$2 : this._map.transform.locationToScreenPoint(this._lngLat));
						let i$1 = this.options.anchor;
						const a$1 = Ps(this.options.offset);
						if (!i$1) {
							const e$3 = this._container.offsetWidth, o$2 = this._container.offsetHeight, r$1 = function(e$4) {
								var t$2, i$2, a$2, o$3;
								return e$4 ? {
									top: null !== (t$2 = e$4.top) && void 0 !== t$2 ? t$2 : 0,
									right: null !== (i$2 = e$4.right) && void 0 !== i$2 ? i$2 : 0,
									bottom: null !== (a$2 = e$4.bottom) && void 0 !== a$2 ? a$2 : 0,
									left: null !== (o$3 = e$4.left) && void 0 !== o$3 ? o$3 : 0
								} : {
									top: 0,
									right: 0,
									bottom: 0,
									left: 0
								};
							}(this.options.padding);
							let s$1;
							s$1 = t$1.y + a$1.bottom.y < o$2 + r$1.top ? ["top"] : t$1.y > this._map.transform.height - o$2 - r$1.bottom ? ["bottom"] : [], t$1.x < e$3 / 2 + r$1.left ? s$1.push("left") : t$1.x > this._map.transform.width - e$3 / 2 - r$1.right && s$1.push("right"), i$1 = 0 === s$1.length ? "bottom" : s$1.join("-");
						}
						let o$1 = t$1.add(a$1[i$1]);
						this.options.subpixelPositioning || (o$1 = o$1.round()), h.setTransform(this._container, `${_s[i$1]} translate(${o$1.x}px,${o$1.y}px)`), ps(this._container, i$1, "popup"), this._updateOpacity();
					}, this._onClose = () => {
						this.remove();
					}, this.options = t.e(Object.create(ws), e$1);
				}
				addTo(e$1) {
					return this._map && this.remove(), this._map = e$1, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new t.l("open")), this;
				}
				isOpen() {
					return !!this._map;
				}
				getLngLat() {
					return this._lngLat;
				}
				setLngLat(e$1) {
					return this._lngLat = t.V.convert(e$1), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
				}
				trackPointer() {
					return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
				}
				getElement() {
					return this._container;
				}
				setText(e$1) {
					return this.setDOMContent(document.createTextNode(e$1));
				}
				setHTML(e$1) {
					const t$1 = document.createDocumentFragment(), i$1 = document.createElement("body");
					let a$1;
					for (i$1.innerHTML = e$1; a$1 = i$1.firstChild, a$1;) t$1.appendChild(a$1);
					return this.setDOMContent(t$1);
				}
				getMaxWidth() {
					var e$1;
					return null === (e$1 = this._container) || void 0 === e$1 ? void 0 : e$1.style.maxWidth;
				}
				setMaxWidth(e$1) {
					return this.options.maxWidth = e$1, this._update(), this;
				}
				setDOMContent(e$1) {
					if (this._content) for (; this._content.hasChildNodes();) this._content.firstChild && this._content.removeChild(this._content.firstChild);
					else this._content = h.create("div", "maplibregl-popup-content", this._container);
					return this._content.appendChild(e$1), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
				}
				addClassName(e$1) {
					return this._container && this._container.classList.add(e$1), this;
				}
				removeClassName(e$1) {
					return this._container && this._container.classList.remove(e$1), this;
				}
				setOffset(e$1) {
					return this.options.offset = e$1, this._update(), this;
				}
				toggleClassName(e$1) {
					if (this._container) return this._container.classList.toggle(e$1);
				}
				setSubpixelPositioning(e$1) {
					this.options.subpixelPositioning = e$1;
				}
				setPadding(e$1) {
					this.options.padding = e$1, this._update();
				}
				_createCloseButton() {
					this.options.closeButton && (this._closeButton = h.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
				}
				_focusFirstElement() {
					if (!this.options.focusAfterOpen || !this._container) return;
					const e$1 = this._container.querySelector(Ts);
					e$1 && e$1.focus();
				}
			}, e.RasterDEMTileSource = Y, e.RasterTileSource = K, e.ScaleControl = class {
				constructor(e$1) {
					this._onMove = () => {
						bs(this._map, this._container, this.options);
					}, this.setUnit = (e$2) => {
						this.options.unit = e$2, bs(this._map, this._container, this.options);
					}, this.options = Object.assign(Object.assign({}, xs), e$1);
				}
				getDefaultPosition() {
					return "bottom-left";
				}
				onAdd(e$1) {
					return this._map = e$1, this._container = h.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", e$1.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
				}
				onRemove() {
					h.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
				}
			}, e.ScrollZoomHandler = Br, e.Style = ki, e.TerrainControl = class {
				constructor(e$1) {
					this._toggleTerrain = () => {
						this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
					}, this._updateTerrainIcon = () => {
						this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
					}, this.options = e$1;
				}
				onAdd(e$1) {
					return this._map = e$1, this._container = h.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = h.create("button", "maplibregl-ctrl-terrain", this._container), h.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
				}
				onRemove() {
					h.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
				}
			}, e.TwoFingersTouchPitchHandler = Rr, e.TwoFingersTouchRotateHandler = Sr, e.TwoFingersTouchZoomHandler = Mr, e.TwoFingersTouchZoomRotateHandler = Gr, e.VectorTileSource = X, e.VideoSource = ie, e.addSourceType = (e$1, i$1) => t._(void 0, void 0, void 0, (function* () {
				if (re(e$1)) throw new Error(`A source type called "${e$1}" already exists.`);
				((e$2, t$1) => {
					oe[e$2] = t$1;
				})(e$1, i$1);
			})), e.clearPrewarmedResources = function() {
				const e$1 = B;
				e$1 && (e$1.isPreloaded() && 1 === e$1.numActive() ? (e$1.release(L), B = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
			}, e.createTileMesh = li, e.getMaxParallelImageRequests = function() {
				return t.c.MAX_PARALLEL_IMAGE_REQUESTS;
			}, e.getRTLTextPluginStatus = function() {
				return ce().getRTLTextPluginStatus();
			}, e.getVersion = function() {
				return Cs;
			}, e.getWorkerCount = function() {
				return k.workerCount;
			}, e.getWorkerUrl = function() {
				return t.c.WORKER_URL;
			}, e.importScriptInWorkers = function(e$1) {
				return Z().broadcast("IS", e$1);
			}, e.isTimeFrozen = function() {
				return l.isFrozen();
			}, e.now = c, e.prewarm = function() {
				j().acquire(L);
			}, e.restoreNow = function() {
				l.restoreNow();
			}, e.setMaxParallelImageRequests = function(e$1) {
				t.c.MAX_PARALLEL_IMAGE_REQUESTS = e$1;
			}, e.setNow = function(e$1) {
				l.setNow(e$1);
			}, e.setRTLTextPlugin = function(e$1, t$1) {
				return ce().setRTLTextPlugin(e$1, t$1);
			}, e.setWorkerCount = function(e$1) {
				k.workerCount = e$1;
			}, e.setWorkerUrl = function(e$1) {
				t.c.WORKER_URL = e$1;
			};
		}));
		return maplibregl;
	}));
}) });

//#endregion
export default require_maplibre_gl();

//# sourceMappingURL=maplibre-gl.js.map