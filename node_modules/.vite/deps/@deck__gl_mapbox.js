import { A as map_view_default, Ct as log_default, H as flatten, I as assert, T as deck_default, ct as lngLatToWorld, i as globe_view_default, lt as unitsPerMeter } from "./dist-dvxpIib5.js";
import "./webgl-device-BEeceotL.js";

//#region node_modules/@deck.gl/mapbox/dist/deck-utils.js
var MAPBOX_VIEW_ID = "mapbox";
var TILE_SIZE = 512;
var DEGREES_TO_RADIANS = Math.PI / 180;
function getDeckInstance({ map, gl, deck }) {
	if (map.__deck) return map.__deck;
	const customRender = deck?.props._customRender;
	const onLoad = deck?.props.onLoad;
	const deckProps = {
		...deck?.props,
		_customRender: () => {
			map.triggerRepaint();
			customRender?.("");
		}
	};
	deckProps.parameters = {
		...getDefaultParameters(map, true),
		...deckProps.parameters
	};
	deckProps.views || (deckProps.views = getDefaultView(map));
	let deckInstance;
	if (!deck || deck.props.gl === gl) {
		Object.assign(deckProps, {
			gl,
			width: null,
			height: null,
			touchAction: "unset",
			viewState: getViewState(map)
		});
		if (deck?.isInitialized) watchMapMove(deck, map);
		else deckProps.onLoad = () => {
			onLoad?.();
			watchMapMove(deckInstance, map);
		};
	}
	if (deck) {
		deckInstance = deck;
		deck.setProps(deckProps);
		deck.userData.isExternal = true;
	} else {
		deckInstance = new deck_default(deckProps);
		map.on("remove", () => {
			removeDeckInstance(map);
		});
	}
	deckInstance.userData.mapboxLayers = /* @__PURE__ */ new Set();
	map.__deck = deckInstance;
	map.on("render", () => {
		if (deckInstance.isInitialized) afterRender(deckInstance, map);
	});
	return deckInstance;
}
function watchMapMove(deck, map) {
	const _handleMapMove = () => {
		if (deck.isInitialized) onMapMove(deck, map);
		else map.off("move", _handleMapMove);
	};
	map.on("move", _handleMapMove);
}
function removeDeckInstance(map) {
	map.__deck?.finalize();
	map.__deck = null;
}
function getDefaultParameters(map, interleaved) {
	const result = interleaved ? {
		depthWriteEnabled: true,
		depthCompare: "less-equal",
		depthBias: 0,
		blend: true,
		blendColorSrcFactor: "src-alpha",
		blendColorDstFactor: "one-minus-src-alpha",
		blendAlphaSrcFactor: "one",
		blendAlphaDstFactor: "one-minus-src-alpha",
		blendColorOperation: "add",
		blendAlphaOperation: "add"
	} : {};
	if (getProjection(map) === "globe") result.cullMode = "back";
	return result;
}
function addLayer(deck, layer) {
	deck.userData.mapboxLayers.add(layer);
	updateLayers(deck);
}
function removeLayer(deck, layer) {
	deck.userData.mapboxLayers.delete(layer);
	updateLayers(deck);
}
function updateLayer(deck, layer) {
	updateLayers(deck);
}
function drawLayer(deck, map, layer, renderParameters) {
	let { currentViewport } = deck.userData;
	let clearStack = false;
	if (!currentViewport) {
		currentViewport = getViewport(deck, map, renderParameters);
		deck.userData.currentViewport = currentViewport;
		clearStack = true;
	}
	if (!deck.isInitialized) return;
	deck._drawLayers("mapbox-repaint", {
		viewports: [currentViewport],
		layerFilter: (params) => (!deck.props.layerFilter || deck.props.layerFilter(params)) && (layer.id === params.layer.id || params.layer.props.operation.includes("terrain")),
		clearStack,
		clearCanvas: false
	});
}
function drawLayerGroup(deck, map, group, renderParameters) {
	let { currentViewport } = deck.userData;
	let clearStack = false;
	if (!currentViewport) {
		currentViewport = getViewport(deck, map, renderParameters);
		deck.userData.currentViewport = currentViewport;
		clearStack = true;
	}
	if (!deck.isInitialized) return;
	deck._drawLayers("mapbox-repaint", {
		viewports: [currentViewport],
		layerFilter: (params) => {
			if (deck.props.layerFilter && !deck.props.layerFilter(params)) return false;
			const layer = params.layer;
			if (layer.props.beforeId === group.beforeId && layer.props.slot === group.slot) return true;
			return false;
		},
		clearStack,
		clearCanvas: false
	});
}
function getProjection(map) {
	const projection = map.getProjection?.();
	const type = projection?.type || projection?.name;
	if (type === "globe") return "globe";
	if (type && type !== "mercator") throw new Error("Unsupported projection");
	return "mercator";
}
function getDefaultView(map) {
	if (getProjection(map) === "globe") return new globe_view_default({ id: MAPBOX_VIEW_ID });
	return new map_view_default({ id: MAPBOX_VIEW_ID });
}
function getViewState(map) {
	const { lng, lat } = map.getCenter();
	const viewState = {
		longitude: (lng + 540) % 360 - 180,
		latitude: lat,
		zoom: map.getZoom(),
		bearing: map.getBearing(),
		pitch: map.getPitch(),
		padding: map.getPadding(),
		repeat: map.getRenderWorldCopies()
	};
	if (map.getTerrain?.()) centerCameraOnTerrain(map, viewState);
	return viewState;
}
function centerCameraOnTerrain(map, viewState) {
	if (map.getFreeCameraOptions) {
		const { position } = map.getFreeCameraOptions();
		if (!position || position.z === void 0) return;
		const height = map.transform.height;
		const { longitude, latitude, pitch } = viewState;
		const cameraX = position.x * TILE_SIZE;
		const cameraY = (1 - position.y) * TILE_SIZE;
		const cameraZ = position.z * TILE_SIZE;
		const center = lngLatToWorld([longitude, latitude]);
		const dx = cameraX - center[0];
		const dy = cameraY - center[1];
		const cameraToCenterDistanceGround = Math.sqrt(dx * dx + dy * dy);
		const pitchRadians = pitch * DEGREES_TO_RADIANS;
		const altitudePixels = 1.5 * height;
		const scale = pitchRadians < .001 ? altitudePixels * Math.cos(pitchRadians) / cameraZ : altitudePixels * Math.sin(pitchRadians) / cameraToCenterDistanceGround;
		viewState.zoom = Math.log2(scale);
		viewState.position = [
			0,
			0,
			(cameraZ - altitudePixels * Math.cos(pitchRadians) / scale) / unitsPerMeter(latitude)
		];
	} else if (typeof map.transform.elevation === "number") viewState.position = [
		0,
		0,
		map.transform.elevation
	];
}
function getViewport(deck, map, renderParameters) {
	const viewState = getViewState(map);
	const { views } = deck.props;
	const view = views && flatten(views).find((v) => v.id === MAPBOX_VIEW_ID) || getDefaultView(map);
	if (renderParameters) view.props.nearZMultiplier = .2;
	const nearZ = renderParameters?.nearZ ?? map.transform._nearZ;
	const farZ = renderParameters?.farZ ?? map.transform._farZ;
	if (Number.isFinite(nearZ)) {
		viewState.nearZ = nearZ / map.transform.height;
		viewState.farZ = farZ / map.transform.height;
	}
	return view.makeViewport({
		width: deck.width,
		height: deck.height,
		viewState
	});
}
function afterRender(deck, map) {
	const { mapboxLayers, isExternal } = deck.userData;
	if (isExternal) {
		const mapboxLayerIds = Array.from(mapboxLayers, (layer) => layer.id);
		const hasNonMapboxLayers = flatten(deck.props.layers, Boolean).some((layer) => layer && !mapboxLayerIds.includes(layer.id));
		let viewports = deck.getViewports();
		const mapboxViewportIdx = viewports.findIndex((vp) => vp.id === MAPBOX_VIEW_ID);
		const hasNonMapboxViews = viewports.length > 1 || mapboxViewportIdx < 0;
		if (hasNonMapboxLayers || hasNonMapboxViews) {
			if (mapboxViewportIdx >= 0) {
				viewports = viewports.slice();
				viewports[mapboxViewportIdx] = getViewport(deck, map);
			}
			deck._drawLayers("mapbox-repaint", {
				viewports,
				layerFilter: (params) => (!deck.props.layerFilter || deck.props.layerFilter(params)) && (params.viewport.id !== MAPBOX_VIEW_ID || !mapboxLayerIds.includes(params.layer.id)),
				clearCanvas: false
			});
		}
	}
	deck.userData.currentViewport = null;
}
function onMapMove(deck, map) {
	deck.setProps({ viewState: getViewState(map) });
	deck.needsRedraw({ clearRedrawFlags: true });
}
function updateLayers(deck) {
	if (deck.userData.isExternal) return;
	const layers = [];
	deck.userData.mapboxLayers.forEach((deckLayer) => {
		const LayerType = deckLayer.props.type;
		const layer = new LayerType(deckLayer.props);
		layers.push(layer);
	});
	deck.setProps({ layers });
}

//#endregion
//#region node_modules/@deck.gl/mapbox/dist/mapbox-layer.js
var MapboxLayer = class {
	constructor(props) {
		if (!props.id) throw new Error("Layer must have an unique id");
		this.id = props.id;
		this.type = "custom";
		this.renderingMode = props.renderingMode || "3d";
		this.slot = props.slot;
		this.map = null;
		this.deck = null;
		this.props = props;
	}
	onAdd(map, gl) {
		this.map = map;
		this.deck = getDeckInstance({
			map,
			gl,
			deck: this.props.deck
		});
		addLayer(this.deck, this);
	}
	onRemove() {
		if (this.deck) removeLayer(this.deck, this);
	}
	setProps(props) {
		Object.assign(this.props, props, { id: this.id });
		if (this.deck) updateLayer(this.deck, this);
	}
	render(gl, renderParameters) {
		drawLayer(this.deck, this.map, this, renderParameters);
	}
};

//#endregion
//#region node_modules/@deck.gl/mapbox/dist/resolve-layers.js
var UNDEFINED_BEFORE_ID$1 = "__UNDEFINED__";
/** Insert Deck layers into the mapbox Map according to the user-defined order */
function resolveLayers(map, deck, oldLayers, newLayers) {
	if (!map || !deck || !map.style || !map.style._loaded) return;
	const layers = flatten(newLayers, Boolean);
	if (oldLayers !== newLayers) {
		const prevLayers = flatten(oldLayers, Boolean);
		const prevLayerIds = new Set(prevLayers.map((l) => l.id));
		for (const layer of layers) prevLayerIds.delete(layer.id);
		for (const id of prevLayerIds) if (map.getLayer(id)) map.removeLayer(id);
	}
	for (const layer of layers) {
		const mapboxLayer = map.getLayer(layer.id);
		if (mapboxLayer) (mapboxLayer.implementation || mapboxLayer).setProps(layer.props);
		else map.addLayer(new MapboxLayer({
			id: layer.id,
			deck,
			slot: layer.props.slot
		}), layer.props.beforeId);
	}
	const mapLayers = map.style._order;
	const layerGroups = {};
	for (const layer of layers) {
		let { beforeId } = layer.props;
		if (!beforeId || !mapLayers.includes(beforeId)) beforeId = UNDEFINED_BEFORE_ID$1;
		layerGroups[beforeId] = layerGroups[beforeId] || [];
		layerGroups[beforeId].push(layer.id);
	}
	for (const beforeId in layerGroups) {
		const layerGroup = layerGroups[beforeId];
		let lastLayerIndex = beforeId === UNDEFINED_BEFORE_ID$1 ? mapLayers.length : mapLayers.indexOf(beforeId);
		let lastLayerId = beforeId === UNDEFINED_BEFORE_ID$1 ? void 0 : beforeId;
		for (let i = layerGroup.length - 1; i >= 0; i--) {
			const layerId = layerGroup[i];
			const layerIndex = mapLayers.indexOf(layerId);
			if (layerIndex !== lastLayerIndex - 1) {
				map.moveLayer(layerId, lastLayerId);
				if (layerIndex > lastLayerIndex) lastLayerIndex++;
			}
			lastLayerIndex--;
			lastLayerId = layerId;
		}
	}
}

//#endregion
//#region node_modules/@deck.gl/mapbox/dist/mapbox-layer-group.js
var MapboxLayerGroup = class {
	constructor(props) {
		assert(props.id, "id is required");
		this.id = props.id;
		this.type = "custom";
		this.renderingMode = props.renderingMode || "3d";
		this.slot = props.slot;
		this.beforeId = props.beforeId;
		this.map = null;
		this.deck = null;
	}
	onAdd(map, gl) {
		this.map = map;
		this.deck = getDeckInstance({
			map,
			gl
		});
	}
	render(gl, renderParameters) {
		if (!this.deck || !this.map) return;
		drawLayerGroup(this.deck, this.map, this, renderParameters);
	}
};

//#endregion
//#region node_modules/@deck.gl/mapbox/dist/resolve-layer-groups.js
var UNDEFINED_BEFORE_ID = "__UNDEFINED__";
function getLayerGroupId(layer) {
	if (layer.props.beforeId) return `deck-layer-group-before:${layer.props.beforeId}`;
	else if (layer.props.slot) return `deck-layer-group-slot:${layer.props.slot}`;
	return "deck-layer-group-last";
}
/** Group Deck layers into buckets (by beforeId or slot) and insert them
*  into the mapbox Map according to the user-defined order
**/
function resolveLayerGroups(map, oldLayers, newLayers) {
	if (!map || !map.style || !map.style._loaded) return;
	const layers = flatten(newLayers, Boolean);
	if (oldLayers !== newLayers) {
		const prevLayers = flatten(oldLayers, Boolean);
		const prevLayerGroupIds = new Set(prevLayers.map((l) => getLayerGroupId(l)));
		const newLayerGroupIds = new Set(layers.map((l) => getLayerGroupId(l)));
		for (const groupId of prevLayerGroupIds) if (!newLayerGroupIds.has(groupId)) {
			if (map.getLayer(groupId)) map.removeLayer(groupId);
		}
	}
	const layerGroups = {};
	for (const layer of layers) {
		const groupId = getLayerGroupId(layer);
		const mapboxGroup = map.getLayer(groupId);
		if (mapboxGroup) layerGroups[groupId] = mapboxGroup.implementation || mapboxGroup;
		else {
			const newGroup = new MapboxLayerGroup({
				id: groupId,
				slot: layer.props.slot,
				beforeId: layer.props.beforeId
			});
			layerGroups[groupId] = newGroup;
			map.addLayer(newGroup, layer.props.beforeId);
		}
	}
	const mapLayers = map.style._order;
	for (const [groupId, group] of Object.entries(layerGroups)) {
		const beforeId = group.beforeId || UNDEFINED_BEFORE_ID;
		const expectedGroupIndex = beforeId === UNDEFINED_BEFORE_ID ? mapLayers.length : mapLayers.indexOf(beforeId);
		if (mapLayers.indexOf(groupId) !== expectedGroupIndex - 1) {
			const moveBeforeId = beforeId === UNDEFINED_BEFORE_ID ? void 0 : beforeId;
			map.moveLayer(groupId, moveBeforeId);
		}
	}
}

//#endregion
//#region node_modules/@deck.gl/mapbox/dist/mapbox-overlay.js
/**
* Implements Mapbox [IControl](https://docs.mapbox.com/mapbox-gl-js/api/markers/#icontrol) interface
* Renders deck.gl layers over the base map and automatically synchronizes with the map's camera
*/
var MapboxOverlay = class {
	constructor(props) {
		this._handleStyleChange = () => {
			this._resolveLayers(this._map, this._deck, this._props.layers, this._props.layers);
			if (!this._map) return;
			if (getProjection(this._map) && !this._props.views) this._deck?.setProps({ views: getDefaultView(this._map) });
		};
		this._updateContainerSize = () => {
			if (this._map && this._container) {
				const { clientWidth, clientHeight } = this._map.getContainer();
				Object.assign(this._container.style, {
					width: `${clientWidth}px`,
					height: `${clientHeight}px`
				});
			}
		};
		this._updateViewState = () => {
			const deck = this._deck;
			const map = this._map;
			if (deck && map) {
				deck.setProps({
					views: this._props.views || getDefaultView(map),
					viewState: getViewState(map)
				});
				if (deck.isInitialized) deck.redraw();
			}
		};
		this._handleMouseEvent = (event) => {
			const deck = this._deck;
			if (!deck || !deck.isInitialized) return;
			const mockEvent = {
				type: event.type,
				offsetCenter: event.point,
				srcEvent: event
			};
			const lastDown = this._lastMouseDownPoint;
			if (!event.point && lastDown) {
				mockEvent.deltaX = event.originalEvent.clientX - lastDown.clientX;
				mockEvent.deltaY = event.originalEvent.clientY - lastDown.clientY;
				mockEvent.offsetCenter = {
					x: lastDown.x + mockEvent.deltaX,
					y: lastDown.y + mockEvent.deltaY
				};
			}
			switch (mockEvent.type) {
				case "mousedown":
					deck._onPointerDown(mockEvent);
					this._lastMouseDownPoint = {
						...event.point,
						clientX: event.originalEvent.clientX,
						clientY: event.originalEvent.clientY
					};
					break;
				case "dragstart":
					mockEvent.type = "panstart";
					deck._onEvent(mockEvent);
					break;
				case "drag":
					mockEvent.type = "panmove";
					deck._onEvent(mockEvent);
					break;
				case "dragend":
					mockEvent.type = "panend";
					deck._onEvent(mockEvent);
					break;
				case "click":
					mockEvent.tapCount = 1;
					deck._onEvent(mockEvent);
					break;
				case "dblclick":
					mockEvent.type = "click";
					mockEvent.tapCount = 2;
					deck._onEvent(mockEvent);
					break;
				case "mousemove":
					mockEvent.type = "pointermove";
					deck._onPointerMove(mockEvent);
					break;
				case "mouseout":
					mockEvent.type = "pointerleave";
					deck._onPointerMove(mockEvent);
					break;
				default: return;
			}
		};
		const { interleaved = false } = props;
		this._interleaved = interleaved;
		this._renderLayersInGroups = props._renderLayersInGroups || false;
		this._props = this.filterProps(props);
	}
	/** Filter out props to pass to Deck **/
	filterProps(props) {
		const { interleaved = false, useDevicePixels, ...deckProps } = props;
		if (!interleaved && useDevicePixels !== void 0) deckProps.useDevicePixels = useDevicePixels;
		return deckProps;
	}
	/** Update (partial) props of the underlying Deck instance. */
	setProps(props) {
		if (this._interleaved && props.layers) this._resolveLayers(this._map, this._deck, this._props.layers, props.layers);
		Object.assign(this._props, this.filterProps(props));
		if (this._deck && this._map) this._deck.setProps({
			...this._props,
			parameters: {
				...getDefaultParameters(this._map, this._interleaved),
				...this._props.parameters
			}
		});
	}
	/** Called when the control is added to a map */
	onAdd(map) {
		this._map = map;
		return this._interleaved ? this._onAddInterleaved(map) : this._onAddOverlaid(map);
	}
	_onAddOverlaid(map) {
		const container = document.createElement("div");
		Object.assign(container.style, {
			position: "absolute",
			left: 0,
			top: 0,
			textAlign: "initial",
			pointerEvents: "none"
		});
		this._container = container;
		this._deck = new deck_default({
			...this._props,
			parent: container,
			parameters: {
				...getDefaultParameters(map, false),
				...this._props.parameters
			},
			views: this._props.views || getDefaultView(map),
			viewState: getViewState(map)
		});
		map.on("resize", this._updateContainerSize);
		map.on("render", this._updateViewState);
		map.on("mousedown", this._handleMouseEvent);
		map.on("dragstart", this._handleMouseEvent);
		map.on("drag", this._handleMouseEvent);
		map.on("dragend", this._handleMouseEvent);
		map.on("mousemove", this._handleMouseEvent);
		map.on("mouseout", this._handleMouseEvent);
		map.on("click", this._handleMouseEvent);
		map.on("dblclick", this._handleMouseEvent);
		this._updateContainerSize();
		return container;
	}
	_onAddInterleaved(map) {
		const gl = map.painter.context.gl;
		if (gl instanceof WebGLRenderingContext) log_default.warn("Incompatible basemap library. See: https://deck.gl/docs/api-reference/mapbox/overview#compatibility")();
		this._deck = getDeckInstance({
			map,
			gl,
			deck: new deck_default({
				...this._props,
				gl,
				parameters: {
					...getDefaultParameters(map, true),
					...this._props.parameters
				}
			})
		});
		map.on("styledata", this._handleStyleChange);
		this._resolveLayers(map, this._deck, [], this._props.layers);
		return document.createElement("div");
	}
	_resolveLayers(map, deck, prevLayers, newLayers) {
		if (this._renderLayersInGroups) resolveLayerGroups(map, prevLayers, newLayers);
		else resolveLayers(map, deck, prevLayers, newLayers);
	}
	/** Called when the control is removed from a map */
	onRemove() {
		const map = this._map;
		if (map) if (this._interleaved) this._onRemoveInterleaved(map);
		else this._onRemoveOverlaid(map);
		this._deck = void 0;
		this._map = void 0;
		this._container = void 0;
	}
	_onRemoveOverlaid(map) {
		map.off("resize", this._updateContainerSize);
		map.off("render", this._updateViewState);
		map.off("mousedown", this._handleMouseEvent);
		map.off("dragstart", this._handleMouseEvent);
		map.off("drag", this._handleMouseEvent);
		map.off("dragend", this._handleMouseEvent);
		map.off("mousemove", this._handleMouseEvent);
		map.off("mouseout", this._handleMouseEvent);
		map.off("click", this._handleMouseEvent);
		map.off("dblclick", this._handleMouseEvent);
		this._deck?.finalize();
	}
	_onRemoveInterleaved(map) {
		map.off("styledata", this._handleStyleChange);
		this._resolveLayers(map, this._deck, this._props.layers, []);
		removeDeckInstance(map);
	}
	getDefaultPosition() {
		return "top-left";
	}
	/** Forwards the Deck.pickObject method */
	pickObject(params) {
		assert(this._deck);
		return this._deck.pickObject(params);
	}
	/** Forwards the Deck.pickMultipleObjects method */
	pickMultipleObjects(params) {
		assert(this._deck);
		return this._deck.pickMultipleObjects(params);
	}
	/** Forwards the Deck.pickObjects method */
	pickObjects(params) {
		assert(this._deck);
		return this._deck.pickObjects(params);
	}
	/** Remove from map and releases all resources */
	finalize() {
		if (this._map) this._map.removeControl(this);
	}
	/** If interleaved: true, returns base map's canvas, otherwise forwards the Deck.getCanvas method. */
	getCanvas() {
		if (!this._map) return null;
		return this._interleaved ? this._map.getCanvas() : this._deck.getCanvas();
	}
};

//#endregion
export { MapboxOverlay };
//# sourceMappingURL=@deck__gl_mapbox.js.map