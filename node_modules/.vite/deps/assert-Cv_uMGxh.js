import { S as Log } from "./webgl-developer-tools-DgucggGC.js";

//#region node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js
/**
* Throws an `Error` with the optional `message` if `condition` is falsy
* @note Replacement for the external assert method to reduce bundle size
*/
function assert$5(condition, message) {
	if (!condition) throw new Error(message || "loader assertion failed.");
}

//#endregion
//#region node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js
var globals$1 = {
	self: typeof self !== "undefined" && self,
	window: typeof window !== "undefined" && window,
	global: typeof global !== "undefined" && global,
	document: typeof document !== "undefined" && document
};
var self_$1 = globals$1.self || globals$1.window || globals$1.global || {};
var window_$2 = globals$1.window || globals$1.self || globals$1.global || {};
var global_$1 = globals$1.global || globals$1.self || globals$1.window || {};
var document_$1 = globals$1.document || {};
/** true if running in a browser */
const isBrowser = Boolean(typeof process !== "object" || String(process) !== "[object process]" || process.browser);
var matches$1 = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
/** Major Node version (as a number) */
const nodeVersion$1 = matches$1 && parseFloat(matches$1[1]) || 0;

//#endregion
//#region node_modules/@loaders.gl/loader-utils/dist/lib/log-utils/log.js
const VERSION$1 = "4.3.3";
var version = VERSION$1[0] >= "0" && VERSION$1[0] <= "9" ? `v${VERSION$1}` : "";
function createLog() {
	const log$1 = new Log({ id: "loaders.gl" });
	globalThis.loaders = globalThis.loaders || {};
	globalThis.loaders.log = log$1;
	globalThis.loaders.version = version;
	globalThis.probe = globalThis.probe || {};
	globalThis.probe.loaders = log$1;
	return log$1;
}
const log = createLog();

//#endregion
//#region node_modules/@loaders.gl/loader-utils/dist/lib/option-utils/merge-loader-options.js
/**
*
* @param baseOptions Can be undefined, in which case a fresh options object will be minted
* @param newOptions
* @returns
*/
function mergeLoaderOptions(baseOptions, newOptions) {
	return mergeOptionsRecursively(baseOptions || {}, newOptions);
}
function mergeOptionsRecursively(baseOptions, newOptions, level = 0) {
	if (level > 3) return newOptions;
	const options = { ...baseOptions };
	for (const [key, newValue] of Object.entries(newOptions)) if (newValue && typeof newValue === "object" && !Array.isArray(newValue)) options[key] = mergeOptionsRecursively(options[key] || {}, newOptions[key], level + 1);
	else options[key] = newOptions[key];
	return options;
}

//#endregion
//#region node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/version.js
/**
* TODO - unpkg.com doesn't seem to have a `latest` specifier for alpha releases...
* 'beta' on beta branch, 'latest' on prod branch
*/
const NPM_TAG = "latest";
function getVersion() {
	if (!globalThis._loadersgl_?.version) {
		globalThis._loadersgl_ = globalThis._loadersgl_ || {};
		globalThis._loadersgl_.version = "4.3.3";
	}
	return globalThis._loadersgl_.version;
}
const VERSION = getVersion();

//#endregion
//#region node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js
/** Throws an `Error` with the optional `message` if `condition` is falsy */
function assert$4(condition, message) {
	if (!condition) throw new Error(message || "loaders.gl assertion failed.");
}

//#endregion
//#region node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js
var globals = {
	self: typeof self !== "undefined" && self,
	window: typeof window !== "undefined" && window,
	global: typeof global !== "undefined" && global,
	document: typeof document !== "undefined" && document
};
var self_ = globals.self || globals.window || globals.global || {};
var window_$1 = globals.window || globals.self || globals.global || {};
var global_ = globals.global || globals.self || globals.window || {};
var document_ = globals.document || {};
/** true if running in the browser, false if running in Node.js */
const isBrowser$1 = typeof process !== "object" || String(process) !== "[object process]" || process.browser;
/** true if running on a mobile device */
const isMobile = typeof window !== "undefined" && typeof window.orientation !== "undefined";
var matches = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
/** Version of Node.js if running under Node, otherwise 0 */
const nodeVersion = matches && parseFloat(matches[1]) || 0;

//#endregion
//#region node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-job.js
/**
* Represents one Job handled by a WorkerPool or WorkerFarm
*/
var WorkerJob = class {
	name;
	workerThread;
	isRunning = true;
	/** Promise that resolves when Job is done */
	result;
	_resolve = () => {};
	_reject = () => {};
	constructor(jobName, workerThread) {
		this.name = jobName;
		this.workerThread = workerThread;
		this.result = new Promise((resolve, reject) => {
			this._resolve = resolve;
			this._reject = reject;
		});
	}
	/**
	* Send a message to the job's worker thread
	* @param data any data structure, ideally consisting mostly of transferrable objects
	*/
	postMessage(type, payload) {
		this.workerThread.postMessage({
			source: "loaders.gl",
			type,
			payload
		});
	}
	/**
	* Call to resolve the `result` Promise with the supplied value
	*/
	done(value) {
		assert$4(this.isRunning);
		this.isRunning = false;
		this._resolve(value);
	}
	/**
	* Call to reject the `result` Promise with the supplied error
	*/
	error(error) {
		assert$4(this.isRunning);
		this.isRunning = false;
		this._reject(error);
	}
};

//#endregion
//#region node_modules/@loaders.gl/worker-utils/dist/lib/node/worker_threads-browser.js
/** Browser polyfill for Node.js built-in `worker_threads` module.
* These fills are non-functional, and just intended to ensure that
* `import 'worker_threads` doesn't break browser builds.
* The replacement is done in package.json browser field
*/
var NodeWorker = class {
	terminate() {}
};

//#endregion
//#region node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-loadable-worker-url.js
var workerURLCache = /* @__PURE__ */ new Map();
/**
* Creates a loadable URL from worker source or URL
* that can be used to create `Worker` instances.
* Due to CORS issues it may be necessary to wrap a URL in a small importScripts
* @param props
* @param props.source Worker source
* @param props.url Worker URL
* @returns loadable url
*/
function getLoadableWorkerURL(props) {
	assert$4(props.source && !props.url || !props.source && props.url);
	let workerURL = workerURLCache.get(props.source || props.url);
	if (!workerURL) {
		if (props.url) {
			workerURL = getLoadableWorkerURLFromURL(props.url);
			workerURLCache.set(props.url, workerURL);
		}
		if (props.source) {
			workerURL = getLoadableWorkerURLFromSource(props.source);
			workerURLCache.set(props.source, workerURL);
		}
	}
	assert$4(workerURL);
	return workerURL;
}
/**
* Build a loadable worker URL from worker URL
* @param url
* @returns loadable URL
*/
function getLoadableWorkerURLFromURL(url) {
	if (!url.startsWith("http")) return url;
	return getLoadableWorkerURLFromSource(buildScriptSource(url));
}
/**
* Build a loadable worker URL from worker source
* @param workerSource
* @returns loadable url
*/
function getLoadableWorkerURLFromSource(workerSource) {
	const blob = new Blob([workerSource], { type: "application/javascript" });
	return URL.createObjectURL(blob);
}
/**
* Per spec, worker cannot be initialized with a script from a different origin
* However a local worker script can still import scripts from other origins,
* so we simply build a wrapper script.
*
* @param workerUrl
* @returns source
*/
function buildScriptSource(workerUrl) {
	return `\
try {
  importScripts('${workerUrl}');
} catch (error) {
  console.error(error);
  throw error;
}`;
}

//#endregion
//#region node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-transfer-list.js
/**
* Returns an array of Transferrable objects that can be used with postMessage
* https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage
* @param object data to be sent via postMessage
* @param recursive - not for application use
* @param transfers - not for application use
* @returns a transfer list that can be passed to postMessage
*/
function getTransferList(object, recursive = true, transfers) {
	const transfersSet = transfers || /* @__PURE__ */ new Set();
	if (!object) {} else if (isTransferable(object)) transfersSet.add(object);
	else if (isTransferable(object.buffer)) transfersSet.add(object.buffer);
	else if (ArrayBuffer.isView(object)) {} else if (recursive && typeof object === "object") for (const key in object) getTransferList(object[key], recursive, transfersSet);
	return transfers === void 0 ? Array.from(transfersSet) : [];
}
function isTransferable(object) {
	if (!object) return false;
	if (object instanceof ArrayBuffer) return true;
	if (typeof MessagePort !== "undefined" && object instanceof MessagePort) return true;
	if (typeof ImageBitmap !== "undefined" && object instanceof ImageBitmap) return true;
	if (typeof OffscreenCanvas !== "undefined" && object instanceof OffscreenCanvas) return true;
	return false;
}

//#endregion
//#region node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-thread.js
var NOOP = () => {};
/**
* Represents one worker thread
*/
var WorkerThread = class {
	name;
	source;
	url;
	terminated = false;
	worker;
	onMessage;
	onError;
	_loadableURL = "";
	/** Checks if workers are supported on this platform */
	static isSupported() {
		return typeof Worker !== "undefined" && isBrowser$1 || typeof NodeWorker !== "undefined" && !isBrowser$1;
	}
	constructor(props) {
		const { name, source: source$2, url } = props;
		assert$4(source$2 || url);
		this.name = name;
		this.source = source$2;
		this.url = url;
		this.onMessage = NOOP;
		this.onError = (error) => console.log(error);
		this.worker = isBrowser$1 ? this._createBrowserWorker() : this._createNodeWorker();
	}
	/**
	* Terminate this worker thread
	* @note Can free up significant memory
	*/
	destroy() {
		this.onMessage = NOOP;
		this.onError = NOOP;
		this.worker.terminate();
		this.terminated = true;
	}
	get isRunning() {
		return Boolean(this.onMessage);
	}
	/**
	* Send a message to this worker thread
	* @param data any data structure, ideally consisting mostly of transferrable objects
	* @param transferList If not supplied, calculated automatically by traversing data
	*/
	postMessage(data, transferList) {
		transferList = transferList || getTransferList(data);
		this.worker.postMessage(data, transferList);
	}
	/**
	* Generate a standard Error from an ErrorEvent
	* @param event
	*/
	_getErrorFromErrorEvent(event) {
		let message = "Failed to load ";
		message += `worker ${this.name} from ${this.url}. `;
		if (event.message) message += `${event.message} in `;
		if (event.lineno) message += `:${event.lineno}:${event.colno}`;
		return new Error(message);
	}
	/**
	* Creates a worker thread on the browser
	*/
	_createBrowserWorker() {
		this._loadableURL = getLoadableWorkerURL({
			source: this.source,
			url: this.url
		});
		const worker = new Worker(this._loadableURL, { name: this.name });
		worker.onmessage = (event) => {
			if (!event.data) this.onError(/* @__PURE__ */ new Error("No data received"));
			else this.onMessage(event.data);
		};
		worker.onerror = (error) => {
			this.onError(this._getErrorFromErrorEvent(error));
			this.terminated = true;
		};
		worker.onmessageerror = (event) => console.error(event);
		return worker;
	}
	/**
	* Creates a worker thread in node.js
	* @todo https://nodejs.org/api/async_hooks.html#async-resource-worker-pool
	*/
	_createNodeWorker() {
		let worker;
		if (this.url) worker = new NodeWorker(this.url.includes(":/") || this.url.startsWith("/") ? this.url : `./${this.url}`, { eval: false });
		else if (this.source) worker = new NodeWorker(this.source, { eval: true });
		else throw new Error("no worker");
		worker.on("message", (data) => {
			this.onMessage(data);
		});
		worker.on("error", (error) => {
			this.onError(error);
		});
		worker.on("exit", (code) => {});
		return worker;
	}
};

//#endregion
//#region node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-pool.js
/**
* Process multiple data messages with small pool of identical workers
*/
var WorkerPool = class {
	name = "unnamed";
	source;
	url;
	maxConcurrency = 1;
	maxMobileConcurrency = 1;
	onDebug = () => {};
	reuseWorkers = true;
	props = {};
	jobQueue = [];
	idleQueue = [];
	count = 0;
	isDestroyed = false;
	/** Checks if workers are supported on this platform */
	static isSupported() {
		return WorkerThread.isSupported();
	}
	/**
	* @param processor - worker function
	* @param maxConcurrency - max count of workers
	*/
	constructor(props) {
		this.source = props.source;
		this.url = props.url;
		this.setProps(props);
	}
	/**
	* Terminates all workers in the pool
	* @note Can free up significant memory
	*/
	destroy() {
		this.idleQueue.forEach((worker) => worker.destroy());
		this.isDestroyed = true;
	}
	setProps(props) {
		this.props = {
			...this.props,
			...props
		};
		if (props.name !== void 0) this.name = props.name;
		if (props.maxConcurrency !== void 0) this.maxConcurrency = props.maxConcurrency;
		if (props.maxMobileConcurrency !== void 0) this.maxMobileConcurrency = props.maxMobileConcurrency;
		if (props.reuseWorkers !== void 0) this.reuseWorkers = props.reuseWorkers;
		if (props.onDebug !== void 0) this.onDebug = props.onDebug;
	}
	async startJob(name, onMessage$1 = (job, type, data) => job.done(data), onError = (job, error) => job.error(error)) {
		const startPromise = new Promise((onStart) => {
			this.jobQueue.push({
				name,
				onMessage: onMessage$1,
				onError,
				onStart
			});
			return this;
		});
		this._startQueuedJob();
		return await startPromise;
	}
	/**
	* Starts first queued job if worker is available or can be created
	* Called when job is started and whenever a worker returns to the idleQueue
	*/
	async _startQueuedJob() {
		if (!this.jobQueue.length) return;
		const workerThread = this._getAvailableWorker();
		if (!workerThread) return;
		const queuedJob = this.jobQueue.shift();
		if (queuedJob) {
			this.onDebug({
				message: "Starting job",
				name: queuedJob.name,
				workerThread,
				backlog: this.jobQueue.length
			});
			const job = new WorkerJob(queuedJob.name, workerThread);
			workerThread.onMessage = (data) => queuedJob.onMessage(job, data.type, data.payload);
			workerThread.onError = (error) => queuedJob.onError(job, error);
			queuedJob.onStart(job);
			try {
				await job.result;
			} catch (error) {
				console.error(`Worker exception: ${error}`);
			} finally {
				this.returnWorkerToQueue(workerThread);
			}
		}
	}
	/**
	* Returns a worker to the idle queue
	* Destroys the worker if
	*  - pool is destroyed
	*  - if this pool doesn't reuse workers
	*  - if maxConcurrency has been lowered
	* @param worker
	*/
	returnWorkerToQueue(worker) {
		if (!isBrowser$1 || this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency()) {
			worker.destroy();
			this.count--;
		} else this.idleQueue.push(worker);
		if (!this.isDestroyed) this._startQueuedJob();
	}
	/**
	* Returns idle worker or creates new worker if maxConcurrency has not been reached
	*/
	_getAvailableWorker() {
		if (this.idleQueue.length > 0) return this.idleQueue.shift() || null;
		if (this.count < this._getMaxConcurrency()) {
			this.count++;
			return new WorkerThread({
				name: `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`,
				source: this.source,
				url: this.url
			});
		}
		return null;
	}
	_getMaxConcurrency() {
		return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;
	}
};

//#endregion
//#region node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-farm.js
var DEFAULT_PROPS = {
	maxConcurrency: 3,
	maxMobileConcurrency: 1,
	reuseWorkers: true,
	onDebug: () => {}
};
/**
* Process multiple jobs with a "farm" of different workers in worker pools.
*/
var WorkerFarm = class WorkerFarm {
	props;
	workerPools = /* @__PURE__ */ new Map();
	static _workerFarm;
	/** Checks if workers are supported on this platform */
	static isSupported() {
		return WorkerThread.isSupported();
	}
	/** Get the singleton instance of the global worker farm */
	static getWorkerFarm(props = {}) {
		WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});
		WorkerFarm._workerFarm.setProps(props);
		return WorkerFarm._workerFarm;
	}
	/** get global instance with WorkerFarm.getWorkerFarm() */
	constructor(props) {
		this.props = { ...DEFAULT_PROPS };
		this.setProps(props);
		/** @type Map<string, WorkerPool>} */
		this.workerPools = /* @__PURE__ */ new Map();
	}
	/**
	* Terminate all workers in the farm
	* @note Can free up significant memory
	*/
	destroy() {
		for (const workerPool of this.workerPools.values()) workerPool.destroy();
		this.workerPools = /* @__PURE__ */ new Map();
	}
	/**
	* Set props used when initializing worker pools
	* @param props
	*/
	setProps(props) {
		this.props = {
			...this.props,
			...props
		};
		for (const workerPool of this.workerPools.values()) workerPool.setProps(this._getWorkerPoolProps());
	}
	/**
	* Returns a worker pool for the specified worker
	* @param options - only used first time for a specific worker name
	* @param options.name - the name of the worker - used to identify worker pool
	* @param options.url -
	* @param options.source -
	* @example
	*   const job = WorkerFarm.getWorkerFarm().getWorkerPool({name, url}).startJob(...);
	*/
	getWorkerPool(options) {
		const { name, source: source$2, url } = options;
		let workerPool = this.workerPools.get(name);
		if (!workerPool) {
			workerPool = new WorkerPool({
				name,
				source: source$2,
				url
			});
			workerPool.setProps(this._getWorkerPoolProps());
			this.workerPools.set(name, workerPool);
		}
		return workerPool;
	}
	_getWorkerPoolProps() {
		return {
			maxConcurrency: this.props.maxConcurrency,
			maxMobileConcurrency: this.props.maxMobileConcurrency,
			reuseWorkers: this.props.reuseWorkers,
			onDebug: this.props.onDebug
		};
	}
};

//#endregion
//#region node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/get-worker-url.js
/**
* Generate a worker URL based on worker object and options
* @returns A URL to one of the following:
* - a published worker on unpkg CDN
* - a local test worker
* - a URL provided by the user in options
*/
function getWorkerURL(worker, options = {}) {
	const workerOptions = options[worker.id] || {};
	const workerFile = isBrowser$1 ? `${worker.id}-worker.js` : `${worker.id}-worker-node.js`;
	let url = workerOptions.workerUrl;
	if (!url && worker.id === "compression") url = options.workerUrl;
	if (options._workerType === "test") if (isBrowser$1) url = `modules/${worker.module}/dist/${workerFile}`;
	else url = `modules/${worker.module}/src/workers/${worker.id}-worker-node.ts`;
	if (!url) {
		let version$1 = worker.version;
		if (version$1 === "latest") version$1 = NPM_TAG;
		const versionTag = version$1 ? `@${version$1}` : "";
		url = `https://unpkg.com/@loaders.gl/${worker.module}${versionTag}/dist/${workerFile}`;
	}
	assert$4(url);
	return url;
}

//#endregion
//#region node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/validate-worker-version.js
/**
* Check if worker is compatible with this library version
* @param worker
* @param libVersion
* @returns `true` if the two versions are compatible
*/
function validateWorkerVersion(worker, coreVersion = VERSION) {
	assert$4(worker, "no worker provided");
	const workerVersion = worker.version;
	if (!coreVersion || !workerVersion) return false;
	return true;
}

//#endregion
//#region node_modules/@loaders.gl/loader-utils/dist/lib/worker-loader-utils/parse-with-worker.js
/**
* Determines if a loader can parse with worker
* @param loader
* @param options
*/
function canParseWithWorker(loader, options) {
	if (!WorkerFarm.isSupported()) return false;
	if (!isBrowser$1 && !options?._nodeWorkers) return false;
	return loader.worker && options?.worker;
}
/**
* this function expects that the worker function sends certain messages,
* this can be automated if the worker is wrapper by a call to createLoaderWorker in @loaders.gl/loader-utils.
*/
async function parseWithWorker(loader, data, options, context, parseOnMainThread) {
	const name = loader.id;
	const url = getWorkerURL(loader, options);
	const workerPool = WorkerFarm.getWorkerFarm(options).getWorkerPool({
		name,
		url
	});
	options = JSON.parse(JSON.stringify(options));
	context = JSON.parse(JSON.stringify(context || {}));
	const job = await workerPool.startJob("process-on-worker", onMessage.bind(null, parseOnMainThread));
	job.postMessage("process", {
		input: data,
		options,
		context
	});
	return await (await job.result).result;
}
/**
* Handle worker's responses to the main thread
* @param job
* @param type
* @param payload
*/
async function onMessage(parseOnMainThread, job, type, payload) {
	switch (type) {
		case "done":
			job.done(payload);
			break;
		case "error":
			job.error(new Error(payload.error));
			break;
		case "process":
			const { id, input, options } = payload;
			try {
				const result = await parseOnMainThread(input, options);
				job.postMessage("done", {
					id,
					result
				});
			} catch (error) {
				const message = error instanceof Error ? error.message : "unknown error";
				job.postMessage("error", {
					id,
					error: message
				});
			}
			break;
		default: console.warn(`parse-with-worker unknown message ${type}`);
	}
}

//#endregion
//#region node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/array-buffer-utils.js
/**
* compare two binary arrays for equality
* @param a
* @param b
* @param byteLength
*/
function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
	byteLength = byteLength || arrayBuffer1.byteLength;
	if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) return false;
	const array1 = new Uint8Array(arrayBuffer1);
	const array2 = new Uint8Array(arrayBuffer2);
	for (let i = 0; i < array1.length; ++i) if (array1[i] !== array2[i]) return false;
	return true;
}
/**
* Concatenate a sequence of ArrayBuffers from arguments
* @return A concatenated ArrayBuffer
*/
function concatenateArrayBuffers(...sources) {
	return concatenateArrayBuffersFromArray(sources);
}
/**
* Concatenate a sequence of ArrayBuffers from array
* @return A concatenated ArrayBuffer
*/
function concatenateArrayBuffersFromArray(sources) {
	const sourceArrays = sources.map((source2) => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);
	const byteLength = sourceArrays.reduce((length$1, typedArray) => length$1 + typedArray.byteLength, 0);
	const result = new Uint8Array(byteLength);
	let offset = 0;
	for (const sourceArray of sourceArrays) {
		result.set(sourceArray, offset);
		offset += sourceArray.byteLength;
	}
	return result.buffer;
}

//#endregion
//#region node_modules/@loaders.gl/loader-utils/dist/lib/iterators/async-iteration.js
/**
* Concatenates all data chunks yielded by an (async) iterator
* This function can e.g. be used to enable atomic parsers to work on (async) iterator inputs
*/
async function concatenateArrayBuffersAsync(asyncIterator) {
	const arrayBuffers = [];
	for await (const chunk of asyncIterator) arrayBuffers.push(chunk);
	return concatenateArrayBuffers(...arrayBuffers);
}

//#endregion
//#region node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/file-aliases.js
var pathPrefix = "";
var fileAliases = {};
/**
* Resolves aliases and adds path-prefix to paths
*/
function resolvePath(filename$1) {
	for (const alias in fileAliases) if (filename$1.startsWith(alias)) {
		const replacement = fileAliases[alias];
		filename$1 = filename$1.replace(alias, replacement);
	}
	if (!filename$1.startsWith("http://") && !filename$1.startsWith("https://")) filename$1 = `${pathPrefix}${filename$1}`;
	return filename$1;
}

//#endregion
//#region node_modules/@loaders.gl/loader-utils/dist/lib/node/buffer.browser.js
/**
* Convert Buffer to ArrayBuffer
* Converts Node.js `Buffer` to `ArrayBuffer` (without triggering bundler to include Buffer polyfill on browser)
* @todo better data type
*/
function toArrayBuffer$1(buffer) {
	return buffer;
}

//#endregion
//#region node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-conversion-utils.js
/**
* Check for Node.js `Buffer` (without triggering bundler to include Buffer polyfill on browser)
*/
function isBuffer$1(value) {
	return value && typeof value === "object" && value.isBuffer;
}
/**
* Convert an object to an array buffer
*/
function toArrayBuffer(data) {
	if (isBuffer$1(data)) return toArrayBuffer$1(data);
	if (data instanceof ArrayBuffer) return data;
	if (ArrayBuffer.isView(data)) {
		if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) return data.buffer;
		return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
	}
	if (typeof data === "string") {
		const text = data;
		return new TextEncoder().encode(text).buffer;
	}
	if (data && typeof data === "object" && data._toArrayBuffer) return data._toArrayBuffer();
	throw new Error("toArrayBuffer");
}

//#endregion
//#region node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js
/**
* Replacement for Node.js path.filename
* @param url
*/
function filename(url) {
	const slashIndex = url ? url.lastIndexOf("/") : -1;
	return slashIndex >= 0 ? url.substr(slashIndex + 1) : "";
}
/**
* Replacement for Node.js path.dirname
* @param url
*/
function dirname(url) {
	const slashIndex = url ? url.lastIndexOf("/") : -1;
	return slashIndex >= 0 ? url.substr(0, slashIndex) : "";
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js
var isBoolean = (x) => typeof x === "boolean";
var isFunction = (x) => typeof x === "function";
const isObject = (x) => x !== null && typeof x === "object";
const isPureObject = (x) => isObject(x) && x.constructor === {}.constructor;
const isIterable = (x) => Boolean(x) && typeof x[Symbol.iterator] === "function";
const isAsyncIterable = (x) => x && typeof x[Symbol.asyncIterator] === "function";
const isResponse = (x) => typeof Response !== "undefined" && x instanceof Response || x && x.arrayBuffer && x.text && x.json;
const isBlob = (x) => typeof Blob !== "undefined" && x instanceof Blob;
/** Check for Node.js `Buffer` without triggering bundler to include buffer polyfill */
const isBuffer = (x) => x && typeof x === "object" && x.isBuffer;
const isReadableDOMStream = (x) => typeof ReadableStream !== "undefined" && x instanceof ReadableStream || isObject(x) && isFunction(x.tee) && isFunction(x.cancel) && isFunction(x.getReader);
const isReadableNodeStream = (x) => isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);
const isReadableStream = (x) => isReadableDOMStream(x) || isReadableNodeStream(x);

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/fetch/fetch-error.js
var FetchError = class extends Error {
	constructor(message, info) {
		super(message);
		this.reason = info.reason;
		this.url = info.url;
		this.response = info.response;
	}
	/** A best effort reason for why the fetch failed */
	reason;
	/** The URL that failed to load. Empty string if not available. */
	url;
	/** The Response object, if any. */
	response;
};

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/utils/mime-type-utils.js
var DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
var MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;
/**
* Compare two MIME types, case insensitively etc.
* @param mimeType1
* @param mimeType2
* @returns true if the MIME types are equivalent
* @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#structure_of_a_mime_type
*/
function compareMIMETypes(mimeType1, mimeType2) {
	if (mimeType1.toLowerCase() === mimeType2.toLowerCase()) return true;
	return false;
}
/**
* Remove extra data like `charset` from MIME types
* @param mimeString
* @returns A clean MIME type, or an empty string
*
* @todo - handle more advanced MIMETYpes, multiple types
* @todo - extract charset etc
*/
function parseMIMEType(mimeString) {
	const matches$2 = MIME_TYPE_PATTERN.exec(mimeString);
	if (matches$2) return matches$2[1];
	return mimeString;
}
/**
* Extract MIME type from data URL
*
* @param mimeString
* @returns A clean MIME type, or an empty string
*
* @todo - handle more advanced MIMETYpes, multiple types
* @todo - extract charset etc
*/
function parseMIMETypeFromURL(url) {
	const matches$2 = DATA_URL_PATTERN.exec(url);
	if (matches$2) return matches$2[1];
	return "";
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js
var QUERY_STRING_PATTERN = /\?.*/;
function extractQueryString(url) {
	const matches$2 = url.match(QUERY_STRING_PATTERN);
	return matches$2 && matches$2[0];
}
function stripQueryString(url) {
	return url.replace(QUERY_STRING_PATTERN, "");
}
function shortenUrlForDisplay(url) {
	if (url.length < 50) return url;
	const urlEnd = url.slice(url.length - 15);
	return `${url.substr(0, 32)}...${urlEnd}`;
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/utils/resource-utils.js
/**
* Returns the URL associated with this resource.
* The returned value may include a query string and need further processing.
* If it cannot determine url, the corresponding value will be an empty string
*
* @todo string parameters are assumed to be URLs
*/
function getResourceUrl(resource) {
	if (isResponse(resource)) return resource.url;
	if (isBlob(resource)) return resource.name || "";
	if (typeof resource === "string") return resource;
	return "";
}
/**
* Returns the URL associated with this resource.
* The returned value may include a query string and need further processing.
* If it cannot determine url, the corresponding value will be an empty string
*
* @todo string parameters are assumed to be URLs
*/
function getResourceMIMEType(resource) {
	if (isResponse(resource)) {
		const response = resource;
		const contentTypeHeader = response.headers.get("content-type") || "";
		const noQueryUrl = stripQueryString(response.url);
		return parseMIMEType(contentTypeHeader) || parseMIMETypeFromURL(noQueryUrl);
	}
	if (isBlob(resource)) return resource.type || "";
	if (typeof resource === "string") return parseMIMETypeFromURL(resource);
	return "";
}
/**
* Returns (approximate) content length for a resource if it can be determined.
* Returns -1 if content length cannot be determined.
* @param resource

* @note string parameters are NOT assumed to be URLs
*/
function getResourceContentLength(resource) {
	if (isResponse(resource)) return resource.headers["content-length"] || -1;
	if (isBlob(resource)) return resource.size;
	if (typeof resource === "string") return resource.length;
	if (resource instanceof ArrayBuffer) return resource.byteLength;
	if (ArrayBuffer.isView(resource)) return resource.byteLength;
	return -1;
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/utils/response-utils.js
/**
* Returns a Response object
* Adds content-length header when possible
*
* @param resource
*/
async function makeResponse(resource) {
	if (isResponse(resource)) return resource;
	const headers = {};
	const contentLength = getResourceContentLength(resource);
	if (contentLength >= 0) headers["content-length"] = String(contentLength);
	const url = getResourceUrl(resource);
	const type = getResourceMIMEType(resource);
	if (type) headers["content-type"] = type;
	const initialDataUrl = await getInitialDataUrl(resource);
	if (initialDataUrl) headers["x-first-bytes"] = initialDataUrl;
	if (typeof resource === "string") resource = new TextEncoder().encode(resource);
	const response = new Response(resource, { headers });
	Object.defineProperty(response, "url", { value: url });
	return response;
}
/**
* Checks response status (async) and throws a helpful error message if status is not OK.
* @param response
*/
async function checkResponse(response) {
	if (!response.ok) throw await getResponseError(response);
}
async function getResponseError(response) {
	const shortUrl = shortenUrlForDisplay(response.url);
	let message = `Failed to fetch resource (${response.status}) ${response.statusText}: ${shortUrl}`;
	message = message.length > 100 ? `${message.slice(0, 100)}...` : message;
	const info = {
		reason: response.statusText,
		url: response.url,
		response
	};
	try {
		const contentType = response.headers.get("Content-Type");
		info.reason = !response.bodyUsed && contentType?.includes("application/json") ? await response.json() : await response.text();
	} catch (error) {}
	return new FetchError(message, info);
}
async function getInitialDataUrl(resource) {
	const INITIAL_DATA_LENGTH = 5;
	if (typeof resource === "string") return `data:,${resource.slice(0, INITIAL_DATA_LENGTH)}`;
	if (resource instanceof Blob) {
		const blobSlice = resource.slice(0, 5);
		return await new Promise((resolve) => {
			const reader = new FileReader();
			reader.onload = (event) => resolve(event?.target?.result);
			reader.readAsDataURL(blobSlice);
		});
	}
	if (resource instanceof ArrayBuffer) return `data:base64,${arrayBufferToBase64(resource.slice(0, INITIAL_DATA_LENGTH))}`;
	return null;
}
function arrayBufferToBase64(buffer) {
	let binary = "";
	const bytes = new Uint8Array(buffer);
	for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
	return btoa(binary);
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/fetch/fetch-file.js
function isNodePath(url) {
	return !isRequestURL(url) && !isDataURL(url);
}
function isRequestURL(url) {
	return url.startsWith("http:") || url.startsWith("https:");
}
function isDataURL(url) {
	return url.startsWith("data:");
}
/**
* fetch API compatible function
* - Supports fetching from Node.js local file system paths
* - Respects pathPrefix and file aliases
*/
async function fetchFile(urlOrData, fetchOptions) {
	if (typeof urlOrData === "string") {
		const url = resolvePath(urlOrData);
		if (isNodePath(url)) {
			if (globalThis.loaders?.fetchNode) return globalThis.loaders?.fetchNode(url, fetchOptions);
		}
		return await fetch(url, fetchOptions);
	}
	return await makeResponse(urlOrData);
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/loader-utils/loggers.js
const probeLog = new Log({ id: "loaders.gl" });
var NullLog = class {
	log() {
		return () => {};
	}
	info() {
		return () => {};
	}
	warn() {
		return () => {};
	}
	error() {
		return () => {};
	}
};
var ConsoleLog = class {
	console;
	constructor() {
		this.console = console;
	}
	log(...args) {
		return this.console.log.bind(this.console, ...args);
	}
	info(...args) {
		return this.console.info.bind(this.console, ...args);
	}
	warn(...args) {
		return this.console.warn.bind(this.console, ...args);
	}
	error(...args) {
		return this.console.error.bind(this.console, ...args);
	}
};

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/loader-utils/option-defaults.js
const DEFAULT_LOADER_OPTIONS = {
	fetch: null,
	mimeType: void 0,
	nothrow: false,
	log: new ConsoleLog(),
	useLocalLibraries: false,
	CDN: "https://unpkg.com/@loaders.gl",
	worker: true,
	maxConcurrency: 3,
	maxMobileConcurrency: 1,
	reuseWorkers: isBrowser,
	_nodeWorkers: false,
	_workerType: "",
	limit: 0,
	_limitMB: 0,
	batchSize: "auto",
	batchDebounceMs: 0,
	metadata: false,
	transforms: []
};
const REMOVED_LOADER_OPTIONS = {
	throws: "nothrow",
	dataType: "(no longer used)",
	uri: "baseUri",
	method: "fetch.method",
	headers: "fetch.headers",
	body: "fetch.body",
	mode: "fetch.mode",
	credentials: "fetch.credentials",
	cache: "fetch.cache",
	redirect: "fetch.redirect",
	referrer: "fetch.referrer",
	referrerPolicy: "fetch.referrerPolicy",
	integrity: "fetch.integrity",
	keepalive: "fetch.keepalive",
	signal: "fetch.signal"
};

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/loader-utils/option-utils.js
/**
* Helper for safely accessing global loaders.gl variables
* Wraps initialization of global variable in function to defeat overly aggressive tree-shakers
*/
function getGlobalLoaderState() {
	globalThis.loaders = globalThis.loaders || {};
	const { loaders } = globalThis;
	if (!loaders._state) loaders._state = {};
	return loaders._state;
}
/**
* Store global loader options on the global object to increase chances of cross loaders-version interoperability
* NOTE: This use case is not reliable but can help when testing new versions of loaders.gl with existing frameworks
* @returns global loader options merged with default loader options
*/
function getGlobalLoaderOptions() {
	const state = getGlobalLoaderState();
	state.globalOptions = state.globalOptions || { ...DEFAULT_LOADER_OPTIONS };
	return state.globalOptions;
}
/**
* Merges options with global opts and loader defaults, also injects baseUri
* @param options
* @param loader
* @param loaders
* @param url
*/
function normalizeOptions(options, loader, loaders, url) {
	loaders = loaders || [];
	loaders = Array.isArray(loaders) ? loaders : [loaders];
	validateOptions(options, loaders);
	return normalizeOptionsInternal(loader, options, url);
}
/**
* Warn for unsupported options
* @param options
* @param loaders
*/
function validateOptions(options, loaders) {
	validateOptionsObject(options, null, DEFAULT_LOADER_OPTIONS, REMOVED_LOADER_OPTIONS, loaders);
	for (const loader of loaders) {
		const idOptions = options && options[loader.id] || {};
		const loaderOptions = loader.options && loader.options[loader.id] || {};
		const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};
		validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);
	}
}
function validateOptionsObject(options, id, defaultOptions$1, deprecatedOptions, loaders) {
	const loaderName = id || "Top level";
	const prefix = id ? `${id}.` : "";
	for (const key in options) {
		const isSubOptions = !id && isObject(options[key]);
		const isBaseUriOption = key === "baseUri" && !id;
		const isWorkerUrlOption = key === "workerUrl" && id;
		if (!(key in defaultOptions$1) && !isBaseUriOption && !isWorkerUrlOption) {
			if (key in deprecatedOptions) probeLog.warn(`${loaderName} loader option \'${prefix}${key}\' no longer supported, use \'${deprecatedOptions[key]}\'`)();
			else if (!isSubOptions) {
				const suggestion = findSimilarOption(key, loaders);
				probeLog.warn(`${loaderName} loader option \'${prefix}${key}\' not recognized. ${suggestion}`)();
			}
		}
	}
}
function findSimilarOption(optionKey, loaders) {
	const lowerCaseOptionKey = optionKey.toLowerCase();
	let bestSuggestion = "";
	for (const loader of loaders) for (const key in loader.options) {
		if (optionKey === key) return `Did you mean \'${loader.id}.${key}\'?`;
		const lowerCaseKey = key.toLowerCase();
		if (lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey)) bestSuggestion = bestSuggestion || `Did you mean \'${loader.id}.${key}\'?`;
	}
	return bestSuggestion;
}
function normalizeOptionsInternal(loader, options, url) {
	const mergedOptions = { ...loader.options || {} };
	addUrlOptions(mergedOptions, url);
	if (mergedOptions.log === null) mergedOptions.log = new NullLog();
	mergeNestedFields(mergedOptions, getGlobalLoaderOptions());
	mergeNestedFields(mergedOptions, options);
	return mergedOptions;
}
function mergeNestedFields(mergedOptions, options) {
	for (const key in options) if (key in options) {
		const value = options[key];
		if (isPureObject(value) && isPureObject(mergedOptions[key])) mergedOptions[key] = {
			...mergedOptions[key],
			...options[key]
		};
		else mergedOptions[key] = options[key];
	}
}
/**
* Harvest information from the url
* @deprecated This is mainly there to support a hack in the GLTFLoader
* TODO - baseUri should be a directory, i.e. remove file component from baseUri
* TODO - extract extension?
* TODO - extract query parameters?
* TODO - should these be injected on context instead of options?
*/
function addUrlOptions(options, url) {
	if (url && !("baseUri" in options)) options.baseUri = url;
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js
function isLoaderObject(loader) {
	if (!loader) return false;
	if (Array.isArray(loader)) loader = loader[0];
	return Array.isArray(loader?.extensions);
}
function normalizeLoader(loader) {
	assert$5(loader, "null loader");
	assert$5(isLoaderObject(loader), "invalid loader");
	let options;
	if (Array.isArray(loader)) {
		options = loader[1];
		loader = loader[0];
		loader = {
			...loader,
			options: {
				...loader.options,
				...options
			}
		};
	}
	if (loader?.parseTextSync || loader?.parseText) loader.text = true;
	if (!loader.text) loader.binary = true;
	return loader;
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/api/register-loaders.js
/**
* Store global registered loaders on the global object to increase chances of cross loaders-version interoperability
* This use case is not reliable but can help when testing new versions of loaders.gl with existing frameworks
*/
var getGlobalLoaderRegistry = () => {
	const state = getGlobalLoaderState();
	state.loaderRegistry = state.loaderRegistry || [];
	return state.loaderRegistry;
};
/**
* Register a list of global loaders
* @note Registration erases loader type information.
* @deprecated It is recommended that applications manage loader registration. This function will likely be remove in loaders.gl v5
*/
function registerLoaders(loaders) {
	const loaderRegistry = getGlobalLoaderRegistry();
	loaders = Array.isArray(loaders) ? loaders : [loaders];
	for (const loader of loaders) {
		const normalizedLoader = normalizeLoader(loader);
		if (!loaderRegistry.find((registeredLoader) => normalizedLoader === registeredLoader)) loaderRegistry.unshift(normalizedLoader);
	}
}
/**
* @deprecated It is recommended that applications manage loader registration. This function will likely be remove in loaders.gl v5
*/
function getRegisteredLoaders() {
	return getGlobalLoaderRegistry();
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/api/select-loader.js
var EXT_PATTERN = /\.([^.]+)$/;
/**
* Find a loader that matches file extension and/or initial file content
* Search the loaders array argument for a loader that matches url extension or initial data
* Returns: a normalized loader
* @param data data to assist
* @param loaders
* @param options
* @param context used internally, applications should not provide this parameter
*/
async function selectLoader(data, loaders = [], options, context) {
	if (!validHTTPResponse(data)) return null;
	let loader = selectLoaderSync(data, loaders, {
		...options,
		nothrow: true
	}, context);
	if (loader) return loader;
	if (isBlob(data)) {
		data = await data.slice(0, 10).arrayBuffer();
		loader = selectLoaderSync(data, loaders, options, context);
	}
	if (!loader && !options?.nothrow) throw new Error(getNoValidLoaderMessage(data));
	return loader;
}
/**
* Find a loader that matches file extension and/or initial file content
* Search the loaders array argument for a loader that matches url extension or initial data
* Returns: a normalized loader
* @param data data to assist
* @param loaders
* @param options
* @param context used internally, applications should not provide this parameter
*/
function selectLoaderSync(data, loaders = [], options, context) {
	if (!validHTTPResponse(data)) return null;
	if (loaders && !Array.isArray(loaders)) return normalizeLoader(loaders);
	let candidateLoaders = [];
	if (loaders) candidateLoaders = candidateLoaders.concat(loaders);
	if (!options?.ignoreRegisteredLoaders) candidateLoaders.push(...getRegisteredLoaders());
	normalizeLoaders(candidateLoaders);
	const loader = selectLoaderInternal(data, candidateLoaders, options, context);
	if (!loader && !options?.nothrow) throw new Error(getNoValidLoaderMessage(data));
	return loader;
}
/** Implements loaders selection logic */
function selectLoaderInternal(data, loaders, options, context) {
	const url = getResourceUrl(data);
	const type = getResourceMIMEType(data);
	const testUrl = stripQueryString(url) || context?.url;
	let loader = null;
	let reason = "";
	if (options?.mimeType) {
		loader = findLoaderByMIMEType(loaders, options?.mimeType);
		reason = `match forced by supplied MIME type ${options?.mimeType}`;
	}
	loader = loader || findLoaderByUrl(loaders, testUrl);
	reason = reason || (loader ? `matched url ${testUrl}` : "");
	loader = loader || findLoaderByMIMEType(loaders, type);
	reason = reason || (loader ? `matched MIME type ${type}` : "");
	loader = loader || findLoaderByInitialBytes(loaders, data);
	reason = reason || (loader ? `matched initial data ${getFirstCharacters(data)}` : "");
	if (options?.fallbackMimeType) {
		loader = loader || findLoaderByMIMEType(loaders, options?.fallbackMimeType);
		reason = reason || (loader ? `matched fallback MIME type ${type}` : "");
	}
	if (reason) log.log(1, `selectLoader selected ${loader?.name}: ${reason}.`);
	return loader;
}
/** Check HTTP Response */
function validHTTPResponse(data) {
	if (data instanceof Response) {
		if (data.status === 204) return false;
	}
	return true;
}
/** Generate a helpful message to help explain why loader selection failed. */
function getNoValidLoaderMessage(data) {
	const url = getResourceUrl(data);
	const type = getResourceMIMEType(data);
	let message = "No valid loader found (";
	message += url ? `${filename(url)}, ` : "no url provided, ";
	message += `MIME type: ${type ? `"${type}"` : "not provided"}, `;
	const firstCharacters = data ? getFirstCharacters(data) : "";
	message += firstCharacters ? ` first bytes: "${firstCharacters}"` : "first bytes: not available";
	message += ")";
	return message;
}
function normalizeLoaders(loaders) {
	for (const loader of loaders) normalizeLoader(loader);
}
function findLoaderByUrl(loaders, url) {
	const match = url && EXT_PATTERN.exec(url);
	const extension = match && match[1];
	return extension ? findLoaderByExtension(loaders, extension) : null;
}
function findLoaderByExtension(loaders, extension) {
	extension = extension.toLowerCase();
	for (const loader of loaders) for (const loaderExtension of loader.extensions) if (loaderExtension.toLowerCase() === extension) return loader;
	return null;
}
function findLoaderByMIMEType(loaders, mimeType) {
	for (const loader of loaders) {
		if (loader.mimeTypes?.some((mimeType1) => compareMIMETypes(mimeType, mimeType1))) return loader;
		if (compareMIMETypes(mimeType, `application/x.${loader.id}`)) return loader;
	}
	return null;
}
function findLoaderByInitialBytes(loaders, data) {
	if (!data) return null;
	for (const loader of loaders) if (typeof data === "string") {
		if (testDataAgainstText(data, loader)) return loader;
	} else if (ArrayBuffer.isView(data)) {
		if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) return loader;
	} else if (data instanceof ArrayBuffer) {
		if (testDataAgainstBinary(data, 0, loader)) return loader;
	}
	return null;
}
function testDataAgainstText(data, loader) {
	if (loader.testText) return loader.testText(data);
	return (Array.isArray(loader.tests) ? loader.tests : [loader.tests]).some((test) => data.startsWith(test));
}
function testDataAgainstBinary(data, byteOffset, loader) {
	return (Array.isArray(loader.tests) ? loader.tests : [loader.tests]).some((test) => testBinary(data, byteOffset, loader, test));
}
function testBinary(data, byteOffset, loader, test) {
	if (test instanceof ArrayBuffer) return compareArrayBuffers(test, data, test.byteLength);
	switch (typeof test) {
		case "function": return test(data);
		case "string": return test === getMagicString(data, byteOffset, test.length);
		default: return false;
	}
}
function getFirstCharacters(data, length$1 = 5) {
	if (typeof data === "string") return data.slice(0, length$1);
	else if (ArrayBuffer.isView(data)) return getMagicString(data.buffer, data.byteOffset, length$1);
	else if (data instanceof ArrayBuffer) return getMagicString(data, 0, length$1);
	return "";
}
function getMagicString(arrayBuffer, byteOffset, length$1) {
	if (arrayBuffer.byteLength < byteOffset + length$1) return "";
	const dataView = new DataView(arrayBuffer);
	let magic = "";
	for (let i = 0; i < length$1; i++) magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
	return magic;
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-string-iterator.js
var DEFAULT_CHUNK_SIZE$2 = 256 * 1024;
/**
* Returns an iterator that breaks a big string into chunks and yields them one-by-one as ArrayBuffers
* @param blob string to iterate over
* @param options
* @param options.chunkSize
*/
function* makeStringIterator(string, options) {
	const chunkSize = options?.chunkSize || DEFAULT_CHUNK_SIZE$2;
	let offset = 0;
	const textEncoder = new TextEncoder();
	while (offset < string.length) {
		const chunkLength = Math.min(string.length - offset, chunkSize);
		const chunk = string.slice(offset, offset + chunkLength);
		offset += chunkLength;
		yield textEncoder.encode(chunk);
	}
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-array-buffer-iterator.js
var DEFAULT_CHUNK_SIZE$1 = 256 * 1024;
/**
* Returns an iterator that breaks a big ArrayBuffer into chunks and yields them one-by-one
* @param blob ArrayBuffer to iterate over
* @param options
* @param options.chunkSize
*/
function* makeArrayBufferIterator(arrayBuffer, options = {}) {
	const { chunkSize = DEFAULT_CHUNK_SIZE$1 } = options;
	let byteOffset = 0;
	while (byteOffset < arrayBuffer.byteLength) {
		const chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);
		const chunk = new ArrayBuffer(chunkByteLength);
		const sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);
		new Uint8Array(chunk).set(sourceArray);
		byteOffset += chunkByteLength;
		yield chunk;
	}
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-blob-iterator.js
var DEFAULT_CHUNK_SIZE = 1024 * 1024;
/**
* Returns an iterator that breaks a big Blob into chunks and yields them one-by-one
* @param blob Blob or File object
* @param options
* @param options.chunkSize
*/
async function* makeBlobIterator(blob, options) {
	const chunkSize = options?.chunkSize || DEFAULT_CHUNK_SIZE;
	let offset = 0;
	while (offset < blob.size) {
		const end = offset + chunkSize;
		const chunk = await blob.slice(offset, end).arrayBuffer();
		offset = end;
		yield chunk;
	}
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-stream-iterator.js
/**
* Returns an async iterable that reads from a stream (works in both Node.js and browsers)
* @param stream stream to iterator over
*/
function makeStreamIterator(stream, options) {
	return isBrowser ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream, options);
}
/**
* Returns an async iterable that reads from a DOM (browser) stream
* @param stream stream to iterate from
* @see https://jakearchibald.com/2017/async-iterators-and-generators/#making-streams-iterate
*/
async function* makeBrowserStreamIterator(stream, options) {
	const reader = stream.getReader();
	let nextBatchPromise;
	try {
		while (true) {
			const currentBatchPromise = nextBatchPromise || reader.read();
			if (options?._streamReadAhead) nextBatchPromise = reader.read();
			const { done, value } = await currentBatchPromise;
			if (done) return;
			yield toArrayBuffer(value);
		}
	} catch (error) {
		reader.releaseLock();
	}
}
/**
* Returns an async iterable that reads from a DOM (browser) stream
* @param stream stream to iterate from
* @note Requires Node.js >= 10
*/
async function* makeNodeStreamIterator(stream, options) {
	for await (const chunk of stream) yield toArrayBuffer(chunk);
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-iterator.js
/**
* Returns an iterator that breaks its input into chunks and yields them one-by-one.
* @param data
* @param options
* @returns
* This function can e.g. be used to enable data sources that can only be read atomically
* (such as `Blob` and `File` via `FileReader`) to still be parsed in batches.
*/
function makeIterator(data, options) {
	if (typeof data === "string") return makeStringIterator(data, options);
	if (data instanceof ArrayBuffer) return makeArrayBufferIterator(data, options);
	if (isBlob(data)) return makeBlobIterator(data, options);
	if (isReadableStream(data)) return makeStreamIterator(data, options);
	if (isResponse(data)) return makeStreamIterator(data.body, options);
	throw new Error("makeIterator");
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/loader-utils/get-data.js
var ERR_DATA = "Cannot convert supplied data type";
function getArrayBufferOrStringFromDataSync(data, loader, options) {
	if (loader.text && typeof data === "string") return data;
	if (isBuffer(data)) data = data.buffer;
	if (data instanceof ArrayBuffer) {
		const arrayBuffer = data;
		if (loader.text && !loader.binary) return new TextDecoder("utf8").decode(arrayBuffer);
		return arrayBuffer;
	}
	if (ArrayBuffer.isView(data)) {
		if (loader.text && !loader.binary) return new TextDecoder("utf8").decode(data);
		let arrayBuffer = data.buffer;
		const byteLength = data.byteLength || data.length;
		if (data.byteOffset !== 0 || byteLength !== arrayBuffer.byteLength) arrayBuffer = arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);
		return arrayBuffer;
	}
	throw new Error(ERR_DATA);
}
async function getArrayBufferOrStringFromData(data, loader, options) {
	const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);
	if (typeof data === "string" || isArrayBuffer) return getArrayBufferOrStringFromDataSync(data, loader, options);
	if (isBlob(data)) data = await makeResponse(data);
	if (isResponse(data)) {
		const response = data;
		await checkResponse(response);
		return loader.binary ? await response.arrayBuffer() : await response.text();
	}
	if (isReadableStream(data)) data = makeIterator(data, options);
	if (isIterable(data) || isAsyncIterable(data)) return concatenateArrayBuffersAsync(data);
	throw new Error(ERR_DATA);
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/loader-utils/get-fetch-function.js
/**
* Gets the current fetch function from options and context
* @param options
* @param context
*/
function getFetchFunction(options, context) {
	const globalOptions = getGlobalLoaderOptions();
	const loaderOptions = options || globalOptions;
	if (typeof loaderOptions.fetch === "function") return loaderOptions.fetch;
	if (isObject(loaderOptions.fetch)) return (url) => fetchFile(url, loaderOptions.fetch);
	if (context?.fetch) return context?.fetch;
	return fetchFile;
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/loader-utils/loader-context.js
/**
* "sub" loaders invoked by other loaders get a "context" injected on `this`
* The context will inject core methods like `parse` and contain information
* about loaders and options passed in to the top-level `parse` call.
*
* @param context
* @param options
* @param previousContext
*/
function getLoaderContext(context, options, parentContext) {
	if (parentContext) return parentContext;
	const newContext = {
		fetch: getFetchFunction(options, context),
		...context
	};
	if (newContext.url) {
		const baseUrl = stripQueryString(newContext.url);
		newContext.baseUrl = baseUrl;
		newContext.queryString = extractQueryString(newContext.url);
		newContext.filename = filename(baseUrl);
		newContext.baseUrl = dirname(baseUrl);
	}
	if (!Array.isArray(newContext.loaders)) newContext.loaders = null;
	return newContext;
}
function getLoadersFromContext(loaders, context) {
	if (loaders && !Array.isArray(loaders)) return loaders;
	let candidateLoaders;
	if (loaders) candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];
	if (context && context.loaders) {
		const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];
		candidateLoaders = candidateLoaders ? [...candidateLoaders, ...contextLoaders] : contextLoaders;
	}
	return candidateLoaders && candidateLoaders.length ? candidateLoaders : void 0;
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/api/parse.js
/**
* Parses `data` using a specified loader
* @param data
* @param loaders
* @param options
* @param context
*/
async function parse(data, loaders, options, context) {
	if (loaders && !Array.isArray(loaders) && !isLoaderObject(loaders)) {
		context = void 0;
		options = loaders;
		loaders = void 0;
	}
	data = await data;
	options = options || {};
	const url = getResourceUrl(data);
	const candidateLoaders = getLoadersFromContext(loaders, context);
	const loader = await selectLoader(data, candidateLoaders, options);
	if (!loader) return null;
	options = normalizeOptions(options, loader, candidateLoaders, url);
	context = getLoaderContext({
		url,
		_parse: parse,
		loaders: candidateLoaders
	}, options, context || null);
	return await parseWithLoader(loader, data, options, context);
}
async function parseWithLoader(loader, data, options, context) {
	validateWorkerVersion(loader);
	options = mergeLoaderOptions(loader.options, options);
	if (isResponse(data)) {
		const response = data;
		const { ok, redirected, status, statusText, type, url } = response;
		context.response = {
			headers: Object.fromEntries(response.headers.entries()),
			ok,
			redirected,
			status,
			statusText,
			type,
			url
		};
	}
	data = await getArrayBufferOrStringFromData(data, loader, options);
	const loaderWithParser = loader;
	if (loaderWithParser.parseTextSync && typeof data === "string") return loaderWithParser.parseTextSync(data, options, context);
	if (canParseWithWorker(loader, options)) return await parseWithWorker(loader, data, options, context, parse);
	if (loaderWithParser.parseText && typeof data === "string") return await loaderWithParser.parseText(data, options, context);
	if (loaderWithParser.parse) return await loaderWithParser.parse(data, options, context);
	assert$4(!loaderWithParser.parseSync);
	throw new Error(`${loader.id} loader - no parser found and worker is disabled`);
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/api/load.js
async function load(url, loaders, options, context) {
	let resolvedLoaders;
	let resolvedOptions;
	if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {
		resolvedLoaders = [];
		resolvedOptions = loaders;
		context = void 0;
	} else {
		resolvedLoaders = loaders;
		resolvedOptions = options;
	}
	const fetch$1 = getFetchFunction(resolvedOptions);
	let data = url;
	if (typeof url === "string") data = await fetch$1(url);
	if (isBlob(url)) data = await fetch$1(url);
	return Array.isArray(resolvedLoaders) ? await parse(data, resolvedLoaders, resolvedOptions) : await parse(data, resolvedLoaders, resolvedOptions);
}

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/log.js
var defaultLogger = new Log({ id: "deck" });
var log_default = defaultLogger;

//#endregion
//#region node_modules/@deck.gl/core/dist/debug/loggers.js
var logState = {
	attributeUpdateStart: -1,
	attributeManagerUpdateStart: -1,
	attributeUpdateMessages: []
};
var LOG_LEVEL_MAJOR_UPDATE = 1;
var LOG_LEVEL_MINOR_UPDATE = 2;
var LOG_LEVEL_UPDATE_DETAIL = 3;
var LOG_LEVEL_INFO = 4;
var LOG_LEVEL_DRAW = 2;
const getLoggers = (log$1) => ({
	"layer.changeFlag": (layer, key, flags) => {
		log$1.log(LOG_LEVEL_UPDATE_DETAIL, `${layer.id} ${key}: `, flags[key])();
	},
	"layer.initialize": (layer) => {
		log$1.log(LOG_LEVEL_MAJOR_UPDATE, `Initializing ${layer}`)();
	},
	"layer.update": (layer, needsUpdate) => {
		if (needsUpdate) {
			const flags = layer.getChangeFlags();
			log$1.log(LOG_LEVEL_MINOR_UPDATE, `Updating ${layer} because: ${Object.keys(flags).filter((key) => flags[key]).join(", ")}`)();
		} else log$1.log(LOG_LEVEL_INFO, `${layer} does not need update`)();
	},
	"layer.matched": (layer, changed) => {
		if (changed) log$1.log(LOG_LEVEL_INFO, `Matched ${layer}, state transfered`)();
	},
	"layer.finalize": (layer) => {
		log$1.log(LOG_LEVEL_MAJOR_UPDATE, `Finalizing ${layer}`)();
	},
	"compositeLayer.renderLayers": (layer, updated, subLayers) => {
		if (updated) log$1.log(LOG_LEVEL_MINOR_UPDATE, `Composite layer rendered new subLayers ${layer}`, subLayers)();
		else log$1.log(LOG_LEVEL_INFO, `Composite layer reused subLayers ${layer}`, subLayers)();
	},
	"layerManager.setLayers": (layerManager, updated, layers) => {
		if (updated) log$1.log(LOG_LEVEL_MINOR_UPDATE, `Updating ${layers.length} deck layers`)();
	},
	"layerManager.activateViewport": (layerManager, viewport) => {
		log$1.log(LOG_LEVEL_UPDATE_DETAIL, "Viewport changed", viewport)();
	},
	"attributeManager.invalidate": (attributeManager, trigger, attributeNames) => {
		log$1.log(LOG_LEVEL_MAJOR_UPDATE, attributeNames ? `invalidated attributes ${attributeNames} (${trigger}) for ${attributeManager.id}` : `invalidated all attributes for ${attributeManager.id}`)();
	},
	"attributeManager.updateStart": (attributeManager) => {
		logState.attributeUpdateMessages.length = 0;
		logState.attributeManagerUpdateStart = Date.now();
	},
	"attributeManager.updateEnd": (attributeManager, numInstances) => {
		const timeMs = Math.round(Date.now() - logState.attributeManagerUpdateStart);
		log$1.groupCollapsed(LOG_LEVEL_MINOR_UPDATE, `Updated attributes for ${numInstances} instances in ${attributeManager.id} in ${timeMs}ms`)();
		for (const updateMessage of logState.attributeUpdateMessages) log$1.log(LOG_LEVEL_UPDATE_DETAIL, updateMessage)();
		log$1.groupEnd(LOG_LEVEL_MINOR_UPDATE)();
	},
	"attribute.updateStart": (attribute) => {
		logState.attributeUpdateStart = Date.now();
	},
	"attribute.allocate": (attribute, numInstances) => {
		const message = `${attribute.id} allocated ${numInstances}`;
		logState.attributeUpdateMessages.push(message);
	},
	"attribute.updateEnd": (attribute, numInstances) => {
		const timeMs = Math.round(Date.now() - logState.attributeUpdateStart);
		const message = `${attribute.id} updated ${numInstances} in ${timeMs}ms`;
		logState.attributeUpdateMessages.push(message);
	},
	"deckRenderer.renderLayers": (deckRenderer, renderStats, opts) => {
		const { pass, redrawReason, stats } = opts;
		for (const status of renderStats) {
			const { totalCount, visibleCount, compositeCount, pickableCount } = status;
			const hiddenCount = totalCount - compositeCount - visibleCount;
			log$1.log(LOG_LEVEL_DRAW, `RENDER #${deckRenderer.renderCount} \
  ${visibleCount} (of ${totalCount} layers) to ${pass} because ${redrawReason} \
  (${hiddenCount} hidden, ${compositeCount} composite ${pickableCount} pickable)`)();
			if (stats) stats.get("Redraw Layers").add(visibleCount);
		}
	}
});

//#endregion
//#region node_modules/@deck.gl/core/dist/debug/index.js
var loggers = {};
loggers = getLoggers(log_default);
function register(handlers) {
	loggers = handlers;
}
function debug(eventType, arg1, arg2, arg3) {
	if (log_default.level > 0 && loggers[eventType]) loggers[eventType].call(null, arg1, arg2, arg3);
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/lib/utils/assert.js
function assert$3(condition, message) {
	if (!condition) throw new Error(message || "shadertools: assertion failed.");
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/lib/filters/prop-types.js
/** Minimal validators for number and array types */
var DEFAULT_PROP_VALIDATORS = {
	number: {
		type: "number",
		validate(value, propType) {
			return Number.isFinite(value) && typeof propType === "object" && (propType.max === void 0 || value <= propType.max) && (propType.min === void 0 || value >= propType.min);
		}
	},
	array: {
		type: "array",
		validate(value, propType) {
			return Array.isArray(value) || ArrayBuffer.isView(value);
		}
	}
};
/**
* Parse a list of property types into property definitions that can be used to validate
* values passed in by applications.
* @param propTypes
* @returns
*/
function makePropValidators(propTypes) {
	const propValidators = {};
	for (const [name, propType] of Object.entries(propTypes)) propValidators[name] = makePropValidator(propType);
	return propValidators;
}
/**
* Creates a property validator for a prop type. Either contains:
* - a valid prop type object ({type, ...})
* - or just a default value, in which case type and name inference is used
*/
function makePropValidator(propType) {
	let type = getTypeOf(propType);
	if (type !== "object") return {
		value: propType,
		...DEFAULT_PROP_VALIDATORS[type],
		type
	};
	if (typeof propType === "object") {
		if (!propType) return {
			type: "object",
			value: null
		};
		if (propType.type !== void 0) return {
			...propType,
			...DEFAULT_PROP_VALIDATORS[propType.type],
			type: propType.type
		};
		if (propType.value === void 0) return {
			type: "object",
			value: propType
		};
		type = getTypeOf(propType.value);
		return {
			...propType,
			...DEFAULT_PROP_VALIDATORS[type],
			type
		};
	}
	throw new Error("props");
}
/**
* "improved" version of javascript typeof that can distinguish arrays and null values
*/
function getTypeOf(value) {
	if (Array.isArray(value) || ArrayBuffer.isView(value)) return "array";
	return typeof value;
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/module-injectors.js
const MODULE_INJECTORS_VS = `\
#ifdef MODULE_LOGDEPTH
  logdepth_adjustPosition(gl_Position);
#endif
`;
const MODULE_INJECTORS_FS = `\
#ifdef MODULE_MATERIAL
  fragColor = material_filterColor(fragColor);
#endif

#ifdef MODULE_LIGHTING
  fragColor = lighting_filterColor(fragColor);
#endif

#ifdef MODULE_FOG
  fragColor = fog_filterColor(fragColor);
#endif

#ifdef MODULE_PICKING
  fragColor = picking_filterHighlightColor(fragColor);
  fragColor = picking_filterPickingColor(fragColor);
#endif

#ifdef MODULE_LOGDEPTH
  logdepth_setFragDepth();
#endif
`;

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/shader-injections.js
var MODULE_INJECTORS = {
	vertex: MODULE_INJECTORS_VS,
	fragment: MODULE_INJECTORS_FS
};
var REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
var REGEX_END_OF_MAIN = /}\n?[^{}]*$/;
var fragments = [];
const DECLARATION_INJECT_MARKER = "__LUMA_INJECT_DECLARATIONS__";
/**
*
*/
function normalizeInjections(injections) {
	const result = {
		vertex: {},
		fragment: {}
	};
	for (const hook in injections) {
		let injection = injections[hook];
		const stage = getHookStage(hook);
		if (typeof injection === "string") injection = {
			order: 0,
			injection
		};
		result[stage][hook] = injection;
	}
	return result;
}
function getHookStage(hook) {
	const type = hook.slice(0, 2);
	switch (type) {
		case "vs": return "vertex";
		case "fs": return "fragment";
		default: throw new Error(type);
	}
}
/**
// A minimal shader injection/templating system.
// RFC: https://github.com/visgl/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/shader-injection-rfc.md
* @param source
* @param type
* @param inject
* @param injectStandardStubs
* @returns
*/
function injectShader(source$2, stage, inject, injectStandardStubs = false) {
	const isVertex = stage === "vertex";
	for (const key in inject) {
		const fragmentData = inject[key];
		fragmentData.sort((a, b) => a.order - b.order);
		fragments.length = fragmentData.length;
		for (let i = 0, len$1 = fragmentData.length; i < len$1; ++i) fragments[i] = fragmentData[i].injection;
		const fragmentString = `${fragments.join("\n")}\n`;
		switch (key) {
			case "vs:#decl":
				if (isVertex) source$2 = source$2.replace(DECLARATION_INJECT_MARKER, fragmentString);
				break;
			case "vs:#main-start":
				if (isVertex) source$2 = source$2.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
				break;
			case "vs:#main-end":
				if (isVertex) source$2 = source$2.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
				break;
			case "fs:#decl":
				if (!isVertex) source$2 = source$2.replace(DECLARATION_INJECT_MARKER, fragmentString);
				break;
			case "fs:#main-start":
				if (!isVertex) source$2 = source$2.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
				break;
			case "fs:#main-end":
				if (!isVertex) source$2 = source$2.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
				break;
			default: source$2 = source$2.replace(key, (match) => match + fragmentString);
		}
	}
	source$2 = source$2.replace(DECLARATION_INJECT_MARKER, "");
	if (injectStandardStubs) source$2 = source$2.replace(/\}\s*$/, (match) => match + MODULE_INJECTORS[stage]);
	return source$2;
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/lib/shader-module/shader-module.js
function initializeShaderModules(modules) {
	modules.map((module) => initializeShaderModule(module));
}
function initializeShaderModule(module) {
	if (module.instance) return;
	initializeShaderModules(module.dependencies || []);
	const { propTypes = {}, deprecations = [], inject = {} } = module;
	const instance = {
		normalizedInjections: normalizeInjections(inject),
		parsedDeprecations: parseDeprecationDefinitions(deprecations)
	};
	if (propTypes) instance.propValidators = makePropValidators(propTypes);
	module.instance = instance;
	let defaultProps = {};
	if (propTypes) defaultProps = Object.entries(propTypes).reduce((obj, [key, propType]) => {
		const value = propType?.value;
		if (value) obj[key] = value;
		return obj;
	}, {});
	module.defaultUniforms = {
		...module.defaultUniforms,
		...defaultProps
	};
}
function checkShaderModuleDeprecations(shaderModule, shaderSource, log$1) {
	shaderModule.deprecations?.forEach((def) => {
		if (def.regex?.test(shaderSource)) if (def.deprecated) log$1.deprecated(def.old, def.new)();
		else log$1.removed(def.old, def.new)();
	});
}
function parseDeprecationDefinitions(deprecations) {
	deprecations.forEach((def) => {
		switch (def.type) {
			case "function":
				def.regex = /* @__PURE__ */ new RegExp(`\\b${def.old}\\(`);
				break;
			default: def.regex = /* @__PURE__ */ new RegExp(`${def.type} ${def.old};`);
		}
	});
	return deprecations;
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/lib/shader-module/shader-module-dependencies.js
/**
* Takes a list of shader module names and returns a new list of
* shader module names that includes all dependencies, sorted so
* that modules that are dependencies of other modules come first.
*
* If the shader glsl code from the returned modules is concatenated
* in the reverse order, it is guaranteed that all functions be resolved and
* that all function and variable definitions come before use.
*
* @param modules - Array of modules (inline modules or module names)
* @return - Array of modules
*/
function getShaderModuleDependencies(modules) {
	initializeShaderModules(modules);
	const moduleMap = {};
	const moduleDepth = {};
	getDependencyGraph({
		modules,
		level: 0,
		moduleMap,
		moduleDepth
	});
	const dependencies = Object.keys(moduleDepth).sort((a, b) => moduleDepth[b] - moduleDepth[a]).map((name) => moduleMap[name]);
	initializeShaderModules(dependencies);
	return dependencies;
}
/**
* Recursively checks module dependencies to calculate dependency level of each module.
*
* @param options.modules - Array of modules
* @param options.level - Current level
* @param options.moduleMap -
* @param options.moduleDepth - Current level
* @return - Map of module name to its level
*/
function getDependencyGraph(options) {
	const { modules, level, moduleMap, moduleDepth } = options;
	if (level >= 5) throw new Error("Possible loop in shader dependency graph");
	for (const module of modules) {
		moduleMap[module.name] = module;
		if (moduleDepth[module.name] === void 0 || moduleDepth[module.name] < level) moduleDepth[module.name] = level;
	}
	for (const module of modules) if (module.dependencies) getDependencyGraph({
		modules: module.dependencies,
		level: level + 1,
		moduleMap,
		moduleDepth
	});
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/platform-defines.js
/** Adds defines to help identify GPU architecture / platform */
function getPlatformShaderDefines(platformInfo) {
	switch (platformInfo?.gpu.toLowerCase()) {
		case "apple": return `\
#define APPLE_GPU
// Apple optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
		case "nvidia": return `\
#define NVIDIA_GPU
// Nvidia optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`;
		case "intel": return `\
#define INTEL_GPU
// Intel optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Intel's built-in 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
		case "amd": return `\
#define AMD_GPU
`;
		default: return `\
#define DEFAULT_GPU
// Prevent driver from optimizing away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Headless Chrome's software shader 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// If the GPU doesn't have full 32 bits precision, will causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
	}
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/lib/shader-transpiler/transpile-glsl-shader.js
/**
* Transpiles GLSL 3.00 shader source code to target GLSL version (3.00 or 1.00)
*
* @note We always run transpiler even if same version e.g. 3.00 => 3.00
* @note For texture sampling transpilation, apps need to use non-standard texture* calls in GLSL 3.00 source
* RFC: https://github.com/visgl/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/portable-glsl-300-rfc.md
*/
function transpileGLSLShader(source$2, stage) {
	if (Number(source$2.match(/^#version[ \t]+(\d+)/m)?.[1] || 100) !== 300) throw new Error("luma.gl v9 only supports GLSL 3.00 shader sources");
	switch (stage) {
		case "vertex":
			source$2 = convertShader(source$2, ES300_VERTEX_REPLACEMENTS);
			return source$2;
		case "fragment":
			source$2 = convertShader(source$2, ES300_FRAGMENT_REPLACEMENTS);
			return source$2;
		default: throw new Error(stage);
	}
}
/** Simple regex replacements for GLSL ES 1.00 syntax that has changed in GLSL ES 3.00 */
var ES300_REPLACEMENTS = [
	[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, "#version 300 es\n"],
	[/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("],
	[/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]
];
var ES300_VERTEX_REPLACEMENTS = [
	...ES300_REPLACEMENTS,
	[makeVariableTextRegExp("attribute"), "in $1"],
	[makeVariableTextRegExp("varying"), "out $1"]
];
/** Simple regex replacements for GLSL ES 1.00 syntax that has changed in GLSL ES 3.00 */
var ES300_FRAGMENT_REPLACEMENTS = [...ES300_REPLACEMENTS, [makeVariableTextRegExp("varying"), "in $1"]];
function convertShader(source$2, replacements) {
	for (const [pattern, replacement] of replacements) source$2 = source$2.replace(pattern, replacement);
	return source$2;
}
/**
* Creates a regexp that tests for a specific variable type
* @example
*   should match:
*     in float weight;
*     out vec4 positions[2];
*   should not match:
*     void f(out float a, in float b) {}
*/
function makeVariableTextRegExp(qualifier) {
	return new RegExp(`\\b${qualifier}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`, "g");
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/shader-hooks.js
/** Generate hook source code */
function getShaderHooks(hookFunctions, hookInjections) {
	let result = "";
	for (const hookName in hookFunctions) {
		const hookFunction = hookFunctions[hookName];
		result += `void ${hookFunction.signature} {\n`;
		if (hookFunction.header) result += `  ${hookFunction.header}`;
		if (hookInjections[hookName]) {
			const injections = hookInjections[hookName];
			injections.sort((a, b) => a.order - b.order);
			for (const injection of injections) result += `  ${injection.injection}\n`;
		}
		if (hookFunction.footer) result += `  ${hookFunction.footer}`;
		result += "}\n";
	}
	return result;
}
/**
* Parse string based hook functions
* And split per shader
*/
function normalizeShaderHooks(hookFunctions) {
	const result = {
		vertex: {},
		fragment: {}
	};
	for (const hookFunction of hookFunctions) {
		let opts;
		let hook;
		if (typeof hookFunction !== "string") {
			opts = hookFunction;
			hook = opts.hook;
		} else {
			opts = {};
			hook = hookFunction;
		}
		hook = hook.trim();
		const [shaderStage, signature] = hook.split(":");
		const name = hook.replace(/\(.+/, "");
		const normalizedHook = Object.assign(opts, { signature });
		switch (shaderStage) {
			case "vs":
				result.vertex[name] = normalizedHook;
				break;
			case "fs":
				result.fragment[name] = normalizedHook;
				break;
			default: throw new Error(shaderStage);
		}
	}
	return result;
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/lib/glsl-utils/get-shader-info.js
/** Extracts information from shader source code */
function getShaderInfo(source$2, defaultName) {
	return {
		name: getShaderName(source$2, defaultName),
		language: "glsl",
		version: getShaderVersion(source$2)
	};
}
/** Extracts GLSLIFY style naming of shaders: `#define SHADER_NAME ...` */
function getShaderName(shader, defaultName = "unnamed") {
	const match = /#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/.exec(shader);
	return match ? match[1] : defaultName;
}
/** returns GLSL shader version of given shader string */
function getShaderVersion(source$2) {
	let version$1 = 100;
	const words = source$2.match(/[^\s]+/g);
	if (words && words.length >= 2 && words[0] === "#version") {
		const parsedVersion = parseInt(words[1], 10);
		if (Number.isFinite(parsedVersion)) version$1 = parsedVersion;
	}
	if (version$1 !== 100 && version$1 !== 300) throw new Error(`Invalid GLSL version ${version$1}`);
	return version$1;
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/assemble-shaders.js
var INJECT_SHADER_DECLARATIONS = `\n\n${DECLARATION_INJECT_MARKER}\n`;
/**
* Precision prologue to inject before functions are injected in shader
* TODO - extract any existing prologue in the fragment source and move it up...
*/
var FRAGMENT_SHADER_PROLOGUE = `\
precision highp float;
`;
/**
* Inject a list of shader modules into a single shader source for WGSL
*/
function assembleWGSLShader(options) {
	const modules = getShaderModuleDependencies(options.modules || []);
	return {
		source: assembleShaderWGSL(options.platformInfo, {
			...options,
			source: options.source,
			stage: "vertex",
			modules
		}),
		getUniforms: assembleGetUniforms(modules)
	};
}
/**
* Injects dependent shader module sources into pair of main vertex/fragment shader sources for GLSL
*/
function assembleGLSLShaderPair(options) {
	const { vs: vs$3, fs: fs$2 } = options;
	const modules = getShaderModuleDependencies(options.modules || []);
	return {
		vs: assembleShaderGLSL(options.platformInfo, {
			...options,
			source: vs$3,
			stage: "vertex",
			modules
		}),
		fs: assembleShaderGLSL(options.platformInfo, {
			...options,
			source: fs$2,
			stage: "fragment",
			modules
		}),
		getUniforms: assembleGetUniforms(modules)
	};
}
/**
* Pulls together complete source code for either a vertex or a fragment shader
* adding prologues, requested module chunks, and any final injections.
* @param gl
* @param options
* @returns
*/
function assembleShaderWGSL(platformInfo, options) {
	const { source: source$2, stage, modules, hookFunctions = [], inject = {}, log: log$1 } = options;
	assert$3(typeof source$2 === "string", "shader source must be a string");
	const coreSource = source$2;
	let assembledSource = "";
	const hookFunctionMap = normalizeShaderHooks(hookFunctions);
	const hookInjections = {};
	const declInjections = {};
	const mainInjections = {};
	for (const key in inject) {
		const injection = typeof inject[key] === "string" ? {
			injection: inject[key],
			order: 0
		} : inject[key];
		const match = /^(v|f)s:(#)?([\w-]+)$/.exec(key);
		if (match) {
			const hash = match[2];
			const name = match[3];
			if (hash) if (name === "decl") declInjections[key] = [injection];
			else mainInjections[key] = [injection];
			else hookInjections[key] = [injection];
		} else mainInjections[key] = [injection];
	}
	const modulesToInject = modules;
	for (const module of modulesToInject) {
		if (log$1) checkShaderModuleDeprecations(module, coreSource, log$1);
		const moduleSource = getShaderModuleSource(module, "wgsl");
		assembledSource += moduleSource;
		const injections = module.injections?.[stage] || {};
		for (const key in injections) {
			const match = /^(v|f)s:#([\w-]+)$/.exec(key);
			if (match) {
				const injectionType = match[2] === "decl" ? declInjections : mainInjections;
				injectionType[key] = injectionType[key] || [];
				injectionType[key].push(injections[key]);
			} else {
				hookInjections[key] = hookInjections[key] || [];
				hookInjections[key].push(injections[key]);
			}
		}
	}
	assembledSource += INJECT_SHADER_DECLARATIONS;
	assembledSource = injectShader(assembledSource, stage, declInjections);
	assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);
	assembledSource += coreSource;
	assembledSource = injectShader(assembledSource, stage, mainInjections);
	return assembledSource;
}
/**
* Pulls together complete source code for either a vertex or a fragment shader
* adding prologues, requested module chunks, and any final injections.
* @param gl
* @param options
* @returns
*/
function assembleShaderGLSL(platformInfo, options) {
	const { source: source$2, stage, language = "glsl", modules, defines: defines$1 = {}, hookFunctions = [], inject = {}, prologue = true, log: log$1 } = options;
	assert$3(typeof source$2 === "string", "shader source must be a string");
	const sourceVersion = language === "glsl" ? getShaderInfo(source$2).version : -1;
	const targetVersion = platformInfo.shaderLanguageVersion;
	const sourceVersionDirective = sourceVersion === 100 ? "#version 100" : "#version 300 es";
	const coreSource = source$2.split("\n").slice(1).join("\n");
	const allDefines = {};
	modules.forEach((module) => {
		Object.assign(allDefines, module.defines);
	});
	Object.assign(allDefines, defines$1);
	let assembledSource = "";
	switch (language) {
		case "wgsl": break;
		case "glsl":
			assembledSource = prologue ? `\
${sourceVersionDirective}

// ----- PROLOGUE -------------------------
${`#define SHADER_TYPE_${stage.toUpperCase()}`}

${getPlatformShaderDefines(platformInfo)}
${stage === "fragment" ? FRAGMENT_SHADER_PROLOGUE : ""}

// ----- APPLICATION DEFINES -------------------------

${getApplicationDefines(allDefines)}

` : `${sourceVersionDirective}
`;
			break;
	}
	const hookFunctionMap = normalizeShaderHooks(hookFunctions);
	const hookInjections = {};
	const declInjections = {};
	const mainInjections = {};
	for (const key in inject) {
		const injection = typeof inject[key] === "string" ? {
			injection: inject[key],
			order: 0
		} : inject[key];
		const match = /^(v|f)s:(#)?([\w-]+)$/.exec(key);
		if (match) {
			const hash = match[2];
			const name = match[3];
			if (hash) if (name === "decl") declInjections[key] = [injection];
			else mainInjections[key] = [injection];
			else hookInjections[key] = [injection];
		} else mainInjections[key] = [injection];
	}
	for (const module of modules) {
		if (log$1) checkShaderModuleDeprecations(module, coreSource, log$1);
		const moduleSource = getShaderModuleSource(module, stage);
		assembledSource += moduleSource;
		const injections = module.instance?.normalizedInjections[stage] || {};
		for (const key in injections) {
			const match = /^(v|f)s:#([\w-]+)$/.exec(key);
			if (match) {
				const injectionType = match[2] === "decl" ? declInjections : mainInjections;
				injectionType[key] = injectionType[key] || [];
				injectionType[key].push(injections[key]);
			} else {
				hookInjections[key] = hookInjections[key] || [];
				hookInjections[key].push(injections[key]);
			}
		}
	}
	assembledSource += "// ----- MAIN SHADER SOURCE -------------------------";
	assembledSource += INJECT_SHADER_DECLARATIONS;
	assembledSource = injectShader(assembledSource, stage, declInjections);
	assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);
	assembledSource += coreSource;
	assembledSource = injectShader(assembledSource, stage, mainInjections);
	if (language === "glsl" && sourceVersion !== targetVersion) assembledSource = transpileGLSLShader(assembledSource, stage);
	return assembledSource.trim();
}
/**
* Returns a combined `getUniforms` covering the options for all the modules,
* the created function will pass on options to the inidividual `getUniforms`
* function of each shader module and combine the results into one object that
* can be passed to setUniforms.
* @param modules
* @returns
*/
function assembleGetUniforms(modules) {
	return function getUniforms$2(opts) {
		const uniforms = {};
		for (const module of modules) {
			const moduleUniforms = module.getUniforms?.(opts, uniforms);
			Object.assign(uniforms, moduleUniforms);
		}
		return uniforms;
	};
}
/**
* NOTE: Removed as id injection defeated caching of shaders
*
* Generate "glslify-compatible" SHADER_NAME defines
* These are understood by the GLSL error parsing function
* If id is provided and no SHADER_NAME constant is present in source, create one
unction getShaderNameDefine(options: {
id?: string;
source: string;
stage: 'vertex' | 'fragment';
}): string {
const {id, source, stage} = options;
const injectShaderName = id && source.indexOf('SHADER_NAME') === -1;
return injectShaderName
? `
#define SHADER_NAME ${id}_${stage}`
: '';
}
*/
/** Generates application defines from an object of key value pairs */
function getApplicationDefines(defines$1 = {}) {
	let sourceText = "";
	for (const define in defines$1) {
		const value = defines$1[define];
		if (value || Number.isFinite(value)) sourceText += `#define ${define.toUpperCase()} ${defines$1[define]}\n`;
	}
	return sourceText;
}
/** Extracts the source code chunk for the specified shader type from the named shader module */
function getShaderModuleSource(module, stage) {
	let moduleSource;
	switch (stage) {
		case "vertex":
			moduleSource = module.vs || "";
			break;
		case "fragment":
			moduleSource = module.fs || "";
			break;
		case "wgsl":
			moduleSource = module.source || "";
			break;
		default: assert$3(false);
	}
	if (!module.name) throw new Error("Shader module must have a name");
	const moduleName = module.name.toUpperCase().replace(/[^0-9a-z]/gi, "_");
	let source$2 = `\
// ----- MODULE ${module.name} ---------------

`;
	if (stage !== "wgsl") source$2 += `#define MODULE_${moduleName}\n`;
	source$2 += `${moduleSource}\n`;
	return source$2;
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/lib/preprocessor/preprocessor.js
var IFDEF_REGEXP = /^\s*\#\s*ifdef\s*([a-zA-Z_]+)\s*$/;
var ENDIF_REGEXP = /^\s*\#\s*endif\s*$/;
function preprocess(source$2, options) {
	const lines = source$2.split("\n");
	const output = [];
	let conditional = true;
	let currentDefine = null;
	for (const line of lines) {
		const matchIf = line.match(IFDEF_REGEXP);
		const matchEnd = line.match(ENDIF_REGEXP);
		if (matchIf) {
			currentDefine = matchIf[1];
			conditional = Boolean(options?.defines?.[currentDefine]);
		} else if (matchEnd) conditional = true;
		else if (conditional) output.push(line);
	}
	return output.join("\n");
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/lib/shader-assembler.js
/**
* A stateful version of `assembleShaders` that can be used to assemble shaders.
* Supports setting of default modules and hooks.
*/
var ShaderAssembler = class ShaderAssembler {
	/** Default ShaderAssembler instance */
	static defaultShaderAssembler;
	/** Hook functions */
	_hookFunctions = [];
	/** Shader modules */
	_defaultModules = [];
	/**
	* A default shader assembler instance - the natural place to register default modules and hooks
	* @returns
	*/
	static getDefaultShaderAssembler() {
		ShaderAssembler.defaultShaderAssembler = ShaderAssembler.defaultShaderAssembler || new ShaderAssembler();
		return ShaderAssembler.defaultShaderAssembler;
	}
	/**
	* Add a default module that does not have to be provided with every call to assembleShaders()
	*/
	addDefaultModule(module) {
		if (!this._defaultModules.find((m) => m.name === (typeof module === "string" ? module : module.name))) this._defaultModules.push(module);
	}
	/**
	* Remove a default module
	*/
	removeDefaultModule(module) {
		const moduleName = typeof module === "string" ? module : module.name;
		this._defaultModules = this._defaultModules.filter((m) => m.name !== moduleName);
	}
	/**
	* Register a shader hook
	* @param hook
	* @param opts
	*/
	addShaderHook(hook, opts) {
		if (opts) hook = Object.assign(opts, { hook });
		this._hookFunctions.push(hook);
	}
	/**
	* Assemble a WGSL unified shader
	* @param platformInfo
	* @param props
	* @returns
	*/
	assembleWGSLShader(props) {
		const modules = this._getModuleList(props.modules);
		const hookFunctions = this._hookFunctions;
		const { source: source$2, getUniforms: getUniforms$2 } = assembleWGSLShader({
			...props,
			source: props.source,
			modules,
			hookFunctions
		});
		return {
			source: props.platformInfo.shaderLanguage === "wgsl" ? preprocess(source$2) : source$2,
			getUniforms: getUniforms$2,
			modules
		};
	}
	/**
	* Assemble a pair of shaders into a single shader program
	* @param platformInfo
	* @param props
	* @returns
	*/
	assembleGLSLShaderPair(props) {
		const modules = this._getModuleList(props.modules);
		const hookFunctions = this._hookFunctions;
		return {
			...assembleGLSLShaderPair({
				...props,
				vs: props.vs,
				fs: props.fs,
				modules,
				hookFunctions
			}),
			modules
		};
	}
	/**
	* Dedupe and combine with default modules
	*/
	_getModuleList(appModules = []) {
		const modules = new Array(this._defaultModules.length + appModules.length);
		const seen = {};
		let count = 0;
		for (let i = 0, len$1 = this._defaultModules.length; i < len$1; ++i) {
			const module = this._defaultModules[i];
			const name = module.name;
			modules[count++] = module;
			seen[name] = true;
		}
		for (let i = 0, len$1 = appModules.length; i < len$1; ++i) {
			const module = appModules[i];
			const name = module.name;
			if (!seen[name]) {
				modules[count++] = module;
				seen[name] = true;
			}
		}
		modules.length = count;
		initializeShaderModules(modules);
		return modules;
	}
};

//#endregion
//#region node_modules/@math.gl/core/dist/lib/common.js
var RADIANS_TO_DEGREES$1 = 1 / Math.PI * 180;
var DEGREES_TO_RADIANS$3 = 1 / 180 * Math.PI;
var DEFAULT_CONFIG = {
	EPSILON: 1e-12,
	debug: false,
	precision: 4,
	printTypes: false,
	printDegrees: false,
	printRowMajor: true,
	_cartographicRadians: false
};
globalThis.mathgl = globalThis.mathgl || { config: { ...DEFAULT_CONFIG } };
const config = globalThis.mathgl.config;
/**
* Formats a value into a string
* @param value
* @param param1
* @returns
*/
function formatValue(value, { precision = config.precision } = {}) {
	value = round(value);
	return `${parseFloat(value.toPrecision(precision))}`;
}
/**
* Check if value is an "array"
* Returns `true` if value is either an array or a typed array
* Note: returns `false` for `ArrayBuffer` and `DataView` instances
* @note isTypedArray and isNumericArray are often more useful in TypeScript
*/
function isArray(value) {
	return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
}
function clamp(value, min, max) {
	return map(value, (value$1) => Math.max(min, Math.min(max, value$1)));
}
function lerp$2(a, b, t) {
	if (isArray(a)) return a.map((ai, i) => lerp$2(ai, b[i], t));
	return t * b + (1 - t) * a;
}
/**
* Compares any two math objects, using `equals` method if available.
* @param a
* @param b
* @param epsilon
* @returns
*/
function equals(a, b, epsilon) {
	const oldEpsilon = config.EPSILON;
	if (epsilon) config.EPSILON = epsilon;
	try {
		if (a === b) return true;
		if (isArray(a) && isArray(b)) {
			if (a.length !== b.length) return false;
			for (let i = 0; i < a.length; ++i) if (!equals(a[i], b[i])) return false;
			return true;
		}
		if (a && a.equals) return a.equals(b);
		if (b && b.equals) return b.equals(a);
		if (typeof a === "number" && typeof b === "number") return Math.abs(a - b) <= config.EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
		return false;
	} finally {
		config.EPSILON = oldEpsilon;
	}
}
function round(value) {
	return Math.round(value / config.EPSILON) * config.EPSILON;
}
function duplicateArray(array) {
	return array.clone ? array.clone() : new Array(array.length);
}
function map(value, func, result) {
	if (isArray(value)) {
		const array = value;
		result = result || duplicateArray(array);
		for (let i = 0; i < result.length && i < array.length; ++i) result[i] = func(typeof value === "number" ? value : value[i], i, result);
		return result;
	}
	return func(value);
}

//#endregion
//#region node_modules/@math.gl/core/dist/classes/base/math-array.js
/** Base class for vectors and matrices */
var MathArray = class extends Array {
	/**
	* Clone the current object
	* @returns a new copy of this object
	*/
	clone() {
		return new this.constructor().copy(this);
	}
	fromArray(array, offset = 0) {
		for (let i = 0; i < this.ELEMENTS; ++i) this[i] = array[i + offset];
		return this.check();
	}
	toArray(targetArray = [], offset = 0) {
		for (let i = 0; i < this.ELEMENTS; ++i) targetArray[offset + i] = this[i];
		return targetArray;
	}
	toObject(targetObject) {
		return targetObject;
	}
	from(arrayOrObject) {
		return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : this.fromObject(arrayOrObject);
	}
	to(arrayOrObject) {
		if (arrayOrObject === this) return this;
		return isArray(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
	}
	toTarget(target) {
		return target ? this.to(target) : this;
	}
	/** @deprecated */
	toFloat32Array() {
		return new Float32Array(this);
	}
	toString() {
		return this.formatString(config);
	}
	/** Formats string according to options */
	formatString(opts) {
		let string = "";
		for (let i = 0; i < this.ELEMENTS; ++i) string += (i > 0 ? ", " : "") + formatValue(this[i], opts);
		return `${opts.printTypes ? this.constructor.name : ""}[${string}]`;
	}
	equals(array) {
		if (!array || this.length !== array.length) return false;
		for (let i = 0; i < this.ELEMENTS; ++i) if (!equals(this[i], array[i])) return false;
		return true;
	}
	exactEquals(array) {
		if (!array || this.length !== array.length) return false;
		for (let i = 0; i < this.ELEMENTS; ++i) if (this[i] !== array[i]) return false;
		return true;
	}
	/** Negates all values in this object */
	negate() {
		for (let i = 0; i < this.ELEMENTS; ++i) this[i] = -this[i];
		return this.check();
	}
	lerp(a, b, t) {
		if (t === void 0) return this.lerp(this, a, b);
		for (let i = 0; i < this.ELEMENTS; ++i) {
			const ai = a[i];
			this[i] = ai + t * ((typeof b === "number" ? b : b[i]) - ai);
		}
		return this.check();
	}
	/** Minimal */
	min(vector) {
		for (let i = 0; i < this.ELEMENTS; ++i) this[i] = Math.min(vector[i], this[i]);
		return this.check();
	}
	/** Maximal */
	max(vector) {
		for (let i = 0; i < this.ELEMENTS; ++i) this[i] = Math.max(vector[i], this[i]);
		return this.check();
	}
	clamp(minVector, maxVector) {
		for (let i = 0; i < this.ELEMENTS; ++i) this[i] = Math.min(Math.max(this[i], minVector[i]), maxVector[i]);
		return this.check();
	}
	add(...vectors) {
		for (const vector of vectors) for (let i = 0; i < this.ELEMENTS; ++i) this[i] += vector[i];
		return this.check();
	}
	subtract(...vectors) {
		for (const vector of vectors) for (let i = 0; i < this.ELEMENTS; ++i) this[i] -= vector[i];
		return this.check();
	}
	scale(scale$2) {
		if (typeof scale$2 === "number") for (let i = 0; i < this.ELEMENTS; ++i) this[i] *= scale$2;
		else for (let i = 0; i < this.ELEMENTS && i < scale$2.length; ++i) this[i] *= scale$2[i];
		return this.check();
	}
	/**
	* Multiplies all elements by `scale`
	* Note: `Matrix4.multiplyByScalar` only scales its 3x3 "minor"
	*/
	multiplyByScalar(scalar) {
		for (let i = 0; i < this.ELEMENTS; ++i) this[i] *= scalar;
		return this.check();
	}
	/** Throws an error if array length is incorrect or contains illegal values */
	check() {
		if (config.debug && !this.validate()) throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
		return this;
	}
	/** Returns false if the array length is incorrect or contains illegal values */
	validate() {
		let valid = this.length === this.ELEMENTS;
		for (let i = 0; i < this.ELEMENTS; ++i) valid = valid && Number.isFinite(this[i]);
		return valid;
	}
	/** @deprecated */
	sub(a) {
		return this.subtract(a);
	}
	/** @deprecated */
	setScalar(a) {
		for (let i = 0; i < this.ELEMENTS; ++i) this[i] = a;
		return this.check();
	}
	/** @deprecated */
	addScalar(a) {
		for (let i = 0; i < this.ELEMENTS; ++i) this[i] += a;
		return this.check();
	}
	/** @deprecated */
	subScalar(a) {
		return this.addScalar(-a);
	}
	/** @deprecated */
	multiplyScalar(scalar) {
		for (let i = 0; i < this.ELEMENTS; ++i) this[i] *= scalar;
		return this.check();
	}
	/** @deprecated */
	divideScalar(a) {
		return this.multiplyByScalar(1 / a);
	}
	/** @deprecated */
	clampScalar(min, max) {
		for (let i = 0; i < this.ELEMENTS; ++i) this[i] = Math.min(Math.max(this[i], min), max);
		return this.check();
	}
	/** @deprecated */
	get elements() {
		return this;
	}
};

//#endregion
//#region node_modules/@math.gl/core/dist/lib/validators.js
function validateVector(v, length$1) {
	if (v.length !== length$1) return false;
	for (let i = 0; i < v.length; ++i) if (!Number.isFinite(v[i])) return false;
	return true;
}
function checkNumber(value) {
	if (!Number.isFinite(value)) throw new Error(`Invalid number ${JSON.stringify(value)}`);
	return value;
}
function checkVector(v, length$1, callerName = "") {
	if (config.debug && !validateVector(v, length$1)) throw new Error(`math.gl: ${callerName} some fields set to invalid numbers'`);
	return v;
}

//#endregion
//#region node_modules/@math.gl/core/dist/lib/assert.js
function assert$2(condition, message) {
	if (!condition) throw new Error(`math.gl assertion ${message}`);
}

//#endregion
//#region node_modules/@math.gl/core/dist/classes/base/vector.js
/** Base class for vectors with at least 2 elements */
var Vector = class extends MathArray {
	get x() {
		return this[0];
	}
	set x(value) {
		this[0] = checkNumber(value);
	}
	get y() {
		return this[1];
	}
	set y(value) {
		this[1] = checkNumber(value);
	}
	/**
	* Returns the length of the vector from the origin to the point described by this vector
	*
	* @note `length` is a reserved word for Arrays, so `v.length()` will return number of elements
	* Instead we provide `len` and `magnitude`
	*/
	len() {
		return Math.sqrt(this.lengthSquared());
	}
	/**
	* Returns the length of the vector from the origin to the point described by this vector
	*/
	magnitude() {
		return this.len();
	}
	/**
	* Returns the squared length of the vector from the origin to the point described by this vector
	*/
	lengthSquared() {
		let length$1 = 0;
		for (let i = 0; i < this.ELEMENTS; ++i) length$1 += this[i] * this[i];
		return length$1;
	}
	/**
	* Returns the squared length of the vector from the origin to the point described by this vector
	*/
	magnitudeSquared() {
		return this.lengthSquared();
	}
	distance(mathArray) {
		return Math.sqrt(this.distanceSquared(mathArray));
	}
	distanceSquared(mathArray) {
		let length$1 = 0;
		for (let i = 0; i < this.ELEMENTS; ++i) {
			const dist = this[i] - mathArray[i];
			length$1 += dist * dist;
		}
		return checkNumber(length$1);
	}
	dot(mathArray) {
		let product = 0;
		for (let i = 0; i < this.ELEMENTS; ++i) product += this[i] * mathArray[i];
		return checkNumber(product);
	}
	normalize() {
		const length$1 = this.magnitude();
		if (length$1 !== 0) for (let i = 0; i < this.ELEMENTS; ++i) this[i] /= length$1;
		return this.check();
	}
	multiply(...vectors) {
		for (const vector of vectors) for (let i = 0; i < this.ELEMENTS; ++i) this[i] *= vector[i];
		return this.check();
	}
	divide(...vectors) {
		for (const vector of vectors) for (let i = 0; i < this.ELEMENTS; ++i) this[i] /= vector[i];
		return this.check();
	}
	lengthSq() {
		return this.lengthSquared();
	}
	distanceTo(vector) {
		return this.distance(vector);
	}
	distanceToSquared(vector) {
		return this.distanceSquared(vector);
	}
	getComponent(i) {
		assert$2(i >= 0 && i < this.ELEMENTS, "index is out of range");
		return checkNumber(this[i]);
	}
	setComponent(i, value) {
		assert$2(i >= 0 && i < this.ELEMENTS, "index is out of range");
		this[i] = value;
		return this.check();
	}
	addVectors(a, b) {
		return this.copy(a).add(b);
	}
	subVectors(a, b) {
		return this.copy(a).subtract(b);
	}
	multiplyVectors(a, b) {
		return this.copy(a).multiply(b);
	}
	addScaledVector(a, b) {
		return this.add(new this.constructor(a).multiplyScalar(b));
	}
};

//#endregion
//#region node_modules/@math.gl/core/dist/gl-matrix/common.js
/**
* Common utilities
* @module glMatrix
*/
const EPSILON = 1e-6;
let ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var degree = Math.PI / 180;

//#endregion
//#region node_modules/@math.gl/core/dist/gl-matrix/vec2.js
/**
* 2 Dimensional Vector
* @module vec2
*/
/**
* Creates a new, empty vec2
*
* @returns a new 2D vector
*/
function create$2() {
	const out = new ARRAY_TYPE(2);
	if (ARRAY_TYPE != Float32Array) {
		out[0] = 0;
		out[1] = 0;
	}
	return out;
}
/**
* Adds two vec2's
*
* @param {NumericArray} out the receiving vector
* @param {Readonly<NumericArray>} a the first operand
* @param {Readonly<NumericArray>} b the second operand
* @returns {NumericArray} out
*/
function add(out, a, b) {
	out[0] = a[0] + b[0];
	out[1] = a[1] + b[1];
	return out;
}
/**
* Negates the components of a vec2
*
* @param {NumericArray} out the receiving vector
* @param {Readonly<NumericArray>} a vector to negate
* @returns {NumericArray} out
*/
function negate$1(out, a) {
	out[0] = -a[0];
	out[1] = -a[1];
	return out;
}
/**
* Performs a linear interpolation between two vec2's
*
* @param {NumericArray} out the receiving vector
* @param {Readonly<NumericArray>} a the first operand
* @param {Readonly<NumericArray>} b the second operand
* @param {Number} t interpolation amount, in the range [0-1], between the two inputs
* @returns {NumericArray} out
*/
function lerp$1(out, a, b, t) {
	const ax = a[0];
	const ay = a[1];
	out[0] = ax + t * (b[0] - ax);
	out[1] = ay + t * (b[1] - ay);
	return out;
}
/**
* Transforms the vec2 with a mat4
* 3rd vector component is implicitly '0'
* 4th vector component is implicitly '1'
*
* @param {NumericArray} out the receiving vector
* @param {Readonly<NumericArray>} a the vector to transform
* @param {ReadonlyMat4} m matrix to transform with
* @returns {NumericArray} out
*/
function transformMat4(out, a, m) {
	const x = a[0];
	const y = a[1];
	out[0] = m[0] * x + m[4] * y + m[12];
	out[1] = m[1] * x + m[5] * y + m[13];
	return out;
}
/**
* Perform some operation over an array of vec2s.
*
* @param {Array} a the array of vectors to iterate over
* @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
* @param {Number} offset Number of elements to skip at the beginning of the array
* @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
* @param {Function} fn Function to call for each vector in the array
* @param {Object} [arg] additional argument to pass to fn
* @returns {Array} a
* @function
*/
const forEach$2 = (function() {
	const vec = create$2();
	return function(a, stride, offset, count, fn, arg) {
		let i;
		let l;
		if (!stride) stride = 2;
		if (!offset) offset = 0;
		if (count) l = Math.min(count * stride + offset, a.length);
		else l = a.length;
		for (i = offset; i < l; i += stride) {
			vec[0] = a[i];
			vec[1] = a[i + 1];
			fn(vec, vec, arg);
			a[i] = vec[0];
			a[i + 1] = vec[1];
		}
		return a;
	};
})();

//#endregion
//#region node_modules/@math.gl/core/dist/lib/gl-matrix-extras.js
function vec2_transformMat4AsVector(out, a, m) {
	const x = a[0];
	const y = a[1];
	const w = m[3] * x + m[7] * y || 1;
	out[0] = (m[0] * x + m[4] * y) / w;
	out[1] = (m[1] * x + m[5] * y) / w;
	return out;
}
function vec3_transformMat4AsVector(out, a, m) {
	const x = a[0];
	const y = a[1];
	const z = a[2];
	const w = m[3] * x + m[7] * y + m[11] * z || 1;
	out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;
	out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;
	out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;
	return out;
}
function vec3_transformMat2(out, a, m) {
	const x = a[0];
	const y = a[1];
	out[0] = m[0] * x + m[2] * y;
	out[1] = m[1] * x + m[3] * y;
	out[2] = a[2];
	return out;
}

//#endregion
//#region node_modules/@math.gl/core/dist/gl-matrix/vec3.js
/**
* 3 Dimensional Vector
* @module vec3
*/
/**
* Creates a new, empty vec3
*
* @returns {vec3} a new 3D vector
*/
function create$1() {
	const out = new ARRAY_TYPE(3);
	if (ARRAY_TYPE != Float32Array) {
		out[0] = 0;
		out[1] = 0;
		out[2] = 0;
	}
	return out;
}
/**
* Calculates the length of a vec3
*
* @param {ReadonlyVec3} a vector to calculate length of
* @returns {Number} length of a
*/
function length(a) {
	const x = a[0];
	const y = a[1];
	const z = a[2];
	return Math.sqrt(x * x + y * y + z * z);
}
/**
* Subtracts vector b from vector a
*
* @param {vec3} out the receiving vector
* @param {ReadonlyVec3} a the first operand
* @param {ReadonlyVec3} b the second operand
* @returns {vec3} out
*/
function subtract(out, a, b) {
	out[0] = a[0] - b[0];
	out[1] = a[1] - b[1];
	out[2] = a[2] - b[2];
	return out;
}
/**
* Calculates the squared length of a vec3
*
* @param {ReadonlyVec3} a vector to calculate squared length of
* @returns {Number} squared length of a
*/
function squaredLength(a) {
	const x = a[0];
	const y = a[1];
	const z = a[2];
	return x * x + y * y + z * z;
}
/**
* Negates the components of a vec3
*
* @param {vec3} out the receiving vector
* @param {ReadonlyVec3} a vector to negate
* @returns {vec3} out
*/
function negate(out, a) {
	out[0] = -a[0];
	out[1] = -a[1];
	out[2] = -a[2];
	return out;
}
/**
* Calculates the dot product of two vec3's
*
* @param {ReadonlyVec3} a the first operand
* @param {ReadonlyVec3} b the second operand
* @returns {Number} dot product of a and b
*/
function dot(a, b) {
	return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
* Computes the cross product of two vec3's
*
* @param {vec3} out the receiving vector
* @param {ReadonlyVec3} a the first operand
* @param {ReadonlyVec3} b the second operand
* @returns {vec3} out
*/
function cross(out, a, b) {
	const ax = a[0];
	const ay = a[1];
	const az = a[2];
	const bx = b[0];
	const by = b[1];
	const bz = b[2];
	out[0] = ay * bz - az * by;
	out[1] = az * bx - ax * bz;
	out[2] = ax * by - ay * bx;
	return out;
}
/**
* Performs a linear interpolation between two vec3's
*
* @param {vec3} out the receiving vector
* @param {ReadonlyVec3} a the first operand
* @param {ReadonlyVec3} b the second operand
* @param {Number} t interpolation amount, in the range [0-1], between the two inputs
* @returns {vec3} out
*/
function lerp(out, a, b, t) {
	const ax = a[0];
	const ay = a[1];
	const az = a[2];
	out[0] = ax + t * (b[0] - ax);
	out[1] = ay + t * (b[1] - ay);
	out[2] = az + t * (b[2] - az);
	return out;
}
/**
* Transforms the vec3 with a mat4.
* 4th vector component is implicitly '1'
*
* @param {vec3} out the receiving vector
* @param {ReadonlyVec3} a the vector to transform
* @param {ReadonlyMat4} m matrix to transform with
* @returns {vec3} out
*/
function transformMat4$1(out, a, m) {
	const x = a[0];
	const y = a[1];
	const z = a[2];
	let w = m[3] * x + m[7] * y + m[11] * z + m[15];
	w = w || 1;
	out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
	out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
	out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
	return out;
}
/**
* Transforms the vec3 with a mat3.
*
* @param {vec3} out the receiving vector
* @param {ReadonlyVec3} a the vector to transform
* @param {ReadonlyMat3} m the 3x3 matrix to transform with
* @returns {vec3} out
*/
function transformMat3(out, a, m) {
	const x = a[0];
	const y = a[1];
	const z = a[2];
	out[0] = x * m[0] + y * m[3] + z * m[6];
	out[1] = x * m[1] + y * m[4] + z * m[7];
	out[2] = x * m[2] + y * m[5] + z * m[8];
	return out;
}
/**
* Transforms the vec3 with a quat
* Can also be used for dual quaternions. (Multiply it with the real part)
*
* @param {vec3} out the receiving vector
* @param {ReadonlyVec3} a the vector to transform
* @param {ReadonlyQuat} q quaternion to transform with
* @returns {vec3} out
*/
function transformQuat(out, a, q) {
	const qx = q[0];
	const qy = q[1];
	const qz = q[2];
	const qw = q[3];
	const x = a[0];
	const y = a[1];
	const z = a[2];
	let uvx = qy * z - qz * y;
	let uvy = qz * x - qx * z;
	let uvz = qx * y - qy * x;
	let uuvx = qy * uvz - qz * uvy;
	let uuvy = qz * uvx - qx * uvz;
	let uuvz = qx * uvy - qy * uvx;
	const w2 = qw * 2;
	uvx *= w2;
	uvy *= w2;
	uvz *= w2;
	uuvx *= 2;
	uuvy *= 2;
	uuvz *= 2;
	out[0] = x + uvx + uuvx;
	out[1] = y + uvy + uuvy;
	out[2] = z + uvz + uuvz;
	return out;
}
/**
* Rotate a 3D vector around the x-axis
* @param {vec3} out The receiving vec3
* @param {ReadonlyVec3} a The vec3 point to rotate
* @param {ReadonlyVec3} b The origin of the rotation
* @param {Number} rad The angle of rotation in radians
* @returns {vec3} out
*/
function rotateX$1(out, a, b, rad) {
	const p = [];
	const r = [];
	p[0] = a[0] - b[0];
	p[1] = a[1] - b[1];
	p[2] = a[2] - b[2];
	r[0] = p[0];
	r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
	r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
	out[0] = r[0] + b[0];
	out[1] = r[1] + b[1];
	out[2] = r[2] + b[2];
	return out;
}
/**
* Rotate a 3D vector around the y-axis
* @param {vec3} out The receiving vec3
* @param {ReadonlyVec3} a The vec3 point to rotate
* @param {ReadonlyVec3} b The origin of the rotation
* @param {Number} rad The angle of rotation in radians
* @returns {vec3} out
*/
function rotateY$1(out, a, b, rad) {
	const p = [];
	const r = [];
	p[0] = a[0] - b[0];
	p[1] = a[1] - b[1];
	p[2] = a[2] - b[2];
	r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
	r[1] = p[1];
	r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
	out[0] = r[0] + b[0];
	out[1] = r[1] + b[1];
	out[2] = r[2] + b[2];
	return out;
}
/**
* Rotate a 3D vector around the z-axis
* @param {vec3} out The receiving vec3
* @param {ReadonlyVec3} a The vec3 point to rotate
* @param {ReadonlyVec3} b The origin of the rotation
* @param {Number} rad The angle of rotation in radians
* @returns {vec3} out
*/
function rotateZ$1(out, a, b, rad) {
	const p = [];
	const r = [];
	p[0] = a[0] - b[0];
	p[1] = a[1] - b[1];
	p[2] = a[2] - b[2];
	r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
	r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
	r[2] = p[2];
	out[0] = r[0] + b[0];
	out[1] = r[1] + b[1];
	out[2] = r[2] + b[2];
	return out;
}
/**
* Get the angle between two 3D vectors
* @param {ReadonlyVec3} a The first operand
* @param {ReadonlyVec3} b The second operand
* @returns {Number} The angle in radians
*/
function angle(a, b) {
	const ax = a[0];
	const ay = a[1];
	const az = a[2];
	const bx = b[0];
	const by = b[1];
	const bz = b[2];
	const mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz));
	const cosine = mag && dot(a, b) / mag;
	return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
* Alias for {@link vec3.subtract}
* @function
*/
const sub = subtract;
/**
* Alias for {@link vec3.length}
* @function
*/
const len = length;
/**
* Alias for {@link vec3.squaredLength}
* @function
*/
const sqrLen = squaredLength;
/**
* Perform some operation over an array of vec3s.
*
* @param {Array} a the array of vectors to iterate over
* @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
* @param {Number} offset Number of elements to skip at the beginning of the array
* @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
* @param {Function} fn Function to call for each vector in the array
* @param {Object} [arg] additional argument to pass to fn
* @returns {Array} a
* @function
*/
const forEach$1 = (function() {
	const vec = create$1();
	return function(a, stride, offset, count, fn, arg) {
		let i;
		let l;
		if (!stride) stride = 3;
		if (!offset) offset = 0;
		if (count) l = Math.min(count * stride + offset, a.length);
		else l = a.length;
		for (i = offset; i < l; i += stride) {
			vec[0] = a[i];
			vec[1] = a[i + 1];
			vec[2] = a[i + 2];
			fn(vec, vec, arg);
			a[i] = vec[0];
			a[i + 1] = vec[1];
			a[i + 2] = vec[2];
		}
		return a;
	};
})();

//#endregion
//#region node_modules/@math.gl/core/dist/classes/vector3.js
var ORIGIN = [
	0,
	0,
	0
];
var ZERO$1;
/**
* Three-element vector class with common linear algebra operations.
* Subclass of Array<number> meaning that it is highly compatible with other libraries
*/
var Vector3 = class Vector3 extends Vector {
	static get ZERO() {
		if (!ZERO$1) {
			ZERO$1 = new Vector3(0, 0, 0);
			Object.freeze(ZERO$1);
		}
		return ZERO$1;
	}
	/**
	* @class
	* @param x
	* @param y
	* @param z
	*/
	constructor(x = 0, y = 0, z = 0) {
		super(-0, -0, -0);
		if (arguments.length === 1 && isArray(x)) this.copy(x);
		else {
			if (config.debug) {
				checkNumber(x);
				checkNumber(y);
				checkNumber(z);
			}
			this[0] = x;
			this[1] = y;
			this[2] = z;
		}
	}
	set(x, y, z) {
		this[0] = x;
		this[1] = y;
		this[2] = z;
		return this.check();
	}
	copy(array) {
		this[0] = array[0];
		this[1] = array[1];
		this[2] = array[2];
		return this.check();
	}
	fromObject(object) {
		if (config.debug) {
			checkNumber(object.x);
			checkNumber(object.y);
			checkNumber(object.z);
		}
		this[0] = object.x;
		this[1] = object.y;
		this[2] = object.z;
		return this.check();
	}
	toObject(object) {
		object.x = this[0];
		object.y = this[1];
		object.z = this[2];
		return object;
	}
	get ELEMENTS() {
		return 3;
	}
	get z() {
		return this[2];
	}
	set z(value) {
		this[2] = checkNumber(value);
	}
	angle(vector) {
		return angle(this, vector);
	}
	cross(vector) {
		cross(this, this, vector);
		return this.check();
	}
	rotateX({ radians, origin = ORIGIN }) {
		rotateX$1(this, this, origin, radians);
		return this.check();
	}
	rotateY({ radians, origin = ORIGIN }) {
		rotateY$1(this, this, origin, radians);
		return this.check();
	}
	rotateZ({ radians, origin = ORIGIN }) {
		rotateZ$1(this, this, origin, radians);
		return this.check();
	}
	transform(matrix4) {
		return this.transformAsPoint(matrix4);
	}
	transformAsPoint(matrix4) {
		transformMat4$1(this, this, matrix4);
		return this.check();
	}
	transformAsVector(matrix4) {
		vec3_transformMat4AsVector(this, this, matrix4);
		return this.check();
	}
	transformByMatrix3(matrix3) {
		transformMat3(this, this, matrix3);
		return this.check();
	}
	transformByMatrix2(matrix2) {
		vec3_transformMat2(this, this, matrix2);
		return this.check();
	}
	transformByQuaternion(quaternion) {
		transformQuat(this, this, quaternion);
		return this.check();
	}
};

//#endregion
//#region node_modules/@math.gl/core/dist/classes/base/matrix.js
/** Base class for matrices */
var Matrix = class extends MathArray {
	toString() {
		let string = "[";
		if (config.printRowMajor) {
			string += "row-major:";
			for (let row = 0; row < this.RANK; ++row) for (let col = 0; col < this.RANK; ++col) string += ` ${this[col * this.RANK + row]}`;
		} else {
			string += "column-major:";
			for (let i = 0; i < this.ELEMENTS; ++i) string += ` ${this[i]}`;
		}
		string += "]";
		return string;
	}
	getElementIndex(row, col) {
		return col * this.RANK + row;
	}
	getElement(row, col) {
		return this[col * this.RANK + row];
	}
	setElement(row, col, value) {
		this[col * this.RANK + row] = checkNumber(value);
		return this;
	}
	getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
		const firstIndex = columnIndex * this.RANK;
		for (let i = 0; i < this.RANK; ++i) result[i] = this[firstIndex + i];
		return result;
	}
	setColumn(columnIndex, columnVector) {
		const firstIndex = columnIndex * this.RANK;
		for (let i = 0; i < this.RANK; ++i) this[firstIndex + i] = columnVector[i];
		return this;
	}
};

//#endregion
//#region node_modules/@math.gl/core/dist/gl-matrix/mat4.js
/**
* Set a mat4 to the identity matrix
*
* @param {mat4} out the receiving matrix
* @returns {mat4} out
*/
function identity(out) {
	out[0] = 1;
	out[1] = 0;
	out[2] = 0;
	out[3] = 0;
	out[4] = 0;
	out[5] = 1;
	out[6] = 0;
	out[7] = 0;
	out[8] = 0;
	out[9] = 0;
	out[10] = 1;
	out[11] = 0;
	out[12] = 0;
	out[13] = 0;
	out[14] = 0;
	out[15] = 1;
	return out;
}
/**
* Transpose the values of a mat4
*
* @param {mat4} out the receiving matrix
* @param {ReadonlyMat4} a the source matrix
* @returns {mat4} out
*/
function transpose(out, a) {
	if (out === a) {
		const a01 = a[1];
		const a02 = a[2];
		const a03 = a[3];
		const a12 = a[6];
		const a13 = a[7];
		const a23 = a[11];
		out[1] = a[4];
		out[2] = a[8];
		out[3] = a[12];
		out[4] = a01;
		out[6] = a[9];
		out[7] = a[13];
		out[8] = a02;
		out[9] = a12;
		out[11] = a[14];
		out[12] = a03;
		out[13] = a13;
		out[14] = a23;
	} else {
		out[0] = a[0];
		out[1] = a[4];
		out[2] = a[8];
		out[3] = a[12];
		out[4] = a[1];
		out[5] = a[5];
		out[6] = a[9];
		out[7] = a[13];
		out[8] = a[2];
		out[9] = a[6];
		out[10] = a[10];
		out[11] = a[14];
		out[12] = a[3];
		out[13] = a[7];
		out[14] = a[11];
		out[15] = a[15];
	}
	return out;
}
/**
* Inverts a mat4
*
* @param {mat4} out the receiving matrix
* @param {ReadonlyMat4} a the source matrix
* @returns {mat4} out
*/
function invert(out, a) {
	const a00 = a[0];
	const a01 = a[1];
	const a02 = a[2];
	const a03 = a[3];
	const a10 = a[4];
	const a11 = a[5];
	const a12 = a[6];
	const a13 = a[7];
	const a20 = a[8];
	const a21 = a[9];
	const a22 = a[10];
	const a23 = a[11];
	const a30 = a[12];
	const a31 = a[13];
	const a32 = a[14];
	const a33 = a[15];
	const b00 = a00 * a11 - a01 * a10;
	const b01 = a00 * a12 - a02 * a10;
	const b02 = a00 * a13 - a03 * a10;
	const b03 = a01 * a12 - a02 * a11;
	const b04 = a01 * a13 - a03 * a11;
	const b05 = a02 * a13 - a03 * a12;
	const b06 = a20 * a31 - a21 * a30;
	const b07 = a20 * a32 - a22 * a30;
	const b08 = a20 * a33 - a23 * a30;
	const b09 = a21 * a32 - a22 * a31;
	const b10 = a21 * a33 - a23 * a31;
	const b11 = a22 * a33 - a23 * a32;
	let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
	if (!det) return null;
	det = 1 / det;
	out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
	out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
	out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
	out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
	out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
	out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
	out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
	out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
	out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
	out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
	out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
	out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
	out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
	out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
	out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
	out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
	return out;
}
/**
* Calculates the determinant of a mat4
*
* @param {ReadonlyMat4} a the source matrix
* @returns {Number} determinant of a
*/
function determinant(a) {
	const a00 = a[0];
	const a01 = a[1];
	const a02 = a[2];
	const a03 = a[3];
	const a10 = a[4];
	const a11 = a[5];
	const a12 = a[6];
	const a13 = a[7];
	const a20 = a[8];
	const a21 = a[9];
	const a22 = a[10];
	const a23 = a[11];
	const a30 = a[12];
	const a31 = a[13];
	const a32 = a[14];
	const a33 = a[15];
	const b0 = a00 * a11 - a01 * a10;
	const b1 = a00 * a12 - a02 * a10;
	const b2 = a01 * a12 - a02 * a11;
	const b3 = a20 * a31 - a21 * a30;
	const b4 = a20 * a32 - a22 * a30;
	const b5 = a21 * a32 - a22 * a31;
	const b6 = a00 * b5 - a01 * b4 + a02 * b3;
	const b7 = a10 * b5 - a11 * b4 + a12 * b3;
	const b8 = a20 * b2 - a21 * b1 + a22 * b0;
	const b9 = a30 * b2 - a31 * b1 + a32 * b0;
	return a13 * b6 - a03 * b7 + a33 * b8 - a23 * b9;
}
/**
* Multiplies two mat4s
*
* @param {mat4} out the receiving matrix
* @param {ReadonlyMat4} a the first operand
* @param {ReadonlyMat4} b the second operand
* @returns {mat4} out
*/
function multiply(out, a, b) {
	const a00 = a[0];
	const a01 = a[1];
	const a02 = a[2];
	const a03 = a[3];
	const a10 = a[4];
	const a11 = a[5];
	const a12 = a[6];
	const a13 = a[7];
	const a20 = a[8];
	const a21 = a[9];
	const a22 = a[10];
	const a23 = a[11];
	const a30 = a[12];
	const a31 = a[13];
	const a32 = a[14];
	const a33 = a[15];
	let b0 = b[0];
	let b1 = b[1];
	let b2 = b[2];
	let b3 = b[3];
	out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	b0 = b[4];
	b1 = b[5];
	b2 = b[6];
	b3 = b[7];
	out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	b0 = b[8];
	b1 = b[9];
	b2 = b[10];
	b3 = b[11];
	out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	b0 = b[12];
	b1 = b[13];
	b2 = b[14];
	b3 = b[15];
	out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	return out;
}
/**
* Translate a mat4 by the given vector
*
* @param {mat4} out the receiving matrix
* @param {ReadonlyMat4} a the matrix to translate
* @param {ReadonlyVec3} v vector to translate by
* @returns {mat4} out
*/
function translate(out, a, v) {
	const x = v[0];
	const y = v[1];
	const z = v[2];
	let a00;
	let a01;
	let a02;
	let a03;
	let a10;
	let a11;
	let a12;
	let a13;
	let a20;
	let a21;
	let a22;
	let a23;
	if (a === out) {
		out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
		out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
		out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
		out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
	} else {
		a00 = a[0];
		a01 = a[1];
		a02 = a[2];
		a03 = a[3];
		a10 = a[4];
		a11 = a[5];
		a12 = a[6];
		a13 = a[7];
		a20 = a[8];
		a21 = a[9];
		a22 = a[10];
		a23 = a[11];
		out[0] = a00;
		out[1] = a01;
		out[2] = a02;
		out[3] = a03;
		out[4] = a10;
		out[5] = a11;
		out[6] = a12;
		out[7] = a13;
		out[8] = a20;
		out[9] = a21;
		out[10] = a22;
		out[11] = a23;
		out[12] = a00 * x + a10 * y + a20 * z + a[12];
		out[13] = a01 * x + a11 * y + a21 * z + a[13];
		out[14] = a02 * x + a12 * y + a22 * z + a[14];
		out[15] = a03 * x + a13 * y + a23 * z + a[15];
	}
	return out;
}
/**
* Scales the mat4 by the dimensions in the given vec3 not using vectorization
*
* @param {mat4} out the receiving matrix
* @param {ReadonlyMat4} a the matrix to scale
* @param {ReadonlyVec3} v the vec3 to scale the matrix by
* @returns {mat4} out
**/
function scale(out, a, v) {
	const x = v[0];
	const y = v[1];
	const z = v[2];
	out[0] = a[0] * x;
	out[1] = a[1] * x;
	out[2] = a[2] * x;
	out[3] = a[3] * x;
	out[4] = a[4] * y;
	out[5] = a[5] * y;
	out[6] = a[6] * y;
	out[7] = a[7] * y;
	out[8] = a[8] * z;
	out[9] = a[9] * z;
	out[10] = a[10] * z;
	out[11] = a[11] * z;
	out[12] = a[12];
	out[13] = a[13];
	out[14] = a[14];
	out[15] = a[15];
	return out;
}
/**
* Rotates a mat4 by the given angle around the given axis
*
* @param {mat4} out the receiving matrix
* @param {ReadonlyMat4} a the matrix to rotate
* @param {Number} rad the angle to rotate the matrix by
* @param {ReadonlyVec3} axis the axis to rotate around
* @returns {mat4} out
*/
function rotate(out, a, rad, axis) {
	let x = axis[0];
	let y = axis[1];
	let z = axis[2];
	let len$1 = Math.sqrt(x * x + y * y + z * z);
	let c;
	let s;
	let t;
	let a00;
	let a01;
	let a02;
	let a03;
	let a10;
	let a11;
	let a12;
	let a13;
	let a20;
	let a21;
	let a22;
	let a23;
	let b00;
	let b01;
	let b02;
	let b10;
	let b11;
	let b12;
	let b20;
	let b21;
	let b22;
	if (len$1 < EPSILON) return null;
	len$1 = 1 / len$1;
	x *= len$1;
	y *= len$1;
	z *= len$1;
	s = Math.sin(rad);
	c = Math.cos(rad);
	t = 1 - c;
	a00 = a[0];
	a01 = a[1];
	a02 = a[2];
	a03 = a[3];
	a10 = a[4];
	a11 = a[5];
	a12 = a[6];
	a13 = a[7];
	a20 = a[8];
	a21 = a[9];
	a22 = a[10];
	a23 = a[11];
	b00 = x * x * t + c;
	b01 = y * x * t + z * s;
	b02 = z * x * t - y * s;
	b10 = x * y * t - z * s;
	b11 = y * y * t + c;
	b12 = z * y * t + x * s;
	b20 = x * z * t + y * s;
	b21 = y * z * t - x * s;
	b22 = z * z * t + c;
	out[0] = a00 * b00 + a10 * b01 + a20 * b02;
	out[1] = a01 * b00 + a11 * b01 + a21 * b02;
	out[2] = a02 * b00 + a12 * b01 + a22 * b02;
	out[3] = a03 * b00 + a13 * b01 + a23 * b02;
	out[4] = a00 * b10 + a10 * b11 + a20 * b12;
	out[5] = a01 * b10 + a11 * b11 + a21 * b12;
	out[6] = a02 * b10 + a12 * b11 + a22 * b12;
	out[7] = a03 * b10 + a13 * b11 + a23 * b12;
	out[8] = a00 * b20 + a10 * b21 + a20 * b22;
	out[9] = a01 * b20 + a11 * b21 + a21 * b22;
	out[10] = a02 * b20 + a12 * b21 + a22 * b22;
	out[11] = a03 * b20 + a13 * b21 + a23 * b22;
	if (a !== out) {
		out[12] = a[12];
		out[13] = a[13];
		out[14] = a[14];
		out[15] = a[15];
	}
	return out;
}
/**
* Rotates a matrix by the given angle around the X axis
*
* @param {mat4} out the receiving matrix
* @param {ReadonlyMat4} a the matrix to rotate
* @param {Number} rad the angle to rotate the matrix by
* @returns {mat4} out
*/
function rotateX(out, a, rad) {
	const s = Math.sin(rad);
	const c = Math.cos(rad);
	const a10 = a[4];
	const a11 = a[5];
	const a12 = a[6];
	const a13 = a[7];
	const a20 = a[8];
	const a21 = a[9];
	const a22 = a[10];
	const a23 = a[11];
	if (a !== out) {
		out[0] = a[0];
		out[1] = a[1];
		out[2] = a[2];
		out[3] = a[3];
		out[12] = a[12];
		out[13] = a[13];
		out[14] = a[14];
		out[15] = a[15];
	}
	out[4] = a10 * c + a20 * s;
	out[5] = a11 * c + a21 * s;
	out[6] = a12 * c + a22 * s;
	out[7] = a13 * c + a23 * s;
	out[8] = a20 * c - a10 * s;
	out[9] = a21 * c - a11 * s;
	out[10] = a22 * c - a12 * s;
	out[11] = a23 * c - a13 * s;
	return out;
}
/**
* Rotates a matrix by the given angle around the Y axis
*
* @param {mat4} out the receiving matrix
* @param {ReadonlyMat4} a the matrix to rotate
* @param {Number} rad the angle to rotate the matrix by
* @returns {mat4} out
*/
function rotateY(out, a, rad) {
	const s = Math.sin(rad);
	const c = Math.cos(rad);
	const a00 = a[0];
	const a01 = a[1];
	const a02 = a[2];
	const a03 = a[3];
	const a20 = a[8];
	const a21 = a[9];
	const a22 = a[10];
	const a23 = a[11];
	if (a !== out) {
		out[4] = a[4];
		out[5] = a[5];
		out[6] = a[6];
		out[7] = a[7];
		out[12] = a[12];
		out[13] = a[13];
		out[14] = a[14];
		out[15] = a[15];
	}
	out[0] = a00 * c - a20 * s;
	out[1] = a01 * c - a21 * s;
	out[2] = a02 * c - a22 * s;
	out[3] = a03 * c - a23 * s;
	out[8] = a00 * s + a20 * c;
	out[9] = a01 * s + a21 * c;
	out[10] = a02 * s + a22 * c;
	out[11] = a03 * s + a23 * c;
	return out;
}
/**
* Rotates a matrix by the given angle around the Z axis
*
* @param {mat4} out the receiving matrix
* @param {ReadonlyMat4} a the matrix to rotate
* @param {Number} rad the angle to rotate the matrix by
* @returns {mat4} out
*/
function rotateZ(out, a, rad) {
	const s = Math.sin(rad);
	const c = Math.cos(rad);
	const a00 = a[0];
	const a01 = a[1];
	const a02 = a[2];
	const a03 = a[3];
	const a10 = a[4];
	const a11 = a[5];
	const a12 = a[6];
	const a13 = a[7];
	if (a !== out) {
		out[8] = a[8];
		out[9] = a[9];
		out[10] = a[10];
		out[11] = a[11];
		out[12] = a[12];
		out[13] = a[13];
		out[14] = a[14];
		out[15] = a[15];
	}
	out[0] = a00 * c + a10 * s;
	out[1] = a01 * c + a11 * s;
	out[2] = a02 * c + a12 * s;
	out[3] = a03 * c + a13 * s;
	out[4] = a10 * c - a00 * s;
	out[5] = a11 * c - a01 * s;
	out[6] = a12 * c - a02 * s;
	out[7] = a13 * c - a03 * s;
	return out;
}
/**
* Calculates a 4x4 matrix from the given quaternion
*
* @param {mat4} out mat4 receiving operation result
* @param {ReadonlyQuat} q Quaternion to create matrix from
*
* @returns {mat4} out
*/
function fromQuat(out, q) {
	const x = q[0];
	const y = q[1];
	const z = q[2];
	const w = q[3];
	const x2 = x + x;
	const y2 = y + y;
	const z2 = z + z;
	const xx = x * x2;
	const yx = y * x2;
	const yy = y * y2;
	const zx = z * x2;
	const zy = z * y2;
	const zz = z * z2;
	const wx = w * x2;
	const wy = w * y2;
	const wz = w * z2;
	out[0] = 1 - yy - zz;
	out[1] = yx + wz;
	out[2] = zx - wy;
	out[3] = 0;
	out[4] = yx - wz;
	out[5] = 1 - xx - zz;
	out[6] = zy + wx;
	out[7] = 0;
	out[8] = zx + wy;
	out[9] = zy - wx;
	out[10] = 1 - xx - yy;
	out[11] = 0;
	out[12] = 0;
	out[13] = 0;
	out[14] = 0;
	out[15] = 1;
	return out;
}
/**
* Generates a frustum matrix with the given bounds
*
* @param {mat4} out mat4 frustum matrix will be written into
* @param {Number} left Left bound of the frustum
* @param {Number} right Right bound of the frustum
* @param {Number} bottom Bottom bound of the frustum
* @param {Number} top Top bound of the frustum
* @param {Number} near Near bound of the frustum
* @param {Number} far Far bound of the frustum
* @returns {mat4} out
*/
function frustum(out, left, right, bottom, top, near, far) {
	const rl = 1 / (right - left);
	const tb = 1 / (top - bottom);
	const nf = 1 / (near - far);
	out[0] = near * 2 * rl;
	out[1] = 0;
	out[2] = 0;
	out[3] = 0;
	out[4] = 0;
	out[5] = near * 2 * tb;
	out[6] = 0;
	out[7] = 0;
	out[8] = (right + left) * rl;
	out[9] = (top + bottom) * tb;
	out[10] = (far + near) * nf;
	out[11] = -1;
	out[12] = 0;
	out[13] = 0;
	out[14] = far * near * 2 * nf;
	out[15] = 0;
	return out;
}
/**
* Generates a perspective projection matrix with the given bounds.
* The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
* which matches WebGL/OpenGL's clip volume.
* Passing null/undefined/no value for far will generate infinite projection matrix.
*
* @param {mat4} out mat4 frustum matrix will be written into
* @param {number} fovy Vertical field of view in radians
* @param {number} aspect Aspect ratio. typically viewport width/height
* @param {number} near Near bound of the frustum
* @param {number} far Far bound of the frustum, can be null or Infinity
* @returns {mat4} out
*/
function perspectiveNO(out, fovy, aspect, near, far) {
	const f = 1 / Math.tan(fovy / 2);
	out[0] = f / aspect;
	out[1] = 0;
	out[2] = 0;
	out[3] = 0;
	out[4] = 0;
	out[5] = f;
	out[6] = 0;
	out[7] = 0;
	out[8] = 0;
	out[9] = 0;
	out[11] = -1;
	out[12] = 0;
	out[13] = 0;
	out[15] = 0;
	if (far != null && far !== Infinity) {
		const nf = 1 / (near - far);
		out[10] = (far + near) * nf;
		out[14] = 2 * far * near * nf;
	} else {
		out[10] = -1;
		out[14] = -2 * near;
	}
	return out;
}
/**
* Alias for {@link mat4.perspectiveNO}
* @function
*/
const perspective = perspectiveNO;
/**
* Generates a orthogonal projection matrix with the given bounds.
* The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
* which matches WebGL/OpenGL's clip volume.
*
* @param {mat4} out mat4 frustum matrix will be written into
* @param {number} left Left bound of the frustum
* @param {number} right Right bound of the frustum
* @param {number} bottom Bottom bound of the frustum
* @param {number} top Top bound of the frustum
* @param {number} near Near bound of the frustum
* @param {number} far Far bound of the frustum
* @returns {mat4} out
*/
function orthoNO(out, left, right, bottom, top, near, far) {
	const lr = 1 / (left - right);
	const bt = 1 / (bottom - top);
	const nf = 1 / (near - far);
	out[0] = -2 * lr;
	out[1] = 0;
	out[2] = 0;
	out[3] = 0;
	out[4] = 0;
	out[5] = -2 * bt;
	out[6] = 0;
	out[7] = 0;
	out[8] = 0;
	out[9] = 0;
	out[10] = 2 * nf;
	out[11] = 0;
	out[12] = (left + right) * lr;
	out[13] = (top + bottom) * bt;
	out[14] = (far + near) * nf;
	out[15] = 1;
	return out;
}
/**
* Alias for {@link mat4.orthoNO}
* @function
*/
const ortho = orthoNO;
/**
* Generates a look-at matrix with the given eye position, focal point, and up axis.
* If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
*
* @param {mat4} out mat4 frustum matrix will be written into
* @param {ReadonlyVec3} eye Position of the viewer
* @param {ReadonlyVec3} center Point the viewer is looking at
* @param {ReadonlyVec3} up vec3 pointing up
* @returns {mat4} out
*/
function lookAt(out, eye, center, up) {
	let len$1;
	let x0;
	let x1;
	let x2;
	let y0;
	let y1;
	let y2;
	let z0;
	let z1;
	let z2;
	const eyex = eye[0];
	const eyey = eye[1];
	const eyez = eye[2];
	const upx = up[0];
	const upy = up[1];
	const upz = up[2];
	const centerx = center[0];
	const centery = center[1];
	const centerz = center[2];
	if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) return identity(out);
	z0 = eyex - centerx;
	z1 = eyey - centery;
	z2 = eyez - centerz;
	len$1 = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
	z0 *= len$1;
	z1 *= len$1;
	z2 *= len$1;
	x0 = upy * z2 - upz * z1;
	x1 = upz * z0 - upx * z2;
	x2 = upx * z1 - upy * z0;
	len$1 = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
	if (!len$1) {
		x0 = 0;
		x1 = 0;
		x2 = 0;
	} else {
		len$1 = 1 / len$1;
		x0 *= len$1;
		x1 *= len$1;
		x2 *= len$1;
	}
	y0 = z1 * x2 - z2 * x1;
	y1 = z2 * x0 - z0 * x2;
	y2 = z0 * x1 - z1 * x0;
	len$1 = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
	if (!len$1) {
		y0 = 0;
		y1 = 0;
		y2 = 0;
	} else {
		len$1 = 1 / len$1;
		y0 *= len$1;
		y1 *= len$1;
		y2 *= len$1;
	}
	out[0] = x0;
	out[1] = y0;
	out[2] = z0;
	out[3] = 0;
	out[4] = x1;
	out[5] = y1;
	out[6] = z1;
	out[7] = 0;
	out[8] = x2;
	out[9] = y2;
	out[10] = z2;
	out[11] = 0;
	out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
	out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
	out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
	out[15] = 1;
	return out;
}

//#endregion
//#region node_modules/@math.gl/core/dist/gl-matrix/vec4.js
/**
* 4 Dimensional Vector
* @module vec4
*/
/**
* Creates a new, empty vec4
*
* @returns {vec4} a new 4D vector
*/
function create() {
	const out = new ARRAY_TYPE(4);
	if (ARRAY_TYPE != Float32Array) {
		out[0] = 0;
		out[1] = 0;
		out[2] = 0;
		out[3] = 0;
	}
	return out;
}
/**
* Scales a vec4 by a scalar number
*
* @param {vec4} out the receiving vector
* @param {ReadonlyVec4} a the vector to scale
* @param {Number} b amount to scale the vector by
* @returns {vec4} out
*/
function scale$1(out, a, b) {
	out[0] = a[0] * b;
	out[1] = a[1] * b;
	out[2] = a[2] * b;
	out[3] = a[3] * b;
	return out;
}
/**
* Transforms the vec4 with a mat4.
*
* @param {vec4} out the receiving vector
* @param {ReadonlyVec4} a the vector to transform
* @param {ReadonlyMat4} m matrix to transform with
* @returns {vec4} out
*/
function transformMat4$2(out, a, m) {
	const x = a[0];
	const y = a[1];
	const z = a[2];
	const w = a[3];
	out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
	out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
	out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
	out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
	return out;
}
/**
* Perform some operation over an array of vec4s.
*
* @param {Array} a the array of vectors to iterate over
* @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
* @param {Number} offset Number of elements to skip at the beginning of the array
* @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
* @param {Function} fn Function to call for each vector in the array
* @param {Object} [arg] additional argument to pass to fn
* @returns {Array} a
* @function
*/
const forEach = (function() {
	const vec = create();
	return function(a, stride, offset, count, fn, arg) {
		let i;
		let l;
		if (!stride) stride = 4;
		if (!offset) offset = 0;
		if (count) l = Math.min(count * stride + offset, a.length);
		else l = a.length;
		for (i = offset; i < l; i += stride) {
			vec[0] = a[i];
			vec[1] = a[i + 1];
			vec[2] = a[i + 2];
			vec[3] = a[i + 3];
			fn(vec, vec, arg);
			a[i] = vec[0];
			a[i + 1] = vec[1];
			a[i + 2] = vec[2];
			a[i + 3] = vec[3];
		}
		return a;
	};
})();

//#endregion
//#region node_modules/@math.gl/core/dist/classes/matrix4.js
var INDICES;
(function(INDICES$1) {
	INDICES$1[INDICES$1["COL0ROW0"] = 0] = "COL0ROW0";
	INDICES$1[INDICES$1["COL0ROW1"] = 1] = "COL0ROW1";
	INDICES$1[INDICES$1["COL0ROW2"] = 2] = "COL0ROW2";
	INDICES$1[INDICES$1["COL0ROW3"] = 3] = "COL0ROW3";
	INDICES$1[INDICES$1["COL1ROW0"] = 4] = "COL1ROW0";
	INDICES$1[INDICES$1["COL1ROW1"] = 5] = "COL1ROW1";
	INDICES$1[INDICES$1["COL1ROW2"] = 6] = "COL1ROW2";
	INDICES$1[INDICES$1["COL1ROW3"] = 7] = "COL1ROW3";
	INDICES$1[INDICES$1["COL2ROW0"] = 8] = "COL2ROW0";
	INDICES$1[INDICES$1["COL2ROW1"] = 9] = "COL2ROW1";
	INDICES$1[INDICES$1["COL2ROW2"] = 10] = "COL2ROW2";
	INDICES$1[INDICES$1["COL2ROW3"] = 11] = "COL2ROW3";
	INDICES$1[INDICES$1["COL3ROW0"] = 12] = "COL3ROW0";
	INDICES$1[INDICES$1["COL3ROW1"] = 13] = "COL3ROW1";
	INDICES$1[INDICES$1["COL3ROW2"] = 14] = "COL3ROW2";
	INDICES$1[INDICES$1["COL3ROW3"] = 15] = "COL3ROW3";
})(INDICES || (INDICES = {}));
var DEFAULT_FOVY = 45 * Math.PI / 180;
var DEFAULT_ASPECT = 1;
var DEFAULT_NEAR = .1;
var DEFAULT_FAR = 500;
var IDENTITY_MATRIX$1 = Object.freeze([
	1,
	0,
	0,
	0,
	0,
	1,
	0,
	0,
	0,
	0,
	1,
	0,
	0,
	0,
	0,
	1
]);
/**
* A 4x4 matrix with common linear algebra operations
* Subclass of Array<number> meaning that it is highly compatible with other libraries
*/
var Matrix4 = class extends Matrix {
	static get IDENTITY() {
		return getIdentityMatrix();
	}
	static get ZERO() {
		return getZeroMatrix();
	}
	get ELEMENTS() {
		return 16;
	}
	get RANK() {
		return 4;
	}
	get INDICES() {
		return INDICES;
	}
	constructor(array) {
		super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);
		if (arguments.length === 1 && Array.isArray(array)) this.copy(array);
		else this.identity();
	}
	copy(array) {
		this[0] = array[0];
		this[1] = array[1];
		this[2] = array[2];
		this[3] = array[3];
		this[4] = array[4];
		this[5] = array[5];
		this[6] = array[6];
		this[7] = array[7];
		this[8] = array[8];
		this[9] = array[9];
		this[10] = array[10];
		this[11] = array[11];
		this[12] = array[12];
		this[13] = array[13];
		this[14] = array[14];
		this[15] = array[15];
		return this.check();
	}
	set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
		this[0] = m00;
		this[1] = m10;
		this[2] = m20;
		this[3] = m30;
		this[4] = m01;
		this[5] = m11;
		this[6] = m21;
		this[7] = m31;
		this[8] = m02;
		this[9] = m12;
		this[10] = m22;
		this[11] = m32;
		this[12] = m03;
		this[13] = m13;
		this[14] = m23;
		this[15] = m33;
		return this.check();
	}
	setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
		this[0] = m00;
		this[1] = m10;
		this[2] = m20;
		this[3] = m30;
		this[4] = m01;
		this[5] = m11;
		this[6] = m21;
		this[7] = m31;
		this[8] = m02;
		this[9] = m12;
		this[10] = m22;
		this[11] = m32;
		this[12] = m03;
		this[13] = m13;
		this[14] = m23;
		this[15] = m33;
		return this.check();
	}
	toRowMajor(result) {
		result[0] = this[0];
		result[1] = this[4];
		result[2] = this[8];
		result[3] = this[12];
		result[4] = this[1];
		result[5] = this[5];
		result[6] = this[9];
		result[7] = this[13];
		result[8] = this[2];
		result[9] = this[6];
		result[10] = this[10];
		result[11] = this[14];
		result[12] = this[3];
		result[13] = this[7];
		result[14] = this[11];
		result[15] = this[15];
		return result;
	}
	/** Set to identity matrix */
	identity() {
		return this.copy(IDENTITY_MATRIX$1);
	}
	/**
	*
	* @param object
	* @returns self
	*/
	fromObject(object) {
		return this.check();
	}
	/**
	* Calculates a 4x4 matrix from the given quaternion
	* @param quaternion Quaternion to create matrix from
	* @returns self
	*/
	fromQuaternion(quaternion) {
		fromQuat(this, quaternion);
		return this.check();
	}
	/**
	* Generates a frustum matrix with the given bounds
	* @param view.left - Left bound of the frustum
	* @param view.right - Right bound of the frustum
	* @param view.bottom - Bottom bound of the frustum
	* @param view.top - Top bound of the frustum
	* @param view.near - Near bound of the frustum
	* @param view.far - Far bound of the frustum. Can be set to Infinity.
	* @returns self
	*/
	frustum(view) {
		const { left, right, bottom, top, near = DEFAULT_NEAR, far = DEFAULT_FAR } = view;
		if (far === Infinity) computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);
		else frustum(this, left, right, bottom, top, near, far);
		return this.check();
	}
	/**
	* Generates a look-at matrix with the given eye position, focal point,
	* and up axis
	* @param view.eye - (vector) Position of the viewer
	* @param view.center - (vector) Point the viewer is looking at
	* @param view.up - (vector) Up axis
	* @returns self
	*/
	lookAt(view) {
		const { eye, center = [
			0,
			0,
			0
		], up = [
			0,
			1,
			0
		] } = view;
		lookAt(this, eye, center, up);
		return this.check();
	}
	/**
	* Generates a orthogonal projection matrix with the given bounds
	* from "traditional" view space parameters
	* @param view.left - Left bound of the frustum
	* @param view.right number  Right bound of the frustum
	* @param view.bottom - Bottom bound of the frustum
	* @param view.top number  Top bound of the frustum
	* @param view.near - Near bound of the frustum
	* @param view.far number  Far bound of the frustum
	* @returns self
	*/
	ortho(view) {
		const { left, right, bottom, top, near = DEFAULT_NEAR, far = DEFAULT_FAR } = view;
		ortho(this, left, right, bottom, top, near, far);
		return this.check();
	}
	/**
	* Generates an orthogonal projection matrix with the same parameters
	* as a perspective matrix (plus focalDistance)
	* @param view.fovy Vertical field of view in radians
	* @param view.aspect Aspect ratio. Typically viewport width / viewport height
	* @param view.focalDistance Distance in the view frustum used for extent calculations
	* @param view.near Near bound of the frustum
	* @param view.far Far bound of the frustum
	* @returns self
	*/
	orthographic(view) {
		const { fovy = DEFAULT_FOVY, aspect = DEFAULT_ASPECT, focalDistance = 1, near = DEFAULT_NEAR, far = DEFAULT_FAR } = view;
		checkRadians(fovy);
		const halfY = fovy / 2;
		const top = focalDistance * Math.tan(halfY);
		const right = top * aspect;
		return this.ortho({
			left: -right,
			right,
			bottom: -top,
			top,
			near,
			far
		});
	}
	/**
	* Generates a perspective projection matrix with the given bounds
	* @param view.fovy Vertical field of view in radians
	* @param view.aspect Aspect ratio. typically viewport width/height
	* @param view.near Near bound of the frustum
	* @param view.far Far bound of the frustum
	* @returns self
	*/
	perspective(view) {
		const { fovy = 45 * Math.PI / 180, aspect = 1, near = .1, far = 500 } = view;
		checkRadians(fovy);
		perspective(this, fovy, aspect, near, far);
		return this.check();
	}
	determinant() {
		return determinant(this);
	}
	/**
	* Extracts the non-uniform scale assuming the matrix is an affine transformation.
	* The scales are the "lengths" of the column vectors in the upper-left 3x3 matrix.
	* @param result
	* @returns self
	*/
	getScale(result = [
		-0,
		-0,
		-0
	]) {
		result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
		result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
		result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
		return result;
	}
	/**
	* Gets the translation portion, assuming the matrix is a affine transformation matrix.
	* @param result
	* @returns self
	*/
	getTranslation(result = [
		-0,
		-0,
		-0
	]) {
		result[0] = this[12];
		result[1] = this[13];
		result[2] = this[14];
		return result;
	}
	/**
	* Gets upper left 3x3 pure rotation matrix (non-scaling), assume affine transformation matrix
	* @param result
	* @param scaleResult
	* @returns self
	*/
	getRotation(result, scaleResult) {
		result = result || [
			-0,
			-0,
			-0,
			-0,
			-0,
			-0,
			-0,
			-0,
			-0,
			-0,
			-0,
			-0,
			-0,
			-0,
			-0,
			-0
		];
		scaleResult = scaleResult || [
			-0,
			-0,
			-0
		];
		const scale$2 = this.getScale(scaleResult);
		const inverseScale0 = 1 / scale$2[0];
		const inverseScale1 = 1 / scale$2[1];
		const inverseScale2 = 1 / scale$2[2];
		result[0] = this[0] * inverseScale0;
		result[1] = this[1] * inverseScale1;
		result[2] = this[2] * inverseScale2;
		result[3] = 0;
		result[4] = this[4] * inverseScale0;
		result[5] = this[5] * inverseScale1;
		result[6] = this[6] * inverseScale2;
		result[7] = 0;
		result[8] = this[8] * inverseScale0;
		result[9] = this[9] * inverseScale1;
		result[10] = this[10] * inverseScale2;
		result[11] = 0;
		result[12] = 0;
		result[13] = 0;
		result[14] = 0;
		result[15] = 1;
		return result;
	}
	/**
	*
	* @param result
	* @param scaleResult
	* @returns self
	*/
	getRotationMatrix3(result, scaleResult) {
		result = result || [
			-0,
			-0,
			-0,
			-0,
			-0,
			-0,
			-0,
			-0,
			-0
		];
		scaleResult = scaleResult || [
			-0,
			-0,
			-0
		];
		const scale$2 = this.getScale(scaleResult);
		const inverseScale0 = 1 / scale$2[0];
		const inverseScale1 = 1 / scale$2[1];
		const inverseScale2 = 1 / scale$2[2];
		result[0] = this[0] * inverseScale0;
		result[1] = this[1] * inverseScale1;
		result[2] = this[2] * inverseScale2;
		result[3] = this[4] * inverseScale0;
		result[4] = this[5] * inverseScale1;
		result[5] = this[6] * inverseScale2;
		result[6] = this[8] * inverseScale0;
		result[7] = this[9] * inverseScale1;
		result[8] = this[10] * inverseScale2;
		return result;
	}
	transpose() {
		transpose(this, this);
		return this.check();
	}
	invert() {
		invert(this, this);
		return this.check();
	}
	multiplyLeft(a) {
		multiply(this, a, this);
		return this.check();
	}
	multiplyRight(a) {
		multiply(this, this, a);
		return this.check();
	}
	rotateX(radians) {
		rotateX(this, this, radians);
		return this.check();
	}
	rotateY(radians) {
		rotateY(this, this, radians);
		return this.check();
	}
	/**
	* Rotates a matrix by the given angle around the Z axis.
	* @param radians
	* @returns self
	*/
	rotateZ(radians) {
		rotateZ(this, this, radians);
		return this.check();
	}
	/**
	*
	* @param param0
	* @returns self
	*/
	rotateXYZ(angleXYZ) {
		return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);
	}
	/**
	*
	* @param radians
	* @param axis
	* @returns self
	*/
	rotateAxis(radians, axis) {
		rotate(this, this, radians, axis);
		return this.check();
	}
	/**
	*
	* @param factor
	* @returns self
	*/
	scale(factor) {
		scale(this, this, Array.isArray(factor) ? factor : [
			factor,
			factor,
			factor
		]);
		return this.check();
	}
	/**
	*
	* @param vec
	* @returns self
	*/
	translate(vector) {
		translate(this, this, vector);
		return this.check();
	}
	/**
	* Transforms any 2, 3 or 4 element vector. 2 and 3 elements are treated as points
	* @param vector
	* @param result
	* @returns self
	*/
	transform(vector, result) {
		if (vector.length === 4) {
			result = transformMat4$2(result || [
				-0,
				-0,
				-0,
				-0
			], vector, this);
			checkVector(result, 4);
			return result;
		}
		return this.transformAsPoint(vector, result);
	}
	/**
	* Transforms any 2 or 3 element array as point (w implicitly 1)
	* @param vector
	* @param result
	* @returns self
	*/
	transformAsPoint(vector, result) {
		const { length: length$1 } = vector;
		let out;
		switch (length$1) {
			case 2:
				out = transformMat4(result || [-0, -0], vector, this);
				break;
			case 3:
				out = transformMat4$1(result || [
					-0,
					-0,
					-0
				], vector, this);
				break;
			default: throw new Error("Illegal vector");
		}
		checkVector(out, vector.length);
		return out;
	}
	/**
	* Transforms any 2 or 3 element array as vector (w implicitly 0)
	* @param vector
	* @param result
	* @returns self
	*/
	transformAsVector(vector, result) {
		let out;
		switch (vector.length) {
			case 2:
				out = vec2_transformMat4AsVector(result || [-0, -0], vector, this);
				break;
			case 3:
				out = vec3_transformMat4AsVector(result || [
					-0,
					-0,
					-0
				], vector, this);
				break;
			default: throw new Error("Illegal vector");
		}
		checkVector(out, vector.length);
		return out;
	}
	/** @deprecated */
	transformPoint(vector, result) {
		return this.transformAsPoint(vector, result);
	}
	/** @deprecated */
	transformVector(vector, result) {
		return this.transformAsPoint(vector, result);
	}
	/** @deprecated */
	transformDirection(vector, result) {
		return this.transformAsVector(vector, result);
	}
	makeRotationX(radians) {
		return this.identity().rotateX(radians);
	}
	makeTranslation(x, y, z) {
		return this.identity().translate([
			x,
			y,
			z
		]);
	}
};
var ZERO;
var IDENTITY$1;
function getZeroMatrix() {
	if (!ZERO) {
		ZERO = new Matrix4([
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0
		]);
		Object.freeze(ZERO);
	}
	return ZERO;
}
function getIdentityMatrix() {
	if (!IDENTITY$1) {
		IDENTITY$1 = new Matrix4();
		Object.freeze(IDENTITY$1);
	}
	return IDENTITY$1;
}
function checkRadians(possiblyDegrees) {
	if (possiblyDegrees > Math.PI * 2) throw Error("expected radians");
}
function computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {
	const column0Row0 = 2 * near / (right - left);
	const column1Row1 = 2 * near / (top - bottom);
	const column2Row0 = (right + left) / (right - left);
	const column2Row1 = (top + bottom) / (top - bottom);
	const column2Row2 = -1;
	const column2Row3 = -1;
	const column3Row2 = -2 * near;
	result[0] = column0Row0;
	result[1] = 0;
	result[2] = 0;
	result[3] = 0;
	result[4] = 0;
	result[5] = column1Row1;
	result[6] = 0;
	result[7] = 0;
	result[8] = column2Row0;
	result[9] = column2Row1;
	result[10] = column2Row2;
	result[11] = column2Row3;
	result[12] = 0;
	result[13] = 0;
	result[14] = column3Row2;
	result[15] = 0;
	return result;
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/modules/math/fp32/fp32.js
var fp32shader = `\
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND

// All these functions are for substituting tan() function from Intel GPU only
const float TWO_PI = 6.2831854820251465;
const float PI_2 = 1.5707963705062866;
const float PI_16 = 0.1963495463132858;

const float SIN_TABLE_0 = 0.19509032368659973;
const float SIN_TABLE_1 = 0.3826834261417389;
const float SIN_TABLE_2 = 0.5555702447891235;
const float SIN_TABLE_3 = 0.7071067690849304;

const float COS_TABLE_0 = 0.9807852506637573;
const float COS_TABLE_1 = 0.9238795042037964;
const float COS_TABLE_2 = 0.8314695954322815;
const float COS_TABLE_3 = 0.7071067690849304;

const float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!
const float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!
const float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!
const float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!

float sin_taylor_fp32(float a) {
  float r, s, t, x;

  if (a == 0.0) {
    return 0.0;
  }

  x = -a * a;
  s = a;
  r = a;

  r = r * x;
  t = r * INVERSE_FACTORIAL_3;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_5;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_7;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_9;
  s = s + t;

  return s;
}

void sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {
  if (a == 0.0) {
    sin_t = 0.0;
    cos_t = 1.0;
  }
  sin_t = sin_taylor_fp32(a);
  cos_t = sqrt(1.0 - sin_t * sin_t);
}

float tan_taylor_fp32(float a) {
    float sin_a;
    float cos_a;

    if (a == 0.0) {
        return 0.0;
    }

    // 2pi range reduction
    float z = floor(a / TWO_PI);
    float r = a - TWO_PI * z;

    float t;
    float q = floor(r / PI_2 + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return 1.0 / 0.0;
    }

    t = r - PI_2 * q;

    q = floor(t / PI_16 + 0.5);
    int k = int(q);
    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return 1.0 / 0.0;
    } else {
        t = t - PI_16 * q;
    }

    float u = 0.0;
    float v = 0.0;

    float sin_t, cos_t;
    float s, c;
    sincos_taylor_fp32(t, sin_t, cos_t);

    if (k == 0) {
        s = sin_t;
        c = cos_t;
    } else {
        if (abs(float(abs_k) - 1.0) < 0.5) {
            u = COS_TABLE_0;
            v = SIN_TABLE_0;
        } else if (abs(float(abs_k) - 2.0) < 0.5) {
            u = COS_TABLE_1;
            v = SIN_TABLE_1;
        } else if (abs(float(abs_k) - 3.0) < 0.5) {
            u = COS_TABLE_2;
            v = SIN_TABLE_2;
        } else if (abs(float(abs_k) - 4.0) < 0.5) {
            u = COS_TABLE_3;
            v = SIN_TABLE_3;
        }
        if (k > 0) {
            s = u * sin_t + v * cos_t;
            c = u * cos_t - v * sin_t;
        } else {
            s = u * sin_t - v * cos_t;
            c = u * cos_t + v * sin_t;
        }
    }

    if (j == 0) {
        sin_a = s;
        cos_a = c;
    } else if (j == 1) {
        sin_a = c;
        cos_a = -s;
    } else if (j == -1) {
        sin_a = -c;
        cos_a = s;
    } else {
        sin_a = -s;
        cos_a = -c;
    }
    return sin_a / cos_a;
}
#endif

float tan_fp32(float a) {
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
  return tan_taylor_fp32(a);
#else
  return tan(a);
#endif
}
`;
/**
* 32 bit math library (fixups for GPUs)
*/
const fp32 = {
	name: "fp32",
	vs: fp32shader
};

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/modules/engine/picking/picking.js
var DEFAULT_HIGHLIGHT_COLOR = [
	0,
	1,
	1,
	1
];
var vs$2 = `\
uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

out vec4 picking_vRGBcolor_Avalid;

// Normalize unsigned byte color to 0-1 range
vec3 picking_normalizeColor(vec3 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

// Normalize unsigned byte color to 0-1 range
vec4 picking_normalizeColor(vec4 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

bool picking_isColorZero(vec3 color) {
  return dot(color, vec3(1.0)) < 0.00001;
}

bool picking_isColorValid(vec3 color) {
  return dot(color, vec3(1.0)) > 0.00001;
}

// Check if this vertex is highlighted 
bool isVertexHighlighted(vec3 vertexColor) {
  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);
  return
    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));
}

// Set the current picking color
void picking_setPickingColor(vec3 pickingColor) {
  pickingColor = picking_normalizeColor(pickingColor);

  if (bool(picking.isActive)) {
    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable
    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));

    if (!bool(picking.isAttribute)) {
      // Stores the picking color so that the fragment shader can render it during picking
      picking_vRGBcolor_Avalid.rgb = pickingColor;
    }
  } else {
    // Do the comparison with selected item color in vertex shader as it should mean fewer compares
    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));
  }
}

void picking_setPickingAttribute(float value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.r = value;
  }
}

void picking_setPickingAttribute(vec2 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rg = value;
  }
}

void picking_setPickingAttribute(vec3 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rgb = value;
  }
}
`;
var fs$1 = `\
uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

in vec4 picking_vRGBcolor_Avalid;

/*
 * Returns highlight color if this item is selected.
 */
vec4 picking_filterHighlightColor(vec4 color) {
  // If we are still picking, we don't highlight
  if (picking.isActive > 0.5) {
    return color;
  }

  bool selected = bool(picking_vRGBcolor_Avalid.a);

  if (selected) {
    // Blend in highlight color based on its alpha value
    float highLightAlpha = picking.highlightColor.a;
    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
    float highLightRatio = highLightAlpha / blendedAlpha;

    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);
    return vec4(blendedRGB, blendedAlpha);
  } else {
    return color;
  }
}

/*
 * Returns picking color if picking enabled else unmodified argument.
 */
vec4 picking_filterPickingColor(vec4 color) {
  if (bool(picking.isActive)) {
    if (picking_vRGBcolor_Avalid.a == 0.0) {
      discard;
    }
    return picking_vRGBcolor_Avalid;
  }
  return color;
}

/*
 * Returns picking color if picking is enabled if not
 * highlight color if this item is selected, otherwise unmodified argument.
 */
vec4 picking_filterColor(vec4 color) {
  vec4 highlightColor = picking_filterHighlightColor(color);
  return picking_filterPickingColor(highlightColor);
}
`;
/**
* Provides support for color-coding-based picking and highlighting.
* In particular, supports picking a specific instance in an instanced
* draw call and highlighting an instance based on its picking color,
* and correspondingly, supports picking and highlighting groups of
* primitives with the same picking color in non-instanced draw-calls
*/
const picking = {
	props: {},
	uniforms: {},
	name: "picking",
	uniformTypes: {
		isActive: "f32",
		isAttribute: "f32",
		isHighlightActive: "f32",
		useFloatColors: "f32",
		highlightedObjectColor: "vec3<f32>",
		highlightColor: "vec4<f32>"
	},
	defaultUniforms: {
		isActive: false,
		isAttribute: false,
		isHighlightActive: false,
		useFloatColors: true,
		highlightedObjectColor: [
			0,
			0,
			0
		],
		highlightColor: DEFAULT_HIGHLIGHT_COLOR
	},
	vs: vs$2,
	fs: fs$1,
	getUniforms: getUniforms$1
};
function getUniforms$1(opts = {}, prevUniforms) {
	const uniforms = {};
	if (opts.highlightedObjectColor === void 0) {} else if (opts.highlightedObjectColor === null) uniforms.isHighlightActive = false;
	else {
		uniforms.isHighlightActive = true;
		uniforms.highlightedObjectColor = opts.highlightedObjectColor.slice(0, 3);
	}
	if (opts.highlightColor) {
		const color = Array.from(opts.highlightColor, (x) => x / 255);
		if (!Number.isFinite(color[3])) color[3] = 1;
		uniforms.highlightColor = color;
	}
	if (opts.isActive !== void 0) {
		uniforms.isActive = Boolean(opts.isActive);
		uniforms.isAttribute = Boolean(opts.isAttribute);
	}
	if (opts.useFloatColors !== void 0) uniforms.useFloatColors = Boolean(opts.useFloatColors);
	return uniforms;
}

//#endregion
//#region node_modules/@deck.gl/core/dist/shaderlib/color/color.js
var colorWGSL = `

struct ColorUniforms {
  opacity: f32,
};

var<private> color: ColorUniforms = ColorUniforms(1.0);
// TODO (kaapp) avoiding binding index collisions to handle layer opacity 
// requires some thought.
// @group(0) @binding(0) var<uniform> color: ColorUniforms;

@must_use
fn deckgl_premultiplied_alpha(fragColor: vec4<f32>) -> vec4<f32> {
    return vec4(fragColor.rgb * fragColor.a, fragColor.a); 
};
`;
var color_default = {
	name: "color",
	dependencies: [],
	source: colorWGSL,
	getUniforms: (_props) => {
		return {};
	},
	uniformTypes: { opacity: "f32" }
};

//#endregion
//#region node_modules/@deck.gl/core/dist/shaderlib/misc/geometry.js
var source$1 = `\
const SMOOTH_EDGE_RADIUS: f32 = 0.5;

struct VertexGeometry {
  position: vec4<f32>,
  worldPosition: vec3<f32>,
  worldPositionAlt: vec3<f32>,
  normal: vec3<f32>,
  uv: vec2<f32>,
  pickingColor: vec3<f32>,
};

var<private> geometry_: VertexGeometry = VertexGeometry(
  vec4<f32>(0.0, 0.0, 1.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec2<f32>(0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0)
);

struct FragmentGeometry {
  uv: vec2<f32>,
};

var<private> fragmentGeometry: FragmentGeometry;

fn smoothedge(edge: f32, x: f32) -> f32 {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`;
var defines = "#define SMOOTH_EDGE_RADIUS 0.5";
var vs$1 = `\
${defines}

struct VertexGeometry {
  vec4 position;
  vec3 worldPosition;
  vec3 worldPositionAlt;
  vec3 normal;
  vec2 uv;
  vec3 pickingColor;
} geometry = VertexGeometry(
  vec4(0.0, 0.0, 1.0, 0.0),
  vec3(0.0),
  vec3(0.0),
  vec3(0.0),
  vec2(0.0),
  vec3(0.0)
);
`;
var fs = `\
${defines}

struct FragmentGeometry {
  vec2 uv;
} geometry;

float smoothedge(float edge, float x) {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`;
var geometry_default = {
	name: "geometry",
	source: source$1,
	vs: vs$1,
	fs
};

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/input-consts.js
const COMPUTE_INTERVAL = 25;
var InputEvent;
(function(InputEvent$1) {
	InputEvent$1[InputEvent$1["Start"] = 1] = "Start";
	InputEvent$1[InputEvent$1["Move"] = 2] = "Move";
	InputEvent$1[InputEvent$1["End"] = 4] = "End";
	InputEvent$1[InputEvent$1["Cancel"] = 8] = "Cancel";
})(InputEvent || (InputEvent = {}));
var InputDirection;
(function(InputDirection$1) {
	InputDirection$1[InputDirection$1["None"] = 0] = "None";
	InputDirection$1[InputDirection$1["Left"] = 1] = "Left";
	InputDirection$1[InputDirection$1["Right"] = 2] = "Right";
	InputDirection$1[InputDirection$1["Up"] = 4] = "Up";
	InputDirection$1[InputDirection$1["Down"] = 8] = "Down";
	InputDirection$1[InputDirection$1["Horizontal"] = 3] = "Horizontal";
	InputDirection$1[InputDirection$1["Vertical"] = 12] = "Vertical";
	InputDirection$1[InputDirection$1["All"] = 15] = "All";
})(InputDirection || (InputDirection = {}));

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/recognizer/recognizer-state.js
var RecognizerState;
(function(RecognizerState$1) {
	RecognizerState$1[RecognizerState$1["Possible"] = 1] = "Possible";
	RecognizerState$1[RecognizerState$1["Began"] = 2] = "Began";
	RecognizerState$1[RecognizerState$1["Changed"] = 4] = "Changed";
	RecognizerState$1[RecognizerState$1["Ended"] = 8] = "Ended";
	RecognizerState$1[RecognizerState$1["Recognized"] = 8] = "Recognized";
	RecognizerState$1[RecognizerState$1["Cancelled"] = 16] = "Cancelled";
	RecognizerState$1[RecognizerState$1["Failed"] = 32] = "Failed";
})(RecognizerState || (RecognizerState = {}));

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/touchaction/touchaction-Consts.js
const TOUCH_ACTION_COMPUTE = "compute";
const TOUCH_ACTION_AUTO = "auto";
const TOUCH_ACTION_MANIPULATION = "manipulation";
const TOUCH_ACTION_NONE = "none";
const TOUCH_ACTION_PAN_X = "pan-x";
const TOUCH_ACTION_PAN_Y = "pan-y";

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/touchaction/clean-touch-actions.js
/**
* when the touchActions are collected they are not a valid value, so we need to clean things up. *
* @returns valid touchAction
*/
function cleanTouchActions(actions) {
	if (actions.includes(TOUCH_ACTION_NONE)) return TOUCH_ACTION_NONE;
	const hasPanX = actions.includes(TOUCH_ACTION_PAN_X);
	const hasPanY = actions.includes(TOUCH_ACTION_PAN_Y);
	if (hasPanX && hasPanY) return TOUCH_ACTION_NONE;
	if (hasPanX || hasPanY) return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
	if (actions.includes(TOUCH_ACTION_MANIPULATION)) return TOUCH_ACTION_MANIPULATION;
	return TOUCH_ACTION_AUTO;
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/touchaction/touchaction.js
/**
* Touch Action
* sets the touchAction property or uses the js alternative
*/
var TouchAction = class {
	constructor(manager, value) {
		this.actions = "";
		this.manager = manager;
		this.set(value);
	}
	/**
	* set the touchAction value on the element or enable the polyfill
	*/
	set(value) {
		if (value === TOUCH_ACTION_COMPUTE) value = this.compute();
		if (this.manager.element) {
			this.manager.element.style.touchAction = value;
			this.actions = value;
		}
	}
	/**
	* just re-set the touchAction value
	*/
	update() {
		this.set(this.manager.options.touchAction);
	}
	/**
	* compute the value for the touchAction property based on the recognizer's settings
	*/
	compute() {
		let actions = [];
		for (const recognizer of this.manager.recognizers) if (recognizer.options.enable) actions = actions.concat(recognizer.getTouchAction());
		return cleanTouchActions(actions.join(" "));
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/utils/split-str.js
/**
* split string on whitespace
* @returns {Array} words
*/
function splitStr(str) {
	return str.trim().split(/\s+/g);
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/utils/event-listeners.js
/**
* addEventListener with multiple events at once
*/
function addEventListeners(target, types, handler) {
	if (!target) return;
	for (const type of splitStr(types)) target.addEventListener(type, handler, false);
}
/**
* removeEventListener with multiple events at once
*/
function removeEventListeners(target, types, handler) {
	if (!target) return;
	for (const type of splitStr(types)) target.removeEventListener(type, handler, false);
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/utils/get-window-for-element.js
/**
* get the window object of an element
*/
function getWindowForElement(element) {
	return (element.ownerDocument || element).defaultView;
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/utils/has-parent.js
/**
* find if a node is in the given parent
*/
function hasParent(node, parent) {
	let ancestor = node;
	while (ancestor) {
		if (ancestor === parent) return true;
		ancestor = ancestor.parentNode;
	}
	return false;
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/get-center.js
/**
* get the center of all the pointers
*/
function getCenter(pointers) {
	const pointersLength = pointers.length;
	if (pointersLength === 1) return {
		x: Math.round(pointers[0].clientX),
		y: Math.round(pointers[0].clientY)
	};
	let x = 0;
	let y = 0;
	let i = 0;
	while (i < pointersLength) {
		x += pointers[i].clientX;
		y += pointers[i].clientY;
		i++;
	}
	return {
		x: Math.round(x / pointersLength),
		y: Math.round(y / pointersLength)
	};
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/simple-clone-input-data.js
/**
* create a simple clone from the input used for storage of firstInput and firstMultiple
*/
function simpleCloneInputData(input) {
	const pointers = [];
	let i = 0;
	while (i < input.pointers.length) {
		pointers[i] = {
			clientX: Math.round(input.pointers[i].clientX),
			clientY: Math.round(input.pointers[i].clientY)
		};
		i++;
	}
	return {
		timeStamp: Date.now(),
		pointers,
		center: getCenter(pointers),
		deltaX: input.deltaX,
		deltaY: input.deltaY
	};
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/get-distance.js
/**
* calculate the absolute distance between two points
* @returns distance
*/
function getPointDistance(p1, p2) {
	const x = p2.x - p1.x;
	const y = p2.y - p1.y;
	return Math.sqrt(x * x + y * y);
}
/**
* calculate the absolute distance between two pointer events
* @returns distance
*/
function getEventDistance(p1, p2) {
	const x = p2.clientX - p1.clientX;
	const y = p2.clientY - p1.clientY;
	return Math.sqrt(x * x + y * y);
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/get-angle.js
/**
* calculate the angle between two coordinates
* @returns angle in degrees
*/
function getPointAngle(p1, p2) {
	const x = p2.x - p1.x;
	const y = p2.y - p1.y;
	return Math.atan2(y, x) * 180 / Math.PI;
}
/**
* calculate the angle between two pointer events
* @returns angle in degrees
*/
function getEventAngle(p1, p2) {
	const x = p2.clientX - p1.clientX;
	const y = p2.clientY - p1.clientY;
	return Math.atan2(y, x) * 180 / Math.PI;
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/get-direction.js
/**
* get the direction between two points
* @returns direction
*/
function getDirection(dx, dy) {
	if (dx === dy) return InputDirection.None;
	if (Math.abs(dx) >= Math.abs(dy)) return dx < 0 ? InputDirection.Left : InputDirection.Right;
	return dy < 0 ? InputDirection.Up : InputDirection.Down;
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/get-delta-xy.js
/** Populates input.deltaX, input.deltaY */
function computeDeltaXY(session, input) {
	const center = input.center;
	let offset = session.offsetDelta;
	let prevDelta = session.prevDelta;
	const prevInput = session.prevInput;
	if (input.eventType === InputEvent.Start || prevInput?.eventType === InputEvent.End) {
		prevDelta = session.prevDelta = {
			x: prevInput?.deltaX || 0,
			y: prevInput?.deltaY || 0
		};
		offset = session.offsetDelta = {
			x: center.x,
			y: center.y
		};
	}
	return {
		deltaX: prevDelta.x + (center.x - offset.x),
		deltaY: prevDelta.y + (center.y - offset.y)
	};
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/get-velocity.js
/**
* calculate the velocity between two points. unit is in px per ms.
*/
function getVelocity(deltaTime, x, y) {
	return {
		x: x / deltaTime || 0,
		y: y / deltaTime || 0
	};
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/get-scale.js
/**
* calculate the scale factor between two pointersets
* no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
*/
function getScale(start, end) {
	return getEventDistance(end[0], end[1]) / getEventDistance(start[0], start[1]);
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/get-rotation.js
/**
* calculate the rotation degrees between two pointer sets
* @returns rotation in degrees
*/
function getRotation(start, end) {
	return getEventAngle(end[1], end[0]) - getEventAngle(start[1], start[0]);
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/compute-interval-input-data.js
/**
* velocity is calculated every x ms
*/
function computeIntervalInputData(session, input) {
	const last = session.lastInterval || input;
	const deltaTime = input.timeStamp - last.timeStamp;
	let velocity;
	let velocityX;
	let velocityY;
	let direction;
	if (input.eventType !== InputEvent.Cancel && (deltaTime > COMPUTE_INTERVAL || last.velocity === void 0)) {
		const deltaX = input.deltaX - last.deltaX;
		const deltaY = input.deltaY - last.deltaY;
		const v = getVelocity(deltaTime, deltaX, deltaY);
		velocityX = v.x;
		velocityY = v.y;
		velocity = Math.abs(v.x) > Math.abs(v.y) ? v.x : v.y;
		direction = getDirection(deltaX, deltaY);
		session.lastInterval = input;
	} else {
		velocity = last.velocity;
		velocityX = last.velocityX;
		velocityY = last.velocityY;
		direction = last.direction;
	}
	input.velocity = velocity;
	input.velocityX = velocityX;
	input.velocityY = velocityY;
	input.direction = direction;
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/compute-input-data.js
/**
* extend the data with some usable properties like scale, rotate, velocity etc
*/
function computeInputData(manager, input) {
	const { session } = manager;
	const { pointers } = input;
	const { length: pointersLength } = pointers;
	if (!session.firstInput) session.firstInput = simpleCloneInputData(input);
	if (pointersLength > 1 && !session.firstMultiple) session.firstMultiple = simpleCloneInputData(input);
	else if (pointersLength === 1) session.firstMultiple = false;
	const { firstInput, firstMultiple } = session;
	const offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
	const center = input.center = getCenter(pointers);
	input.timeStamp = Date.now();
	input.deltaTime = input.timeStamp - firstInput.timeStamp;
	input.angle = getPointAngle(offsetCenter, center);
	input.distance = getPointDistance(offsetCenter, center);
	const { deltaX, deltaY } = computeDeltaXY(session, input);
	input.deltaX = deltaX;
	input.deltaY = deltaY;
	input.offsetDirection = getDirection(input.deltaX, input.deltaY);
	const overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
	input.overallVelocityX = overallVelocity.x;
	input.overallVelocityY = overallVelocity.y;
	input.overallVelocity = Math.abs(overallVelocity.x) > Math.abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
	input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
	input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
	input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
	let target = manager.element;
	if (hasParent(input.srcEvent.target, target)) target = input.srcEvent.target;
	input.target = target;
	computeIntervalInputData(session, input);
	return input;
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/input-handler.js
/**
* handle input events
*/
function inputHandler(manager, eventType, input) {
	const pointersLen = input.pointers.length;
	const changedPointersLen = input.changedPointers.length;
	const isFirst = eventType & InputEvent.Start && pointersLen - changedPointersLen === 0;
	const isFinal = eventType & (InputEvent.End | InputEvent.Cancel) && pointersLen - changedPointersLen === 0;
	input.isFirst = Boolean(isFirst);
	input.isFinal = Boolean(isFinal);
	if (isFirst) manager.session = {};
	input.eventType = eventType;
	const processedInput = computeInputData(manager, input);
	manager.emit("hammer.input", processedInput);
	manager.recognize(processedInput);
	manager.session.prevInput = processedInput;
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/input.js
/**
* create new input type manager
*/
var Input$1 = class {
	constructor(manager) {
		this.evEl = "";
		this.evWin = "";
		this.evTarget = "";
		/** smaller wrapper around the handler, for the scope and the enabled state of the manager,
		* so when disabled the input events are completely bypassed.
		*/
		this.domHandler = (ev) => {
			if (this.manager.options.enable) this.handler(ev);
		};
		this.manager = manager;
		this.element = manager.element;
		this.target = manager.options.inputTarget || manager.element;
	}
	callback(eventType, input) {
		inputHandler(this.manager, eventType, input);
	}
	/**
	* bind the events
	*/
	init() {
		addEventListeners(this.element, this.evEl, this.domHandler);
		addEventListeners(this.target, this.evTarget, this.domHandler);
		addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
	}
	/**
	* unbind the events
	*/
	destroy() {
		removeEventListeners(this.element, this.evEl, this.domHandler);
		removeEventListeners(this.target, this.evTarget, this.domHandler);
		removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/inputs/pointerevent.js
var POINTER_INPUT_MAP = {
	pointerdown: InputEvent.Start,
	pointermove: InputEvent.Move,
	pointerup: InputEvent.End,
	pointercancel: InputEvent.Cancel,
	pointerout: InputEvent.Cancel
};
var POINTER_ELEMENT_EVENTS = "pointerdown";
var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
/**
* Pointer events input
*/
var PointerEventInput = class extends Input$1 {
	constructor(manager) {
		super(manager);
		this.evEl = POINTER_ELEMENT_EVENTS;
		this.evWin = POINTER_WINDOW_EVENTS;
		this.store = this.manager.session.pointerEvents = [];
		this.init();
	}
	/**
	* handle mouse events
	*/
	handler(ev) {
		const { store } = this;
		let removePointer = false;
		const eventType = POINTER_INPUT_MAP[ev.type];
		const pointerType = ev.pointerType;
		const isTouch = pointerType === "touch";
		let storeIndex = store.findIndex((e) => e.pointerId === ev.pointerId);
		if (eventType & InputEvent.Start && (ev.buttons || isTouch)) {
			if (storeIndex < 0) {
				store.push(ev);
				storeIndex = store.length - 1;
			}
		} else if (eventType & (InputEvent.End | InputEvent.Cancel)) removePointer = true;
		if (storeIndex < 0) return;
		store[storeIndex] = ev;
		this.callback(eventType, {
			pointers: store,
			changedPointers: [ev],
			eventType,
			pointerType,
			srcEvent: ev
		});
		if (removePointer) store.splice(storeIndex, 1);
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/utils/prefixed.js
var VENDOR_PREFIXES = [
	"",
	"webkit",
	"Moz",
	"MS",
	"ms",
	"o"
];
/**
* get the prefixed property
* @returns prefixed property name
*/
function prefixed(obj, property) {
	const camelProp = property[0].toUpperCase() + property.slice(1);
	for (const prefix of VENDOR_PREFIXES) {
		const prop = prefix ? prefix + camelProp : property;
		if (prop in obj) return prop;
	}
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/manager.js
var STOP = 1;
var FORCED_STOP = 2;
var defaultOptions = {
	touchAction: "compute",
	enable: true,
	inputTarget: null,
	cssProps: {
		userSelect: "none",
		userDrag: "none",
		touchCallout: "none",
		tapHighlightColor: "rgba(0,0,0,0)"
	}
};
/**
* Manager
*/
var Manager = class {
	constructor(element, options) {
		this.options = {
			...defaultOptions,
			...options,
			cssProps: {
				...defaultOptions.cssProps,
				...options.cssProps
			},
			inputTarget: options.inputTarget || element
		};
		this.handlers = {};
		this.session = {};
		this.recognizers = [];
		this.oldCssProps = {};
		this.element = element;
		this.input = new PointerEventInput(this);
		this.touchAction = new TouchAction(this, this.options.touchAction);
		this.toggleCssProps(true);
	}
	/**
	* set options
	*/
	set(options) {
		Object.assign(this.options, options);
		if (options.touchAction) this.touchAction.update();
		if (options.inputTarget) {
			this.input.destroy();
			this.input.target = options.inputTarget;
			this.input.init();
		}
		return this;
	}
	/**
	* stop recognizing for this session.
	* This session will be discarded, when a new [input]start event is fired.
	* When forced, the recognizer cycle is stopped immediately.
	*/
	stop(force) {
		this.session.stopped = force ? FORCED_STOP : STOP;
	}
	/**
	* run the recognizers!
	* called by the inputHandler function on every movement of the pointers (touches)
	* it walks through all the recognizers and tries to detect the gesture that is being made
	*/
	recognize(inputData) {
		const { session } = this;
		if (session.stopped) return;
		if (this.session.prevented) inputData.srcEvent.preventDefault();
		let recognizer;
		const { recognizers } = this;
		let { curRecognizer } = session;
		if (!curRecognizer || curRecognizer && curRecognizer.state & RecognizerState.Recognized) curRecognizer = session.curRecognizer = null;
		let i = 0;
		while (i < recognizers.length) {
			recognizer = recognizers[i];
			if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer === curRecognizer || recognizer.canRecognizeWith(curRecognizer))) recognizer.recognize(inputData);
			else recognizer.reset();
			if (!curRecognizer && recognizer.state & (RecognizerState.Began | RecognizerState.Changed | RecognizerState.Ended)) curRecognizer = session.curRecognizer = recognizer;
			i++;
		}
	}
	/**
	* get a recognizer by its event name.
	*/
	get(recognizerName) {
		const { recognizers } = this;
		for (let i = 0; i < recognizers.length; i++) if (recognizers[i].options.event === recognizerName) return recognizers[i];
		return null;
	}
	/**
	* add a recognizer to the manager
	* existing recognizers with the same event name will be removed
	*/
	add(recognizer) {
		if (Array.isArray(recognizer)) {
			for (const item of recognizer) this.add(item);
			return this;
		}
		const existing = this.get(recognizer.options.event);
		if (existing) this.remove(existing);
		this.recognizers.push(recognizer);
		recognizer.manager = this;
		this.touchAction.update();
		return recognizer;
	}
	/**
	* remove a recognizer by name or instance
	*/
	remove(recognizerOrName) {
		if (Array.isArray(recognizerOrName)) {
			for (const item of recognizerOrName) this.remove(item);
			return this;
		}
		const recognizer = typeof recognizerOrName === "string" ? this.get(recognizerOrName) : recognizerOrName;
		if (recognizer) {
			const { recognizers } = this;
			const index = recognizers.indexOf(recognizer);
			if (index !== -1) {
				recognizers.splice(index, 1);
				this.touchAction.update();
			}
		}
		return this;
	}
	/**
	* bind event
	*/
	on(events, handler) {
		if (!events || !handler) return;
		const { handlers } = this;
		for (const event of splitStr(events)) {
			handlers[event] = handlers[event] || [];
			handlers[event].push(handler);
		}
	}
	/**
	* unbind event, leave hander blank to remove all handlers
	*/
	off(events, handler) {
		if (!events) return;
		const { handlers } = this;
		for (const event of splitStr(events)) if (!handler) delete handlers[event];
		else if (handlers[event]) handlers[event].splice(handlers[event].indexOf(handler), 1);
	}
	/**
	* emit event to the listeners
	*/
	emit(event, data) {
		const handlers = this.handlers[event] && this.handlers[event].slice();
		if (!handlers || !handlers.length) return;
		const evt = data;
		evt.type = event;
		evt.preventDefault = function() {
			data.srcEvent.preventDefault();
		};
		let i = 0;
		while (i < handlers.length) {
			handlers[i](evt);
			i++;
		}
	}
	/**
	* destroy the manager and unbinds all events
	* it doesn't unbind dom events, that is the user own responsibility
	*/
	destroy() {
		this.toggleCssProps(false);
		this.handlers = {};
		this.session = {};
		this.input.destroy();
		this.element = null;
	}
	/**
	* add/remove the css properties as defined in manager.options.cssProps
	*/
	toggleCssProps(add$1) {
		const { element } = this;
		if (!element) return;
		for (const [name, value] of Object.entries(this.options.cssProps)) {
			const prop = prefixed(element.style, name);
			if (add$1) {
				this.oldCssProps[prop] = element.style[prop];
				element.style[prop] = value;
			} else element.style[prop] = this.oldCssProps[prop] || "";
		}
		if (!add$1) this.oldCssProps = {};
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/utils/unique-id.js
/**
* get a unique id
*/
var _uniqueId = 1;
function uniqueId() {
	return _uniqueId++;
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/recognizer/state-str.js
/**
* get a usable string, used as event postfix
*/
function stateStr(state) {
	if (state & RecognizerState.Cancelled) return "cancel";
	else if (state & RecognizerState.Ended) return "end";
	else if (state & RecognizerState.Changed) return "move";
	else if (state & RecognizerState.Began) return "start";
	return "";
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/recognizer/recognizer.js
/**
* Recognizer flow explained; *
* All recognizers have the initial state of POSSIBLE when a input session starts.
* The definition of a input session is from the first input until the last input, with all it's movement in it. *
* Example session for mouse-input: mousedown -> mousemove -> mouseup
*
* On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
* which determines with state it should be.
*
* If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
* POSSIBLE to give it another change on the next cycle.
*
*               Possible
*                  |
*            +-----+---------------+
*            |                     |
*      +-----+-----+               |
*      |           |               |
*   Failed      Cancelled          |
*                          +-------+------+
*                          |              |
*                      Recognized       Began
*                                         |
*                                      Changed
*                                         |
*                                  Ended/Recognized
*/
/**
* Recognizer
* Every recognizer needs to extend from this class.
*/
var Recognizer = class {
	constructor(options) {
		this.options = options;
		this.id = uniqueId();
		this.state = RecognizerState.Possible;
		this.simultaneous = {};
		this.requireFail = [];
	}
	/**
	* set options
	*/
	set(options) {
		Object.assign(this.options, options);
		this.manager.touchAction.update();
		return this;
	}
	/**
	* recognize simultaneous with an other recognizer.
	*/
	recognizeWith(recognizerOrName) {
		if (Array.isArray(recognizerOrName)) {
			for (const item of recognizerOrName) this.recognizeWith(item);
			return this;
		}
		let otherRecognizer;
		if (typeof recognizerOrName === "string") {
			otherRecognizer = this.manager.get(recognizerOrName);
			if (!otherRecognizer) throw new Error(`Cannot find recognizer ${recognizerOrName}`);
		} else otherRecognizer = recognizerOrName;
		const { simultaneous } = this;
		if (!simultaneous[otherRecognizer.id]) {
			simultaneous[otherRecognizer.id] = otherRecognizer;
			otherRecognizer.recognizeWith(this);
		}
		return this;
	}
	/**
	* drop the simultaneous link. it doesnt remove the link on the other recognizer.
	*/
	dropRecognizeWith(recognizerOrName) {
		if (Array.isArray(recognizerOrName)) {
			for (const item of recognizerOrName) this.dropRecognizeWith(item);
			return this;
		}
		let otherRecognizer;
		if (typeof recognizerOrName === "string") otherRecognizer = this.manager.get(recognizerOrName);
		else otherRecognizer = recognizerOrName;
		if (otherRecognizer) delete this.simultaneous[otherRecognizer.id];
		return this;
	}
	/**
	* recognizer can only run when an other is failing
	*/
	requireFailure(recognizerOrName) {
		if (Array.isArray(recognizerOrName)) {
			for (const item of recognizerOrName) this.requireFailure(item);
			return this;
		}
		let otherRecognizer;
		if (typeof recognizerOrName === "string") {
			otherRecognizer = this.manager.get(recognizerOrName);
			if (!otherRecognizer) throw new Error(`Cannot find recognizer ${recognizerOrName}`);
		} else otherRecognizer = recognizerOrName;
		const { requireFail } = this;
		if (requireFail.indexOf(otherRecognizer) === -1) {
			requireFail.push(otherRecognizer);
			otherRecognizer.requireFailure(this);
		}
		return this;
	}
	/**
	* drop the requireFailure link. it does not remove the link on the other recognizer.
	*/
	dropRequireFailure(recognizerOrName) {
		if (Array.isArray(recognizerOrName)) {
			for (const item of recognizerOrName) this.dropRequireFailure(item);
			return this;
		}
		let otherRecognizer;
		if (typeof recognizerOrName === "string") otherRecognizer = this.manager.get(recognizerOrName);
		else otherRecognizer = recognizerOrName;
		if (otherRecognizer) {
			const index = this.requireFail.indexOf(otherRecognizer);
			if (index > -1) this.requireFail.splice(index, 1);
		}
		return this;
	}
	/**
	* has require failures boolean
	*/
	hasRequireFailures() {
		return Boolean(this.requireFail.find((recognier) => recognier.options.enable));
	}
	/**
	* if the recognizer can recognize simultaneous with an other recognizer
	*/
	canRecognizeWith(otherRecognizer) {
		return Boolean(this.simultaneous[otherRecognizer.id]);
	}
	/**
	* You should use `tryEmit` instead of `emit` directly to check
	* that all the needed recognizers has failed before emitting.
	*/
	emit(input) {
		if (!input) return;
		const { state } = this;
		if (state < RecognizerState.Ended) this.manager.emit(this.options.event + stateStr(state), input);
		this.manager.emit(this.options.event, input);
		if (input.additionalEvent) this.manager.emit(input.additionalEvent, input);
		if (state >= RecognizerState.Ended) this.manager.emit(this.options.event + stateStr(state), input);
	}
	/**
	* Check that all the require failure recognizers has failed,
	* if true, it emits a gesture event,
	* otherwise, setup the state to FAILED.
	*/
	tryEmit(input) {
		if (this.canEmit()) this.emit(input);
		else this.state = RecognizerState.Failed;
	}
	/**
	* can we emit?
	*/
	canEmit() {
		let i = 0;
		while (i < this.requireFail.length) {
			if (!(this.requireFail[i].state & (RecognizerState.Failed | RecognizerState.Possible))) return false;
			i++;
		}
		return true;
	}
	/**
	* update the recognizer
	*/
	recognize(inputData) {
		const inputDataClone = { ...inputData };
		if (!this.options.enable) {
			this.reset();
			this.state = RecognizerState.Failed;
			return;
		}
		if (this.state & (RecognizerState.Recognized | RecognizerState.Cancelled | RecognizerState.Failed)) this.state = RecognizerState.Possible;
		this.state = this.process(inputDataClone);
		if (this.state & (RecognizerState.Began | RecognizerState.Changed | RecognizerState.Ended | RecognizerState.Cancelled)) this.tryEmit(inputDataClone);
	}
	/**
	* return the event names that are emitted by this recognizer
	*/
	getEventNames() {
		return [this.options.event];
	}
	/**
	* called when the gesture isn't allowed to recognize
	* like when another is being recognized or it is disabled
	*/
	reset() {}
};

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/recognizers/attribute.js
/**
* This recognizer is just used as a base for the simple attribute recognizers.
*/
var AttrRecognizer = class extends Recognizer {
	/**
	* Used to check if it the recognizer receives valid input, like input.distance > 10.
	*/
	attrTest(input) {
		const optionPointers = this.options.pointers;
		return optionPointers === 0 || input.pointers.length === optionPointers;
	}
	/**
	* Process the input and return the state for the recognizer
	*/
	process(input) {
		const { state } = this;
		const { eventType } = input;
		const isRecognized = state & (RecognizerState.Began | RecognizerState.Changed);
		const isValid = this.attrTest(input);
		if (isRecognized && (eventType & InputEvent.Cancel || !isValid)) return state | RecognizerState.Cancelled;
		else if (isRecognized || isValid) {
			if (eventType & InputEvent.End) return state | RecognizerState.Ended;
			else if (!(state & RecognizerState.Began)) return RecognizerState.Began;
			return state | RecognizerState.Changed;
		}
		return RecognizerState.Failed;
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/recognizers/tap.js
/**
* A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
* between the given interval and position. The delay option can be used to recognize multi-taps without firing
* a single tap.
*
* The eventData from the emitted event contains the property `tapCount`, which contains the amount of
* multi-taps being recognized.
*/
var TapRecognizer = class extends Recognizer {
	constructor(options = {}) {
		super({
			enable: true,
			event: "tap",
			pointers: 1,
			taps: 1,
			interval: 300,
			time: 250,
			threshold: 9,
			posThreshold: 10,
			...options
		});
		/** previous time for tap counting */
		this.pTime = null;
		/** previous center for tap counting */
		this.pCenter = null;
		this._timer = null;
		this._input = null;
		this.count = 0;
	}
	getTouchAction() {
		return [TOUCH_ACTION_MANIPULATION];
	}
	process(input) {
		const { options } = this;
		const validPointers = input.pointers.length === options.pointers;
		const validMovement = input.distance < options.threshold;
		const validTouchTime = input.deltaTime < options.time;
		this.reset();
		if (input.eventType & InputEvent.Start && this.count === 0) return this.failTimeout();
		if (validMovement && validTouchTime && validPointers) {
			if (input.eventType !== InputEvent.End) return this.failTimeout();
			const validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
			const validMultiTap = !this.pCenter || getPointDistance(this.pCenter, input.center) < options.posThreshold;
			this.pTime = input.timeStamp;
			this.pCenter = input.center;
			if (!validMultiTap || !validInterval) this.count = 1;
			else this.count += 1;
			this._input = input;
			if (this.count % options.taps === 0) {
				if (!this.hasRequireFailures()) return RecognizerState.Recognized;
				this._timer = setTimeout(() => {
					this.state = RecognizerState.Recognized;
					this.tryEmit(this._input);
				}, options.interval);
				return RecognizerState.Began;
			}
		}
		return RecognizerState.Failed;
	}
	failTimeout() {
		this._timer = setTimeout(() => {
			this.state = RecognizerState.Failed;
		}, this.options.interval);
		return RecognizerState.Failed;
	}
	reset() {
		clearTimeout(this._timer);
	}
	emit(input) {
		if (this.state === RecognizerState.Recognized) {
			input.tapCount = this.count;
			this.manager.emit(this.options.event, input);
		}
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/recognizers/pan.js
var EVENT_NAMES$1 = [
	"",
	"start",
	"move",
	"end",
	"cancel",
	"up",
	"down",
	"left",
	"right"
];
/**
* Pan
* Recognized when the pointer is down and moved in the allowed direction.
*/
var PanRecognizer = class extends AttrRecognizer {
	constructor(options = {}) {
		super({
			enable: true,
			pointers: 1,
			event: "pan",
			threshold: 10,
			direction: InputDirection.All,
			...options
		});
		this.pX = null;
		this.pY = null;
	}
	getTouchAction() {
		const { options: { direction } } = this;
		const actions = [];
		if (direction & InputDirection.Horizontal) actions.push(TOUCH_ACTION_PAN_Y);
		if (direction & InputDirection.Vertical) actions.push(TOUCH_ACTION_PAN_X);
		return actions;
	}
	getEventNames() {
		return EVENT_NAMES$1.map((suffix) => this.options.event + suffix);
	}
	directionTest(input) {
		const { options } = this;
		let hasMoved = true;
		let { distance } = input;
		let { direction } = input;
		const x = input.deltaX;
		const y = input.deltaY;
		if (!(direction & options.direction)) if (options.direction & InputDirection.Horizontal) {
			direction = x === 0 ? InputDirection.None : x < 0 ? InputDirection.Left : InputDirection.Right;
			hasMoved = x !== this.pX;
			distance = Math.abs(input.deltaX);
		} else {
			direction = y === 0 ? InputDirection.None : y < 0 ? InputDirection.Up : InputDirection.Down;
			hasMoved = y !== this.pY;
			distance = Math.abs(input.deltaY);
		}
		input.direction = direction;
		return hasMoved && distance > options.threshold && Boolean(direction & options.direction);
	}
	attrTest(input) {
		return super.attrTest(input) && (Boolean(this.state & RecognizerState.Began) || !(this.state & RecognizerState.Began) && this.directionTest(input));
	}
	emit(input) {
		this.pX = input.deltaX;
		this.pY = input.deltaY;
		const direction = InputDirection[input.direction].toLowerCase();
		if (direction) input.additionalEvent = this.options.event + direction;
		super.emit(input);
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/recognizers/pinch.js
var EVENT_NAMES = [
	"",
	"start",
	"move",
	"end",
	"cancel",
	"in",
	"out"
];
/**
* Pinch
* Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
*/
var PinchRecognizer = class extends AttrRecognizer {
	constructor(options = {}) {
		super({
			enable: true,
			event: "pinch",
			threshold: 0,
			pointers: 2,
			...options
		});
	}
	getTouchAction() {
		return [TOUCH_ACTION_NONE];
	}
	getEventNames() {
		return EVENT_NAMES.map((suffix) => this.options.event + suffix);
	}
	attrTest(input) {
		return super.attrTest(input) && (Math.abs(input.scale - 1) > this.options.threshold || Boolean(this.state & RecognizerState.Began));
	}
	emit(input) {
		if (input.scale !== 1) {
			const inOut = input.scale < 1 ? "in" : "out";
			input.additionalEvent = this.options.event + inOut;
		}
		super.emit(input);
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/inputs/input.js
var Input = class {
	constructor(element, callback, options) {
		this.element = element;
		this.callback = callback;
		this.options = options;
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/utils/globals.js
const userAgent = typeof navigator !== "undefined" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "";
var window_ = typeof window !== "undefined" ? window : global;

//#endregion
//#region node_modules/mjolnir.js/dist/inputs/wheel-input.js
var firefox = userAgent.indexOf("firefox") !== -1;
var WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
var WHEEL_DELTA_PER_LINE = 40;
var SHIFT_MULTIPLIER = .25;
var WheelInput = class extends Input {
	constructor(element, callback, options) {
		super(element, callback, {
			enable: true,
			...options
		});
		this.handleEvent = (event) => {
			if (!this.options.enable) return;
			let value = event.deltaY;
			if (globalThis.WheelEvent) {
				if (firefox && event.deltaMode === globalThis.WheelEvent.DOM_DELTA_PIXEL) value /= globalThis.devicePixelRatio;
				if (event.deltaMode === globalThis.WheelEvent.DOM_DELTA_LINE) value *= WHEEL_DELTA_PER_LINE;
			}
			if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);
			if (event.shiftKey && value) value = value * SHIFT_MULTIPLIER;
			this.callback({
				type: "wheel",
				center: {
					x: event.clientX,
					y: event.clientY
				},
				delta: -value,
				srcEvent: event,
				pointerType: "mouse",
				target: event.target
			});
		};
		element.addEventListener("wheel", this.handleEvent, { passive: false });
	}
	destroy() {
		this.element.removeEventListener("wheel", this.handleEvent);
	}
	/**
	* Enable this input (begin processing events)
	* if the specified event type is among those handled by this input.
	*/
	enableEventType(eventType, enabled) {
		if (eventType === "wheel") this.options.enable = enabled;
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/inputs/move-input.js
var MOUSE_EVENTS$1 = [
	"mousedown",
	"mousemove",
	"mouseup",
	"mouseover",
	"mouseout",
	"mouseleave"
];
/**
* Hammer.js swallows 'move' events (for pointer/touch/mouse)
* when the pointer is not down. This class sets up a handler
* specifically for these events to work around this limitation.
* Note that this could be extended to more intelligently handle
* move events across input types, e.g. storing multiple simultaneous
* pointer/touch events, calculating speed/direction, etc.
*/
var MoveInput = class extends Input {
	constructor(element, callback, options) {
		super(element, callback, {
			enable: true,
			...options
		});
		this.handleEvent = (event) => {
			this.handleOverEvent(event);
			this.handleOutEvent(event);
			this.handleEnterEvent(event);
			this.handleLeaveEvent(event);
			this.handleMoveEvent(event);
		};
		this.pressed = false;
		const { enable } = this.options;
		this.enableMoveEvent = enable;
		this.enableLeaveEvent = enable;
		this.enableEnterEvent = enable;
		this.enableOutEvent = enable;
		this.enableOverEvent = enable;
		MOUSE_EVENTS$1.forEach((event) => element.addEventListener(event, this.handleEvent));
	}
	destroy() {
		MOUSE_EVENTS$1.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
	}
	/**
	* Enable this input (begin processing events)
	* if the specified event type is among those handled by this input.
	*/
	enableEventType(eventType, enabled) {
		switch (eventType) {
			case "pointermove":
				this.enableMoveEvent = enabled;
				break;
			case "pointerover":
				this.enableOverEvent = enabled;
				break;
			case "pointerout":
				this.enableOutEvent = enabled;
				break;
			case "pointerenter":
				this.enableEnterEvent = enabled;
				break;
			case "pointerleave":
				this.enableLeaveEvent = enabled;
				break;
			default:
		}
	}
	handleOverEvent(event) {
		if (this.enableOverEvent && event.type === "mouseover") this._emit("pointerover", event);
	}
	handleOutEvent(event) {
		if (this.enableOutEvent && event.type === "mouseout") this._emit("pointerout", event);
	}
	handleEnterEvent(event) {
		if (this.enableEnterEvent && event.type === "mouseenter") this._emit("pointerenter", event);
	}
	handleLeaveEvent(event) {
		if (this.enableLeaveEvent && event.type === "mouseleave") this._emit("pointerleave", event);
	}
	handleMoveEvent(event) {
		if (this.enableMoveEvent) switch (event.type) {
			case "mousedown":
				if (event.button >= 0) this.pressed = true;
				break;
			case "mousemove":
				if (event.buttons === 0) this.pressed = false;
				if (!this.pressed) this._emit("pointermove", event);
				break;
			case "mouseup":
				this.pressed = false;
				break;
			default:
		}
	}
	_emit(type, event) {
		this.callback({
			type,
			center: {
				x: event.clientX,
				y: event.clientY
			},
			srcEvent: event,
			pointerType: "mouse",
			target: event.target
		});
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/inputs/key-input.js
var KEY_EVENTS = ["keydown", "keyup"];
var KeyInput = class extends Input {
	constructor(element, callback, options) {
		super(element, callback, {
			enable: true,
			tabIndex: 0,
			...options
		});
		this.handleEvent = (event) => {
			const targetElement = event.target || event.srcElement;
			if (targetElement.tagName === "INPUT" && targetElement.type === "text" || targetElement.tagName === "TEXTAREA") return;
			if (this.enableDownEvent && event.type === "keydown") this.callback({
				type: "keydown",
				srcEvent: event,
				key: event.key,
				target: event.target
			});
			if (this.enableUpEvent && event.type === "keyup") this.callback({
				type: "keyup",
				srcEvent: event,
				key: event.key,
				target: event.target
			});
		};
		this.enableDownEvent = this.options.enable;
		this.enableUpEvent = this.options.enable;
		element.tabIndex = this.options.tabIndex;
		element.style.outline = "none";
		KEY_EVENTS.forEach((event) => element.addEventListener(event, this.handleEvent));
	}
	destroy() {
		KEY_EVENTS.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
	}
	/**
	* Enable this input (begin processing events)
	* if the specified event type is among those handled by this input.
	*/
	enableEventType(eventType, enabled) {
		if (eventType === "keydown") this.enableDownEvent = enabled;
		if (eventType === "keyup") this.enableUpEvent = enabled;
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/inputs/contextmenu-input.js
var ContextmenuInput = class extends Input {
	constructor(element, callback, options) {
		super(element, callback, options);
		this.handleEvent = (event) => {
			if (!this.options.enable) return;
			this.callback({
				type: "contextmenu",
				center: {
					x: event.clientX,
					y: event.clientY
				},
				srcEvent: event,
				pointerType: "mouse",
				target: event.target
			});
		};
		element.addEventListener("contextmenu", this.handleEvent);
	}
	destroy() {
		this.element.removeEventListener("contextmenu", this.handleEvent);
	}
	/**
	* Enable this input (begin processing events)
	* if the specified event type is among those handled by this input.
	*/
	enableEventType(eventType, enabled) {
		if (eventType === "contextmenu") this.options.enable = enabled;
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/utils/event-utils.js
var DOWN_EVENT = 1;
var MOVE_EVENT = 2;
var UP_EVENT = 4;
var MOUSE_EVENTS = {
	pointerdown: DOWN_EVENT,
	pointermove: MOVE_EVENT,
	pointerup: UP_EVENT,
	mousedown: DOWN_EVENT,
	mousemove: MOVE_EVENT,
	mouseup: UP_EVENT
};
var MOUSE_EVENT_BUTTON_LEFT = 0;
var MOUSE_EVENT_BUTTON_MIDDLE = 1;
var MOUSE_EVENT_BUTTON_RIGHT = 2;
var MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;
var MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;
var MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;
/**
* Extract the involved mouse button
*/
function whichButtons(event) {
	const eventType = MOUSE_EVENTS[event.srcEvent.type];
	if (!eventType) return null;
	const { buttons, button } = event.srcEvent;
	let leftButton = false;
	let middleButton = false;
	let rightButton = false;
	if (eventType === MOVE_EVENT) {
		leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);
		middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);
		rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);
	} else {
		leftButton = button === MOUSE_EVENT_BUTTON_LEFT;
		middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;
		rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;
	}
	return {
		leftButton,
		middleButton,
		rightButton
	};
}
/**
* Calculate event position relative to the root element
*/
function getOffsetPosition(event, rootElement) {
	const center = event.center;
	if (!center) return null;
	const rect = rootElement.getBoundingClientRect();
	const scaleX = rect.width / rootElement.offsetWidth || 1;
	const scaleY = rect.height / rootElement.offsetHeight || 1;
	return {
		center,
		offsetCenter: {
			x: (center.x - rect.left - rootElement.clientLeft) / scaleX,
			y: (center.y - rect.top - rootElement.clientTop) / scaleY
		}
	};
}

//#endregion
//#region node_modules/mjolnir.js/dist/utils/event-registrar.js
var DEFAULT_OPTIONS = {
	srcElement: "root",
	priority: 0
};
var EventRegistrar = class {
	constructor(eventManager, recognizerName) {
		/**
		* Handles hammerjs event
		*/
		this.handleEvent = (event) => {
			if (this.isEmpty()) return;
			const mjolnirEvent = this._normalizeEvent(event);
			let target = event.srcEvent.target;
			while (target && target !== mjolnirEvent.rootElement) {
				this._emit(mjolnirEvent, target);
				if (mjolnirEvent.handled) return;
				target = target.parentNode;
			}
			this._emit(mjolnirEvent, "root");
		};
		this.eventManager = eventManager;
		this.recognizerName = recognizerName;
		this.handlers = [];
		this.handlersByElement = /* @__PURE__ */ new Map();
		this._active = false;
	}
	isEmpty() {
		return !this._active;
	}
	add(type, handler, options, once = false, passive = false) {
		const { handlers, handlersByElement } = this;
		const opts = {
			...DEFAULT_OPTIONS,
			...options
		};
		let entries = handlersByElement.get(opts.srcElement);
		if (!entries) {
			entries = [];
			handlersByElement.set(opts.srcElement, entries);
		}
		const entry = {
			type,
			handler,
			srcElement: opts.srcElement,
			priority: opts.priority
		};
		if (once) entry.once = true;
		if (passive) entry.passive = true;
		handlers.push(entry);
		this._active = this._active || !entry.passive;
		let insertPosition = entries.length - 1;
		while (insertPosition >= 0) {
			if (entries[insertPosition].priority >= entry.priority) break;
			insertPosition--;
		}
		entries.splice(insertPosition + 1, 0, entry);
	}
	remove(type, handler) {
		const { handlers, handlersByElement } = this;
		for (let i = handlers.length - 1; i >= 0; i--) {
			const entry = handlers[i];
			if (entry.type === type && entry.handler === handler) {
				handlers.splice(i, 1);
				const entries = handlersByElement.get(entry.srcElement);
				entries.splice(entries.indexOf(entry), 1);
				if (entries.length === 0) handlersByElement.delete(entry.srcElement);
			}
		}
		this._active = handlers.some((entry) => !entry.passive);
	}
	/**
	* Invoke handlers on a particular element
	*/
	_emit(event, srcElement) {
		const entries = this.handlersByElement.get(srcElement);
		if (entries) {
			let immediatePropagationStopped = false;
			const stopPropagation = () => {
				event.handled = true;
			};
			const stopImmediatePropagation = () => {
				event.handled = true;
				immediatePropagationStopped = true;
			};
			const entriesToRemove = [];
			for (let i = 0; i < entries.length; i++) {
				const { type, handler, once } = entries[i];
				handler({
					...event,
					type,
					stopPropagation,
					stopImmediatePropagation
				});
				if (once) entriesToRemove.push(entries[i]);
				if (immediatePropagationStopped) break;
			}
			for (let i = 0; i < entriesToRemove.length; i++) {
				const { type, handler } = entriesToRemove[i];
				this.remove(type, handler);
			}
		}
	}
	/**
	* Normalizes hammerjs and custom events to have predictable fields.
	*/
	_normalizeEvent(event) {
		const rootElement = this.eventManager.getElement();
		return {
			...event,
			...whichButtons(event),
			...getOffsetPosition(event, rootElement),
			preventDefault: () => {
				event.srcEvent.preventDefault();
			},
			stopImmediatePropagation: null,
			stopPropagation: null,
			handled: false,
			rootElement
		};
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/event-manager.js
function normalizeRecognizer(item) {
	if ("recognizer" in item) return item;
	let recognizer;
	const itemArray = Array.isArray(item) ? [...item] : [item];
	if (typeof itemArray[0] === "function") recognizer = new (itemArray.shift())(itemArray.shift() || {});
	else recognizer = itemArray.shift();
	return {
		recognizer,
		recognizeWith: typeof itemArray[0] === "string" ? [itemArray[0]] : itemArray[0],
		requireFailure: typeof itemArray[1] === "string" ? [itemArray[1]] : itemArray[1]
	};
}
var EventManager = class {
	constructor(element = null, options = {}) {
		/**
		* Handle basic events using the 'hammer.input' Hammer.js API:
		* Before running Recognizers, Hammer emits a 'hammer.input' event
		* with the basic event info. This function emits all basic events
		* aliased to the "class" of event received.
		* See constants.BASIC_EVENT_CLASSES basic event class definitions.
		*/
		this._onBasicInput = (event) => {
			this.manager.emit(event.srcEvent.type, event);
		};
		/**
		* Handle events not supported by Hammer.js,
		* and pipe back out through same (Hammer) channel used by other events.
		*/
		this._onOtherEvent = (event) => {
			this.manager.emit(event.type, event);
		};
		this.options = {
			recognizers: [],
			events: {},
			touchAction: "compute",
			tabIndex: 0,
			cssProps: {},
			...options
		};
		this.events = /* @__PURE__ */ new Map();
		this.element = element;
		if (!element) return;
		this.manager = new Manager(element, this.options);
		for (const item of this.options.recognizers) {
			const { recognizer, recognizeWith, requireFailure } = normalizeRecognizer(item);
			this.manager.add(recognizer);
			if (recognizeWith) recognizer.recognizeWith(recognizeWith);
			if (requireFailure) recognizer.requireFailure(requireFailure);
		}
		this.manager.on("hammer.input", this._onBasicInput);
		this.wheelInput = new WheelInput(element, this._onOtherEvent, { enable: false });
		this.moveInput = new MoveInput(element, this._onOtherEvent, { enable: false });
		this.keyInput = new KeyInput(element, this._onOtherEvent, {
			enable: false,
			tabIndex: options.tabIndex
		});
		this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, { enable: false });
		this.on(this.options.events);
	}
	getElement() {
		return this.element;
	}
	destroy() {
		if (!this.element) return;
		this.wheelInput.destroy();
		this.moveInput.destroy();
		this.keyInput.destroy();
		this.contextmenuInput.destroy();
		this.manager.destroy();
	}
	/** Register an event handler function to be called on `event` */
	on(event, handler, opts) {
		this._addEventHandler(event, handler, opts, false);
	}
	once(event, handler, opts) {
		this._addEventHandler(event, handler, opts, true);
	}
	watch(event, handler, opts) {
		this._addEventHandler(event, handler, opts, false, true);
	}
	off(event, handler) {
		this._removeEventHandler(event, handler);
	}
	_toggleRecognizer(name, enabled) {
		const { manager } = this;
		if (!manager) return;
		const recognizer = manager.get(name);
		if (recognizer) {
			recognizer.set({ enable: enabled });
			manager.touchAction.update();
		}
		this.wheelInput?.enableEventType(name, enabled);
		this.moveInput?.enableEventType(name, enabled);
		this.keyInput?.enableEventType(name, enabled);
		this.contextmenuInput?.enableEventType(name, enabled);
	}
	/**
	* Process the event registration for a single event + handler.
	*/
	_addEventHandler(event, handler, opts, once, passive) {
		if (typeof event !== "string") {
			opts = handler;
			for (const [eventName, eventHandler] of Object.entries(event)) this._addEventHandler(eventName, eventHandler, opts, once, passive);
			return;
		}
		const { manager, events } = this;
		if (!manager) return;
		let eventRegistrar = events.get(event);
		if (!eventRegistrar) {
			const recognizerName = this._getRecognizerName(event) || event;
			eventRegistrar = new EventRegistrar(this, recognizerName);
			events.set(event, eventRegistrar);
			if (manager) manager.on(event, eventRegistrar.handleEvent);
		}
		eventRegistrar.add(event, handler, opts, once, passive);
		if (!eventRegistrar.isEmpty()) this._toggleRecognizer(eventRegistrar.recognizerName, true);
	}
	/**
	* Process the event deregistration for a single event + handler.
	*/
	_removeEventHandler(event, handler) {
		if (typeof event !== "string") {
			for (const [eventName, eventHandler] of Object.entries(event)) this._removeEventHandler(eventName, eventHandler);
			return;
		}
		const { events } = this;
		const eventRegistrar = events.get(event);
		if (!eventRegistrar) return;
		eventRegistrar.remove(event, handler);
		if (eventRegistrar.isEmpty()) {
			const { recognizerName } = eventRegistrar;
			let isRecognizerUsed = false;
			for (const eh of events.values()) if (eh.recognizerName === recognizerName && !eh.isEmpty()) {
				isRecognizerUsed = true;
				break;
			}
			if (!isRecognizerUsed) this._toggleRecognizer(recognizerName, false);
		}
	}
	_getRecognizerName(event) {
		return this.manager.recognizers.find((recognizer) => {
			return recognizer.getEventNames().includes(event);
		})?.options.event;
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/constants.js
/**
* The coordinate system that positions/dimensions are defined in.
*/
const COORDINATE_SYSTEM = {
	DEFAULT: -1,
	LNGLAT: 1,
	METER_OFFSETS: 2,
	LNGLAT_OFFSETS: 3,
	CARTESIAN: 0
};
Object.defineProperty(COORDINATE_SYSTEM, "IDENTITY", { get: () => {
	log_default.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")();
	return 0;
} });
/**
* How coordinates are transformed from the world space into the common space.
*/
const PROJECTION_MODE = {
	WEB_MERCATOR: 1,
	GLOBE: 2,
	WEB_MERCATOR_AUTO_OFFSET: 4,
	IDENTITY: 0
};
const UNIT = {
	common: 0,
	meters: 1,
	pixels: 2
};
const EVENT_HANDLERS = {
	click: "onClick",
	dblclick: "onClick",
	panstart: "onDragStart",
	panmove: "onDrag",
	panend: "onDragEnd"
};
const RECOGNIZERS = {
	multipan: [PanRecognizer, {
		threshold: 10,
		direction: InputDirection.Vertical,
		pointers: 2
	}],
	pinch: [
		PinchRecognizer,
		{},
		null,
		["multipan"]
	],
	pan: [
		PanRecognizer,
		{ threshold: 1 },
		["pinch"],
		["multipan"]
	],
	dblclick: [TapRecognizer, {
		event: "dblclick",
		taps: 2
	}],
	click: [
		TapRecognizer,
		{ event: "click" },
		null,
		["dblclick"]
	]
};

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/memoize.js
function isEqual(a, b) {
	if (a === b) return true;
	if (Array.isArray(a)) {
		const len$1 = a.length;
		if (!b || b.length !== len$1) return false;
		for (let i = 0; i < len$1; i++) if (a[i] !== b[i]) return false;
		return true;
	}
	return false;
}
/**
* Speed up consecutive function calls by caching the result of calls with identical input
* https://en.wikipedia.org/wiki/Memoization
* @param {function} compute - the function to be memoized
*/
function memoize(compute) {
	let cachedArgs = {};
	let cachedResult;
	return (args) => {
		for (const key in args) if (!isEqual(args[key], cachedArgs[key])) {
			cachedResult = compute(args);
			cachedArgs = args;
			break;
		}
		return cachedResult;
	};
}

//#endregion
//#region node_modules/@deck.gl/core/dist/shaderlib/project/viewport-uniforms.js
var ZERO_VECTOR$1 = [
	0,
	0,
	0,
	0
];
var VECTOR_TO_POINT_MATRIX = [
	1,
	0,
	0,
	0,
	0,
	1,
	0,
	0,
	0,
	0,
	1,
	0,
	0,
	0,
	0,
	0
];
var IDENTITY_MATRIX = [
	1,
	0,
	0,
	0,
	0,
	1,
	0,
	0,
	0,
	0,
	1,
	0,
	0,
	0,
	0,
	1
];
var DEFAULT_PIXELS_PER_UNIT2 = [
	0,
	0,
	0
];
var DEFAULT_COORDINATE_ORIGIN = [
	0,
	0,
	0
];
var getMemoizedViewportUniforms = memoize(calculateViewportUniforms);
function getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin = DEFAULT_COORDINATE_ORIGIN) {
	if (coordinateOrigin.length < 3) coordinateOrigin = [
		coordinateOrigin[0],
		coordinateOrigin[1],
		0
	];
	let shaderCoordinateOrigin = coordinateOrigin;
	let geospatialOrigin;
	let offsetMode = true;
	if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) geospatialOrigin = coordinateOrigin;
	else geospatialOrigin = viewport.isGeospatial ? [
		Math.fround(viewport.longitude),
		Math.fround(viewport.latitude),
		0
	] : null;
	switch (viewport.projectionMode) {
		case PROJECTION_MODE.WEB_MERCATOR:
			if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
				geospatialOrigin = [
					0,
					0,
					0
				];
				offsetMode = false;
			}
			break;
		case PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET:
			if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) shaderCoordinateOrigin = geospatialOrigin;
			else if (coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
				shaderCoordinateOrigin = [
					Math.fround(viewport.center[0]),
					Math.fround(viewport.center[1]),
					0
				];
				geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);
				shaderCoordinateOrigin[0] -= coordinateOrigin[0];
				shaderCoordinateOrigin[1] -= coordinateOrigin[1];
				shaderCoordinateOrigin[2] -= coordinateOrigin[2];
			}
			break;
		case PROJECTION_MODE.IDENTITY:
			shaderCoordinateOrigin = viewport.position.map(Math.fround);
			shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;
			break;
		case PROJECTION_MODE.GLOBE:
			offsetMode = false;
			geospatialOrigin = null;
			break;
		default: offsetMode = false;
	}
	return {
		geospatialOrigin,
		shaderCoordinateOrigin,
		offsetMode
	};
}
function calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin) {
	const { viewMatrixUncentered, projectionMatrix } = viewport;
	let { viewMatrix, viewProjectionMatrix } = viewport;
	let projectionCenter = ZERO_VECTOR$1;
	let originCommon = ZERO_VECTOR$1;
	let cameraPosCommon = viewport.cameraPosition;
	const { geospatialOrigin, shaderCoordinateOrigin, offsetMode } = getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin);
	if (offsetMode) {
		originCommon = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
		cameraPosCommon = [
			cameraPosCommon[0] - originCommon[0],
			cameraPosCommon[1] - originCommon[1],
			cameraPosCommon[2] - originCommon[2]
		];
		originCommon[3] = 1;
		projectionCenter = transformMat4$2([], originCommon, viewProjectionMatrix);
		viewMatrix = viewMatrixUncentered || viewMatrix;
		viewProjectionMatrix = multiply([], projectionMatrix, viewMatrix);
		viewProjectionMatrix = multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);
	}
	return {
		viewMatrix,
		viewProjectionMatrix,
		projectionCenter,
		originCommon,
		cameraPosCommon,
		shaderCoordinateOrigin,
		geospatialOrigin
	};
}
/**
* Returns uniforms for shaders based on current projection
* includes: projection matrix suitable for shaders
*
* TODO - Ensure this works with any viewport, not just WebMercatorViewports
*
* @param {WebMercatorViewport} viewport -
* @return {Float32Array} - 4x4 projection matrix that can be used in shaders
*/
function getUniformsFromViewport({ viewport, devicePixelRatio = 1, modelMatrix = null, coordinateSystem = COORDINATE_SYSTEM.DEFAULT, coordinateOrigin = DEFAULT_COORDINATE_ORIGIN, autoWrapLongitude = false }) {
	if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
	const uniforms = getMemoizedViewportUniforms({
		viewport,
		devicePixelRatio,
		coordinateSystem,
		coordinateOrigin
	});
	uniforms.wrapLongitude = autoWrapLongitude;
	uniforms.modelMatrix = modelMatrix || IDENTITY_MATRIX;
	return uniforms;
}
function calculateViewportUniforms({ viewport, devicePixelRatio, coordinateSystem, coordinateOrigin }) {
	const { projectionCenter, viewProjectionMatrix, originCommon, cameraPosCommon, shaderCoordinateOrigin, geospatialOrigin } = calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin);
	const distanceScales = viewport.getDistanceScales();
	const viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];
	const focalDistance = transformMat4$2([], [
		0,
		0,
		-viewport.focalDistance,
		1
	], viewport.projectionMatrix)[3] || 1;
	const uniforms = {
		coordinateSystem,
		projectionMode: viewport.projectionMode,
		coordinateOrigin: shaderCoordinateOrigin,
		commonOrigin: originCommon.slice(0, 3),
		center: projectionCenter,
		pseudoMeters: Boolean(viewport._pseudoMeters),
		viewportSize,
		devicePixelRatio,
		focalDistance,
		commonUnitsPerMeter: distanceScales.unitsPerMeter,
		commonUnitsPerWorldUnit: distanceScales.unitsPerMeter,
		commonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,
		scale: viewport.scale,
		wrapLongitude: false,
		viewProjectionMatrix,
		modelMatrix: IDENTITY_MATRIX,
		cameraPosition: cameraPosCommon
	};
	if (geospatialOrigin) {
		const distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin);
		switch (coordinateSystem) {
			case COORDINATE_SYSTEM.METER_OFFSETS:
				uniforms.commonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;
				uniforms.commonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;
				break;
			case COORDINATE_SYSTEM.LNGLAT:
			case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
				if (!viewport._pseudoMeters) uniforms.commonUnitsPerMeter = distanceScalesAtOrigin.unitsPerMeter;
				uniforms.commonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;
				uniforms.commonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;
				break;
			case COORDINATE_SYSTEM.CARTESIAN:
				uniforms.commonUnitsPerWorldUnit = [
					1,
					1,
					distanceScalesAtOrigin.unitsPerMeter[2]
				];
				uniforms.commonUnitsPerWorldUnit2 = [
					0,
					0,
					distanceScalesAtOrigin.unitsPerMeter2[2]
				];
				break;
			default: break;
		}
	}
	return uniforms;
}

//#endregion
//#region node_modules/@deck.gl/core/dist/shaderlib/project/project.wgsl.js
var COORDINATE_SYSTEM_WGSL_CONSTANTS = Object.keys(COORDINATE_SYSTEM).map((key) => `const COORDINATE_SYSTEM_${key}: i32 = ${COORDINATE_SYSTEM[key]};`).join("");
var PROJECTION_MODE_WGSL_CONSTANTS = Object.keys(PROJECTION_MODE).map((key) => `const PROJECTION_MODE_${key}: i32 = ${PROJECTION_MODE[key]};`).join("");
var UNIT_WGSL_CONSTANTS = Object.keys(UNIT).map((key) => `const UNIT_${key.toUpperCase()}: i32 = ${UNIT[key]};`).join("");
const projectWGSLHeader = `\
${COORDINATE_SYSTEM_WGSL_CONSTANTS}
${PROJECTION_MODE_WGSL_CONSTANTS}
${UNIT_WGSL_CONSTANTS}

const TILE_SIZE: f32 = 512.0;
const PI: f32 = 3.1415926536;
const WORLD_SCALE: f32 = TILE_SIZE / (PI * 2.0);
const ZERO_64_LOW: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
const EARTH_RADIUS: f32 = 6370972.0; // meters
const GLOBE_RADIUS: f32 = 256.0;

// -----------------------------------------------------------------------------
// Uniform block (converted from GLSL uniform block)
// -----------------------------------------------------------------------------
struct ProjectUniforms {
  wrapLongitude: i32,
  coordinateSystem: i32,
  commonUnitsPerMeter: vec3<f32>,
  projectionMode: i32,
  scale: f32,
  commonUnitsPerWorldUnit: vec3<f32>,
  commonUnitsPerWorldUnit2: vec3<f32>,
  center: vec4<f32>,
  modelMatrix: mat4x4<f32>,
  viewProjectionMatrix: mat4x4<f32>,
  viewportSize: vec2<f32>,
  devicePixelRatio: f32,
  focalDistance: f32,
  cameraPosition: vec3<f32>,
  coordinateOrigin: vec3<f32>,
  commonOrigin: vec3<f32>,
  pseudoMeters: i32,
};

@group(0) @binding(0)
var<uniform> project: ProjectUniforms;

// -----------------------------------------------------------------------------
// Geometry data
// (In your GLSL code, "geometry" was assumed to be available globally. In WGSL,
// you might supply this via vertex attributes or a uniform. Here we define a
// uniform struct for demonstration.)
// -----------------------------------------------------------------------------

// Structure to carry additional geometry data used by deck.gl filters.
struct Geometry {
  worldPosition: vec3<f32>,
  worldPositionAlt: vec3<f32>,
  position: vec4<f32>,
  normal: vec3<f32>,
  uv: vec2<f32>,
  pickingColor: vec3<f32>,
};

// @group(0) @binding(1)
var<private> geometry: Geometry;
`;
const projectWGSL = `\
${projectWGSLHeader}

// -----------------------------------------------------------------------------
// Functions
// -----------------------------------------------------------------------------

// Returns an adjustment factor for commonUnitsPerMeter
fn _project_size_at_latitude(lat: f32) -> f32 {
  let y = clamp(lat, -89.9, 89.9);
  return 1.0 / cos(radians(y));
}

// Overloaded version: scales a value in meters at a given latitude.
fn _project_size_at_latitude_m(meters: f32, lat: f32) -> f32 {
  return meters * project.commonUnitsPerMeter.z * _project_size_at_latitude(lat);
}

// Computes a non-linear scale factor based on geometry.
// (Note: This function relies on "geometry" being provided.)
fn project_size() -> f32 {
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR &&
      project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
      project.pseudoMeters == 0) {
    if (geometry.position.w == 0.0) {
      return _project_size_at_latitude(geometry.worldPosition.y);
    }
    let y: f32 = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
    let y2 = y * y;
    let y4 = y2 * y2;
    let y6 = y4 * y2;
    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
  }
  return 1.0;
}

// Overloads to scale offsets (meters to world units)
fn project_size_float(meters: f32) -> f32 {
  return meters * project.commonUnitsPerMeter.z * project_size();
}

fn project_size_vec2(meters: vec2<f32>) -> vec2<f32> {
  return meters * project.commonUnitsPerMeter.xy * project_size();
}

fn project_size_vec3(meters: vec3<f32>) -> vec3<f32> {
  return meters * project.commonUnitsPerMeter * project_size();
}

fn project_size_vec4(meters: vec4<f32>) -> vec4<f32> {
  return vec4<f32>(meters.xyz * project.commonUnitsPerMeter, meters.w);
}

// Returns a rotation matrix aligning the zaxis with the given up vector.
fn project_get_orientation_matrix(up: vec3<f32>) -> mat3x3<f32> {
  let uz = normalize(up);
  let ux = select(
    vec3<f32>(1.0, 0.0, 0.0),
    normalize(vec3<f32>(uz.y, -uz.x, 0.0)),
    abs(uz.z) == 1.0
  );
  let uy = cross(uz, ux);
  return mat3x3<f32>(ux, uy, uz);
}

// Since WGSL does not support "out" parameters, we return a struct.
struct RotationResult {
  needsRotation: bool,
  transform: mat3x3<f32>,
};

fn project_needs_rotation(commonPosition: vec3<f32>) -> RotationResult {
  if (project.projectionMode == PROJECTION_MODE_GLOBE) {
    return RotationResult(true, project_get_orientation_matrix(commonPosition));
  } else {
    return RotationResult(false, mat3x3<f32>());  // identity alternative if needed
  };
}

// Projects a normal vector from the current coordinate system to world space.
fn project_normal(vector: vec3<f32>) -> vec3<f32> {
  let normal_modelspace = project.modelMatrix * vec4<f32>(vector, 0.0);
  var n = normalize(normal_modelspace.xyz * project.commonUnitsPerMeter);
  let rotResult = project_needs_rotation(geometry.position.xyz);
  if (rotResult.needsRotation) {
    n = rotResult.transform * n;
  }
  return n;
}

// Applies a scale offset based on y-offset (dy)
fn project_offset_(offset: vec4<f32>) -> vec4<f32> {
  let dy: f32 = offset.y;
  let commonUnitsPerWorldUnit = project.commonUnitsPerWorldUnit + project.commonUnitsPerWorldUnit2 * dy;
  return vec4<f32>(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}

// Projects lng/lat coordinates to a unit tile [0,1]
fn project_mercator_(lnglat: vec2<f32>) -> vec2<f32> {
  var x = lnglat.x;
  if (project.wrapLongitude != 0) {
    x = ((x + 180.0) % 360.0) - 180.0;
  }
  let y = clamp(lnglat.y, -89.9, 89.9);
  return vec2<f32>(
    radians(x) + PI,
    PI + log(tan(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

// Projects lng/lat/z coordinates for a globe projection.
fn project_globe_(lnglatz: vec3<f32>) -> vec3<f32> {
  let lambda = radians(lnglatz.x);
  let phi = radians(lnglatz.y);
  let cosPhi = cos(phi);
  let D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;
  return vec3<f32>(
    sin(lambda) * cosPhi,
    -cos(lambda) * cosPhi,
    sin(phi)
  ) * D;
}

// Projects positions (with an optional 64-bit low part) from the input
// coordinate system to the common space.
fn project_position_vec4_f64(position: vec4<f32>, position64Low: vec3<f32>) -> vec4<f32> {
  var position_world = project.modelMatrix * position;

  // Work around for a Mac+NVIDIA bug:
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4<f32>(
        project_mercator_(position_world.xy),
        _project_size_at_latitude_m(position_world.z, position_world.y),
        position_world.w
      );
    }
    if (project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
      position_world = vec4f(position_world.xyz + project.coordinateOrigin, position_world.w);
    }
  }
  if (project.projectionMode == PROJECTION_MODE_GLOBE) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4<f32>(
        project_globe_(position_world.xyz),
        position_world.w
      );
    }
  }
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      if (abs(position_world.y - project.coordinateOrigin.y) > 0.25) {
        return vec4<f32>(
          project_mercator_(position_world.xy) - project.commonOrigin.xy,
          project_size_float(position_world.z),
          position_world.w
        );
      }
    }
  }
  if (project.projectionMode == PROJECTION_MODE_IDENTITY ||
      (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
       (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
        project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
    position_world = vec4f(position_world.xyz - project.coordinateOrigin, position_world.w);
  }

  return project_offset_(position_world) +
         project_offset_(project.modelMatrix * vec4<f32>(position64Low, 0.0));
}

// Overloaded versions for different input types.
fn project_position_vec4_f32(position: vec4<f32>) -> vec4<f32> {
  return project_position_vec4_f64(position, ZERO_64_LOW);
}

fn project_position_vec3_f64(position: vec3<f32>, position64Low: vec3<f32>) -> vec3<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 1.0), position64Low);
  return projected_position.xyz;
}

fn project_position_vec3_f32(position: vec3<f32>) -> vec3<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 1.0), ZERO_64_LOW);
  return projected_position.xyz;
}

fn project_position_vec2_f32(position: vec2<f32>) -> vec2<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 0.0, 1.0), ZERO_64_LOW);
  return projected_position.xy;
}

// Transforms a common space position to clip space.
fn project_common_position_to_clipspace_with_projection(position: vec4<f32>, viewProjectionMatrix: mat4x4<f32>, center: vec4<f32>) -> vec4<f32> {
  return viewProjectionMatrix * position + center;
}

// Uses the project viewProjectionMatrix and center.
fn project_common_position_to_clipspace(position: vec4<f32>) -> vec4<f32> {
  return project_common_position_to_clipspace_with_projection(position, project.viewProjectionMatrix, project.center);
}

// Returns a clip space offset corresponding to a given number of screen pixels.
fn project_pixel_size_to_clipspace(pixels: vec2<f32>) -> vec2<f32> {
  let offset = pixels / project.viewportSize * project.devicePixelRatio * 2.0;
  return offset * project.focalDistance;
}

fn project_meter_size_to_pixel(meters: f32) -> f32 {
  return project_size_float(meters) * project.scale;
}

fn project_unit_size_to_pixel(size: f32, unit: i32) -> f32 {
  if (unit == UNIT_METERS) {
    return project_meter_size_to_pixel(size);
  } else if (unit == UNIT_COMMON) {
    return size * project.scale;
  }
  // UNIT_PIXELS: no scaling applied.
  return size;
}

fn project_pixel_size_float(pixels: f32) -> f32 {
  return pixels / project.scale;
}

fn project_pixel_size_vec2(pixels: vec2<f32>) -> vec2<f32> {
  return pixels / project.scale;
}
`;

//#endregion
//#region node_modules/@deck.gl/core/dist/shaderlib/project/project.glsl.js
var COORDINATE_SYSTEM_GLSL_CONSTANTS = Object.keys(COORDINATE_SYSTEM).map((key) => `const int COORDINATE_SYSTEM_${key} = ${COORDINATE_SYSTEM[key]};`).join("");
var PROJECTION_MODE_GLSL_CONSTANTS = Object.keys(PROJECTION_MODE).map((key) => `const int PROJECTION_MODE_${key} = ${PROJECTION_MODE[key]};`).join("");
var UNIT_GLSL_CONSTANTS = Object.keys(UNIT).map((key) => `const int UNIT_${key.toUpperCase()} = ${UNIT[key]};`).join("");
const projectGLSL = `\
${COORDINATE_SYSTEM_GLSL_CONSTANTS}
${PROJECTION_MODE_GLSL_CONSTANTS}
${UNIT_GLSL_CONSTANTS}
uniform projectUniforms {
bool wrapLongitude;
int coordinateSystem;
vec3 commonUnitsPerMeter;
int projectionMode;
float scale;
vec3 commonUnitsPerWorldUnit;
vec3 commonUnitsPerWorldUnit2;
vec4 center;
mat4 modelMatrix;
mat4 viewProjectionMatrix;
vec2 viewportSize;
float devicePixelRatio;
float focalDistance;
vec3 cameraPosition;
vec3 coordinateOrigin;
vec3 commonOrigin;
bool pseudoMeters;
} project;
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / (PI * 2.0);
const vec3 ZERO_64_LOW = vec3(0.0);
const float EARTH_RADIUS = 6370972.0;
const float GLOBE_RADIUS = 256.0;
float project_size_at_latitude(float lat) {
float y = clamp(lat, -89.9, 89.9);
return 1.0 / cos(radians(y));
}
float project_size() {
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR &&
project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
project.pseudoMeters == false) {
if (geometry.position.w == 0.0) {
return project_size_at_latitude(geometry.worldPosition.y);
}
float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
float y2 = y * y;
float y4 = y2 * y2;
float y6 = y4 * y2;
return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
}
return 1.0;
}
float project_size_at_latitude(float meters, float lat) {
return meters * project.commonUnitsPerMeter.z * project_size_at_latitude(lat);
}
float project_size(float meters) {
return meters * project.commonUnitsPerMeter.z * project_size();
}
vec2 project_size(vec2 meters) {
return meters * project.commonUnitsPerMeter.xy * project_size();
}
vec3 project_size(vec3 meters) {
return meters * project.commonUnitsPerMeter * project_size();
}
vec4 project_size(vec4 meters) {
return vec4(meters.xyz * project.commonUnitsPerMeter, meters.w);
}
mat3 project_get_orientation_matrix(vec3 up) {
vec3 uz = normalize(up);
vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));
vec3 uy = cross(uz, ux);
return mat3(ux, uy, uz);
}
bool project_needs_rotation(vec3 commonPosition, out mat3 transform) {
if (project.projectionMode == PROJECTION_MODE_GLOBE) {
transform = project_get_orientation_matrix(commonPosition);
return true;
}
return false;
}
vec3 project_normal(vec3 vector) {
vec4 normal_modelspace = project.modelMatrix * vec4(vector, 0.0);
vec3 n = normalize(normal_modelspace.xyz * project.commonUnitsPerMeter);
mat3 rotation;
if (project_needs_rotation(geometry.position.xyz, rotation)) {
n = rotation * n;
}
return n;
}
vec4 project_offset_(vec4 offset) {
float dy = offset.y;
vec3 commonUnitsPerWorldUnit = project.commonUnitsPerWorldUnit + project.commonUnitsPerWorldUnit2 * dy;
return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}
vec2 project_mercator_(vec2 lnglat) {
float x = lnglat.x;
if (project.wrapLongitude) {
x = mod(x + 180., 360.0) - 180.;
}
float y = clamp(lnglat.y, -89.9, 89.9);
return vec2(
radians(x) + PI,
PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))
) * WORLD_SCALE;
}
vec3 project_globe_(vec3 lnglatz) {
float lambda = radians(lnglatz.x);
float phi = radians(lnglatz.y);
float cosPhi = cos(phi);
float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;
return vec3(
sin(lambda) * cosPhi,
-cos(lambda) * cosPhi,
sin(phi)
) * D;
}
vec4 project_position(vec4 position, vec3 position64Low) {
vec4 position_world = project.modelMatrix * position;
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_mercator_(position_world.xy),
project_size_at_latitude(position_world.z, position_world.y),
position_world.w
);
}
if (project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
position_world.xyz += project.coordinateOrigin;
}
}
if (project.projectionMode == PROJECTION_MODE_GLOBE) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_globe_(position_world.xyz),
position_world.w
);
}
}
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
if (abs(position_world.y - project.coordinateOrigin.y) > 0.25) {
return vec4(
project_mercator_(position_world.xy) - project.commonOrigin.xy,
project_size(position_world.z),
position_world.w
);
}
}
}
if (project.projectionMode == PROJECTION_MODE_IDENTITY ||
(project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
(project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
position_world.xyz -= project.coordinateOrigin;
}
return project_offset_(position_world) + project_offset_(project.modelMatrix * vec4(position64Low, 0.0));
}
vec4 project_position(vec4 position) {
return project_position(position, ZERO_64_LOW);
}
vec3 project_position(vec3 position, vec3 position64Low) {
vec4 projected_position = project_position(vec4(position, 1.0), position64Low);
return projected_position.xyz;
}
vec3 project_position(vec3 position) {
vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);
return projected_position.xyz;
}
vec2 project_position(vec2 position) {
vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);
return projected_position.xy;
}
vec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {
return viewProjectionMatrix * position + center;
}
vec4 project_common_position_to_clipspace(vec4 position) {
return project_common_position_to_clipspace(position, project.viewProjectionMatrix, project.center);
}
vec2 project_pixel_size_to_clipspace(vec2 pixels) {
vec2 offset = pixels / project.viewportSize * project.devicePixelRatio * 2.0;
return offset * project.focalDistance;
}
float project_size_to_pixel(float meters) {
return project_size(meters) * project.scale;
}
float project_size_to_pixel(float size, int unit) {
if (unit == UNIT_METERS) return project_size_to_pixel(size);
if (unit == UNIT_COMMON) return size * project.scale;
return size;
}
float project_pixel_size(float pixels) {
return pixels / project.scale;
}
vec2 project_pixel_size(vec2 pixels) {
return pixels / project.scale;
}
`;

//#endregion
//#region node_modules/@deck.gl/core/dist/shaderlib/project/project.js
var INITIAL_MODULE_OPTIONS = {};
function getUniforms(opts = INITIAL_MODULE_OPTIONS) {
	if ("viewport" in opts) return getUniformsFromViewport(opts);
	return {};
}
var project_default = {
	name: "project",
	dependencies: [fp32, geometry_default],
	source: projectWGSL,
	vs: projectGLSL,
	getUniforms,
	uniformTypes: {
		wrapLongitude: "f32",
		coordinateSystem: "i32",
		commonUnitsPerMeter: "vec3<f32>",
		projectionMode: "i32",
		scale: "f32",
		commonUnitsPerWorldUnit: "vec3<f32>",
		commonUnitsPerWorldUnit2: "vec3<f32>",
		center: "vec4<f32>",
		modelMatrix: "mat4x4<f32>",
		viewProjectionMatrix: "mat4x4<f32>",
		viewportSize: "vec2<f32>",
		devicePixelRatio: "f32",
		focalDistance: "f32",
		cameraPosition: "vec3<f32>",
		coordinateOrigin: "vec3<f32>",
		commonOrigin: "vec3<f32>",
		pseudoMeters: "f32"
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/shaderlib/project32/project32.js
var source = `\
// Define a structure to hold both the clip-space position and the common position.
struct ProjectResult {
  clipPosition: vec4<f32>,
  commonPosition: vec4<f32>,
};

// This function mimics the GLSL version with the 'out' parameter by returning both values.
fn project_position_to_clipspace_and_commonspace(
    position: vec3<f32>,
    position64Low: vec3<f32>,
    offset: vec3<f32>
) -> ProjectResult {
  // Compute the projected position.
  let projectedPosition: vec3<f32> = project_position_vec3_f64(position, position64Low);

  // Start with the provided offset.
  var finalOffset: vec3<f32> = offset;

  // Get whether a rotation is needed and the rotation matrix.
  let rotationResult = project_needs_rotation(projectedPosition);

  // If rotation is needed, update the offset.
  if (rotationResult.needsRotation) {
    finalOffset = rotationResult.transform * offset;
  }

  // Compute the common position.
  let commonPosition: vec4<f32> = vec4<f32>(projectedPosition + finalOffset, 1.0);

  // Convert to clip-space.
  let clipPosition: vec4<f32> = project_common_position_to_clipspace(commonPosition);

  return ProjectResult(clipPosition, commonPosition);
}

// A convenience overload that returns only the clip-space position.
fn project_position_to_clipspace(
    position: vec3<f32>,
    position64Low: vec3<f32>,
    offset: vec3<f32>
) -> vec4<f32> {
  return project_position_to_clipspace_and_commonspace(position, position64Low, offset).clipPosition;
}
`;
var vs = `\
vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition
) {
  vec3 projectedPosition = project_position(position, position64Low);
  mat3 rotation;
  if (project_needs_rotation(projectedPosition, rotation)) {
    // offset is specified as ENU
    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe
    offset = rotation * offset;
  }
  commonPosition = vec4(projectedPosition + offset, 1.0);
  return project_common_position_to_clipspace(commonPosition);
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset
) {
  vec4 commonPosition;
  return project_position_to_clipspace(position, position64Low, offset, commonPosition);
}
`;
var project32_default = {
	name: "project32",
	dependencies: [project_default],
	source,
	vs
};

//#endregion
//#region node_modules/@math.gl/web-mercator/dist/math-utils.js
function createMat4$1() {
	return [
		1,
		0,
		0,
		0,
		0,
		1,
		0,
		0,
		0,
		0,
		1,
		0,
		0,
		0,
		0,
		1
	];
}
function transformVector(matrix, vector) {
	const result = transformMat4$2([], vector, matrix);
	scale$1(result, result, 1 / result[3]);
	return result;
}
function mod$1(value, divisor) {
	const modulus = value % divisor;
	return modulus < 0 ? divisor + modulus : modulus;
}
function clamp$1(x, min, max) {
	return x < min ? min : x > max ? max : x;
}
function ieLog2(x) {
	return Math.log(x) * Math.LOG2E;
}
const log2 = Math.log2 || ieLog2;

//#endregion
//#region node_modules/@math.gl/web-mercator/dist/assert.js
function assert$1(condition, message) {
	if (!condition) throw new Error(message || "@math.gl/web-mercator: assertion failed.");
}

//#endregion
//#region node_modules/@math.gl/web-mercator/dist/web-mercator-utils.js
var PI = Math.PI;
var PI_4 = PI / 4;
var DEGREES_TO_RADIANS$2 = PI / 180;
var RADIANS_TO_DEGREES = 180 / PI;
var TILE_SIZE$1 = 512;
var EARTH_CIRCUMFERENCE = 4003e4;
const MAX_LATITUDE = 85.051129;
const DEFAULT_ALTITUDE = 1.5;
/** Linear scale to logarithimic zoom **/
function scaleToZoom(scale$2) {
	return log2(scale$2);
}
/**
* Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
* Performs the nonlinear part of the web mercator projection.
* Remaining projection is done with 4x4 matrices which also handles
* perspective.
*
* @param lngLat - [lng, lat] coordinates
*   Specifies a point on the sphere to project onto the map.
* @return [x,y] coordinates.
*/
function lngLatToWorld(lngLat) {
	const [lng, lat] = lngLat;
	assert$1(Number.isFinite(lng));
	assert$1(Number.isFinite(lat) && lat >= -90 && lat <= 90, "invalid latitude");
	const lambda2 = lng * DEGREES_TO_RADIANS$2;
	const phi2 = lat * DEGREES_TO_RADIANS$2;
	return [TILE_SIZE$1 * (lambda2 + PI) / (2 * PI), TILE_SIZE$1 * (PI + Math.log(Math.tan(PI_4 + phi2 * .5))) / (2 * PI)];
}
/**
* Unproject world point [x,y] on map onto {lat, lon} on sphere
*
* @param xy - array with [x,y] members
*  representing point on projected map plane
* @return - array with [x,y] of point on sphere.
*   Has toArray method if you need a GeoJSON Array.
*   Per cartographic tradition, lat and lon are specified as degrees.
*/
function worldToLngLat(xy) {
	const [x, y] = xy;
	const lambda2 = x / TILE_SIZE$1 * (2 * PI) - PI;
	const phi2 = 2 * (Math.atan(Math.exp(y / TILE_SIZE$1 * (2 * PI) - PI)) - PI_4);
	return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
}
/**
* Returns the zoom level that gives a 1 meter pixel at a certain latitude
* 1 = C*cos(y)/2^z/TILE_SIZE = C*cos(y)/2^(z+9)
*/
function getMeterZoom(options) {
	const { latitude } = options;
	assert$1(Number.isFinite(latitude));
	return scaleToZoom(EARTH_CIRCUMFERENCE * Math.cos(latitude * DEGREES_TO_RADIANS$2)) - 9;
}
/**
* Calculate the conversion from meter to common units at a given latitude
* This is a cheaper version of `getDistanceScales`
* @param latitude center latitude in degrees
* @returns common units per meter
*/
function unitsPerMeter(latitude) {
	const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS$2);
	return TILE_SIZE$1 / EARTH_CIRCUMFERENCE / latCosine;
}
/**
* Calculate distance scales in meters around current lat/lon, both for
* degrees and pixels.
* In mercator projection mode, the distance scales vary significantly
* with latitude.
*/
function getDistanceScales(options) {
	const { latitude, longitude, highPrecision = false } = options;
	assert$1(Number.isFinite(latitude) && Number.isFinite(longitude));
	const worldSize = TILE_SIZE$1;
	const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS$2);
	/**
	* Number of pixels occupied by one degree longitude around current lat/lon:
	unitsPerDegreeX = d(lngLatToWorld([lng, lat])[0])/d(lng)
	= scale * TILE_SIZE * DEGREES_TO_RADIANS / (2 * PI)
	unitsPerDegreeY = d(lngLatToWorld([lng, lat])[1])/d(lat)
	= -scale * TILE_SIZE * DEGREES_TO_RADIANS / cos(lat * DEGREES_TO_RADIANS)  / (2 * PI)
	*/
	const unitsPerDegreeX = worldSize / 360;
	const unitsPerDegreeY = unitsPerDegreeX / latCosine;
	/**
	* Number of pixels occupied by one meter around current lat/lon:
	*/
	const altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;
	/**
	* LngLat: longitude -> east and latitude -> north (bottom left)
	* UTM meter offset: x -> east and y -> north (bottom left)
	* World space: x -> east and y -> south (top left)
	*
	* Y needs to be flipped when converting delta degree/meter to delta pixels
	*/
	const result = {
		unitsPerMeter: [
			altUnitsPerMeter,
			altUnitsPerMeter,
			altUnitsPerMeter
		],
		metersPerUnit: [
			1 / altUnitsPerMeter,
			1 / altUnitsPerMeter,
			1 / altUnitsPerMeter
		],
		unitsPerDegree: [
			unitsPerDegreeX,
			unitsPerDegreeY,
			altUnitsPerMeter
		],
		degreesPerUnit: [
			1 / unitsPerDegreeX,
			1 / unitsPerDegreeY,
			1 / altUnitsPerMeter
		]
	};
	/**
	* Taylor series 2nd order for 1/latCosine
	f'(a) * (x - a)
	= d(1/cos(lat * DEGREES_TO_RADIANS))/d(lat) * dLat
	= DEGREES_TO_RADIANS * tan(lat * DEGREES_TO_RADIANS) / cos(lat * DEGREES_TO_RADIANS) * dLat
	*/
	if (highPrecision) {
		const latCosine2 = DEGREES_TO_RADIANS$2 * Math.tan(latitude * DEGREES_TO_RADIANS$2) / latCosine;
		const unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;
		const altUnitsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
		const altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;
		result.unitsPerDegree2 = [
			0,
			unitsPerDegreeY2,
			altUnitsPerDegree2
		];
		result.unitsPerMeter2 = [
			altUnitsPerMeter2,
			0,
			altUnitsPerMeter2
		];
	}
	return result;
}
/**
* Offset a lng/lat position by meterOffset (northing, easting)
*/
function addMetersToLngLat(lngLatZ, xyz) {
	const [longitude, latitude, z0] = lngLatZ;
	const [x, y, z] = xyz;
	const { unitsPerMeter: unitsPerMeter$1, unitsPerMeter2 } = getDistanceScales({
		longitude,
		latitude,
		highPrecision: true
	});
	const worldspace = lngLatToWorld(lngLatZ);
	worldspace[0] += x * (unitsPerMeter$1[0] + unitsPerMeter2[0] * y);
	worldspace[1] += y * (unitsPerMeter$1[1] + unitsPerMeter2[1] * y);
	const newLngLat = worldToLngLat(worldspace);
	const newZ = (z0 || 0) + (z || 0);
	return Number.isFinite(z0) || Number.isFinite(z) ? [
		newLngLat[0],
		newLngLat[1],
		newZ
	] : newLngLat;
}
/**
*
* view and projection matrix creation is intentionally kept compatible with
* mapbox-gl's implementation to ensure that seamless interoperation
* with mapbox and react-map-gl. See: https://github.com/mapbox/mapbox-gl-js
*/
function getViewMatrix(options) {
	const { height, pitch, bearing, altitude, scale: scale$2, center } = options;
	const vm = createMat4$1();
	translate(vm, vm, [
		0,
		0,
		-altitude
	]);
	rotateX(vm, vm, -pitch * DEGREES_TO_RADIANS$2);
	rotateZ(vm, vm, bearing * DEGREES_TO_RADIANS$2);
	const relativeScale = scale$2 / height;
	scale(vm, vm, [
		relativeScale,
		relativeScale,
		relativeScale
	]);
	if (center) translate(vm, vm, negate([], center));
	return vm;
}
/**
* Calculates mapbox compatible projection matrix from parameters
*
* @param options.width Width of "viewport" or window
* @param options.height Height of "viewport" or window
* @param options.scale Scale at the current zoom
* @param options.center Offset of the target, vec3 in world space
* @param options.offset Offset of the focal point, vec2 in screen space
* @param options.pitch Camera angle in degrees (0 is straight down)
* @param options.fovy field of view in degrees
* @param options.altitude if provided, field of view is calculated using `altitudeToFovy()`
* @param options.nearZMultiplier control z buffer
* @param options.farZMultiplier control z buffer
* @returns project parameters object
*/
function getProjectionParameters(options) {
	const { width, height, altitude, pitch = 0, offset, center, scale: scale$2, nearZMultiplier = 1, farZMultiplier = 1 } = options;
	let { fovy = altitudeToFovy(DEFAULT_ALTITUDE) } = options;
	if (altitude !== void 0) fovy = altitudeToFovy(altitude);
	const fovRadians = fovy * DEGREES_TO_RADIANS$2;
	const pitchRadians = pitch * DEGREES_TO_RADIANS$2;
	const focalDistance = fovyToAltitude(fovy);
	let cameraToSeaLevelDistance = focalDistance;
	if (center) cameraToSeaLevelDistance += center[2] * scale$2 / Math.cos(pitchRadians) / height;
	const fovAboveCenter = fovRadians * (.5 + (offset ? offset[1] : 0) / height);
	const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * cameraToSeaLevelDistance / Math.sin(clamp$1(Math.PI / 2 - pitchRadians - fovAboveCenter, .01, Math.PI - .01));
	const furthestDistance = Math.sin(pitchRadians) * topHalfSurfaceDistance + cameraToSeaLevelDistance;
	const horizonDistance = cameraToSeaLevelDistance * 10;
	const farZ = Math.min(furthestDistance * farZMultiplier, horizonDistance);
	return {
		fov: fovRadians,
		aspect: width / height,
		focalDistance,
		near: nearZMultiplier,
		far: farZ
	};
}
/**
*
* Convert an altitude to field of view such that the
* focal distance is equal to the altitude
*
* @param altitude - altitude of camera in screen units
* @return fovy field of view in degrees
*/
function altitudeToFovy(altitude) {
	return 2 * Math.atan(.5 / altitude) * RADIANS_TO_DEGREES;
}
/**
*
* Convert an field of view such that the
* focal distance is equal to the altitude
*
* @param fovy - field of view in degrees
* @return altitude altitude of camera in screen units
*/
function fovyToAltitude(fovy) {
	return .5 / Math.tan(.5 * fovy * DEGREES_TO_RADIANS$2);
}
function worldToPixels(xyz, pixelProjectionMatrix) {
	const [x, y, z = 0] = xyz;
	assert$1(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));
	return transformVector(pixelProjectionMatrix, [
		x,
		y,
		z,
		1
	]);
}
/**
* Unproject pixels on screen to flat coordinates.
*
* @param xyz - pixel coordinate on screen.
* @param pixelUnprojectionMatrix - unprojection matrix 4x4
* @param targetZ - if pixel coordinate does not have a 3rd component (depth),
*    targetZ is used as the elevation plane to unproject onto
* @return [x, y, Z] flat coordinates on 512*512 Mercator Zoom 0 tile.
*/
function pixelsToWorld(xyz, pixelUnprojectionMatrix, targetZ = 0) {
	const [x, y, z] = xyz;
	assert$1(Number.isFinite(x) && Number.isFinite(y), "invalid pixel coordinate");
	if (Number.isFinite(z)) return transformVector(pixelUnprojectionMatrix, [
		x,
		y,
		z,
		1
	]);
	const coord0 = transformVector(pixelUnprojectionMatrix, [
		x,
		y,
		0,
		1
	]);
	const coord1 = transformVector(pixelUnprojectionMatrix, [
		x,
		y,
		1,
		1
	]);
	const z0 = coord0[2];
	const z1 = coord1[2];
	const t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
	return lerp$1([], coord0, coord1, t);
}

//#endregion
//#region node_modules/@math.gl/web-mercator/dist/fit-bounds.js
/**
* Returns map settings {latitude, longitude, zoom}
* that will contain the provided corners within the provided width.
*
* > _Note: Only supports non-perspective mode._
*
* @param options fit bounds parameters
* @returns - latitude, longitude and zoom
*/
function fitBounds(options) {
	const { width, height, bounds, minExtent = 0, maxZoom = 24, offset = [0, 0] } = options;
	const [[west, south], [east, north]] = bounds;
	const padding = getPaddingObject(options.padding);
	const nw = lngLatToWorld([west, clamp$1(north, -MAX_LATITUDE, MAX_LATITUDE)]);
	const se = lngLatToWorld([east, clamp$1(south, -MAX_LATITUDE, MAX_LATITUDE)]);
	const size = [Math.max(Math.abs(se[0] - nw[0]), minExtent), Math.max(Math.abs(se[1] - nw[1]), minExtent)];
	const targetSize = [width - padding.left - padding.right - Math.abs(offset[0]) * 2, height - padding.top - padding.bottom - Math.abs(offset[1]) * 2];
	assert$1(targetSize[0] > 0 && targetSize[1] > 0);
	const scaleX = targetSize[0] / size[0];
	const scaleY = targetSize[1] / size[1];
	const offsetX = (padding.right - padding.left) / 2 / scaleX;
	const offsetY = (padding.top - padding.bottom) / 2 / scaleY;
	const centerLngLat = worldToLngLat([(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY]);
	const zoom = Math.min(maxZoom, log2(Math.abs(Math.min(scaleX, scaleY))));
	assert$1(Number.isFinite(zoom));
	return {
		longitude: centerLngLat[0],
		latitude: centerLngLat[1],
		zoom
	};
}
function getPaddingObject(padding = 0) {
	if (typeof padding === "number") return {
		top: padding,
		bottom: padding,
		left: padding,
		right: padding
	};
	assert$1(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));
	return padding;
}

//#endregion
//#region node_modules/@math.gl/web-mercator/dist/get-bounds.js
var DEGREES_TO_RADIANS$1 = Math.PI / 180;
function getBounds(viewport, z = 0) {
	const { width, height, unproject } = viewport;
	const unprojectOps = { targetZ: z };
	const bottomLeft = unproject([0, height], unprojectOps);
	const bottomRight = unproject([width, height], unprojectOps);
	let topLeft;
	let topRight;
	if ((viewport.fovy ? .5 * viewport.fovy * DEGREES_TO_RADIANS$1 : Math.atan(.5 / viewport.altitude)) > (90 - viewport.pitch) * DEGREES_TO_RADIANS$1 - .01) {
		topLeft = unprojectOnFarPlane(viewport, 0, z);
		topRight = unprojectOnFarPlane(viewport, width, z);
	} else {
		topLeft = unproject([0, 0], unprojectOps);
		topRight = unproject([width, 0], unprojectOps);
	}
	return [
		bottomLeft,
		bottomRight,
		topRight,
		topLeft
	];
}
function unprojectOnFarPlane(viewport, x, targetZ) {
	const { pixelUnprojectionMatrix } = viewport;
	const coord0 = transformVector(pixelUnprojectionMatrix, [
		x,
		0,
		1,
		1
	]);
	const coord1 = transformVector(pixelUnprojectionMatrix, [
		x,
		viewport.height,
		1,
		1
	]);
	const t = (targetZ * viewport.distanceScales.unitsPerMeter[2] - coord0[2]) / (coord1[2] - coord0[2]);
	const result = worldToLngLat(lerp$1([], coord0, coord1, t));
	result.push(targetZ);
	return result;
}

//#endregion
//#region node_modules/@math.gl/web-mercator/dist/normalize-viewport-props.js
var TILE_SIZE = 512;
/**
* Apply mathematical constraints to viewport props
* @param props
*/
function normalizeViewportProps(props) {
	const { width, height, pitch = 0 } = props;
	let { longitude, latitude, zoom, bearing = 0 } = props;
	if (longitude < -180 || longitude > 180) longitude = mod$1(longitude + 180, 360) - 180;
	if (bearing < -180 || bearing > 180) bearing = mod$1(bearing + 180, 360) - 180;
	const minZoom = log2(height / TILE_SIZE);
	if (zoom <= minZoom) {
		zoom = minZoom;
		latitude = 0;
	} else {
		const halfHeightPixels = height / 2 / Math.pow(2, zoom);
		const minLatitude = worldToLngLat([0, halfHeightPixels])[1];
		if (latitude < minLatitude) latitude = minLatitude;
		else {
			const maxLatitude = worldToLngLat([0, TILE_SIZE - halfHeightPixels])[1];
			if (latitude > maxLatitude) latitude = maxLatitude;
		}
	}
	return {
		width,
		height,
		longitude,
		latitude,
		zoom,
		pitch,
		bearing
	};
}

//#endregion
//#region node_modules/@deck.gl/core/dist/shaderlib/picking/picking.js
var picking_default = {
	...picking,
	defaultUniforms: {
		...picking.defaultUniforms,
		useFloatColors: false
	},
	inject: {
		"vs:DECKGL_FILTER_GL_POSITION": `
    // for picking depth values
    picking_setPickingAttribute(position.z / position.w);
  `,
		"vs:DECKGL_FILTER_COLOR": `
  picking_setPickingColor(geometry.pickingColor);
  `,
		"fs:DECKGL_FILTER_COLOR": {
			order: 99,
			injection: `
  // use highlight color if this fragment belongs to the selected object.
  color = picking_filterHighlightColor(color);

  // use picking color if rendering to picking FBO.
  color = picking_filterPickingColor(color);
    `
		}
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/typed-array-manager.js
var TypedArrayManager = class {
	constructor(options = {}) {
		this._pool = [];
		this.opts = {
			overAlloc: 2,
			poolSize: 100
		};
		this.setOptions(options);
	}
	setOptions(options) {
		Object.assign(this.opts, options);
	}
	allocate(typedArray, count, { size = 1, type, padding = 0, copy = false, initialize = false, maxCount }) {
		const Type = type || typedArray && typedArray.constructor || Float32Array;
		const newSize = count * size + padding;
		if (ArrayBuffer.isView(typedArray)) {
			if (newSize <= typedArray.length) return typedArray;
			if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) return new Type(typedArray.buffer, 0, newSize);
		}
		let maxSize = Infinity;
		if (maxCount) maxSize = maxCount * size + padding;
		const newArray = this._allocate(Type, newSize, initialize, maxSize);
		if (typedArray && copy) newArray.set(typedArray);
		else if (!initialize) newArray.fill(0, 0, 4);
		this._release(typedArray);
		return newArray;
	}
	release(typedArray) {
		this._release(typedArray);
	}
	_allocate(Type, size, initialize, maxSize) {
		let sizeToAllocate = Math.max(Math.ceil(size * this.opts.overAlloc), 1);
		if (sizeToAllocate > maxSize) sizeToAllocate = maxSize;
		const pool = this._pool;
		const byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;
		const i = pool.findIndex((b) => b.byteLength >= byteLength);
		if (i >= 0) {
			const array = new Type(pool.splice(i, 1)[0], 0, sizeToAllocate);
			if (initialize) array.fill(0);
			return array;
		}
		return new Type(sizeToAllocate);
	}
	_release(typedArray) {
		if (!ArrayBuffer.isView(typedArray)) return;
		const pool = this._pool;
		const { buffer } = typedArray;
		const { byteLength } = buffer;
		const i = pool.findIndex((b) => b.byteLength >= byteLength);
		if (i < 0) pool.push(buffer);
		else if (i > 0 || pool.length < this.opts.poolSize) pool.splice(i, 0, buffer);
		if (pool.length > this.opts.poolSize) pool.shift();
	}
};
var typed_array_manager_default = new TypedArrayManager();

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/math-utils.js
function createMat4() {
	return [
		1,
		0,
		0,
		0,
		0,
		1,
		0,
		0,
		0,
		0,
		1,
		0,
		0,
		0,
		0,
		1
	];
}
function mod(value, divisor) {
	const modulus = value % divisor;
	return modulus < 0 ? divisor + modulus : modulus;
}
function getCameraPosition(viewMatrixInverse) {
	return [
		viewMatrixInverse[12],
		viewMatrixInverse[13],
		viewMatrixInverse[14]
	];
}
function getFrustumPlanes(viewProjectionMatrix) {
	return {
		left: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[0], viewProjectionMatrix[7] + viewProjectionMatrix[4], viewProjectionMatrix[11] + viewProjectionMatrix[8], viewProjectionMatrix[15] + viewProjectionMatrix[12]),
		right: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[0], viewProjectionMatrix[7] - viewProjectionMatrix[4], viewProjectionMatrix[11] - viewProjectionMatrix[8], viewProjectionMatrix[15] - viewProjectionMatrix[12]),
		bottom: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[1], viewProjectionMatrix[7] + viewProjectionMatrix[5], viewProjectionMatrix[11] + viewProjectionMatrix[9], viewProjectionMatrix[15] + viewProjectionMatrix[13]),
		top: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[1], viewProjectionMatrix[7] - viewProjectionMatrix[5], viewProjectionMatrix[11] - viewProjectionMatrix[9], viewProjectionMatrix[15] - viewProjectionMatrix[13]),
		near: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[2], viewProjectionMatrix[7] + viewProjectionMatrix[6], viewProjectionMatrix[11] + viewProjectionMatrix[10], viewProjectionMatrix[15] + viewProjectionMatrix[14]),
		far: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[2], viewProjectionMatrix[7] - viewProjectionMatrix[6], viewProjectionMatrix[11] - viewProjectionMatrix[10], viewProjectionMatrix[15] - viewProjectionMatrix[14])
	};
}
var scratchVector = new Vector3();
function getFrustumPlane(a, b, c, d) {
	scratchVector.set(a, b, c);
	const L = scratchVector.len();
	return {
		distance: d / L,
		normal: new Vector3(-a / L, -b / L, -c / L)
	};
}
/**
* Calculate the low part of a WebGL 64 bit float
* @param x {number} - the input float number
* @returns {number} - the lower 32 bit of the number
*/
function fp64LowPart(x) {
	return x - Math.fround(x);
}
var scratchArray;
/**
* Split a Float64Array into a double-length Float32Array
* @param typedArray
* @param options
* @param options.size  - per attribute size
* @param options.startIndex - start index in the source array
* @param options.endIndex  - end index in the source array
* @returns {} - high part, low part for each attribute:
[1xHi, 1yHi, 1zHi, 1xLow, 1yLow, 1zLow, 2xHi, ...]
*/
function toDoublePrecisionArray(typedArray, options) {
	const { size = 1, startIndex = 0 } = options;
	const endIndex = options.endIndex !== void 0 ? options.endIndex : typedArray.length;
	const count = (endIndex - startIndex) / size;
	scratchArray = typed_array_manager_default.allocate(scratchArray, count, {
		type: Float32Array,
		size: size * 2
	});
	let sourceIndex = startIndex;
	let targetIndex = 0;
	while (sourceIndex < endIndex) {
		for (let j = 0; j < size; j++) {
			const value = typedArray[sourceIndex++];
			scratchArray[targetIndex + j] = value;
			scratchArray[targetIndex + j + size] = fp64LowPart(value);
		}
		targetIndex += size * 2;
	}
	return scratchArray.subarray(0, count * size * 2);
}
function mergeBounds(boundsList) {
	let mergedBounds = null;
	let isMerged = false;
	for (const bounds of boundsList) {
		if (!bounds) continue;
		if (!mergedBounds) mergedBounds = bounds;
		else {
			if (!isMerged) {
				mergedBounds = [[mergedBounds[0][0], mergedBounds[0][1]], [mergedBounds[1][0], mergedBounds[1][1]]];
				isMerged = true;
			}
			mergedBounds[0][0] = Math.min(mergedBounds[0][0], bounds[0][0]);
			mergedBounds[0][1] = Math.min(mergedBounds[0][1], bounds[0][1]);
			mergedBounds[1][0] = Math.max(mergedBounds[1][0], bounds[1][0]);
			mergedBounds[1][1] = Math.max(mergedBounds[1][1], bounds[1][1]);
		}
	}
	return mergedBounds;
}

//#endregion
//#region node_modules/@deck.gl/core/dist/viewports/viewport.js
var DEGREES_TO_RADIANS = Math.PI / 180;
var IDENTITY = createMat4();
var ZERO_VECTOR = [
	0,
	0,
	0
];
var DEFAULT_DISTANCE_SCALES = {
	unitsPerMeter: [
		1,
		1,
		1
	],
	metersPerUnit: [
		1,
		1,
		1
	]
};
function createProjectionMatrix({ width, height, orthographic, fovyRadians, focalDistance, padding, near, far }) {
	const aspect = width / height;
	const matrix = orthographic ? new Matrix4().orthographic({
		fovy: fovyRadians,
		aspect,
		focalDistance,
		near,
		far
	}) : new Matrix4().perspective({
		fovy: fovyRadians,
		aspect,
		near,
		far
	});
	if (padding) {
		const { left = 0, right = 0, top = 0, bottom = 0 } = padding;
		const offsetX = clamp((left + width - right) / 2, 0, width) - width / 2;
		const offsetY = clamp((top + height - bottom) / 2, 0, height) - height / 2;
		matrix[8] -= offsetX * 2 / width;
		matrix[9] += offsetY * 2 / height;
	}
	return matrix;
}
/**
* Manages coordinate system transformations.
*
* Note: The Viewport is immutable in the sense that it only has accessors.
* A new viewport instance should be created if any parameters have changed.
*/
var Viewport = class Viewport {
	constructor(opts = {}) {
		this._frustumPlanes = {};
		this.id = opts.id || this.constructor.displayName || "viewport";
		this.x = opts.x || 0;
		this.y = opts.y || 0;
		this.width = opts.width || 1;
		this.height = opts.height || 1;
		this.zoom = opts.zoom || 0;
		this.padding = opts.padding;
		this.distanceScales = opts.distanceScales || DEFAULT_DISTANCE_SCALES;
		this.focalDistance = opts.focalDistance || 1;
		this.position = opts.position || ZERO_VECTOR;
		this.modelMatrix = opts.modelMatrix || null;
		const { longitude, latitude } = opts;
		this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);
		this._initProps(opts);
		this._initMatrices(opts);
		this.equals = this.equals.bind(this);
		this.project = this.project.bind(this);
		this.unproject = this.unproject.bind(this);
		this.projectPosition = this.projectPosition.bind(this);
		this.unprojectPosition = this.unprojectPosition.bind(this);
		this.projectFlat = this.projectFlat.bind(this);
		this.unprojectFlat = this.unprojectFlat.bind(this);
	}
	get subViewports() {
		return null;
	}
	get metersPerPixel() {
		return this.distanceScales.metersPerUnit[2] / this.scale;
	}
	get projectionMode() {
		if (this.isGeospatial) return this.zoom < 12 ? PROJECTION_MODE.WEB_MERCATOR : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;
		return PROJECTION_MODE.IDENTITY;
	}
	equals(viewport) {
		if (!(viewport instanceof Viewport)) return false;
		if (this === viewport) return true;
		return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && equals(viewport.projectionMatrix, this.projectionMatrix) && equals(viewport.viewMatrix, this.viewMatrix);
	}
	/**
	* Projects xyz (possibly latitude and longitude) to pixel coordinates in window
	* using viewport projection parameters
	* - [longitude, latitude] to [x, y]
	* - [longitude, latitude, Z] => [x, y, z]
	* Note: By default, returns top-left coordinates for canvas/SVG type render
	*
	* @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
	* @param {Object} opts - options
	* @param {Object} opts.topLeft=true - Whether projected coords are top left
	* @return {Array} - [x, y] or [x, y, z] in top left coords
	*/
	project(xyz, { topLeft = true } = {}) {
		const coord = worldToPixels(this.projectPosition(xyz), this.pixelProjectionMatrix);
		const [x, y] = coord;
		const y2 = topLeft ? y : this.height - y;
		return xyz.length === 2 ? [x, y2] : [
			x,
			y2,
			coord[2]
		];
	}
	/**
	* Unproject pixel coordinates on screen onto world coordinates,
	* (possibly [lon, lat]) on map.
	* - [x, y] => [lng, lat]
	* - [x, y, z] => [lng, lat, Z]
	* @param {Array} xyz -
	* @param {Object} opts - options
	* @param {Object} opts.topLeft=true - Whether origin is top left
	* @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
	*/
	unproject(xyz, { topLeft = true, targetZ } = {}) {
		const [x, y, z] = xyz;
		const y2 = topLeft ? y : this.height - y;
		const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
		const coord = pixelsToWorld([
			x,
			y2,
			z
		], this.pixelUnprojectionMatrix, targetZWorld);
		const [X, Y, Z] = this.unprojectPosition(coord);
		if (Number.isFinite(z)) return [
			X,
			Y,
			Z
		];
		return Number.isFinite(targetZ) ? [
			X,
			Y,
			targetZ
		] : [X, Y];
	}
	projectPosition(xyz) {
		const [X, Y] = this.projectFlat(xyz);
		return [
			X,
			Y,
			(xyz[2] || 0) * this.distanceScales.unitsPerMeter[2]
		];
	}
	unprojectPosition(xyz) {
		const [X, Y] = this.unprojectFlat(xyz);
		return [
			X,
			Y,
			(xyz[2] || 0) * this.distanceScales.metersPerUnit[2]
		];
	}
	/**
	* Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
	* Performs the nonlinear part of the web mercator projection.
	* Remaining projection is done with 4x4 matrices which also handles
	* perspective.
	* @param {Array} lngLat - [lng, lat] coordinates
	*   Specifies a point on the sphere to project onto the map.
	* @return {Array} [x,y] coordinates.
	*/
	projectFlat(xyz) {
		if (this.isGeospatial) {
			const result = lngLatToWorld(xyz);
			result[1] = clamp(result[1], -318, 830);
			return result;
		}
		return xyz;
	}
	/**
	* Unproject world point [x,y] on map onto {lat, lon} on sphere
	* @param {object|Vector} xy - object with {x,y} members
	*  representing point on projected map plane
	* @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
	*   Has toArray method if you need a GeoJSON Array.
	*   Per cartographic tradition, lat and lon are specified as degrees.
	*/
	unprojectFlat(xyz) {
		if (this.isGeospatial) return worldToLngLat(xyz);
		return xyz;
	}
	/**
	* Get bounds of the current viewport
	* @return {Array} - [minX, minY, maxX, maxY]
	*/
	getBounds(options = {}) {
		const unprojectOption = { targetZ: options.z || 0 };
		const topLeft = this.unproject([0, 0], unprojectOption);
		const topRight = this.unproject([this.width, 0], unprojectOption);
		const bottomLeft = this.unproject([0, this.height], unprojectOption);
		const bottomRight = this.unproject([this.width, this.height], unprojectOption);
		return [
			Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
			Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]),
			Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
			Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])
		];
	}
	getDistanceScales(coordinateOrigin) {
		if (coordinateOrigin && this.isGeospatial) return getDistanceScales({
			longitude: coordinateOrigin[0],
			latitude: coordinateOrigin[1],
			highPrecision: true
		});
		return this.distanceScales;
	}
	containsPixel({ x, y, width = 1, height = 1 }) {
		return x < this.x + this.width && this.x < x + width && y < this.y + this.height && this.y < y + height;
	}
	getFrustumPlanes() {
		if (this._frustumPlanes.near) return this._frustumPlanes;
		Object.assign(this._frustumPlanes, getFrustumPlanes(this.viewProjectionMatrix));
		return this._frustumPlanes;
	}
	/**
	* Needed by panning and linear transition
	* Pan the viewport to place a given world coordinate at screen point [x, y]
	*
	* @param {Array} coords - world coordinates
	* @param {Array} pixel - [x,y] coordinates on screen
	* @param {Array} startPixel - [x,y] screen position where pan started (optional, for delta-based panning)
	* @return {Object} props of the new viewport
	*/
	panByPosition(coords, pixel, startPixel) {
		return null;
	}
	_initProps(opts) {
		const longitude = opts.longitude;
		const latitude = opts.latitude;
		if (this.isGeospatial) {
			if (!Number.isFinite(opts.zoom)) this.zoom = getMeterZoom({ latitude }) + Math.log2(this.focalDistance);
			this.distanceScales = opts.distanceScales || getDistanceScales({
				latitude,
				longitude
			});
		}
		this.scale = Math.pow(2, this.zoom);
		const { position, modelMatrix } = opts;
		let meterOffset = ZERO_VECTOR;
		if (position) meterOffset = modelMatrix ? new Matrix4(modelMatrix).transformAsVector(position, []) : position;
		if (this.isGeospatial) {
			const center = this.projectPosition([
				longitude,
				latitude,
				0
			]);
			this.center = new Vector3(meterOffset).scale(this.distanceScales.unitsPerMeter).add(center);
		} else this.center = this.projectPosition(meterOffset);
	}
	_initMatrices(opts) {
		const { viewMatrix = IDENTITY, projectionMatrix = null, orthographic = false, fovyRadians, fovy = 75, near = .1, far = 1e3, padding = null, focalDistance = 1 } = opts;
		this.viewMatrixUncentered = viewMatrix;
		this.viewMatrix = new Matrix4().multiplyRight(viewMatrix).translate(new Vector3(this.center).negate());
		this.projectionMatrix = projectionMatrix || createProjectionMatrix({
			width: this.width,
			height: this.height,
			orthographic,
			fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS,
			focalDistance,
			padding,
			near,
			far
		});
		const vpm = createMat4();
		multiply(vpm, vpm, this.projectionMatrix);
		multiply(vpm, vpm, this.viewMatrix);
		this.viewProjectionMatrix = vpm;
		this.viewMatrixInverse = invert([], this.viewMatrix) || this.viewMatrix;
		this.cameraPosition = getCameraPosition(this.viewMatrixInverse);
		const viewportMatrix = createMat4();
		const pixelProjectionMatrix = createMat4();
		scale(viewportMatrix, viewportMatrix, [
			this.width / 2,
			-this.height / 2,
			1
		]);
		translate(viewportMatrix, viewportMatrix, [
			1,
			-1,
			0
		]);
		multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);
		this.pixelProjectionMatrix = pixelProjectionMatrix;
		this.pixelUnprojectionMatrix = invert(createMat4(), this.pixelProjectionMatrix);
		if (!this.pixelUnprojectionMatrix) log_default.warn("Pixel project matrix not invertible")();
	}
};
Viewport.displayName = "Viewport";
var viewport_default = Viewport;

//#endregion
//#region node_modules/@deck.gl/core/dist/viewports/web-mercator-viewport.js
/**
* Manages transformations to/from WGS84 coordinates using the Web Mercator Projection.
*/
var WebMercatorViewport = class WebMercatorViewport extends viewport_default {
	constructor(opts = {}) {
		const { latitude = 0, longitude = 0, zoom = 0, pitch = 0, bearing = 0, nearZMultiplier = .1, farZMultiplier = 1.01, nearZ, farZ, orthographic = false, projectionMatrix, repeat = false, worldOffset = 0, position, padding, legacyMeterSizes = false } = opts;
		let { width, height, altitude = 1.5 } = opts;
		const scale$2 = Math.pow(2, zoom);
		width = width || 1;
		height = height || 1;
		let fovy;
		let projectionParameters = null;
		if (projectionMatrix) {
			altitude = projectionMatrix[5] / 2;
			fovy = altitudeToFovy(altitude);
		} else {
			if (opts.fovy) {
				fovy = opts.fovy;
				altitude = fovyToAltitude(fovy);
			} else fovy = altitudeToFovy(altitude);
			let offset;
			if (padding) {
				const { top = 0, bottom = 0 } = padding;
				offset = [0, clamp((top + height - bottom) / 2, 0, height) - height / 2];
			}
			projectionParameters = getProjectionParameters({
				width,
				height,
				scale: scale$2,
				center: position && [
					0,
					0,
					position[2] * unitsPerMeter(latitude)
				],
				offset,
				pitch,
				fovy,
				nearZMultiplier,
				farZMultiplier
			});
			if (Number.isFinite(nearZ)) projectionParameters.near = nearZ;
			if (Number.isFinite(farZ)) projectionParameters.far = farZ;
		}
		let viewMatrixUncentered = getViewMatrix({
			height,
			pitch,
			bearing,
			scale: scale$2,
			altitude
		});
		if (worldOffset) viewMatrixUncentered = new Matrix4().translate([
			512 * worldOffset,
			0,
			0
		]).multiplyLeft(viewMatrixUncentered);
		super({
			...opts,
			width,
			height,
			viewMatrix: viewMatrixUncentered,
			longitude,
			latitude,
			zoom,
			...projectionParameters,
			fovy,
			focalDistance: altitude
		});
		this.latitude = latitude;
		this.longitude = longitude;
		this.zoom = zoom;
		this.pitch = pitch;
		this.bearing = bearing;
		this.altitude = altitude;
		this.fovy = fovy;
		this.orthographic = orthographic;
		this._subViewports = repeat ? [] : null;
		this._pseudoMeters = legacyMeterSizes;
		Object.freeze(this);
	}
	get subViewports() {
		if (this._subViewports && !this._subViewports.length) {
			const bounds = this.getBounds();
			const minOffset = Math.floor((bounds[0] + 180) / 360);
			const maxOffset = Math.ceil((bounds[2] - 180) / 360);
			for (let x = minOffset; x <= maxOffset; x++) {
				const offsetViewport = x ? new WebMercatorViewport({
					...this,
					worldOffset: x
				}) : this;
				this._subViewports.push(offsetViewport);
			}
		}
		return this._subViewports;
	}
	projectPosition(xyz) {
		if (this._pseudoMeters) return super.projectPosition(xyz);
		const [X, Y] = this.projectFlat(xyz);
		return [
			X,
			Y,
			(xyz[2] || 0) * unitsPerMeter(xyz[1])
		];
	}
	unprojectPosition(xyz) {
		if (this._pseudoMeters) return super.unprojectPosition(xyz);
		const [X, Y] = this.unprojectFlat(xyz);
		return [
			X,
			Y,
			(xyz[2] || 0) / unitsPerMeter(Y)
		];
	}
	/**
	* Add a meter delta to a base lnglat coordinate, returning a new lnglat array
	*
	* Note: Uses simple linear approximation around the viewport center
	* Error increases with size of offset (roughly 1% per 100km)
	*
	* @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate
	* @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
	* @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas
	*/
	addMetersToLngLat(lngLatZ, xyz) {
		return addMetersToLngLat(lngLatZ, xyz);
	}
	panByPosition(coords, pixel, startPixel) {
		const fromLocation = pixelsToWorld(pixel, this.pixelUnprojectionMatrix);
		const toLocation = this.projectFlat(coords);
		const translate$1 = add([], toLocation, negate$1([], fromLocation));
		const newCenter = add([], this.center, translate$1);
		const [longitude, latitude] = this.unprojectFlat(newCenter);
		return {
			longitude,
			latitude
		};
	}
	getBounds(options = {}) {
		const corners = getBounds(this, options.z || 0);
		return [
			Math.min(corners[0][0], corners[1][0], corners[2][0], corners[3][0]),
			Math.min(corners[0][1], corners[1][1], corners[2][1], corners[3][1]),
			Math.max(corners[0][0], corners[1][0], corners[2][0], corners[3][0]),
			Math.max(corners[0][1], corners[1][1], corners[2][1], corners[3][1])
		];
	}
	/**
	* Returns a new viewport that fit around the given rectangle.
	* Only supports non-perspective mode.
	*/
	fitBounds(bounds, options = {}) {
		const { width, height } = this;
		const { longitude, latitude, zoom } = fitBounds({
			width,
			height,
			bounds,
			...options
		});
		return new WebMercatorViewport({
			width,
			height,
			longitude,
			latitude,
			zoom
		});
	}
};
WebMercatorViewport.displayName = "WebMercatorViewport";
var web_mercator_viewport_default = WebMercatorViewport;

//#endregion
//#region node_modules/@deck.gl/core/dist/lifecycle/constants.js
const LIFECYCLE = {
	NO_STATE: "Awaiting state",
	MATCHED: "Matched. State transferred from previous layer",
	INITIALIZED: "Initialized",
	AWAITING_GC: "Discarded. Awaiting garbage collection",
	AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
	FINALIZED: "Finalized! Awaiting garbage collection"
};
const COMPONENT_SYMBOL = Symbol.for("component");
const PROP_TYPES_SYMBOL = Symbol.for("propTypes");
const DEPRECATED_PROPS_SYMBOL = Symbol.for("deprecatedProps");
const ASYNC_DEFAULTS_SYMBOL = Symbol.for("asyncPropDefaults");
const ASYNC_ORIGINAL_SYMBOL = Symbol.for("asyncPropOriginal");
const ASYNC_RESOLVED_SYMBOL = Symbol.for("asyncPropResolved");

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/flatten.js
/**
* Flattens a nested array into a single level array,
* or a single value into an array with one value
* @example flatten([[1, [2]], [3], 4]) => [1, 2, 3, 4]
* @example flatten(1) => [1]
* @param array The array to flatten.
* @param filter= - Optional predicate called on each `value` to
*   determine if it should be included (pushed onto) the resulting array.
* @return Returns the new flattened array (new array or `result` if provided)
*/
function flatten(array, filter = () => true) {
	if (!Array.isArray(array)) return filter(array) ? [array] : [];
	return flattenArray(array, filter, []);
}
/** Deep flattens an array. Helper to `flatten`, see its parameters */
function flattenArray(array, filter, result) {
	let index = -1;
	while (++index < array.length) {
		const value = array[index];
		if (Array.isArray(value)) flattenArray(value, filter, result);
		else if (filter(value)) result.push(value);
	}
	return result;
}
/** Uses copyWithin to significantly speed up typed array value filling */
function fillArray({ target, source: source$2, start = 0, count = 1 }) {
	const length$1 = source$2.length;
	const total = count * length$1;
	let copied = 0;
	for (let i = start; copied < length$1; copied++) target[i++] = source$2[copied];
	while (copied < total) if (copied < total - copied) {
		target.copyWithin(start + copied, start, start + copied);
		copied *= 2;
	} else {
		target.copyWithin(start + copied, start, start + total - copied);
		copied = total;
	}
	return target;
}

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/deep-equal.js
/**
* Fast partial deep equal for prop.
*
* @param a Prop
* @param b Prop to compare against `a`
* @param depth Depth to which to recurse in nested Objects/Arrays. Use 0 (default) for shallow comparison, -1 for infinite depth
*/
function deepEqual(a, b, depth) {
	if (a === b) return true;
	if (!depth || !a || !b) return false;
	if (Array.isArray(a)) {
		if (!Array.isArray(b) || a.length !== b.length) return false;
		for (let i = 0; i < a.length; i++) if (!deepEqual(a[i], b[i], depth - 1)) return false;
		return true;
	}
	if (Array.isArray(b)) return false;
	if (typeof a === "object" && typeof b === "object") {
		const aKeys = Object.keys(a);
		const bKeys = Object.keys(b);
		if (aKeys.length !== bKeys.length) return false;
		for (const key of aKeys) {
			if (!b.hasOwnProperty(key)) return false;
			if (!deepEqual(a[key], b[key], depth - 1)) return false;
		}
		return true;
	}
	return false;
}

//#endregion
//#region node_modules/@deck.gl/core/dist/transitions/transition.js
var Transition = class {
	/**
	* @params timeline {Timeline}
	*/
	constructor(timeline) {
		this._inProgress = false;
		this._handle = null;
		this.time = 0;
		this.settings = { duration: 0 };
		this._timeline = timeline;
	}
	get inProgress() {
		return this._inProgress;
	}
	/**
	* (re)start this transition.
	* @params props {object} - optional overriding props. see constructor
	*/
	start(settings) {
		this.cancel();
		this.settings = settings;
		this._inProgress = true;
		this.settings.onStart?.(this);
	}
	/**
	* end this transition if it is in progress.
	*/
	end() {
		if (this._inProgress) {
			this._timeline.removeChannel(this._handle);
			this._handle = null;
			this._inProgress = false;
			this.settings.onEnd?.(this);
		}
	}
	/**
	* cancel this transition if it is in progress.
	*/
	cancel() {
		if (this._inProgress) {
			this.settings.onInterrupt?.(this);
			this._timeline.removeChannel(this._handle);
			this._handle = null;
			this._inProgress = false;
		}
	}
	/**
	* update this transition. Returns `true` if updated.
	*/
	update() {
		if (!this._inProgress) return false;
		if (this._handle === null) {
			const { _timeline: timeline, settings } = this;
			this._handle = timeline.addChannel({
				delay: timeline.getTime(),
				duration: settings.duration
			});
		}
		this.time = this._timeline.getTime(this._handle);
		this._onUpdate();
		this.settings.onUpdate?.(this);
		if (this._timeline.isFinished(this._handle)) this.end();
		return true;
	}
	_onUpdate() {}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/assert.js
function assert(condition, message) {
	if (!condition) throw new Error(message || "deck.gl: assertion failed.");
}

//#endregion
export { getShaderModuleDependencies as $, project_default as A, color_default as B, altitudeToFovy as C, unitsPerMeter as D, pixelsToWorld as E, PROJECTION_MODE as F, len as G, scale$1 as H, RECOGNIZERS as I, sub as J, lerp as K, UNIT as L, memoize as M, COORDINATE_SYSTEM as N, worldToPixels as O, EVENT_HANDLERS as P, ShaderAssembler as Q, EventManager as R, addMetersToLngLat as S, lngLatToWorld as T, transformMat4$2 as U, Matrix4 as V, Vector3 as W, equals as X, clamp as Y, lerp$2 as Z, toDoublePrecisionArray as _, flatten as a, isBrowser as at, normalizeViewportProps as b, ASYNC_RESOLVED_SYMBOL as c, LIFECYCLE as d, debug as et, PROP_TYPES_SYMBOL as f, mod as g, mergeBounds as h, fillArray as i, registerLoaders as it, getOffsetOrigin as j, project32_default as k, COMPONENT_SYMBOL as l, viewport_default as m, Transition as n, log_default as nt, ASYNC_DEFAULTS_SYMBOL as o, assert$5 as ot, web_mercator_viewport_default as p, sqrLen as q, deepEqual as r, load as rt, ASYNC_ORIGINAL_SYMBOL as s, assert as t, register as tt, DEPRECATED_PROPS_SYMBOL as u, typed_array_manager_default as v, fovyToAltitude as w, MAX_LATITUDE as x, picking_default as y, geometry_default as z };
//# sourceMappingURL=assert-Cv_uMGxh.js.map