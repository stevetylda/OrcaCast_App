import { n as __toESM, t as __commonJS } from "./chunk-CVmoYqME.js";
import { $ as getShaderModuleDependencies, B as color_default, J as sub, L as UNIT, M as memoize, N as COORDINATE_SYSTEM, O as worldToPixels, Q as ShaderAssembler, S as addMetersToLngLat, T as lngLatToWorld, U as transformMat4, Z as lerp, _ as toDoublePrecisionArray, a as flatten, c as ASYNC_RESOLVED_SYMBOL, d as LIFECYCLE, et as debug, f as PROP_TYPES_SYMBOL, h as mergeBounds, i as fillArray, j as getOffsetOrigin, k as project32_default, l as COMPONENT_SYMBOL, n as Transition, nt as log_default, o as ASYNC_DEFAULTS_SYMBOL, p as web_mercator_viewport_default, r as deepEqual, rt as load, s as ASYNC_ORIGINAL_SYMBOL, t as assert, u as DEPRECATED_PROPS_SYMBOL, v as typed_array_manager_default, y as picking_default } from "./assert-Cv_uMGxh.js";
import { _ as Resource, d as getVertexFormatFromAttribute, g as Buffer, h as getTypedArrayConstructor, m as getDataType, p as alignTo, y as log } from "./webgl-developer-tools-DgucggGC.js";
import { a as RenderPipeline, c as Texture, i as getVariableShaderTypeInfo, l as Sampler, n as getScratchArrayBuffer, o as Shader, r as getAttributeInfosFromLayouts, s as TextureView, t as WebGLDevice } from "./webgl-device-Dj1w3AsR.js";

//#region node_modules/@luma.gl/shadertools/dist/lib/glsl-utils/shader-utils.js
var FS300 = `#version 300 es\nout vec4 transform_output;
void main() {
  transform_output = vec4(0);
}`;
/**
* Given the shader input and output variable names,
* builds and return a pass through fragment shader.
*/
function getPassthroughFS(options) {
	const { input, inputChannels, output } = options || {};
	if (!input) return FS300;
	if (!inputChannels) throw new Error("inputChannels");
	return `\
#version 300 es
in ${channelCountToType(inputChannels)} ${input};
out vec4 ${output};
void main() {
  ${output} = ${convertToVec4(input, inputChannels)};
}`;
}
function channelCountToType(channels) {
	switch (channels) {
		case 1: return "float";
		case 2: return "vec2";
		case 3: return "vec3";
		case 4: return "vec4";
		default: throw new Error(`invalid channels: ${channels}`);
	}
}
/** Returns glsl instruction for converting to vec4 */
function convertToVec4(variable, channels) {
	switch (channels) {
		case 1: return `vec4(${variable}, 0.0, 0.0, 1.0)`;
		case 2: return `vec4(${variable}, 0.0, 1.0)`;
		case 3: return `vec4(${variable}, 1.0)`;
		case 4: return variable;
		default: throw new Error(`invalid channels: ${channels}`);
	}
}

//#endregion
//#region node_modules/@luma.gl/core/dist/adapter/resources/compute-pipeline.js
/**
* A compiled and linked shader program for compute
*/
var ComputePipeline = class ComputePipeline extends Resource {
	get [Symbol.toStringTag]() {
		return "ComputePipeline";
	}
	hash = "";
	/** The merged shader layout */
	shaderLayout;
	constructor(device, props) {
		super(device, props, ComputePipeline.defaultProps);
		this.shaderLayout = props.shaderLayout;
	}
	static defaultProps = {
		...Resource.defaultProps,
		shader: void 0,
		entryPoint: void 0,
		constants: {},
		shaderLayout: void 0
	};
};

//#endregion
//#region node_modules/@luma.gl/core/dist/utils/is-array.js
/**
* Check is an array is a typed array
* @param value value to be tested
* @returns input as TypedArray, or null
* @todo this should be provided by @math.gl/types
*/
function isTypedArray$1(value) {
	return ArrayBuffer.isView(value) && !(value instanceof DataView);
}
/**
* Check is an array is a numeric array (typed array or array of numbers)
* @param value value to be tested
* @returns input as NumberArray, or null
* @todo this should be provided by @math.gl/types
*/
function isNumberArray$1(value) {
	if (Array.isArray(value)) return value.length === 0 || typeof value[0] === "number";
	return isTypedArray$1(value);
}

//#endregion
//#region node_modules/@luma.gl/core/dist/portable/uniform-buffer-layout.js
/**
* Smallest buffer size that can be used for uniform buffers.
* TODO - does this depend on device?
*/
var minBufferSize = 1024;
/**
* Std140 layout for uniform buffers
* Supports manual listing of uniforms
*/
var UniformBufferLayout = class {
	layout = {};
	/** number of bytes needed for buffer allocation */
	byteLength;
	/** Create a new UniformBufferLayout given a map of attributes. */
	constructor(uniformTypes, uniformSizes = {}) {
		/** number of 4 byte slots taken */
		let size = 0;
		for (const [key, uniformType] of Object.entries(uniformTypes)) {
			const { type, components } = getVariableShaderTypeInfo(uniformType);
			const count$1 = components * (uniformSizes?.[key] ?? 1);
			size = alignTo(size, count$1);
			const offset = size;
			size += count$1;
			this.layout[key] = {
				type,
				size: count$1,
				offset
			};
		}
		size += (4 - size % 4) % 4;
		const actualByteLength = size * 4;
		this.byteLength = Math.max(actualByteLength, minBufferSize);
	}
	/** Get the data for the complete buffer */
	getData(uniformValues) {
		const arrayBuffer = getScratchArrayBuffer(this.byteLength);
		const typedArrays = {
			i32: new Int32Array(arrayBuffer),
			u32: new Uint32Array(arrayBuffer),
			f32: new Float32Array(arrayBuffer),
			f16: new Uint16Array(arrayBuffer)
		};
		for (const [name, value] of Object.entries(uniformValues)) {
			const uniformLayout = this.layout[name];
			if (!uniformLayout) {
				log.warn(`Supplied uniform value ${name} not present in uniform block layout`)();
				continue;
			}
			const { type, size, offset } = uniformLayout;
			const typedArray = typedArrays[type];
			if (size === 1) {
				if (typeof value !== "number" && typeof value !== "boolean") {
					log.warn(`Supplied value for single component uniform ${name} is not a number: ${value}`)();
					continue;
				}
				typedArray[offset] = Number(value);
			} else {
				if (!isNumberArray$1(value)) {
					log.warn(`Supplied value for multi component / array uniform ${name} is not a numeric array: ${value}`)();
					continue;
				}
				typedArray.set(value, offset);
			}
		}
		return new Uint8Array(arrayBuffer, 0, this.byteLength);
	}
	/** Does this layout have a field with specified name */
	has(name) {
		return Boolean(this.layout[name]);
	}
	/** Get offset and size for a field with specified name */
	get(name) {
		return this.layout[name];
	}
};

//#endregion
//#region node_modules/@luma.gl/core/dist/utils/array-equal.js
/** Test if two arrays are deep equal, with a length limit that defaults to 16 */
function arrayEqual(a$1, b$1, limit = 16) {
	if (a$1 !== b$1) return false;
	const arrayA = a$1;
	const arrayB = b$1;
	if (!isNumberArray$1(arrayA)) return false;
	if (isNumberArray$1(arrayB) && arrayA.length === arrayB.length) {
		for (let i$1 = 0; i$1 < arrayA.length; ++i$1) if (arrayB[i$1] !== arrayA[i$1]) return false;
	}
	return true;
}
/** Copy a value */
function arrayCopy(a$1) {
	if (isNumberArray$1(a$1)) return a$1.slice();
	return a$1;
}

//#endregion
//#region node_modules/@luma.gl/core/dist/portable/uniform-block.js
/**
* A uniform block holds values of the of uniform values for one uniform block / buffer.
* It also does some book keeping on what has changed, to minimize unnecessary writes to uniform buffers.
*/
var UniformBlock = class {
	name;
	uniforms = {};
	modifiedUniforms = {};
	modified = true;
	bindingLayout = {};
	needsRedraw = "initialized";
	constructor(props) {
		this.name = props?.name || "unnamed";
		if (props?.name && props?.shaderLayout) {
			const binding = props?.shaderLayout.bindings?.find((binding_) => binding_.type === "uniform" && binding_.name === props?.name);
			if (!binding) throw new Error(props?.name);
			const uniformBlock$8 = binding;
			for (const uniform of uniformBlock$8.uniforms || []) this.bindingLayout[uniform.name] = uniform;
		}
	}
	/** Set a map of uniforms */
	setUniforms(uniforms) {
		for (const [key, value] of Object.entries(uniforms)) {
			this._setUniform(key, value);
			if (!this.needsRedraw) this.setNeedsRedraw(`${this.name}.${key}=${value}`);
		}
	}
	setNeedsRedraw(reason) {
		this.needsRedraw = this.needsRedraw || reason;
	}
	/** Returns all uniforms */
	getAllUniforms() {
		this.modifiedUniforms = {};
		this.needsRedraw = false;
		return this.uniforms || {};
	}
	/** Set a single uniform */
	_setUniform(key, value) {
		if (arrayEqual(this.uniforms[key], value)) return;
		this.uniforms[key] = arrayCopy(value);
		this.modifiedUniforms[key] = true;
		this.modified = true;
	}
};

//#endregion
//#region node_modules/@luma.gl/core/dist/portable/uniform-store.js
/**
* A uniform store holds a uniform values for one or more uniform blocks,
* - It can generate binary data for any uniform buffer
* - It can manage a uniform buffer for each block
* - It can update managed uniform buffers with a single call
* - It performs some book keeping on what has changed to minimize unnecessary writes to uniform buffers.
*/
var UniformStore = class {
	/** Stores the uniform values for each uniform block */
	uniformBlocks = /* @__PURE__ */ new Map();
	/** Can generate data for a uniform buffer for each block from data */
	uniformBufferLayouts = /* @__PURE__ */ new Map();
	/** Actual buffer for the blocks */
	uniformBuffers = /* @__PURE__ */ new Map();
	/**
	* Create a new UniformStore instance
	* @param blocks
	*/
	constructor(blocks) {
		for (const [bufferName, block] of Object.entries(blocks)) {
			const uniformBufferName = bufferName;
			const uniformBufferLayout = new UniformBufferLayout(block.uniformTypes ?? {}, block.uniformSizes ?? {});
			this.uniformBufferLayouts.set(uniformBufferName, uniformBufferLayout);
			const uniformBlock$8 = new UniformBlock({ name: bufferName });
			uniformBlock$8.setUniforms(block.defaultUniforms || {});
			this.uniformBlocks.set(uniformBufferName, uniformBlock$8);
		}
	}
	/** Destroy any managed uniform buffers */
	destroy() {
		for (const uniformBuffer of this.uniformBuffers.values()) uniformBuffer.destroy();
	}
	/**
	* Set uniforms
	* Makes all properties partial
	*/
	setUniforms(uniforms) {
		for (const [blockName, uniformValues] of Object.entries(uniforms)) this.uniformBlocks.get(blockName)?.setUniforms(uniformValues);
		this.updateUniformBuffers();
	}
	/** Get the required minimum length of the uniform buffer */
	getUniformBufferByteLength(uniformBufferName) {
		return this.uniformBufferLayouts.get(uniformBufferName)?.byteLength || 0;
	}
	/** Get formatted binary memory that can be uploaded to a buffer */
	getUniformBufferData(uniformBufferName) {
		const uniformValues = this.uniformBlocks.get(uniformBufferName)?.getAllUniforms() || {};
		return this.uniformBufferLayouts.get(uniformBufferName)?.getData(uniformValues);
	}
	/**
	* Creates an unmanaged uniform buffer (umnanaged means that application is responsible for destroying it)
	* The new buffer is initialized with current / supplied values
	*/
	createUniformBuffer(device, uniformBufferName, uniforms) {
		if (uniforms) this.setUniforms(uniforms);
		const byteLength = this.getUniformBufferByteLength(uniformBufferName);
		const uniformBuffer = device.createBuffer({
			usage: Buffer.UNIFORM | Buffer.COPY_DST,
			byteLength
		});
		const uniformBufferData = this.getUniformBufferData(uniformBufferName);
		uniformBuffer.write(uniformBufferData);
		return uniformBuffer;
	}
	/** Get the managed uniform buffer. "managed" resources are destroyed when the uniformStore is destroyed. */
	getManagedUniformBuffer(device, uniformBufferName) {
		if (!this.uniformBuffers.get(uniformBufferName)) {
			const byteLength = this.getUniformBufferByteLength(uniformBufferName);
			const uniformBuffer = device.createBuffer({
				usage: Buffer.UNIFORM | Buffer.COPY_DST,
				byteLength
			});
			this.uniformBuffers.set(uniformBufferName, uniformBuffer);
		}
		return this.uniformBuffers.get(uniformBufferName);
	}
	/** Updates all uniform buffers where values have changed */
	updateUniformBuffers() {
		let reason = false;
		for (const uniformBufferName of this.uniformBlocks.keys()) {
			const bufferReason = this.updateUniformBuffer(uniformBufferName);
			reason ||= bufferReason;
		}
		if (reason) log.log(3, `UniformStore.updateUniformBuffers(): ${reason}`)();
		return reason;
	}
	/** Update one uniform buffer. Only updates if values have changed */
	updateUniformBuffer(uniformBufferName) {
		const uniformBlock$8 = this.uniformBlocks.get(uniformBufferName);
		let uniformBuffer = this.uniformBuffers.get(uniformBufferName);
		let reason = false;
		if (uniformBuffer && uniformBlock$8?.needsRedraw) {
			reason ||= uniformBlock$8.needsRedraw;
			const uniformBufferData = this.getUniformBufferData(uniformBufferName);
			uniformBuffer = this.uniformBuffers.get(uniformBufferName);
			uniformBuffer?.write(uniformBufferData);
			const uniformValues = this.uniformBlocks.get(uniformBufferName)?.getAllUniforms();
			log.log(4, `Writing to uniform buffer ${String(uniformBufferName)}`, uniformBufferData, uniformValues)();
		}
		return reason;
	}
};

//#endregion
//#region node_modules/wgsl_reflect/wgsl_reflect.module.js
var e = class {
	constructor(e$1, t$1) {
		this.name = e$1, this.attributes = t$1, this.size = 0;
	}
	get isArray() {
		return !1;
	}
	get isStruct() {
		return !1;
	}
	get isTemplate() {
		return !1;
	}
	get isPointer() {
		return !1;
	}
	getTypeName() {
		return this.name;
	}
};
var t = class {
	constructor(e$1, t$1, n$1) {
		this.name = e$1, this.type = t$1, this.attributes = n$1, this.offset = 0, this.size = 0;
	}
	get isArray() {
		return this.type.isArray;
	}
	get isStruct() {
		return this.type.isStruct;
	}
	get isTemplate() {
		return this.type.isTemplate;
	}
	get align() {
		return this.type.isStruct ? this.type.align : 0;
	}
	get members() {
		return this.type.isStruct ? this.type.members : null;
	}
	get format() {
		return this.type.isArray || this.type.isTemplate ? this.type.format : null;
	}
	get count() {
		return this.type.isArray ? this.type.count : 0;
	}
	get stride() {
		return this.type.isArray ? this.type.stride : this.size;
	}
};
var n = class extends e {
	constructor(e$1, t$1) {
		super(e$1, t$1), this.members = [], this.align = 0, this.startLine = -1, this.endLine = -1, this.inUse = !1;
	}
	get isStruct() {
		return !0;
	}
};
var s = class extends e {
	constructor(e$1, t$1) {
		super(e$1, t$1), this.count = 0, this.stride = 0;
	}
	get isArray() {
		return !0;
	}
	getTypeName() {
		return `array<${this.format.getTypeName()}, ${this.count}>`;
	}
};
var r = class extends e {
	constructor(e$1, t$1, n$1) {
		super(e$1, n$1), this.format = t$1;
	}
	get isPointer() {
		return !0;
	}
	getTypeName() {
		return `&${this.format.getTypeName()}`;
	}
};
var a = class extends e {
	constructor(e$1, t$1, n$1, s$1) {
		super(e$1, n$1), this.format = t$1, this.access = s$1;
	}
	get isTemplate() {
		return !0;
	}
	getTypeName() {
		let e$1 = this.name;
		if (null !== this.format) {
			if ("vec2" === e$1 || "vec3" === e$1 || "vec4" === e$1 || "mat2x2" === e$1 || "mat2x3" === e$1 || "mat2x4" === e$1 || "mat3x2" === e$1 || "mat3x3" === e$1 || "mat3x4" === e$1 || "mat4x2" === e$1 || "mat4x3" === e$1 || "mat4x4" === e$1) {
				if ("f32" === this.format.name) return e$1 += "f", e$1;
				if ("i32" === this.format.name) return e$1 += "i", e$1;
				if ("u32" === this.format.name) return e$1 += "u", e$1;
				if ("bool" === this.format.name) return e$1 += "b", e$1;
				if ("f16" === this.format.name) return e$1 += "h", e$1;
			}
			e$1 += `<${this.format.name}>`;
		} else if ("vec2" === e$1 || "vec3" === e$1 || "vec4" === e$1) return e$1;
		return e$1;
	}
};
var i;
((e$1) => {
	e$1[e$1.Uniform = 0] = "Uniform", e$1[e$1.Storage = 1] = "Storage", e$1[e$1.Texture = 2] = "Texture", e$1[e$1.Sampler = 3] = "Sampler", e$1[e$1.StorageTexture = 4] = "StorageTexture";
})(i || (i = {}));
var o = class {
	constructor(e$1, t$1, n$1, s$1, r$1, a$1, i$1) {
		this.name = e$1, this.type = t$1, this.group = n$1, this.binding = s$1, this.attributes = r$1, this.resourceType = a$1, this.access = i$1;
	}
	get isArray() {
		return this.type.isArray;
	}
	get isStruct() {
		return this.type.isStruct;
	}
	get isTemplate() {
		return this.type.isTemplate;
	}
	get size() {
		return this.type.size;
	}
	get align() {
		return this.type.isStruct ? this.type.align : 0;
	}
	get members() {
		return this.type.isStruct ? this.type.members : null;
	}
	get format() {
		return this.type.isArray || this.type.isTemplate ? this.type.format : null;
	}
	get count() {
		return this.type.isArray ? this.type.count : 0;
	}
	get stride() {
		return this.type.isArray ? this.type.stride : this.size;
	}
};
var c = class {
	constructor(e$1, t$1) {
		this.name = e$1, this.type = t$1;
	}
};
var l = class {
	constructor(e$1, t$1, n$1, s$1) {
		this.name = e$1, this.type = t$1, this.locationType = n$1, this.location = s$1, this.interpolation = null;
	}
};
var u = class {
	constructor(e$1, t$1, n$1, s$1) {
		this.name = e$1, this.type = t$1, this.locationType = n$1, this.location = s$1;
	}
};
var h = class {
	constructor(e$1, t$1, n$1, s$1) {
		this.name = e$1, this.type = t$1, this.attributes = n$1, this.id = s$1;
	}
};
var f = class {
	constructor(e$1, t$1, n$1) {
		this.name = e$1, this.type = t$1, this.attributes = n$1;
	}
};
var p = class {
	constructor(e$1, t$1 = null, n$1) {
		this.stage = null, this.inputs = [], this.outputs = [], this.arguments = [], this.returnType = null, this.resources = [], this.overrides = [], this.startLine = -1, this.endLine = -1, this.inUse = !1, this.calls = /* @__PURE__ */ new Set(), this.name = e$1, this.stage = t$1, this.attributes = n$1;
	}
};
var d = class {
	constructor() {
		this.vertex = [], this.fragment = [], this.compute = [];
	}
};
function m(e$1) {
	var t$1 = (32768 & e$1) >> 15, n$1 = (31744 & e$1) >> 10, s$1 = 1023 & e$1;
	return 0 == n$1 ? (t$1 ? -1 : 1) * Math.pow(2, -14) * (s$1 / Math.pow(2, 10)) : 31 == n$1 ? s$1 ? NaN : Infinity * (t$1 ? -1 : 1) : (t$1 ? -1 : 1) * Math.pow(2, n$1 - 15) * (1 + s$1 / Math.pow(2, 10));
}
var g = new Float32Array(1), _ = new Int32Array(g.buffer), x = new Uint16Array(1);
function y(e$1) {
	g[0] = e$1;
	const t$1 = _[0], n$1 = t$1 >> 31 & 1;
	let s$1 = t$1 >> 23 & 255, r$1 = 8388607 & t$1;
	if (255 === s$1) return x[0] = n$1 << 15 | 31744 | (0 !== r$1 ? 512 : 0), x[0];
	if (0 === s$1) {
		if (0 === r$1) return x[0] = n$1 << 15, x[0];
		r$1 |= 8388608;
		let e$2 = 113;
		for (; !(8388608 & r$1);) r$1 <<= 1, e$2--;
		return s$1 = 127 - e$2, r$1 &= 8388607, s$1 > 0 ? (r$1 = (r$1 >> 126 - s$1) + (r$1 >> 127 - s$1 & 1), x[0] = n$1 << 15 | s$1 << 10 | r$1 >> 13, x[0]) : (x[0] = n$1 << 15, x[0]);
	}
	return s$1 = s$1 - 127 + 15, s$1 >= 31 ? (x[0] = n$1 << 15 | 31744, x[0]) : s$1 <= 0 ? s$1 < -10 ? (x[0] = n$1 << 15, x[0]) : (r$1 = (8388608 | r$1) >> 1 - s$1, x[0] = n$1 << 15 | r$1 >> 13, x[0]) : (r$1 >>= 13, x[0] = n$1 << 15 | s$1 << 10 | r$1, x[0]);
}
var b = new Uint32Array(1), v = new Float32Array(b.buffer, 0, 1);
function w(e$1) {
	return b[0] = 112 + (e$1 >> 6 & 31) << 23 | (63 & e$1) << 17, v[0];
}
function k(e$1, t$1, n$1, s$1, r$1, a$1, i$1, o$1, c$1) {
	const l$1 = s$1 * (i$1 >>= r$1) * (a$1 >>= r$1) + n$1 * i$1 + t$1 * o$1;
	switch (c$1) {
		case "r8unorm": return [I(e$1, l$1, "8unorm", 1)[0]];
		case "r8snorm": return [I(e$1, l$1, "8snorm", 1)[0]];
		case "r8uint": return [I(e$1, l$1, "8uint", 1)[0]];
		case "r8sint": return [I(e$1, l$1, "8sint", 1)[0]];
		case "rg8unorm": {
			const t$2 = I(e$1, l$1, "8unorm", 2);
			return [t$2[0], t$2[1]];
		}
		case "rg8snorm": {
			const t$2 = I(e$1, l$1, "8snorm", 2);
			return [t$2[0], t$2[1]];
		}
		case "rg8uint": {
			const t$2 = I(e$1, l$1, "8uint", 2);
			return [t$2[0], t$2[1]];
		}
		case "rg8sint": {
			const t$2 = I(e$1, l$1, "8sint", 2);
			return [t$2[0], t$2[1]];
		}
		case "rgba8unorm-srgb":
		case "rgba8unorm": {
			const t$2 = I(e$1, l$1, "8unorm", 4);
			return [
				t$2[0],
				t$2[1],
				t$2[2],
				t$2[3]
			];
		}
		case "rgba8snorm": {
			const t$2 = I(e$1, l$1, "8snorm", 4);
			return [
				t$2[0],
				t$2[1],
				t$2[2],
				t$2[3]
			];
		}
		case "rgba8uint": {
			const t$2 = I(e$1, l$1, "8uint", 4);
			return [
				t$2[0],
				t$2[1],
				t$2[2],
				t$2[3]
			];
		}
		case "rgba8sint": {
			const t$2 = I(e$1, l$1, "8sint", 4);
			return [
				t$2[0],
				t$2[1],
				t$2[2],
				t$2[3]
			];
		}
		case "bgra8unorm-srgb":
		case "bgra8unorm": {
			const t$2 = I(e$1, l$1, "8unorm", 4);
			return [
				t$2[2],
				t$2[1],
				t$2[0],
				t$2[3]
			];
		}
		case "r16uint": return [I(e$1, l$1, "16uint", 1)[0]];
		case "r16sint": return [I(e$1, l$1, "16sint", 1)[0]];
		case "r16float": return [I(e$1, l$1, "16float", 1)[0]];
		case "rg16uint": {
			const t$2 = I(e$1, l$1, "16uint", 2);
			return [t$2[0], t$2[1]];
		}
		case "rg16sint": {
			const t$2 = I(e$1, l$1, "16sint", 2);
			return [t$2[0], t$2[1]];
		}
		case "rg16float": {
			const t$2 = I(e$1, l$1, "16float", 2);
			return [t$2[0], t$2[1]];
		}
		case "rgba16uint": {
			const t$2 = I(e$1, l$1, "16uint", 4);
			return [
				t$2[0],
				t$2[1],
				t$2[2],
				t$2[3]
			];
		}
		case "rgba16sint": {
			const t$2 = I(e$1, l$1, "16sint", 4);
			return [
				t$2[0],
				t$2[1],
				t$2[2],
				t$2[3]
			];
		}
		case "rgba16float": {
			const t$2 = I(e$1, l$1, "16float", 4);
			return [
				t$2[0],
				t$2[1],
				t$2[2],
				t$2[3]
			];
		}
		case "r32uint": return [I(e$1, l$1, "32uint", 1)[0]];
		case "r32sint": return [I(e$1, l$1, "32sint", 1)[0]];
		case "depth16unorm":
		case "depth24plus":
		case "depth24plus-stencil8":
		case "depth32float":
		case "depth32float-stencil8":
		case "r32float": return [I(e$1, l$1, "32float", 1)[0]];
		case "rg32uint": {
			const t$2 = I(e$1, l$1, "32uint", 2);
			return [t$2[0], t$2[1]];
		}
		case "rg32sint": {
			const t$2 = I(e$1, l$1, "32sint", 2);
			return [t$2[0], t$2[1]];
		}
		case "rg32float": {
			const t$2 = I(e$1, l$1, "32float", 2);
			return [t$2[0], t$2[1]];
		}
		case "rgba32uint": {
			const t$2 = I(e$1, l$1, "32uint", 4);
			return [
				t$2[0],
				t$2[1],
				t$2[2],
				t$2[3]
			];
		}
		case "rgba32sint": {
			const t$2 = I(e$1, l$1, "32sint", 4);
			return [
				t$2[0],
				t$2[1],
				t$2[2],
				t$2[3]
			];
		}
		case "rgba32float": {
			const t$2 = I(e$1, l$1, "32float", 4);
			return [
				t$2[0],
				t$2[1],
				t$2[2],
				t$2[3]
			];
		}
		case "rg11b10ufloat": {
			const t$2 = new Uint32Array(e$1.buffer, l$1, 1)[0], n$2 = (4192256 & t$2) >> 11, s$2 = (4290772992 & t$2) >> 22;
			return [
				w(2047 & t$2),
				w(n$2),
				function(e$2) {
					return b[0] = 112 + (e$2 >> 5 & 31) << 23 | (31 & e$2) << 18, v[0];
				}(s$2),
				1
			];
		}
	}
	return null;
}
function I(e$1, t$1, n$1, s$1) {
	const r$1 = [
		0,
		0,
		0,
		0
	];
	for (let a$1 = 0; a$1 < s$1; ++a$1) switch (n$1) {
		case "8unorm":
			r$1[a$1] = e$1[t$1] / 255, t$1++;
			break;
		case "8snorm":
			r$1[a$1] = e$1[t$1] / 255 * 2 - 1, t$1++;
			break;
		case "8uint":
			r$1[a$1] = e$1[t$1], t$1++;
			break;
		case "8sint":
			r$1[a$1] = e$1[t$1] - 127, t$1++;
			break;
		case "16uint":
			r$1[a$1] = e$1[t$1] | e$1[t$1 + 1] << 8, t$1 += 2;
			break;
		case "16sint":
			r$1[a$1] = (e$1[t$1] | e$1[t$1 + 1] << 8) - 32768, t$1 += 2;
			break;
		case "16float":
			r$1[a$1] = m(e$1[t$1] | e$1[t$1 + 1] << 8), t$1 += 2;
			break;
		case "32uint":
		case "32sint":
			r$1[a$1] = e$1[t$1] | e$1[t$1 + 1] << 8 | e$1[t$1 + 2] << 16 | e$1[t$1 + 3] << 24, t$1 += 4;
			break;
		case "32float": r$1[a$1] = new Float32Array(e$1.buffer, t$1, 1)[0], t$1 += 4;
	}
	return r$1;
}
function T(e$1, t$1, n$1, s$1, r$1) {
	for (let a$1 = 0; a$1 < s$1; ++a$1) switch (n$1) {
		case "8unorm":
			e$1[t$1] = 255 * r$1[a$1], t$1++;
			break;
		case "8snorm":
			e$1[t$1] = .5 * (r$1[a$1] + 1) * 255, t$1++;
			break;
		case "8uint":
			e$1[t$1] = r$1[a$1], t$1++;
			break;
		case "8sint":
			e$1[t$1] = r$1[a$1] + 127, t$1++;
			break;
		case "16uint":
			new Uint16Array(e$1.buffer, t$1, 1)[0] = r$1[a$1], t$1 += 2;
			break;
		case "16sint":
			new Int16Array(e$1.buffer, t$1, 1)[0] = r$1[a$1], t$1 += 2;
			break;
		case "16float": {
			const n$2 = y(r$1[a$1]);
			new Uint16Array(e$1.buffer, t$1, 1)[0] = n$2, t$1 += 2;
			break;
		}
		case "32uint":
			new Uint32Array(e$1.buffer, t$1, 1)[0] = r$1[a$1], t$1 += 4;
			break;
		case "32sint":
			new Int32Array(e$1.buffer, t$1, 1)[0] = r$1[a$1], t$1 += 4;
			break;
		case "32float": new Float32Array(e$1.buffer, t$1, 1)[0] = r$1[a$1], t$1 += 4;
	}
	return r$1;
}
var S = {
	r8unorm: {
		bytesPerBlock: 1,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 1
	},
	r8snorm: {
		bytesPerBlock: 1,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 1
	},
	r8uint: {
		bytesPerBlock: 1,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 1
	},
	r8sint: {
		bytesPerBlock: 1,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 1
	},
	rg8unorm: {
		bytesPerBlock: 2,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 2
	},
	rg8snorm: {
		bytesPerBlock: 2,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 2
	},
	rg8uint: {
		bytesPerBlock: 2,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 2
	},
	rg8sint: {
		bytesPerBlock: 2,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 2
	},
	rgba8unorm: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	"rgba8unorm-srgb": {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	rgba8snorm: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	rgba8uint: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	rgba8sint: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	bgra8unorm: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	"bgra8unorm-srgb": {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	r16uint: {
		bytesPerBlock: 2,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 1
	},
	r16sint: {
		bytesPerBlock: 2,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 1
	},
	r16float: {
		bytesPerBlock: 2,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 1
	},
	rg16uint: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 2
	},
	rg16sint: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 2
	},
	rg16float: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 2
	},
	rgba16uint: {
		bytesPerBlock: 8,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	rgba16sint: {
		bytesPerBlock: 8,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	rgba16float: {
		bytesPerBlock: 8,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	r32uint: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 1
	},
	r32sint: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 1
	},
	r32float: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 1
	},
	rg32uint: {
		bytesPerBlock: 8,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 2
	},
	rg32sint: {
		bytesPerBlock: 8,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 2
	},
	rg32float: {
		bytesPerBlock: 8,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 2
	},
	rgba32uint: {
		bytesPerBlock: 16,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	rgba32sint: {
		bytesPerBlock: 16,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	rgba32float: {
		bytesPerBlock: 16,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	rgb10a2uint: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	rgb10a2unorm: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	rg11b10ufloat: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	stencil8: {
		bytesPerBlock: 1,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		isDepthStencil: !0,
		hasDepth: !1,
		hasStencil: !0,
		channels: 1
	},
	depth16unorm: {
		bytesPerBlock: 2,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		isDepthStencil: !0,
		hasDepth: !0,
		hasStencil: !1,
		channels: 1
	},
	depth24plus: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		isDepthStencil: !0,
		hasDepth: !0,
		hasStencil: !1,
		depthOnlyFormat: "depth32float",
		channels: 1
	},
	"depth24plus-stencil8": {
		bytesPerBlock: 8,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		isDepthStencil: !0,
		hasDepth: !0,
		hasStencil: !0,
		depthOnlyFormat: "depth32float",
		channels: 1
	},
	depth32float: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		isDepthStencil: !0,
		hasDepth: !0,
		hasStencil: !1,
		channels: 1
	},
	"depth32float-stencil8": {
		bytesPerBlock: 8,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		isDepthStencil: !0,
		hasDepth: !0,
		hasStencil: !0,
		stencilOnlyFormat: "depth32float",
		channels: 1
	},
	rgb9e5ufloat: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	"bc1-rgba-unorm": {
		bytesPerBlock: 8,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"bc1-rgba-unorm-srgb": {
		bytesPerBlock: 8,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"bc2-rgba-unorm": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"bc2-rgba-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"bc3-rgba-unorm": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"bc3-rgba-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"bc4-r-unorm": {
		bytesPerBlock: 8,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 1
	},
	"bc4-r-snorm": {
		bytesPerBlock: 8,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 1
	},
	"bc5-rg-unorm": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 2
	},
	"bc5-rg-snorm": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 2
	},
	"bc6h-rgb-ufloat": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"bc6h-rgb-float": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"bc7-rgba-unorm": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"bc7-rgba-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"etc2-rgb8unorm": {
		bytesPerBlock: 8,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"etc2-rgb8unorm-srgb": {
		bytesPerBlock: 8,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"etc2-rgb8a1unorm": {
		bytesPerBlock: 8,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"etc2-rgb8a1unorm-srgb": {
		bytesPerBlock: 8,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"etc2-rgba8unorm": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"etc2-rgba8unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"eac-r11unorm": {
		bytesPerBlock: 8,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !0,
		channels: 1
	},
	"eac-r11snorm": {
		bytesPerBlock: 8,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !0,
		channels: 1
	},
	"eac-rg11unorm": {
		bytesPerBlock: 16,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !0,
		channels: 2
	},
	"eac-rg11snorm": {
		bytesPerBlock: 16,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !0,
		channels: 2
	},
	"astc-4x4-unorm": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"astc-4x4-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"astc-5x4-unorm": {
		bytesPerBlock: 16,
		blockWidth: 5,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"astc-5x4-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 5,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"astc-5x5-unorm": {
		bytesPerBlock: 16,
		blockWidth: 5,
		blockHeight: 5,
		isCompressed: !0,
		channels: 4
	},
	"astc-5x5-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 5,
		blockHeight: 5,
		isCompressed: !0,
		channels: 4
	},
	"astc-6x5-unorm": {
		bytesPerBlock: 16,
		blockWidth: 6,
		blockHeight: 5,
		isCompressed: !0,
		channels: 4
	},
	"astc-6x5-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 6,
		blockHeight: 5,
		isCompressed: !0,
		channels: 4
	},
	"astc-6x6-unorm": {
		bytesPerBlock: 16,
		blockWidth: 6,
		blockHeight: 6,
		isCompressed: !0,
		channels: 4
	},
	"astc-6x6-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 6,
		blockHeight: 6,
		isCompressed: !0,
		channels: 4
	},
	"astc-8x5-unorm": {
		bytesPerBlock: 16,
		blockWidth: 8,
		blockHeight: 5,
		isCompressed: !0,
		channels: 4
	},
	"astc-8x5-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 8,
		blockHeight: 5,
		isCompressed: !0,
		channels: 4
	},
	"astc-8x6-unorm": {
		bytesPerBlock: 16,
		blockWidth: 8,
		blockHeight: 6,
		isCompressed: !0,
		channels: 4
	},
	"astc-8x6-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 8,
		blockHeight: 6,
		isCompressed: !0,
		channels: 4
	},
	"astc-8x8-unorm": {
		bytesPerBlock: 16,
		blockWidth: 8,
		blockHeight: 8,
		isCompressed: !0,
		channels: 4
	},
	"astc-8x8-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 8,
		blockHeight: 8,
		isCompressed: !0,
		channels: 4
	},
	"astc-10x5-unorm": {
		bytesPerBlock: 16,
		blockWidth: 10,
		blockHeight: 5,
		isCompressed: !0,
		channels: 4
	},
	"astc-10x5-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 10,
		blockHeight: 5,
		isCompressed: !0,
		channels: 4
	},
	"astc-10x6-unorm": {
		bytesPerBlock: 16,
		blockWidth: 10,
		blockHeight: 6,
		isCompressed: !0,
		channels: 4
	},
	"astc-10x6-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 10,
		blockHeight: 6,
		isCompressed: !0,
		channels: 4
	},
	"astc-10x8-unorm": {
		bytesPerBlock: 16,
		blockWidth: 10,
		blockHeight: 8,
		isCompressed: !0,
		channels: 4
	},
	"astc-10x8-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 10,
		blockHeight: 8,
		isCompressed: !0,
		channels: 4
	},
	"astc-10x10-unorm": {
		bytesPerBlock: 16,
		blockWidth: 10,
		blockHeight: 10,
		isCompressed: !0,
		channels: 4
	},
	"astc-10x10-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 10,
		blockHeight: 10,
		isCompressed: !0,
		channels: 4
	},
	"astc-12x10-unorm": {
		bytesPerBlock: 16,
		blockWidth: 12,
		blockHeight: 10,
		isCompressed: !0,
		channels: 4
	},
	"astc-12x10-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 12,
		blockHeight: 10,
		isCompressed: !0,
		channels: 4
	},
	"astc-12x12-unorm": {
		bytesPerBlock: 16,
		blockWidth: 12,
		blockHeight: 12,
		isCompressed: !0,
		channels: 4
	},
	"astc-12x12-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 12,
		blockHeight: 12,
		isCompressed: !0,
		channels: 4
	}
};
var A = class A {
	constructor() {
		this.id = A._id++, this.line = 0;
	}
	get isAstNode() {
		return !0;
	}
	get astNodeType() {
		return "";
	}
	search(e$1) {
		e$1(this);
	}
	searchBlock(e$1, t$1) {
		if (e$1) {
			t$1(E.instance);
			for (const n$1 of e$1) n$1 instanceof Array ? this.searchBlock(n$1, t$1) : n$1.search(t$1);
			t$1($.instance);
		}
	}
	constEvaluate(e$1, t$1) {
		throw new Error("Cannot evaluate node");
	}
	constEvaluateString(e$1) {
		return this.constEvaluate(e$1).toString();
	}
};
A._id = 0;
var E = class extends A {};
E.instance = new E();
var $ = class extends A {};
$.instance = new $();
var L = new Set([
	"all",
	"all",
	"any",
	"select",
	"arrayLength",
	"abs",
	"acos",
	"acosh",
	"asin",
	"asinh",
	"atan",
	"atanh",
	"atan2",
	"ceil",
	"clamp",
	"cos",
	"cosh",
	"countLeadingZeros",
	"countOneBits",
	"countTrailingZeros",
	"cross",
	"degrees",
	"determinant",
	"distance",
	"dot",
	"dot4U8Packed",
	"dot4I8Packed",
	"exp",
	"exp2",
	"extractBits",
	"faceForward",
	"firstLeadingBit",
	"firstTrailingBit",
	"floor",
	"fma",
	"fract",
	"frexp",
	"insertBits",
	"inverseSqrt",
	"ldexp",
	"length",
	"log",
	"log2",
	"max",
	"min",
	"mix",
	"modf",
	"normalize",
	"pow",
	"quantizeToF16",
	"radians",
	"reflect",
	"refract",
	"reverseBits",
	"round",
	"saturate",
	"sign",
	"sin",
	"sinh",
	"smoothStep",
	"sqrt",
	"step",
	"tan",
	"tanh",
	"transpose",
	"trunc",
	"dpdx",
	"dpdxCoarse",
	"dpdxFine",
	"dpdy",
	"dpdyCoarse",
	"dpdyFine",
	"fwidth",
	"fwidthCoarse",
	"fwidthFine",
	"textureDimensions",
	"textureGather",
	"textureGatherCompare",
	"textureLoad",
	"textureNumLayers",
	"textureNumLevels",
	"textureNumSamples",
	"textureSample",
	"textureSampleBias",
	"textureSampleCompare",
	"textureSampleCompareLevel",
	"textureSampleGrad",
	"textureSampleLevel",
	"textureSampleBaseClampToEdge",
	"textureStore",
	"atomicLoad",
	"atomicStore",
	"atomicAdd",
	"atomicSub",
	"atomicMax",
	"atomicMin",
	"atomicAnd",
	"atomicOr",
	"atomicXor",
	"atomicExchange",
	"atomicCompareExchangeWeak",
	"pack4x8snorm",
	"pack4x8unorm",
	"pack4xI8",
	"pack4xU8",
	"pack4x8Clamp",
	"pack4xU8Clamp",
	"pack2x16snorm",
	"pack2x16unorm",
	"pack2x16float",
	"unpack4x8snorm",
	"unpack4x8unorm",
	"unpack4xI8",
	"unpack4xU8",
	"unpack2x16snorm",
	"unpack2x16unorm",
	"unpack2x16float",
	"storageBarrier",
	"textureBarrier",
	"workgroupBarrier",
	"workgroupUniformLoad",
	"subgroupAdd",
	"subgroupExclusiveAdd",
	"subgroupInclusiveAdd",
	"subgroupAll",
	"subgroupAnd",
	"subgroupAny",
	"subgroupBallot",
	"subgroupBroadcast",
	"subgroupBroadcastFirst",
	"subgroupElect",
	"subgroupMax",
	"subgroupMin",
	"subgroupMul",
	"subgroupExclusiveMul",
	"subgroupInclusiveMul",
	"subgroupOr",
	"subgroupShuffle",
	"subgroupShuffleDown",
	"subgroupShuffleUp",
	"subgroupShuffleXor",
	"subgroupXor",
	"quadBroadcast",
	"quadSwapDiagonal",
	"quadSwapX",
	"quadSwapY"
]);
var C = class extends A {
	constructor() {
		super();
	}
};
var D = class extends C {
	constructor(e$1, t$1, n$1, s$1, r$1, a$1) {
		super(), this.calls = /* @__PURE__ */ new Set(), this.name = e$1, this.args = t$1, this.returnType = n$1, this.body = s$1, this.startLine = r$1, this.endLine = a$1;
	}
	get astNodeType() {
		return "function";
	}
	search(e$1) {
		if (this.attributes) for (const t$1 of this.attributes) e$1(t$1);
		e$1(this);
		for (const t$1 of this.args) e$1(t$1);
		this.searchBlock(this.body, e$1);
	}
};
var N = class extends C {
	constructor(e$1) {
		super(), this.expression = e$1;
	}
	get astNodeType() {
		return "staticAssert";
	}
	search(e$1) {
		this.expression.search(e$1);
	}
};
var V = class extends C {
	constructor(e$1, t$1) {
		super(), this.condition = e$1, this.body = t$1;
	}
	get astNodeType() {
		return "while";
	}
	search(e$1) {
		this.condition.search(e$1), this.searchBlock(this.body, e$1);
	}
};
var O = class extends C {
	constructor(e$1, t$1) {
		super(), this.body = e$1, this.loopId = t$1;
	}
	get astNodeType() {
		return "continuing";
	}
	search(e$1) {
		this.searchBlock(this.body, e$1);
	}
};
var B = class extends C {
	constructor(e$1, t$1, n$1, s$1) {
		super(), this.init = e$1, this.condition = t$1, this.increment = n$1, this.body = s$1;
	}
	get astNodeType() {
		return "for";
	}
	search(e$1) {
		var t$1, n$1, s$1;
		null === (t$1 = this.init) || void 0 === t$1 || t$1.search(e$1), null === (n$1 = this.condition) || void 0 === n$1 || n$1.search(e$1), null === (s$1 = this.increment) || void 0 === s$1 || s$1.search(e$1), this.searchBlock(this.body, e$1);
	}
};
var F = class extends C {
	constructor(e$1, t$1, n$1, s$1, r$1) {
		super(), this.attributes = null, this.name = e$1, this.type = t$1, this.storage = n$1, this.access = s$1, this.value = r$1;
	}
	get astNodeType() {
		return "var";
	}
	search(e$1) {
		var t$1;
		e$1(this), null === (t$1 = this.value) || void 0 === t$1 || t$1.search(e$1);
	}
};
var M = class extends C {
	constructor(e$1, t$1, n$1) {
		super(), this.attributes = null, this.name = e$1, this.type = t$1, this.value = n$1;
	}
	get astNodeType() {
		return "override";
	}
	search(e$1) {
		var t$1;
		null === (t$1 = this.value) || void 0 === t$1 || t$1.search(e$1);
	}
};
var U = class extends C {
	constructor(e$1, t$1, n$1, s$1, r$1) {
		super(), this.attributes = null, this.name = e$1, this.type = t$1, this.storage = n$1, this.access = s$1, this.value = r$1;
	}
	get astNodeType() {
		return "let";
	}
	search(e$1) {
		var t$1;
		e$1(this), null === (t$1 = this.value) || void 0 === t$1 || t$1.search(e$1);
	}
};
var P = class extends C {
	constructor(e$1, t$1, n$1, s$1, r$1) {
		super(), this.attributes = null, this.name = e$1, this.type = t$1, this.storage = n$1, this.access = s$1, this.value = r$1;
	}
	get astNodeType() {
		return "const";
	}
	constEvaluate(e$1, t$1) {
		return this.value.constEvaluate(e$1, t$1);
	}
	search(e$1) {
		var t$1;
		e$1(this), null === (t$1 = this.value) || void 0 === t$1 || t$1.search(e$1);
	}
};
var W, q, H, z;
((e$1) => {
	e$1.increment = "++", e$1.decrement = "--";
})(W || (W = {})), ((e$1) => {
	e$1.parse = function(t$1) {
		const n$1 = t$1;
		if ("parse" == n$1) throw new Error("Invalid value for IncrementOperator");
		return e$1[n$1];
	};
})(W || (W = {}));
var R = class extends C {
	constructor(e$1, t$1) {
		super(), this.operator = e$1, this.variable = t$1;
	}
	get astNodeType() {
		return "increment";
	}
	search(e$1) {
		this.variable.search(e$1);
	}
};
((e$1) => {
	e$1.assign = "=", e$1.addAssign = "+=", e$1.subtractAssin = "-=", e$1.multiplyAssign = "*=", e$1.divideAssign = "/=", e$1.moduloAssign = "%=", e$1.andAssign = "&=", e$1.orAssign = "|=", e$1.xorAssign = "^=", e$1.shiftLeftAssign = "<<=", e$1.shiftRightAssign = ">>=";
})(q || (q = {})), ((e$1) => {
	e$1.parse = function(e$2) {
		const t$1 = e$2;
		if ("parse" == t$1) throw new Error("Invalid value for AssignOperator");
		return t$1;
	};
})(q || (q = {}));
var G = class extends C {
	constructor(e$1, t$1, n$1) {
		super(), this.operator = e$1, this.variable = t$1, this.value = n$1;
	}
	get astNodeType() {
		return "assign";
	}
	search(e$1) {
		this.variable.search(e$1), this.value.search(e$1);
	}
};
var X = class extends C {
	constructor(e$1, t$1) {
		super(), this.name = e$1, this.args = t$1;
	}
	get astNodeType() {
		return "call";
	}
	isBuiltin() {
		return L.has(this.name);
	}
	search(e$1) {
		for (const t$1 of this.args) t$1.search(e$1);
		e$1(this);
	}
};
var j = class extends C {
	constructor(e$1, t$1) {
		super(), this.body = e$1, this.continuing = t$1;
	}
	get astNodeType() {
		return "loop";
	}
	search(e$1) {
		var t$1;
		this.searchBlock(this.body, e$1), null === (t$1 = this.continuing) || void 0 === t$1 || t$1.search(e$1);
	}
};
var Z = class extends C {
	constructor(e$1, t$1) {
		super(), this.condition = e$1, this.cases = t$1;
	}
	get astNodeType() {
		return "switch";
	}
	search(e$1) {
		e$1(this);
		for (const t$1 of this.cases) t$1.search(e$1);
	}
};
var Q = class extends C {
	constructor(e$1, t$1, n$1, s$1) {
		super(), this.condition = e$1, this.body = t$1, this.elseif = n$1, this.else = s$1;
	}
	get astNodeType() {
		return "if";
	}
	search(e$1) {
		this.condition.search(e$1), this.searchBlock(this.body, e$1), this.searchBlock(this.elseif, e$1), this.searchBlock(this.else, e$1);
	}
};
var Y = class extends C {
	constructor(e$1) {
		super(), this.value = e$1;
	}
	get astNodeType() {
		return "return";
	}
	search(e$1) {
		var t$1;
		null === (t$1 = this.value) || void 0 === t$1 || t$1.search(e$1);
	}
};
var K = class extends C {
	constructor(e$1) {
		super(), this.name = e$1;
	}
	get astNodeType() {
		return "enable";
	}
};
var J = class extends C {
	constructor(e$1) {
		super(), this.extensions = e$1;
	}
	get astNodeType() {
		return "requires";
	}
};
var ee = class extends C {
	constructor(e$1, t$1) {
		super(), this.severity = e$1, this.rule = t$1;
	}
	get astNodeType() {
		return "diagnostic";
	}
};
var te = class extends C {
	constructor(e$1, t$1) {
		super(), this.name = e$1, this.type = t$1;
	}
	get astNodeType() {
		return "alias";
	}
};
var ne = class extends C {
	constructor() {
		super();
	}
	get astNodeType() {
		return "discard";
	}
};
var se = class extends C {
	constructor() {
		super(), this.condition = null, this.loopId = -1;
	}
	get astNodeType() {
		return "break";
	}
};
var re = class extends C {
	constructor() {
		super(), this.loopId = -1;
	}
	get astNodeType() {
		return "continue";
	}
};
var ae = class ae extends C {
	constructor(e$1) {
		super(), this.attributes = null, this.name = e$1;
	}
	get astNodeType() {
		return "type";
	}
	get isStruct() {
		return !1;
	}
	get isArray() {
		return !1;
	}
	static maxFormatType(e$1) {
		let t$1 = e$1[0];
		if ("f32" === t$1.name) return t$1;
		for (let n$1 = 1; n$1 < e$1.length; ++n$1) {
			const s$1 = ae._priority.get(t$1.name);
			ae._priority.get(e$1[n$1].name) < s$1 && (t$1 = e$1[n$1]);
		}
		return "x32" === t$1.name ? ae.i32 : t$1;
	}
	getTypeName() {
		return this.name;
	}
};
ae.x32 = new ae("x32"), ae.f32 = new ae("f32"), ae.i32 = new ae("i32"), ae.u32 = new ae("u32"), ae.f16 = new ae("f16"), ae.bool = new ae("bool"), ae.void = new ae("void"), ae._priority = new Map([
	["f32", 0],
	["f16", 1],
	["u32", 2],
	["i32", 3],
	["x32", 3]
]);
var ie = class extends ae {
	constructor(e$1) {
		super(e$1);
	}
};
var oe = class extends ae {
	constructor(e$1, t$1, n$1, s$1) {
		super(e$1), this.members = t$1, this.startLine = n$1, this.endLine = s$1;
	}
	get astNodeType() {
		return "struct";
	}
	get isStruct() {
		return !0;
	}
	getMemberIndex(e$1) {
		for (let t$1 = 0; t$1 < this.members.length; t$1++) if (this.members[t$1].name == e$1) return t$1;
		return -1;
	}
	search(e$1) {
		for (const t$1 of this.members) e$1(t$1);
	}
};
var ce = class extends ae {
	constructor(e$1, t$1, n$1) {
		super(e$1), this.format = t$1, this.access = n$1;
	}
	get astNodeType() {
		return "template";
	}
	getTypeName() {
		let e$1 = this.name;
		if (null !== this.format) {
			if ("vec2" === e$1 || "vec3" === e$1 || "vec4" === e$1 || "mat2x2" === e$1 || "mat2x3" === e$1 || "mat2x4" === e$1 || "mat3x2" === e$1 || "mat3x3" === e$1 || "mat3x4" === e$1 || "mat4x2" === e$1 || "mat4x3" === e$1 || "mat4x4" === e$1) {
				if ("f32" === this.format.name) return e$1 += "f", e$1;
				if ("i32" === this.format.name) return e$1 += "i", e$1;
				if ("u32" === this.format.name) return e$1 += "u", e$1;
				if ("bool" === this.format.name) return e$1 += "b", e$1;
				if ("f16" === this.format.name) return e$1 += "h", e$1;
			}
			e$1 += `<${this.format.name}>`;
		} else if ("vec2" === e$1 || "vec3" === e$1 || "vec4" === e$1) return e$1;
		return e$1;
	}
};
ce.vec2f = new ce("vec2", ae.f32, null), ce.vec3f = new ce("vec3", ae.f32, null), ce.vec4f = new ce("vec4", ae.f32, null), ce.vec2i = new ce("vec2", ae.i32, null), ce.vec3i = new ce("vec3", ae.i32, null), ce.vec4i = new ce("vec4", ae.i32, null), ce.vec2u = new ce("vec2", ae.u32, null), ce.vec3u = new ce("vec3", ae.u32, null), ce.vec4u = new ce("vec4", ae.u32, null), ce.vec2h = new ce("vec2", ae.f16, null), ce.vec3h = new ce("vec3", ae.f16, null), ce.vec4h = new ce("vec4", ae.f16, null), ce.vec2b = new ce("vec2", ae.bool, null), ce.vec3b = new ce("vec3", ae.bool, null), ce.vec4b = new ce("vec4", ae.bool, null), ce.mat2x2f = new ce("mat2x2", ae.f32, null), ce.mat2x3f = new ce("mat2x3", ae.f32, null), ce.mat2x4f = new ce("mat2x4", ae.f32, null), ce.mat3x2f = new ce("mat3x2", ae.f32, null), ce.mat3x3f = new ce("mat3x3", ae.f32, null), ce.mat3x4f = new ce("mat3x4", ae.f32, null), ce.mat4x2f = new ce("mat4x2", ae.f32, null), ce.mat4x3f = new ce("mat4x3", ae.f32, null), ce.mat4x4f = new ce("mat4x4", ae.f32, null), ce.mat2x2h = new ce("mat2x2", ae.f16, null), ce.mat2x3h = new ce("mat2x3", ae.f16, null), ce.mat2x4h = new ce("mat2x4", ae.f16, null), ce.mat3x2h = new ce("mat3x2", ae.f16, null), ce.mat3x3h = new ce("mat3x3", ae.f16, null), ce.mat3x4h = new ce("mat3x4", ae.f16, null), ce.mat4x2h = new ce("mat4x2", ae.f16, null), ce.mat4x3h = new ce("mat4x3", ae.f16, null), ce.mat4x4h = new ce("mat4x4", ae.f16, null), ce.mat2x2i = new ce("mat2x2", ae.i32, null), ce.mat2x3i = new ce("mat2x3", ae.i32, null), ce.mat2x4i = new ce("mat2x4", ae.i32, null), ce.mat3x2i = new ce("mat3x2", ae.i32, null), ce.mat3x3i = new ce("mat3x3", ae.i32, null), ce.mat3x4i = new ce("mat3x4", ae.i32, null), ce.mat4x2i = new ce("mat4x2", ae.i32, null), ce.mat4x3i = new ce("mat4x3", ae.i32, null), ce.mat4x4i = new ce("mat4x4", ae.i32, null), ce.mat2x2u = new ce("mat2x2", ae.u32, null), ce.mat2x3u = new ce("mat2x3", ae.u32, null), ce.mat2x4u = new ce("mat2x4", ae.u32, null), ce.mat3x2u = new ce("mat3x2", ae.u32, null), ce.mat3x3u = new ce("mat3x3", ae.u32, null), ce.mat3x4u = new ce("mat3x4", ae.u32, null), ce.mat4x2u = new ce("mat4x2", ae.u32, null), ce.mat4x3u = new ce("mat4x3", ae.u32, null), ce.mat4x4u = new ce("mat4x4", ae.u32, null);
var le = class extends ae {
	constructor(e$1, t$1, n$1, s$1) {
		super(e$1), this.storage = t$1, this.type = n$1, this.access = s$1;
	}
	get astNodeType() {
		return "pointer";
	}
};
var ue = class extends ae {
	constructor(e$1, t$1, n$1, s$1) {
		super(e$1), this.attributes = t$1, this.format = n$1, this.count = s$1;
	}
	get astNodeType() {
		return "array";
	}
	get isArray() {
		return !0;
	}
};
var he = class extends ae {
	constructor(e$1, t$1, n$1) {
		super(e$1), this.format = t$1, this.access = n$1;
	}
	get astNodeType() {
		return "sampler";
	}
};
var fe = class extends A {
	constructor() {
		super(), this.postfix = null;
	}
};
var pe = class extends fe {
	constructor(e$1) {
		super(), this.value = e$1;
	}
	get astNodeType() {
		return "stringExpr";
	}
	toString() {
		return this.value;
	}
	constEvaluateString() {
		return this.value;
	}
};
var de = class extends fe {
	constructor(e$1, t$1) {
		super(), this.type = e$1, this.args = t$1;
	}
	get astNodeType() {
		return "createExpr";
	}
	search(e$1) {
		if (e$1(this), this.args) for (const t$1 of this.args) t$1.search(e$1);
	}
	constEvaluate(e$1, t$1) {
		return t$1 && (t$1[0] = this.type), e$1.evalExpression(this, e$1.context);
	}
};
var me = class extends fe {
	constructor(e$1, t$1) {
		super(), this.cachedReturnValue = null, this.name = e$1, this.args = t$1;
	}
	get astNodeType() {
		return "callExpr";
	}
	setCachedReturnValue(e$1) {
		this.cachedReturnValue = e$1;
	}
	get isBuiltin() {
		return L.has(this.name);
	}
	constEvaluate(e$1, t$1) {
		return e$1.evalExpression(this, e$1.context);
	}
	search(e$1) {
		for (const t$1 of this.args) t$1.search(e$1);
		e$1(this);
	}
};
var ge = class extends fe {
	constructor(e$1) {
		super(), this.name = e$1;
	}
	get astNodeType() {
		return "varExpr";
	}
	search(e$1) {
		e$1(this), this.postfix && this.postfix.search(e$1);
	}
	constEvaluate(e$1, t$1) {
		return e$1.evalExpression(this, e$1.context);
	}
};
var _e = class extends fe {
	constructor(e$1, t$1) {
		super(), this.name = e$1, this.initializer = t$1;
	}
	get astNodeType() {
		return "constExpr";
	}
	constEvaluate(e$1, t$1) {
		if (this.initializer) {
			const t$2 = e$1.evalExpression(this.initializer, e$1.context);
			return null !== t$2 && this.postfix ? t$2.getSubData(e$1, this.postfix, e$1.context) : t$2;
		}
		return null;
	}
	search(e$1) {
		this.initializer.search(e$1);
	}
};
var xe = class extends fe {
	constructor(e$1, t$1) {
		super(), this.value = e$1, this.type = t$1;
	}
	get astNodeType() {
		return "literalExpr";
	}
	constEvaluate(e$1, t$1) {
		return void 0 !== t$1 && (t$1[0] = this.type), this.value;
	}
	get isScalar() {
		return this.value instanceof Be;
	}
	get isVector() {
		return this.value instanceof Me || this.value instanceof Ue;
	}
	get scalarValue() {
		return this.value instanceof Be ? this.value.value : (console.error("Value is not scalar."), 0);
	}
	get vectorValue() {
		return this.value instanceof Me || this.value instanceof Ue ? this.value.data : (console.error("Value is not a vector or matrix."), new Float32Array(0));
	}
};
var ye = class extends fe {
	constructor(e$1, t$1) {
		super(), this.type = e$1, this.value = t$1;
	}
	get astNodeType() {
		return "bitcastExpr";
	}
	search(e$1) {
		this.value.search(e$1);
	}
};
var ve = class extends fe {
	constructor(e$1) {
		super(), this.index = e$1;
	}
	search(e$1) {
		this.index.search(e$1);
	}
};
var we = class extends fe {
	constructor() {
		super();
	}
};
var ke = class extends we {
	constructor(e$1, t$1) {
		super(), this.operator = e$1, this.right = t$1;
	}
	get astNodeType() {
		return "unaryOp";
	}
	constEvaluate(e$1, t$1) {
		return e$1.evalExpression(this, e$1.context);
	}
	search(e$1) {
		this.right.search(e$1);
	}
};
var Ie = class extends we {
	constructor(e$1, t$1, n$1) {
		super(), this.operator = e$1, this.left = t$1, this.right = n$1;
	}
	get astNodeType() {
		return "binaryOp";
	}
	_getPromotedType(e$1, t$1) {
		return e$1.name === t$1.name ? e$1 : "f32" === e$1.name || "f32" === t$1.name ? ae.f32 : "u32" === e$1.name || "u32" === t$1.name ? ae.u32 : ae.i32;
	}
	constEvaluate(e$1, t$1) {
		return e$1.evalExpression(this, e$1.context);
	}
	search(e$1) {
		this.left.search(e$1), this.right.search(e$1);
	}
};
var Te = class extends A {
	constructor(e$1) {
		super(), this.body = e$1;
	}
	search(e$1) {
		e$1(this), this.searchBlock(this.body, e$1);
	}
};
var Se = class extends fe {
	constructor() {
		super();
	}
	get astNodeType() {
		return "default";
	}
};
var Ae = class extends Te {
	constructor(e$1, t$1) {
		super(t$1), this.selectors = e$1;
	}
	get astNodeType() {
		return "case";
	}
	search(e$1) {
		this.searchBlock(this.body, e$1);
	}
};
var Ee = class extends Te {
	constructor(e$1) {
		super(e$1);
	}
	get astNodeType() {
		return "default";
	}
	search(e$1) {
		this.searchBlock(this.body, e$1);
	}
};
var $e = class extends A {
	constructor(e$1, t$1, n$1) {
		super(), this.name = e$1, this.type = t$1, this.attributes = n$1;
	}
	get astNodeType() {
		return "argument";
	}
};
var Le = class extends A {
	constructor(e$1, t$1) {
		super(), this.condition = e$1, this.body = t$1;
	}
	get astNodeType() {
		return "elseif";
	}
	search(e$1) {
		this.condition.search(e$1), this.searchBlock(this.body, e$1);
	}
};
var Ce = class extends A {
	constructor(e$1, t$1, n$1) {
		super(), this.name = e$1, this.type = t$1, this.attributes = n$1;
	}
	get astNodeType() {
		return "member";
	}
};
var De = class extends A {
	constructor(e$1, t$1) {
		super(), this.name = e$1, this.value = t$1;
	}
	get astNodeType() {
		return "attribute";
	}
};
var Ne = class Ne {
	constructor(e$1, t$1) {
		this.parent = null, this.typeInfo = e$1, this.parent = t$1, this.id = Ne._id++;
	}
	clone() {
		throw `Clone: Not implemented for ${this.constructor.name}`;
	}
	setDataValue(e$1, t$1, n$1, s$1) {
		console.error(`SetDataValue: Not implemented for ${this.constructor.name}`);
	}
	getSubData(e$1, t$1, n$1) {
		return console.error(`GetDataValue: Not implemented for ${this.constructor.name}`), null;
	}
	toString() {
		return `<${this.typeInfo.getTypeName()}>`;
	}
};
Ne._id = 0;
var Ve = class extends Ne {
	constructor() {
		super(new e("void", null), null);
	}
	toString() {
		return "void";
	}
};
Ve.void = new Ve();
var Oe = class extends Ne {
	constructor(e$1) {
		super(new r("pointer", e$1.typeInfo, null), null), this.reference = e$1;
	}
	clone() {
		return this;
	}
	setDataValue(e$1, t$1, n$1, s$1) {
		this.reference.setDataValue(e$1, t$1, n$1, s$1);
	}
	getSubData(e$1, t$1, n$1) {
		return t$1 ? this.reference.getSubData(e$1, t$1, n$1) : this;
	}
	toString() {
		return `&${this.reference.toString()}`;
	}
};
var Be = class Be extends Ne {
	constructor(e$1, t$1, n$1 = null) {
		super(t$1, n$1), e$1 instanceof Int32Array || e$1 instanceof Uint32Array || e$1 instanceof Float32Array ? this.data = e$1 : "x32" === this.typeInfo.name ? e$1 - Math.floor(e$1) !== 0 ? this.data = new Float32Array([e$1]) : this.data = e$1 >= 0 ? new Uint32Array([e$1]) : new Int32Array([e$1]) : "i32" === this.typeInfo.name || "bool" === this.typeInfo.name ? this.data = new Int32Array([e$1]) : "u32" === this.typeInfo.name ? this.data = new Uint32Array([e$1]) : "f32" === this.typeInfo.name || "f16" === this.typeInfo.name ? this.data = new Float32Array([e$1]) : console.error("ScalarData2: Invalid type", t$1);
	}
	clone() {
		if (this.data instanceof Float32Array) return new Be(new Float32Array(this.data), this.typeInfo, null);
		if (this.data instanceof Int32Array) return new Be(new Int32Array(this.data), this.typeInfo, null);
		if (this.data instanceof Uint32Array) return new Be(new Uint32Array(this.data), this.typeInfo, null);
		throw "ScalarData: Invalid data type";
	}
	get value() {
		return this.data[0];
	}
	set value(e$1) {
		this.data[0] = e$1;
	}
	setDataValue(e$1, t$1, n$1, s$1) {
		if (n$1) return void console.error("SetDataValue: Scalar data does not support postfix", n$1);
		if (!(t$1 instanceof Be)) return void console.error("SetDataValue: Invalid value", t$1);
		let r$1 = t$1.data[0];
		"i32" === this.typeInfo.name || "u32" === this.typeInfo.name ? r$1 = Math.floor(r$1) : "bool" === this.typeInfo.name && (r$1 = r$1 ? 1 : 0), this.data[0] = r$1;
	}
	getSubData(e$1, t$1, n$1) {
		return t$1 ? (console.error("getSubData: Scalar data does not support postfix", t$1), null) : this;
	}
	toString() {
		return `${this.value}`;
	}
};
function Fe(e$1, t$1, n$1) {
	const s$1 = t$1.length;
	return 2 === s$1 ? "f32" === n$1 ? new Me(new Float32Array(t$1), e$1.getTypeInfo("vec2f")) : "i32" === n$1 || "bool" === n$1 ? new Me(new Int32Array(t$1), e$1.getTypeInfo("vec2i")) : "u32" === n$1 ? new Me(new Uint32Array(t$1), e$1.getTypeInfo("vec2u")) : "f16" === n$1 ? new Me(new Float32Array(t$1), e$1.getTypeInfo("vec2h")) : (console.error(`getSubData: Unknown format ${n$1}`), null) : 3 === s$1 ? "f32" === n$1 ? new Me(new Float32Array(t$1), e$1.getTypeInfo("vec3f")) : "i32" === n$1 || "bool" === n$1 ? new Me(new Int32Array(t$1), e$1.getTypeInfo("vec3i")) : "u32" === n$1 ? new Me(new Uint32Array(t$1), e$1.getTypeInfo("vec3u")) : "f16" === n$1 ? new Me(new Float32Array(t$1), e$1.getTypeInfo("vec3h")) : (console.error(`getSubData: Unknown format ${n$1}`), null) : 4 === s$1 ? "f32" === n$1 ? new Me(new Float32Array(t$1), e$1.getTypeInfo("vec4f")) : "i32" === n$1 || "bool" === n$1 ? new Me(new Int32Array(t$1), e$1.getTypeInfo("vec4i")) : "u32" === n$1 ? new Me(new Uint32Array(t$1), e$1.getTypeInfo("vec4u")) : "f16" === n$1 ? new Me(new Float32Array(t$1), e$1.getTypeInfo("vec4h")) : (console.error(`getSubData: Unknown format ${n$1}`), null) : (console.error(`getSubData: Invalid vector size ${t$1.length}`), null);
}
var Me = class Me extends Ne {
	constructor(e$1, t$1, n$1 = null) {
		if (super(t$1, n$1), e$1 instanceof Float32Array || e$1 instanceof Uint32Array || e$1 instanceof Int32Array) this.data = e$1;
		else {
			const t$2 = this.typeInfo.name;
			"vec2f" === t$2 || "vec3f" === t$2 || "vec4f" === t$2 ? this.data = new Float32Array(e$1) : "vec2i" === t$2 || "vec3i" === t$2 || "vec4i" === t$2 ? this.data = new Int32Array(e$1) : "vec2u" === t$2 || "vec3u" === t$2 || "vec4u" === t$2 ? this.data = new Uint32Array(e$1) : "vec2h" === t$2 || "vec3h" === t$2 || "vec4h" === t$2 ? this.data = new Float32Array(e$1) : "vec2b" === t$2 || "vec3b" === t$2 || "vec4b" === t$2 ? this.data = new Int32Array(e$1) : "vec2" === t$2 || "vec3" === t$2 || "vec4" === t$2 ? this.data = new Float32Array(e$1) : console.error(`VectorData: Invalid type ${t$2}`);
		}
	}
	clone() {
		if (this.data instanceof Float32Array) return new Me(new Float32Array(this.data), this.typeInfo, null);
		if (this.data instanceof Int32Array) return new Me(new Int32Array(this.data), this.typeInfo, null);
		if (this.data instanceof Uint32Array) return new Me(new Uint32Array(this.data), this.typeInfo, null);
		throw "VectorData: Invalid data type";
	}
	setDataValue(e$1, t$1, n$1, s$1) {
		n$1 instanceof pe ? console.error("TODO: Set vector postfix") : t$1 instanceof Me ? this.data = t$1.data : console.error("SetDataValue: Invalid value", t$1);
	}
	getSubData(e$1, t$1, n$1) {
		if (null === t$1) return this;
		let s$1 = e$1.getTypeInfo("f32");
		if (this.typeInfo instanceof a) s$1 = this.typeInfo.format || s$1;
		else {
			const t$2 = this.typeInfo.name;
			"vec2f" === t$2 || "vec3f" === t$2 || "vec4f" === t$2 ? s$1 = e$1.getTypeInfo("f32") : "vec2i" === t$2 || "vec3i" === t$2 || "vec4i" === t$2 ? s$1 = e$1.getTypeInfo("i32") : "vec2b" === t$2 || "vec3b" === t$2 || "vec4b" === t$2 ? s$1 = e$1.getTypeInfo("bool") : "vec2u" === t$2 || "vec3u" === t$2 || "vec4u" === t$2 ? s$1 = e$1.getTypeInfo("u32") : "vec2h" === t$2 || "vec3h" === t$2 || "vec4h" === t$2 ? s$1 = e$1.getTypeInfo("f16") : console.error(`GetSubData: Unknown type ${t$2}`);
		}
		let r$1 = this;
		for (; null !== t$1 && null !== r$1;) {
			if (t$1 instanceof ve) {
				const a$1 = t$1.index;
				let i$1 = -1;
				if (a$1 instanceof xe) {
					if (!(a$1.value instanceof Be)) return console.error(`GetSubData: Invalid array index ${a$1.value}`), null;
					i$1 = a$1.value.value;
				} else {
					const t$2 = e$1.evalExpression(a$1, n$1);
					if (!(t$2 instanceof Be)) return console.error("GetSubData: Unknown index type", a$1), null;
					i$1 = t$2.value;
				}
				if (i$1 < 0 || i$1 >= r$1.data.length) return console.error("GetSubData: Index out of range", i$1), null;
				if (r$1.data instanceof Float32Array) return new Be(new Float32Array(r$1.data.buffer, r$1.data.byteOffset + 4 * i$1, 1), s$1);
				if (r$1.data instanceof Int32Array) return new Be(new Int32Array(r$1.data.buffer, r$1.data.byteOffset + 4 * i$1, 1), s$1);
				if (r$1.data instanceof Uint32Array) return new Be(new Uint32Array(r$1.data.buffer, r$1.data.byteOffset + 4 * i$1, 1), s$1);
				throw "GetSubData: Invalid data type";
			}
			if (!(t$1 instanceof pe)) return console.error("GetSubData: Unknown postfix", t$1), null;
			{
				const n$2 = t$1.value.toLowerCase();
				if (1 === n$2.length) {
					let e$2 = 0;
					if ("x" === n$2 || "r" === n$2) e$2 = 0;
					else if ("y" === n$2 || "g" === n$2) e$2 = 1;
					else if ("z" === n$2 || "b" === n$2) e$2 = 2;
					else {
						if ("w" !== n$2 && "a" !== n$2) return console.error(`GetSubData: Unknown member ${n$2}`), null;
						e$2 = 3;
					}
					if (this.data instanceof Float32Array) return new Be(new Float32Array(this.data.buffer, this.data.byteOffset + 4 * e$2, 1), s$1, this);
					if (this.data instanceof Int32Array) return new Be(new Int32Array(this.data.buffer, this.data.byteOffset + 4 * e$2, 1), s$1, this);
					if (this.data instanceof Uint32Array) return new Be(new Uint32Array(this.data.buffer, this.data.byteOffset + 4 * e$2, 1), s$1, this);
				}
				const a$1 = [];
				for (const e$2 of n$2) "x" === e$2 || "r" === e$2 ? a$1.push(this.data[0]) : "y" === e$2 || "g" === e$2 ? a$1.push(this.data[1]) : "z" === e$2 || "b" === e$2 ? a$1.push(this.data[2]) : "w" === e$2 || "a" === e$2 ? a$1.push(this.data[3]) : console.error(`GetDataValue: Unknown member ${e$2}`);
				r$1 = Fe(e$1, a$1, s$1.name);
			}
			t$1 = t$1.postfix;
		}
		return r$1;
	}
	toString() {
		let e$1 = `${this.data[0]}`;
		for (let t$1 = 1; t$1 < this.data.length; ++t$1) e$1 += `, ${this.data[t$1]}`;
		return e$1;
	}
};
var Ue = class Ue extends Ne {
	constructor(e$1, t$1, n$1 = null) {
		super(t$1, n$1), e$1 instanceof Float32Array ? this.data = e$1 : this.data = new Float32Array(e$1);
	}
	clone() {
		return new Ue(new Float32Array(this.data), this.typeInfo, null);
	}
	setDataValue(e$1, t$1, n$1, s$1) {
		n$1 instanceof pe ? console.error("TODO: Set matrix postfix") : t$1 instanceof Ue ? this.data = t$1.data : console.error("SetDataValue: Invalid value", t$1);
	}
	getSubData(e$1, t$1, n$1) {
		if (null === t$1) return this;
		const s$1 = this.typeInfo.name;
		if (e$1.getTypeInfo("f32"), this.typeInfo instanceof a) this.typeInfo.format;
		else if (s$1.endsWith("f")) e$1.getTypeInfo("f32");
		else if (s$1.endsWith("i")) e$1.getTypeInfo("i32");
		else if (s$1.endsWith("u")) e$1.getTypeInfo("u32");
		else {
			if (!s$1.endsWith("h")) return console.error(`GetDataValue: Unknown type ${s$1}`), null;
			e$1.getTypeInfo("f16");
		}
		if (t$1 instanceof ve) {
			const r$1 = t$1.index;
			let a$1 = -1;
			if (r$1 instanceof xe) {
				if (!(r$1.value instanceof Be)) return console.error(`GetDataValue: Invalid array index ${r$1.value}`), null;
				a$1 = r$1.value.value;
			} else {
				const t$2 = e$1.evalExpression(r$1, n$1);
				if (!(t$2 instanceof Be)) return console.error("GetDataValue: Unknown index type", r$1), null;
				a$1 = t$2.value;
			}
			if (a$1 < 0 || a$1 >= this.data.length) return console.error("GetDataValue: Index out of range", a$1), null;
			const i$1 = s$1.endsWith("h") ? "h" : "f";
			let o$1;
			if ("mat2x2" === s$1 || "mat2x2f" === s$1 || "mat2x2h" === s$1 || "mat3x2" === s$1 || "mat3x2f" === s$1 || "mat3x2h" === s$1 || "mat4x2" === s$1 || "mat4x2f" === s$1 || "mat4x2h" === s$1) o$1 = new Me(new Float32Array(this.data.buffer, this.data.byteOffset + 2 * a$1 * 4, 2), e$1.getTypeInfo(`vec2${i$1}`));
			else if ("mat2x3" === s$1 || "mat2x3f" === s$1 || "mat2x3h" === s$1 || "mat3x3" === s$1 || "mat3x3f" === s$1 || "mat3x3h" === s$1 || "mat4x3" === s$1 || "mat4x3f" === s$1 || "mat4x3h" === s$1) o$1 = new Me(new Float32Array(this.data.buffer, this.data.byteOffset + 3 * a$1 * 4, 3), e$1.getTypeInfo(`vec3${i$1}`));
			else {
				if ("mat2x4" !== s$1 && "mat2x4f" !== s$1 && "mat2x4h" !== s$1 && "mat3x4" !== s$1 && "mat3x4f" !== s$1 && "mat3x4h" !== s$1 && "mat4x4" !== s$1 && "mat4x4f" !== s$1 && "mat4x4h" !== s$1) return console.error(`GetDataValue: Unknown type ${s$1}`), null;
				o$1 = new Me(new Float32Array(this.data.buffer, this.data.byteOffset + 4 * a$1 * 4, 4), e$1.getTypeInfo(`vec4${i$1}`));
			}
			return t$1.postfix ? o$1.getSubData(e$1, t$1.postfix, n$1) : o$1;
		}
		return console.error("GetDataValue: Invalid postfix", t$1), null;
	}
	toString() {
		let e$1 = `${this.data[0]}`;
		for (let t$1 = 1; t$1 < this.data.length; ++t$1) e$1 += `, ${this.data[t$1]}`;
		return e$1;
	}
};
var Pe = class Pe extends Ne {
	constructor(e$1, t$1, n$1 = 0, s$1 = null) {
		super(t$1, s$1), this.buffer = e$1 instanceof ArrayBuffer ? e$1 : e$1.buffer, this.offset = n$1;
	}
	clone() {
		return new Pe(new Uint8Array(new Uint8Array(this.buffer, this.offset, this.typeInfo.size)).buffer, this.typeInfo, 0, null);
	}
	setDataValue(t$1, r$1, a$1, i$1) {
		if (null === r$1) return void console.log("setDataValue: NULL data.");
		let o$1 = this.offset, c$1 = this.typeInfo;
		for (; a$1;) {
			if (a$1 instanceof ve) if (c$1 instanceof s) {
				const e$1 = a$1.index;
				if (e$1 instanceof xe) {
					if (!(e$1.value instanceof Be)) return void console.error(`SetDataValue: Invalid index type ${e$1.value}`);
					o$1 += e$1.value.value * c$1.stride;
				} else {
					const n$1 = t$1.evalExpression(e$1, i$1);
					if (!(n$1 instanceof Be)) return void console.error("SetDataValue: Unknown index type", e$1);
					o$1 += n$1.value * c$1.stride;
				}
				c$1 = c$1.format;
			} else console.error(`SetDataValue: Type ${c$1.getTypeName()} is not an array`);
			else {
				if (!(a$1 instanceof pe)) return void console.error("SetDataValue: Unknown postfix type", a$1);
				{
					const t$2 = a$1.value;
					if (c$1 instanceof n) {
						let e$1 = !1;
						for (const n$1 of c$1.members) if (n$1.name === t$2) {
							o$1 += n$1.offset, c$1 = n$1.type, e$1 = !0;
							break;
						}
						if (!e$1) return void console.error(`SetDataValue: Member ${t$2} not found`);
					} else if (c$1 instanceof e) {
						const e$1 = c$1.getTypeName();
						let n$1 = 0;
						if ("x" === t$2 || "r" === t$2) n$1 = 0;
						else if ("y" === t$2 || "g" === t$2) n$1 = 1;
						else if ("z" === t$2 || "b" === t$2) n$1 = 2;
						else {
							if ("w" !== t$2 && "a" !== t$2) return void console.error(`SetDataValue: Unknown member ${t$2}`);
							n$1 = 3;
						}
						if (!(r$1 instanceof Be)) return void console.error("SetDataValue: Invalid value", r$1);
						const s$1 = r$1.value;
						"vec2f" === e$1 ? new Float32Array(this.buffer, o$1, 2)[n$1] = s$1 : "vec3f" === e$1 ? new Float32Array(this.buffer, o$1, 3)[n$1] = s$1 : "vec4f" === e$1 ? new Float32Array(this.buffer, o$1, 4)[n$1] = s$1 : "vec2i" === e$1 ? new Int32Array(this.buffer, o$1, 2)[n$1] = s$1 : "vec3i" === e$1 ? new Int32Array(this.buffer, o$1, 3)[n$1] = s$1 : "vec4i" === e$1 ? new Int32Array(this.buffer, o$1, 4)[n$1] = s$1 : "vec2u" === e$1 ? new Uint32Array(this.buffer, o$1, 2)[n$1] = s$1 : "vec3u" === e$1 ? new Uint32Array(this.buffer, o$1, 3)[n$1] = s$1 : "vec4u" === e$1 ? new Uint32Array(this.buffer, o$1, 4)[n$1] = s$1 : console.error(`SetDataValue: Type ${e$1} is not a struct`);
						return;
					}
				}
			}
			a$1 = a$1.postfix;
		}
		this.setData(t$1, r$1, c$1, o$1, i$1);
	}
	setData(e$1, t$1, n$1, s$1, r$1) {
		const a$1 = n$1.getTypeName();
		if ("f32" !== a$1 && "f16" !== a$1) if ("i32" !== a$1 && "atomic<i32>" !== a$1 && "x32" !== a$1) if ("u32" !== a$1 && "atomic<u32>" !== a$1) if ("bool" !== a$1) {
			if ("vec2f" === a$1 || "vec2h" === a$1) {
				const e$2 = new Float32Array(this.buffer, s$1, 2);
				t$1 instanceof Me ? (e$2[0] = t$1.data[0], e$2[1] = t$1.data[1]) : (e$2[0] = t$1[0], e$2[1] = t$1[1]);
				return;
			}
			if ("vec3f" === a$1 || "vec3h" === a$1) {
				const e$2 = new Float32Array(this.buffer, s$1, 3);
				t$1 instanceof Me ? (e$2[0] = t$1.data[0], e$2[1] = t$1.data[1], e$2[2] = t$1.data[2]) : (e$2[0] = t$1[0], e$2[1] = t$1[1], e$2[2] = t$1[2]);
				return;
			}
			if ("vec4f" === a$1 || "vec4h" === a$1) {
				const e$2 = new Float32Array(this.buffer, s$1, 4);
				t$1 instanceof Me ? (e$2[0] = t$1.data[0], e$2[1] = t$1.data[1], e$2[2] = t$1.data[2], e$2[3] = t$1.data[3]) : (e$2[0] = t$1[0], e$2[1] = t$1[1], e$2[2] = t$1[2], e$2[3] = t$1[3]);
				return;
			}
			if ("vec2i" === a$1) {
				const e$2 = new Int32Array(this.buffer, s$1, 2);
				t$1 instanceof Me ? (e$2[0] = t$1.data[0], e$2[1] = t$1.data[1]) : (e$2[0] = t$1[0], e$2[1] = t$1[1]);
				return;
			}
			if ("vec3i" === a$1) {
				const e$2 = new Int32Array(this.buffer, s$1, 3);
				t$1 instanceof Me ? (e$2[0] = t$1.data[0], e$2[1] = t$1.data[1], e$2[2] = t$1.data[2]) : (e$2[0] = t$1[0], e$2[1] = t$1[1], e$2[2] = t$1[2]);
				return;
			}
			if ("vec4i" === a$1) {
				const e$2 = new Int32Array(this.buffer, s$1, 4);
				t$1 instanceof Me ? (e$2[0] = t$1.data[0], e$2[1] = t$1.data[1], e$2[2] = t$1.data[2], e$2[3] = t$1.data[3]) : (e$2[0] = t$1[0], e$2[1] = t$1[1], e$2[2] = t$1[2], e$2[3] = t$1[3]);
				return;
			}
			if ("vec2u" === a$1) {
				const e$2 = new Uint32Array(this.buffer, s$1, 2);
				t$1 instanceof Me ? (e$2[0] = t$1.data[0], e$2[1] = t$1.data[1]) : (e$2[0] = t$1[0], e$2[1] = t$1[1]);
				return;
			}
			if ("vec3u" === a$1) {
				const e$2 = new Uint32Array(this.buffer, s$1, 3);
				t$1 instanceof Me ? (e$2[0] = t$1.data[0], e$2[1] = t$1.data[1], e$2[2] = t$1.data[2]) : (e$2[0] = t$1[0], e$2[1] = t$1[1], e$2[2] = t$1[2]);
				return;
			}
			if ("vec4u" === a$1) {
				const e$2 = new Uint32Array(this.buffer, s$1, 4);
				t$1 instanceof Me ? (e$2[0] = t$1.data[0], e$2[1] = t$1.data[1], e$2[2] = t$1.data[2], e$2[3] = t$1.data[3]) : (e$2[0] = t$1[0], e$2[1] = t$1[1], e$2[2] = t$1[2], e$2[3] = t$1[3]);
				return;
			}
			if ("vec2b" === a$1) {
				const e$2 = new Uint32Array(this.buffer, s$1, 2);
				t$1 instanceof Me ? (e$2[0] = t$1.data[0], e$2[1] = t$1.data[1]) : (e$2[0] = t$1[0], e$2[1] = t$1[1]);
				return;
			}
			if ("vec3b" === a$1) {
				const e$2 = new Uint32Array(this.buffer, s$1, 3);
				t$1 instanceof Me ? (e$2[0] = t$1.data[0], e$2[1] = t$1.data[1], e$2[2] = t$1.data[2]) : (e$2[0] = t$1[0], e$2[1] = t$1[1], e$2[2] = t$1[2]);
				return;
			}
			if ("vec4b" === a$1) {
				const e$2 = new Uint32Array(this.buffer, s$1, 4);
				t$1 instanceof Me ? (e$2[0] = t$1.data[0], e$2[1] = t$1.data[1], e$2[2] = t$1.data[2], e$2[3] = t$1.data[3]) : (e$2[0] = t$1[0], e$2[1] = t$1[1], e$2[2] = t$1[2], e$2[3] = t$1[3]);
				return;
			}
			if ("mat2x2f" === a$1 || "mat2x2h" === a$1) {
				const e$2 = new Float32Array(this.buffer, s$1, 4);
				t$1 instanceof Ue ? (e$2[0] = t$1.data[0], e$2[1] = t$1.data[1], e$2[2] = t$1.data[2], e$2[3] = t$1.data[3]) : (e$2[0] = t$1[0], e$2[1] = t$1[1], e$2[2] = t$1[2], e$2[3] = t$1[3]);
				return;
			}
			if ("mat2x3f" === a$1 || "mat2x3h" === a$1) {
				const e$2 = new Float32Array(this.buffer, s$1, 6);
				t$1 instanceof Ue ? (e$2[0] = t$1.data[0], e$2[1] = t$1.data[1], e$2[2] = t$1.data[2], e$2[3] = t$1.data[3], e$2[4] = t$1.data[4], e$2[5] = t$1.data[5]) : (e$2[0] = t$1[0], e$2[1] = t$1[1], e$2[2] = t$1[2], e$2[3] = t$1[3], e$2[4] = t$1[4], e$2[5] = t$1[5]);
				return;
			}
			if ("mat2x4f" === a$1 || "mat2x4h" === a$1) {
				const e$2 = new Float32Array(this.buffer, s$1, 8);
				t$1 instanceof Ue ? (e$2[0] = t$1.data[0], e$2[1] = t$1.data[1], e$2[2] = t$1.data[2], e$2[3] = t$1.data[3], e$2[4] = t$1.data[4], e$2[5] = t$1.data[5], e$2[6] = t$1.data[6], e$2[7] = t$1.data[7]) : (e$2[0] = t$1[0], e$2[1] = t$1[1], e$2[2] = t$1[2], e$2[3] = t$1[3], e$2[4] = t$1[4], e$2[5] = t$1[5], e$2[6] = t$1[6], e$2[7] = t$1[7]);
				return;
			}
			if ("mat3x2f" === a$1 || "mat3x2h" === a$1) {
				const e$2 = new Float32Array(this.buffer, s$1, 6);
				t$1 instanceof Ue ? (e$2[0] = t$1.data[0], e$2[1] = t$1.data[1], e$2[2] = t$1.data[2], e$2[3] = t$1.data[3], e$2[4] = t$1.data[4], e$2[5] = t$1.data[5]) : (e$2[0] = t$1[0], e$2[1] = t$1[1], e$2[2] = t$1[2], e$2[3] = t$1[3], e$2[4] = t$1[4], e$2[5] = t$1[5]);
				return;
			}
			if ("mat3x3f" === a$1 || "mat3x3h" === a$1) {
				const e$2 = new Float32Array(this.buffer, s$1, 9);
				t$1 instanceof Ue ? (e$2[0] = t$1.data[0], e$2[1] = t$1.data[1], e$2[2] = t$1.data[2], e$2[3] = t$1.data[3], e$2[4] = t$1.data[4], e$2[5] = t$1.data[5], e$2[6] = t$1.data[6], e$2[7] = t$1.data[7], e$2[8] = t$1.data[8]) : (e$2[0] = t$1[0], e$2[1] = t$1[1], e$2[2] = t$1[2], e$2[3] = t$1[3], e$2[4] = t$1[4], e$2[5] = t$1[5], e$2[6] = t$1[6], e$2[7] = t$1[7], e$2[8] = t$1[8]);
				return;
			}
			if ("mat3x4f" === a$1 || "mat3x4h" === a$1) {
				const e$2 = new Float32Array(this.buffer, s$1, 12);
				t$1 instanceof Ue ? (e$2[0] = t$1.data[0], e$2[1] = t$1.data[1], e$2[2] = t$1.data[2], e$2[3] = t$1.data[3], e$2[4] = t$1.data[4], e$2[5] = t$1.data[5], e$2[6] = t$1.data[6], e$2[7] = t$1.data[7], e$2[8] = t$1.data[8], e$2[9] = t$1.data[9], e$2[10] = t$1.data[10], e$2[11] = t$1.data[11]) : (e$2[0] = t$1[0], e$2[1] = t$1[1], e$2[2] = t$1[2], e$2[3] = t$1[3], e$2[4] = t$1[4], e$2[5] = t$1[5], e$2[6] = t$1[6], e$2[7] = t$1[7], e$2[8] = t$1[8], e$2[9] = t$1[9], e$2[10] = t$1[10], e$2[11] = t$1[11]);
				return;
			}
			if ("mat4x2f" === a$1 || "mat4x2h" === a$1) {
				const e$2 = new Float32Array(this.buffer, s$1, 8);
				t$1 instanceof Ue ? (e$2[0] = t$1.data[0], e$2[1] = t$1.data[1], e$2[2] = t$1.data[2], e$2[3] = t$1.data[3], e$2[4] = t$1.data[4], e$2[5] = t$1.data[5], e$2[6] = t$1.data[6], e$2[7] = t$1.data[7]) : (e$2[0] = t$1[0], e$2[1] = t$1[1], e$2[2] = t$1[2], e$2[3] = t$1[3], e$2[4] = t$1[4], e$2[5] = t$1[5], e$2[6] = t$1[6], e$2[7] = t$1[7]);
				return;
			}
			if ("mat4x3f" === a$1 || "mat4x3h" === a$1) {
				const e$2 = new Float32Array(this.buffer, s$1, 12);
				t$1 instanceof Ue ? (e$2[0] = t$1.data[0], e$2[1] = t$1.data[1], e$2[2] = t$1.data[2], e$2[3] = t$1.data[3], e$2[4] = t$1.data[4], e$2[5] = t$1.data[5], e$2[6] = t$1.data[6], e$2[7] = t$1.data[7], e$2[8] = t$1.data[8], e$2[9] = t$1.data[9], e$2[10] = t$1.data[10], e$2[11] = t$1.data[11]) : (e$2[0] = t$1[0], e$2[1] = t$1[1], e$2[2] = t$1[2], e$2[3] = t$1[3], e$2[4] = t$1[4], e$2[5] = t$1[5], e$2[6] = t$1[6], e$2[7] = t$1[7], e$2[8] = t$1[8], e$2[9] = t$1[9], e$2[10] = t$1[10], e$2[11] = t$1[11]);
				return;
			}
			if ("mat4x4f" === a$1 || "mat4x4h" === a$1) {
				const e$2 = new Float32Array(this.buffer, s$1, 16);
				t$1 instanceof Ue ? (e$2[0] = t$1.data[0], e$2[1] = t$1.data[1], e$2[2] = t$1.data[2], e$2[3] = t$1.data[3], e$2[4] = t$1.data[4], e$2[5] = t$1.data[5], e$2[6] = t$1.data[6], e$2[7] = t$1.data[7], e$2[8] = t$1.data[8], e$2[9] = t$1.data[9], e$2[10] = t$1.data[10], e$2[11] = t$1.data[11], e$2[12] = t$1.data[12], e$2[13] = t$1.data[13], e$2[14] = t$1.data[14], e$2[15] = t$1.data[15]) : (e$2[0] = t$1[0], e$2[1] = t$1[1], e$2[2] = t$1[2], e$2[3] = t$1[3], e$2[4] = t$1[4], e$2[5] = t$1[5], e$2[6] = t$1[6], e$2[7] = t$1[7], e$2[8] = t$1[8], e$2[9] = t$1[9], e$2[10] = t$1[10], e$2[11] = t$1[11], e$2[12] = t$1[12], e$2[13] = t$1[13], e$2[14] = t$1[14], e$2[15] = t$1[15]);
				return;
			}
			if (t$1 instanceof Pe) {
				if (n$1 === t$1.typeInfo) {
					new Uint8Array(this.buffer, s$1, t$1.buffer.byteLength).set(new Uint8Array(t$1.buffer));
					return;
				}
				console.error("SetDataValue: Type mismatch", a$1, t$1.typeInfo.getTypeName());
			} else console.error(`SetData: Unknown type ${a$1}`);
		} else t$1 instanceof Be && (new Int32Array(this.buffer, s$1, 1)[0] = t$1.value);
		else t$1 instanceof Be && (new Uint32Array(this.buffer, s$1, 1)[0] = t$1.value);
		else t$1 instanceof Be && (new Int32Array(this.buffer, s$1, 1)[0] = t$1.value);
		else t$1 instanceof Be && (new Float32Array(this.buffer, s$1, 1)[0] = t$1.value);
	}
	getSubData(t$1, r$1, i$1) {
		var o$1, c$1, l$1;
		if (null === r$1) return this;
		let u$1 = this.offset, h$1 = this.typeInfo;
		for (; r$1;) {
			if (r$1 instanceof ve) {
				const e$1 = r$1.index, n$1 = e$1 instanceof fe ? t$1.evalExpression(e$1, i$1) : e$1;
				let a$1 = 0;
				if (n$1 instanceof Be ? a$1 = n$1.value : "number" == typeof n$1 ? a$1 = n$1 : console.error("GetDataValue: Invalid index type", e$1), h$1 instanceof s) u$1 += a$1 * h$1.stride, h$1 = h$1.format;
				else {
					const e$2 = h$1.getTypeName();
					"mat4x4" === e$2 || "mat4x4f" === e$2 || "mat4x4h" === e$2 ? (u$1 += 16 * a$1, h$1 = t$1.getTypeInfo("vec4f")) : console.error(`getDataValue: Type ${h$1.getTypeName()} is not an array`);
				}
			} else {
				if (!(r$1 instanceof pe)) return console.error("GetDataValue: Unknown postfix type", r$1), null;
				{
					const s$1 = r$1.value;
					if (h$1 instanceof n) {
						let e$1 = !1;
						for (const t$2 of h$1.members) if (t$2.name === s$1) {
							u$1 += t$2.offset, h$1 = t$2.type, e$1 = !0;
							break;
						}
						if (!e$1) return console.error(`GetDataValue: Member ${s$1} not found`), null;
					} else if (h$1 instanceof e) {
						const e$1 = h$1.getTypeName();
						if ("vec2f" === e$1 || "vec3f" === e$1 || "vec4f" === e$1 || "vec2i" === e$1 || "vec3i" === e$1 || "vec4i" === e$1 || "vec2u" === e$1 || "vec3u" === e$1 || "vec4u" === e$1 || "vec2b" === e$1 || "vec3b" === e$1 || "vec4b" === e$1 || "vec2h" === e$1 || "vec3h" === e$1 || "vec4h" === e$1 || "vec2" === e$1 || "vec3" === e$1 || "vec4" === e$1) {
							if (s$1.length > 0 && s$1.length < 5) {
								let n$1 = "f";
								const r$2 = [];
								for (let a$1 = 0; a$1 < s$1.length; ++a$1) {
									const i$2 = s$1[a$1].toLowerCase();
									let o$2 = 0;
									if ("x" === i$2 || "r" === i$2) o$2 = 0;
									else if ("y" === i$2 || "g" === i$2) o$2 = 1;
									else if ("z" === i$2 || "b" === i$2) o$2 = 2;
									else {
										if ("w" !== i$2 && "a" !== i$2) return console.error(`Unknown member ${s$1}`), null;
										o$2 = 3;
									}
									if (1 === s$1.length) {
										if (e$1.endsWith("f")) return this.buffer.byteLength < u$1 + 4 * o$2 + 4 ? (console.log("Insufficient buffer data"), null) : new Be(new Float32Array(this.buffer, u$1 + 4 * o$2, 1), t$1.getTypeInfo("f32"), this);
										if (e$1.endsWith("h")) return new Be(new Float32Array(this.buffer, u$1 + 4 * o$2, 1), t$1.getTypeInfo("f16"), this);
										if (e$1.endsWith("i")) return new Be(new Int32Array(this.buffer, u$1 + 4 * o$2, 1), t$1.getTypeInfo("i32"), this);
										if (e$1.endsWith("b")) return new Be(new Int32Array(this.buffer, u$1 + 4 * o$2, 1), t$1.getTypeInfo("bool"), this);
										if (e$1.endsWith("u")) return new Be(new Uint32Array(this.buffer, u$1 + 4 * o$2, 1), t$1.getTypeInfo("i32"), this);
									}
									if ("vec2f" === e$1) r$2.push(new Float32Array(this.buffer, u$1, 2)[o$2]);
									else if ("vec3f" === e$1) {
										if (u$1 + 12 >= this.buffer.byteLength) return console.log("Insufficient buffer data"), null;
										const e$2 = new Float32Array(this.buffer, u$1, 3);
										r$2.push(e$2[o$2]);
									} else if ("vec4f" === e$1) r$2.push(new Float32Array(this.buffer, u$1, 4)[o$2]);
									else if ("vec2i" === e$1) n$1 = "i", r$2.push(new Int32Array(this.buffer, u$1, 2)[o$2]);
									else if ("vec3i" === e$1) n$1 = "i", r$2.push(new Int32Array(this.buffer, u$1, 3)[o$2]);
									else if ("vec4i" === e$1) n$1 = "i", r$2.push(new Int32Array(this.buffer, u$1, 4)[o$2]);
									else if ("vec2u" === e$1) {
										n$1 = "u";
										const e$2 = new Uint32Array(this.buffer, u$1, 2);
										r$2.push(e$2[o$2]);
									} else "vec3u" === e$1 ? (n$1 = "u", r$2.push(new Uint32Array(this.buffer, u$1, 3)[o$2])) : "vec4u" === e$1 && (n$1 = "u", r$2.push(new Uint32Array(this.buffer, u$1, 4)[o$2]));
								}
								return 2 === r$2.length ? h$1 = t$1.getTypeInfo(`vec2${n$1}`) : 3 === r$2.length ? h$1 = t$1.getTypeInfo(`vec3${n$1}`) : 4 === r$2.length ? h$1 = t$1.getTypeInfo(`vec4${n$1}`) : console.error(`GetDataValue: Invalid vector length ${r$2.length}`), new Me(r$2, h$1, null);
							}
							return console.error(`GetDataValue: Unknown member ${s$1}`), null;
						}
						return console.error(`GetDataValue: Type ${e$1} is not a struct`), null;
					}
				}
			}
			r$1 = r$1.postfix;
		}
		const f$1 = h$1.getTypeName();
		return "f32" === f$1 ? new Be(new Float32Array(this.buffer, u$1, 1), h$1, this) : "i32" === f$1 ? new Be(new Int32Array(this.buffer, u$1, 1), h$1, this) : "u32" === f$1 ? new Be(new Uint32Array(this.buffer, u$1, 1), h$1, this) : "vec2f" === f$1 ? new Me(new Float32Array(this.buffer, u$1, 2), h$1, this) : "vec3f" === f$1 ? new Me(new Float32Array(this.buffer, u$1, 3), h$1, this) : "vec4f" === f$1 ? new Me(new Float32Array(this.buffer, u$1, 4), h$1, this) : "vec2i" === f$1 ? new Me(new Int32Array(this.buffer, u$1, 2), h$1, this) : "vec3i" === f$1 ? new Me(new Int32Array(this.buffer, u$1, 3), h$1, this) : "vec4i" === f$1 ? new Me(new Int32Array(this.buffer, u$1, 4), h$1, this) : "vec2u" === f$1 ? new Me(new Uint32Array(this.buffer, u$1, 2), h$1, this) : "vec3u" === f$1 ? new Me(new Uint32Array(this.buffer, u$1, 3), h$1, this) : "vec4u" === f$1 ? new Me(new Uint32Array(this.buffer, u$1, 4), h$1, this) : h$1 instanceof a && "atomic" === h$1.name ? "u32" === (null === (o$1 = h$1.format) || void 0 === o$1 ? void 0 : o$1.name) ? new Be(new Uint32Array(this.buffer, u$1, 1)[0], h$1.format, this) : "i32" === (null === (c$1 = h$1.format) || void 0 === c$1 ? void 0 : c$1.name) ? new Be(new Int32Array(this.buffer, u$1, 1)[0], h$1.format, this) : (console.error(`GetDataValue: Invalid atomic format ${null === (l$1 = h$1.format) || void 0 === l$1 ? void 0 : l$1.name}`), null) : new Pe(this.buffer, h$1, u$1, this);
	}
	toString() {
		let e$1 = "";
		if (this.typeInfo instanceof s) if ("f32" === this.typeInfo.format.name) {
			const t$1 = new Float32Array(this.buffer, this.offset);
			e$1 = `[${t$1[0]}`;
			for (let n$1 = 1; n$1 < t$1.length; ++n$1) e$1 += `, ${t$1[n$1]}`;
		} else if ("i32" === this.typeInfo.format.name) {
			const t$1 = new Int32Array(this.buffer, this.offset);
			e$1 = `[${t$1[0]}`;
			for (let n$1 = 1; n$1 < t$1.length; ++n$1) e$1 += `, ${t$1[n$1]}`;
		} else if ("u32" === this.typeInfo.format.name) {
			const t$1 = new Uint32Array(this.buffer, this.offset);
			e$1 = `[${t$1[0]}`;
			for (let n$1 = 1; n$1 < t$1.length; ++n$1) e$1 += `, ${t$1[n$1]}`;
		} else if ("vec2f" === this.typeInfo.format.name) {
			const t$1 = new Float32Array(this.buffer, this.offset);
			e$1 = `[${t$1[0]}, ${t$1[1]}]`;
			for (let n$1 = 1; n$1 < t$1.length / 2; ++n$1) e$1 += `, [${t$1[2 * n$1]}, ${t$1[2 * n$1 + 1]}]`;
		} else if ("vec3f" === this.typeInfo.format.name) {
			const t$1 = new Float32Array(this.buffer, this.offset);
			e$1 = `[${t$1[0]}, ${t$1[1]}, ${t$1[2]}]`;
			for (let n$1 = 4; n$1 < t$1.length; n$1 += 4) e$1 += `, [${t$1[n$1]}, ${t$1[n$1 + 1]}, ${t$1[n$1 + 2]}]`;
		} else if ("vec4f" === this.typeInfo.format.name) {
			const t$1 = new Float32Array(this.buffer, this.offset);
			e$1 = `[${t$1[0]}, ${t$1[1]}, ${t$1[2]}, ${t$1[3]}]`;
			for (let n$1 = 4; n$1 < t$1.length; n$1 += 4) e$1 += `, [${t$1[n$1]}, ${t$1[n$1 + 1]}, ${t$1[n$1 + 2]}, ${t$1[n$1 + 3]}]`;
		} else e$1 = "[...]";
		else this.typeInfo instanceof n ? e$1 += "{...}" : e$1 = "[...]";
		return e$1;
	}
};
var We = class We extends Ne {
	constructor(e$1, t$1, n$1, s$1) {
		super(t$1, null), this.data = e$1, this.descriptor = n$1, this.view = s$1;
	}
	clone() {
		return new We(this.data, this.typeInfo, this.descriptor, this.view);
	}
	get width() {
		var e$1, t$1;
		const n$1 = this.descriptor.size;
		return n$1 instanceof Array && n$1.length > 0 ? null !== (e$1 = n$1[0]) && void 0 !== e$1 ? e$1 : 0 : n$1 instanceof Object && null !== (t$1 = n$1.width) && void 0 !== t$1 ? t$1 : 0;
	}
	get height() {
		var e$1, t$1;
		const n$1 = this.descriptor.size;
		return n$1 instanceof Array && n$1.length > 1 ? null !== (e$1 = n$1[1]) && void 0 !== e$1 ? e$1 : 0 : n$1 instanceof Object && null !== (t$1 = n$1.height) && void 0 !== t$1 ? t$1 : 0;
	}
	get depthOrArrayLayers() {
		var e$1, t$1;
		const n$1 = this.descriptor.size;
		return n$1 instanceof Array && n$1.length > 2 ? null !== (e$1 = n$1[2]) && void 0 !== e$1 ? e$1 : 0 : n$1 instanceof Object && null !== (t$1 = n$1.depthOrArrayLayers) && void 0 !== t$1 ? t$1 : 0;
	}
	get format() {
		var e$1;
		return this.descriptor && null !== (e$1 = this.descriptor.format) && void 0 !== e$1 ? e$1 : "rgba8unorm";
	}
	get sampleCount() {
		var e$1;
		return this.descriptor && null !== (e$1 = this.descriptor.sampleCount) && void 0 !== e$1 ? e$1 : 1;
	}
	get mipLevelCount() {
		var e$1;
		return this.descriptor && null !== (e$1 = this.descriptor.mipLevelCount) && void 0 !== e$1 ? e$1 : 1;
	}
	get dimension() {
		var e$1;
		return this.descriptor && null !== (e$1 = this.descriptor.dimension) && void 0 !== e$1 ? e$1 : "2d";
	}
	getMipLevelSize(e$1) {
		if (e$1 >= this.mipLevelCount) return [
			0,
			0,
			0
		];
		const t$1 = [
			this.width,
			this.height,
			this.depthOrArrayLayers
		];
		for (let n$1 = 0; n$1 < t$1.length; ++n$1) t$1[n$1] = Math.max(1, t$1[n$1] >> e$1);
		return t$1;
	}
	get texelByteSize() {
		const t$1 = S[this.format];
		return t$1 ? t$1.isDepthStencil ? 4 : t$1.bytesPerBlock : 0;
	}
	get bytesPerRow() {
		return this.width * this.texelByteSize;
	}
	get isDepthStencil() {
		const t$1 = S[this.format];
		return !!t$1 && t$1.isDepthStencil;
	}
	getGpuSize() {
		const e$1 = this.format, t$1 = S[e$1], n$1 = this.width;
		if (!e$1 || n$1 <= 0 || !t$1) return -1;
		const s$1 = this.height, r$1 = this.depthOrArrayLayers, a$1 = this.dimension;
		return n$1 / t$1.blockWidth * ("1d" === a$1 ? 1 : s$1 / t$1.blockHeight) * t$1.bytesPerBlock * r$1;
	}
	getPixel(e$1, t$1, n$1 = 0, s$1 = 0) {
		const r$1 = this.texelByteSize, a$1 = this.bytesPerRow, i$1 = this.height, o$1 = this.data[s$1];
		return k(new Uint8Array(o$1), e$1, t$1, n$1, s$1, i$1, a$1, r$1, this.format);
	}
	setPixel(e$1, t$1, n$1, s$1, r$1) {
		const a$1 = this.texelByteSize, i$1 = this.bytesPerRow, o$1 = this.height, c$1 = this.data[s$1];
		(function(e$2, t$2, n$2, s$2, r$2, a$2, i$2, o$2, c$2, l$1) {
			const u$1 = s$2 * (i$2 >>= r$2) * (a$2 >>= r$2) + n$2 * i$2 + t$2 * o$2;
			switch (c$2) {
				case "r8unorm":
					T(e$2, u$1, "8unorm", 1, l$1);
					return;
				case "r8snorm":
					T(e$2, u$1, "8snorm", 1, l$1);
					return;
				case "r8uint":
					T(e$2, u$1, "8uint", 1, l$1);
					return;
				case "r8sint":
					T(e$2, u$1, "8sint", 1, l$1);
					return;
				case "rg8unorm":
					T(e$2, u$1, "8unorm", 2, l$1);
					return;
				case "rg8snorm":
					T(e$2, u$1, "8snorm", 2, l$1);
					return;
				case "rg8uint":
					T(e$2, u$1, "8uint", 2, l$1);
					return;
				case "rg8sint":
					T(e$2, u$1, "8sint", 2, l$1);
					return;
				case "rgba8unorm-srgb":
				case "rgba8unorm":
				case "bgra8unorm-srgb":
				case "bgra8unorm":
					T(e$2, u$1, "8unorm", 4, l$1);
					return;
				case "rgba8snorm":
					T(e$2, u$1, "8snorm", 4, l$1);
					return;
				case "rgba8uint":
					T(e$2, u$1, "8uint", 4, l$1);
					return;
				case "rgba8sint":
					T(e$2, u$1, "8sint", 4, l$1);
					return;
				case "r16uint":
					T(e$2, u$1, "16uint", 1, l$1);
					return;
				case "r16sint":
					T(e$2, u$1, "16sint", 1, l$1);
					return;
				case "r16float":
					T(e$2, u$1, "16float", 1, l$1);
					return;
				case "rg16uint":
					T(e$2, u$1, "16uint", 2, l$1);
					return;
				case "rg16sint":
					T(e$2, u$1, "16sint", 2, l$1);
					return;
				case "rg16float":
					T(e$2, u$1, "16float", 2, l$1);
					return;
				case "rgba16uint":
					T(e$2, u$1, "16uint", 4, l$1);
					return;
				case "rgba16sint":
					T(e$2, u$1, "16sint", 4, l$1);
					return;
				case "rgba16float":
					T(e$2, u$1, "16float", 4, l$1);
					return;
				case "r32uint":
					T(e$2, u$1, "32uint", 1, l$1);
					return;
				case "r32sint":
					T(e$2, u$1, "32sint", 1, l$1);
					return;
				case "depth16unorm":
				case "depth24plus":
				case "depth24plus-stencil8":
				case "depth32float":
				case "depth32float-stencil8":
				case "r32float":
					T(e$2, u$1, "32float", 1, l$1);
					return;
				case "rg32uint":
					T(e$2, u$1, "32uint", 2, l$1);
					return;
				case "rg32sint":
					T(e$2, u$1, "32sint", 2, l$1);
					return;
				case "rg32float":
					T(e$2, u$1, "32float", 2, l$1);
					return;
				case "rgba32uint":
					T(e$2, u$1, "32uint", 4, l$1);
					return;
				case "rgba32sint":
					T(e$2, u$1, "32sint", 4, l$1);
					return;
				case "rgba32float":
					T(e$2, u$1, "32float", 4, l$1);
					return;
				case "rg11b10ufloat": console.error("TODO: rg11b10ufloat not supported for writing");
			}
		})(new Uint8Array(c$1), e$1, t$1, n$1, s$1, o$1, i$1, a$1, this.format, r$1);
	}
};
((e$1) => {
	e$1[e$1.token = 0] = "token", e$1[e$1.keyword = 1] = "keyword", e$1[e$1.reserved = 2] = "reserved";
})(z || (z = {}));
var qe = class {
	constructor(e$1, t$1, n$1) {
		this.name = e$1, this.type = t$1, this.rule = n$1;
	}
	toString() {
		return this.name;
	}
};
var He = class {};
H = He, He.none = new qe("", z.reserved, ""), He.eof = new qe("EOF", z.token, ""), He.reserved = {
	asm: new qe("asm", z.reserved, "asm"),
	bf16: new qe("bf16", z.reserved, "bf16"),
	do: new qe("do", z.reserved, "do"),
	enum: new qe("enum", z.reserved, "enum"),
	f16: new qe("f16", z.reserved, "f16"),
	f64: new qe("f64", z.reserved, "f64"),
	handle: new qe("handle", z.reserved, "handle"),
	i8: new qe("i8", z.reserved, "i8"),
	i16: new qe("i16", z.reserved, "i16"),
	i64: new qe("i64", z.reserved, "i64"),
	mat: new qe("mat", z.reserved, "mat"),
	premerge: new qe("premerge", z.reserved, "premerge"),
	regardless: new qe("regardless", z.reserved, "regardless"),
	typedef: new qe("typedef", z.reserved, "typedef"),
	u8: new qe("u8", z.reserved, "u8"),
	u16: new qe("u16", z.reserved, "u16"),
	u64: new qe("u64", z.reserved, "u64"),
	unless: new qe("unless", z.reserved, "unless"),
	using: new qe("using", z.reserved, "using"),
	vec: new qe("vec", z.reserved, "vec"),
	void: new qe("void", z.reserved, "void")
}, He.keywords = {
	array: new qe("array", z.keyword, "array"),
	atomic: new qe("atomic", z.keyword, "atomic"),
	bool: new qe("bool", z.keyword, "bool"),
	f32: new qe("f32", z.keyword, "f32"),
	i32: new qe("i32", z.keyword, "i32"),
	mat2x2: new qe("mat2x2", z.keyword, "mat2x2"),
	mat2x3: new qe("mat2x3", z.keyword, "mat2x3"),
	mat2x4: new qe("mat2x4", z.keyword, "mat2x4"),
	mat3x2: new qe("mat3x2", z.keyword, "mat3x2"),
	mat3x3: new qe("mat3x3", z.keyword, "mat3x3"),
	mat3x4: new qe("mat3x4", z.keyword, "mat3x4"),
	mat4x2: new qe("mat4x2", z.keyword, "mat4x2"),
	mat4x3: new qe("mat4x3", z.keyword, "mat4x3"),
	mat4x4: new qe("mat4x4", z.keyword, "mat4x4"),
	ptr: new qe("ptr", z.keyword, "ptr"),
	sampler: new qe("sampler", z.keyword, "sampler"),
	sampler_comparison: new qe("sampler_comparison", z.keyword, "sampler_comparison"),
	struct: new qe("struct", z.keyword, "struct"),
	texture_1d: new qe("texture_1d", z.keyword, "texture_1d"),
	texture_2d: new qe("texture_2d", z.keyword, "texture_2d"),
	texture_2d_array: new qe("texture_2d_array", z.keyword, "texture_2d_array"),
	texture_3d: new qe("texture_3d", z.keyword, "texture_3d"),
	texture_cube: new qe("texture_cube", z.keyword, "texture_cube"),
	texture_cube_array: new qe("texture_cube_array", z.keyword, "texture_cube_array"),
	texture_multisampled_2d: new qe("texture_multisampled_2d", z.keyword, "texture_multisampled_2d"),
	texture_storage_1d: new qe("texture_storage_1d", z.keyword, "texture_storage_1d"),
	texture_storage_2d: new qe("texture_storage_2d", z.keyword, "texture_storage_2d"),
	texture_storage_2d_array: new qe("texture_storage_2d_array", z.keyword, "texture_storage_2d_array"),
	texture_storage_3d: new qe("texture_storage_3d", z.keyword, "texture_storage_3d"),
	texture_depth_2d: new qe("texture_depth_2d", z.keyword, "texture_depth_2d"),
	texture_depth_2d_array: new qe("texture_depth_2d_array", z.keyword, "texture_depth_2d_array"),
	texture_depth_cube: new qe("texture_depth_cube", z.keyword, "texture_depth_cube"),
	texture_depth_cube_array: new qe("texture_depth_cube_array", z.keyword, "texture_depth_cube_array"),
	texture_depth_multisampled_2d: new qe("texture_depth_multisampled_2d", z.keyword, "texture_depth_multisampled_2d"),
	texture_external: new qe("texture_external", z.keyword, "texture_external"),
	u32: new qe("u32", z.keyword, "u32"),
	vec2: new qe("vec2", z.keyword, "vec2"),
	vec3: new qe("vec3", z.keyword, "vec3"),
	vec4: new qe("vec4", z.keyword, "vec4"),
	bitcast: new qe("bitcast", z.keyword, "bitcast"),
	block: new qe("block", z.keyword, "block"),
	break: new qe("break", z.keyword, "break"),
	case: new qe("case", z.keyword, "case"),
	continue: new qe("continue", z.keyword, "continue"),
	continuing: new qe("continuing", z.keyword, "continuing"),
	default: new qe("default", z.keyword, "default"),
	diagnostic: new qe("diagnostic", z.keyword, "diagnostic"),
	discard: new qe("discard", z.keyword, "discard"),
	else: new qe("else", z.keyword, "else"),
	enable: new qe("enable", z.keyword, "enable"),
	fallthrough: new qe("fallthrough", z.keyword, "fallthrough"),
	false: new qe("false", z.keyword, "false"),
	fn: new qe("fn", z.keyword, "fn"),
	for: new qe("for", z.keyword, "for"),
	function: new qe("function", z.keyword, "function"),
	if: new qe("if", z.keyword, "if"),
	let: new qe("let", z.keyword, "let"),
	const: new qe("const", z.keyword, "const"),
	loop: new qe("loop", z.keyword, "loop"),
	while: new qe("while", z.keyword, "while"),
	private: new qe("private", z.keyword, "private"),
	read: new qe("read", z.keyword, "read"),
	read_write: new qe("read_write", z.keyword, "read_write"),
	return: new qe("return", z.keyword, "return"),
	requires: new qe("requires", z.keyword, "requires"),
	storage: new qe("storage", z.keyword, "storage"),
	switch: new qe("switch", z.keyword, "switch"),
	true: new qe("true", z.keyword, "true"),
	alias: new qe("alias", z.keyword, "alias"),
	type: new qe("type", z.keyword, "type"),
	uniform: new qe("uniform", z.keyword, "uniform"),
	var: new qe("var", z.keyword, "var"),
	override: new qe("override", z.keyword, "override"),
	workgroup: new qe("workgroup", z.keyword, "workgroup"),
	write: new qe("write", z.keyword, "write"),
	r8unorm: new qe("r8unorm", z.keyword, "r8unorm"),
	r8snorm: new qe("r8snorm", z.keyword, "r8snorm"),
	r8uint: new qe("r8uint", z.keyword, "r8uint"),
	r8sint: new qe("r8sint", z.keyword, "r8sint"),
	r16uint: new qe("r16uint", z.keyword, "r16uint"),
	r16sint: new qe("r16sint", z.keyword, "r16sint"),
	r16float: new qe("r16float", z.keyword, "r16float"),
	rg8unorm: new qe("rg8unorm", z.keyword, "rg8unorm"),
	rg8snorm: new qe("rg8snorm", z.keyword, "rg8snorm"),
	rg8uint: new qe("rg8uint", z.keyword, "rg8uint"),
	rg8sint: new qe("rg8sint", z.keyword, "rg8sint"),
	r32uint: new qe("r32uint", z.keyword, "r32uint"),
	r32sint: new qe("r32sint", z.keyword, "r32sint"),
	r32float: new qe("r32float", z.keyword, "r32float"),
	rg16uint: new qe("rg16uint", z.keyword, "rg16uint"),
	rg16sint: new qe("rg16sint", z.keyword, "rg16sint"),
	rg16float: new qe("rg16float", z.keyword, "rg16float"),
	rgba8unorm: new qe("rgba8unorm", z.keyword, "rgba8unorm"),
	rgba8unorm_srgb: new qe("rgba8unorm_srgb", z.keyword, "rgba8unorm_srgb"),
	rgba8snorm: new qe("rgba8snorm", z.keyword, "rgba8snorm"),
	rgba8uint: new qe("rgba8uint", z.keyword, "rgba8uint"),
	rgba8sint: new qe("rgba8sint", z.keyword, "rgba8sint"),
	bgra8unorm: new qe("bgra8unorm", z.keyword, "bgra8unorm"),
	bgra8unorm_srgb: new qe("bgra8unorm_srgb", z.keyword, "bgra8unorm_srgb"),
	rgb10a2unorm: new qe("rgb10a2unorm", z.keyword, "rgb10a2unorm"),
	rg11b10float: new qe("rg11b10float", z.keyword, "rg11b10float"),
	rg32uint: new qe("rg32uint", z.keyword, "rg32uint"),
	rg32sint: new qe("rg32sint", z.keyword, "rg32sint"),
	rg32float: new qe("rg32float", z.keyword, "rg32float"),
	rgba16uint: new qe("rgba16uint", z.keyword, "rgba16uint"),
	rgba16sint: new qe("rgba16sint", z.keyword, "rgba16sint"),
	rgba16float: new qe("rgba16float", z.keyword, "rgba16float"),
	rgba32uint: new qe("rgba32uint", z.keyword, "rgba32uint"),
	rgba32sint: new qe("rgba32sint", z.keyword, "rgba32sint"),
	rgba32float: new qe("rgba32float", z.keyword, "rgba32float"),
	static_assert: new qe("static_assert", z.keyword, "static_assert")
}, He.tokens = {
	decimal_float_literal: new qe("decimal_float_literal", z.token, /((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?[fh]?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+[fh]?)|(-?[0-9]+[fh])/),
	hex_float_literal: new qe("hex_float_literal", z.token, /-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+[fh]?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+[fh]?))/),
	int_literal: new qe("int_literal", z.token, /-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),
	uint_literal: new qe("uint_literal", z.token, /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),
	name: new qe("name", z.token, /([_\p{XID_Start}][\p{XID_Continue}]+)|([\p{XID_Start}])/u),
	ident: new qe("ident", z.token, /[_a-zA-Z][0-9a-zA-Z_]*/),
	and: new qe("and", z.token, "&"),
	and_and: new qe("and_and", z.token, "&&"),
	arrow: new qe("arrow ", z.token, "->"),
	attr: new qe("attr", z.token, "@"),
	forward_slash: new qe("forward_slash", z.token, "/"),
	bang: new qe("bang", z.token, "!"),
	bracket_left: new qe("bracket_left", z.token, "["),
	bracket_right: new qe("bracket_right", z.token, "]"),
	brace_left: new qe("brace_left", z.token, "{"),
	brace_right: new qe("brace_right", z.token, "}"),
	colon: new qe("colon", z.token, ":"),
	comma: new qe("comma", z.token, ","),
	equal: new qe("equal", z.token, "="),
	equal_equal: new qe("equal_equal", z.token, "=="),
	not_equal: new qe("not_equal", z.token, "!="),
	greater_than: new qe("greater_than", z.token, ">"),
	greater_than_equal: new qe("greater_than_equal", z.token, ">="),
	shift_right: new qe("shift_right", z.token, ">>"),
	less_than: new qe("less_than", z.token, "<"),
	less_than_equal: new qe("less_than_equal", z.token, "<="),
	shift_left: new qe("shift_left", z.token, "<<"),
	modulo: new qe("modulo", z.token, "%"),
	minus: new qe("minus", z.token, "-"),
	minus_minus: new qe("minus_minus", z.token, "--"),
	period: new qe("period", z.token, "."),
	plus: new qe("plus", z.token, "+"),
	plus_plus: new qe("plus_plus", z.token, "++"),
	or: new qe("or", z.token, "|"),
	or_or: new qe("or_or", z.token, "||"),
	paren_left: new qe("paren_left", z.token, "("),
	paren_right: new qe("paren_right", z.token, ")"),
	semicolon: new qe("semicolon", z.token, ";"),
	star: new qe("star", z.token, "*"),
	tilde: new qe("tilde", z.token, "~"),
	underscore: new qe("underscore", z.token, "_"),
	xor: new qe("xor", z.token, "^"),
	plus_equal: new qe("plus_equal", z.token, "+="),
	minus_equal: new qe("minus_equal", z.token, "-="),
	times_equal: new qe("times_equal", z.token, "*="),
	division_equal: new qe("division_equal", z.token, "/="),
	modulo_equal: new qe("modulo_equal", z.token, "%="),
	and_equal: new qe("and_equal", z.token, "&="),
	or_equal: new qe("or_equal", z.token, "|="),
	xor_equal: new qe("xor_equal", z.token, "^="),
	shift_right_equal: new qe("shift_right_equal", z.token, ">>="),
	shift_left_equal: new qe("shift_left_equal", z.token, "<<=")
}, He.simpleTokens = {
	"@": H.tokens.attr,
	"{": H.tokens.brace_left,
	"}": H.tokens.brace_right,
	":": H.tokens.colon,
	",": H.tokens.comma,
	"(": H.tokens.paren_left,
	")": H.tokens.paren_right,
	";": H.tokens.semicolon
}, He.literalTokens = {
	"&": H.tokens.and,
	"&&": H.tokens.and_and,
	"->": H.tokens.arrow,
	"/": H.tokens.forward_slash,
	"!": H.tokens.bang,
	"[": H.tokens.bracket_left,
	"]": H.tokens.bracket_right,
	"=": H.tokens.equal,
	"==": H.tokens.equal_equal,
	"!=": H.tokens.not_equal,
	">": H.tokens.greater_than,
	">=": H.tokens.greater_than_equal,
	">>": H.tokens.shift_right,
	"<": H.tokens.less_than,
	"<=": H.tokens.less_than_equal,
	"<<": H.tokens.shift_left,
	"%": H.tokens.modulo,
	"-": H.tokens.minus,
	"--": H.tokens.minus_minus,
	".": H.tokens.period,
	"+": H.tokens.plus,
	"++": H.tokens.plus_plus,
	"|": H.tokens.or,
	"||": H.tokens.or_or,
	"*": H.tokens.star,
	"~": H.tokens.tilde,
	_: H.tokens.underscore,
	"^": H.tokens.xor,
	"+=": H.tokens.plus_equal,
	"-=": H.tokens.minus_equal,
	"*=": H.tokens.times_equal,
	"/=": H.tokens.division_equal,
	"%=": H.tokens.modulo_equal,
	"&=": H.tokens.and_equal,
	"|=": H.tokens.or_equal,
	"^=": H.tokens.xor_equal,
	">>=": H.tokens.shift_right_equal,
	"<<=": H.tokens.shift_left_equal
}, He.regexTokens = {
	decimal_float_literal: H.tokens.decimal_float_literal,
	hex_float_literal: H.tokens.hex_float_literal,
	int_literal: H.tokens.int_literal,
	uint_literal: H.tokens.uint_literal,
	ident: H.tokens.ident
}, He.storage_class = [
	H.keywords.function,
	H.keywords.private,
	H.keywords.workgroup,
	H.keywords.uniform,
	H.keywords.storage
], He.access_mode = [
	H.keywords.read,
	H.keywords.write,
	H.keywords.read_write
], He.sampler_type = [H.keywords.sampler, H.keywords.sampler_comparison], He.sampled_texture_type = [
	H.keywords.texture_1d,
	H.keywords.texture_2d,
	H.keywords.texture_2d_array,
	H.keywords.texture_3d,
	H.keywords.texture_cube,
	H.keywords.texture_cube_array
], He.multisampled_texture_type = [H.keywords.texture_multisampled_2d], He.storage_texture_type = [
	H.keywords.texture_storage_1d,
	H.keywords.texture_storage_2d,
	H.keywords.texture_storage_2d_array,
	H.keywords.texture_storage_3d
], He.depth_texture_type = [
	H.keywords.texture_depth_2d,
	H.keywords.texture_depth_2d_array,
	H.keywords.texture_depth_cube,
	H.keywords.texture_depth_cube_array,
	H.keywords.texture_depth_multisampled_2d
], He.texture_external_type = [H.keywords.texture_external], He.any_texture_type = [
	...H.sampled_texture_type,
	...H.multisampled_texture_type,
	...H.storage_texture_type,
	...H.depth_texture_type,
	...H.texture_external_type
], He.texel_format = [
	H.keywords.r8unorm,
	H.keywords.r8snorm,
	H.keywords.r8uint,
	H.keywords.r8sint,
	H.keywords.r16uint,
	H.keywords.r16sint,
	H.keywords.r16float,
	H.keywords.rg8unorm,
	H.keywords.rg8snorm,
	H.keywords.rg8uint,
	H.keywords.rg8sint,
	H.keywords.r32uint,
	H.keywords.r32sint,
	H.keywords.r32float,
	H.keywords.rg16uint,
	H.keywords.rg16sint,
	H.keywords.rg16float,
	H.keywords.rgba8unorm,
	H.keywords.rgba8unorm_srgb,
	H.keywords.rgba8snorm,
	H.keywords.rgba8uint,
	H.keywords.rgba8sint,
	H.keywords.bgra8unorm,
	H.keywords.bgra8unorm_srgb,
	H.keywords.rgb10a2unorm,
	H.keywords.rg11b10float,
	H.keywords.rg32uint,
	H.keywords.rg32sint,
	H.keywords.rg32float,
	H.keywords.rgba16uint,
	H.keywords.rgba16sint,
	H.keywords.rgba16float,
	H.keywords.rgba32uint,
	H.keywords.rgba32sint,
	H.keywords.rgba32float
], He.const_literal = [
	H.tokens.int_literal,
	H.tokens.uint_literal,
	H.tokens.decimal_float_literal,
	H.tokens.hex_float_literal,
	H.keywords.true,
	H.keywords.false
], He.literal_or_ident = [
	H.tokens.ident,
	H.tokens.int_literal,
	H.tokens.uint_literal,
	H.tokens.decimal_float_literal,
	H.tokens.hex_float_literal,
	H.tokens.name
], He.element_count_expression = [
	H.tokens.int_literal,
	H.tokens.uint_literal,
	H.tokens.ident
], He.template_types = [
	H.keywords.vec2,
	H.keywords.vec3,
	H.keywords.vec4,
	H.keywords.mat2x2,
	H.keywords.mat2x3,
	H.keywords.mat2x4,
	H.keywords.mat3x2,
	H.keywords.mat3x3,
	H.keywords.mat3x4,
	H.keywords.mat4x2,
	H.keywords.mat4x3,
	H.keywords.mat4x4,
	H.keywords.atomic,
	H.keywords.bitcast,
	...H.any_texture_type
], He.attribute_name = [
	H.tokens.ident,
	H.keywords.block,
	H.keywords.diagnostic
], He.assignment_operators = [
	H.tokens.equal,
	H.tokens.plus_equal,
	H.tokens.minus_equal,
	H.tokens.times_equal,
	H.tokens.division_equal,
	H.tokens.modulo_equal,
	H.tokens.and_equal,
	H.tokens.or_equal,
	H.tokens.xor_equal,
	H.tokens.shift_right_equal,
	H.tokens.shift_left_equal
], He.increment_operators = [H.tokens.plus_plus, H.tokens.minus_minus];
var ze = class {
	constructor(e$1, t$1, n$1, s$1, r$1) {
		this.type = e$1, this.lexeme = t$1, this.line = n$1, this.start = s$1, this.end = r$1;
	}
	toString() {
		return this.lexeme;
	}
	isTemplateType() {
		return -1 != He.template_types.indexOf(this.type);
	}
	isArrayType() {
		return this.type == He.keywords.array;
	}
	isArrayOrTemplateType() {
		return this.isArrayType() || this.isTemplateType();
	}
};
var Re = class {
	constructor(e$1) {
		this._tokens = [], this._start = 0, this._current = 0, this._line = 1, this._source = null != e$1 ? e$1 : "";
	}
	scanTokens() {
		for (; !this._isAtEnd();) if (this._start = this._current, !this.scanToken()) throw `Invalid syntax at line ${this._line}`;
		return this._tokens.push(new ze(He.eof, "", this._line, this._current, this._current)), this._tokens;
	}
	scanToken() {
		let e$1 = this._advance();
		if ("\n" == e$1) return this._line++, !0;
		if (this._isWhitespace(e$1)) return !0;
		if ("/" == e$1) {
			if ("/" == this._peekAhead()) {
				for (; "\n" != e$1;) {
					if (this._isAtEnd()) return !0;
					e$1 = this._advance();
				}
				return this._line++, !0;
			}
			if ("*" == this._peekAhead()) {
				this._advance();
				let t$2 = 1;
				for (; t$2 > 0;) {
					if (this._isAtEnd()) return !0;
					if (e$1 = this._advance(), "\n" == e$1) this._line++;
					else if ("*" == e$1) {
						if ("/" == this._peekAhead() && (this._advance(), t$2--, 0 == t$2)) return !0;
					} else "/" == e$1 && "*" == this._peekAhead() && (this._advance(), t$2++);
				}
				return !0;
			}
		}
		const t$1 = He.simpleTokens[e$1];
		if (t$1) return this._addToken(t$1), !0;
		let n$1 = He.none;
		const s$1 = this._isAlpha(e$1), r$1 = "_" === e$1;
		if (this._isAlphaNumeric(e$1)) {
			let t$2 = this._peekAhead();
			for (; this._isAlphaNumeric(t$2);) e$1 += this._advance(), t$2 = this._peekAhead();
		}
		if (s$1) {
			const t$2 = He.keywords[e$1];
			if (t$2) return this._addToken(t$2), !0;
		}
		if (s$1 || r$1) return this._addToken(He.tokens.ident), !0;
		for (;;) {
			let t$2 = this._findType(e$1);
			const s$2 = this._peekAhead();
			if ("-" == e$1 && this._tokens.length > 0) {
				if ("=" == s$2) return this._current++, e$1 += s$2, this._addToken(He.tokens.minus_equal), !0;
				if ("-" == s$2) return this._current++, e$1 += s$2, this._addToken(He.tokens.minus_minus), !0;
				const n$2 = this._tokens.length - 1;
				if ((-1 != He.literal_or_ident.indexOf(this._tokens[n$2].type) || this._tokens[n$2].type == He.tokens.paren_right) && ">" != s$2) return this._addToken(t$2), !0;
			}
			if (">" == e$1 && (">" == s$2 || "=" == s$2)) {
				let e$2 = !1, n$2 = this._tokens.length - 1;
				for (let t$3 = 0; t$3 < 5 && n$2 >= 0 && -1 === He.assignment_operators.indexOf(this._tokens[n$2].type); ++t$3, --n$2) if (this._tokens[n$2].type === He.tokens.less_than) {
					n$2 > 0 && this._tokens[n$2 - 1].isArrayOrTemplateType() && (e$2 = !0);
					break;
				}
				if (e$2) return this._addToken(t$2), !0;
			}
			if (t$2 === He.none) {
				let s$3 = e$1, r$2 = 0;
				const a$1 = 2;
				for (let e$2 = 0; e$2 < a$1; ++e$2) if (s$3 += this._peekAhead(e$2), t$2 = this._findType(s$3), t$2 !== He.none) {
					r$2 = e$2;
					break;
				}
				if (t$2 === He.none) return n$1 !== He.none && (this._current--, this._addToken(n$1), !0);
				e$1 = s$3, this._current += r$2 + 1;
			}
			if (n$1 = t$2, this._isAtEnd()) break;
			e$1 += this._advance();
		}
		return n$1 !== He.none && (this._addToken(n$1), !0);
	}
	_findType(e$1) {
		for (const t$1 in He.regexTokens) {
			const n$1 = He.regexTokens[t$1];
			if (this._match(e$1, n$1.rule)) return n$1;
		}
		return He.literalTokens[e$1] || He.none;
	}
	_match(e$1, t$1) {
		const n$1 = t$1.exec(e$1);
		return n$1 && 0 == n$1.index && n$1[0] == e$1;
	}
	_isAtEnd() {
		return this._current >= this._source.length;
	}
	_isAlpha(e$1) {
		return !this._isNumeric(e$1) && !this._isWhitespace(e$1) && "_" !== e$1 && "." !== e$1 && "(" !== e$1 && ")" !== e$1 && "[" !== e$1 && "]" !== e$1 && "{" !== e$1 && "}" !== e$1 && "," !== e$1 && ";" !== e$1 && ":" !== e$1 && "=" !== e$1 && "!" !== e$1 && "<" !== e$1 && ">" !== e$1 && "+" !== e$1 && "-" !== e$1 && "*" !== e$1 && "/" !== e$1 && "%" !== e$1 && "&" !== e$1 && "|" !== e$1 && "^" !== e$1 && "~" !== e$1 && "@" !== e$1 && "#" !== e$1 && "?" !== e$1 && "'" !== e$1 && "`" !== e$1 && "\"" !== e$1 && "\\" !== e$1 && "\n" !== e$1 && "\r" !== e$1 && "	" !== e$1 && "\0" !== e$1;
	}
	_isNumeric(e$1) {
		return e$1 >= "0" && e$1 <= "9";
	}
	_isAlphaNumeric(e$1) {
		return this._isAlpha(e$1) || this._isNumeric(e$1) || "_" === e$1;
	}
	_isWhitespace(e$1) {
		return " " == e$1 || "	" == e$1 || "\r" == e$1;
	}
	_advance(e$1 = 0) {
		let t$1 = this._source[this._current];
		return e$1 = e$1 || 0, e$1++, this._current += e$1, t$1;
	}
	_peekAhead(e$1 = 0) {
		return e$1 = e$1 || 0, this._current + e$1 >= this._source.length ? "\0" : this._source[this._current + e$1];
	}
	_addToken(e$1) {
		const t$1 = this._source.substring(this._start, this._current);
		this._tokens.push(new ze(e$1, t$1, this._line, this._start, this._current));
	}
};
function Ge(e$1) {
	return Array.isArray(e$1) || (null == e$1 ? void 0 : e$1.buffer) instanceof ArrayBuffer;
}
var Xe = new Float32Array(1), je = new Uint32Array(Xe.buffer), Ze = new Uint32Array(Xe.buffer), Qe = new Int32Array(1), Ye = new Float32Array(Qe.buffer), Ke = new Uint32Array(Qe.buffer), Je = new Uint32Array(1), et = new Float32Array(Je.buffer), tt = new Int32Array(Je.buffer);
function nt(e$1, t$1, n$1) {
	if (t$1 === n$1) return e$1;
	if ("f32" === t$1) {
		if ("i32" === n$1 || "x32" === n$1) return Xe[0] = e$1, je[0];
		if ("u32" === n$1) return Xe[0] = e$1, Ze[0];
	} else if ("i32" === t$1 || "x32" === t$1) {
		if ("f32" === n$1) return Qe[0] = e$1, Ye[0];
		if ("u32" === n$1) return Qe[0] = e$1, Ke[0];
	} else if ("u32" === t$1) {
		if ("f32" === n$1) return Je[0] = e$1, et[0];
		if ("i32" === n$1 || "x32" === n$1) return Je[0] = e$1, tt[0];
	}
	return console.error(`Unsupported cast from ${t$1} to ${n$1}`), e$1;
}
var st = class {
	constructor(e$1) {
		this.resources = null, this.inUse = !1, this.info = null, this.node = e$1;
	}
};
var rt = class {
	constructor(e$1, t$1) {
		this.align = e$1, this.size = t$1;
	}
};
var at = class at {
	constructor() {
		this.uniforms = [], this.storage = [], this.textures = [], this.samplers = [], this.aliases = [], this.overrides = [], this.structs = [], this.entry = new d(), this.functions = [], this._types = /* @__PURE__ */ new Map(), this._functions = /* @__PURE__ */ new Map();
	}
	_isStorageTexture(e$1) {
		return "texture_storage_1d" == e$1.name || "texture_storage_2d" == e$1.name || "texture_storage_2d_array" == e$1.name || "texture_storage_3d" == e$1.name;
	}
	updateAST(e$1) {
		for (const t$1 of e$1) t$1 instanceof D && this._functions.set(t$1.name, new st(t$1));
		for (const t$1 of e$1) if (t$1 instanceof oe) {
			const e$2 = this.getTypeInfo(t$1, null);
			e$2 instanceof n && this.structs.push(e$2);
		}
		for (const t$1 of e$1) if (t$1 instanceof te) this.aliases.push(this._getAliasInfo(t$1));
		else {
			if (t$1 instanceof M) {
				const e$2 = t$1, n$1 = this._getAttributeNum(e$2.attributes, "id", 0), s$1 = null != e$2.type ? this.getTypeInfo(e$2.type, e$2.attributes) : null;
				this.overrides.push(new h(e$2.name, s$1, e$2.attributes, n$1));
				continue;
			}
			if (this._isUniformVar(t$1)) {
				const e$2 = t$1, n$1 = this._getAttributeNum(e$2.attributes, "group", 0), s$1 = this._getAttributeNum(e$2.attributes, "binding", 0), r$1 = this.getTypeInfo(e$2.type, e$2.attributes), a$1 = new o(e$2.name, r$1, n$1, s$1, e$2.attributes, i.Uniform, e$2.access);
				a$1.access || (a$1.access = "read"), this.uniforms.push(a$1);
				continue;
			}
			if (this._isStorageVar(t$1)) {
				const e$2 = t$1, n$1 = this._getAttributeNum(e$2.attributes, "group", 0), s$1 = this._getAttributeNum(e$2.attributes, "binding", 0), r$1 = this.getTypeInfo(e$2.type, e$2.attributes), a$1 = this._isStorageTexture(r$1), c$1 = new o(e$2.name, r$1, n$1, s$1, e$2.attributes, a$1 ? i.StorageTexture : i.Storage, e$2.access);
				c$1.access || (c$1.access = "read"), this.storage.push(c$1);
				continue;
			}
			if (this._isTextureVar(t$1)) {
				const e$2 = t$1, n$1 = this._getAttributeNum(e$2.attributes, "group", 0), s$1 = this._getAttributeNum(e$2.attributes, "binding", 0), r$1 = this.getTypeInfo(e$2.type, e$2.attributes), a$1 = this._isStorageTexture(r$1), c$1 = new o(e$2.name, r$1, n$1, s$1, e$2.attributes, a$1 ? i.StorageTexture : i.Texture, e$2.access);
				c$1.access || (c$1.access = "read"), a$1 ? this.storage.push(c$1) : this.textures.push(c$1);
				continue;
			}
			if (this._isSamplerVar(t$1)) {
				const e$2 = t$1, n$1 = this._getAttributeNum(e$2.attributes, "group", 0), s$1 = this._getAttributeNum(e$2.attributes, "binding", 0), r$1 = this.getTypeInfo(e$2.type, e$2.attributes), a$1 = new o(e$2.name, r$1, n$1, s$1, e$2.attributes, i.Sampler, e$2.access);
				this.samplers.push(a$1);
				continue;
			}
		}
		for (const t$1 of e$1) if (t$1 instanceof D) {
			const e$2 = this._getAttribute(t$1, "vertex"), n$1 = this._getAttribute(t$1, "fragment"), s$1 = this._getAttribute(t$1, "compute"), r$1 = e$2 || n$1 || s$1, a$1 = new p(t$1.name, null == r$1 ? void 0 : r$1.name, t$1.attributes);
			a$1.attributes = t$1.attributes, a$1.startLine = t$1.startLine, a$1.endLine = t$1.endLine, this.functions.push(a$1), this._functions.get(t$1.name).info = a$1, r$1 && (this._functions.get(t$1.name).inUse = !0, a$1.inUse = !0, a$1.resources = this._findResources(t$1, !!r$1), a$1.inputs = this._getInputs(t$1.args), a$1.outputs = this._getOutputs(t$1.returnType), this.entry[r$1.name].push(a$1)), a$1.arguments = t$1.args.map((e$3) => new f(e$3.name, this.getTypeInfo(e$3.type, e$3.attributes), e$3.attributes)), a$1.returnType = t$1.returnType ? this.getTypeInfo(t$1.returnType, t$1.attributes) : null;
			continue;
		}
		for (const e$2 of this._functions.values()) e$2.info && (e$2.info.inUse = e$2.inUse, this._addCalls(e$2.node, e$2.info.calls));
		for (const e$2 of this._functions.values()) e$2.node.search((t$1) => {
			var n$1, s$1, r$1;
			if (t$1 instanceof De) {
				if (t$1.value) if (Ge(t$1.value)) for (const s$2 of t$1.value) for (const t$2 of this.overrides) s$2 === t$2.name && (null === (n$1 = e$2.info) || void 0 === n$1 || n$1.overrides.push(t$2));
				else for (const n$2 of this.overrides) t$1.value === n$2.name && (null === (s$1 = e$2.info) || void 0 === s$1 || s$1.overrides.push(n$2));
			} else if (t$1 instanceof ge) for (const n$2 of this.overrides) t$1.name === n$2.name && (null === (r$1 = e$2.info) || void 0 === r$1 || r$1.overrides.push(n$2));
		});
		for (const e$2 of this.uniforms) this._markStructsInUse(e$2.type);
		for (const e$2 of this.storage) this._markStructsInUse(e$2.type);
	}
	getFunctionInfo(e$1) {
		for (const t$1 of this.functions) if (t$1.name == e$1) return t$1;
		return null;
	}
	getStructInfo(e$1) {
		for (const t$1 of this.structs) if (t$1.name == e$1) return t$1;
		return null;
	}
	getOverrideInfo(e$1) {
		for (const t$1 of this.overrides) if (t$1.name == e$1) return t$1;
		return null;
	}
	_markStructsInUse(e$1) {
		if (e$1) if (e$1.isStruct) {
			if (e$1.inUse = !0, e$1.members) for (const t$1 of e$1.members) this._markStructsInUse(t$1.type);
		} else if (e$1.isArray) this._markStructsInUse(e$1.format);
		else if (e$1.isTemplate) e$1.format && this._markStructsInUse(e$1.format);
		else {
			const t$1 = this._getAlias(e$1.name);
			t$1 && this._markStructsInUse(t$1);
		}
	}
	_addCalls(e$1, t$1) {
		var n$1;
		for (const s$1 of e$1.calls) {
			const e$2 = null === (n$1 = this._functions.get(s$1.name)) || void 0 === n$1 ? void 0 : n$1.info;
			e$2 && t$1.add(e$2);
		}
	}
	findResource(e$1, t$1, n$1) {
		if (n$1) {
			for (const s$1 of this.entry.compute) if (s$1.name === n$1) {
				for (const n$2 of s$1.resources) if (n$2.group == e$1 && n$2.binding == t$1) return n$2;
			}
			for (const s$1 of this.entry.vertex) if (s$1.name === n$1) {
				for (const n$2 of s$1.resources) if (n$2.group == e$1 && n$2.binding == t$1) return n$2;
			}
			for (const s$1 of this.entry.fragment) if (s$1.name === n$1) {
				for (const n$2 of s$1.resources) if (n$2.group == e$1 && n$2.binding == t$1) return n$2;
			}
		}
		for (const n$2 of this.uniforms) if (n$2.group == e$1 && n$2.binding == t$1) return n$2;
		for (const n$2 of this.storage) if (n$2.group == e$1 && n$2.binding == t$1) return n$2;
		for (const n$2 of this.textures) if (n$2.group == e$1 && n$2.binding == t$1) return n$2;
		for (const n$2 of this.samplers) if (n$2.group == e$1 && n$2.binding == t$1) return n$2;
		return null;
	}
	_findResource(e$1) {
		for (const t$1 of this.uniforms) if (t$1.name == e$1) return t$1;
		for (const t$1 of this.storage) if (t$1.name == e$1) return t$1;
		for (const t$1 of this.textures) if (t$1.name == e$1) return t$1;
		for (const t$1 of this.samplers) if (t$1.name == e$1) return t$1;
		return null;
	}
	_markStructsFromAST(e$1) {
		const t$1 = this.getTypeInfo(e$1, null);
		this._markStructsInUse(t$1);
	}
	_findResources(e$1, t$1) {
		const n$1 = [], s$1 = this, r$1 = [];
		return e$1.search((a$1) => {
			if (a$1 instanceof E) r$1.push({});
			else if (a$1 instanceof $) r$1.pop();
			else if (a$1 instanceof F) {
				const e$2 = a$1;
				t$1 && null !== e$2.type && this._markStructsFromAST(e$2.type), r$1.length > 0 && (r$1[r$1.length - 1][e$2.name] = e$2);
			} else if (a$1 instanceof de) {
				const e$2 = a$1;
				t$1 && null !== e$2.type && this._markStructsFromAST(e$2.type);
			} else if (a$1 instanceof U) {
				const e$2 = a$1;
				t$1 && null !== e$2.type && this._markStructsFromAST(e$2.type), r$1.length > 0 && (r$1[r$1.length - 1][e$2.name] = e$2);
			} else if (a$1 instanceof ge) {
				const e$2 = a$1;
				if (r$1.length > 0) {
					if (r$1[r$1.length - 1][e$2.name]) return;
				}
				const t$2 = s$1._findResource(e$2.name);
				t$2 && n$1.push(t$2);
			} else if (a$1 instanceof me) {
				const r$2 = a$1, i$1 = s$1._functions.get(r$2.name);
				i$1 && (t$1 && (i$1.inUse = !0), e$1.calls.add(i$1.node), null === i$1.resources && (i$1.resources = s$1._findResources(i$1.node, t$1)), n$1.push(...i$1.resources));
			} else if (a$1 instanceof X) {
				const r$2 = a$1, i$1 = s$1._functions.get(r$2.name);
				i$1 && (t$1 && (i$1.inUse = !0), e$1.calls.add(i$1.node), null === i$1.resources && (i$1.resources = s$1._findResources(i$1.node, t$1)), n$1.push(...i$1.resources));
			}
		}), [...new Map(n$1.map((e$2) => [e$2.name, e$2])).values()];
	}
	getBindGroups() {
		const e$1 = [];
		function t$1(t$2, n$1) {
			t$2 >= e$1.length && (e$1.length = t$2 + 1), void 0 === e$1[t$2] && (e$1[t$2] = []), n$1 >= e$1[t$2].length && (e$1[t$2].length = n$1 + 1);
		}
		for (const n$1 of this.uniforms) {
			t$1(n$1.group, n$1.binding);
			e$1[n$1.group][n$1.binding] = n$1;
		}
		for (const n$1 of this.storage) {
			t$1(n$1.group, n$1.binding);
			e$1[n$1.group][n$1.binding] = n$1;
		}
		for (const n$1 of this.textures) {
			t$1(n$1.group, n$1.binding);
			e$1[n$1.group][n$1.binding] = n$1;
		}
		for (const n$1 of this.samplers) {
			t$1(n$1.group, n$1.binding);
			e$1[n$1.group][n$1.binding] = n$1;
		}
		return e$1;
	}
	_getOutputs(e$1, t$1 = void 0) {
		if (void 0 === t$1 && (t$1 = []), e$1 instanceof oe) this._getStructOutputs(e$1, t$1);
		else {
			const n$1 = this._getOutputInfo(e$1);
			null !== n$1 && t$1.push(n$1);
		}
		return t$1;
	}
	_getStructOutputs(e$1, t$1) {
		for (const n$1 of e$1.members) if (n$1.type instanceof oe) this._getStructOutputs(n$1.type, t$1);
		else {
			const e$2 = this._getAttribute(n$1, "location") || this._getAttribute(n$1, "builtin");
			if (null !== e$2) {
				const s$1 = this.getTypeInfo(n$1.type, n$1.type.attributes), r$1 = this._parseInt(e$2.value), a$1 = new u(n$1.name, s$1, e$2.name, r$1);
				t$1.push(a$1);
			}
		}
	}
	_getOutputInfo(e$1) {
		const t$1 = this._getAttribute(e$1, "location") || this._getAttribute(e$1, "builtin");
		if (null !== t$1) {
			const n$1 = this.getTypeInfo(e$1, e$1.attributes), s$1 = this._parseInt(t$1.value);
			return new u("", n$1, t$1.name, s$1);
		}
		return null;
	}
	_getInputs(e$1, t$1 = void 0) {
		void 0 === t$1 && (t$1 = []);
		for (const n$1 of e$1) if (n$1.type instanceof oe) this._getStructInputs(n$1.type, t$1);
		else {
			const e$2 = this._getInputInfo(n$1);
			null !== e$2 && t$1.push(e$2);
		}
		return t$1;
	}
	_getStructInputs(e$1, t$1) {
		for (const n$1 of e$1.members) if (n$1.type instanceof oe) this._getStructInputs(n$1.type, t$1);
		else {
			const e$2 = this._getInputInfo(n$1);
			null !== e$2 && t$1.push(e$2);
		}
	}
	_getInputInfo(e$1) {
		const t$1 = this._getAttribute(e$1, "location") || this._getAttribute(e$1, "builtin");
		if (null !== t$1) {
			const n$1 = this._getAttribute(e$1, "interpolation"), s$1 = this.getTypeInfo(e$1.type, e$1.attributes), r$1 = this._parseInt(t$1.value), a$1 = new l(e$1.name, s$1, t$1.name, r$1);
			return null !== n$1 && (a$1.interpolation = this._parseString(n$1.value)), a$1;
		}
		return null;
	}
	_parseString(e$1) {
		return e$1 instanceof Array && (e$1 = e$1[0]), e$1;
	}
	_parseInt(e$1) {
		e$1 instanceof Array && (e$1 = e$1[0]);
		const t$1 = parseInt(e$1);
		return isNaN(t$1) ? e$1 : t$1;
	}
	_getAlias(e$1) {
		for (const t$1 of this.aliases) if (t$1.name == e$1) return t$1.type;
		return null;
	}
	_getAliasInfo(e$1) {
		return new c(e$1.name, this.getTypeInfo(e$1.type, null));
	}
	getTypeInfoByName(e$1) {
		for (const t$1 of this.structs) if (t$1.name == e$1) return t$1;
		for (const t$1 of this.aliases) if (t$1.name == e$1) return t$1.type;
		return null;
	}
	getTypeInfo(i$1, o$1 = null) {
		if (this._types.has(i$1)) return this._types.get(i$1);
		if (i$1 instanceof le) {
			const e$1 = i$1.type ? this.getTypeInfo(i$1.type, i$1.attributes) : null, t$1 = new r(i$1.name, e$1, o$1);
			return this._types.set(i$1, t$1), this._updateTypeInfo(t$1), t$1;
		}
		if (i$1 instanceof ue) {
			const e$1 = i$1, t$1 = e$1.format ? this.getTypeInfo(e$1.format, e$1.attributes) : null, n$1 = new s(e$1.name, o$1);
			return n$1.format = t$1, n$1.count = e$1.count, this._types.set(i$1, n$1), this._updateTypeInfo(n$1), n$1;
		}
		if (i$1 instanceof oe) {
			const e$1 = i$1, s$1 = new n(e$1.name, o$1);
			s$1.startLine = e$1.startLine, s$1.endLine = e$1.endLine;
			for (const n$1 of e$1.members) {
				const e$2 = this.getTypeInfo(n$1.type, n$1.attributes);
				s$1.members.push(new t(n$1.name, e$2, n$1.attributes));
			}
			return this._types.set(i$1, s$1), this._updateTypeInfo(s$1), s$1;
		}
		if (i$1 instanceof he) {
			const t$1 = i$1, n$1 = t$1.format instanceof ae, s$1 = t$1.format ? n$1 ? this.getTypeInfo(t$1.format, null) : new e(t$1.format, null) : null, r$1 = new a(t$1.name, s$1, o$1, t$1.access);
			return this._types.set(i$1, r$1), this._updateTypeInfo(r$1), r$1;
		}
		if (i$1 instanceof ce) {
			const e$1 = i$1, t$1 = e$1.format ? this.getTypeInfo(e$1.format, null) : null, n$1 = new a(e$1.name, t$1, o$1, e$1.access);
			return this._types.set(i$1, n$1), this._updateTypeInfo(n$1), n$1;
		}
		const c$1 = new e(i$1.name, o$1);
		return this._types.set(i$1, c$1), this._updateTypeInfo(c$1), c$1;
	}
	_updateTypeInfo(e$1) {
		var t$1, a$1, i$1;
		const o$1 = this._getTypeSize(e$1);
		if (e$1.size = null !== (t$1 = null == o$1 ? void 0 : o$1.size) && void 0 !== t$1 ? t$1 : 0, e$1 instanceof s && e$1.format) {
			const t$2 = this._getTypeSize(e$1.format);
			e$1.stride = Math.max(null !== (a$1 = null == t$2 ? void 0 : t$2.size) && void 0 !== a$1 ? a$1 : 0, null !== (i$1 = null == t$2 ? void 0 : t$2.align) && void 0 !== i$1 ? i$1 : 0), this._updateTypeInfo(e$1.format);
		}
		e$1 instanceof r && this._updateTypeInfo(e$1.format), e$1 instanceof n && this._updateStructInfo(e$1);
	}
	_updateStructInfo(e$1) {
		var t$1;
		let n$1 = 0, s$1 = 0, r$1 = 0, a$1 = 0;
		for (let i$1 = 0, o$1 = e$1.members.length; i$1 < o$1; ++i$1) {
			const o$2 = e$1.members[i$1], c$1 = this._getTypeSize(o$2);
			if (!c$1) continue;
			null !== (t$1 = this._getAlias(o$2.type.name)) && void 0 !== t$1 || o$2.type;
			const l$1 = c$1.align, u$1 = c$1.size;
			n$1 = this._roundUp(l$1, n$1 + s$1), s$1 = u$1, r$1 = n$1, a$1 = Math.max(a$1, l$1), o$2.offset = n$1, o$2.size = u$1, this._updateTypeInfo(o$2.type);
		}
		e$1.size = this._roundUp(a$1, r$1 + s$1), e$1.align = a$1;
	}
	_getTypeSize(r$1) {
		var a$1, i$1;
		if (null == r$1) return null;
		const o$1 = this._getAttributeNum(r$1.attributes, "size", 0), c$1 = this._getAttributeNum(r$1.attributes, "align", 0);
		if (r$1 instanceof t && (r$1 = r$1.type), r$1 instanceof e) {
			const e$1 = this._getAlias(r$1.name);
			null !== e$1 && (r$1 = e$1);
		}
		{
			const e$1 = at._typeInfo[r$1.name];
			if (void 0 !== e$1) {
				const t$1 = "f16" === (null === (a$1 = r$1.format) || void 0 === a$1 ? void 0 : a$1.name) ? 2 : 1;
				return new rt(Math.max(c$1, e$1.align / t$1), Math.max(o$1, e$1.size / t$1));
			}
		}
		{
			const e$1 = at._typeInfo[r$1.name.substring(0, r$1.name.length - 1)];
			if (e$1) {
				const t$1 = "h" === r$1.name[r$1.name.length - 1] ? 2 : 1;
				return new rt(Math.max(c$1, e$1.align / t$1), Math.max(o$1, e$1.size / t$1));
			}
		}
		if (r$1 instanceof s) {
			let e$1 = r$1, t$1 = 8, n$1 = 8;
			const s$1 = this._getTypeSize(e$1.format);
			null !== s$1 && (n$1 = s$1.size, t$1 = s$1.align);
			return n$1 = e$1.count * this._getAttributeNum(null !== (i$1 = null == r$1 ? void 0 : r$1.attributes) && void 0 !== i$1 ? i$1 : null, "stride", this._roundUp(t$1, n$1)), o$1 && (n$1 = o$1), new rt(Math.max(c$1, t$1), Math.max(o$1, n$1));
		}
		if (r$1 instanceof n) {
			let e$1 = 0, t$1 = 0, n$1 = 0, s$1 = 0, a$2 = 0;
			for (const t$2 of r$1.members) {
				const r$2 = this._getTypeSize(t$2.type);
				null !== r$2 && (e$1 = Math.max(r$2.align, e$1), n$1 = this._roundUp(r$2.align, n$1 + s$1), s$1 = r$2.size, a$2 = n$1);
			}
			return t$1 = this._roundUp(e$1, a$2 + s$1), new rt(Math.max(c$1, e$1), Math.max(o$1, t$1));
		}
		return null;
	}
	_isUniformVar(e$1) {
		return e$1 instanceof F && "uniform" == e$1.storage;
	}
	_isStorageVar(e$1) {
		return e$1 instanceof F && "storage" == e$1.storage;
	}
	_isTextureVar(e$1) {
		return e$1 instanceof F && null !== e$1.type && -1 != at._textureTypes.indexOf(e$1.type.name);
	}
	_isSamplerVar(e$1) {
		return e$1 instanceof F && null !== e$1.type && -1 != at._samplerTypes.indexOf(e$1.type.name);
	}
	_getAttribute(e$1, t$1) {
		const n$1 = e$1;
		if (!n$1 || !n$1.attributes) return null;
		const s$1 = n$1.attributes;
		for (let e$2 of s$1) if (e$2.name == t$1) return e$2;
		return null;
	}
	_getAttributeNum(e$1, t$1, n$1) {
		if (null === e$1) return n$1;
		for (let s$1 of e$1) if (s$1.name == t$1) {
			let e$2 = null !== s$1 && null !== s$1.value ? s$1.value : n$1;
			return e$2 instanceof Array && (e$2 = e$2[0]), "number" == typeof e$2 ? e$2 : "string" == typeof e$2 ? parseInt(e$2) : n$1;
		}
		return n$1;
	}
	_roundUp(e$1, t$1) {
		return Math.ceil(t$1 / e$1) * e$1;
	}
};
at._typeInfo = {
	f16: {
		align: 2,
		size: 2
	},
	i32: {
		align: 4,
		size: 4
	},
	u32: {
		align: 4,
		size: 4
	},
	f32: {
		align: 4,
		size: 4
	},
	atomic: {
		align: 4,
		size: 4
	},
	vec2: {
		align: 8,
		size: 8
	},
	vec3: {
		align: 16,
		size: 12
	},
	vec4: {
		align: 16,
		size: 16
	},
	mat2x2: {
		align: 8,
		size: 16
	},
	mat3x2: {
		align: 8,
		size: 24
	},
	mat4x2: {
		align: 8,
		size: 32
	},
	mat2x3: {
		align: 16,
		size: 32
	},
	mat3x3: {
		align: 16,
		size: 48
	},
	mat4x3: {
		align: 16,
		size: 64
	},
	mat2x4: {
		align: 16,
		size: 32
	},
	mat3x4: {
		align: 16,
		size: 48
	},
	mat4x4: {
		align: 16,
		size: 64
	}
}, at._textureTypes = He.any_texture_type.map((e$1) => e$1.name), at._samplerTypes = He.sampler_type.map((e$1) => e$1.name);
var it = 0;
var ot = class ot {
	constructor(e$1, t$1, n$1) {
		this.id = it++, this.name = e$1, this.value = t$1, this.node = n$1;
	}
	clone() {
		return new ot(this.name, this.value, this.node);
	}
};
var ct = class ct {
	constructor(e$1) {
		this.id = it++, this.name = e$1.name, this.node = e$1;
	}
	clone() {
		return new ct(this.node);
	}
};
var lt = class lt {
	constructor(e$1) {
		this.parent = null, this.variables = /* @__PURE__ */ new Map(), this.functions = /* @__PURE__ */ new Map(), this.currentFunctionName = "", this.id = it++, e$1 && (this.parent = e$1, this.currentFunctionName = e$1.currentFunctionName);
	}
	getVariable(e$1) {
		var t$1;
		return this.variables.has(e$1) ? null !== (t$1 = this.variables.get(e$1)) && void 0 !== t$1 ? t$1 : null : this.parent ? this.parent.getVariable(e$1) : null;
	}
	getFunction(e$1) {
		var t$1;
		return this.functions.has(e$1) ? null !== (t$1 = this.functions.get(e$1)) && void 0 !== t$1 ? t$1 : null : this.parent ? this.parent.getFunction(e$1) : null;
	}
	createVariable(e$1, t$1, n$1) {
		this.variables.set(e$1, new ot(e$1, t$1, null != n$1 ? n$1 : null));
	}
	setVariable(e$1, t$1, n$1) {
		const s$1 = this.getVariable(e$1);
		null !== s$1 ? s$1.value = t$1 : this.createVariable(e$1, t$1, n$1);
	}
	getVariableValue(e$1) {
		var t$1;
		const n$1 = this.getVariable(e$1);
		return null !== (t$1 = null == n$1 ? void 0 : n$1.value) && void 0 !== t$1 ? t$1 : null;
	}
	clone() {
		return new lt(this);
	}
};
var ut = class {
	evalExpression(e$1, t$1) {
		return null;
	}
	getTypeInfo(e$1) {
		return null;
	}
	getVariableName(e$1, t$1) {
		return "";
	}
};
var ht = class {
	constructor(e$1) {
		this.exec = e$1;
	}
	getTypeInfo(e$1) {
		return this.exec.getTypeInfo(e$1);
	}
	All(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		let s$1 = !0;
		if (n$1 instanceof Me) return n$1.data.forEach((e$2) => {
			e$2 || (s$1 = !1);
		}), new Be(s$1 ? 1 : 0, this.getTypeInfo("bool"));
		throw new Error(`All() expects a vector argument. Line ${e$1.line}`);
	}
	Any(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Be(n$1.data.some((e$2) => e$2) ? 1 : 0, this.getTypeInfo("bool"));
		throw new Error(`Any() expects a vector argument. Line ${e$1.line}`);
	}
	Select(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[2], t$1);
		if (!(n$1 instanceof Be)) throw new Error(`Select() expects a bool condition. Line ${e$1.line}`);
		return n$1.value ? this.exec.evalExpression(e$1.args[1], t$1) : this.exec.evalExpression(e$1.args[0], t$1);
	}
	ArrayLength(e$1, t$1) {
		let n$1 = e$1.args[0];
		n$1 instanceof ke && (n$1 = n$1.right);
		const s$1 = this.exec.evalExpression(n$1, t$1);
		if (s$1 instanceof Pe && 0 === s$1.typeInfo.size) {
			const e$2 = s$1.typeInfo;
			return new Be(s$1.buffer.byteLength / e$2.stride, this.getTypeInfo("u32"));
		}
		return new Be(s$1.typeInfo.size, this.getTypeInfo("u32"));
	}
	Abs(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => Math.abs(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.abs(s$1.value), s$1.typeInfo);
	}
	Acos(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => Math.acos(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.acos(s$1.value), n$1.typeInfo);
	}
	Acosh(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => Math.acosh(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.acosh(s$1.value), n$1.typeInfo);
	}
	Asin(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => Math.asin(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.asin(s$1.value), n$1.typeInfo);
	}
	Asinh(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => Math.asinh(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.asinh(s$1.value), n$1.typeInfo);
	}
	Atan(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => Math.atan(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.atan(s$1.value), n$1.typeInfo);
	}
	Atanh(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => Math.atanh(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.atanh(s$1.value), n$1.typeInfo);
	}
	Atan2(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1), s$1 = this.exec.evalExpression(e$1.args[1], t$1);
		if (n$1 instanceof Me && s$1 instanceof Me) return new Me(n$1.data.map((e$2, t$2) => Math.atan2(e$2, s$1.data[t$2])), n$1.typeInfo);
		const r$1 = n$1, a$1 = s$1;
		return new Be(Math.atan2(r$1.value, a$1.value), n$1.typeInfo);
	}
	Ceil(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => Math.ceil(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.ceil(s$1.value), n$1.typeInfo);
	}
	_clamp(e$1, t$1, n$1) {
		return Math.min(Math.max(e$1, t$1), n$1);
	}
	Clamp(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1), s$1 = this.exec.evalExpression(e$1.args[1], t$1), r$1 = this.exec.evalExpression(e$1.args[2], t$1);
		if (n$1 instanceof Me && s$1 instanceof Me && r$1 instanceof Me) return new Me(n$1.data.map((e$2, t$2) => this._clamp(e$2, s$1.data[t$2], r$1.data[t$2])), n$1.typeInfo);
		const a$1 = n$1, i$1 = s$1, o$1 = r$1;
		return new Be(this._clamp(a$1.value, i$1.value, o$1.value), n$1.typeInfo);
	}
	Cos(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => Math.cos(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.cos(s$1.value), n$1.typeInfo);
	}
	Cosh(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => Math.cosh(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.cos(s$1.value), n$1.typeInfo);
	}
	CountLeadingZeros(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => Math.clz32(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.clz32(s$1.value), n$1.typeInfo);
	}
	_countOneBits(e$1) {
		let t$1 = 0;
		for (; 0 !== e$1;) 1 & e$1 && t$1++, e$1 >>= 1;
		return t$1;
	}
	CountOneBits(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => this._countOneBits(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(this._countOneBits(s$1.value), n$1.typeInfo);
	}
	_countTrailingZeros(e$1) {
		if (0 === e$1) return 32;
		let t$1 = 0;
		for (; !(1 & e$1);) e$1 >>= 1, t$1++;
		return t$1;
	}
	CountTrailingZeros(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => this._countTrailingZeros(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(this._countTrailingZeros(s$1.value), n$1.typeInfo);
	}
	Cross(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1), s$1 = this.exec.evalExpression(e$1.args[1], t$1);
		if (n$1 instanceof Me && s$1 instanceof Me) {
			if (3 !== n$1.data.length || 3 !== s$1.data.length) return console.error(`Cross() expects 3D vectors. Line ${e$1.line}`), null;
			const t$2 = n$1.data, r$1 = s$1.data;
			return new Me([
				t$2[1] * r$1[2] - r$1[1] * t$2[2],
				t$2[2] * r$1[0] - r$1[2] * t$2[0],
				t$2[0] * r$1[1] - r$1[0] * t$2[1]
			], n$1.typeInfo);
		}
		return console.error(`Cross() expects vector arguments. Line ${e$1.line}`), null;
	}
	Degrees(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1), s$1 = 180 / Math.PI;
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => e$2 * s$1), n$1.typeInfo);
		return new Be(n$1.value * s$1, this.getTypeInfo("f32"));
	}
	Determinant(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Ue) {
			const e$2 = n$1.data, t$2 = n$1.typeInfo.getTypeName(), s$1 = t$2.endsWith("h") ? this.getTypeInfo("f16") : this.getTypeInfo("f32");
			if ("mat2x2" === t$2 || "mat2x2f" === t$2 || "mat2x2h" === t$2) return new Be(e$2[0] * e$2[3] - e$2[1] * e$2[2], s$1);
			if ("mat2x3" === t$2 || "mat2x3f" === t$2 || "mat2x3h" === t$2) return new Be(e$2[0] * (e$2[4] * e$2[8] - e$2[5] * e$2[7]) - e$2[1] * (e$2[3] * e$2[8] - e$2[5] * e$2[6]) + e$2[2] * (e$2[3] * e$2[7] - e$2[4] * e$2[6]), s$1);
			if ("mat2x4" === t$2 || "mat2x4f" === t$2 || "mat2x4h" === t$2) console.error(`TODO: Determinant for ${t$2}`);
			else if ("mat3x2" === t$2 || "mat3x2f" === t$2 || "mat3x2h" === t$2) console.error(`TODO: Determinant for ${t$2}`);
			else {
				if ("mat3x3" === t$2 || "mat3x3f" === t$2 || "mat3x3h" === t$2) return new Be(e$2[0] * (e$2[4] * e$2[8] - e$2[5] * e$2[7]) - e$2[1] * (e$2[3] * e$2[8] - e$2[5] * e$2[6]) + e$2[2] * (e$2[3] * e$2[7] - e$2[4] * e$2[6]), s$1);
				"mat3x4" === t$2 || "mat3x4f" === t$2 || "mat3x4h" === t$2 || "mat4x2" === t$2 || "mat4x2f" === t$2 || "mat4x2h" === t$2 || "mat4x3" === t$2 || "mat4x3f" === t$2 || "mat4x3h" === t$2 ? console.error(`TODO: Determinant for ${t$2}`) : "mat4x4" !== t$2 && "mat4x4f" !== t$2 && "mat4x4h" !== t$2 || console.error(`TODO: Determinant for ${t$2}`);
			}
		}
		return console.error(`Determinant expects a matrix argument. Line ${e$1.line}`), null;
	}
	Distance(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1), s$1 = this.exec.evalExpression(e$1.args[1], t$1);
		if (n$1 instanceof Me && s$1 instanceof Me) {
			let e$2 = 0;
			for (let t$2 = 0; t$2 < n$1.data.length; ++t$2) e$2 += (n$1.data[t$2] - s$1.data[t$2]) * (n$1.data[t$2] - s$1.data[t$2]);
			return new Be(Math.sqrt(e$2), this.getTypeInfo("f32"));
		}
		const r$1 = n$1, a$1 = s$1;
		return new Be(Math.abs(r$1.value - a$1.value), n$1.typeInfo);
	}
	_dot(e$1, t$1) {
		let n$1 = 0;
		for (let s$1 = 0; s$1 < e$1.length; ++s$1) n$1 += t$1[s$1] * e$1[s$1];
		return n$1;
	}
	Dot(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1), s$1 = this.exec.evalExpression(e$1.args[1], t$1);
		return n$1 instanceof Me && s$1 instanceof Me ? new Be(this._dot(n$1.data, s$1.data), this.getTypeInfo("f32")) : (console.error(`Dot() expects vector arguments. Line ${e$1.line}`), null);
	}
	Dot4U8Packed(e$1, t$1) {
		return console.error(`TODO: dot4U8Packed. Line ${e$1.line}`), null;
	}
	Dot4I8Packed(e$1, t$1) {
		return console.error(`TODO: dot4I8Packed. Line ${e$1.line}`), null;
	}
	Exp(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => Math.exp(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.exp(s$1.value), n$1.typeInfo);
	}
	Exp2(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => Math.pow(2, e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.pow(2, s$1.value), n$1.typeInfo);
	}
	ExtractBits(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1), s$1 = this.exec.evalExpression(e$1.args[1], t$1), r$1 = this.exec.evalExpression(e$1.args[2], t$1);
		if ("u32" !== s$1.typeInfo.name && "x32" !== s$1.typeInfo.name) return console.error(`ExtractBits() expects an i32 offset argument. Line ${e$1.line}`), null;
		if ("u32" !== r$1.typeInfo.name && "x32" !== r$1.typeInfo.name) return console.error(`ExtractBits() expects an i32 count argument. Line ${e$1.line}`), null;
		const a$1 = s$1.value, i$1 = r$1.value;
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => e$2 >> a$1 & (1 << i$1) - 1), n$1.typeInfo);
		if ("i32" !== n$1.typeInfo.name && "x32" !== n$1.typeInfo.name) return console.error(`ExtractBits() expects an i32 argument. Line ${e$1.line}`), null;
		const o$1 = n$1.value;
		return new Be(o$1 >> a$1 & (1 << i$1) - 1, this.getTypeInfo("i32"));
	}
	FaceForward(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1), s$1 = this.exec.evalExpression(e$1.args[1], t$1), r$1 = this.exec.evalExpression(e$1.args[2], t$1);
		if (n$1 instanceof Me && s$1 instanceof Me && r$1 instanceof Me) return new Me(this._dot(s$1.data, r$1.data) < 0 ? Array.from(n$1.data) : n$1.data.map((e$2) => -e$2), n$1.typeInfo);
		return console.error(`FaceForward() expects vector arguments. Line ${e$1.line}`), null;
	}
	_firstLeadingBit(e$1) {
		return 0 === e$1 ? -1 : 31 - Math.clz32(e$1);
	}
	FirstLeadingBit(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => this._firstLeadingBit(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(this._firstLeadingBit(s$1.value), n$1.typeInfo);
	}
	_firstTrailingBit(e$1) {
		return 0 === e$1 ? -1 : Math.log2(e$1 & -e$1);
	}
	FirstTrailingBit(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => this._firstTrailingBit(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(this._firstTrailingBit(s$1.value), n$1.typeInfo);
	}
	Floor(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => Math.floor(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.floor(s$1.value), n$1.typeInfo);
	}
	Fma(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1), s$1 = this.exec.evalExpression(e$1.args[1], t$1), r$1 = this.exec.evalExpression(e$1.args[2], t$1);
		if (n$1 instanceof Me && s$1 instanceof Me && r$1 instanceof Me) return n$1.data.length !== s$1.data.length || n$1.data.length !== r$1.data.length ? (console.error(`Fma() expects vectors of the same length. Line ${e$1.line}`), null) : new Me(n$1.data.map((e$2, t$2) => e$2 * s$1.data[t$2] + r$1.data[t$2]), n$1.typeInfo);
		const a$1 = n$1, i$1 = s$1, o$1 = r$1;
		return new Be(a$1.value * i$1.value + o$1.value, a$1.typeInfo);
	}
	Fract(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => e$2 - Math.floor(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(s$1.value - Math.floor(s$1.value), n$1.typeInfo);
	}
	Frexp(e$1, t$1) {
		return console.error(`TODO: frexp. Line ${e$1.line}`), null;
	}
	InsertBits(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1), s$1 = this.exec.evalExpression(e$1.args[1], t$1), r$1 = this.exec.evalExpression(e$1.args[2], t$1), a$1 = this.exec.evalExpression(e$1.args[3], t$1);
		if ("u32" !== r$1.typeInfo.name && "x32" !== r$1.typeInfo.name) return console.error(`InsertBits() expects an i32 offset argument. Line ${e$1.line}`), null;
		const i$1 = r$1.value, o$1 = (1 << a$1.value) - 1 << i$1, c$1 = ~o$1;
		if (n$1 instanceof Me && s$1 instanceof Me) return new Me(n$1.data.map((e$2, t$2) => e$2 & c$1 | s$1.data[t$2] << i$1 & o$1), n$1.typeInfo);
		const l$1 = n$1.value, u$1 = s$1.value;
		return new Be(l$1 & c$1 | u$1 << i$1 & o$1, n$1.typeInfo);
	}
	InverseSqrt(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => 1 / Math.sqrt(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(1 / Math.sqrt(s$1.value), n$1.typeInfo);
	}
	Ldexp(e$1, t$1) {
		return console.error(`TODO: ldexp. Line ${e$1.line}`), null;
	}
	Length(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) {
			let e$2 = 0;
			return n$1.data.forEach((t$2) => {
				e$2 += t$2 * t$2;
			}), new Be(Math.sqrt(e$2), this.getTypeInfo("f32"));
		}
		const s$1 = n$1;
		return new Be(Math.abs(s$1.value), n$1.typeInfo);
	}
	Log(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => Math.log(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.log(s$1.value), n$1.typeInfo);
	}
	Log2(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => Math.log2(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.log2(s$1.value), n$1.typeInfo);
	}
	Max(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1), s$1 = this.exec.evalExpression(e$1.args[1], t$1);
		if (n$1 instanceof Me && s$1 instanceof Me) return new Me(n$1.data.map((e$2, t$2) => Math.max(e$2, s$1.data[t$2])), n$1.typeInfo);
		const r$1 = n$1, a$1 = s$1;
		return new Be(Math.max(r$1.value, a$1.value), n$1.typeInfo);
	}
	Min(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1), s$1 = this.exec.evalExpression(e$1.args[1], t$1);
		if (n$1 instanceof Me && s$1 instanceof Me) return new Me(n$1.data.map((e$2, t$2) => Math.min(e$2, s$1.data[t$2])), n$1.typeInfo);
		const r$1 = n$1, a$1 = s$1;
		return new Be(Math.min(r$1.value, a$1.value), n$1.typeInfo);
	}
	Mix(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1), s$1 = this.exec.evalExpression(e$1.args[1], t$1), r$1 = this.exec.evalExpression(e$1.args[2], t$1);
		if (n$1 instanceof Me && s$1 instanceof Me && r$1 instanceof Me) return new Me(n$1.data.map((e$2, t$2) => n$1.data[t$2] * (1 - r$1.data[t$2]) + s$1.data[t$2] * r$1.data[t$2]), n$1.typeInfo);
		const a$1 = s$1, i$1 = r$1;
		return new Be(n$1.value * (1 - i$1.value) + a$1.value * i$1.value, n$1.typeInfo);
	}
	Modf(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1), s$1 = this.exec.evalExpression(e$1.args[1], t$1);
		if (n$1 instanceof Me && s$1 instanceof Me) return new Me(n$1.data.map((e$2, t$2) => e$2 % s$1.data[t$2]), n$1.typeInfo);
		const r$1 = s$1;
		return new Be(n$1.value % r$1.value, n$1.typeInfo);
	}
	Normalize(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) {
			const s$1 = this.Length(e$1, t$1).value;
			return new Me(n$1.data.map((e$2) => e$2 / s$1), n$1.typeInfo);
		}
		return console.error(`Normalize() expects a vector argument. Line ${e$1.line}`), null;
	}
	Pow(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1), s$1 = this.exec.evalExpression(e$1.args[1], t$1);
		if (n$1 instanceof Me && s$1 instanceof Me) return new Me(n$1.data.map((e$2, t$2) => Math.pow(e$2, s$1.data[t$2])), n$1.typeInfo);
		const r$1 = n$1, a$1 = s$1;
		return new Be(Math.pow(r$1.value, a$1.value), n$1.typeInfo);
	}
	QuantizeToF16(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => e$2), n$1.typeInfo);
		return new Be(n$1.value, n$1.typeInfo);
	}
	Radians(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => e$2 * Math.PI / 180), n$1.typeInfo);
		return new Be(n$1.value * Math.PI / 180, this.getTypeInfo("f32"));
	}
	Reflect(e$1, t$1) {
		let n$1 = this.exec.evalExpression(e$1.args[0], t$1), s$1 = this.exec.evalExpression(e$1.args[1], t$1);
		if (n$1 instanceof Me && s$1 instanceof Me) {
			const e$2 = this._dot(n$1.data, s$1.data);
			return new Me(n$1.data.map((t$2, n$2) => t$2 - 2 * e$2 * s$1.data[n$2]), n$1.typeInfo);
		}
		return console.error(`Reflect() expects vector arguments. Line ${e$1.line}`), null;
	}
	Refract(e$1, t$1) {
		let n$1 = this.exec.evalExpression(e$1.args[0], t$1), s$1 = this.exec.evalExpression(e$1.args[1], t$1), r$1 = this.exec.evalExpression(e$1.args[2], t$1);
		if (n$1 instanceof Me && s$1 instanceof Me && r$1 instanceof Be) {
			const e$2 = this._dot(s$1.data, n$1.data);
			return new Me(n$1.data.map((t$2, n$2) => {
				const a$1 = 1 - r$1.value * r$1.value * (1 - e$2 * e$2);
				if (a$1 < 0) return 0;
				const i$1 = Math.sqrt(a$1);
				return r$1.value * t$2 - (r$1.value * e$2 + i$1) * s$1.data[n$2];
			}), n$1.typeInfo);
		}
		return console.error(`Refract() expects vector arguments and a scalar argument. Line ${e$1.line}`), null;
	}
	ReverseBits(e$1, t$1) {
		return console.error(`TODO: reverseBits. Line ${e$1.line}`), null;
	}
	Round(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => Math.round(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.round(s$1.value), n$1.typeInfo);
	}
	Saturate(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => Math.min(Math.max(e$2, 0), 1)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.min(Math.max(s$1.value, 0), 1), n$1.typeInfo);
	}
	Sign(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => Math.sign(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.sign(s$1.value), n$1.typeInfo);
	}
	Sin(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => Math.sin(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.sin(s$1.value), n$1.typeInfo);
	}
	Sinh(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => Math.sinh(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.sinh(s$1.value), n$1.typeInfo);
	}
	_smoothstep(e$1, t$1, n$1) {
		const s$1 = Math.min(Math.max((n$1 - e$1) / (t$1 - e$1), 0), 1);
		return s$1 * s$1 * (3 - 2 * s$1);
	}
	SmoothStep(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1), s$1 = this.exec.evalExpression(e$1.args[1], t$1), r$1 = this.exec.evalExpression(e$1.args[2], t$1);
		if (r$1 instanceof Me && n$1 instanceof Me && s$1 instanceof Me) return new Me(r$1.data.map((e$2, t$2) => this._smoothstep(n$1.data[t$2], s$1.data[t$2], e$2)), r$1.typeInfo);
		const a$1 = n$1, i$1 = s$1, o$1 = r$1;
		return new Be(this._smoothstep(a$1.value, i$1.value, o$1.value), r$1.typeInfo);
	}
	Sqrt(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => Math.sqrt(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.sqrt(s$1.value), n$1.typeInfo);
	}
	Step(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1), s$1 = this.exec.evalExpression(e$1.args[1], t$1);
		if (s$1 instanceof Me && n$1 instanceof Me) return new Me(s$1.data.map((e$2, t$2) => e$2 < n$1.data[t$2] ? 0 : 1), s$1.typeInfo);
		const r$1 = n$1;
		return new Be(s$1.value < r$1.value ? 0 : 1, r$1.typeInfo);
	}
	Tan(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => Math.tan(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.tan(s$1.value), n$1.typeInfo);
	}
	Tanh(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => Math.tanh(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.tanh(s$1.value), n$1.typeInfo);
	}
	_getTransposeType(e$1) {
		const t$1 = e$1.getTypeName();
		return "mat2x2f" === t$1 || "mat2x2h" === t$1 ? e$1 : "mat2x3f" === t$1 ? this.getTypeInfo("mat3x2f") : "mat2x3h" === t$1 ? this.getTypeInfo("mat3x2h") : "mat2x4f" === t$1 ? this.getTypeInfo("mat4x2f") : "mat2x4h" === t$1 ? this.getTypeInfo("mat4x2h") : "mat3x2f" === t$1 ? this.getTypeInfo("mat2x3f") : "mat3x2h" === t$1 ? this.getTypeInfo("mat2x3h") : "mat3x3f" === t$1 || "mat3x3h" === t$1 ? e$1 : "mat3x4f" === t$1 ? this.getTypeInfo("mat4x3f") : "mat3x4h" === t$1 ? this.getTypeInfo("mat4x3h") : "mat4x2f" === t$1 ? this.getTypeInfo("mat2x4f") : "mat4x2h" === t$1 ? this.getTypeInfo("mat2x4h") : "mat4x3f" === t$1 ? this.getTypeInfo("mat3x4f") : "mat4x3h" === t$1 ? this.getTypeInfo("mat3x4h") : ("mat4x4f" === t$1 || "mat4x4h" === t$1 || console.error(`Invalid matrix type ${t$1}`), e$1);
	}
	Transpose(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (!(n$1 instanceof Ue)) return console.error(`Transpose() expects a matrix argument. Line ${e$1.line}`), null;
		const s$1 = this._getTransposeType(n$1.typeInfo);
		if ("mat2x2" === n$1.typeInfo.name || "mat2x2f" === n$1.typeInfo.name || "mat2x2h" === n$1.typeInfo.name) {
			const e$2 = n$1.data;
			return new Ue([
				e$2[0],
				e$2[2],
				e$2[1],
				e$2[3]
			], s$1);
		}
		if ("mat2x3" === n$1.typeInfo.name || "mat2x3f" === n$1.typeInfo.name || "mat2x3h" === n$1.typeInfo.name) {
			const e$2 = n$1.data;
			return new Ue([
				e$2[0],
				e$2[3],
				e$2[6],
				e$2[1],
				e$2[4],
				e$2[7]
			], s$1);
		}
		if ("mat2x4" === n$1.typeInfo.name || "mat2x4f" === n$1.typeInfo.name || "mat2x4h" === n$1.typeInfo.name) {
			const e$2 = n$1.data;
			return new Ue([
				e$2[0],
				e$2[4],
				e$2[8],
				e$2[12],
				e$2[1],
				e$2[5],
				e$2[9],
				e$2[13]
			], s$1);
		}
		if ("mat3x2" === n$1.typeInfo.name || "mat3x2f" === n$1.typeInfo.name || "mat3x2h" === n$1.typeInfo.name) {
			const e$2 = n$1.data;
			return new Ue([
				e$2[0],
				e$2[3],
				e$2[1],
				e$2[4],
				e$2[2],
				e$2[5]
			], s$1);
		}
		if ("mat3x3" === n$1.typeInfo.name || "mat3x3f" === n$1.typeInfo.name || "mat3x3h" === n$1.typeInfo.name) {
			const e$2 = n$1.data;
			return new Ue([
				e$2[0],
				e$2[3],
				e$2[6],
				e$2[1],
				e$2[4],
				e$2[7],
				e$2[2],
				e$2[5],
				e$2[8]
			], s$1);
		}
		if ("mat3x4" === n$1.typeInfo.name || "mat3x4f" === n$1.typeInfo.name || "mat3x4h" === n$1.typeInfo.name) {
			const e$2 = n$1.data;
			return new Ue([
				e$2[0],
				e$2[4],
				e$2[8],
				e$2[12],
				e$2[1],
				e$2[5],
				e$2[9],
				e$2[13],
				e$2[2],
				e$2[6],
				e$2[10],
				e$2[14]
			], s$1);
		}
		if ("mat4x2" === n$1.typeInfo.name || "mat4x2f" === n$1.typeInfo.name || "mat4x2h" === n$1.typeInfo.name) {
			const e$2 = n$1.data;
			return new Ue([
				e$2[0],
				e$2[4],
				e$2[1],
				e$2[5],
				e$2[2],
				e$2[6]
			], s$1);
		}
		if ("mat4x3" === n$1.typeInfo.name || "mat4x3f" === n$1.typeInfo.name || "mat4x3h" === n$1.typeInfo.name) {
			const e$2 = n$1.data;
			return new Ue([
				e$2[0],
				e$2[4],
				e$2[8],
				e$2[1],
				e$2[5],
				e$2[9],
				e$2[2],
				e$2[6],
				e$2[10]
			], s$1);
		}
		if ("mat4x4" === n$1.typeInfo.name || "mat4x4f" === n$1.typeInfo.name || "mat4x4h" === n$1.typeInfo.name) {
			const e$2 = n$1.data;
			return new Ue([
				e$2[0],
				e$2[4],
				e$2[8],
				e$2[12],
				e$2[1],
				e$2[5],
				e$2[9],
				e$2[13],
				e$2[2],
				e$2[6],
				e$2[10],
				e$2[14],
				e$2[3],
				e$2[7],
				e$2[11],
				e$2[15]
			], s$1);
		}
		return console.error(`Invalid matrix type ${n$1.typeInfo.name}`), null;
	}
	Trunc(e$1, t$1) {
		const n$1 = this.exec.evalExpression(e$1.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$2) => Math.trunc(e$2)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.trunc(s$1.value), n$1.typeInfo);
	}
	Dpdx(e$1, t$1) {
		return console.error(`TODO: dpdx. Line ${e$1.line}`), null;
	}
	DpdxCoarse(e$1, t$1) {
		return console.error(`TODO: dpdxCoarse. Line ${e$1.line}`), null;
	}
	DpdxFine(e$1, t$1) {
		return console.error("TODO: dpdxFine"), null;
	}
	Dpdy(e$1, t$1) {
		return console.error("TODO: dpdy"), null;
	}
	DpdyCoarse(e$1, t$1) {
		return console.error("TODO: dpdyCoarse"), null;
	}
	DpdyFine(e$1, t$1) {
		return console.error("TODO: dpdyFine"), null;
	}
	Fwidth(e$1, t$1) {
		return console.error("TODO: fwidth"), null;
	}
	FwidthCoarse(e$1, t$1) {
		return console.error("TODO: fwidthCoarse"), null;
	}
	FwidthFine(e$1, t$1) {
		return console.error("TODO: fwidthFine"), null;
	}
	TextureDimensions(e$1, t$1) {
		const n$1 = e$1.args[0], s$1 = e$1.args.length > 1 ? this.exec.evalExpression(e$1.args[1], t$1).value : 0;
		if (n$1 instanceof ge) {
			const r$1 = n$1.name, a$1 = t$1.getVariableValue(r$1);
			if (a$1 instanceof We) {
				if (s$1 < 0 || s$1 >= a$1.mipLevelCount) return console.error(`Invalid mip level for textureDimensions. Line ${e$1.line}`), null;
				const t$2 = a$1.getMipLevelSize(s$1), n$2 = a$1.dimension;
				return "1d" === n$2 ? new Be(t$2[0], this.getTypeInfo("u32")) : "3d" === n$2 ? new Me(t$2, this.getTypeInfo("vec3u")) : "2d" === n$2 ? new Me(t$2.slice(0, 2), this.getTypeInfo("vec2u")) : (console.error(`Invalid texture dimension ${n$2} not found. Line ${e$1.line}`), null);
			}
			return console.error(`Texture ${r$1} not found. Line ${e$1.line}`), null;
		}
		return console.error(`Invalid texture argument for textureDimensions. Line ${e$1.line}`), null;
	}
	TextureGather(e$1, t$1) {
		return console.error("TODO: textureGather"), null;
	}
	TextureGatherCompare(e$1, t$1) {
		return console.error("TODO: textureGatherCompare"), null;
	}
	TextureLoad(e$1, t$1) {
		const n$1 = e$1.args[0], s$1 = this.exec.evalExpression(e$1.args[1], t$1), r$1 = e$1.args.length > 2 ? this.exec.evalExpression(e$1.args[2], t$1).value : 0;
		if (!(s$1 instanceof Me) || 2 !== s$1.data.length) return console.error(`Invalid UV argument for textureLoad. Line ${e$1.line}`), null;
		if (n$1 instanceof ge) {
			const a$1 = n$1.name, i$1 = t$1.getVariableValue(a$1);
			if (i$1 instanceof We) {
				const t$2 = Math.floor(s$1.data[0]), n$2 = Math.floor(s$1.data[1]);
				if (t$2 < 0 || t$2 >= i$1.width || n$2 < 0 || n$2 >= i$1.height) return console.error(`Texture ${a$1} out of bounds. Line ${e$1.line}`), null;
				const o$1 = i$1.getPixel(t$2, n$2, 0, r$1);
				return null === o$1 ? (console.error(`Invalid texture format for textureLoad. Line ${e$1.line}`), null) : new Me(o$1, this.getTypeInfo("vec4f"));
			}
			return console.error(`Texture ${a$1} not found. Line ${e$1.line}`), null;
		}
		return console.error(`Invalid texture argument for textureLoad. Line ${e$1.line}`), null;
	}
	TextureNumLayers(e$1, t$1) {
		const n$1 = e$1.args[0];
		if (n$1 instanceof ge) {
			const s$1 = n$1.name, r$1 = t$1.getVariableValue(s$1);
			return r$1 instanceof We ? new Be(r$1.depthOrArrayLayers, this.getTypeInfo("u32")) : (console.error(`Texture ${s$1} not found. Line ${e$1.line}`), null);
		}
		return console.error(`Invalid texture argument for textureNumLayers. Line ${e$1.line}`), null;
	}
	TextureNumLevels(e$1, t$1) {
		const n$1 = e$1.args[0];
		if (n$1 instanceof ge) {
			const s$1 = n$1.name, r$1 = t$1.getVariableValue(s$1);
			return r$1 instanceof We ? new Be(r$1.mipLevelCount, this.getTypeInfo("u32")) : (console.error(`Texture ${s$1} not found. Line ${e$1.line}`), null);
		}
		return console.error(`Invalid texture argument for textureNumLevels. Line ${e$1.line}`), null;
	}
	TextureNumSamples(e$1, t$1) {
		const n$1 = e$1.args[0];
		if (n$1 instanceof ge) {
			const s$1 = n$1.name, r$1 = t$1.getVariableValue(s$1);
			return r$1 instanceof We ? new Be(r$1.sampleCount, this.getTypeInfo("u32")) : (console.error(`Texture ${s$1} not found. Line ${e$1.line}`), null);
		}
		return console.error(`Invalid texture argument for textureNumSamples. Line ${e$1.line}`), null;
	}
	TextureSample(e$1, t$1) {
		return console.error("TODO: textureSample"), null;
	}
	TextureSampleBias(e$1, t$1) {
		return console.error("TODO: textureSampleBias"), null;
	}
	TextureSampleCompare(e$1, t$1) {
		return console.error("TODO: textureSampleCompare"), null;
	}
	TextureSampleCompareLevel(e$1, t$1) {
		return console.error("TODO: textureSampleCompareLevel"), null;
	}
	TextureSampleGrad(e$1, t$1) {
		return console.error("TODO: textureSampleGrad"), null;
	}
	TextureSampleLevel(e$1, t$1) {
		return console.error("TODO: textureSampleLevel"), null;
	}
	TextureSampleBaseClampToEdge(e$1, t$1) {
		return console.error("TODO: textureSampleBaseClampToEdge"), null;
	}
	TextureStore(e$1, t$1) {
		const n$1 = e$1.args[0], s$1 = this.exec.evalExpression(e$1.args[1], t$1), r$1 = 4 === e$1.args.length ? this.exec.evalExpression(e$1.args[2], t$1).value : 0, a$1 = 4 === e$1.args.length ? this.exec.evalExpression(e$1.args[3], t$1).data : this.exec.evalExpression(e$1.args[2], t$1).data;
		if (4 !== a$1.length) return console.error(`Invalid value argument for textureStore. Line ${e$1.line}`), null;
		if (!(s$1 instanceof Me) || 2 !== s$1.data.length) return console.error(`Invalid UV argument for textureStore. Line ${e$1.line}`), null;
		if (n$1 instanceof ge) {
			const i$1 = n$1.name, o$1 = t$1.getVariableValue(i$1);
			if (o$1 instanceof We) {
				const t$2 = o$1.getMipLevelSize(0), n$2 = Math.floor(s$1.data[0]), c$1 = Math.floor(s$1.data[1]);
				return n$2 < 0 || n$2 >= t$2[0] || c$1 < 0 || c$1 >= t$2[1] ? (console.error(`Texture ${i$1} out of bounds. Line ${e$1.line}`), null) : (o$1.setPixel(n$2, c$1, 0, r$1, Array.from(a$1)), null);
			}
			return console.error(`Texture ${i$1} not found. Line ${e$1.line}`), null;
		}
		return console.error(`Invalid texture argument for textureStore. Line ${e$1.line}`), null;
	}
	AtomicLoad(e$1, t$1) {
		let n$1 = e$1.args[0];
		n$1 instanceof ke && (n$1 = n$1.right);
		const s$1 = this.exec.getVariableName(n$1, t$1);
		return t$1.getVariable(s$1).value.getSubData(this.exec, n$1.postfix, t$1);
	}
	AtomicStore(e$1, t$1) {
		let n$1 = e$1.args[0];
		n$1 instanceof ke && (n$1 = n$1.right);
		const s$1 = this.exec.getVariableName(n$1, t$1), r$1 = t$1.getVariable(s$1);
		let a$1 = e$1.args[1];
		const i$1 = this.exec.evalExpression(a$1, t$1), o$1 = r$1.value.getSubData(this.exec, n$1.postfix, t$1);
		return o$1 instanceof Be && i$1 instanceof Be && (o$1.value = i$1.value), r$1.value instanceof Pe && r$1.value.setDataValue(this.exec, o$1, n$1.postfix, t$1), null;
	}
	AtomicAdd(e$1, t$1) {
		let n$1 = e$1.args[0];
		n$1 instanceof ke && (n$1 = n$1.right);
		const s$1 = this.exec.getVariableName(n$1, t$1), r$1 = t$1.getVariable(s$1);
		let a$1 = e$1.args[1];
		const i$1 = this.exec.evalExpression(a$1, t$1), o$1 = r$1.value.getSubData(this.exec, n$1.postfix, t$1), c$1 = new Be(o$1.value, o$1.typeInfo);
		return o$1 instanceof Be && i$1 instanceof Be && (o$1.value += i$1.value), r$1.value instanceof Pe && r$1.value.setDataValue(this.exec, o$1, n$1.postfix, t$1), c$1;
	}
	AtomicSub(e$1, t$1) {
		let n$1 = e$1.args[0];
		n$1 instanceof ke && (n$1 = n$1.right);
		const s$1 = this.exec.getVariableName(n$1, t$1), r$1 = t$1.getVariable(s$1);
		let a$1 = e$1.args[1];
		const i$1 = this.exec.evalExpression(a$1, t$1), o$1 = r$1.value.getSubData(this.exec, n$1.postfix, t$1), c$1 = new Be(o$1.value, o$1.typeInfo);
		return o$1 instanceof Be && i$1 instanceof Be && (o$1.value -= i$1.value), r$1.value instanceof Pe && r$1.value.setDataValue(this.exec, o$1, n$1.postfix, t$1), c$1;
	}
	AtomicMax(e$1, t$1) {
		let n$1 = e$1.args[0];
		n$1 instanceof ke && (n$1 = n$1.right);
		const s$1 = this.exec.getVariableName(n$1, t$1), r$1 = t$1.getVariable(s$1);
		let a$1 = e$1.args[1];
		const i$1 = this.exec.evalExpression(a$1, t$1), o$1 = r$1.value.getSubData(this.exec, n$1.postfix, t$1), c$1 = new Be(o$1.value, o$1.typeInfo);
		return o$1 instanceof Be && i$1 instanceof Be && (o$1.value = Math.max(o$1.value, i$1.value)), r$1.value instanceof Pe && r$1.value.setDataValue(this.exec, o$1, n$1.postfix, t$1), c$1;
	}
	AtomicMin(e$1, t$1) {
		let n$1 = e$1.args[0];
		n$1 instanceof ke && (n$1 = n$1.right);
		const s$1 = this.exec.getVariableName(n$1, t$1), r$1 = t$1.getVariable(s$1);
		let a$1 = e$1.args[1];
		const i$1 = this.exec.evalExpression(a$1, t$1), o$1 = r$1.value.getSubData(this.exec, n$1.postfix, t$1), c$1 = new Be(o$1.value, o$1.typeInfo);
		return o$1 instanceof Be && i$1 instanceof Be && (o$1.value = Math.min(o$1.value, i$1.value)), r$1.value instanceof Pe && r$1.value.setDataValue(this.exec, o$1, n$1.postfix, t$1), c$1;
	}
	AtomicAnd(e$1, t$1) {
		let n$1 = e$1.args[0];
		n$1 instanceof ke && (n$1 = n$1.right);
		const s$1 = this.exec.getVariableName(n$1, t$1), r$1 = t$1.getVariable(s$1);
		let a$1 = e$1.args[1];
		const i$1 = this.exec.evalExpression(a$1, t$1), o$1 = r$1.value.getSubData(this.exec, n$1.postfix, t$1), c$1 = new Be(o$1.value, o$1.typeInfo);
		return o$1 instanceof Be && i$1 instanceof Be && (o$1.value = o$1.value & i$1.value), r$1.value instanceof Pe && r$1.value.setDataValue(this.exec, o$1, n$1.postfix, t$1), c$1;
	}
	AtomicOr(e$1, t$1) {
		let n$1 = e$1.args[0];
		n$1 instanceof ke && (n$1 = n$1.right);
		const s$1 = this.exec.getVariableName(n$1, t$1), r$1 = t$1.getVariable(s$1);
		let a$1 = e$1.args[1];
		const i$1 = this.exec.evalExpression(a$1, t$1), o$1 = r$1.value.getSubData(this.exec, n$1.postfix, t$1), c$1 = new Be(o$1.value, o$1.typeInfo);
		return o$1 instanceof Be && i$1 instanceof Be && (o$1.value = o$1.value | i$1.value), r$1.value instanceof Pe && r$1.value.setDataValue(this.exec, o$1, n$1.postfix, t$1), c$1;
	}
	AtomicXor(e$1, t$1) {
		let n$1 = e$1.args[0];
		n$1 instanceof ke && (n$1 = n$1.right);
		const s$1 = this.exec.getVariableName(n$1, t$1), r$1 = t$1.getVariable(s$1);
		let a$1 = e$1.args[1];
		const i$1 = this.exec.evalExpression(a$1, t$1), o$1 = r$1.value.getSubData(this.exec, n$1.postfix, t$1), c$1 = new Be(o$1.value, o$1.typeInfo);
		return o$1 instanceof Be && i$1 instanceof Be && (o$1.value = o$1.value ^ i$1.value), r$1.value instanceof Pe && r$1.value.setDataValue(this.exec, o$1, n$1.postfix, t$1), c$1;
	}
	AtomicExchange(e$1, t$1) {
		let n$1 = e$1.args[0];
		n$1 instanceof ke && (n$1 = n$1.right);
		const s$1 = this.exec.getVariableName(n$1, t$1), r$1 = t$1.getVariable(s$1);
		let a$1 = e$1.args[1];
		const i$1 = this.exec.evalExpression(a$1, t$1), o$1 = r$1.value.getSubData(this.exec, n$1.postfix, t$1), c$1 = new Be(o$1.value, o$1.typeInfo);
		return o$1 instanceof Be && i$1 instanceof Be && (o$1.value = i$1.value), r$1.value instanceof Pe && r$1.value.setDataValue(this.exec, o$1, n$1.postfix, t$1), c$1;
	}
	AtomicCompareExchangeWeak(e$1, t$1) {
		return console.error("TODO: atomicCompareExchangeWeak"), null;
	}
	Pack4x8snorm(e$1, t$1) {
		return console.error("TODO: pack4x8snorm"), null;
	}
	Pack4x8unorm(e$1, t$1) {
		return console.error("TODO: pack4x8unorm"), null;
	}
	Pack4xI8(e$1, t$1) {
		return console.error("TODO: pack4xI8"), null;
	}
	Pack4xU8(e$1, t$1) {
		return console.error("TODO: pack4xU8"), null;
	}
	Pack4x8Clamp(e$1, t$1) {
		return console.error("TODO: pack4x8Clamp"), null;
	}
	Pack4xU8Clamp(e$1, t$1) {
		return console.error("TODO: pack4xU8Clamp"), null;
	}
	Pack2x16snorm(e$1, t$1) {
		return console.error("TODO: pack2x16snorm"), null;
	}
	Pack2x16unorm(e$1, t$1) {
		return console.error("TODO: pack2x16unorm"), null;
	}
	Pack2x16float(e$1, t$1) {
		return console.error("TODO: pack2x16float"), null;
	}
	Unpack4x8snorm(e$1, t$1) {
		return console.error("TODO: unpack4x8snorm"), null;
	}
	Unpack4x8unorm(e$1, t$1) {
		return console.error("TODO: unpack4x8unorm"), null;
	}
	Unpack4xI8(e$1, t$1) {
		return console.error("TODO: unpack4xI8"), null;
	}
	Unpack4xU8(e$1, t$1) {
		return console.error("TODO: unpack4xU8"), null;
	}
	Unpack2x16snorm(e$1, t$1) {
		return console.error("TODO: unpack2x16snorm"), null;
	}
	Unpack2x16unorm(e$1, t$1) {
		return console.error("TODO: unpack2x16unorm"), null;
	}
	Unpack2x16float(e$1, t$1) {
		return console.error("TODO: unpack2x16float"), null;
	}
	StorageBarrier(e$1, t$1) {
		return null;
	}
	TextureBarrier(e$1, t$1) {
		return null;
	}
	WorkgroupBarrier(e$1, t$1) {
		return null;
	}
	WorkgroupUniformLoad(e$1, t$1) {
		return null;
	}
	SubgroupAdd(e$1, t$1) {
		return console.error("TODO: subgroupAdd"), null;
	}
	SubgroupExclusiveAdd(e$1, t$1) {
		return console.error("TODO: subgroupExclusiveAdd"), null;
	}
	SubgroupInclusiveAdd(e$1, t$1) {
		return console.error("TODO: subgroupInclusiveAdd"), null;
	}
	SubgroupAll(e$1, t$1) {
		return console.error("TODO: subgroupAll"), null;
	}
	SubgroupAnd(e$1, t$1) {
		return console.error("TODO: subgroupAnd"), null;
	}
	SubgroupAny(e$1, t$1) {
		return console.error("TODO: subgroupAny"), null;
	}
	SubgroupBallot(e$1, t$1) {
		return console.error("TODO: subgroupBallot"), null;
	}
	SubgroupBroadcast(e$1, t$1) {
		return console.error("TODO: subgroupBroadcast"), null;
	}
	SubgroupBroadcastFirst(e$1, t$1) {
		return console.error("TODO: subgroupBroadcastFirst"), null;
	}
	SubgroupElect(e$1, t$1) {
		return console.error("TODO: subgroupElect"), null;
	}
	SubgroupMax(e$1, t$1) {
		return console.error("TODO: subgroupMax"), null;
	}
	SubgroupMin(e$1, t$1) {
		return console.error("TODO: subgroupMin"), null;
	}
	SubgroupMul(e$1, t$1) {
		return console.error("TODO: subgroupMul"), null;
	}
	SubgroupExclusiveMul(e$1, t$1) {
		return console.error("TODO: subgroupExclusiveMul"), null;
	}
	SubgroupInclusiveMul(e$1, t$1) {
		return console.error("TODO: subgroupInclusiveMul"), null;
	}
	SubgroupOr(e$1, t$1) {
		return console.error("TODO: subgroupOr"), null;
	}
	SubgroupShuffle(e$1, t$1) {
		return console.error("TODO: subgroupShuffle"), null;
	}
	SubgroupShuffleDown(e$1, t$1) {
		return console.error("TODO: subgroupShuffleDown"), null;
	}
	SubgroupShuffleUp(e$1, t$1) {
		return console.error("TODO: subgroupShuffleUp"), null;
	}
	SubgroupShuffleXor(e$1, t$1) {
		return console.error("TODO: subgroupShuffleXor"), null;
	}
	SubgroupXor(e$1, t$1) {
		return console.error("TODO: subgroupXor"), null;
	}
	QuadBroadcast(e$1, t$1) {
		return console.error("TODO: quadBroadcast"), null;
	}
	QuadSwapDiagonal(e$1, t$1) {
		return console.error("TODO: quadSwapDiagonal"), null;
	}
	QuadSwapX(e$1, t$1) {
		return console.error("TODO: quadSwapX"), null;
	}
	QuadSwapY(e$1, t$1) {
		return console.error("TODO: quadSwapY"), null;
	}
};
var ft = {
	vec2: 2,
	vec2f: 2,
	vec2i: 2,
	vec2u: 2,
	vec2b: 2,
	vec2h: 2,
	vec3: 3,
	vec3f: 3,
	vec3i: 3,
	vec3u: 3,
	vec3b: 3,
	vec3h: 3,
	vec4: 4,
	vec4f: 4,
	vec4i: 4,
	vec4u: 4,
	vec4b: 4,
	vec4h: 4
}, pt = {
	mat2x2: [
		2,
		2,
		4
	],
	mat2x2f: [
		2,
		2,
		4
	],
	mat2x2h: [
		2,
		2,
		4
	],
	mat2x3: [
		2,
		3,
		6
	],
	mat2x3f: [
		2,
		3,
		6
	],
	mat2x3h: [
		2,
		3,
		6
	],
	mat2x4: [
		2,
		4,
		8
	],
	mat2x4f: [
		2,
		4,
		8
	],
	mat2x4h: [
		2,
		4,
		8
	],
	mat3x2: [
		3,
		2,
		6
	],
	mat3x2f: [
		3,
		2,
		6
	],
	mat3x2h: [
		3,
		2,
		6
	],
	mat3x3: [
		3,
		3,
		9
	],
	mat3x3f: [
		3,
		3,
		9
	],
	mat3x3h: [
		3,
		3,
		9
	],
	mat3x4: [
		3,
		4,
		12
	],
	mat3x4f: [
		3,
		4,
		12
	],
	mat3x4h: [
		3,
		4,
		12
	],
	mat4x2: [
		4,
		2,
		8
	],
	mat4x2f: [
		4,
		2,
		8
	],
	mat4x2h: [
		4,
		2,
		8
	],
	mat4x3: [
		4,
		3,
		12
	],
	mat4x3f: [
		4,
		3,
		12
	],
	mat4x3h: [
		4,
		3,
		12
	],
	mat4x4: [
		4,
		4,
		16
	],
	mat4x4f: [
		4,
		4,
		16
	],
	mat4x4h: [
		4,
		4,
		16
	]
};
var dt = class dt extends ut {
	constructor(e$1, t$1) {
		var n$1;
		super(), this.ast = null != e$1 ? e$1 : [], this.reflection = new at(), this.reflection.updateAST(this.ast), this.context = null !== (n$1 = null == t$1 ? void 0 : t$1.clone()) && void 0 !== n$1 ? n$1 : new lt(), this.builtins = new ht(this), this.typeInfo = {
			bool: this.getTypeInfo(ae.bool),
			i32: this.getTypeInfo(ae.i32),
			u32: this.getTypeInfo(ae.u32),
			f32: this.getTypeInfo(ae.f32),
			f16: this.getTypeInfo(ae.f16),
			vec2f: this.getTypeInfo(ce.vec2f),
			vec2u: this.getTypeInfo(ce.vec2u),
			vec2i: this.getTypeInfo(ce.vec2i),
			vec2h: this.getTypeInfo(ce.vec2h),
			vec3f: this.getTypeInfo(ce.vec3f),
			vec3u: this.getTypeInfo(ce.vec3u),
			vec3i: this.getTypeInfo(ce.vec3i),
			vec3h: this.getTypeInfo(ce.vec3h),
			vec4f: this.getTypeInfo(ce.vec4f),
			vec4u: this.getTypeInfo(ce.vec4u),
			vec4i: this.getTypeInfo(ce.vec4i),
			vec4h: this.getTypeInfo(ce.vec4h),
			mat2x2f: this.getTypeInfo(ce.mat2x2f),
			mat2x3f: this.getTypeInfo(ce.mat2x3f),
			mat2x4f: this.getTypeInfo(ce.mat2x4f),
			mat3x2f: this.getTypeInfo(ce.mat3x2f),
			mat3x3f: this.getTypeInfo(ce.mat3x3f),
			mat3x4f: this.getTypeInfo(ce.mat3x4f),
			mat4x2f: this.getTypeInfo(ce.mat4x2f),
			mat4x3f: this.getTypeInfo(ce.mat4x3f),
			mat4x4f: this.getTypeInfo(ce.mat4x4f)
		};
	}
	getVariableValue(e$1) {
		var t$1, n$1;
		const r$1 = null !== (n$1 = null === (t$1 = this.context.getVariable(e$1)) || void 0 === t$1 ? void 0 : t$1.value) && void 0 !== n$1 ? n$1 : null;
		if (null === r$1) return null;
		if (r$1 instanceof Be) return r$1.value;
		if (r$1 instanceof Me) return Array.from(r$1.data);
		if (r$1 instanceof Ue) return Array.from(r$1.data);
		if (r$1 instanceof Pe && r$1.typeInfo instanceof s) {
			if ("u32" === r$1.typeInfo.format.name) return Array.from(new Uint32Array(r$1.buffer, r$1.offset, r$1.typeInfo.count));
			if ("i32" === r$1.typeInfo.format.name) return Array.from(new Int32Array(r$1.buffer, r$1.offset, r$1.typeInfo.count));
			if ("f32" === r$1.typeInfo.format.name) return Array.from(new Float32Array(r$1.buffer, r$1.offset, r$1.typeInfo.count));
		}
		return console.error(`Unsupported return variable type ${r$1.typeInfo.name}`), null;
	}
	execute(e$1) {
		(e$1 = null != e$1 ? e$1 : {}).constants && this._setOverrides(e$1.constants, this.context), this._execStatements(this.ast, this.context);
	}
	dispatchWorkgroups(e$1, t$1, n$1, s$1) {
		const r$1 = this.context.clone();
		(s$1 = null != s$1 ? s$1 : {}).constants && this._setOverrides(s$1.constants, r$1), this._execStatements(this.ast, r$1);
		const a$1 = r$1.getFunction(e$1);
		if (!a$1) return void console.error(`Function ${e$1} not found`);
		if ("number" == typeof t$1) t$1 = [
			t$1,
			1,
			1
		];
		else {
			if (0 === t$1.length) return void console.error("Invalid dispatch count");
			1 === t$1.length ? t$1 = [
				t$1[0],
				1,
				1
			] : 2 === t$1.length ? t$1 = [
				t$1[0],
				t$1[1],
				1
			] : t$1.length > 3 && (t$1 = [
				t$1[0],
				t$1[1],
				t$1[2]
			]);
		}
		const i$1 = t$1[0], o$1 = t$1[1], c$1 = t$1[2], l$1 = this.getTypeInfo("vec3u");
		r$1.setVariable("@num_workgroups", new Me(t$1, l$1));
		const u$1 = this.reflection.getFunctionInfo(e$1);
		null === u$1 && console.error(`Function ${e$1} not found in reflection data`);
		for (const e$2 in n$1) for (const t$2 in n$1[e$2]) {
			const s$2 = n$1[e$2][t$2];
			r$1.variables.forEach((n$2) => {
				var r$2;
				const a$2 = n$2.node;
				if (null == a$2 ? void 0 : a$2.attributes) {
					let i$2 = null, o$2 = null;
					for (const e$3 of a$2.attributes) "binding" === e$3.name ? i$2 = e$3.value : "group" === e$3.name && (o$2 = e$3.value);
					if (t$2 == i$2 && e$2 == o$2) {
						let i$3 = !1;
						for (const s$3 of u$1.resources) if (s$3.name === n$2.name && s$3.group === parseInt(e$2) && s$3.binding === parseInt(t$2)) {
							i$3 = !0;
							break;
						}
						if (i$3) if (void 0 !== s$2.texture && void 0 !== s$2.descriptor) n$2.value = new We(s$2.texture, this.getTypeInfo(a$2.type), s$2.descriptor, null !== (r$2 = s$2.texture.view) && void 0 !== r$2 ? r$2 : null);
						else void 0 !== s$2.uniform ? n$2.value = new Pe(s$2.uniform, this.getTypeInfo(a$2.type)) : n$2.value = new Pe(s$2, this.getTypeInfo(a$2.type));
					}
				}
			});
		}
		for (let e$2 = 0; e$2 < c$1; ++e$2) for (let t$2 = 0; t$2 < o$1; ++t$2) for (let n$2 = 0; n$2 < i$1; ++n$2) r$1.setVariable("@workgroup_id", new Me([
			n$2,
			t$2,
			e$2
		], this.getTypeInfo("vec3u"))), this._dispatchWorkgroup(a$1, [
			n$2,
			t$2,
			e$2
		], r$1);
	}
	execStatement(e$1, t$1) {
		if (e$1 instanceof Y) return this.evalExpression(e$1.value, t$1);
		if (e$1 instanceof se) {
			if (e$1.condition) {
				const n$1 = this.evalExpression(e$1.condition, t$1);
				if (!(n$1 instanceof Be)) throw new Error("Invalid break-if condition");
				if (!n$1.value) return null;
			}
			return dt._breakObj;
		}
		if (e$1 instanceof re) return dt._continueObj;
		if (e$1 instanceof U) this._let(e$1, t$1);
		else if (e$1 instanceof F) this._var(e$1, t$1);
		else if (e$1 instanceof P) this._const(e$1, t$1);
		else if (e$1 instanceof D) this._function(e$1, t$1);
		else {
			if (e$1 instanceof Q) return this._if(e$1, t$1);
			if (e$1 instanceof Z) return this._switch(e$1, t$1);
			if (e$1 instanceof B) return this._for(e$1, t$1);
			if (e$1 instanceof V) return this._while(e$1, t$1);
			if (e$1 instanceof j) return this._loop(e$1, t$1);
			if (e$1 instanceof O) {
				const n$1 = t$1.clone();
				return n$1.currentFunctionName = t$1.currentFunctionName, this._execStatements(e$1.body, n$1);
			}
			if (e$1 instanceof G) this._assign(e$1, t$1);
			else if (e$1 instanceof R) this._increment(e$1, t$1);
			else {
				if (e$1 instanceof oe) return null;
				if (e$1 instanceof M) {
					const n$1 = e$1.name;
					null === t$1.getVariable(n$1) && t$1.setVariable(n$1, new Be(0, this.getTypeInfo("u32")));
				} else if (e$1 instanceof X) this._call(e$1, t$1);
				else {
					if (e$1 instanceof ee) return null;
					if (e$1 instanceof te) return null;
					console.error("Invalid statement type.", e$1, `Line ${e$1.line}`);
				}
			}
		}
		return null;
	}
	evalExpression(e$1, t$1) {
		return e$1 instanceof Ie ? this._evalBinaryOp(e$1, t$1) : e$1 instanceof xe ? this._evalLiteral(e$1, t$1) : e$1 instanceof ge ? this._evalVariable(e$1, t$1) : e$1 instanceof me ? this._evalCall(e$1, t$1) : e$1 instanceof de ? this._evalCreate(e$1, t$1) : e$1 instanceof _e ? this._evalConst(e$1, t$1) : e$1 instanceof ye ? this._evalBitcast(e$1, t$1) : e$1 instanceof ke ? this._evalUnaryOp(e$1, t$1) : (console.error("Invalid expression type", e$1, `Line ${e$1.line}`), null);
	}
	getTypeInfo(e$1) {
		var t$1;
		if (e$1 instanceof ae) {
			const t$2 = this.reflection.getTypeInfo(e$1);
			if (null !== t$2) return t$2;
		}
		let n$1 = null !== (t$1 = this.typeInfo[e$1]) && void 0 !== t$1 ? t$1 : null;
		return null !== n$1 || (n$1 = this.reflection.getTypeInfoByName(e$1)), n$1;
	}
	_setOverrides(e$1, t$1) {
		for (const n$1 in e$1) {
			const s$1 = e$1[n$1], r$1 = this.reflection.getOverrideInfo(n$1);
			null !== r$1 ? (null === r$1.type && (r$1.type = this.getTypeInfo("u32")), "u32" === r$1.type.name || "i32" === r$1.type.name || "f32" === r$1.type.name || "f16" === r$1.type.name ? t$1.setVariable(n$1, new Be(s$1, r$1.type)) : "bool" === r$1.type.name ? t$1.setVariable(n$1, new Be(s$1 ? 1 : 0, r$1.type)) : "vec2" === r$1.type.name || "vec3" === r$1.type.name || "vec4" === r$1.type.name || "vec2f" === r$1.type.name || "vec3f" === r$1.type.name || "vec4f" === r$1.type.name || "vec2i" === r$1.type.name || "vec3i" === r$1.type.name || "vec4i" === r$1.type.name || "vec2u" === r$1.type.name || "vec3u" === r$1.type.name || "vec4u" === r$1.type.name || "vec2h" === r$1.type.name || "vec3h" === r$1.type.name || "vec4h" === r$1.type.name ? t$1.setVariable(n$1, new Me(s$1, r$1.type)) : console.error(`Invalid constant type for ${n$1}`)) : console.error(`Override ${n$1} does not exist in the shader.`);
		}
	}
	_dispatchWorkgroup(e$1, t$1, n$1) {
		const s$1 = [
			1,
			1,
			1
		];
		for (const t$2 of e$1.node.attributes) if ("workgroup_size" === t$2.name) {
			if (t$2.value.length > 0) {
				const e$2 = n$1.getVariableValue(t$2.value[0]);
				s$1[0] = e$2 instanceof Be ? e$2.value : parseInt(t$2.value[0]);
			}
			if (t$2.value.length > 1) {
				const e$2 = n$1.getVariableValue(t$2.value[1]);
				s$1[1] = e$2 instanceof Be ? e$2.value : parseInt(t$2.value[1]);
			}
			if (t$2.value.length > 2) {
				const e$2 = n$1.getVariableValue(t$2.value[2]);
				s$1[2] = e$2 instanceof Be ? e$2.value : parseInt(t$2.value[2]);
			}
		}
		const r$1 = this.getTypeInfo("vec3u"), a$1 = this.getTypeInfo("u32");
		n$1.setVariable("@workgroup_size", new Me(s$1, r$1));
		const i$1 = s$1[0], o$1 = s$1[1], c$1 = s$1[2];
		for (let l$1 = 0, u$1 = 0; l$1 < c$1; ++l$1) for (let c$2 = 0; c$2 < o$1; ++c$2) for (let o$2 = 0; o$2 < i$1; ++o$2, ++u$1) {
			const i$2 = [
				o$2,
				c$2,
				l$1
			], h$1 = [
				o$2 + t$1[0] * s$1[0],
				c$2 + t$1[1] * s$1[1],
				l$1 + t$1[2] * s$1[2]
			];
			n$1.setVariable("@local_invocation_id", new Me(i$2, r$1)), n$1.setVariable("@global_invocation_id", new Me(h$1, r$1)), n$1.setVariable("@local_invocation_index", new Be(u$1, a$1)), this._dispatchExec(e$1, n$1);
		}
	}
	_dispatchExec(e$1, t$1) {
		for (const n$1 of e$1.node.args) for (const e$2 of n$1.attributes) if ("builtin" === e$2.name) {
			const s$1 = `@${e$2.value}`, r$1 = t$1.getVariable(s$1);
			void 0 !== r$1 && t$1.variables.set(n$1.name, r$1);
		}
		this._execStatements(e$1.node.body, t$1);
	}
	getVariableName(e$1, t$1) {
		for (; e$1 instanceof ke;) e$1 = e$1.right;
		return e$1 instanceof ge ? e$1.name : (console.error("Unknown variable type", e$1, "Line", e$1.line), null);
	}
	_execStatements(e$1, t$1) {
		for (const n$1 of e$1) {
			if (n$1 instanceof Array) {
				const e$3 = t$1.clone(), s$1 = this._execStatements(n$1, e$3);
				if (s$1) return s$1;
				continue;
			}
			const e$2 = this.execStatement(n$1, t$1);
			if (e$2) return e$2;
		}
		return null;
	}
	_call(e$1, t$1) {
		const n$1 = t$1.clone();
		n$1.currentFunctionName = e$1.name;
		const s$1 = t$1.getFunction(e$1.name);
		if (s$1) {
			for (let t$2 = 0; t$2 < s$1.node.args.length; ++t$2) {
				const r$1 = s$1.node.args[t$2], a$1 = this.evalExpression(e$1.args[t$2], n$1);
				n$1.setVariable(r$1.name, a$1, r$1);
			}
			this._execStatements(s$1.node.body, n$1);
		} else if (e$1.isBuiltin) this._callBuiltinFunction(e$1, n$1);
		else this.getTypeInfo(e$1.name) && this._evalCreate(e$1, t$1);
	}
	_increment(e$1, t$1) {
		const n$1 = this.getVariableName(e$1.variable, t$1), s$1 = t$1.getVariable(n$1);
		s$1 ? "++" === e$1.operator ? s$1.value instanceof Be ? s$1.value.value++ : console.error(`Variable ${n$1} is not a scalar. Line ${e$1.line}`) : "--" === e$1.operator ? s$1.value instanceof Be ? s$1.value.value-- : console.error(`Variable ${n$1} is not a scalar. Line ${e$1.line}`) : console.error(`Unknown increment operator ${e$1.operator}. Line ${e$1.line}`) : console.error(`Variable ${n$1} not found. Line ${e$1.line}`);
	}
	_getVariableData(e$1, t$1) {
		if (e$1 instanceof ge) {
			const n$1 = this.getVariableName(e$1, t$1), s$1 = t$1.getVariable(n$1);
			return null === s$1 ? (console.error(`Variable ${n$1} not found. Line ${e$1.line}`), null) : s$1.value.getSubData(this, e$1.postfix, t$1);
		}
		if (e$1 instanceof ke) {
			if ("*" === e$1.operator) {
				const n$1 = this._getVariableData(e$1.right, t$1);
				return n$1 instanceof Oe ? n$1.reference.getSubData(this, e$1.postfix, t$1) : (console.error(`Variable ${e$1.right} is not a pointer. Line ${e$1.line}`), null);
			}
			if ("&" === e$1.operator) return new Oe(this._getVariableData(e$1.right, t$1));
		}
		return null;
	}
	_assign(e$1, t$1) {
		let n$1 = null, s$1 = "<var>", r$1 = null;
		if (e$1.variable instanceof ke) {
			const n$2 = this._getVariableData(e$1.variable, t$1), s$2 = this.evalExpression(e$1.value, t$1), r$2 = e$1.operator;
			if ("=" === r$2) {
				if (n$2 instanceof Be || n$2 instanceof Me || n$2 instanceof Ue) {
					if (s$2 instanceof Be || s$2 instanceof Me || s$2 instanceof Ue && n$2.data.length === s$2.data.length) return void n$2.data.set(s$2.data);
					console.error(`Invalid assignment. Line ${e$1.line}`);
				} else if (n$2 instanceof Pe && s$2 instanceof Pe && n$2.buffer.byteLength - n$2.offset >= s$2.buffer.byteLength - s$2.offset) return void (n$2.buffer.byteLength % 4 == 0 ? new Uint32Array(n$2.buffer, n$2.offset, n$2.typeInfo.size / 4).set(new Uint32Array(s$2.buffer, s$2.offset, s$2.typeInfo.size / 4)) : new Uint8Array(n$2.buffer, n$2.offset, n$2.typeInfo.size).set(new Uint8Array(s$2.buffer, s$2.offset, s$2.typeInfo.size)));
				return console.error(`Invalid assignment. Line ${e$1.line}`), null;
			}
			if ("+=" === r$2) return n$2 instanceof Be || n$2 instanceof Me || n$2 instanceof Ue ? s$2 instanceof Be || s$2 instanceof Me || s$2 instanceof Ue ? void n$2.data.set(s$2.data.map((e$2, t$2) => n$2.data[t$2] + e$2)) : void console.error(`Invalid assignment . Line ${e$1.line}`) : void console.error(`Invalid assignment. Line ${e$1.line}`);
			if ("-=" === r$2) return (n$2 instanceof Be || n$2 instanceof Me || n$2 instanceof Ue) && (s$2 instanceof Be || s$2 instanceof Me || s$2 instanceof Ue) ? void n$2.data.set(s$2.data.map((e$2, t$2) => n$2.data[t$2] - e$2)) : void console.error(`Invalid assignment. Line ${e$1.line}`);
		}
		if (e$1.variable instanceof ke) {
			if ("*" === e$1.variable.operator) {
				s$1 = this.getVariableName(e$1.variable.right, t$1);
				const r$2 = t$1.getVariable(s$1);
				if (!(r$2 && r$2.value instanceof Oe)) return void console.error(`Variable ${s$1} is not a pointer. Line ${e$1.line}`);
				n$1 = r$2.value.reference;
				let a$2 = e$1.variable.postfix;
				if (!a$2) {
					let t$2 = e$1.variable.right;
					for (; t$2 instanceof ke;) {
						if (t$2.postfix) {
							a$2 = t$2.postfix;
							break;
						}
						t$2 = t$2.right;
					}
				}
				a$2 && (n$1 = n$1.getSubData(this, a$2, t$1));
			}
		} else {
			r$1 = e$1.variable.postfix, s$1 = this.getVariableName(e$1.variable, t$1);
			const a$2 = t$1.getVariable(s$1);
			if (null === a$2) return void console.error(`Variable ${s$1} not found. Line ${e$1.line}`);
			n$1 = a$2.value;
		}
		if (n$1 instanceof Oe && (n$1 = n$1.reference), null === n$1) return void console.error(`Variable ${s$1} not found. Line ${e$1.line}`);
		const a$1 = this.evalExpression(e$1.value, t$1), i$1 = e$1.operator;
		if ("=" !== i$1) {
			const s$2 = n$1.getSubData(this, r$1, t$1);
			if (s$2 instanceof Me && a$1 instanceof Be) {
				const t$2 = s$2.data, n$2 = a$1.value;
				if ("+=" === i$1) for (let e$2 = 0; e$2 < t$2.length; ++e$2) t$2[e$2] += n$2;
				else if ("-=" === i$1) for (let e$2 = 0; e$2 < t$2.length; ++e$2) t$2[e$2] -= n$2;
				else if ("*=" === i$1) for (let e$2 = 0; e$2 < t$2.length; ++e$2) t$2[e$2] *= n$2;
				else if ("/=" === i$1) for (let e$2 = 0; e$2 < t$2.length; ++e$2) t$2[e$2] /= n$2;
				else if ("%=" === i$1) for (let e$2 = 0; e$2 < t$2.length; ++e$2) t$2[e$2] %= n$2;
				else if ("&=" === i$1) for (let e$2 = 0; e$2 < t$2.length; ++e$2) t$2[e$2] &= n$2;
				else if ("|=" === i$1) for (let e$2 = 0; e$2 < t$2.length; ++e$2) t$2[e$2] |= n$2;
				else if ("^=" === i$1) for (let e$2 = 0; e$2 < t$2.length; ++e$2) t$2[e$2] ^= n$2;
				else if ("<<=" === i$1) for (let e$2 = 0; e$2 < t$2.length; ++e$2) t$2[e$2] <<= n$2;
				else if (">>=" === i$1) for (let e$2 = 0; e$2 < t$2.length; ++e$2) t$2[e$2] >>= n$2;
				else console.error(`Invalid operator ${i$1}. Line ${e$1.line}`);
			} else if (s$2 instanceof Me && a$1 instanceof Me) {
				const t$2 = s$2.data, n$2 = a$1.data;
				if (t$2.length !== n$2.length) return void console.error(`Vector length mismatch. Line ${e$1.line}`);
				if ("+=" === i$1) for (let e$2 = 0; e$2 < t$2.length; ++e$2) t$2[e$2] += n$2[e$2];
				else if ("-=" === i$1) for (let e$2 = 0; e$2 < t$2.length; ++e$2) t$2[e$2] -= n$2[e$2];
				else if ("*=" === i$1) for (let e$2 = 0; e$2 < t$2.length; ++e$2) t$2[e$2] *= n$2[e$2];
				else if ("/=" === i$1) for (let e$2 = 0; e$2 < t$2.length; ++e$2) t$2[e$2] /= n$2[e$2];
				else if ("%=" === i$1) for (let e$2 = 0; e$2 < t$2.length; ++e$2) t$2[e$2] %= n$2[e$2];
				else if ("&=" === i$1) for (let e$2 = 0; e$2 < t$2.length; ++e$2) t$2[e$2] &= n$2[e$2];
				else if ("|=" === i$1) for (let e$2 = 0; e$2 < t$2.length; ++e$2) t$2[e$2] |= n$2[e$2];
				else if ("^=" === i$1) for (let e$2 = 0; e$2 < t$2.length; ++e$2) t$2[e$2] ^= n$2[e$2];
				else if ("<<=" === i$1) for (let e$2 = 0; e$2 < t$2.length; ++e$2) t$2[e$2] <<= n$2[e$2];
				else if (">>=" === i$1) for (let e$2 = 0; e$2 < t$2.length; ++e$2) t$2[e$2] >>= n$2[e$2];
				else console.error(`Invalid operator ${i$1}. Line ${e$1.line}`);
			} else {
				if (!(s$2 instanceof Be && a$1 instanceof Be)) return void console.error(`Invalid type for ${e$1.operator} operator. Line ${e$1.line}`);
				"+=" === i$1 ? s$2.value += a$1.value : "-=" === i$1 ? s$2.value -= a$1.value : "*=" === i$1 ? s$2.value *= a$1.value : "/=" === i$1 ? s$2.value /= a$1.value : "%=" === i$1 ? s$2.value %= a$1.value : "&=" === i$1 ? s$2.value &= a$1.value : "|=" === i$1 ? s$2.value |= a$1.value : "^=" === i$1 ? s$2.value ^= a$1.value : "<<=" === i$1 ? s$2.value <<= a$1.value : ">>=" === i$1 ? s$2.value >>= a$1.value : console.error(`Invalid operator ${i$1}. Line ${e$1.line}`);
			}
			n$1 instanceof Pe && n$1.setDataValue(this, s$2, r$1, t$1);
			return;
		}
		if (n$1 instanceof Pe) n$1.setDataValue(this, a$1, r$1, t$1);
		else if (r$1) {
			if (!(n$1 instanceof Me || n$1 instanceof Ue)) return void console.error(`Variable ${s$1} is not a vector or matrix. Line ${e$1.line}`);
			if (r$1 instanceof ve) {
				const i$2 = this.evalExpression(r$1.index, t$1).value;
				if (n$1 instanceof Me) {
					if (!(a$1 instanceof Be)) return void console.error(`Invalid assignment to ${s$1}. Line ${e$1.line}`);
					n$1.data[i$2] = a$1.value;
				} else {
					if (!(n$1 instanceof Ue)) return void console.error(`Invalid assignment to ${s$1}. Line ${e$1.line}`);
					{
						const i$3 = this.evalExpression(r$1.index, t$1).value;
						if (i$3 < 0) return void console.error(`Invalid assignment to ${s$1}. Line ${e$1.line}`);
						if (!(a$1 instanceof Me)) return void console.error(`Invalid assignment to ${s$1}. Line ${e$1.line}`);
						{
							const t$2 = n$1.typeInfo.getTypeName();
							if ("mat2x2" === t$2 || "mat2x2f" === t$2 || "mat2x2h" === t$2) {
								if (!(i$3 < 2 && 2 === a$1.data.length)) return void console.error(`Invalid assignment to ${s$1}. Line ${e$1.line}`);
								n$1.data[2 * i$3] = a$1.data[0], n$1.data[2 * i$3 + 1] = a$1.data[1];
							} else if ("mat2x3" === t$2 || "mat2x3f" === t$2 || "mat2x3h" === t$2) {
								if (!(i$3 < 2 && 3 === a$1.data.length)) return void console.error(`Invalid assignment to ${s$1}. Line ${e$1.line}`);
								n$1.data[3 * i$3] = a$1.data[0], n$1.data[3 * i$3 + 1] = a$1.data[1], n$1.data[3 * i$3 + 2] = a$1.data[2];
							} else if ("mat2x4" === t$2 || "mat2x4f" === t$2 || "mat2x4h" === t$2) {
								if (!(i$3 < 2 && 4 === a$1.data.length)) return void console.error(`Invalid assignment to ${s$1}. Line ${e$1.line}`);
								n$1.data[4 * i$3] = a$1.data[0], n$1.data[4 * i$3 + 1] = a$1.data[1], n$1.data[4 * i$3 + 2] = a$1.data[2], n$1.data[4 * i$3 + 3] = a$1.data[3];
							} else if ("mat3x2" === t$2 || "mat3x2f" === t$2 || "mat3x2h" === t$2) {
								if (!(i$3 < 3 && 2 === a$1.data.length)) return void console.error(`Invalid assignment to ${s$1}. Line ${e$1.line}`);
								n$1.data[2 * i$3] = a$1.data[0], n$1.data[2 * i$3 + 1] = a$1.data[1];
							} else if ("mat3x3" === t$2 || "mat3x3f" === t$2 || "mat3x3h" === t$2) {
								if (!(i$3 < 3 && 3 === a$1.data.length)) return void console.error(`Invalid assignment to ${s$1}. Line ${e$1.line}`);
								n$1.data[3 * i$3] = a$1.data[0], n$1.data[3 * i$3 + 1] = a$1.data[1], n$1.data[3 * i$3 + 2] = a$1.data[2];
							} else if ("mat3x4" === t$2 || "mat3x4f" === t$2 || "mat3x4h" === t$2) {
								if (!(i$3 < 3 && 4 === a$1.data.length)) return void console.error(`Invalid assignment to ${s$1}. Line ${e$1.line}`);
								n$1.data[4 * i$3] = a$1.data[0], n$1.data[4 * i$3 + 1] = a$1.data[1], n$1.data[4 * i$3 + 2] = a$1.data[2], n$1.data[4 * i$3 + 3] = a$1.data[3];
							} else if ("mat4x2" === t$2 || "mat4x2f" === t$2 || "mat4x2h" === t$2) {
								if (!(i$3 < 4 && 2 === a$1.data.length)) return void console.error(`Invalid assignment to ${s$1}. Line ${e$1.line}`);
								n$1.data[2 * i$3] = a$1.data[0], n$1.data[2 * i$3 + 1] = a$1.data[1];
							} else if ("mat4x3" === t$2 || "mat4x3f" === t$2 || "mat4x3h" === t$2) {
								if (!(i$3 < 4 && 3 === a$1.data.length)) return void console.error(`Invalid assignment to ${s$1}. Line ${e$1.line}`);
								n$1.data[3 * i$3] = a$1.data[0], n$1.data[3 * i$3 + 1] = a$1.data[1], n$1.data[3 * i$3 + 2] = a$1.data[2];
							} else {
								if ("mat4x4" !== t$2 && "mat4x4f" !== t$2 && "mat4x4h" !== t$2) return void console.error(`Invalid assignment to ${s$1}. Line ${e$1.line}`);
								if (!(i$3 < 4 && 4 === a$1.data.length)) return void console.error(`Invalid assignment to ${s$1}. Line ${e$1.line}`);
								n$1.data[4 * i$3] = a$1.data[0], n$1.data[4 * i$3 + 1] = a$1.data[1], n$1.data[4 * i$3 + 2] = a$1.data[2], n$1.data[4 * i$3 + 3] = a$1.data[3];
							}
						}
					}
				}
			} else if (r$1 instanceof pe) {
				const t$2 = r$1.value;
				if (!(n$1 instanceof Me)) return void console.error(`Invalid assignment to ${t$2}. Variable ${s$1} is not a vector. Line ${e$1.line}`);
				if (a$1 instanceof Be) {
					if (t$2.length > 1) return void console.error(`Invalid assignment to ${t$2} for variable ${s$1}. Line ${e$1.line}`);
					if ("x" === t$2) n$1.data[0] = a$1.value;
					else if ("y" === t$2) {
						if (n$1.data.length < 2) return void console.error(`Invalid assignment to ${t$2} for variable ${s$1}. Line ${e$1.line}`);
						n$1.data[1] = a$1.value;
					} else if ("z" === t$2) {
						if (n$1.data.length < 3) return void console.error(`Invalid assignment to ${t$2} for variable ${s$1}. Line ${e$1.line}`);
						n$1.data[2] = a$1.value;
					} else if ("w" === t$2) {
						if (n$1.data.length < 4) return void console.error(`Invalid assignment to ${t$2} for variable ${s$1}. Line ${e$1.line}`);
						n$1.data[3] = a$1.value;
					}
				} else {
					if (!(a$1 instanceof Me)) return void console.error(`Invalid assignment to ${s$1}. Line ${e$1.line}`);
					if (t$2.length !== a$1.data.length) return void console.error(`Invalid assignment to ${t$2} for variable ${s$1}. Line ${e$1.line}`);
					for (let r$2 = 0; r$2 < t$2.length; ++r$2) {
						const i$2 = t$2[r$2];
						if ("x" === i$2 || "r" === i$2) n$1.data[0] = a$1.data[r$2];
						else if ("y" === i$2 || "g" === i$2) {
							if (a$1.data.length < 2) return void console.error(`Invalid assignment to ${i$2} for variable ${s$1}. Line ${e$1.line}`);
							n$1.data[1] = a$1.data[r$2];
						} else if ("z" === i$2 || "b" === i$2) {
							if (a$1.data.length < 3) return void console.error(`Invalid assignment to ${i$2} for variable ${s$1}. Line ${e$1.line}`);
							n$1.data[2] = a$1.data[r$2];
						} else {
							if ("w" !== i$2 && "a" !== i$2) return void console.error(`Invalid assignment to ${i$2} for variable ${s$1}. Line ${e$1.line}`);
							if (a$1.data.length < 4) return void console.error(`Invalid assignment to ${i$2} for variable ${s$1}. Line ${e$1.line}`);
							n$1.data[3] = a$1.data[r$2];
						}
					}
				}
			}
		} else n$1 instanceof Be && a$1 instanceof Be ? n$1.value = a$1.value : n$1 instanceof Me && a$1 instanceof Me || n$1 instanceof Ue && a$1 instanceof Ue ? n$1.data.set(a$1.data) : console.error(`Invalid assignment to ${s$1}. Line ${e$1.line}`);
	}
	_function(e$1, t$1) {
		const n$1 = new ct(e$1);
		t$1.functions.set(e$1.name, n$1);
	}
	_const(e$1, t$1) {
		let n$1 = null;
		null !== e$1.value && (n$1 = this.evalExpression(e$1.value, t$1)), t$1.createVariable(e$1.name, n$1, e$1);
	}
	_let(e$1, t$1) {
		let n$1 = null;
		if (null !== e$1.value) {
			if (n$1 = this.evalExpression(e$1.value, t$1), null === n$1) return void console.error(`Invalid value for variable ${e$1.name}. Line ${e$1.line}`);
			e$1.value instanceof ke || (n$1 = n$1.clone());
		} else {
			const s$1 = e$1.type.name;
			if ("f32" === s$1 || "i32" === s$1 || "u32" === s$1 || "bool" === s$1 || "f16" === s$1 || "vec2" === s$1 || "vec3" === s$1 || "vec4" === s$1 || "vec2f" === s$1 || "vec3f" === s$1 || "vec4f" === s$1 || "vec2i" === s$1 || "vec3i" === s$1 || "vec4i" === s$1 || "vec2u" === s$1 || "vec3u" === s$1 || "vec4u" === s$1 || "vec2h" === s$1 || "vec3h" === s$1 || "vec4h" === s$1 || "vec2b" === s$1 || "vec3b" === s$1 || "vec4b" === s$1 || "mat2x2" === s$1 || "mat2x3" === s$1 || "mat2x4" === s$1 || "mat3x2" === s$1 || "mat3x3" === s$1 || "mat3x4" === s$1 || "mat4x2" === s$1 || "mat4x3" === s$1 || "mat4x4" === s$1 || "mat2x2f" === s$1 || "mat2x3f" === s$1 || "mat2x4f" === s$1 || "mat3x2f" === s$1 || "mat3x3f" === s$1 || "mat3x4f" === s$1 || "mat4x2f" === s$1 || "mat4x3f" === s$1 || "mat4x4f" === s$1 || "mat2x2h" === s$1 || "mat2x3h" === s$1 || "mat2x4h" === s$1 || "mat3x2h" === s$1 || "mat3x3h" === s$1 || "mat3x4h" === s$1 || "mat4x2h" === s$1 || "mat4x3h" === s$1 || "mat4x4h" === s$1 || "array" === s$1) {
				const s$2 = new de(e$1.type, []);
				n$1 = this._evalCreate(s$2, t$1);
			}
		}
		t$1.createVariable(e$1.name, n$1, e$1);
	}
	_var(e$1, t$1) {
		let n$1 = null;
		if (null !== e$1.value) {
			if (n$1 = this.evalExpression(e$1.value, t$1), null === n$1) return void console.error(`Invalid value for variable ${e$1.name}. Line ${e$1.line}`);
			e$1.value instanceof ke || (n$1 = n$1.clone());
		} else {
			if (null === e$1.type) return void console.error(`Variable ${e$1.name} has no type. Line ${e$1.line}`);
			const s$1 = e$1.type.name;
			if ("f32" === s$1 || "i32" === s$1 || "u32" === s$1 || "bool" === s$1 || "f16" === s$1 || "vec2" === s$1 || "vec3" === s$1 || "vec4" === s$1 || "vec2f" === s$1 || "vec3f" === s$1 || "vec4f" === s$1 || "vec2i" === s$1 || "vec3i" === s$1 || "vec4i" === s$1 || "vec2u" === s$1 || "vec3u" === s$1 || "vec4u" === s$1 || "vec2h" === s$1 || "vec3h" === s$1 || "vec4h" === s$1 || "vec2b" === s$1 || "vec3b" === s$1 || "vec4b" === s$1 || "mat2x2" === s$1 || "mat2x3" === s$1 || "mat2x4" === s$1 || "mat3x2" === s$1 || "mat3x3" === s$1 || "mat3x4" === s$1 || "mat4x2" === s$1 || "mat4x3" === s$1 || "mat4x4" === s$1 || "mat2x2f" === s$1 || "mat2x3f" === s$1 || "mat2x4f" === s$1 || "mat3x2f" === s$1 || "mat3x3f" === s$1 || "mat3x4f" === s$1 || "mat4x2f" === s$1 || "mat4x3f" === s$1 || "mat4x4f" === s$1 || "mat2x2h" === s$1 || "mat2x3h" === s$1 || "mat2x4h" === s$1 || "mat3x2h" === s$1 || "mat3x3h" === s$1 || "mat3x4h" === s$1 || "mat4x2h" === s$1 || "mat4x3h" === s$1 || "mat4x4h" === s$1 || e$1.type instanceof ue || e$1.type instanceof oe || e$1.type instanceof ce) {
				const s$2 = new de(e$1.type, []);
				n$1 = this._evalCreate(s$2, t$1);
			}
		}
		t$1.createVariable(e$1.name, n$1, e$1);
	}
	_switch(e$1, t$1) {
		t$1 = t$1.clone();
		const n$1 = this.evalExpression(e$1.condition, t$1);
		if (!(n$1 instanceof Be)) return console.error(`Invalid if condition. Line ${e$1.line}`), null;
		let s$1 = null;
		for (const r$1 of e$1.cases) if (r$1 instanceof Ae) for (const a$1 of r$1.selectors) {
			if (a$1 instanceof Se) {
				s$1 = r$1;
				continue;
			}
			const i$1 = this.evalExpression(a$1, t$1);
			if (!(i$1 instanceof Be)) return console.error(`Invalid case selector. Line ${e$1.line}`), null;
			if (i$1.value === n$1.value) return this._execStatements(r$1.body, t$1);
		}
		else r$1 instanceof Ee && (s$1 = r$1);
		return s$1 ? this._execStatements(s$1.body, t$1) : null;
	}
	_if(e$1, t$1) {
		t$1 = t$1.clone();
		const n$1 = this.evalExpression(e$1.condition, t$1);
		if (!(n$1 instanceof Be)) return console.error(`Invalid if condition. Line ${e$1.line}`), null;
		if (n$1.value) return this._execStatements(e$1.body, t$1);
		for (const n$2 of e$1.elseif) {
			const s$1 = this.evalExpression(n$2.condition, t$1);
			if (!(s$1 instanceof Be)) return console.error(`Invalid if condition. Line ${e$1.line}`), null;
			if (s$1.value) return this._execStatements(n$2.body, t$1);
		}
		return e$1.else ? this._execStatements(e$1.else, t$1) : null;
	}
	_getScalarValue(e$1) {
		return e$1 instanceof Be ? e$1.value : (console.error("Expected scalar value.", e$1), 0);
	}
	_for(e$1, t$1) {
		for (t$1 = t$1.clone(), this.execStatement(e$1.init, t$1); this._getScalarValue(this.evalExpression(e$1.condition, t$1));) {
			const n$1 = this._execStatements(e$1.body, t$1);
			if (n$1 === dt._breakObj) break;
			if (null !== n$1 && n$1 !== dt._continueObj) return n$1;
			this.execStatement(e$1.increment, t$1);
		}
		return null;
	}
	_loop(e$1, t$1) {
		for (t$1 = t$1.clone();;) {
			const n$1 = this._execStatements(e$1.body, t$1);
			if (n$1 === dt._breakObj) break;
			if (n$1 === dt._continueObj) {
				if (e$1.continuing) {
					if (this._execStatements(e$1.continuing.body, t$1) === dt._breakObj) break;
				}
			} else if (null !== n$1) return n$1;
		}
		return null;
	}
	_while(e$1, t$1) {
		for (t$1 = t$1.clone(); this._getScalarValue(this.evalExpression(e$1.condition, t$1));) {
			const n$1 = this._execStatements(e$1.body, t$1);
			if (n$1 === dt._breakObj) break;
			if (n$1 !== dt._continueObj && null !== n$1) return n$1;
		}
		return null;
	}
	_evalBitcast(e$1, t$1) {
		const n$1 = this.evalExpression(e$1.value, t$1), s$1 = e$1.type;
		if (n$1 instanceof Be) return new Be(nt(n$1.value, n$1.typeInfo.name, s$1.name), this.getTypeInfo(s$1));
		if (n$1 instanceof Me) {
			const t$2 = n$1.typeInfo.getTypeName();
			let r$1 = "";
			if (t$2.endsWith("f")) r$1 = "f32";
			else if (t$2.endsWith("i")) r$1 = "i32";
			else if (t$2.endsWith("u")) r$1 = "u32";
			else if (t$2.endsWith("b")) r$1 = "bool";
			else {
				if (!t$2.endsWith("h")) return console.error(`Unknown vector type ${t$2}. Line ${e$1.line}`), null;
				r$1 = "f16";
			}
			const a$1 = s$1.getTypeName();
			let i$1 = "";
			if (a$1.endsWith("f")) i$1 = "f32";
			else if (a$1.endsWith("i")) i$1 = "i32";
			else if (a$1.endsWith("u")) i$1 = "u32";
			else if (a$1.endsWith("b")) i$1 = "bool";
			else {
				if (!a$1.endsWith("h")) return console.error(`Unknown vector type ${i$1}. Line ${e$1.line}`), null;
				i$1 = "f16";
			}
			return new Me(function(e$2, t$3, n$2) {
				if (t$3 === n$2) return e$2;
				const s$2 = new Array(e$2.length);
				for (let r$2 = 0; r$2 < e$2.length; r$2++) s$2[r$2] = nt(e$2[r$2], t$3, n$2);
				return s$2;
			}(Array.from(n$1.data), r$1, i$1), this.getTypeInfo(s$1));
		}
		return console.error(`TODO: bitcast for ${n$1.typeInfo.name}. Line ${e$1.line}`), null;
	}
	_evalConst(e$1, t$1) {
		return t$1.getVariableValue(e$1.name).clone().getSubData(this, e$1.postfix, t$1);
	}
	_evalCreate(e$1, t$1) {
		var r$1;
		if (e$1 instanceof de) {
			if (null === e$1.type) return Ve.void;
			switch (e$1.type.getTypeName()) {
				case "bool":
				case "i32":
				case "u32":
				case "f32":
				case "f16": return this._callConstructorValue(e$1, t$1);
				case "vec2":
				case "vec3":
				case "vec4":
				case "vec2f":
				case "vec3f":
				case "vec4f":
				case "vec2h":
				case "vec3h":
				case "vec4h":
				case "vec2i":
				case "vec3i":
				case "vec4i":
				case "vec2u":
				case "vec3u":
				case "vec4u":
				case "vec2b":
				case "vec3b":
				case "vec4b": return this._callConstructorVec(e$1, t$1);
				case "mat2x2":
				case "mat2x2f":
				case "mat2x2h":
				case "mat2x3":
				case "mat2x3f":
				case "mat2x3h":
				case "mat2x4":
				case "mat2x4f":
				case "mat2x4h":
				case "mat3x2":
				case "mat3x2f":
				case "mat3x2h":
				case "mat3x3":
				case "mat3x3f":
				case "mat3x3h":
				case "mat3x4":
				case "mat3x4f":
				case "mat3x4h":
				case "mat4x2":
				case "mat4x2f":
				case "mat4x2h":
				case "mat4x3":
				case "mat4x3f":
				case "mat4x3h":
				case "mat4x4":
				case "mat4x4f":
				case "mat4x4h": return this._callConstructorMatrix(e$1, t$1);
			}
		}
		const a$1 = e$1 instanceof de ? e$1.type.name : e$1.name, i$1 = e$1 instanceof de ? this.getTypeInfo(e$1.type) : this.getTypeInfo(e$1.name);
		if (null === i$1) return console.error(`Unknown type ${a$1}. Line ${e$1.line}`), null;
		if (0 === i$1.size) return null;
		const o$1 = new Pe(new ArrayBuffer(i$1.size), i$1, 0);
		if (i$1 instanceof n) {
			if (e$1.args) for (let n$1 = 0; n$1 < e$1.args.length; ++n$1) {
				const s$1 = i$1.members[n$1], r$2 = e$1.args[n$1], a$2 = this.evalExpression(r$2, t$1);
				o$1.setData(this, a$2, s$1.type, s$1.offset, t$1);
			}
		} else if (i$1 instanceof s) {
			let n$1 = 0;
			if (e$1.args) for (let s$1 = 0; s$1 < e$1.args.length; ++s$1) {
				const a$2 = e$1.args[s$1], c$1 = this.evalExpression(a$2, t$1);
				null === i$1.format && ("x32" === (null === (r$1 = c$1.typeInfo) || void 0 === r$1 ? void 0 : r$1.name) ? i$1.format = this.getTypeInfo("i32") : i$1.format = c$1.typeInfo), o$1.setData(this, c$1, i$1.format, n$1, t$1), n$1 += i$1.stride;
			}
		} else console.error(`Unknown type "${a$1}". Line ${e$1.line}`);
		return e$1 instanceof de ? o$1.getSubData(this, e$1.postfix, t$1) : o$1;
	}
	_evalLiteral(e$1, t$1) {
		const n$1 = this.getTypeInfo(e$1.type), s$1 = n$1.name;
		if ("x32" === s$1 || "u32" === s$1 || "f32" === s$1 || "f16" === s$1 || "i32" === s$1 || "bool" === s$1) return new Be(e$1.scalarValue, n$1);
		return "vec2" === s$1 || "vec3" === s$1 || "vec4" === s$1 || "vec2f" === s$1 || "vec3f" === s$1 || "vec4f" === s$1 || "vec2h" === s$1 || "vec3h" === s$1 || "vec4h" === s$1 || "vec2i" === s$1 || "vec3i" === s$1 || "vec4i" === s$1 || "vec2u" === s$1 || "vec3u" === s$1 || "vec4u" === s$1 ? this._callConstructorVec(e$1, t$1) : "mat2x2" === s$1 || "mat2x3" === s$1 || "mat2x4" === s$1 || "mat3x2" === s$1 || "mat3x3" === s$1 || "mat3x4" === s$1 || "mat4x2" === s$1 || "mat4x3" === s$1 || "mat4x4" === s$1 || "mat2x2f" === s$1 || "mat2x3f" === s$1 || "mat2x4f" === s$1 || "mat3x2f" === s$1 || "mat3x3f" === s$1 || "mat3x4f" === s$1 || "mat4x2f" === s$1 || "mat4x3f" === s$1 || "mat4x4f" === s$1 || "mat2x2h" === s$1 || "mat2x3h" === s$1 || "mat2x4h" === s$1 || "mat3x2h" === s$1 || "mat3x3h" === s$1 || "mat3x4h" === s$1 || "mat4x2h" === s$1 || "mat4x3h" === s$1 || "mat4x4h" === s$1 ? this._callConstructorMatrix(e$1, t$1) : e$1.value;
	}
	_evalVariable(e$1, t$1) {
		const n$1 = t$1.getVariableValue(e$1.name);
		return null === n$1 ? n$1 : n$1.getSubData(this, e$1.postfix, t$1);
	}
	_maxFormatTypeInfo(e$1) {
		let t$1 = e$1[0];
		if ("f32" === t$1.name) return t$1;
		for (let n$1 = 1; n$1 < e$1.length; ++n$1) {
			const s$1 = dt._priority.get(t$1.name);
			dt._priority.get(e$1[n$1].name) < s$1 && (t$1 = e$1[n$1]);
		}
		return "x32" === t$1.name ? this.getTypeInfo("i32") : t$1;
	}
	_evalUnaryOp(e$1, t$1) {
		const n$1 = this.evalExpression(e$1.right, t$1);
		if ("&" === e$1.operator) return new Oe(n$1);
		if ("*" === e$1.operator) return n$1 instanceof Oe ? n$1.reference.getSubData(this, e$1.postfix, t$1) : (console.error(`Invalid dereference. Line ${e$1.line}`), null);
		const s$1 = n$1 instanceof Be ? n$1.value : n$1 instanceof Me ? Array.from(n$1.data) : null;
		switch (e$1.operator) {
			case "+": {
				if (Ge(s$1)) return new Me(s$1.map((e$3, t$3) => +e$3), n$1.typeInfo);
				const e$2 = s$1, t$2 = this._maxFormatTypeInfo([n$1.typeInfo, n$1.typeInfo]);
				return new Be(+e$2, t$2);
			}
			case "-": {
				if (Ge(s$1)) return new Me(s$1.map((e$3, t$3) => -e$3), n$1.typeInfo);
				const e$2 = s$1, t$2 = this._maxFormatTypeInfo([n$1.typeInfo, n$1.typeInfo]);
				return new Be(-e$2, t$2);
			}
			case "!": {
				if (Ge(s$1)) return new Me(s$1.map((e$3, t$3) => e$3 ? 0 : 1), n$1.typeInfo);
				const e$2 = s$1, t$2 = this._maxFormatTypeInfo([n$1.typeInfo, n$1.typeInfo]);
				return new Be(e$2 ? 0 : 1, t$2);
			}
			case "~": {
				if (Ge(s$1)) return new Me(s$1.map((e$3, t$3) => ~e$3), n$1.typeInfo);
				const e$2 = s$1, t$2 = this._maxFormatTypeInfo([n$1.typeInfo, n$1.typeInfo]);
				return new Be(~e$2, t$2);
			}
		}
		return console.error(`Invalid unary operator ${e$1.operator}. Line ${e$1.line}`), null;
	}
	_evalBinaryOp(e$1, t$1) {
		const n$1 = this.evalExpression(e$1.left, t$1), s$1 = this.evalExpression(e$1.right, t$1), r$1 = n$1 instanceof Be ? n$1.value : n$1 instanceof Me || n$1 instanceof Ue ? Array.from(n$1.data) : null, a$1 = s$1 instanceof Be ? s$1.value : s$1 instanceof Me || s$1 instanceof Ue ? Array.from(s$1.data) : null;
		switch (e$1.operator) {
			case "+": {
				if (Ge(r$1) && Ge(a$1)) {
					const t$3 = r$1, s$2 = a$1;
					if (t$3.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$1.line}.`), null;
					return new Me(t$3.map((e$2, t$4) => e$2 + s$2[t$4]), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$2 = a$1;
					return new Me(r$1.map((t$3, n$2) => t$3 + e$2), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$2 = r$1;
					return new Me(a$1.map((t$3, n$2) => e$2 + t$3), s$1.typeInfo);
				}
				const t$2 = r$1, i$1 = a$1, o$1 = this._maxFormatTypeInfo([n$1.typeInfo, s$1.typeInfo]);
				return new Be(t$2 + i$1, o$1);
			}
			case "-": {
				if (Ge(r$1) && Ge(a$1)) {
					const t$3 = r$1, s$2 = a$1;
					if (t$3.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$1.line}.`), null;
					return new Me(t$3.map((e$2, t$4) => e$2 - s$2[t$4]), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$2 = a$1;
					return new Me(r$1.map((t$3, n$2) => t$3 - e$2), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$2 = r$1;
					return new Me(a$1.map((t$3, n$2) => e$2 - t$3), s$1.typeInfo);
				}
				const t$2 = r$1, i$1 = a$1, o$1 = this._maxFormatTypeInfo([n$1.typeInfo, s$1.typeInfo]);
				return new Be(t$2 - i$1, o$1);
			}
			case "*": {
				if (Ge(r$1) && Ge(a$1)) {
					const t$3 = r$1, i$2 = a$1;
					if (n$1 instanceof Ue && s$1 instanceof Ue) {
						const r$2 = function(e$2, t$4, n$2, s$2) {
							if (void 0 === pt[t$4.name] || void 0 === pt[s$2.name]) return null;
							const r$3 = pt[t$4.name][0], a$3 = pt[t$4.name][1], i$3 = pt[s$2.name][0];
							if (r$3 !== pt[s$2.name][1]) return null;
							const o$3 = new Array(i$3 * a$3);
							for (let t$5 = 0; t$5 < a$3; t$5++) for (let s$3 = 0; s$3 < i$3; s$3++) {
								let c$1 = 0;
								for (let i$4 = 0; i$4 < r$3; i$4++) c$1 += e$2[i$4 * a$3 + t$5] * n$2[s$3 * r$3 + i$4];
								o$3[t$5 * i$3 + s$3] = c$1;
							}
							return o$3;
						}(t$3, n$1.typeInfo, i$2, s$1.typeInfo);
						if (null === r$2) return console.error(`Matrix multiplication failed. Line ${e$1.line}.`), null;
						const a$2 = pt[s$1.typeInfo.name][0], o$2 = pt[n$1.typeInfo.name][1];
						return new Ue(r$2, this.getTypeInfo(`mat${a$2}x${o$2}f`));
					}
					if (n$1 instanceof Ue && s$1 instanceof Me) {
						const r$2 = function(e$2, t$4, n$2, s$2) {
							if (void 0 === pt[t$4.name] || void 0 === ft[s$2.name]) return null;
							const r$3 = pt[t$4.name][0], a$2 = pt[t$4.name][1];
							if (r$3 !== n$2.length) return null;
							const i$3 = new Array(a$2);
							for (let t$5 = 0; t$5 < a$2; t$5++) {
								let s$3 = 0;
								for (let i$4 = 0; i$4 < r$3; i$4++) s$3 += e$2[i$4 * a$2 + t$5] * n$2[i$4];
								i$3[t$5] = s$3;
							}
							return i$3;
						}(t$3, n$1.typeInfo, i$2, s$1.typeInfo);
						return null === r$2 ? (console.error(`Matrix vector multiplication failed. Line ${e$1.line}.`), null) : new Me(r$2, s$1.typeInfo);
					}
					if (n$1 instanceof Me && s$1 instanceof Ue) {
						const r$2 = function(e$2, t$4, n$2, s$2) {
							if (void 0 === ft[t$4.name] || void 0 === pt[s$2.name]) return null;
							const r$3 = pt[s$2.name][0], a$2 = pt[s$2.name][1];
							if (a$2 !== e$2.length) return null;
							const i$3 = [];
							for (let t$5 = 0; t$5 < r$3; t$5++) {
								let s$3 = 0;
								for (let i$4 = 0; i$4 < a$2; i$4++) s$3 += e$2[i$4] * n$2[i$4 * r$3 + t$5];
								i$3[t$5] = s$3;
							}
							return i$3;
						}(t$3, n$1.typeInfo, i$2, s$1.typeInfo);
						return null === r$2 ? (console.error(`Matrix vector multiplication failed. Line ${e$1.line}.`), null) : new Me(r$2, n$1.typeInfo);
					}
					if (t$3.length !== i$2.length) return console.error(`Vector length mismatch. Line ${e$1.line}.`), null;
					return new Me(t$3.map((e$2, t$4) => e$2 * i$2[t$4]), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$2 = a$1, t$3 = r$1.map((t$4, n$2) => t$4 * e$2);
					return n$1 instanceof Ue ? new Ue(t$3, n$1.typeInfo) : new Me(t$3, n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$2 = r$1, t$3 = a$1.map((t$4, n$2) => e$2 * t$4);
					return s$1 instanceof Ue ? new Ue(t$3, s$1.typeInfo) : new Me(t$3, s$1.typeInfo);
				}
				const t$2 = r$1, i$1 = a$1, o$1 = this._maxFormatTypeInfo([n$1.typeInfo, s$1.typeInfo]);
				return new Be(t$2 * i$1, o$1);
			}
			case "%": {
				if (Ge(r$1) && Ge(a$1)) {
					const t$3 = r$1, s$2 = a$1;
					if (t$3.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$1.line}.`), null;
					return new Me(t$3.map((e$2, t$4) => e$2 % s$2[t$4]), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$2 = a$1;
					return new Me(r$1.map((t$3, n$2) => t$3 % e$2), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$2 = r$1;
					return new Me(a$1.map((t$3, n$2) => e$2 % t$3), s$1.typeInfo);
				}
				const t$2 = r$1, i$1 = a$1, o$1 = this._maxFormatTypeInfo([n$1.typeInfo, s$1.typeInfo]);
				return new Be(t$2 % i$1, o$1);
			}
			case "/": {
				if (Ge(r$1) && Ge(a$1)) {
					const t$3 = r$1, s$2 = a$1;
					if (t$3.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$1.line}.`), null;
					return new Me(t$3.map((e$2, t$4) => e$2 / s$2[t$4]), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$2 = a$1;
					return new Me(r$1.map((t$3, n$2) => t$3 / e$2), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$2 = r$1;
					return new Me(a$1.map((t$3, n$2) => e$2 / t$3), s$1.typeInfo);
				}
				const t$2 = r$1, i$1 = a$1, o$1 = this._maxFormatTypeInfo([n$1.typeInfo, s$1.typeInfo]);
				return new Be(t$2 / i$1, o$1);
			}
			case "&": {
				if (Ge(r$1) && Ge(a$1)) {
					const t$3 = r$1, s$2 = a$1;
					if (t$3.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$1.line}.`), null;
					return new Me(t$3.map((e$2, t$4) => e$2 & s$2[t$4]), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$2 = a$1;
					return new Me(r$1.map((t$3, n$2) => t$3 & e$2), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$2 = r$1;
					return new Me(a$1.map((t$3, n$2) => e$2 & t$3), s$1.typeInfo);
				}
				const t$2 = r$1, i$1 = a$1, o$1 = this._maxFormatTypeInfo([n$1.typeInfo, s$1.typeInfo]);
				return new Be(t$2 & i$1, o$1);
			}
			case "|": {
				if (Ge(r$1) && Ge(a$1)) {
					const t$3 = r$1, s$2 = a$1;
					if (t$3.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$1.line}.`), null;
					return new Me(t$3.map((e$2, t$4) => e$2 | s$2[t$4]), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$2 = a$1;
					return new Me(r$1.map((t$3, n$2) => t$3 | e$2), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$2 = r$1;
					return new Me(a$1.map((t$3, n$2) => e$2 | t$3), s$1.typeInfo);
				}
				const t$2 = r$1, i$1 = a$1, o$1 = this._maxFormatTypeInfo([n$1.typeInfo, s$1.typeInfo]);
				return new Be(t$2 | i$1, o$1);
			}
			case "^": {
				if (Ge(r$1) && Ge(a$1)) {
					const t$3 = r$1, s$2 = a$1;
					if (t$3.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$1.line}.`), null;
					return new Me(t$3.map((e$2, t$4) => e$2 ^ s$2[t$4]), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$2 = a$1;
					return new Me(r$1.map((t$3, n$2) => t$3 ^ e$2), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$2 = r$1;
					return new Me(a$1.map((t$3, n$2) => e$2 ^ t$3), s$1.typeInfo);
				}
				const t$2 = r$1, i$1 = a$1, o$1 = this._maxFormatTypeInfo([n$1.typeInfo, s$1.typeInfo]);
				return new Be(t$2 ^ i$1, o$1);
			}
			case "<<": {
				if (Ge(r$1) && Ge(a$1)) {
					const t$3 = r$1, s$2 = a$1;
					if (t$3.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$1.line}.`), null;
					return new Me(t$3.map((e$2, t$4) => e$2 << s$2[t$4]), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$2 = a$1;
					return new Me(r$1.map((t$3, n$2) => t$3 << e$2), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$2 = r$1;
					return new Me(a$1.map((t$3, n$2) => e$2 << t$3), s$1.typeInfo);
				}
				const t$2 = r$1, i$1 = a$1, o$1 = this._maxFormatTypeInfo([n$1.typeInfo, s$1.typeInfo]);
				return new Be(t$2 << i$1, o$1);
			}
			case ">>": {
				if (Ge(r$1) && Ge(a$1)) {
					const t$3 = r$1, s$2 = a$1;
					if (t$3.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$1.line}.`), null;
					return new Me(t$3.map((e$2, t$4) => e$2 >> s$2[t$4]), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$2 = a$1;
					return new Me(r$1.map((t$3, n$2) => t$3 >> e$2), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$2 = r$1;
					return new Me(a$1.map((t$3, n$2) => e$2 >> t$3), s$1.typeInfo);
				}
				const t$2 = r$1, i$1 = a$1, o$1 = this._maxFormatTypeInfo([n$1.typeInfo, s$1.typeInfo]);
				return new Be(t$2 >> i$1, o$1);
			}
			case ">":
				if (Ge(r$1) && Ge(a$1)) {
					const t$2 = r$1, s$2 = a$1;
					if (t$2.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$1.line}.`), null;
					return new Me(t$2.map((e$2, t$3) => e$2 > s$2[t$3] ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$2 = a$1;
					return new Me(r$1.map((t$2, n$2) => t$2 > e$2 ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$2 = r$1;
					return new Me(a$1.map((t$2, n$2) => e$2 > t$2 ? 1 : 0), s$1.typeInfo);
				}
				return new Be(r$1 > a$1 ? 1 : 0, this.getTypeInfo("bool"));
			case "<":
				if (Ge(r$1) && Ge(a$1)) {
					const t$2 = r$1, s$2 = a$1;
					if (t$2.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$1.line}.`), null;
					return new Me(t$2.map((e$2, t$3) => e$2 < s$2[t$3] ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$2 = a$1;
					return new Me(r$1.map((t$2, n$2) => t$2 < e$2 ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$2 = r$1;
					return new Me(a$1.map((t$2, n$2) => e$2 < t$2 ? 1 : 0), s$1.typeInfo);
				}
				return new Be(r$1 < a$1 ? 1 : 0, this.getTypeInfo("bool"));
			case "==":
				if (Ge(r$1) && Ge(a$1)) {
					const t$2 = r$1, s$2 = a$1;
					if (t$2.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$1.line}.`), null;
					return new Me(t$2.map((e$2, t$3) => e$2 === s$2[t$3] ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$2 = a$1;
					return new Me(r$1.map((t$2, n$2) => t$2 == e$2 ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$2 = r$1;
					return new Me(a$1.map((t$2, n$2) => e$2 == t$2 ? 1 : 0), s$1.typeInfo);
				}
				return new Be(r$1 === a$1 ? 1 : 0, this.getTypeInfo("bool"));
			case "!=":
				if (Ge(r$1) && Ge(a$1)) {
					const t$2 = r$1, s$2 = a$1;
					if (t$2.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$1.line}.`), null;
					return new Me(t$2.map((e$2, t$3) => e$2 !== s$2[t$3] ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$2 = a$1;
					return new Me(r$1.map((t$2, n$2) => t$2 !== e$2 ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$2 = r$1;
					return new Me(a$1.map((t$2, n$2) => e$2 !== t$2 ? 1 : 0), s$1.typeInfo);
				}
				return new Be(r$1 !== a$1 ? 1 : 0, this.getTypeInfo("bool"));
			case ">=":
				if (Ge(r$1) && Ge(a$1)) {
					const t$2 = r$1, s$2 = a$1;
					if (t$2.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$1.line}.`), null;
					return new Me(t$2.map((e$2, t$3) => e$2 >= s$2[t$3] ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$2 = a$1;
					return new Me(r$1.map((t$2, n$2) => t$2 >= e$2 ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$2 = r$1;
					return new Me(a$1.map((t$2, n$2) => e$2 >= t$2 ? 1 : 0), s$1.typeInfo);
				}
				return new Be(r$1 >= a$1 ? 1 : 0, this.getTypeInfo("bool"));
			case "<=":
				if (Ge(r$1) && Ge(a$1)) {
					const t$2 = r$1, s$2 = a$1;
					if (t$2.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$1.line}.`), null;
					return new Me(t$2.map((e$2, t$3) => e$2 <= s$2[t$3] ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$2 = a$1;
					return new Me(r$1.map((t$2, n$2) => t$2 <= e$2 ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$2 = r$1;
					return new Me(a$1.map((t$2, n$2) => e$2 <= t$2 ? 1 : 0), s$1.typeInfo);
				}
				return new Be(r$1 <= a$1 ? 1 : 0, this.getTypeInfo("bool"));
			case "&&":
				if (Ge(r$1) && Ge(a$1)) {
					const t$2 = r$1, s$2 = a$1;
					if (t$2.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$1.line}.`), null;
					return new Me(t$2.map((e$2, t$3) => e$2 && s$2[t$3] ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$2 = a$1;
					return new Me(r$1.map((t$2, n$2) => t$2 && e$2 ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$2 = r$1;
					return new Me(a$1.map((t$2, n$2) => e$2 && t$2 ? 1 : 0), s$1.typeInfo);
				}
				return new Be(r$1 && a$1 ? 1 : 0, this.getTypeInfo("bool"));
			case "||":
				if (Ge(r$1) && Ge(a$1)) {
					const t$2 = r$1, s$2 = a$1;
					if (t$2.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$1.line}.`), null;
					return new Me(t$2.map((e$2, t$3) => e$2 || s$2[t$3] ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$2 = a$1;
					return new Me(r$1.map((t$2, n$2) => t$2 || e$2 ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$2 = r$1;
					return new Me(a$1.map((t$2, n$2) => e$2 || t$2 ? 1 : 0), s$1.typeInfo);
				}
				return new Be(r$1 || a$1 ? 1 : 0, this.getTypeInfo("bool"));
		}
		return console.error(`Unknown operator ${e$1.operator}. Line ${e$1.line}`), null;
	}
	_evalCall(e$1, t$1) {
		if (null !== e$1.cachedReturnValue) return e$1.cachedReturnValue;
		const n$1 = t$1.clone();
		n$1.currentFunctionName = e$1.name;
		const s$1 = t$1.getFunction(e$1.name);
		if (!s$1) {
			if (e$1.isBuiltin) return this._callBuiltinFunction(e$1, n$1);
			return this.getTypeInfo(e$1.name) ? this._evalCreate(e$1, t$1) : (console.error(`Unknown function "${e$1.name}". Line ${e$1.line}`), null);
		}
		for (let t$2 = 0; t$2 < s$1.node.args.length; ++t$2) {
			const r$1 = s$1.node.args[t$2], a$1 = this.evalExpression(e$1.args[t$2], n$1);
			n$1.createVariable(r$1.name, a$1, r$1);
		}
		return this._execStatements(s$1.node.body, n$1);
	}
	_callBuiltinFunction(e$1, t$1) {
		switch (e$1.name) {
			case "all": return this.builtins.All(e$1, t$1);
			case "any": return this.builtins.Any(e$1, t$1);
			case "select": return this.builtins.Select(e$1, t$1);
			case "arrayLength": return this.builtins.ArrayLength(e$1, t$1);
			case "abs": return this.builtins.Abs(e$1, t$1);
			case "acos": return this.builtins.Acos(e$1, t$1);
			case "acosh": return this.builtins.Acosh(e$1, t$1);
			case "asin": return this.builtins.Asin(e$1, t$1);
			case "asinh": return this.builtins.Asinh(e$1, t$1);
			case "atan": return this.builtins.Atan(e$1, t$1);
			case "atanh": return this.builtins.Atanh(e$1, t$1);
			case "atan2": return this.builtins.Atan2(e$1, t$1);
			case "ceil": return this.builtins.Ceil(e$1, t$1);
			case "clamp": return this.builtins.Clamp(e$1, t$1);
			case "cos": return this.builtins.Cos(e$1, t$1);
			case "cosh": return this.builtins.Cosh(e$1, t$1);
			case "countLeadingZeros": return this.builtins.CountLeadingZeros(e$1, t$1);
			case "countOneBits": return this.builtins.CountOneBits(e$1, t$1);
			case "countTrailingZeros": return this.builtins.CountTrailingZeros(e$1, t$1);
			case "cross": return this.builtins.Cross(e$1, t$1);
			case "degrees": return this.builtins.Degrees(e$1, t$1);
			case "determinant": return this.builtins.Determinant(e$1, t$1);
			case "distance": return this.builtins.Distance(e$1, t$1);
			case "dot": return this.builtins.Dot(e$1, t$1);
			case "dot4U8Packed": return this.builtins.Dot4U8Packed(e$1, t$1);
			case "dot4I8Packed": return this.builtins.Dot4I8Packed(e$1, t$1);
			case "exp": return this.builtins.Exp(e$1, t$1);
			case "exp2": return this.builtins.Exp2(e$1, t$1);
			case "extractBits": return this.builtins.ExtractBits(e$1, t$1);
			case "faceForward": return this.builtins.FaceForward(e$1, t$1);
			case "firstLeadingBit": return this.builtins.FirstLeadingBit(e$1, t$1);
			case "firstTrailingBit": return this.builtins.FirstTrailingBit(e$1, t$1);
			case "floor": return this.builtins.Floor(e$1, t$1);
			case "fma": return this.builtins.Fma(e$1, t$1);
			case "fract": return this.builtins.Fract(e$1, t$1);
			case "frexp": return this.builtins.Frexp(e$1, t$1);
			case "insertBits": return this.builtins.InsertBits(e$1, t$1);
			case "inverseSqrt": return this.builtins.InverseSqrt(e$1, t$1);
			case "ldexp": return this.builtins.Ldexp(e$1, t$1);
			case "length": return this.builtins.Length(e$1, t$1);
			case "log": return this.builtins.Log(e$1, t$1);
			case "log2": return this.builtins.Log2(e$1, t$1);
			case "max": return this.builtins.Max(e$1, t$1);
			case "min": return this.builtins.Min(e$1, t$1);
			case "mix": return this.builtins.Mix(e$1, t$1);
			case "modf": return this.builtins.Modf(e$1, t$1);
			case "normalize": return this.builtins.Normalize(e$1, t$1);
			case "pow": return this.builtins.Pow(e$1, t$1);
			case "quantizeToF16": return this.builtins.QuantizeToF16(e$1, t$1);
			case "radians": return this.builtins.Radians(e$1, t$1);
			case "reflect": return this.builtins.Reflect(e$1, t$1);
			case "refract": return this.builtins.Refract(e$1, t$1);
			case "reverseBits": return this.builtins.ReverseBits(e$1, t$1);
			case "round": return this.builtins.Round(e$1, t$1);
			case "saturate": return this.builtins.Saturate(e$1, t$1);
			case "sign": return this.builtins.Sign(e$1, t$1);
			case "sin": return this.builtins.Sin(e$1, t$1);
			case "sinh": return this.builtins.Sinh(e$1, t$1);
			case "smoothstep": return this.builtins.SmoothStep(e$1, t$1);
			case "sqrt": return this.builtins.Sqrt(e$1, t$1);
			case "step": return this.builtins.Step(e$1, t$1);
			case "tan": return this.builtins.Tan(e$1, t$1);
			case "tanh": return this.builtins.Tanh(e$1, t$1);
			case "transpose": return this.builtins.Transpose(e$1, t$1);
			case "trunc": return this.builtins.Trunc(e$1, t$1);
			case "dpdx": return this.builtins.Dpdx(e$1, t$1);
			case "dpdxCoarse": return this.builtins.DpdxCoarse(e$1, t$1);
			case "dpdxFine": return this.builtins.DpdxFine(e$1, t$1);
			case "dpdy": return this.builtins.Dpdy(e$1, t$1);
			case "dpdyCoarse": return this.builtins.DpdyCoarse(e$1, t$1);
			case "dpdyFine": return this.builtins.DpdyFine(e$1, t$1);
			case "fwidth": return this.builtins.Fwidth(e$1, t$1);
			case "fwidthCoarse": return this.builtins.FwidthCoarse(e$1, t$1);
			case "fwidthFine": return this.builtins.FwidthFine(e$1, t$1);
			case "textureDimensions": return this.builtins.TextureDimensions(e$1, t$1);
			case "textureGather": return this.builtins.TextureGather(e$1, t$1);
			case "textureGatherCompare": return this.builtins.TextureGatherCompare(e$1, t$1);
			case "textureLoad": return this.builtins.TextureLoad(e$1, t$1);
			case "textureNumLayers": return this.builtins.TextureNumLayers(e$1, t$1);
			case "textureNumLevels": return this.builtins.TextureNumLevels(e$1, t$1);
			case "textureNumSamples": return this.builtins.TextureNumSamples(e$1, t$1);
			case "textureSample": return this.builtins.TextureSample(e$1, t$1);
			case "textureSampleBias": return this.builtins.TextureSampleBias(e$1, t$1);
			case "textureSampleCompare": return this.builtins.TextureSampleCompare(e$1, t$1);
			case "textureSampleCompareLevel": return this.builtins.TextureSampleCompareLevel(e$1, t$1);
			case "textureSampleGrad": return this.builtins.TextureSampleGrad(e$1, t$1);
			case "textureSampleLevel": return this.builtins.TextureSampleLevel(e$1, t$1);
			case "textureSampleBaseClampToEdge": return this.builtins.TextureSampleBaseClampToEdge(e$1, t$1);
			case "textureStore": return this.builtins.TextureStore(e$1, t$1);
			case "atomicLoad": return this.builtins.AtomicLoad(e$1, t$1);
			case "atomicStore": return this.builtins.AtomicStore(e$1, t$1);
			case "atomicAdd": return this.builtins.AtomicAdd(e$1, t$1);
			case "atomicSub": return this.builtins.AtomicSub(e$1, t$1);
			case "atomicMax": return this.builtins.AtomicMax(e$1, t$1);
			case "atomicMin": return this.builtins.AtomicMin(e$1, t$1);
			case "atomicAnd": return this.builtins.AtomicAnd(e$1, t$1);
			case "atomicOr": return this.builtins.AtomicOr(e$1, t$1);
			case "atomicXor": return this.builtins.AtomicXor(e$1, t$1);
			case "atomicExchange": return this.builtins.AtomicExchange(e$1, t$1);
			case "atomicCompareExchangeWeak": return this.builtins.AtomicCompareExchangeWeak(e$1, t$1);
			case "pack4x8snorm": return this.builtins.Pack4x8snorm(e$1, t$1);
			case "pack4x8unorm": return this.builtins.Pack4x8unorm(e$1, t$1);
			case "pack4xI8": return this.builtins.Pack4xI8(e$1, t$1);
			case "pack4xU8": return this.builtins.Pack4xU8(e$1, t$1);
			case "pack4x8Clamp": return this.builtins.Pack4x8Clamp(e$1, t$1);
			case "pack4xU8Clamp": return this.builtins.Pack4xU8Clamp(e$1, t$1);
			case "pack2x16snorm": return this.builtins.Pack2x16snorm(e$1, t$1);
			case "pack2x16unorm": return this.builtins.Pack2x16unorm(e$1, t$1);
			case "pack2x16float": return this.builtins.Pack2x16float(e$1, t$1);
			case "unpack4x8snorm": return this.builtins.Unpack4x8snorm(e$1, t$1);
			case "unpack4x8unorm": return this.builtins.Unpack4x8unorm(e$1, t$1);
			case "unpack4xI8": return this.builtins.Unpack4xI8(e$1, t$1);
			case "unpack4xU8": return this.builtins.Unpack4xU8(e$1, t$1);
			case "unpack2x16snorm": return this.builtins.Unpack2x16snorm(e$1, t$1);
			case "unpack2x16unorm": return this.builtins.Unpack2x16unorm(e$1, t$1);
			case "unpack2x16float": return this.builtins.Unpack2x16float(e$1, t$1);
			case "storageBarrier": return this.builtins.StorageBarrier(e$1, t$1);
			case "textureBarrier": return this.builtins.TextureBarrier(e$1, t$1);
			case "workgroupBarrier": return this.builtins.WorkgroupBarrier(e$1, t$1);
			case "workgroupUniformLoad": return this.builtins.WorkgroupUniformLoad(e$1, t$1);
			case "subgroupAdd": return this.builtins.SubgroupAdd(e$1, t$1);
			case "subgroupExclusiveAdd": return this.builtins.SubgroupExclusiveAdd(e$1, t$1);
			case "subgroupInclusiveAdd": return this.builtins.SubgroupInclusiveAdd(e$1, t$1);
			case "subgroupAll": return this.builtins.SubgroupAll(e$1, t$1);
			case "subgroupAnd": return this.builtins.SubgroupAnd(e$1, t$1);
			case "subgroupAny": return this.builtins.SubgroupAny(e$1, t$1);
			case "subgroupBallot": return this.builtins.SubgroupBallot(e$1, t$1);
			case "subgroupBroadcast": return this.builtins.SubgroupBroadcast(e$1, t$1);
			case "subgroupBroadcastFirst": return this.builtins.SubgroupBroadcastFirst(e$1, t$1);
			case "subgroupElect": return this.builtins.SubgroupElect(e$1, t$1);
			case "subgroupMax": return this.builtins.SubgroupMax(e$1, t$1);
			case "subgroupMin": return this.builtins.SubgroupMin(e$1, t$1);
			case "subgroupMul": return this.builtins.SubgroupMul(e$1, t$1);
			case "subgroupExclusiveMul": return this.builtins.SubgroupExclusiveMul(e$1, t$1);
			case "subgroupInclusiveMul": return this.builtins.SubgroupInclusiveMul(e$1, t$1);
			case "subgroupOr": return this.builtins.SubgroupOr(e$1, t$1);
			case "subgroupShuffle": return this.builtins.SubgroupShuffle(e$1, t$1);
			case "subgroupShuffleDown": return this.builtins.SubgroupShuffleDown(e$1, t$1);
			case "subgroupShuffleUp": return this.builtins.SubgroupShuffleUp(e$1, t$1);
			case "subgroupShuffleXor": return this.builtins.SubgroupShuffleXor(e$1, t$1);
			case "subgroupXor": return this.builtins.SubgroupXor(e$1, t$1);
			case "quadBroadcast": return this.builtins.QuadBroadcast(e$1, t$1);
			case "quadSwapDiagonal": return this.builtins.QuadSwapDiagonal(e$1, t$1);
			case "quadSwapX": return this.builtins.QuadSwapX(e$1, t$1);
			case "quadSwapY": return this.builtins.QuadSwapY(e$1, t$1);
		}
		const n$1 = t$1.getFunction(e$1.name);
		if (n$1) {
			const s$1 = t$1.clone();
			for (let t$2 = 0; t$2 < n$1.node.args.length; ++t$2) {
				const r$1 = n$1.node.args[t$2], a$1 = this.evalExpression(e$1.args[t$2], s$1);
				s$1.setVariable(r$1.name, a$1, r$1);
			}
			return this._execStatements(n$1.node.body, s$1);
		}
		return null;
	}
	_callConstructorValue(e$1, t$1) {
		if (!e$1.args || 0 === e$1.args.length) return new Be(0, this.getTypeInfo(e$1.type));
		const n$1 = this.evalExpression(e$1.args[0], t$1);
		return n$1.typeInfo = this.getTypeInfo(e$1.type), n$1.getSubData(this, e$1.postfix, t$1).clone();
	}
	_callConstructorVec(e$1, t$1) {
		const n$1 = this.getTypeInfo(e$1.type), s$1 = e$1.type.getTypeName(), r$1 = ft[s$1];
		if (void 0 === r$1) return console.error(`Invalid vec constructor ${s$1}. Line ${e$1.line}`), null;
		const a$1 = [];
		if (e$1 instanceof xe) if (e$1.isVector) {
			const t$2 = e$1.vectorValue;
			for (const e$2 of t$2) a$1.push(e$2);
		} else a$1.push(e$1.scalarValue);
		else if (e$1.args) for (const n$2 of e$1.args) {
			const e$2 = this.evalExpression(n$2, t$1);
			if (e$2 instanceof Me) {
				const t$2 = e$2.data;
				for (let e$3 = 0; e$3 < t$2.length; ++e$3) {
					let n$3 = t$2[e$3];
					a$1.push(n$3);
				}
			} else if (e$2 instanceof Be) {
				let t$2 = e$2.value;
				a$1.push(t$2);
			}
		}
		if (e$1.type instanceof ce && null === e$1.type.format && (e$1.type.format = ce.f32), 0 === a$1.length) return new Me(new Array(r$1).fill(0), n$1).getSubData(this, e$1.postfix, t$1);
		if (1 === a$1.length) for (; a$1.length < r$1;) a$1.push(a$1[0]);
		if (a$1.length < r$1) return console.error(`Invalid vec constructor. Line ${e$1.line}`), null;
		return new Me(a$1.length > r$1 ? a$1.slice(0, r$1) : a$1, n$1).getSubData(this, e$1.postfix, t$1);
	}
	_callConstructorMatrix(e$1, t$1) {
		const n$1 = this.getTypeInfo(e$1.type), s$1 = e$1.type.getTypeName(), r$1 = pt[s$1];
		if (void 0 === r$1) return console.error(`Invalid matrix constructor ${s$1}. Line ${e$1.line}`), null;
		const i$1 = [];
		if (e$1 instanceof xe) if (e$1.isVector) {
			const t$2 = e$1.vectorValue;
			for (const e$2 of t$2) i$1.push(e$2);
		} else i$1.push(e$1.scalarValue);
		else if (e$1.args) for (const n$2 of e$1.args) {
			const e$2 = this.evalExpression(n$2, t$1);
			e$2 instanceof Me ? i$1.push(...e$2.data) : e$2 instanceof Be ? i$1.push(e$2.value) : e$2 instanceof Ue && i$1.push(...e$2.data);
		}
		if (n$1 instanceof a && null === n$1.format && (n$1.format = this.getTypeInfo("f32")), 0 === i$1.length) return new Ue(new Array(r$1[2]).fill(0), n$1).getSubData(this, e$1.postfix, t$1);
		return i$1.length !== r$1[2] ? (console.error(`Invalid matrix constructor. Line ${e$1.line}`), null) : new Ue(i$1, n$1).getSubData(this, e$1.postfix, t$1);
	}
};
dt._breakObj = new Ne(new e("BREAK", null), null), dt._continueObj = new Ne(new e("CONTINUE", null), null), dt._priority = new Map([
	["f32", 0],
	["f16", 1],
	["u32", 2],
	["i32", 3],
	["x32", 3]
]);
var mt = class {
	constructor() {
		this.constants = /* @__PURE__ */ new Map(), this.aliases = /* @__PURE__ */ new Map(), this.structs = /* @__PURE__ */ new Map();
	}
};
var gt = class {
	constructor() {
		this._tokens = [], this._current = 0, this._currentLine = 1, this._deferArrayCountEval = [], this._currentLoop = [], this._context = new mt(), this._exec = new dt(), this._forwardTypeCount = 0;
	}
	parse(e$1) {
		this._initialize(e$1), this._deferArrayCountEval.length = 0;
		const t$1 = [];
		for (; !this._isAtEnd();) {
			const e$2 = this._global_decl_or_directive();
			if (!e$2) break;
			t$1.push(e$2);
		}
		if (this._deferArrayCountEval.length > 0) {
			for (const e$2 of this._deferArrayCountEval) {
				const t$2 = e$2.arrayType, n$1 = e$2.countNode;
				if (n$1 instanceof ge) {
					const e$3 = n$1.name, s$1 = this._context.constants.get(e$3);
					if (s$1) try {
						t$2.count = s$1.constEvaluate(this._exec);
					} catch (e$4) {}
				}
			}
			this._deferArrayCountEval.length = 0;
		}
		if (this._forwardTypeCount > 0) for (const e$2 of t$1) e$2.search((e$3) => {
			e$3 instanceof Ce || e$3 instanceof le ? e$3.type = this._forwardType(e$3.type) : e$3 instanceof ue ? e$3.format = this._forwardType(e$3.format) : e$3 instanceof F || e$3 instanceof U || e$3 instanceof P ? e$3.type = this._forwardType(e$3.type) : e$3 instanceof D ? e$3.returnType = this._forwardType(e$3.returnType) : e$3 instanceof $e && (e$3.type = this._forwardType(e$3.type));
		});
		return t$1;
	}
	_forwardType(e$1) {
		if (e$1 instanceof ie) {
			const t$1 = this._getType(e$1.name);
			if (t$1) return t$1;
		} else e$1 instanceof le ? e$1.type = this._forwardType(e$1.type) : e$1 instanceof ue && (e$1.format = this._forwardType(e$1.format));
		return e$1;
	}
	_initialize(e$1) {
		if (e$1) if ("string" == typeof e$1) this._tokens = new Re(e$1).scanTokens();
		else this._tokens = e$1;
		else this._tokens = [];
		this._current = 0;
	}
	_updateNode(e$1, t$1) {
		return e$1.line = null != t$1 ? t$1 : this._currentLine, e$1;
	}
	_error(e$1, t$1) {
		return {
			token: e$1,
			message: t$1,
			toString: () => `${t$1}`
		};
	}
	_isAtEnd() {
		return this._current >= this._tokens.length || this._peek().type == He.eof;
	}
	_match(e$1) {
		if (e$1 instanceof qe) return !!this._check(e$1) && (this._advance(), !0);
		for (let t$1 = 0, n$1 = e$1.length; t$1 < n$1; ++t$1) {
			const n$2 = e$1[t$1];
			if (this._check(n$2)) return this._advance(), !0;
		}
		return !1;
	}
	_consume(e$1, t$1) {
		if (this._check(e$1)) return this._advance();
		throw this._error(this._peek(), `${t$1}. Line:${this._currentLine}`);
	}
	_check(e$1) {
		if (this._isAtEnd()) return !1;
		const t$1 = this._peek();
		if (e$1 instanceof Array) {
			const n$1 = t$1.type;
			let s$1 = !1;
			for (const t$2 of e$1) {
				if (n$1 === t$2) return !0;
				t$2 === He.tokens.name && (s$1 = !0);
			}
			if (s$1) {
				const e$2 = He.tokens.name.rule.exec(t$1.lexeme);
				if (e$2 && 0 == e$2.index && e$2[0] == t$1.lexeme) return !0;
			}
			return !1;
		}
		if (t$1.type === e$1) return !0;
		if (e$1 === He.tokens.name) {
			const e$2 = He.tokens.name.rule.exec(t$1.lexeme);
			return e$2 && 0 == e$2.index && e$2[0] == t$1.lexeme;
		}
		return !1;
	}
	_advance() {
		var e$1, t$1;
		return this._currentLine = null !== (t$1 = null === (e$1 = this._peek()) || void 0 === e$1 ? void 0 : e$1.line) && void 0 !== t$1 ? t$1 : -1, this._isAtEnd() || this._current++, this._previous();
	}
	_peek() {
		return this._tokens[this._current];
	}
	_previous() {
		return this._tokens[this._current - 1];
	}
	_global_decl_or_directive() {
		for (; this._match(He.tokens.semicolon) && !this._isAtEnd(););
		if (this._match(He.keywords.alias)) {
			const e$2 = this._type_alias();
			return this._consume(He.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([e$2]), e$2;
		}
		if (this._match(He.keywords.diagnostic)) {
			const e$2 = this._diagnostic();
			return this._consume(He.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([e$2]), e$2;
		}
		if (this._match(He.keywords.requires)) {
			const e$2 = this._requires_directive();
			return this._consume(He.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([e$2]), e$2;
		}
		if (this._match(He.keywords.enable)) {
			const e$2 = this._enable_directive();
			return this._consume(He.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([e$2]), e$2;
		}
		const e$1 = this._attribute();
		if (this._check(He.keywords.var)) {
			const t$1 = this._global_variable_decl();
			return null != t$1 && (t$1.attributes = e$1), this._consume(He.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t$1]), t$1;
		}
		if (this._check(He.keywords.override)) {
			const t$1 = this._override_variable_decl();
			return null != t$1 && (t$1.attributes = e$1), this._consume(He.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t$1]), t$1;
		}
		if (this._check(He.keywords.let)) {
			const t$1 = this._global_let_decl();
			return null != t$1 && (t$1.attributes = e$1), this._consume(He.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t$1]), t$1;
		}
		if (this._check(He.keywords.const)) {
			const t$1 = this._global_const_decl();
			return null != t$1 && (t$1.attributes = e$1), this._consume(He.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t$1]), t$1;
		}
		if (this._check(He.keywords.struct)) {
			const t$1 = this._struct_decl();
			return null != t$1 && (t$1.attributes = e$1), this._exec.reflection.updateAST([t$1]), t$1;
		}
		if (this._check(He.keywords.fn)) {
			const t$1 = this._function_decl();
			return null != t$1 && (t$1.attributes = e$1), this._exec.reflection.updateAST([t$1]), t$1;
		}
		return null;
	}
	_function_decl() {
		if (!this._match(He.keywords.fn)) return null;
		const e$1 = this._currentLine, t$1 = this._consume(He.tokens.ident, "Expected function name.").toString();
		this._consume(He.tokens.paren_left, "Expected '(' for function arguments.");
		const n$1 = [];
		if (!this._check(He.tokens.paren_right)) do {
			if (this._check(He.tokens.paren_right)) break;
			const e$2 = this._attribute(), t$2 = this._consume(He.tokens.name, "Expected argument name.").toString();
			this._consume(He.tokens.colon, "Expected ':' for argument type.");
			const s$2 = this._attribute(), r$2 = this._type_decl();
			null != r$2 && (r$2.attributes = s$2, n$1.push(this._updateNode(new $e(t$2, r$2, e$2))));
		} while (this._match(He.tokens.comma));
		this._consume(He.tokens.paren_right, "Expected ')' after function arguments.");
		let s$1 = null;
		if (this._match(He.tokens.arrow)) {
			const e$2 = this._attribute();
			s$1 = this._type_decl(), null != s$1 && (s$1.attributes = e$2);
		}
		const r$1 = this._compound_statement(), a$1 = this._currentLine;
		return this._updateNode(new D(t$1, n$1, s$1, r$1, e$1, a$1), e$1);
	}
	_compound_statement() {
		const e$1 = [];
		for (this._consume(He.tokens.brace_left, "Expected '{' for block."); !this._check(He.tokens.brace_right);) {
			const t$1 = this._statement();
			null !== t$1 && e$1.push(t$1);
		}
		return this._consume(He.tokens.brace_right, "Expected '}' for block."), e$1;
	}
	_statement() {
		for (; this._match(He.tokens.semicolon) && !this._isAtEnd(););
		if (this._check(He.tokens.attr) && this._attribute(), this._check(He.keywords.if)) return this._if_statement();
		if (this._check(He.keywords.switch)) return this._switch_statement();
		if (this._check(He.keywords.loop)) return this._loop_statement();
		if (this._check(He.keywords.for)) return this._for_statement();
		if (this._check(He.keywords.while)) return this._while_statement();
		if (this._check(He.keywords.continuing)) return this._continuing_statement();
		if (this._check(He.keywords.static_assert)) return this._static_assert_statement();
		if (this._check(He.tokens.brace_left)) return this._compound_statement();
		let e$1 = null;
		if (this._check(He.keywords.return)) e$1 = this._return_statement();
		else if (this._check([
			He.keywords.var,
			He.keywords.let,
			He.keywords.const
		])) e$1 = this._variable_statement();
		else if (this._match(He.keywords.discard)) e$1 = this._updateNode(new ne());
		else if (this._match(He.keywords.break)) {
			const t$1 = this._updateNode(new se());
			if (this._currentLoop.length > 0) t$1.loopId = this._currentLoop[this._currentLoop.length - 1].id;
			e$1 = t$1, this._check(He.keywords.if) && (this._advance(), t$1.condition = this._optional_paren_expression());
		} else if (this._match(He.keywords.continue)) {
			const t$1 = this._updateNode(new re());
			if (!(this._currentLoop.length > 0)) throw this._error(this._peek(), `Continue statement must be inside a loop. Line: ${t$1.line}`);
			t$1.loopId = this._currentLoop[this._currentLoop.length - 1].id;
			e$1 = t$1;
		} else e$1 = this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement();
		return null != e$1 && this._consume(He.tokens.semicolon, "Expected ';' after statement."), e$1;
	}
	_static_assert_statement() {
		if (!this._match(He.keywords.static_assert)) return null;
		const e$1 = this._currentLine, t$1 = this._optional_paren_expression();
		return this._updateNode(new N(t$1), e$1);
	}
	_while_statement() {
		if (!this._match(He.keywords.while)) return null;
		const e$1 = this._updateNode(new V(null, null));
		return this._currentLoop.push(e$1), e$1.condition = this._optional_paren_expression(), this._check(He.tokens.attr) && this._attribute(), e$1.body = this._compound_statement(), this._currentLoop.pop(), e$1;
	}
	_continuing_statement() {
		const e$1 = this._currentLoop.length > 0 ? this._currentLoop[this._currentLoop.length - 1].id : -1;
		if (!this._match(He.keywords.continuing)) return null;
		const t$1 = this._currentLine, n$1 = this._compound_statement();
		return this._updateNode(new O(n$1, e$1), t$1);
	}
	_for_statement() {
		if (!this._match(He.keywords.for)) return null;
		this._consume(He.tokens.paren_left, "Expected '('.");
		const e$1 = this._updateNode(new B(null, null, null, null));
		return this._currentLoop.push(e$1), e$1.init = this._check(He.tokens.semicolon) ? null : this._for_init(), this._consume(He.tokens.semicolon, "Expected ';'."), e$1.condition = this._check(He.tokens.semicolon) ? null : this._short_circuit_or_expression(), this._consume(He.tokens.semicolon, "Expected ';'."), e$1.increment = this._check(He.tokens.paren_right) ? null : this._for_increment(), this._consume(He.tokens.paren_right, "Expected ')'."), this._check(He.tokens.attr) && this._attribute(), e$1.body = this._compound_statement(), this._currentLoop.pop(), e$1;
	}
	_for_init() {
		return this._variable_statement() || this._func_call_statement() || this._assignment_statement();
	}
	_for_increment() {
		return this._func_call_statement() || this._increment_decrement_statement() || this._assignment_statement();
	}
	_variable_statement() {
		if (this._check(He.keywords.var)) {
			const e$1 = this._variable_decl();
			if (null === e$1) throw this._error(this._peek(), "Variable declaration expected.");
			let t$1 = null;
			return this._match(He.tokens.equal) && (t$1 = this._short_circuit_or_expression()), this._updateNode(new F(e$1.name, e$1.type, e$1.storage, e$1.access, t$1), e$1.line);
		}
		if (this._match(He.keywords.let)) {
			const e$1 = this._currentLine, t$1 = this._consume(He.tokens.name, "Expected name for let.").toString();
			let n$1 = null;
			if (this._match(He.tokens.colon)) {
				const e$2 = this._attribute();
				n$1 = this._type_decl(), null != n$1 && (n$1.attributes = e$2);
			}
			this._consume(He.tokens.equal, "Expected '=' for let.");
			const s$1 = this._short_circuit_or_expression();
			return this._updateNode(new U(t$1, n$1, null, null, s$1), e$1);
		}
		if (this._match(He.keywords.const)) {
			const e$1 = this._currentLine, t$1 = this._consume(He.tokens.name, "Expected name for const.").toString();
			let n$1 = null;
			if (this._match(He.tokens.colon)) {
				const e$2 = this._attribute();
				n$1 = this._type_decl(), null != n$1 && (n$1.attributes = e$2);
			}
			this._consume(He.tokens.equal, "Expected '=' for const.");
			const s$1 = this._short_circuit_or_expression();
			return null === n$1 && s$1 instanceof xe && (n$1 = s$1.type), this._updateNode(new P(t$1, n$1, null, null, s$1), e$1);
		}
		return null;
	}
	_increment_decrement_statement() {
		const e$1 = this._current, t$1 = this._unary_expression();
		if (null == t$1) return null;
		if (!this._check(He.increment_operators)) return this._current = e$1, null;
		const n$1 = this._consume(He.increment_operators, "Expected increment operator");
		return this._updateNode(new R(n$1.type === He.tokens.plus_plus ? W.increment : W.decrement, t$1));
	}
	_assignment_statement() {
		let e$1 = null;
		const t$1 = this._currentLine;
		if (this._check(He.tokens.brace_right)) return null;
		let n$1 = this._match(He.tokens.underscore);
		if (n$1 || (e$1 = this._unary_expression()), !n$1 && null == e$1) return null;
		const s$1 = this._consume(He.assignment_operators, "Expected assignment operator."), r$1 = this._short_circuit_or_expression();
		return this._updateNode(new G(q.parse(s$1.lexeme), e$1, r$1), t$1);
	}
	_func_call_statement() {
		if (!this._check(He.tokens.ident)) return null;
		const e$1 = this._currentLine, t$1 = this._current, n$1 = this._consume(He.tokens.ident, "Expected function name."), s$1 = this._argument_expression_list();
		return null === s$1 ? (this._current = t$1, null) : this._updateNode(new X(n$1.lexeme, s$1), e$1);
	}
	_loop_statement() {
		if (!this._match(He.keywords.loop)) return null;
		this._check(He.tokens.attr) && this._attribute(), this._consume(He.tokens.brace_left, "Expected '{' for loop.");
		const e$1 = this._updateNode(new j([], null));
		this._currentLoop.push(e$1);
		let t$1 = this._statement();
		for (; null !== t$1;) {
			if (Array.isArray(t$1)) for (let n$1 of t$1) e$1.body.push(n$1);
			else e$1.body.push(t$1);
			if (t$1 instanceof O) {
				e$1.continuing = t$1;
				break;
			}
			t$1 = this._statement();
		}
		return this._currentLoop.pop(), this._consume(He.tokens.brace_right, "Expected '}' for loop."), e$1;
	}
	_switch_statement() {
		if (!this._match(He.keywords.switch)) return null;
		const e$1 = this._updateNode(new Z(null, []));
		if (this._currentLoop.push(e$1), e$1.condition = this._optional_paren_expression(), this._check(He.tokens.attr) && this._attribute(), this._consume(He.tokens.brace_left, "Expected '{' for switch."), e$1.cases = this._switch_body(), null == e$1.cases || 0 == e$1.cases.length) throw this._error(this._previous(), "Expected 'case' or 'default'.");
		return this._consume(He.tokens.brace_right, "Expected '}' for switch."), this._currentLoop.pop(), e$1;
	}
	_switch_body() {
		const e$1 = [];
		let t$1 = !1;
		for (; this._check([He.keywords.default, He.keywords.case]);) {
			if (this._match(He.keywords.case)) {
				const n$1 = this._case_selectors();
				for (const e$2 of n$1) if (e$2 instanceof Se) {
					if (t$1) throw this._error(this._previous(), "Multiple default cases in switch statement.");
					t$1 = !0;
					break;
				}
				this._match(He.tokens.colon), this._check(He.tokens.attr) && this._attribute(), this._consume(He.tokens.brace_left, "Exected '{' for switch case.");
				const s$1 = this._case_body();
				this._consume(He.tokens.brace_right, "Exected '}' for switch case."), e$1.push(this._updateNode(new Ae(n$1, s$1)));
			}
			if (this._match(He.keywords.default)) {
				if (t$1) throw this._error(this._previous(), "Multiple default cases in switch statement.");
				this._match(He.tokens.colon), this._check(He.tokens.attr) && this._attribute(), this._consume(He.tokens.brace_left, "Exected '{' for switch default.");
				const n$1 = this._case_body();
				this._consume(He.tokens.brace_right, "Exected '}' for switch default."), e$1.push(this._updateNode(new Ee(n$1)));
			}
		}
		return e$1;
	}
	_case_selectors() {
		const e$1 = [];
		for (this._match(He.keywords.default) ? e$1.push(this._updateNode(new Se())) : e$1.push(this._shift_expression()); this._match(He.tokens.comma);) this._match(He.keywords.default) ? e$1.push(this._updateNode(new Se())) : e$1.push(this._shift_expression());
		return e$1;
	}
	_case_body() {
		if (this._match(He.keywords.fallthrough)) return this._consume(He.tokens.semicolon, "Expected ';'"), [];
		let e$1 = this._statement();
		if (null == e$1) return [];
		e$1 instanceof Array || (e$1 = [e$1]);
		const t$1 = this._case_body();
		return 0 == t$1.length ? e$1 : [...e$1, t$1[0]];
	}
	_if_statement() {
		if (!this._match(He.keywords.if)) return null;
		const e$1 = this._currentLine, t$1 = this._optional_paren_expression();
		this._check(He.tokens.attr) && this._attribute();
		const n$1 = this._compound_statement();
		let s$1 = [];
		this._match_elseif() && (this._check(He.tokens.attr) && this._attribute(), s$1 = this._elseif_statement(s$1));
		let r$1 = null;
		return this._match(He.keywords.else) && (this._check(He.tokens.attr) && this._attribute(), r$1 = this._compound_statement()), this._updateNode(new Q(t$1, n$1, s$1, r$1), e$1);
	}
	_match_elseif() {
		return this._tokens[this._current].type === He.keywords.else && this._tokens[this._current + 1].type === He.keywords.if && (this._advance(), this._advance(), !0);
	}
	_elseif_statement(e$1 = []) {
		const t$1 = this._optional_paren_expression(), n$1 = this._compound_statement();
		return e$1.push(this._updateNode(new Le(t$1, n$1))), this._match_elseif() && (this._check(He.tokens.attr) && this._attribute(), this._elseif_statement(e$1)), e$1;
	}
	_return_statement() {
		if (!this._match(He.keywords.return)) return null;
		const e$1 = this._short_circuit_or_expression();
		return this._updateNode(new Y(e$1));
	}
	_short_circuit_or_expression() {
		let e$1 = this._short_circuit_and_expr();
		for (; this._match(He.tokens.or_or);) e$1 = this._updateNode(new Ie(this._previous().toString(), e$1, this._short_circuit_and_expr()));
		return e$1;
	}
	_short_circuit_and_expr() {
		let e$1 = this._inclusive_or_expression();
		for (; this._match(He.tokens.and_and);) e$1 = this._updateNode(new Ie(this._previous().toString(), e$1, this._inclusive_or_expression()));
		return e$1;
	}
	_inclusive_or_expression() {
		let e$1 = this._exclusive_or_expression();
		for (; this._match(He.tokens.or);) e$1 = this._updateNode(new Ie(this._previous().toString(), e$1, this._exclusive_or_expression()));
		return e$1;
	}
	_exclusive_or_expression() {
		let e$1 = this._and_expression();
		for (; this._match(He.tokens.xor);) e$1 = this._updateNode(new Ie(this._previous().toString(), e$1, this._and_expression()));
		return e$1;
	}
	_and_expression() {
		let e$1 = this._equality_expression();
		for (; this._match(He.tokens.and);) e$1 = this._updateNode(new Ie(this._previous().toString(), e$1, this._equality_expression()));
		return e$1;
	}
	_equality_expression() {
		const e$1 = this._relational_expression();
		return this._match([He.tokens.equal_equal, He.tokens.not_equal]) ? this._updateNode(new Ie(this._previous().toString(), e$1, this._relational_expression())) : e$1;
	}
	_relational_expression() {
		let e$1 = this._shift_expression();
		for (; this._match([
			He.tokens.less_than,
			He.tokens.greater_than,
			He.tokens.less_than_equal,
			He.tokens.greater_than_equal
		]);) e$1 = this._updateNode(new Ie(this._previous().toString(), e$1, this._shift_expression()));
		return e$1;
	}
	_shift_expression() {
		let e$1 = this._additive_expression();
		for (; this._match([He.tokens.shift_left, He.tokens.shift_right]);) e$1 = this._updateNode(new Ie(this._previous().toString(), e$1, this._additive_expression()));
		return e$1;
	}
	_additive_expression() {
		let e$1 = this._multiplicative_expression();
		for (; this._match([He.tokens.plus, He.tokens.minus]);) e$1 = this._updateNode(new Ie(this._previous().toString(), e$1, this._multiplicative_expression()));
		return e$1;
	}
	_multiplicative_expression() {
		let e$1 = this._unary_expression();
		for (; this._match([
			He.tokens.star,
			He.tokens.forward_slash,
			He.tokens.modulo
		]);) e$1 = this._updateNode(new Ie(this._previous().toString(), e$1, this._unary_expression()));
		return e$1;
	}
	_unary_expression() {
		return this._match([
			He.tokens.minus,
			He.tokens.bang,
			He.tokens.tilde,
			He.tokens.star,
			He.tokens.and
		]) ? this._updateNode(new ke(this._previous().toString(), this._unary_expression())) : this._singular_expression();
	}
	_singular_expression() {
		const e$1 = this._primary_expression(), t$1 = this._postfix_expression();
		return t$1 && (e$1.postfix = t$1), e$1;
	}
	_postfix_expression() {
		if (this._match(He.tokens.bracket_left)) {
			const e$1 = this._short_circuit_or_expression();
			this._consume(He.tokens.bracket_right, "Expected ']'.");
			const t$1 = this._updateNode(new ve(e$1)), n$1 = this._postfix_expression();
			return n$1 && (t$1.postfix = n$1), t$1;
		}
		if (this._match(He.tokens.period)) {
			const e$1 = this._consume(He.tokens.name, "Expected member name."), t$1 = this._postfix_expression(), n$1 = this._updateNode(new pe(e$1.lexeme));
			return t$1 && (n$1.postfix = t$1), n$1;
		}
		return null;
	}
	_getStruct(e$1) {
		if (this._context.aliases.has(e$1)) return this._context.aliases.get(e$1).type;
		if (this._context.structs.has(e$1)) return this._context.structs.get(e$1);
		return null;
	}
	_getType(e$1) {
		const t$1 = this._getStruct(e$1);
		if (null !== t$1) return t$1;
		switch (e$1) {
			case "void": return ae.void;
			case "bool": return ae.bool;
			case "i32": return ae.i32;
			case "u32": return ae.u32;
			case "f32": return ae.f32;
			case "f16": return ae.f16;
			case "vec2f": return ce.vec2f;
			case "vec3f": return ce.vec3f;
			case "vec4f": return ce.vec4f;
			case "vec2i": return ce.vec2i;
			case "vec3i": return ce.vec3i;
			case "vec4i": return ce.vec4i;
			case "vec2u": return ce.vec2u;
			case "vec3u": return ce.vec3u;
			case "vec4u": return ce.vec4u;
			case "vec2h": return ce.vec2h;
			case "vec3h": return ce.vec3h;
			case "vec4h": return ce.vec4h;
			case "mat2x2f": return ce.mat2x2f;
			case "mat2x3f": return ce.mat2x3f;
			case "mat2x4f": return ce.mat2x4f;
			case "mat3x2f": return ce.mat3x2f;
			case "mat3x3f": return ce.mat3x3f;
			case "mat3x4f": return ce.mat3x4f;
			case "mat4x2f": return ce.mat4x2f;
			case "mat4x3f": return ce.mat4x3f;
			case "mat4x4f": return ce.mat4x4f;
			case "mat2x2h": return ce.mat2x2h;
			case "mat2x3h": return ce.mat2x3h;
			case "mat2x4h": return ce.mat2x4h;
			case "mat3x2h": return ce.mat3x2h;
			case "mat3x3h": return ce.mat3x3h;
			case "mat3x4h": return ce.mat3x4h;
			case "mat4x2h": return ce.mat4x2h;
			case "mat4x3h": return ce.mat4x3h;
			case "mat4x4h": return ce.mat4x4h;
			case "mat2x2i": return ce.mat2x2i;
			case "mat2x3i": return ce.mat2x3i;
			case "mat2x4i": return ce.mat2x4i;
			case "mat3x2i": return ce.mat3x2i;
			case "mat3x3i": return ce.mat3x3i;
			case "mat3x4i": return ce.mat3x4i;
			case "mat4x2i": return ce.mat4x2i;
			case "mat4x3i": return ce.mat4x3i;
			case "mat4x4i": return ce.mat4x4i;
			case "mat2x2u": return ce.mat2x2u;
			case "mat2x3u": return ce.mat2x3u;
			case "mat2x4u": return ce.mat2x4u;
			case "mat3x2u": return ce.mat3x2u;
			case "mat3x3u": return ce.mat3x3u;
			case "mat3x4u": return ce.mat3x4u;
			case "mat4x2u": return ce.mat4x2u;
			case "mat4x3u": return ce.mat4x3u;
			case "mat4x4u": return ce.mat4x4u;
		}
		return null;
	}
	_validateTypeRange(e$1, t$1) {
		if ("i32" === t$1.name) {
			if (e$1 < -2147483648 || e$1 > 2147483647) throw this._error(this._previous(), `Value out of range for i32: ${e$1}. Line: ${this._currentLine}.`);
		} else if ("u32" === t$1.name && (e$1 < 0 || e$1 > 4294967295)) throw this._error(this._previous(), `Value out of range for u32: ${e$1}. Line: ${this._currentLine}.`);
	}
	_primary_expression() {
		if (this._match(He.tokens.ident)) {
			const e$2 = this._previous().toString();
			if (this._check(He.tokens.paren_left)) {
				const t$2 = this._argument_expression_list(), n$1 = this._getType(e$2);
				return null !== n$1 ? this._updateNode(new de(n$1, t$2)) : this._updateNode(new me(e$2, t$2));
			}
			if (this._context.constants.has(e$2)) {
				const t$2 = this._context.constants.get(e$2);
				return this._updateNode(new _e(e$2, t$2.value));
			}
			return this._updateNode(new ge(e$2));
		}
		if (this._match(He.tokens.int_literal)) {
			const e$2 = this._previous().toString();
			let t$2 = e$2.endsWith("i") || e$2.endsWith("i") ? ae.i32 : e$2.endsWith("u") || e$2.endsWith("U") ? ae.u32 : ae.x32;
			const n$1 = parseInt(e$2);
			return this._validateTypeRange(n$1, t$2), this._updateNode(new xe(new Be(n$1, this._exec.getTypeInfo(t$2)), t$2));
		}
		if (this._match(He.tokens.uint_literal)) {
			const e$2 = parseInt(this._previous().toString());
			return this._validateTypeRange(e$2, ae.u32), this._updateNode(new xe(new Be(e$2, this._exec.getTypeInfo(ae.u32)), ae.u32));
		}
		if (this._match([He.tokens.decimal_float_literal, He.tokens.hex_float_literal])) {
			let e$2 = this._previous().toString(), t$2 = e$2.endsWith("h");
			t$2 && (e$2 = e$2.substring(0, e$2.length - 1));
			const n$1 = parseFloat(e$2);
			this._validateTypeRange(n$1, t$2 ? ae.f16 : ae.f32);
			const s$1 = t$2 ? ae.f16 : ae.f32;
			return this._updateNode(new xe(new Be(n$1, this._exec.getTypeInfo(s$1)), s$1));
		}
		if (this._match([He.keywords.true, He.keywords.false])) {
			let e$2 = this._previous().toString() === He.keywords.true.rule;
			return this._updateNode(new xe(new Be(e$2 ? 1 : 0, this._exec.getTypeInfo(ae.bool)), ae.bool));
		}
		if (this._check(He.tokens.paren_left)) return this._paren_expression();
		if (this._match(He.keywords.bitcast)) {
			this._consume(He.tokens.less_than, "Expected '<'.");
			const e$2 = this._type_decl();
			this._consume(He.tokens.greater_than, "Expected '>'.");
			const t$2 = this._paren_expression();
			return this._updateNode(new ye(e$2, t$2));
		}
		const e$1 = this._type_decl(), t$1 = this._argument_expression_list();
		return this._updateNode(new de(e$1, t$1));
	}
	_argument_expression_list() {
		if (!this._match(He.tokens.paren_left)) return null;
		const e$1 = [];
		do {
			if (this._check(He.tokens.paren_right)) break;
			const t$1 = this._short_circuit_or_expression();
			e$1.push(t$1);
		} while (this._match(He.tokens.comma));
		return this._consume(He.tokens.paren_right, "Expected ')' for agument list"), e$1;
	}
	_optional_paren_expression() {
		this._match(He.tokens.paren_left);
		const e$1 = this._short_circuit_or_expression();
		return this._match(He.tokens.paren_right), e$1;
	}
	_paren_expression() {
		this._consume(He.tokens.paren_left, "Expected '('.");
		const e$1 = this._short_circuit_or_expression();
		return this._consume(He.tokens.paren_right, "Expected ')'."), e$1;
	}
	_struct_decl() {
		if (!this._match(He.keywords.struct)) return null;
		const e$1 = this._currentLine, t$1 = this._consume(He.tokens.ident, "Expected name for struct.").toString();
		this._consume(He.tokens.brace_left, "Expected '{' for struct body.");
		const n$1 = [];
		for (; !this._check(He.tokens.brace_right);) {
			const e$2 = this._attribute(), t$2 = this._consume(He.tokens.name, "Expected variable name.").toString();
			this._consume(He.tokens.colon, "Expected ':' for struct member type.");
			const s$2 = this._attribute(), r$2 = this._type_decl();
			null != r$2 && (r$2.attributes = s$2), this._check(He.tokens.brace_right) ? this._match(He.tokens.comma) : this._consume(He.tokens.comma, "Expected ',' for struct member."), n$1.push(this._updateNode(new Ce(t$2, r$2, e$2)));
		}
		this._consume(He.tokens.brace_right, "Expected '}' after struct body.");
		const s$1 = this._currentLine, r$1 = this._updateNode(new oe(t$1, n$1, e$1, s$1), e$1);
		return this._context.structs.set(t$1, r$1), r$1;
	}
	_global_variable_decl() {
		const e$1 = this._variable_decl();
		if (!e$1) return null;
		if (this._match(He.tokens.equal)) e$1.value = this._const_expression();
		if (null !== e$1.type && e$1.value instanceof xe) {
			if ("x32" !== e$1.value.type.name) {
				if (e$1.type.getTypeName() !== e$1.value.type.getTypeName()) throw this._error(this._peek(), `Invalid cast from ${e$1.value.type.name} to ${e$1.type.name}. Line:${this._currentLine}`);
			}
			e$1.value.isScalar && this._validateTypeRange(e$1.value.scalarValue, e$1.type), e$1.value.type = e$1.type;
		} else null === e$1.type && e$1.value instanceof xe && (e$1.type = "x32" === e$1.value.type.name ? ae.i32 : e$1.value.type, e$1.value.isScalar && this._validateTypeRange(e$1.value.scalarValue, e$1.type));
		return e$1;
	}
	_override_variable_decl() {
		const e$1 = this._override_decl();
		return e$1 && this._match(He.tokens.equal) && (e$1.value = this._const_expression()), e$1;
	}
	_global_const_decl() {
		var e$1;
		if (!this._match(He.keywords.const)) return null;
		const t$1 = this._consume(He.tokens.name, "Expected variable name"), n$1 = this._currentLine;
		let s$1 = null;
		if (this._match(He.tokens.colon)) {
			const e$2 = this._attribute();
			s$1 = this._type_decl(), null != s$1 && (s$1.attributes = e$2);
		}
		let r$1 = null;
		this._consume(He.tokens.equal, "const declarations require an assignment");
		const i$1 = this._short_circuit_or_expression();
		try {
			let e$2 = [ae.f32], n$2 = i$1.constEvaluate(this._exec, e$2);
			n$2 instanceof Be && this._validateTypeRange(n$2.value, e$2[0]), e$2[0] instanceof ce && null === e$2[0].format && n$2.typeInfo instanceof a && null !== n$2.typeInfo.format && ("f16" === n$2.typeInfo.format.name ? e$2[0].format = ae.f16 : "f32" === n$2.typeInfo.format.name ? e$2[0].format = ae.f32 : "i32" === n$2.typeInfo.format.name ? e$2[0].format = ae.i32 : "u32" === n$2.typeInfo.format.name ? e$2[0].format = ae.u32 : "bool" === n$2.typeInfo.format.name ? e$2[0].format = ae.bool : console.error(`TODO: impelement template format type ${n$2.typeInfo.format.name}`)), r$1 = this._updateNode(new xe(n$2, e$2[0])), this._exec.context.setVariable(t$1.toString(), n$2);
		} catch (e$2) {
			r$1 = i$1;
		}
		if (null !== s$1 && r$1 instanceof xe) {
			if ("x32" !== r$1.type.name) {
				if (s$1.getTypeName() !== r$1.type.getTypeName()) throw this._error(this._peek(), `Invalid cast from ${r$1.type.name} to ${s$1.name}. Line:${this._currentLine}`);
			}
			r$1.type = s$1, r$1.isScalar && this._validateTypeRange(r$1.scalarValue, r$1.type);
		} else null === s$1 && r$1 instanceof xe && (s$1 = null !== (e$1 = null == r$1 ? void 0 : r$1.type) && void 0 !== e$1 ? e$1 : ae.f32, s$1 === ae.x32 && (s$1 = ae.i32));
		const o$1 = this._updateNode(new P(t$1.toString(), s$1, "", "", r$1), n$1);
		return this._context.constants.set(o$1.name, o$1), o$1;
	}
	_global_let_decl() {
		if (!this._match(He.keywords.let)) return null;
		const e$1 = this._currentLine, t$1 = this._consume(He.tokens.name, "Expected variable name");
		let n$1 = null;
		if (this._match(He.tokens.colon)) {
			const e$2 = this._attribute();
			n$1 = this._type_decl(), null != n$1 && (n$1.attributes = e$2);
		}
		let s$1 = null;
		if (this._match(He.tokens.equal) && (s$1 = this._const_expression()), null !== n$1 && s$1 instanceof xe) {
			if ("x32" !== s$1.type.name) {
				if (n$1.getTypeName() !== s$1.type.getTypeName()) throw this._error(this._peek(), `Invalid cast from ${s$1.type.name} to ${n$1.name}. Line:${this._currentLine}`);
			}
			s$1.type = n$1;
		} else null === n$1 && s$1 instanceof xe && (n$1 = "x32" === s$1.type.name ? ae.i32 : s$1.type);
		return s$1 instanceof xe && s$1.isScalar && this._validateTypeRange(s$1.scalarValue, n$1), this._updateNode(new U(t$1.toString(), n$1, "", "", s$1), e$1);
	}
	_const_expression() {
		return this._short_circuit_or_expression();
	}
	_variable_decl() {
		if (!this._match(He.keywords.var)) return null;
		const e$1 = this._currentLine;
		let t$1 = "", n$1 = "";
		this._match(He.tokens.less_than) && (t$1 = this._consume(He.storage_class, "Expected storage_class.").toString(), this._match(He.tokens.comma) && (n$1 = this._consume(He.access_mode, "Expected access_mode.").toString()), this._consume(He.tokens.greater_than, "Expected '>'."));
		const s$1 = this._consume(He.tokens.name, "Expected variable name");
		let r$1 = null;
		if (this._match(He.tokens.colon)) {
			const e$2 = this._attribute();
			r$1 = this._type_decl(), null != r$1 && (r$1.attributes = e$2);
		}
		return this._updateNode(new F(s$1.toString(), r$1, t$1, n$1, null), e$1);
	}
	_override_decl() {
		if (!this._match(He.keywords.override)) return null;
		const e$1 = this._consume(He.tokens.name, "Expected variable name");
		let t$1 = null;
		if (this._match(He.tokens.colon)) {
			const e$2 = this._attribute();
			t$1 = this._type_decl(), null != t$1 && (t$1.attributes = e$2);
		}
		return this._updateNode(new M(e$1.toString(), t$1, null));
	}
	_diagnostic() {
		this._consume(He.tokens.paren_left, "Expected '('");
		const e$1 = this._consume(He.tokens.ident, "Expected severity control name.");
		this._consume(He.tokens.comma, "Expected ','");
		let t$1 = this._consume(He.tokens.ident, "Expected diagnostic rule name.").toString();
		if (this._match(He.tokens.period)) t$1 += `.${this._consume(He.tokens.ident, "Expected diagnostic message.").toString()}`;
		return this._consume(He.tokens.paren_right, "Expected ')'"), this._updateNode(new ee(e$1.toString(), t$1));
	}
	_enable_directive() {
		const e$1 = this._consume(He.tokens.ident, "identity expected.");
		return this._updateNode(new K(e$1.toString()));
	}
	_requires_directive() {
		const e$1 = [this._consume(He.tokens.ident, "identity expected.").toString()];
		for (; this._match(He.tokens.comma);) {
			const t$1 = this._consume(He.tokens.ident, "identity expected.");
			e$1.push(t$1.toString());
		}
		return this._updateNode(new J(e$1));
	}
	_type_alias() {
		const e$1 = this._consume(He.tokens.ident, "identity expected.");
		this._consume(He.tokens.equal, "Expected '=' for type alias.");
		let t$1 = this._type_decl();
		if (null === t$1) throw this._error(this._peek(), "Expected Type for Alias.");
		this._context.aliases.has(t$1.name) && (t$1 = this._context.aliases.get(t$1.name).type);
		const n$1 = this._updateNode(new te(e$1.toString(), t$1));
		return this._context.aliases.set(n$1.name, n$1), n$1;
	}
	_type_decl() {
		if (this._check([
			He.tokens.ident,
			...He.texel_format,
			He.keywords.bool,
			He.keywords.f32,
			He.keywords.i32,
			He.keywords.u32
		])) {
			const e$2 = this._advance().toString();
			if (this._context.structs.has(e$2)) return this._context.structs.get(e$2);
			if (this._context.aliases.has(e$2)) return this._context.aliases.get(e$2).type;
			if (!this._getType(e$2)) {
				const t$2 = this._updateNode(new ie(e$2));
				return this._forwardTypeCount++, t$2;
			}
			return this._updateNode(new ae(e$2));
		}
		let e$1 = this._texture_sampler_types();
		if (e$1) return e$1;
		if (this._check(He.template_types)) {
			let e$2 = this._advance().toString(), t$2 = null, n$1 = null;
			this._match(He.tokens.less_than) && (t$2 = this._type_decl(), n$1 = null, this._match(He.tokens.comma) && (n$1 = this._consume(He.access_mode, "Expected access_mode for pointer").toString()), this._consume(He.tokens.greater_than, "Expected '>' for type."));
			return this._updateNode(new ce(e$2, t$2, n$1));
		}
		if (this._match(He.keywords.ptr)) {
			let e$2 = this._previous().toString();
			this._consume(He.tokens.less_than, "Expected '<' for pointer.");
			const t$2 = this._consume(He.storage_class, "Expected storage_class for pointer");
			this._consume(He.tokens.comma, "Expected ',' for pointer.");
			const n$1 = this._type_decl();
			let s$1 = null;
			this._match(He.tokens.comma) && (s$1 = this._consume(He.access_mode, "Expected access_mode for pointer").toString()), this._consume(He.tokens.greater_than, "Expected '>' for pointer.");
			return this._updateNode(new le(e$2, t$2.toString(), n$1, s$1));
		}
		const t$1 = this._attribute();
		if (this._match(He.keywords.array)) {
			let e$2 = null, n$1 = -1;
			const s$1 = this._previous();
			let r$1 = null;
			if (this._match(He.tokens.less_than)) {
				e$2 = this._type_decl(), this._context.aliases.has(e$2.name) && (e$2 = this._context.aliases.get(e$2.name).type);
				let t$2 = "";
				if (this._match(He.tokens.comma)) {
					r$1 = this._shift_expression();
					try {
						t$2 = r$1.constEvaluate(this._exec).toString(), r$1 = null;
					} catch (e$3) {
						t$2 = "1";
					}
				}
				this._consume(He.tokens.greater_than, "Expected '>' for array."), n$1 = t$2 ? parseInt(t$2) : 0;
			}
			const a$1 = this._updateNode(new ue(s$1.toString(), t$1, e$2, n$1));
			return r$1 && this._deferArrayCountEval.push({
				arrayType: a$1,
				countNode: r$1
			}), a$1;
		}
		return null;
	}
	_texture_sampler_types() {
		if (this._match(He.sampler_type)) return this._updateNode(new he(this._previous().toString(), null, null));
		if (this._match(He.depth_texture_type)) return this._updateNode(new he(this._previous().toString(), null, null));
		if (this._match(He.sampled_texture_type) || this._match(He.multisampled_texture_type)) {
			const e$1 = this._previous();
			this._consume(He.tokens.less_than, "Expected '<' for sampler type.");
			const t$1 = this._type_decl();
			return this._consume(He.tokens.greater_than, "Expected '>' for sampler type."), this._updateNode(new he(e$1.toString(), t$1, null));
		}
		if (this._match(He.storage_texture_type)) {
			const e$1 = this._previous();
			this._consume(He.tokens.less_than, "Expected '<' for sampler type.");
			const t$1 = this._consume(He.texel_format, "Invalid texel format.").toString();
			this._consume(He.tokens.comma, "Expected ',' after texel format.");
			const n$1 = this._consume(He.access_mode, "Expected access mode for storage texture type.").toString();
			return this._consume(He.tokens.greater_than, "Expected '>' for sampler type."), this._updateNode(new he(e$1.toString(), t$1, n$1));
		}
		return null;
	}
	_attribute() {
		let e$1 = [];
		for (; this._match(He.tokens.attr);) {
			const t$1 = this._consume(He.attribute_name, "Expected attribute name"), n$1 = this._updateNode(new De(t$1.toString(), null));
			if (this._match(He.tokens.paren_left)) {
				if (n$1.value = this._consume(He.literal_or_ident, "Expected attribute value").toString(), this._check(He.tokens.comma)) {
					this._advance();
					do {
						const e$2 = this._consume(He.literal_or_ident, "Expected attribute value").toString();
						n$1.value instanceof Array || (n$1.value = [n$1.value]), n$1.value.push(e$2);
					} while (this._match(He.tokens.comma));
				}
				this._consume(He.tokens.paren_right, "Expected ')'");
			}
			e$1.push(n$1);
		}
		return 0 == e$1.length ? null : e$1;
	}
};
var _t = class extends at {
	constructor(e$1) {
		super(), e$1 && this.update(e$1);
	}
	update(e$1) {
		const t$1 = new gt().parse(e$1);
		this.updateAST(t$1);
	}
};

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/lib/wgsl/get-shader-layout-wgsl.js
/**
* Parse a ShaderLayout from WGSL shader source code.
* @param source WGSL source code (can contain both @vertex and @fragment entry points)
* @returns
*/
function getShaderLayoutFromWGSL(source) {
	const shaderLayout = {
		attributes: [],
		bindings: []
	};
	let parsedWGSL;
	try {
		parsedWGSL = parseWGSL(source);
	} catch (error) {
		log.error(error.message)();
		return shaderLayout;
	}
	for (const uniform of parsedWGSL.uniforms) {
		const members = [];
		for (const attribute of uniform.type?.members || []) members.push({
			name: attribute.name,
			type: getType(attribute.type)
		});
		shaderLayout.bindings.push({
			type: "uniform",
			name: uniform.name,
			group: uniform.group,
			location: uniform.binding,
			members
		});
	}
	for (const texture of parsedWGSL.textures) shaderLayout.bindings.push({
		type: "texture",
		name: texture.name,
		group: texture.group,
		location: texture.binding
	});
	for (const sampler of parsedWGSL.samplers) shaderLayout.bindings.push({
		type: "sampler",
		name: sampler.name,
		group: sampler.group,
		location: sampler.binding
	});
	const vertex = parsedWGSL.entry.vertex[0];
	const attributeCount = vertex?.inputs.length || 0;
	for (let i$1 = 0; i$1 < attributeCount; i$1++) {
		const wgslAttribute = vertex.inputs[i$1];
		if (wgslAttribute.locationType === "location") {
			const type = getType(wgslAttribute.type);
			shaderLayout.attributes.push({
				name: wgslAttribute.name,
				location: Number(wgslAttribute.location),
				type
			});
		}
	}
	return shaderLayout;
}
/** Get a valid shader attribute type string from a wgsl-reflect type */
function getType(type) {
	return type?.format ? `${type.name}<${type.format.name}>` : type.name;
}
function parseWGSL(source) {
	try {
		return new _t(source);
	} catch (error) {
		if (error instanceof Error) throw error;
		let message = "WGSL parse error";
		if (typeof error === "object" && error?.message) message += `: ${error.message} `;
		if (typeof error === "object" && error?.token) message += error.token.line || "";
		throw new Error(message, { cause: error });
	}
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64-utils.js
/**
* Calculate WebGL 64 bit float
* @param a  - the input float number
* @param out - the output array. If not supplied, a new array is created.
* @param startIndex - the index in the output array to fill from. Default 0.
* @returns - the fp64 representation of the input number
*/
function fp64ify(a$1, out = [], startIndex = 0) {
	const hiPart = Math.fround(a$1);
	const loPart = a$1 - hiPart;
	out[startIndex] = hiPart;
	out[startIndex + 1] = loPart;
	return out;
}
/**
* Calculate the low part of a WebGL 64 bit float
* @param a the input float number
* @returns the lower 32 bit of the number
*/
function fp64LowPart(a$1) {
	return a$1 - Math.fround(a$1);
}
/**
* Calculate WebGL 64 bit matrix (transposed "Float64Array")
* @param matrix  the input matrix
* @returns the fp64 representation of the input matrix
*/
function fp64ifyMatrix4(matrix) {
	const matrixFP64 = new Float32Array(32);
	for (let i$1 = 0; i$1 < 4; ++i$1) for (let j$1 = 0; j$1 < 4; ++j$1) {
		const index = i$1 * 4 + j$1;
		fp64ify(matrix[j$1 * 4 + i$1], matrixFP64, index * 2);
	}
	return matrixFP64;
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64-arithmetic-glsl.js
const fp64arithmeticShader = `\

uniform fp64arithmeticUniforms {
  uniform float ONE;
} fp64;

/*
About LUMA_FP64_CODE_ELIMINATION_WORKAROUND

The purpose of this workaround is to prevent shader compilers from
optimizing away necessary arithmetic operations by swapping their sequences
or transform the equation to some 'equivalent' form.

The method is to multiply an artifical variable, ONE, which will be known to
the compiler to be 1 only at runtime. The whole expression is then represented
as a polynomial with respective to ONE. In the coefficients of all terms, only one a
and one b should appear

err = (a + b) * ONE^6 - a * ONE^5 - (a + b) * ONE^4 + a * ONE^3 - b - (a + b) * ONE^2 + a * ONE
*/

// Divide float number to high and low floats to extend fraction bits
vec2 split(float a) {
  const float SPLIT = 4097.0;
  float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float a_hi = t * fp64.ONE - (t - a);
  float a_lo = a * fp64.ONE - a_hi;
#else
  float a_hi = t - (t - a);
  float a_lo = a - a_hi;
#endif
  return vec2(a_hi, a_lo);
}

// Divide float number again when high float uses too many fraction bits
vec2 split2(vec2 a) {
  vec2 b = split(a.x);
  b.y += a.y;
  return b;
}

// Special sum operation when a > b
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float sum = (a + b) * fp64.ONE;
  float err = b - (sum - a) * fp64.ONE;
#else
  float sum = a + b;
  float err = b - (sum - a);
#endif
  return vec2(sum, err);
}

// General sum operation
vec2 twoSum(float a, float b) {
  float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE + (b - v);
#else
  float v = s - a;
  float err = (a - (s - v)) + (b - v);
#endif
  return vec2(s, err);
}

vec2 twoSub(float a, float b) {
  float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE - (b + v);
#else
  float v = s - a;
  float err = (a - (s - v)) - (b + v);
#endif
  return vec2(s, err);
}

vec2 twoSqr(float a) {
  float prod = a * a;
  vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float err = ((a_fp64.x * a_fp64.x - prod) * fp64.ONE + 2.0 * a_fp64.x *
    a_fp64.y * fp64.ONE * fp64.ONE) + a_fp64.y * a_fp64.y * fp64.ONE * fp64.ONE * fp64.ONE;
#else
  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
  return vec2(prod, err);
}

vec2 twoProd(float a, float b) {
  float prod = a * b;
  vec2 a_fp64 = split(a);
  vec2 b_fp64 = split(b);
  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
  return vec2(prod, err);
}

vec2 sum_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSum(a.x, b.x);
  t = twoSum(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 sub_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSub(a.x, b.x);
  t = twoSub(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 mul_fp64(vec2 a, vec2 b) {
  vec2 prod = twoProd(a.x, b.x);
  // y component is for the error
  prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  return prod;
}

vec2 div_fp64(vec2 a, vec2 b) {
  float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
  vec2 yn = a * xn;
#endif
  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
  vec2 prod = twoProd(xn, diff);
  return sum_fp64(yn, prod);
}

vec2 sqrt_fp64(vec2 a) {
  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);

  float x = 1.0 / sqrt(a.x);
  float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  vec2 yn_sqr = twoSqr(yn) * fp64.ONE;
#else
  vec2 yn_sqr = twoSqr(yn);
#endif
  float diff = sub_fp64(a, yn_sqr).x;
  vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  return sum_fp64(split(yn), prod);
#else
  return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`;

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64.js
var defaultUniforms = { ONE: 1 };
/**
* 64bit arithmetic: add, sub, mul, div (small subset of fp64 module)
*/
const fp64arithmetic = {
	name: "fp64arithmetic",
	vs: fp64arithmeticShader,
	defaultUniforms,
	uniformTypes: { ONE: "f32" },
	fp64ify,
	fp64LowPart,
	fp64ifyMatrix4
};

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting-glsl.js
const lightingUniformsGLSL = `\
precision highp int;

// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  vec3 color;
};

struct PointLight {
  vec3 color;
  vec3 position;
  vec3 attenuation; // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  vec3 color;
  vec3 direction;
};

uniform lightingUniforms {
  int enabled;
  int lightType;

  int directionalLightCount;
  int pointLightCount;

  vec3 ambientColor;

  vec3 lightColor0;
  vec3 lightPosition0;
  vec3 lightDirection0;
  vec3 lightAttenuation0;

  vec3 lightColor1;
  vec3 lightPosition1;
  vec3 lightDirection1;
  vec3 lightAttenuation1;

  vec3 lightColor2;
  vec3 lightPosition2;
  vec3 lightDirection2;
  vec3 lightAttenuation2;
} lighting;

PointLight lighting_getPointLight(int index) {
  switch (index) {
    case 0:
      return PointLight(lighting.lightColor0, lighting.lightPosition0, lighting.lightAttenuation0);
    case 1:
      return PointLight(lighting.lightColor1, lighting.lightPosition1, lighting.lightAttenuation1);
    case 2:
    default:  
      return PointLight(lighting.lightColor2, lighting.lightPosition2, lighting.lightAttenuation2);
  }
}

DirectionalLight lighting_getDirectionalLight(int index) {
  switch (index) {
    case 0:
      return DirectionalLight(lighting.lightColor0, lighting.lightDirection0);
    case 1:
      return DirectionalLight(lighting.lightColor1, lighting.lightDirection1);
    case 2:
    default:   
      return DirectionalLight(lighting.lightColor2, lighting.lightDirection2);
  }
} 

float getPointLightAttenuation(PointLight pointLight, float distance) {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}

// #endif
`;

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting-wgsl.js
const lightingUniformsWGSL = `\
// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  color: vec3<f32>,
};

struct PointLight {
  color: vec3<f32>,
  position: vec3<f32>,
  attenuation: vec3<f32>, // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  color: vec3<f32>,
  direction: vec3<f32>,
};

struct lightingUniforms {
  enabled: i32,
  pointLightCount: i32,
  directionalLightCount: i32,

  ambientColor: vec3<f32>,

  // TODO - support multiple lights by uncommenting arrays below
  lightType: i32,
  lightColor: vec3<f32>,
  lightDirection: vec3<f32>,
  lightPosition: vec3<f32>,
  lightAttenuation: vec3<f32>,

  // AmbientLight ambientLight;
  // PointLight pointLight[MAX_LIGHTS];
  // DirectionalLight directionalLight[MAX_LIGHTS];
};

// Binding 0:1 is reserved for lighting (Note: could go into separate bind group as it is stable across draw calls)
@binding(1) @group(0) var<uniform> lighting : lightingUniforms;

fn lighting_getPointLight(index: i32) -> PointLight {
  return PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);
}

fn lighting_getDirectionalLight(index: i32) -> DirectionalLight {
  return DirectionalLight(lighting.lightColor, lighting.lightDirection);
} 

fn getPointLightAttenuation(pointLight: PointLight, distance: f32) -> f32 {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}
`;

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting.js
/** Max number of supported lights (in addition to ambient light */
var MAX_LIGHTS = 5;
/** Whether to divide */
var COLOR_FACTOR = 255;
/** Shader type field for lights */
var LIGHT_TYPE;
(function(LIGHT_TYPE$1) {
	LIGHT_TYPE$1[LIGHT_TYPE$1["POINT"] = 0] = "POINT";
	LIGHT_TYPE$1[LIGHT_TYPE$1["DIRECTIONAL"] = 1] = "DIRECTIONAL";
})(LIGHT_TYPE || (LIGHT_TYPE = {}));
/** UBO ready lighting module */
const lighting = {
	props: {},
	uniforms: {},
	name: "lighting",
	defines: {},
	uniformTypes: {
		enabled: "i32",
		lightType: "i32",
		directionalLightCount: "i32",
		pointLightCount: "i32",
		ambientColor: "vec3<f32>",
		lightColor0: "vec3<f32>",
		lightPosition0: "vec3<f32>",
		lightDirection0: "vec3<f32>",
		lightAttenuation0: "vec3<f32>",
		lightColor1: "vec3<f32>",
		lightPosition1: "vec3<f32>",
		lightDirection1: "vec3<f32>",
		lightAttenuation1: "vec3<f32>",
		lightColor2: "vec3<f32>",
		lightPosition2: "vec3<f32>",
		lightDirection2: "vec3<f32>",
		lightAttenuation2: "vec3<f32>"
	},
	defaultUniforms: {
		enabled: 1,
		lightType: LIGHT_TYPE.POINT,
		directionalLightCount: 0,
		pointLightCount: 0,
		ambientColor: [
			.1,
			.1,
			.1
		],
		lightColor0: [
			1,
			1,
			1
		],
		lightPosition0: [
			1,
			1,
			2
		],
		lightDirection0: [
			1,
			1,
			1
		],
		lightAttenuation0: [
			1,
			0,
			0
		],
		lightColor1: [
			1,
			1,
			1
		],
		lightPosition1: [
			1,
			1,
			2
		],
		lightDirection1: [
			1,
			1,
			1
		],
		lightAttenuation1: [
			1,
			0,
			0
		],
		lightColor2: [
			1,
			1,
			1
		],
		lightPosition2: [
			1,
			1,
			2
		],
		lightDirection2: [
			1,
			1,
			1
		],
		lightAttenuation2: [
			1,
			0,
			0
		]
	},
	source: lightingUniformsWGSL,
	vs: lightingUniformsGLSL,
	fs: lightingUniformsGLSL,
	getUniforms
};
function getUniforms(props, prevUniforms = {}) {
	props = props ? { ...props } : props;
	if (!props) return { ...lighting.defaultUniforms };
	if (props.lights) props = {
		...props,
		...extractLightTypes(props.lights),
		lights: void 0
	};
	const { ambientLight, pointLights, directionalLights } = props || {};
	if (!(ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0)) return {
		...lighting.defaultUniforms,
		enabled: 0
	};
	const uniforms = {
		...lighting.defaultUniforms,
		...prevUniforms,
		...getLightSourceUniforms({
			ambientLight,
			pointLights,
			directionalLights
		})
	};
	if (props.enabled !== void 0) uniforms.enabled = props.enabled ? 1 : 0;
	return uniforms;
}
function getLightSourceUniforms({ ambientLight, pointLights = [], directionalLights = [] }) {
	const lightSourceUniforms = {};
	lightSourceUniforms.ambientColor = convertColor(ambientLight);
	let currentLight = 0;
	for (const pointLight of pointLights) {
		lightSourceUniforms.lightType = LIGHT_TYPE.POINT;
		const i$1 = currentLight;
		lightSourceUniforms[`lightColor${i$1}`] = convertColor(pointLight);
		lightSourceUniforms[`lightPosition${i$1}`] = pointLight.position;
		lightSourceUniforms[`lightAttenuation${i$1}`] = pointLight.attenuation || [
			1,
			0,
			0
		];
		currentLight++;
	}
	for (const directionalLight of directionalLights) {
		lightSourceUniforms.lightType = LIGHT_TYPE.DIRECTIONAL;
		const i$1 = currentLight;
		lightSourceUniforms[`lightColor${i$1}`] = convertColor(directionalLight);
		lightSourceUniforms[`lightDirection${i$1}`] = directionalLight.direction;
		currentLight++;
	}
	if (currentLight > MAX_LIGHTS) log.warn("MAX_LIGHTS exceeded")();
	lightSourceUniforms.directionalLightCount = directionalLights.length;
	lightSourceUniforms.pointLightCount = pointLights.length;
	return lightSourceUniforms;
}
function extractLightTypes(lights) {
	const lightSources = {
		pointLights: [],
		directionalLights: []
	};
	for (const light of lights || []) switch (light.type) {
		case "ambient":
			lightSources.ambientLight = light;
			break;
		case "directional":
			lightSources.directionalLights?.push(light);
			break;
		case "point":
			lightSources.pointLights?.push(light);
			break;
		default:
	}
	return lightSources;
}
/** Take color 0-255 and intensity as input and output 0.0-1.0 range */
function convertColor(colorDef = {}) {
	const { color = [
		0,
		0,
		0
	], intensity = 1 } = colorDef;
	return color.map((component) => component * intensity / COLOR_FACTOR);
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/modules/lighting/phong-material/phong-shaders-glsl.js
const PHONG_VS = `\
uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;
`;
const PHONG_FS = `\
#define MAX_LIGHTS 3

uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
  vec3 halfway_direction = normalize(light_direction + view_direction);
  float lambertian = dot(light_direction, normal_worldspace);
  float specular = 0.0;
  if (lambertian > 0.0) {
    float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, material.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;
}

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  vec3 view_direction = normalize(cameraPosition - position_worldspace);
  lightColor = material.ambient * surfaceColor * lighting.ambientColor;

  for (int i = 0; i < lighting.pointLightCount; i++) {
    PointLight pointLight = lighting_getPointLight(i);
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    float light_attenuation = getPointLightAttenuation(pointLight, distance(light_position_worldspace, position_worldspace));
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color / light_attenuation);
  }

  int totalLights = min(MAX_LIGHTS, lighting.pointLightCount + lighting.directionalLightCount);
  for (int i = lighting.pointLightCount; i < totalLights; i++) {
    DirectionalLight directionalLight = lighting_getDirectionalLight(i);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
}
`;

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/modules/lighting/phong-material/phong-shaders-wgsl.js
const PHONG_WGSL = `\
struct phongMaterialUniforms {
  ambient: f32,
  diffuse: f32,
  shininess: f32,
  specularColor: vec3<f32>,
};

@binding(2) @group(0) var<uniform> phongMaterial : phongMaterialUniforms;

fn lighting_getLightColor(surfaceColor: vec3<f32>, light_direction: vec3<f32>, view_direction: vec3<f32>, normal_worldspace: vec3<f32>, color: vec3<f32>) -> vec3<f32> {
  let halfway_direction: vec3<f32> = normalize(light_direction + view_direction);
  var lambertian: f32 = dot(light_direction, normal_worldspace);
  var specular: f32 = 0.0;
  if (lambertian > 0.0) {
    let specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, phongMaterial.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * phongMaterial.diffuse * surfaceColor + specular * phongMaterial.specularColor) * color;
}

fn lighting_getLightColor2(surfaceColor: vec3<f32>, cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32> {
  var lightColor: vec3<f32> = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  let view_direction: vec3<f32> = normalize(cameraPosition - position_worldspace);
  lightColor = phongMaterial.ambient * surfaceColor * lighting.ambientColor;

  if (lighting.lightType == 0) {
    let pointLight: PointLight  = lighting_getPointLight(0);
    let light_position_worldspace: vec3<f32> = pointLight.position;
    let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  } else if (lighting.lightType == 1) {
    var directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
  /*
  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.pointLightCount) {
      break;
    }
    PointLight pointLight = lighting.pointLight[i];
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  }

  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.directionalLightCount) {
      break;
    }
    DirectionalLight directionalLight = lighting.directionalLight[i];
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  */
}

fn lighting_getSpecularLightColor(cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32>{
  var lightColor = vec3<f32>(0, 0, 0);
  let surfaceColor = vec3<f32>(0, 0, 0);

  if (lighting.enabled == 0) {
    let view_direction = normalize(cameraPosition - position_worldspace);

    switch (lighting.lightType) {
      case 0, default: {
        let pointLight: PointLight = lighting_getPointLight(0);
        let light_position_worldspace: vec3<f32> = pointLight.position;
        let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
        lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
      }
      case 1: {
        let directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
        lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
      }
    }
  }
  return lightColor;
}
`;
/**
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting.pointLightCount) {
break;
}
PointLight pointLight = lighting_getPointLight(i);
vec3 light_position_worldspace = pointLight.position;
vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
}

for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting.directionalLightCount) {
break;
}
PointLight pointLight = lighting_getDirectionalLight(i);
lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
}
}
/**
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting.pointLightCount) {
break;
}
PointLight pointLight = lighting_getPointLight(i);
vec3 light_position_worldspace = pointLight.position;
vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
}

for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting.directionalLightCount) {
break;
}
PointLight pointLight = lighting_getDirectionalLight(i);
lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
}
}
*/

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/modules/lighting/gouraud-material/gouraud-material.js
/** In Gouraud shading, color is calculated for each triangle vertex normal, and then color is interpolated colors across the triangle */
const gouraudMaterial = {
	props: {},
	name: "gouraudMaterial",
	vs: PHONG_FS.replace("phongMaterial", "gouraudMaterial"),
	fs: PHONG_VS.replace("phongMaterial", "gouraudMaterial"),
	source: PHONG_WGSL.replaceAll("phongMaterial", "gouraudMaterial"),
	defines: { LIGHTING_VERTEX: true },
	dependencies: [lighting],
	uniformTypes: {
		ambient: "f32",
		diffuse: "f32",
		shininess: "f32",
		specularColor: "vec3<f32>"
	},
	defaultUniforms: {
		ambient: .35,
		diffuse: .6,
		shininess: 32,
		specularColor: [
			.15,
			.15,
			.15
		]
	},
	getUniforms(props) {
		const uniforms = { ...props };
		if (uniforms.specularColor) uniforms.specularColor = uniforms.specularColor.map((x$1) => x$1 / 255);
		return {
			...gouraudMaterial.defaultUniforms,
			...uniforms
		};
	}
};

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/modules/lighting/phong-material/phong-material.js
/** In Phong shading, the normal vector is linearly interpolated across the surface of the polygon from the polygon's vertex normals. */
const phongMaterial = {
	name: "phongMaterial",
	dependencies: [lighting],
	source: PHONG_WGSL,
	vs: PHONG_VS,
	fs: PHONG_FS,
	defines: { LIGHTING_FRAGMENT: true },
	uniformTypes: {
		ambient: "f32",
		diffuse: "f32",
		shininess: "f32",
		specularColor: "vec3<f32>"
	},
	defaultUniforms: {
		ambient: .35,
		diffuse: .6,
		shininess: 32,
		specularColor: [
			.15,
			.15,
			.15
		]
	},
	getUniforms(props) {
		const uniforms = { ...props };
		if (uniforms.specularColor) uniforms.specularColor = uniforms.specularColor.map((x$1) => x$1 / 255);
		return {
			...phongMaterial.defaultUniforms,
			...uniforms
		};
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/shaderlib/project/project-functions.js
/**
* Projection utils
* TODO: move to Viewport class?
*/
var DEFAULT_COORDINATE_ORIGIN = [
	0,
	0,
	0
];
function lngLatZToWorldPosition(lngLatZ, viewport, offsetMode = false) {
	const p$1 = viewport.projectPosition(lngLatZ);
	if (offsetMode && viewport instanceof web_mercator_viewport_default) {
		const [longitude, latitude, z$1 = 0] = lngLatZ;
		p$1[2] = z$1 * viewport.getDistanceScales([longitude, latitude]).unitsPerMeter[2];
	}
	return p$1;
}
function normalizeParameters(opts) {
	const { viewport, modelMatrix, coordinateOrigin } = opts;
	let { coordinateSystem, fromCoordinateSystem, fromCoordinateOrigin } = opts;
	if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
	if (fromCoordinateSystem === void 0) fromCoordinateSystem = coordinateSystem;
	if (fromCoordinateOrigin === void 0) fromCoordinateOrigin = coordinateOrigin;
	return {
		viewport,
		coordinateSystem,
		coordinateOrigin,
		modelMatrix,
		fromCoordinateSystem,
		fromCoordinateOrigin
	};
}
/** Get the common space position from world coordinates in the given coordinate system */
function getWorldPosition(position, { viewport, modelMatrix, coordinateSystem, coordinateOrigin, offsetMode }) {
	let [x$1, y$1, z$1 = 0] = position;
	if (modelMatrix) [x$1, y$1, z$1] = transformMat4([], [
		x$1,
		y$1,
		z$1,
		1
	], modelMatrix);
	switch (coordinateSystem) {
		case COORDINATE_SYSTEM.LNGLAT: return lngLatZToWorldPosition([
			x$1,
			y$1,
			z$1
		], viewport, offsetMode);
		case COORDINATE_SYSTEM.LNGLAT_OFFSETS: return lngLatZToWorldPosition([
			x$1 + coordinateOrigin[0],
			y$1 + coordinateOrigin[1],
			z$1 + (coordinateOrigin[2] || 0)
		], viewport, offsetMode);
		case COORDINATE_SYSTEM.METER_OFFSETS: return lngLatZToWorldPosition(addMetersToLngLat(coordinateOrigin, [
			x$1,
			y$1,
			z$1
		]), viewport, offsetMode);
		case COORDINATE_SYSTEM.CARTESIAN:
		default: return viewport.isGeospatial ? [
			x$1 + coordinateOrigin[0],
			y$1 + coordinateOrigin[1],
			z$1 + coordinateOrigin[2]
		] : viewport.projectPosition([
			x$1,
			y$1,
			z$1
		]);
	}
}
/**
* Equivalent to project_position in project.glsl
* projects a user supplied position to world position directly with or without
* a reference coordinate system
*/
function projectPosition(position, params) {
	const { viewport, coordinateSystem, coordinateOrigin, modelMatrix, fromCoordinateSystem, fromCoordinateOrigin } = normalizeParameters(params);
	const { autoOffset = true } = params;
	const { geospatialOrigin = DEFAULT_COORDINATE_ORIGIN, shaderCoordinateOrigin = DEFAULT_COORDINATE_ORIGIN, offsetMode = false } = autoOffset ? getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin) : {};
	const worldPosition = getWorldPosition(position, {
		viewport,
		modelMatrix,
		coordinateSystem: fromCoordinateSystem,
		coordinateOrigin: fromCoordinateOrigin,
		offsetMode
	});
	if (offsetMode) {
		const positionCommonSpace = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
		sub(worldPosition, worldPosition, positionCommonSpace);
	}
	return worldPosition;
}

//#endregion
//#region node_modules/@luma.gl/engine/dist/utils/uid.js
var uidCounters = {};
/**
* Returns a UID.
* @param id= - Identifier base name
* @return uid
**/
function uid(id = "id") {
	uidCounters[id] = uidCounters[id] || 1;
	return `${id}-${uidCounters[id]++}`;
}

//#endregion
//#region node_modules/@luma.gl/engine/dist/geometry/gpu-geometry.js
var GPUGeometry = class {
	id;
	userData = {};
	/** Determines how vertices are read from the 'vertex' attributes */
	topology;
	bufferLayout = [];
	vertexCount;
	indices;
	attributes;
	constructor(props) {
		this.id = props.id || uid("geometry");
		this.topology = props.topology;
		this.indices = props.indices || null;
		this.attributes = props.attributes;
		this.vertexCount = props.vertexCount;
		this.bufferLayout = props.bufferLayout || [];
		if (this.indices) {
			if (!(this.indices.usage & Buffer.INDEX)) throw new Error("Index buffer must have INDEX usage");
		}
	}
	destroy() {
		this.indices?.destroy();
		for (const attribute of Object.values(this.attributes)) attribute.destroy();
	}
	getVertexCount() {
		return this.vertexCount;
	}
	getAttributes() {
		return this.attributes;
	}
	getIndexes() {
		return this.indices || null;
	}
	_calculateVertexCount(positions) {
		return positions.byteLength / 12;
	}
};
function makeGPUGeometry(device, geometry) {
	if (geometry instanceof GPUGeometry) return geometry;
	const indices = getIndexBufferFromGeometry(device, geometry);
	const { attributes, bufferLayout } = getAttributeBuffersFromGeometry(device, geometry);
	return new GPUGeometry({
		topology: geometry.topology || "triangle-list",
		bufferLayout,
		vertexCount: geometry.vertexCount,
		indices,
		attributes
	});
}
function getIndexBufferFromGeometry(device, geometry) {
	if (!geometry.indices) return;
	const data = geometry.indices.value;
	return device.createBuffer({
		usage: Buffer.INDEX,
		data
	});
}
function getAttributeBuffersFromGeometry(device, geometry) {
	const bufferLayout = [];
	const attributes = {};
	for (const [attributeName, attribute] of Object.entries(geometry.attributes)) {
		let name = attributeName;
		switch (attributeName) {
			case "POSITION":
				name = "positions";
				break;
			case "NORMAL":
				name = "normals";
				break;
			case "TEXCOORD_0":
				name = "texCoords";
				break;
			case "COLOR_0":
				name = "colors";
				break;
		}
		if (attribute) {
			attributes[name] = device.createBuffer({
				data: attribute.value,
				id: `${attributeName}-buffer`
			});
			const { value, size, normalized } = attribute;
			bufferLayout.push({
				name,
				format: getVertexFormatFromAttribute(value, size, normalized)
			});
		}
	}
	return {
		attributes,
		bufferLayout,
		vertexCount: geometry._calculateVertexCount(geometry.attributes, geometry.indices)
	};
}

//#endregion
//#region node_modules/@luma.gl/engine/dist/factories/pipeline-factory.js
/**
* Efficiently creates / caches pipelines
*/
var PipelineFactory = class PipelineFactory {
	static defaultProps = { ...RenderPipeline.defaultProps };
	/** Get the singleton default pipeline factory for the specified device */
	static getDefaultPipelineFactory(device) {
		device._lumaData["defaultPipelineFactory"] = device._lumaData["defaultPipelineFactory"] || new PipelineFactory(device);
		return device._lumaData["defaultPipelineFactory"];
	}
	device;
	cachingEnabled;
	destroyPolicy;
	debug;
	_hashCounter = 0;
	_hashes = {};
	_renderPipelineCache = {};
	_computePipelineCache = {};
	get [Symbol.toStringTag]() {
		return "PipelineFactory";
	}
	toString() {
		return `PipelineFactory(${this.device.id})`;
	}
	constructor(device) {
		this.device = device;
		this.cachingEnabled = device.props._cachePipelines;
		this.destroyPolicy = device.props._cacheDestroyPolicy;
		this.debug = device.props.debugFactories;
	}
	/** Return a RenderPipeline matching supplied props. Reuses an equivalent pipeline if already created. */
	createRenderPipeline(props) {
		if (!this.cachingEnabled) return this.device.createRenderPipeline(props);
		const allProps = {
			...RenderPipeline.defaultProps,
			...props
		};
		const cache$1 = this._renderPipelineCache;
		const hash = this._hashRenderPipeline(allProps);
		let pipeline = cache$1[hash]?.pipeline;
		if (!pipeline) {
			pipeline = this.device.createRenderPipeline({
				...allProps,
				id: allProps.id ? `${allProps.id}-cached` : uid("unnamed-cached")
			});
			pipeline.hash = hash;
			cache$1[hash] = {
				pipeline,
				useCount: 1
			};
			if (this.debug) log.log(3, `${this}: ${pipeline} created, count=${cache$1[hash].useCount}`)();
		} else {
			cache$1[hash].useCount++;
			if (this.debug) log.log(3, `${this}: ${cache$1[hash].pipeline} reused, count=${cache$1[hash].useCount}, (id=${props.id})`)();
		}
		return pipeline;
	}
	/** Return a ComputePipeline matching supplied props. Reuses an equivalent pipeline if already created. */
	createComputePipeline(props) {
		if (!this.cachingEnabled) return this.device.createComputePipeline(props);
		const allProps = {
			...ComputePipeline.defaultProps,
			...props
		};
		const cache$1 = this._computePipelineCache;
		const hash = this._hashComputePipeline(allProps);
		let pipeline = cache$1[hash]?.pipeline;
		if (!pipeline) {
			pipeline = this.device.createComputePipeline({
				...allProps,
				id: allProps.id ? `${allProps.id}-cached` : void 0
			});
			pipeline.hash = hash;
			cache$1[hash] = {
				pipeline,
				useCount: 1
			};
			if (this.debug) log.log(3, `${this}: ${pipeline} created, count=${cache$1[hash].useCount}`)();
		} else {
			cache$1[hash].useCount++;
			if (this.debug) log.log(3, `${this}: ${cache$1[hash].pipeline} reused, count=${cache$1[hash].useCount}, (id=${props.id})`)();
		}
		return pipeline;
	}
	release(pipeline) {
		if (!this.cachingEnabled) {
			pipeline.destroy();
			return;
		}
		const cache$1 = this._getCache(pipeline);
		const hash = pipeline.hash;
		cache$1[hash].useCount--;
		if (cache$1[hash].useCount === 0) {
			this._destroyPipeline(pipeline);
			if (this.debug) log.log(3, `${this}: ${pipeline} released and destroyed`)();
		} else if (cache$1[hash].useCount < 0) {
			log.error(`${this}: ${pipeline} released, useCount < 0, resetting`)();
			cache$1[hash].useCount = 0;
		} else if (this.debug) log.log(3, `${this}: ${pipeline} released, count=${cache$1[hash].useCount}`)();
	}
	/** Destroy a cached pipeline, removing it from the cache (depending on destroy policy) */
	_destroyPipeline(pipeline) {
		const cache$1 = this._getCache(pipeline);
		switch (this.destroyPolicy) {
			case "never": return false;
			case "unused":
				delete cache$1[pipeline.hash];
				pipeline.destroy();
				return true;
		}
	}
	/** Get the appropriate cache for the type of pipeline */
	_getCache(pipeline) {
		let cache$1;
		if (pipeline instanceof ComputePipeline) cache$1 = this._computePipelineCache;
		if (pipeline instanceof RenderPipeline) cache$1 = this._renderPipelineCache;
		if (!cache$1) throw new Error(`${this}`);
		if (!cache$1[pipeline.hash]) throw new Error(`${this}: ${pipeline} matched incorrect entry`);
		return cache$1;
	}
	/** Calculate a hash based on all the inputs for a compute pipeline */
	_hashComputePipeline(props) {
		const { type } = this.device;
		return `${type}/C/${this._getHash(props.shader.source)}`;
	}
	/** Calculate a hash based on all the inputs for a render pipeline */
	_hashRenderPipeline(props) {
		const vsHash = props.vs ? this._getHash(props.vs.source) : 0;
		const fsHash = props.fs ? this._getHash(props.fs.source) : 0;
		const varyingHash = "-";
		const bufferLayoutHash = this._getHash(JSON.stringify(props.bufferLayout));
		const { type } = this.device;
		switch (type) {
			case "webgl": return `${type}/R/${vsHash}/${fsHash}V${varyingHash}BL${bufferLayoutHash}`;
			case "webgpu":
			default:
				const parameterHash = this._getHash(JSON.stringify(props.parameters));
				return `${type}/R/${vsHash}/${fsHash}V${varyingHash}T${props.topology}P${parameterHash}BL${bufferLayoutHash}`;
		}
	}
	_getHash(key) {
		if (this._hashes[key] === void 0) this._hashes[key] = this._hashCounter++;
		return this._hashes[key];
	}
};

//#endregion
//#region node_modules/@luma.gl/engine/dist/factories/shader-factory.js
/** Manages a cached pool of Shaders for reuse. */
var ShaderFactory = class ShaderFactory {
	static defaultProps = { ...Shader.defaultProps };
	/** Returns the default ShaderFactory for the given {@link Device}, creating one if necessary. */
	static getDefaultShaderFactory(device) {
		device._lumaData["defaultShaderFactory"] ||= new ShaderFactory(device);
		return device._lumaData["defaultShaderFactory"];
	}
	device;
	cachingEnabled;
	destroyPolicy;
	debug;
	_cache = {};
	get [Symbol.toStringTag]() {
		return "ShaderFactory";
	}
	toString() {
		return `${this[Symbol.toStringTag]}(${this.device.id})`;
	}
	/** @internal */
	constructor(device) {
		this.device = device;
		this.cachingEnabled = device.props._cacheShaders;
		this.destroyPolicy = device.props._cacheDestroyPolicy;
		this.debug = true;
	}
	/** Requests a {@link Shader} from the cache, creating a new Shader only if necessary. */
	createShader(props) {
		if (!this.cachingEnabled) return this.device.createShader(props);
		const key = this._hashShader(props);
		let cacheEntry = this._cache[key];
		if (!cacheEntry) {
			const shader = this.device.createShader({
				...props,
				id: props.id ? `${props.id}-cached` : void 0
			});
			this._cache[key] = cacheEntry = {
				shader,
				useCount: 1
			};
			if (this.debug) log.log(3, `${this}: Created new shader ${shader.id}`)();
		} else {
			cacheEntry.useCount++;
			if (this.debug) log.log(3, `${this}: Reusing shader ${cacheEntry.shader.id} count=${cacheEntry.useCount}`)();
		}
		return cacheEntry.shader;
	}
	/** Releases a previously-requested {@link Shader}, destroying it if no users remain. */
	release(shader) {
		if (!this.cachingEnabled) {
			shader.destroy();
			return;
		}
		const key = this._hashShader(shader);
		const cacheEntry = this._cache[key];
		if (cacheEntry) {
			cacheEntry.useCount--;
			if (cacheEntry.useCount === 0) {
				if (this.destroyPolicy === "unused") {
					delete this._cache[key];
					cacheEntry.shader.destroy();
					if (this.debug) log.log(3, `${this}: Releasing shader ${shader.id}, destroyed`)();
				}
			} else if (cacheEntry.useCount < 0) throw new Error(`ShaderFactory: Shader ${shader.id} released too many times`);
			else if (this.debug) log.log(3, `${this}: Releasing shader ${shader.id} count=${cacheEntry.useCount}`)();
		}
	}
	_hashShader(value) {
		return `${value.stage}:${value.source}`;
	}
};

//#endregion
//#region node_modules/@luma.gl/engine/dist/debug/debug-shader-layout.js
/**
* Extracts a table suitable for `console.table()` from a shader layout to assist in debugging.
* @param layout shader layout
* @param name app should provide the most meaningful name, usually the model or pipeline name / id.
* @returns
*/
function getDebugTableForShaderLayout(layout, name) {
	const table = {};
	const header = "Values";
	if (layout.attributes.length === 0 && !layout.varyings?.length) return { "No attributes or varyings": { [header]: "N/A" } };
	for (const attributeDeclaration of layout.attributes) if (attributeDeclaration) {
		const glslDeclaration = `${attributeDeclaration.location} ${attributeDeclaration.name}: ${attributeDeclaration.type}`;
		table[`in ${glslDeclaration}`] = { [header]: attributeDeclaration.stepMode || "vertex" };
	}
	for (const varyingDeclaration of layout.varyings || []) {
		const glslDeclaration = `${varyingDeclaration.location} ${varyingDeclaration.name}`;
		table[`out ${glslDeclaration}`] = { [header]: JSON.stringify(varyingDeclaration) };
	}
	return table;
}

//#endregion
//#region node_modules/@luma.gl/engine/dist/debug/debug-framebuffer.js
/** Only works with 1st device? */
var canvas = null;
var ctx = null;
/** Debug utility to draw FBO contents onto screen */
function debugFramebuffer(fbo, { id, minimap, opaque, top = "0", left = "0", rgbaScale = 1 }) {
	if (!canvas) {
		canvas = document.createElement("canvas");
		canvas.id = id;
		canvas.title = id;
		canvas.style.zIndex = "100";
		canvas.style.position = "absolute";
		canvas.style.top = top;
		canvas.style.left = left;
		canvas.style.border = "blue 5px solid";
		canvas.style.transform = "scaleY(-1)";
		document.body.appendChild(canvas);
		ctx = canvas.getContext("2d");
	}
	if (canvas.width !== fbo.width || canvas.height !== fbo.height) {
		canvas.width = fbo.width / 2;
		canvas.height = fbo.height / 2;
		canvas.style.width = "400px";
		canvas.style.height = "400px";
	}
	const color = fbo.device.readPixelsToArrayWebGL(fbo);
	const imageData = ctx?.createImageData(fbo.width, fbo.height);
	if (imageData) {
		const offset = 0;
		for (let i$1 = 0; i$1 < color.length; i$1 += 4) {
			imageData.data[offset + i$1 + 0] = color[i$1 + 0] * rgbaScale;
			imageData.data[offset + i$1 + 1] = color[i$1 + 1] * rgbaScale;
			imageData.data[offset + i$1 + 2] = color[i$1 + 2] * rgbaScale;
			imageData.data[offset + i$1 + 3] = opaque ? 255 : color[i$1 + 3] * rgbaScale;
		}
		ctx?.putImageData(imageData, 0, 0);
	}
}

//#endregion
//#region node_modules/@luma.gl/engine/dist/utils/deep-equal.js
/**
* Fast partial deep equal for prop.
*
* @param a Prop
* @param b Prop to compare against `a`
* @param depth Depth to which to recurse in nested Objects/Arrays. Use 0 (default) for shallow comparison, -1 for infinite depth
*/
function deepEqual$1(a$1, b$1, depth) {
	if (a$1 === b$1) return true;
	if (!depth || !a$1 || !b$1) return false;
	if (Array.isArray(a$1)) {
		if (!Array.isArray(b$1) || a$1.length !== b$1.length) return false;
		for (let i$1 = 0; i$1 < a$1.length; i$1++) if (!deepEqual$1(a$1[i$1], b$1[i$1], depth - 1)) return false;
		return true;
	}
	if (Array.isArray(b$1)) return false;
	if (typeof a$1 === "object" && typeof b$1 === "object") {
		const aKeys = Object.keys(a$1);
		const bKeys = Object.keys(b$1);
		if (aKeys.length !== bKeys.length) return false;
		for (const key of aKeys) {
			if (!b$1.hasOwnProperty(key)) return false;
			if (!deepEqual$1(a$1[key], b$1[key], depth - 1)) return false;
		}
		return true;
	}
	return false;
}

//#endregion
//#region node_modules/@luma.gl/engine/dist/utils/buffer-layout-helper.js
/** BufferLayoutHelper is a helper class that should not be used directly by applications */
var BufferLayoutHelper = class {
	bufferLayouts;
	constructor(bufferLayouts) {
		this.bufferLayouts = bufferLayouts;
	}
	getBufferLayout(name) {
		return this.bufferLayouts.find((layout) => layout.name === name) || null;
	}
	/** Get attribute names from a BufferLayout */
	getAttributeNamesForBuffer(bufferLayout) {
		return bufferLayout.attributes ? bufferLayout.attributes?.map((layout) => layout.attribute) : [bufferLayout.name];
	}
	mergeBufferLayouts(bufferLayouts1, bufferLayouts2) {
		const mergedLayouts = [...bufferLayouts1];
		for (const attribute of bufferLayouts2) {
			const index = mergedLayouts.findIndex((attribute2) => attribute2.name === attribute.name);
			if (index < 0) mergedLayouts.push(attribute);
			else mergedLayouts[index] = attribute;
		}
		return mergedLayouts;
	}
	getBufferIndex(bufferName) {
		const bufferIndex = this.bufferLayouts.findIndex((layout) => layout.name === bufferName);
		if (bufferIndex === -1) log.warn(`BufferLayout: Missing buffer for "${bufferName}".`)();
		return bufferIndex;
	}
};

//#endregion
//#region node_modules/@luma.gl/engine/dist/utils/buffer-layout-order.js
function sortedBufferLayoutByShaderSourceLocations(shaderLayout, bufferLayout) {
	const shaderLayoutMap = Object.fromEntries(shaderLayout.attributes.map((attr) => [attr.name, attr.location]));
	const sortedLayout = bufferLayout.slice();
	sortedLayout.sort((a$1, b$1) => {
		const attributeNamesA = a$1.attributes ? a$1.attributes.map((attr) => attr.attribute) : [a$1.name];
		const attributeNamesB = b$1.attributes ? b$1.attributes.map((attr) => attr.attribute) : [b$1.name];
		return Math.min(...attributeNamesA.map((name) => shaderLayoutMap[name])) - Math.min(...attributeNamesB.map((name) => shaderLayoutMap[name]));
	});
	return sortedLayout;
}

//#endregion
//#region node_modules/@math.gl/types/dist/is-array.js
/**
* Check is an array is a typed array
* @param value value to be tested
* @returns input with type narrowed to TypedArray, or null
*/
function isTypedArray(value) {
	return ArrayBuffer.isView(value) && !(value instanceof DataView);
}
/**
* Check is an array is an array of numbers)
* @param value value to be tested
* @returns input with type narrowed to NumberArray, or null
*/
function isNumberArray(value) {
	if (Array.isArray(value)) return value.length === 0 || typeof value[0] === "number";
	return false;
}
/**
* Check is an array is a numeric array (typed array or array of numbers)
* @param value value to be tested
* @returns input with type narrowed to NumericArray, or null
*/
function isNumericArray(value) {
	return isTypedArray(value) || isNumberArray(value);
}

//#endregion
//#region node_modules/@luma.gl/engine/dist/model/split-uniforms-and-bindings.js
function isUniformValue(value) {
	return isNumericArray(value) || typeof value === "number" || typeof value === "boolean";
}
function splitUniformsAndBindings(uniforms) {
	const result = {
		bindings: {},
		uniforms: {}
	};
	Object.keys(uniforms).forEach((name) => {
		const uniform = uniforms[name];
		if (isUniformValue(uniform)) result.uniforms[name] = uniform;
		else result.bindings[name] = uniform;
	});
	return result;
}

//#endregion
//#region node_modules/@luma.gl/engine/dist/shader-inputs.js
/**
* ShaderInputs holds uniform and binding values for one or more shader modules,
* - It can generate binary data for any uniform buffer
* - It can manage a uniform buffer for each block
* - It can update managed uniform buffers with a single call
* - It performs some book keeping on what has changed to minimize unnecessary writes to uniform buffers.
*/
var ShaderInputs = class {
	options = { disableWarnings: false };
	/**
	* The map of modules
	* @todo should should this include the resolved dependencies?
	*/
	modules;
	/** Stores the uniform values for each module */
	moduleUniforms;
	/** Stores the uniform bindings for each module  */
	moduleBindings;
	/** Tracks if uniforms have changed */
	/**
	* Create a new UniformStore instance
	* @param modules
	*/
	constructor(modules, options) {
		Object.assign(this.options, options);
		const resolvedModules = getShaderModuleDependencies(Object.values(modules).filter((module$1) => module$1.dependencies));
		for (const resolvedModule of resolvedModules) modules[resolvedModule.name] = resolvedModule;
		log.log(1, "Creating ShaderInputs with modules", Object.keys(modules))();
		this.modules = modules;
		this.moduleUniforms = {};
		this.moduleBindings = {};
		for (const [name, module$1] of Object.entries(modules)) {
			this._addModule(module$1);
			if (module$1.name && name !== module$1.name && !this.options.disableWarnings) log.warn(`Module name: ${name} vs ${module$1.name}`)();
		}
	}
	/** Destroy */
	destroy() {}
	/**
	* Set module props
	*/
	setProps(props) {
		for (const name of Object.keys(props)) {
			const moduleName = name;
			const moduleProps = props[moduleName] || {};
			const module$1 = this.modules[moduleName];
			if (!module$1) {
				if (!this.options.disableWarnings) log.warn(`Module ${name} not found`)();
				continue;
			}
			const oldUniforms = this.moduleUniforms[moduleName];
			const oldBindings = this.moduleBindings[moduleName];
			const { uniforms, bindings } = splitUniformsAndBindings(module$1.getUniforms?.(moduleProps, oldUniforms) || moduleProps);
			this.moduleUniforms[moduleName] = {
				...oldUniforms,
				...uniforms
			};
			this.moduleBindings[moduleName] = {
				...oldBindings,
				...bindings
			};
		}
	}
	/**
	* Return the map of modules
	* @todo should should this include the resolved dependencies?
	*/
	getModules() {
		return Object.values(this.modules);
	}
	/** Get all uniform values for all modules */
	getUniformValues() {
		return this.moduleUniforms;
	}
	/** Merges all bindings for the shader (from the various modules) */
	getBindingValues() {
		const bindings = {};
		for (const moduleBindings of Object.values(this.moduleBindings)) Object.assign(bindings, moduleBindings);
		return bindings;
	}
	/** Return a debug table that can be used for console.table() or log.table() */
	getDebugTable() {
		const table = {};
		for (const [moduleName, module$1] of Object.entries(this.moduleUniforms)) for (const [key, value] of Object.entries(module$1)) table[`${moduleName}.${key}`] = {
			type: this.modules[moduleName].uniformTypes?.[key],
			value: String(value)
		};
		return table;
	}
	_addModule(module$1) {
		const moduleName = module$1.name;
		this.moduleUniforms[moduleName] = module$1.defaultUniforms || {};
		this.moduleBindings[moduleName] = {};
	}
};

//#endregion
//#region node_modules/@luma.gl/engine/dist/application-utils/load-file.js
var pathPrefix = "";
/**
* Loads ImageBitmap asynchronously. Respects setPathPrefix.
* image.crossOrigin can be set via opts.crossOrigin, default to 'anonymous'
* @returns a promise tracking the load
*/
async function loadImageBitmap(url, opts) {
	const image = new Image();
	image.crossOrigin = opts?.crossOrigin || "anonymous";
	image.src = url.startsWith("http") ? url : pathPrefix + url;
	await image.decode();
	return opts ? await createImageBitmap(image, opts) : await createImageBitmap(image);
}

//#endregion
//#region node_modules/@luma.gl/engine/dist/async-texture/async-texture.js
const TextureCubeFaces = [
	"+X",
	"-X",
	"+Y",
	"-Y",
	"+Z",
	"-Z"
];
const CubeFaces = [
	"+X",
	"-X",
	"+Y",
	"-Y",
	"+Z",
	"-Z"
];
/**
* It is very convenient to be able to initialize textures with promises
* This can add considerable complexity to the Texture class, and doesn't
* fit with the immutable nature of WebGPU resources.
* Instead, luma.gl offers async textures as a separate class.
*/
var AsyncTexture = class AsyncTexture {
	device;
	id;
	props;
	texture;
	sampler;
	view;
	ready;
	isReady = false;
	destroyed = false;
	resolveReady = () => {};
	rejectReady = () => {};
	get [Symbol.toStringTag]() {
		return "AsyncTexture";
	}
	toString() {
		return `AsyncTexture:"${this.id}"(${this.isReady ? "ready" : "loading"})`;
	}
	constructor(device, props) {
		this.device = device;
		const id = uid("async-texture");
		this.props = {
			...AsyncTexture.defaultProps,
			id,
			...props
		};
		this.id = this.props.id;
		props = { ...props };
		if (typeof props?.data === "string" && props.dimension === "2d") props.data = loadImageBitmap(props.data);
		if (props.mipmaps) props.mipLevels = "auto";
		this.ready = new Promise((resolve, reject) => {
			this.resolveReady = () => {
				this.isReady = true;
				resolve();
			};
			this.rejectReady = reject;
		});
		this.initAsync(props);
	}
	async initAsync(props) {
		const asyncData = props.data;
		const data = await awaitAllPromises(asyncData).then(void 0, this.rejectReady);
		if (this.destroyed) return;
		const size = this.props.width && this.props.height ? {
			width: this.props.width,
			height: this.props.height
		} : this.getTextureDataSize(data);
		if (!size) throw new Error("Texture size could not be determined");
		const syncProps = {
			...size,
			...props,
			data: void 0,
			mipLevels: 1
		};
		const maxMips = this.device.getMipLevelCount(syncProps.width, syncProps.height);
		syncProps.mipLevels = this.props.mipLevels === "auto" ? maxMips : Math.min(maxMips, this.props.mipLevels);
		this.texture = this.device.createTexture(syncProps);
		this.sampler = this.texture.sampler;
		this.view = this.texture.view;
		if (props.data) switch (this.props.dimension) {
			case "1d":
				this._setTexture1DData(this.texture, data);
				break;
			case "2d":
				this._setTexture2DData(data);
				break;
			case "3d":
				this._setTexture3DData(this.texture, data);
				break;
			case "2d-array":
				this._setTextureArrayData(this.texture, data);
				break;
			case "cube":
				this._setTextureCubeData(this.texture, data);
				break;
			case "cube-array":
				this._setTextureCubeArrayData(this.texture, data);
				break;
		}
		if (this.props.mipmaps) this.generateMipmaps();
		log.info(1, `${this} loaded`);
		this.resolveReady();
	}
	destroy() {
		if (this.texture) {
			this.texture.destroy();
			this.texture = null;
		}
		this.destroyed = true;
	}
	generateMipmaps() {
		this.texture.generateMipmapsWebGL();
	}
	/** Set sampler or create and set new Sampler from SamplerProps */
	setSampler(sampler = {}) {
		this.texture.setSampler(sampler instanceof Sampler ? sampler : this.device.createSampler(sampler));
	}
	/**
	* Textures are immutable and cannot be resized after creation,
	* but we can create a similar texture with the same parameters but a new size.
	* @note Does not copy contents of the texture
	* @note Mipmaps may need to be regenerated after resizing / setting new data
	* @todo Abort pending promise and create a texture with the new size?
	*/
	resize(size) {
		if (!this.isReady) throw new Error("Cannot resize texture before it is ready");
		if (size.width === this.texture.width && size.height === this.texture.height) return false;
		if (this.texture) {
			const texture = this.texture;
			this.texture = texture.clone(size);
			texture.destroy();
		}
		return true;
	}
	/** Check if texture data is a typed array */
	isTextureLevelData(data) {
		const typedArray = data?.data;
		return ArrayBuffer.isView(typedArray);
	}
	/** Get the size of the texture described by the provided TextureData */
	getTextureDataSize(data) {
		if (!data) return null;
		if (ArrayBuffer.isView(data)) return null;
		if (Array.isArray(data)) return this.getTextureDataSize(data[0]);
		if (this.device.isExternalImage(data)) return this.device.getExternalImageSize(data);
		if (data && typeof data === "object" && data.constructor === Object) {
			const untypedData = Object.values(data)[0];
			return {
				width: untypedData.width,
				height: untypedData.height
			};
		}
		throw new Error("texture size deduction failed");
	}
	/** Convert luma.gl cubemap face constants to depth index */
	getCubeFaceDepth(face) {
		switch (face) {
			case "+X": return 0;
			case "-X": return 1;
			case "+Y": return 2;
			case "-Y": return 3;
			case "+Z": return 4;
			case "-Z": return 5;
			default: throw new Error(face);
		}
	}
	setTextureData(data) {}
	/** Experimental: Set multiple mip levels */
	_setTexture1DData(texture, data) {
		throw new Error("setTexture1DData not supported in WebGL.");
	}
	/** Experimental: Set multiple mip levels */
	_setTexture2DData(lodData, depth = 0) {
		if (!this.texture) throw new Error("Texture not initialized");
		const lodArray = this._normalizeTextureData(lodData);
		if (lodArray.length > 1 && this.props.mipmaps !== false) log.warn(`Texture ${this.id} mipmap and multiple LODs.`)();
		for (let mipLevel = 0; mipLevel < lodArray.length; mipLevel++) {
			const imageData = lodArray[mipLevel];
			if (this.device.isExternalImage(imageData)) this.texture.copyExternalImage({
				image: imageData,
				depth,
				mipLevel,
				flipY: true
			});
			else this.texture.copyImageData({
				data: imageData.data,
				mipLevel
			});
		}
	}
	/**
	* Experimental: Sets 3D texture data: multiple depth slices, multiple mip levels
	* @param data
	*/
	_setTexture3DData(texture, data) {
		if (this.texture?.props.dimension !== "3d") throw new Error(this.id);
		for (let depth = 0; depth < data.length; depth++) this._setTexture2DData(data[depth], depth);
	}
	/**
	* Experimental: Set Cube texture data, multiple faces, multiple mip levels
	* @todo - could support TextureCubeArray with depth
	* @param data
	* @param index
	*/
	_setTextureCubeData(texture, data) {
		if (this.texture?.props.dimension !== "cube") throw new Error(this.id);
		for (const [face, faceData] of Object.entries(data)) {
			const faceDepth = CubeFaces.indexOf(face);
			this._setTexture2DData(faceData, faceDepth);
		}
	}
	/**
	* Experimental: Sets texture array data, multiple levels, multiple depth slices
	* @param data
	*/
	_setTextureArrayData(texture, data) {
		if (this.texture?.props.dimension !== "2d-array") throw new Error(this.id);
		for (let depth = 0; depth < data.length; depth++) this._setTexture2DData(data[depth], depth);
	}
	/**
	* Experimental: Sets texture cube array, multiple faces, multiple levels, multiple mip levels
	* @param data
	*/
	_setTextureCubeArrayData(texture, data) {
		throw new Error("setTextureCubeArrayData not supported in WebGL2.");
	}
	/** Experimental */
	_setTextureCubeFaceData(texture, lodData, face, depth = 0) {
		if (Array.isArray(lodData) && lodData.length > 1 && this.props.mipmaps !== false) log.warn(`${this.id} has mipmap and multiple LODs.`)();
		const faceDepth = TextureCubeFaces.indexOf(face);
		this._setTexture2DData(lodData, faceDepth);
	}
	/**
	* Normalize TextureData to an array of TextureImageData / ExternalImages
	* @param data
	* @param options
	* @returns array of TextureImageData / ExternalImages
	*/
	_normalizeTextureData(data) {
		const options = this.texture;
		let mipLevelArray;
		if (ArrayBuffer.isView(data)) mipLevelArray = [{
			data,
			width: options.width,
			height: options.height
		}];
		else if (!Array.isArray(data)) mipLevelArray = [data];
		else mipLevelArray = data;
		return mipLevelArray;
	}
	static defaultProps = {
		...Texture.defaultProps,
		data: null,
		mipmaps: false
	};
};
/** Resolve all promises in a nested data structure */
async function awaitAllPromises(x$1) {
	x$1 = await x$1;
	if (Array.isArray(x$1)) return await Promise.all(x$1.map(awaitAllPromises));
	if (x$1 && typeof x$1 === "object" && x$1.constructor === Object) {
		const object = x$1;
		const values = await Promise.all(Object.values(object));
		const keys = Object.keys(object);
		const resolvedObject = {};
		for (let i$1 = 0; i$1 < keys.length; i$1++) resolvedObject[keys[i$1]] = values[i$1];
		return resolvedObject;
	}
	return x$1;
}

//#endregion
//#region node_modules/@luma.gl/engine/dist/model/model.js
var LOG_DRAW_PRIORITY = 2;
var LOG_DRAW_TIMEOUT = 1e4;
/**
* v9 Model API
* A model
* - automatically reuses pipelines (programs) when possible
* - automatically rebuilds pipelines if necessary to accommodate changed settings
* shadertools integration
* - accepts modules and performs shader transpilation
*/
var Model = class Model {
	static defaultProps = {
		...RenderPipeline.defaultProps,
		source: void 0,
		vs: null,
		fs: null,
		id: "unnamed",
		handle: void 0,
		userData: {},
		defines: {},
		modules: [],
		geometry: null,
		indexBuffer: null,
		attributes: {},
		constantAttributes: {},
		varyings: [],
		isInstanced: void 0,
		instanceCount: 0,
		vertexCount: 0,
		shaderInputs: void 0,
		pipelineFactory: void 0,
		shaderFactory: void 0,
		transformFeedback: void 0,
		shaderAssembler: ShaderAssembler.getDefaultShaderAssembler(),
		debugShaders: void 0,
		disableWarnings: void 0
	};
	device;
	id;
	source;
	vs;
	fs;
	pipelineFactory;
	shaderFactory;
	userData = {};
	/** The render pipeline GPU parameters, depth testing etc */
	parameters;
	/** The primitive topology */
	topology;
	/** Buffer layout */
	bufferLayout;
	/** Use instanced rendering */
	isInstanced = void 0;
	/** instance count. `undefined` means not instanced */
	instanceCount = 0;
	/** Vertex count */
	vertexCount;
	/** Index buffer */
	indexBuffer = null;
	/** Buffer-valued attributes */
	bufferAttributes = {};
	/** Constant-valued attributes */
	constantAttributes = {};
	/** Bindings (textures, samplers, uniform buffers) */
	bindings = {};
	/**
	* VertexArray
	* @note not implemented: if bufferLayout is updated, vertex array has to be rebuilt!
	* @todo - allow application to define multiple vertex arrays?
	* */
	vertexArray;
	/** TransformFeedback, WebGL 2 only. */
	transformFeedback = null;
	/** The underlying GPU "program". @note May be recreated if parameters change */
	pipeline;
	/** ShaderInputs instance */
	shaderInputs;
	_uniformStore;
	_attributeInfos = {};
	_gpuGeometry = null;
	props;
	_pipelineNeedsUpdate = "newly created";
	_needsRedraw = "initializing";
	_destroyed = false;
	/** "Time" of last draw. Monotonically increasing timestamp */
	_lastDrawTimestamp = -1;
	get [Symbol.toStringTag]() {
		return "Model";
	}
	toString() {
		return `Model(${this.id})`;
	}
	constructor(device, props) {
		this.props = {
			...Model.defaultProps,
			...props
		};
		props = this.props;
		this.id = props.id || uid("model");
		this.device = device;
		Object.assign(this.userData, props.userData);
		const moduleMap = Object.fromEntries(this.props.modules?.map((module$1) => [module$1.name, module$1]) || []);
		const shaderInputs = props.shaderInputs || new ShaderInputs(moduleMap, { disableWarnings: this.props.disableWarnings });
		this.setShaderInputs(shaderInputs);
		const platformInfo = getPlatformInfo(device);
		const modules = (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || [];
		if (this.device.type === "webgpu" && this.props.source) {
			const { source, getUniforms: getUniforms$1 } = this.props.shaderAssembler.assembleWGSLShader({
				platformInfo,
				...this.props,
				modules
			});
			this.source = source;
			this._getModuleUniforms = getUniforms$1;
			this.props.shaderLayout ||= getShaderLayoutFromWGSL(this.source);
		} else {
			const { vs: vs$2, fs: fs$1, getUniforms: getUniforms$1 } = this.props.shaderAssembler.assembleGLSLShaderPair({
				platformInfo,
				...this.props,
				modules
			});
			this.vs = vs$2;
			this.fs = fs$1;
			this._getModuleUniforms = getUniforms$1;
		}
		this.vertexCount = this.props.vertexCount;
		this.instanceCount = this.props.instanceCount;
		this.topology = this.props.topology;
		this.bufferLayout = this.props.bufferLayout;
		this.parameters = this.props.parameters;
		if (props.geometry) this.setGeometry(props.geometry);
		this.pipelineFactory = props.pipelineFactory || PipelineFactory.getDefaultPipelineFactory(this.device);
		this.shaderFactory = props.shaderFactory || ShaderFactory.getDefaultShaderFactory(this.device);
		this.pipeline = this._updatePipeline();
		this.vertexArray = device.createVertexArray({
			shaderLayout: this.pipeline.shaderLayout,
			bufferLayout: this.pipeline.bufferLayout
		});
		if (this._gpuGeometry) this._setGeometryAttributes(this._gpuGeometry);
		if ("isInstanced" in props) this.isInstanced = props.isInstanced;
		if (props.instanceCount) this.setInstanceCount(props.instanceCount);
		if (props.vertexCount) this.setVertexCount(props.vertexCount);
		if (props.indexBuffer) this.setIndexBuffer(props.indexBuffer);
		if (props.attributes) this.setAttributes(props.attributes);
		if (props.constantAttributes) this.setConstantAttributes(props.constantAttributes);
		if (props.bindings) this.setBindings(props.bindings);
		if (props.transformFeedback) this.transformFeedback = props.transformFeedback;
		Object.seal(this);
	}
	destroy() {
		if (!this._destroyed) {
			this.pipelineFactory.release(this.pipeline);
			this.shaderFactory.release(this.pipeline.vs);
			if (this.pipeline.fs) this.shaderFactory.release(this.pipeline.fs);
			this._uniformStore.destroy();
			this._gpuGeometry?.destroy();
			this._destroyed = true;
		}
	}
	/** Query redraw status. Clears the status. */
	needsRedraw() {
		if (this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp) this.setNeedsRedraw("contents of bound textures or buffers updated");
		const needsRedraw = this._needsRedraw;
		this._needsRedraw = false;
		return needsRedraw;
	}
	/** Mark the model as needing a redraw */
	setNeedsRedraw(reason) {
		this._needsRedraw ||= reason;
	}
	predraw() {
		this.updateShaderInputs();
		this.pipeline = this._updatePipeline();
	}
	draw(renderPass) {
		const loadingBinding = this._areBindingsLoading();
		if (loadingBinding) {
			log.info(LOG_DRAW_PRIORITY, `>>> DRAWING ABORTED ${this.id}: ${loadingBinding} not loaded`)();
			return false;
		}
		try {
			renderPass.pushDebugGroup(`${this}.predraw(${renderPass})`);
			this.predraw();
		} finally {
			renderPass.popDebugGroup();
		}
		let drawSuccess;
		try {
			renderPass.pushDebugGroup(`${this}.draw(${renderPass})`);
			this._logDrawCallStart();
			this.pipeline = this._updatePipeline();
			const syncBindings = this._getBindings();
			this.pipeline.setBindings(syncBindings, { disableWarnings: this.props.disableWarnings });
			const { indexBuffer } = this.vertexArray;
			const indexCount = indexBuffer ? indexBuffer.byteLength / (indexBuffer.indexType === "uint32" ? 4 : 2) : void 0;
			drawSuccess = this.pipeline.draw({
				renderPass,
				vertexArray: this.vertexArray,
				isInstanced: this.isInstanced,
				vertexCount: this.vertexCount,
				instanceCount: this.instanceCount,
				indexCount,
				transformFeedback: this.transformFeedback || void 0,
				parameters: this.parameters,
				topology: this.topology
			});
		} finally {
			renderPass.popDebugGroup();
			this._logDrawCallEnd();
		}
		this._logFramebuffer(renderPass);
		if (drawSuccess) {
			this._lastDrawTimestamp = this.device.timestamp;
			this._needsRedraw = false;
		} else this._needsRedraw = "waiting for resource initialization";
		return drawSuccess;
	}
	/**
	* Updates the optional geometry
	* Geometry, set topology and bufferLayout
	* @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
	*/
	setGeometry(geometry) {
		this._gpuGeometry?.destroy();
		const gpuGeometry = geometry && makeGPUGeometry(this.device, geometry);
		if (gpuGeometry) {
			this.setTopology(gpuGeometry.topology || "triangle-list");
			this.bufferLayout = new BufferLayoutHelper(this.bufferLayout).mergeBufferLayouts(gpuGeometry.bufferLayout, this.bufferLayout);
			if (this.vertexArray) this._setGeometryAttributes(gpuGeometry);
		}
		this._gpuGeometry = gpuGeometry;
	}
	/**
	* Updates the primitive topology ('triangle-list', 'triangle-strip' etc).
	* @note Triggers a pipeline rebuild / pipeline cache fetch on WebGPU
	*/
	setTopology(topology) {
		if (topology !== this.topology) {
			this.topology = topology;
			this._setPipelineNeedsUpdate("topology");
		}
	}
	/**
	* Updates the buffer layout.
	* @note Triggers a pipeline rebuild / pipeline cache fetch
	*/
	setBufferLayout(bufferLayout) {
		const bufferLayoutHelper = new BufferLayoutHelper(this.bufferLayout);
		this.bufferLayout = this._gpuGeometry ? bufferLayoutHelper.mergeBufferLayouts(bufferLayout, this._gpuGeometry.bufferLayout) : bufferLayout;
		this._setPipelineNeedsUpdate("bufferLayout");
		this.pipeline = this._updatePipeline();
		this.vertexArray = this.device.createVertexArray({
			shaderLayout: this.pipeline.shaderLayout,
			bufferLayout: this.pipeline.bufferLayout
		});
		if (this._gpuGeometry) this._setGeometryAttributes(this._gpuGeometry);
	}
	/**
	* Set GPU parameters.
	* @note Can trigger a pipeline rebuild / pipeline cache fetch.
	* @param parameters
	*/
	setParameters(parameters) {
		if (!deepEqual$1(parameters, this.parameters, 2)) {
			this.parameters = parameters;
			this._setPipelineNeedsUpdate("parameters");
		}
	}
	/**
	* Updates the instance count (used in draw calls)
	* @note Any attributes with stepMode=instance need to be at least this big
	*/
	setInstanceCount(instanceCount) {
		this.instanceCount = instanceCount;
		if (this.isInstanced === void 0 && instanceCount > 0) this.isInstanced = true;
		this.setNeedsRedraw("instanceCount");
	}
	/**
	* Updates the vertex count (used in draw calls)
	* @note Any attributes with stepMode=vertex need to be at least this big
	*/
	setVertexCount(vertexCount) {
		this.vertexCount = vertexCount;
		this.setNeedsRedraw("vertexCount");
	}
	/** Set the shader inputs */
	setShaderInputs(shaderInputs) {
		this.shaderInputs = shaderInputs;
		this._uniformStore = new UniformStore(this.shaderInputs.modules);
		for (const [moduleName, module$1] of Object.entries(this.shaderInputs.modules)) if (shaderModuleHasUniforms(module$1)) {
			const uniformBuffer = this._uniformStore.getManagedUniformBuffer(this.device, moduleName);
			this.bindings[`${moduleName}Uniforms`] = uniformBuffer;
		}
		this.setNeedsRedraw("shaderInputs");
	}
	/** Update uniform buffers from the model's shader inputs */
	updateShaderInputs() {
		this._uniformStore.setUniforms(this.shaderInputs.getUniformValues());
		this.setBindings(this.shaderInputs.getBindingValues());
		this.setNeedsRedraw("shaderInputs");
	}
	/**
	* Sets bindings (textures, samplers, uniform buffers)
	*/
	setBindings(bindings) {
		Object.assign(this.bindings, bindings);
		this.setNeedsRedraw("bindings");
	}
	/**
	* Updates optional transform feedback. WebGL only.
	*/
	setTransformFeedback(transformFeedback) {
		this.transformFeedback = transformFeedback;
		this.setNeedsRedraw("transformFeedback");
	}
	/**
	* Sets the index buffer
	* @todo - how to unset it if we change geometry?
	*/
	setIndexBuffer(indexBuffer) {
		this.vertexArray.setIndexBuffer(indexBuffer);
		this.setNeedsRedraw("indexBuffer");
	}
	/**
	* Sets attributes (buffers)
	* @note Overrides any attributes previously set with the same name
	*/
	setAttributes(buffers, options) {
		const disableWarnings = options?.disableWarnings ?? this.props.disableWarnings;
		if (buffers["indices"]) log.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)();
		this.bufferLayout = sortedBufferLayoutByShaderSourceLocations(this.pipeline.shaderLayout, this.bufferLayout);
		const bufferLayoutHelper = new BufferLayoutHelper(this.bufferLayout);
		for (const [bufferName, buffer] of Object.entries(buffers)) {
			const bufferLayout = bufferLayoutHelper.getBufferLayout(bufferName);
			if (!bufferLayout) {
				if (!disableWarnings) log.warn(`Model(${this.id}): Missing layout for buffer "${bufferName}".`)();
				continue;
			}
			const attributeNames = bufferLayoutHelper.getAttributeNamesForBuffer(bufferLayout);
			let set = false;
			for (const attributeName of attributeNames) {
				const attributeInfo = this._attributeInfos[attributeName];
				if (attributeInfo) {
					const location = this.device.type === "webgpu" ? bufferLayoutHelper.getBufferIndex(attributeInfo.bufferName) : attributeInfo.location;
					this.vertexArray.setBuffer(location, buffer);
					set = true;
				}
			}
			if (!set && !disableWarnings) log.warn(`Model(${this.id}): Ignoring buffer "${buffer.id}" for unknown attribute "${bufferName}"`)();
		}
		this.setNeedsRedraw("attributes");
	}
	/**
	* Sets constant attributes
	* @note Overrides any attributes previously set with the same name
	* Constant attributes are only supported in WebGL, not in WebGPU
	* Any attribute that is disabled in the current vertex array object
	* is read from the context's global constant value for that attribute location.
	* @param constantAttributes
	*/
	setConstantAttributes(attributes, options) {
		for (const [attributeName, value] of Object.entries(attributes)) {
			const attributeInfo = this._attributeInfos[attributeName];
			if (attributeInfo) this.vertexArray.setConstantWebGL(attributeInfo.location, value);
			else if (!(options?.disableWarnings ?? this.props.disableWarnings)) log.warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${attributeName}"`)();
		}
		this.setNeedsRedraw("constants");
	}
	/** Check that bindings are loaded. Returns id of first binding that is still loading. */
	_areBindingsLoading() {
		for (const binding of Object.values(this.bindings)) if (binding instanceof AsyncTexture && !binding.isReady) return binding.id;
		return false;
	}
	/** Extracts texture view from loaded async textures. Returns null if any textures have not yet been loaded. */
	_getBindings() {
		const validBindings = {};
		for (const [name, binding] of Object.entries(this.bindings)) if (binding instanceof AsyncTexture) {
			if (binding.isReady) validBindings[name] = binding.texture;
		} else validBindings[name] = binding;
		return validBindings;
	}
	/** Get the timestamp of the latest updated bound GPU memory resource (buffer/texture). */
	_getBindingsUpdateTimestamp() {
		let timestamp = 0;
		for (const binding of Object.values(this.bindings)) if (binding instanceof TextureView) timestamp = Math.max(timestamp, binding.texture.updateTimestamp);
		else if (binding instanceof Buffer || binding instanceof Texture) timestamp = Math.max(timestamp, binding.updateTimestamp);
		else if (binding instanceof AsyncTexture) timestamp = binding.texture ? Math.max(timestamp, binding.texture.updateTimestamp) : Infinity;
		else if (!(binding instanceof Sampler)) timestamp = Math.max(timestamp, binding.buffer.updateTimestamp);
		return timestamp;
	}
	/**
	* Updates the optional geometry attributes
	* Geometry, sets several attributes, indexBuffer, and also vertex count
	* @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
	*/
	_setGeometryAttributes(gpuGeometry) {
		const attributes = { ...gpuGeometry.attributes };
		for (const [attributeName] of Object.entries(attributes)) if (!this.pipeline.shaderLayout.attributes.find((layout) => layout.name === attributeName) && attributeName !== "positions") delete attributes[attributeName];
		this.vertexCount = gpuGeometry.vertexCount;
		this.setIndexBuffer(gpuGeometry.indices || null);
		this.setAttributes(gpuGeometry.attributes, { disableWarnings: true });
		this.setAttributes(attributes, { disableWarnings: this.props.disableWarnings });
		this.setNeedsRedraw("geometry attributes");
	}
	/** Mark pipeline as needing update */
	_setPipelineNeedsUpdate(reason) {
		this._pipelineNeedsUpdate ||= reason;
		this.setNeedsRedraw(reason);
	}
	/** Update pipeline if needed */
	_updatePipeline() {
		if (this._pipelineNeedsUpdate) {
			let prevShaderVs = null;
			let prevShaderFs = null;
			if (this.pipeline) {
				log.log(1, `Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)();
				prevShaderVs = this.pipeline.vs;
				prevShaderFs = this.pipeline.fs;
			}
			this._pipelineNeedsUpdate = false;
			const vs$2 = this.shaderFactory.createShader({
				id: `${this.id}-vertex`,
				stage: "vertex",
				source: this.source || this.vs,
				debugShaders: this.props.debugShaders
			});
			let fs$1 = null;
			if (this.source) fs$1 = vs$2;
			else if (this.fs) fs$1 = this.shaderFactory.createShader({
				id: `${this.id}-fragment`,
				stage: "fragment",
				source: this.source || this.fs,
				debugShaders: this.props.debugShaders
			});
			this.pipeline = this.pipelineFactory.createRenderPipeline({
				...this.props,
				bufferLayout: this.bufferLayout,
				topology: this.topology,
				parameters: this.parameters,
				bindings: this._getBindings(),
				vs: vs$2,
				fs: fs$1
			});
			this._attributeInfos = getAttributeInfosFromLayouts(this.pipeline.shaderLayout, this.bufferLayout);
			if (prevShaderVs) this.shaderFactory.release(prevShaderVs);
			if (prevShaderFs) this.shaderFactory.release(prevShaderFs);
		}
		return this.pipeline;
	}
	/** Throttle draw call logging */
	_lastLogTime = 0;
	_logOpen = false;
	_logDrawCallStart() {
		const logDrawTimeout = log.level > 3 ? 0 : LOG_DRAW_TIMEOUT;
		if (log.level < 2 || Date.now() - this._lastLogTime < logDrawTimeout) return;
		this._lastLogTime = Date.now();
		this._logOpen = true;
		log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, { collapsed: log.level <= 2 })();
	}
	_logDrawCallEnd() {
		if (this._logOpen) {
			const shaderLayoutTable = getDebugTableForShaderLayout(this.pipeline.shaderLayout, this.id);
			log.table(LOG_DRAW_PRIORITY, shaderLayoutTable)();
			const uniformTable = this.shaderInputs.getDebugTable();
			log.table(LOG_DRAW_PRIORITY, uniformTable)();
			const attributeTable = this._getAttributeDebugTable();
			log.table(LOG_DRAW_PRIORITY, this._attributeInfos)();
			log.table(LOG_DRAW_PRIORITY, attributeTable)();
			log.groupEnd(LOG_DRAW_PRIORITY)();
			this._logOpen = false;
		}
	}
	_drawCount = 0;
	_logFramebuffer(renderPass) {
		const debugFramebuffers = this.device.props.debugFramebuffers;
		this._drawCount++;
		if (!debugFramebuffers) return;
		const framebuffer = renderPass.props.framebuffer;
		if (framebuffer) debugFramebuffer(framebuffer, {
			id: framebuffer.id,
			minimap: true
		});
	}
	_getAttributeDebugTable() {
		const table = {};
		for (const [name, attributeInfo] of Object.entries(this._attributeInfos)) {
			const values = this.vertexArray.attributes[attributeInfo.location];
			table[attributeInfo.location] = {
				name,
				type: attributeInfo.shaderType,
				values: values ? this._getBufferOrConstantValues(values, attributeInfo.bufferDataType) : "null"
			};
		}
		if (this.vertexArray.indexBuffer) {
			const { indexBuffer } = this.vertexArray;
			const values = indexBuffer.indexType === "uint32" ? new Uint32Array(indexBuffer.debugData) : new Uint16Array(indexBuffer.debugData);
			table["indices"] = {
				name: "indices",
				type: indexBuffer.indexType,
				values: values.toString()
			};
		}
		return table;
	}
	_getBufferOrConstantValues(attribute, dataType) {
		const TypedArrayConstructor = getTypedArrayConstructor(dataType);
		return (attribute instanceof Buffer ? new TypedArrayConstructor(attribute.debugData) : attribute).toString();
	}
};
function shaderModuleHasUniforms(module$1) {
	return Boolean(module$1.uniformTypes && !isObjectEmpty(module$1.uniformTypes));
}
/** Create a shadertools platform info from the Device */
function getPlatformInfo(device) {
	return {
		type: device.type,
		shaderLanguage: device.info.shadingLanguage,
		shaderLanguageVersion: device.info.shadingLanguageVersion,
		gpu: device.info.gpu,
		features: device.features
	};
}
/** Returns true if given object is empty, false otherwise. */
function isObjectEmpty(obj) {
	for (const key in obj) return false;
	return true;
}

//#endregion
//#region node_modules/@luma.gl/engine/dist/compute/buffer-transform.js
/**
* Manages a WebGL program (pipeline) for bufferbuffer transforms.
* @note Only works under WebGL2.
*/
var BufferTransform = class BufferTransform {
	device;
	model;
	transformFeedback;
	static defaultProps = {
		...Model.defaultProps,
		outputs: void 0,
		feedbackBuffers: void 0
	};
	static isSupported(device) {
		return device?.info?.type === "webgl";
	}
	constructor(device, props = BufferTransform.defaultProps) {
		if (!BufferTransform.isSupported(device)) throw new Error("BufferTransform not yet implemented on WebGPU");
		this.device = device;
		this.model = new Model(this.device, {
			id: props.id || "buffer-transform-model",
			fs: props.fs || getPassthroughFS(),
			topology: props.topology || "point-list",
			varyings: props.outputs || props.varyings,
			...props
		});
		this.transformFeedback = this.device.createTransformFeedback({
			layout: this.model.pipeline.shaderLayout,
			buffers: props.feedbackBuffers
		});
		this.model.setTransformFeedback(this.transformFeedback);
		Object.seal(this);
	}
	/** Destroy owned resources. */
	destroy() {
		if (this.model) this.model.destroy();
	}
	/** @deprecated Use {@link destroy}. */
	delete() {
		this.destroy();
	}
	/** Run one transform loop. */
	run(options) {
		if (options?.inputBuffers) this.model.setAttributes(options.inputBuffers);
		if (options?.outputBuffers) this.transformFeedback.setBuffers(options.outputBuffers);
		const renderPass = this.device.beginRenderPass(options);
		this.model.draw(renderPass);
		renderPass.end();
	}
	/** @deprecated App knows what buffers it is passing in - Returns the {@link Buffer} or {@link BufferRange} for given varying name. */
	getBuffer(varyingName) {
		return this.transformFeedback.getBuffer(varyingName);
	}
	/** @deprecated App knows what buffers it is passing in - Reads the {@link Buffer} or {@link BufferRange} for given varying name. */
	readAsync(varyingName) {
		const result = this.getBuffer(varyingName);
		if (!result) throw new Error("BufferTransform#getBuffer");
		if (result instanceof Buffer) return result.readAsync();
		const { buffer, byteOffset = 0, byteLength = buffer.byteLength } = result;
		return buffer.readAsync(byteOffset, byteLength);
	}
};

//#endregion
//#region node_modules/@luma.gl/engine/dist/geometry/geometry.js
var Geometry = class {
	id;
	/** Determines how vertices are read from the 'vertex' attributes */
	topology;
	vertexCount;
	indices;
	attributes;
	userData = {};
	constructor(props) {
		const { attributes = {}, indices = null, vertexCount = null } = props;
		this.id = props.id || uid("geometry");
		this.topology = props.topology;
		if (indices) this.indices = ArrayBuffer.isView(indices) ? {
			value: indices,
			size: 1
		} : indices;
		this.attributes = {};
		for (const [attributeName, attributeValue] of Object.entries(attributes)) {
			const attribute = ArrayBuffer.isView(attributeValue) ? { value: attributeValue } : attributeValue;
			if (!ArrayBuffer.isView(attribute.value)) throw new Error(`${this._print(attributeName)}: must be typed array or object with value as typed array`);
			if ((attributeName === "POSITION" || attributeName === "positions") && !attribute.size) attribute.size = 3;
			if (attributeName === "indices") {
				if (this.indices) throw new Error("Multiple indices detected");
				this.indices = attribute;
			} else this.attributes[attributeName] = attribute;
		}
		if (this.indices && this.indices["isIndexed"] !== void 0) {
			this.indices = Object.assign({}, this.indices);
			delete this.indices["isIndexed"];
		}
		this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);
	}
	getVertexCount() {
		return this.vertexCount;
	}
	/**
	* Return an object with all attributes plus indices added as a field.
	* TODO Geometry types are a mess
	*/
	getAttributes() {
		return this.indices ? {
			indices: this.indices,
			...this.attributes
		} : this.attributes;
	}
	_print(attributeName) {
		return `Geometry ${this.id} attribute ${attributeName}`;
	}
	/**
	* GeometryAttribute
	* value: typed array
	* type: indices, vertices, uvs
	* size: elements per vertex
	* target: WebGL buffer type (string or constant)
	*
	* @param attributes
	* @param indices
	* @returns
	*/
	_setAttributes(attributes, indices) {
		return this;
	}
	_calculateVertexCount(attributes, indices) {
		if (indices) return indices.value.length;
		let vertexCount = Infinity;
		for (const attribute of Object.values(attributes)) {
			const { value, size, constant } = attribute;
			if (!constant && value && size !== void 0 && size >= 1) vertexCount = Math.min(vertexCount, value.length / size);
		}
		return vertexCount;
	}
};

//#endregion
//#region node_modules/@luma.gl/engine/dist/geometries/cube-geometry.js
var CubeGeometry = class extends Geometry {
	constructor(props = {}) {
		const { id = uid("cube-geometry"), indices = true } = props;
		super(indices ? {
			...props,
			id,
			topology: "triangle-list",
			indices: {
				size: 1,
				value: CUBE_INDICES
			},
			attributes: {
				...ATTRIBUTES,
				...props.attributes
			}
		} : {
			...props,
			id,
			topology: "triangle-list",
			indices: void 0,
			attributes: {
				...NON_INDEXED_ATTRIBUTES,
				...props.attributes
			}
		});
	}
};
var CUBE_INDICES = new Uint16Array([
	0,
	1,
	2,
	0,
	2,
	3,
	4,
	5,
	6,
	4,
	6,
	7,
	8,
	9,
	10,
	8,
	10,
	11,
	12,
	13,
	14,
	12,
	14,
	15,
	16,
	17,
	18,
	16,
	18,
	19,
	20,
	21,
	22,
	20,
	22,
	23
]);
var CUBE_POSITIONS = new Float32Array([
	-1,
	-1,
	1,
	1,
	-1,
	1,
	1,
	1,
	1,
	-1,
	1,
	1,
	-1,
	-1,
	-1,
	-1,
	1,
	-1,
	1,
	1,
	-1,
	1,
	-1,
	-1,
	-1,
	1,
	-1,
	-1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	-1,
	-1,
	-1,
	-1,
	1,
	-1,
	-1,
	1,
	-1,
	1,
	-1,
	-1,
	1,
	1,
	-1,
	-1,
	1,
	1,
	-1,
	1,
	1,
	1,
	1,
	-1,
	1,
	-1,
	-1,
	-1,
	-1,
	-1,
	1,
	-1,
	1,
	1,
	-1,
	1,
	-1
]);
var CUBE_NORMALS = new Float32Array([
	0,
	0,
	1,
	0,
	0,
	1,
	0,
	0,
	1,
	0,
	0,
	1,
	0,
	0,
	-1,
	0,
	0,
	-1,
	0,
	0,
	-1,
	0,
	0,
	-1,
	0,
	1,
	0,
	0,
	1,
	0,
	0,
	1,
	0,
	0,
	1,
	0,
	0,
	-1,
	0,
	0,
	-1,
	0,
	0,
	-1,
	0,
	0,
	-1,
	0,
	1,
	0,
	0,
	1,
	0,
	0,
	1,
	0,
	0,
	1,
	0,
	0,
	-1,
	0,
	0,
	-1,
	0,
	0,
	-1,
	0,
	0,
	-1,
	0,
	0
]);
var CUBE_TEX_COORDS = new Float32Array([
	0,
	0,
	1,
	0,
	1,
	1,
	0,
	1,
	1,
	0,
	1,
	1,
	0,
	1,
	0,
	0,
	0,
	1,
	0,
	0,
	1,
	0,
	1,
	1,
	1,
	1,
	0,
	1,
	0,
	0,
	1,
	0,
	1,
	0,
	1,
	1,
	0,
	1,
	0,
	0,
	0,
	0,
	1,
	0,
	1,
	1,
	0,
	1
]);
const CUBE_NON_INDEXED_POSITIONS = new Float32Array([
	1,
	-1,
	1,
	-1,
	-1,
	1,
	-1,
	-1,
	-1,
	1,
	-1,
	-1,
	1,
	-1,
	1,
	-1,
	-1,
	-1,
	1,
	1,
	1,
	1,
	-1,
	1,
	1,
	-1,
	-1,
	1,
	1,
	-1,
	1,
	1,
	1,
	1,
	-1,
	-1,
	-1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	-1,
	-1,
	1,
	-1,
	-1,
	1,
	1,
	1,
	1,
	-1,
	-1,
	-1,
	1,
	-1,
	1,
	1,
	-1,
	1,
	-1,
	-1,
	-1,
	-1,
	-1,
	-1,
	1,
	-1,
	1,
	-1,
	1,
	1,
	1,
	-1,
	1,
	1,
	-1,
	-1,
	1,
	-1,
	-1,
	1,
	1,
	-1,
	1,
	1,
	1,
	1,
	1,
	-1,
	-1,
	-1,
	-1,
	-1,
	-1,
	1,
	-1,
	1,
	1,
	-1,
	1,
	-1,
	-1,
	-1,
	1,
	-1
]);
const CUBE_NON_INDEXED_TEX_COORDS = new Float32Array([
	1,
	1,
	0,
	1,
	0,
	0,
	1,
	0,
	1,
	1,
	0,
	0,
	1,
	1,
	0,
	1,
	0,
	0,
	1,
	0,
	1,
	1,
	0,
	0,
	1,
	1,
	0,
	1,
	0,
	0,
	1,
	0,
	1,
	1,
	0,
	0,
	1,
	1,
	0,
	1,
	0,
	0,
	1,
	0,
	1,
	1,
	0,
	0,
	1,
	1,
	0,
	1,
	0,
	0,
	0,
	0,
	1,
	0,
	1,
	1,
	1,
	1,
	0,
	1,
	0,
	0,
	1,
	0,
	1,
	1,
	0,
	0
]);
const CUBE_NON_INDEXED_COLORS = new Float32Array([
	1,
	0,
	1,
	1,
	0,
	0,
	1,
	1,
	0,
	0,
	0,
	1,
	1,
	0,
	0,
	1,
	1,
	0,
	1,
	1,
	0,
	0,
	0,
	1,
	1,
	1,
	1,
	1,
	1,
	0,
	1,
	1,
	1,
	0,
	0,
	1,
	1,
	1,
	0,
	1,
	1,
	1,
	1,
	1,
	1,
	0,
	0,
	1,
	0,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	0,
	1,
	0,
	1,
	0,
	1,
	0,
	1,
	1,
	1,
	1,
	1,
	0,
	1,
	0,
	0,
	1,
	1,
	0,
	1,
	1,
	1,
	0,
	1,
	0,
	1,
	0,
	0,
	0,
	1,
	0,
	0,
	1,
	1,
	0,
	1,
	0,
	1,
	1,
	1,
	1,
	1,
	0,
	1,
	1,
	1,
	0,
	0,
	1,
	1,
	0,
	0,
	1,
	1,
	1,
	0,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	0,
	0,
	1,
	0,
	0,
	0,
	1,
	0,
	1,
	0,
	1,
	1,
	1,
	0,
	1,
	1,
	0,
	0,
	1,
	0,
	1,
	0,
	1
]);
var ATTRIBUTES = {
	POSITION: {
		size: 3,
		value: CUBE_POSITIONS
	},
	NORMAL: {
		size: 3,
		value: CUBE_NORMALS
	},
	TEXCOORD_0: {
		size: 2,
		value: CUBE_TEX_COORDS
	}
};
var NON_INDEXED_ATTRIBUTES = {
	POSITION: {
		size: 3,
		value: CUBE_NON_INDEXED_POSITIONS
	},
	TEXCOORD_0: {
		size: 2,
		value: CUBE_NON_INDEXED_TEX_COORDS
	},
	COLOR_0: {
		size: 3,
		value: CUBE_NON_INDEXED_COLORS
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/attribute/gl-utils.js
function typedArrayFromDataType(type) {
	switch (type) {
		case "float64": return Float64Array;
		case "uint8":
		case "unorm8": return Uint8ClampedArray;
		default: return getTypedArrayConstructor(type);
	}
}
const dataTypeFromTypedArray = getDataType;
function getBufferAttributeLayout(name, accessor, deviceType) {
	const type = deviceType === "webgpu" && accessor.type === "uint8" ? "unorm8" : accessor.type;
	return {
		attribute: name,
		format: accessor.size > 1 ? `${type}x${accessor.size}` : accessor.type,
		byteOffset: accessor.offset || 0
	};
}
function getStride(accessor) {
	return accessor.stride || accessor.size * accessor.bytesPerElement;
}
function bufferLayoutEqual(accessor1, accessor2) {
	return accessor1.type === accessor2.type && accessor1.size === accessor2.size && getStride(accessor1) === getStride(accessor2) && (accessor1.offset || 0) === (accessor2.offset || 0);
}

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/attribute/data-column.js
function resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {
	if (shaderAttributeOptions.offset) log_default.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
	const stride = getStride(baseAccessor);
	const vertexOffset = shaderAttributeOptions.vertexOffset !== void 0 ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;
	const elementOffset = shaderAttributeOptions.elementOffset || 0;
	const offset = vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + (baseAccessor.offset || 0);
	return {
		...shaderAttributeOptions,
		offset,
		stride
	};
}
function resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {
	const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);
	return {
		high: resolvedOptions,
		low: {
			...resolvedOptions,
			offset: resolvedOptions.offset + baseAccessor.size * 4
		}
	};
}
var DataColumn = class {
	constructor(device, opts, state) {
		this._buffer = null;
		this.device = device;
		this.id = opts.id || "";
		this.size = opts.size || 1;
		const logicalType = opts.logicalType || opts.type;
		const doublePrecision = logicalType === "float64";
		let { defaultValue } = opts;
		defaultValue = Number.isFinite(defaultValue) ? [defaultValue] : defaultValue || new Array(this.size).fill(0);
		let bufferType;
		if (doublePrecision) bufferType = "float32";
		else if (!logicalType && opts.isIndexed) bufferType = "uint32";
		else bufferType = logicalType || "float32";
		let defaultType = typedArrayFromDataType(logicalType || bufferType);
		this.doublePrecision = doublePrecision;
		if (doublePrecision && opts.fp64 === false) defaultType = Float32Array;
		this.value = null;
		this.settings = {
			...opts,
			defaultType,
			defaultValue,
			logicalType,
			type: bufferType,
			normalized: bufferType.includes("norm"),
			size: this.size,
			bytesPerElement: defaultType.BYTES_PER_ELEMENT
		};
		this.state = {
			...state,
			externalBuffer: null,
			bufferAccessor: this.settings,
			allocatedValue: null,
			numInstances: 0,
			bounds: null,
			constant: false
		};
	}
	get isConstant() {
		return this.state.constant;
	}
	get buffer() {
		return this._buffer;
	}
	get byteOffset() {
		const accessor = this.getAccessor();
		if (accessor.vertexOffset) return accessor.vertexOffset * getStride(accessor);
		return 0;
	}
	get numInstances() {
		return this.state.numInstances;
	}
	set numInstances(n$1) {
		this.state.numInstances = n$1;
	}
	delete() {
		if (this._buffer) {
			this._buffer.delete();
			this._buffer = null;
		}
		typed_array_manager_default.release(this.state.allocatedValue);
	}
	getBuffer() {
		if (this.state.constant) return null;
		return this.state.externalBuffer || this._buffer;
	}
	getValue(attributeName = this.id, options = null) {
		const result = {};
		if (this.state.constant) {
			const value = this.value;
			if (options) {
				const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);
				const offset = shaderAttributeDef.offset / value.BYTES_PER_ELEMENT;
				const size = shaderAttributeDef.size || this.size;
				result[attributeName] = value.subarray(offset, offset + size);
			} else result[attributeName] = value;
		} else result[attributeName] = this.getBuffer();
		if (this.doublePrecision) if (this.value instanceof Float64Array) result[`${attributeName}64Low`] = result[attributeName];
		else result[`${attributeName}64Low`] = new Float32Array(this.size);
		return result;
	}
	_getBufferLayout(attributeName = this.id, options = null) {
		const accessor = this.getAccessor();
		const attributes = [];
		const result = {
			name: this.id,
			byteStride: getStride(accessor),
			attributes
		};
		if (this.doublePrecision) {
			const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(accessor, options || {});
			attributes.push(getBufferAttributeLayout(attributeName, {
				...accessor,
				...doubleShaderAttributeDefs.high
			}, this.device.type), getBufferAttributeLayout(`${attributeName}64Low`, {
				...accessor,
				...doubleShaderAttributeDefs.low
			}, this.device.type));
		} else if (options) {
			const shaderAttributeDef = resolveShaderAttribute(accessor, options);
			attributes.push(getBufferAttributeLayout(attributeName, {
				...accessor,
				...shaderAttributeDef
			}, this.device.type));
		} else attributes.push(getBufferAttributeLayout(attributeName, accessor, this.device.type));
		return result;
	}
	setAccessor(accessor) {
		this.state.bufferAccessor = accessor;
	}
	getAccessor() {
		return this.state.bufferAccessor;
	}
	getBounds() {
		if (this.state.bounds) return this.state.bounds;
		let result = null;
		if (this.state.constant && this.value) {
			const min = Array.from(this.value);
			result = [min, min];
		} else {
			const { value, numInstances, size } = this;
			const len = numInstances * size;
			if (value && len && value.length >= len) {
				const min = new Array(size).fill(Infinity);
				const max = new Array(size).fill(-Infinity);
				for (let i$1 = 0; i$1 < len;) for (let j$1 = 0; j$1 < size; j$1++) {
					const v$1 = value[i$1++];
					if (v$1 < min[j$1]) min[j$1] = v$1;
					if (v$1 > max[j$1]) max[j$1] = v$1;
				}
				result = [min, max];
			}
		}
		this.state.bounds = result;
		return result;
	}
	setData(data) {
		const { state } = this;
		let opts;
		if (ArrayBuffer.isView(data)) opts = { value: data };
		else if (data instanceof Buffer) opts = { buffer: data };
		else opts = data;
		const accessor = {
			...this.settings,
			...opts
		};
		if (ArrayBuffer.isView(opts.value)) {
			if (!opts.type) if (this.doublePrecision && opts.value instanceof Float64Array) accessor.type = "float32";
			else {
				const type = dataTypeFromTypedArray(opts.value);
				accessor.type = accessor.normalized ? type.replace("int", "norm") : type;
			}
			accessor.bytesPerElement = opts.value.BYTES_PER_ELEMENT;
			accessor.stride = getStride(accessor);
		}
		state.bounds = null;
		if (opts.constant) {
			let value = opts.value;
			value = this._normalizeValue(value, [], 0);
			if (this.settings.normalized) value = this.normalizeConstant(value);
			if (!(!state.constant || !this._areValuesEqual(value, this.value))) return false;
			state.externalBuffer = null;
			state.constant = true;
			this.value = ArrayBuffer.isView(value) ? value : new Float32Array(value);
		} else if (opts.buffer) {
			state.externalBuffer = opts.buffer;
			state.constant = false;
			this.value = opts.value || null;
		} else if (opts.value) {
			this._checkExternalBuffer(opts);
			let value = opts.value;
			state.externalBuffer = null;
			state.constant = false;
			this.value = value;
			let { buffer } = this;
			const stride = getStride(accessor);
			const byteOffset = (accessor.vertexOffset || 0) * stride;
			if (this.doublePrecision && value instanceof Float64Array) value = toDoublePrecisionArray(value, accessor);
			if (this.settings.isIndexed) {
				const ArrayType = this.settings.defaultType;
				if (value.constructor !== ArrayType) value = new ArrayType(value);
			}
			const requiredBufferSize = value.byteLength + byteOffset + stride * 2;
			if (!buffer || buffer.byteLength < requiredBufferSize) buffer = this._createBuffer(requiredBufferSize);
			buffer.write(value, byteOffset);
		}
		this.setAccessor(accessor);
		return true;
	}
	updateSubBuffer(opts = {}) {
		this.state.bounds = null;
		const value = this.value;
		const { startOffset = 0, endOffset } = opts;
		this.buffer.write(this.doublePrecision && value instanceof Float64Array ? toDoublePrecisionArray(value, {
			size: this.size,
			startIndex: startOffset,
			endIndex: endOffset
		}) : value.subarray(startOffset, endOffset), startOffset * value.BYTES_PER_ELEMENT + this.byteOffset);
	}
	allocate(numInstances, copy$1 = false) {
		const { state } = this;
		const oldValue = state.allocatedValue;
		const value = typed_array_manager_default.allocate(oldValue, numInstances + 1, {
			size: this.size,
			type: this.settings.defaultType,
			copy: copy$1
		});
		this.value = value;
		const { byteOffset } = this;
		let { buffer } = this;
		if (!buffer || buffer.byteLength < value.byteLength + byteOffset) {
			buffer = this._createBuffer(value.byteLength + byteOffset);
			if (copy$1 && oldValue) buffer.write(oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue, byteOffset);
		}
		state.allocatedValue = value;
		state.constant = false;
		state.externalBuffer = null;
		this.setAccessor(this.settings);
		return true;
	}
	_checkExternalBuffer(opts) {
		const { value } = opts;
		if (!ArrayBuffer.isView(value)) throw new Error(`Attribute ${this.id} value is not TypedArray`);
		const ArrayType = this.settings.defaultType;
		let illegalArrayType = false;
		if (this.doublePrecision) illegalArrayType = value.BYTES_PER_ELEMENT < 4;
		if (illegalArrayType) throw new Error(`Attribute ${this.id} does not support ${value.constructor.name}`);
		if (!(value instanceof ArrayType) && this.settings.normalized && !("normalized" in opts)) log_default.warn(`Attribute ${this.id} is normalized`)();
	}
	normalizeConstant(value) {
		switch (this.settings.type) {
			case "snorm8": return new Float32Array(value).map((x$1) => (x$1 + 128) / 255 * 2 - 1);
			case "snorm16": return new Float32Array(value).map((x$1) => (x$1 + 32768) / 65535 * 2 - 1);
			case "unorm8": return new Float32Array(value).map((x$1) => x$1 / 255);
			case "unorm16": return new Float32Array(value).map((x$1) => x$1 / 65535);
			default: return value;
		}
	}
	_normalizeValue(value, out, start) {
		const { defaultValue, size } = this.settings;
		if (Number.isFinite(value)) {
			out[start] = value;
			return out;
		}
		if (!value) {
			let i$1 = size;
			while (--i$1 >= 0) out[start + i$1] = defaultValue[i$1];
			return out;
		}
		switch (size) {
			case 4: out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];
			case 3: out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];
			case 2: out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];
			case 1:
				out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];
				break;
			default:
				let i$1 = size;
				while (--i$1 >= 0) out[start + i$1] = Number.isFinite(value[i$1]) ? value[i$1] : defaultValue[i$1];
		}
		return out;
	}
	_areValuesEqual(value1, value2) {
		if (!value1 || !value2) return false;
		const { size } = this;
		for (let i$1 = 0; i$1 < size; i$1++) if (value1[i$1] !== value2[i$1]) return false;
		return true;
	}
	_createBuffer(byteLength) {
		if (this._buffer) this._buffer.destroy();
		const { isIndexed, type } = this.settings;
		this._buffer = this.device.createBuffer({
			...this._buffer?.props,
			id: this.id,
			usage: (isIndexed ? Buffer.INDEX : Buffer.VERTEX) | Buffer.COPY_DST,
			indexType: isIndexed ? type : void 0,
			byteLength
		});
		return this._buffer;
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/iterable-utils.js
var EMPTY_ARRAY$2 = [];
var placeholderArray = [];
function createIterable(data, startRow = 0, endRow = Infinity) {
	let iterable = EMPTY_ARRAY$2;
	const objectInfo = {
		index: -1,
		data,
		target: []
	};
	if (!data) iterable = EMPTY_ARRAY$2;
	else if (typeof data[Symbol.iterator] === "function") iterable = data;
	else if (data.length > 0) {
		placeholderArray.length = data.length;
		iterable = placeholderArray;
	}
	if (startRow > 0 || Number.isFinite(endRow)) {
		iterable = (Array.isArray(iterable) ? iterable : Array.from(iterable)).slice(startRow, endRow);
		objectInfo.index = startRow - 1;
	}
	return {
		iterable,
		objectInfo
	};
}
function isAsyncIterable(data) {
	return data && data[Symbol.asyncIterator];
}
function getAccessorFromBuffer(typedArray, options) {
	const { size, stride, offset, startIndices, nested } = options;
	const bytesPerElement = typedArray.BYTES_PER_ELEMENT;
	const elementStride = stride ? stride / bytesPerElement : size;
	const elementOffset = offset ? offset / bytesPerElement : 0;
	const vertexCount = Math.floor((typedArray.length - elementOffset) / elementStride);
	return (_$1, { index, target }) => {
		if (!startIndices) {
			const sourceIndex = index * elementStride + elementOffset;
			for (let j$1 = 0; j$1 < size; j$1++) target[j$1] = typedArray[sourceIndex + j$1];
			return target;
		}
		const startIndex = startIndices[index];
		const endIndex = startIndices[index + 1] || vertexCount;
		let result;
		if (nested) {
			result = new Array(endIndex - startIndex);
			for (let i$1 = startIndex; i$1 < endIndex; i$1++) {
				const sourceIndex = i$1 * elementStride + elementOffset;
				target = new Array(size);
				for (let j$1 = 0; j$1 < size; j$1++) target[j$1] = typedArray[sourceIndex + j$1];
				result[i$1 - startIndex] = target;
			}
		} else if (elementStride === size) result = typedArray.subarray(startIndex * size + elementOffset, endIndex * size + elementOffset);
		else {
			result = new typedArray.constructor((endIndex - startIndex) * size);
			let targetIndex = 0;
			for (let i$1 = startIndex; i$1 < endIndex; i$1++) {
				const sourceIndex = i$1 * elementStride + elementOffset;
				for (let j$1 = 0; j$1 < size; j$1++) result[targetIndex++] = typedArray[sourceIndex + j$1];
			}
		}
		return result;
	};
}

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/range.js
const EMPTY = [];
const FULL = [[0, Infinity]];
function add(rangeList, range) {
	if (rangeList === FULL) return rangeList;
	if (range[0] < 0) range[0] = 0;
	if (range[0] >= range[1]) return rangeList;
	const newRangeList = [];
	const len = rangeList.length;
	let insertPosition = 0;
	for (let i$1 = 0; i$1 < len; i$1++) {
		const range0 = rangeList[i$1];
		if (range0[1] < range[0]) {
			newRangeList.push(range0);
			insertPosition = i$1 + 1;
		} else if (range0[0] > range[1]) newRangeList.push(range0);
		else range = [Math.min(range0[0], range[0]), Math.max(range0[1], range[1])];
	}
	newRangeList.splice(insertPosition, 0, range);
	return newRangeList;
}

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/attribute/transition-settings.js
var DEFAULT_TRANSITION_SETTINGS = {
	interpolation: {
		duration: 0,
		easing: (t$1) => t$1
	},
	spring: {
		stiffness: .05,
		damping: .5
	}
};
function normalizeTransitionSettings(userSettings, layerSettings) {
	if (!userSettings) return null;
	if (Number.isFinite(userSettings)) userSettings = {
		type: "interpolation",
		duration: userSettings
	};
	const type = userSettings.type || "interpolation";
	return {
		...DEFAULT_TRANSITION_SETTINGS[type],
		...layerSettings,
		...userSettings,
		type
	};
}

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/attribute/attribute.js
var Attribute = class extends DataColumn {
	constructor(device, opts) {
		super(device, opts, {
			startIndices: null,
			lastExternalBuffer: null,
			binaryValue: null,
			binaryAccessor: null,
			needsUpdate: true,
			needsRedraw: false,
			layoutChanged: false,
			updateRanges: FULL
		});
		/** Legacy approach to set attribute value - read `isConstant` instead for attribute state */
		this.constant = false;
		this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : void 0);
		Object.seal(this.settings);
		Object.seal(this.state);
		this._validateAttributeUpdaters();
	}
	get startIndices() {
		return this.state.startIndices;
	}
	set startIndices(layout) {
		this.state.startIndices = layout;
	}
	needsUpdate() {
		return this.state.needsUpdate;
	}
	needsRedraw({ clearChangedFlags = false } = {}) {
		const needsRedraw = this.state.needsRedraw;
		this.state.needsRedraw = needsRedraw && !clearChangedFlags;
		return needsRedraw;
	}
	layoutChanged() {
		return this.state.layoutChanged;
	}
	setAccessor(accessor) {
		var _a;
		(_a = this.state).layoutChanged || (_a.layoutChanged = !bufferLayoutEqual(accessor, this.getAccessor()));
		super.setAccessor(accessor);
	}
	getUpdateTriggers() {
		const { accessor } = this.settings;
		return [this.id].concat(typeof accessor !== "function" && accessor || []);
	}
	supportsTransition() {
		return Boolean(this.settings.transition);
	}
	getTransitionSetting(opts) {
		if (!opts || !this.supportsTransition()) return null;
		const { accessor } = this.settings;
		const layerSettings = this.settings.transition;
		return normalizeTransitionSettings(Array.isArray(accessor) ? opts[accessor.find((a$1) => opts[a$1])] : opts[accessor], layerSettings);
	}
	setNeedsUpdate(reason = this.id, dataRange) {
		this.state.needsUpdate = this.state.needsUpdate || reason;
		this.setNeedsRedraw(reason);
		if (dataRange) {
			const { startRow = 0, endRow = Infinity } = dataRange;
			this.state.updateRanges = add(this.state.updateRanges, [startRow, endRow]);
		} else this.state.updateRanges = FULL;
	}
	clearNeedsUpdate() {
		this.state.needsUpdate = false;
		this.state.updateRanges = EMPTY;
	}
	setNeedsRedraw(reason = this.id) {
		this.state.needsRedraw = this.state.needsRedraw || reason;
	}
	allocate(numInstances) {
		const { state, settings } = this;
		if (settings.noAlloc) return false;
		if (settings.update) {
			super.allocate(numInstances, state.updateRanges !== FULL);
			return true;
		}
		return false;
	}
	updateBuffer({ numInstances, data, props, context }) {
		if (!this.needsUpdate()) return false;
		const { state: { updateRanges }, settings: { update, noAlloc } } = this;
		let updated = true;
		if (update) {
			for (const [startRow, endRow] of updateRanges) update.call(context, this, {
				data,
				startRow,
				endRow,
				props,
				numInstances
			});
			if (!this.value) {} else if (this.constant || !this.buffer || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {
				this.setData({
					value: this.value,
					constant: this.constant
				});
				this.constant = false;
			} else for (const [startRow, endRow] of updateRanges) {
				const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;
				const endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;
				super.updateSubBuffer({
					startOffset,
					endOffset
				});
			}
			this._checkAttributeArray();
		} else updated = false;
		this.clearNeedsUpdate();
		this.setNeedsRedraw();
		return updated;
	}
	setConstantValue(context, value) {
		const isWebGPU = this.device.type === "webgpu";
		if (isWebGPU || value === void 0 || typeof value === "function") {
			if (isWebGPU && typeof value !== "function") {
				const normalisedValue = this._normalizeValue(value, [], 0);
				if (!this._areValuesEqual(normalisedValue, this.value)) this.setNeedsUpdate("WebGPU constant updated");
			}
			return false;
		}
		const transformedValue = this.settings.transform && context ? this.settings.transform.call(context, value) : value;
		if (this.setData({
			constant: true,
			value: transformedValue
		})) this.setNeedsRedraw();
		this.clearNeedsUpdate();
		return true;
	}
	setExternalBuffer(buffer) {
		const { state } = this;
		if (!buffer) {
			state.lastExternalBuffer = null;
			return false;
		}
		this.clearNeedsUpdate();
		if (state.lastExternalBuffer === buffer) return true;
		state.lastExternalBuffer = buffer;
		this.setNeedsRedraw();
		this.setData(buffer);
		return true;
	}
	setBinaryValue(buffer, startIndices = null) {
		const { state, settings } = this;
		if (!buffer) {
			state.binaryValue = null;
			state.binaryAccessor = null;
			return false;
		}
		if (settings.noAlloc) return false;
		if (state.binaryValue === buffer) {
			this.clearNeedsUpdate();
			return true;
		}
		state.binaryValue = buffer;
		this.setNeedsRedraw();
		if (settings.transform || startIndices !== this.startIndices) {
			if (ArrayBuffer.isView(buffer)) buffer = { value: buffer };
			const binaryValue = buffer;
			assert(ArrayBuffer.isView(binaryValue.value), `invalid ${settings.accessor}`);
			const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;
			state.binaryAccessor = getAccessorFromBuffer(binaryValue.value, {
				size: binaryValue.size || this.size,
				stride: binaryValue.stride,
				offset: binaryValue.offset,
				startIndices,
				nested: needsNormalize
			});
			return false;
		}
		this.clearNeedsUpdate();
		this.setData(buffer);
		return true;
	}
	getVertexOffset(row) {
		const { startIndices } = this;
		return (startIndices ? row < startIndices.length ? startIndices[row] : this.numInstances : row) * this.size;
	}
	getValue() {
		const shaderAttributeDefs = this.settings.shaderAttributes;
		const result = super.getValue();
		if (!shaderAttributeDefs) return result;
		for (const shaderAttributeName in shaderAttributeDefs) Object.assign(result, super.getValue(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));
		return result;
	}
	/** Generate WebGPU-style buffer layout descriptor from this attribute */
	getBufferLayout(modelInfo) {
		this.state.layoutChanged = false;
		const shaderAttributeDefs = this.settings.shaderAttributes;
		const result = super._getBufferLayout();
		const { stepMode } = this.settings;
		if (stepMode === "dynamic") result.stepMode = modelInfo ? modelInfo.isInstanced ? "instance" : "vertex" : "instance";
		else result.stepMode = stepMode ?? "vertex";
		if (!shaderAttributeDefs) return result;
		for (const shaderAttributeName in shaderAttributeDefs) {
			const map = super._getBufferLayout(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]);
			result.attributes.push(...map.attributes);
		}
		return result;
	}
	_autoUpdater(attribute, { data, startRow, endRow, props, numInstances }) {
		if (attribute.constant) {
			if (this.context.device.type !== "webgpu") return;
		}
		const { settings, state, value, size, startIndices } = attribute;
		const { accessor, transform } = settings;
		let accessorFunc = state.binaryAccessor || (typeof accessor === "function" ? accessor : props[accessor]);
		if (typeof accessorFunc !== "function" && typeof accessor === "string") accessorFunc = () => props[accessor];
		assert(typeof accessorFunc === "function", `accessor "${accessor}" is not a function`);
		let i$1 = attribute.getVertexOffset(startRow);
		const { iterable, objectInfo } = createIterable(data, startRow, endRow);
		for (const object of iterable) {
			objectInfo.index++;
			let objectValue = accessorFunc(object, objectInfo);
			if (transform) objectValue = transform.call(this, objectValue);
			if (startIndices) {
				const numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];
				if (objectValue && Array.isArray(objectValue[0])) {
					let startIndex = i$1;
					for (const item of objectValue) {
						attribute._normalizeValue(item, value, startIndex);
						startIndex += size;
					}
				} else if (objectValue && objectValue.length > size) value.set(objectValue, i$1);
				else {
					attribute._normalizeValue(objectValue, objectInfo.target, 0);
					fillArray({
						target: value,
						source: objectInfo.target,
						start: i$1,
						count: numVertices
					});
				}
				i$1 += numVertices * size;
			} else {
				attribute._normalizeValue(objectValue, value, i$1);
				i$1 += size;
			}
		}
	}
	_validateAttributeUpdaters() {
		const { settings } = this;
		if (!(settings.noAlloc || typeof settings.update === "function")) throw new Error(`Attribute ${this.id} missing update or accessor`);
	}
	_checkAttributeArray() {
		const { value } = this;
		const limit = Math.min(4, this.size);
		if (value && value.length >= limit) {
			let valid = true;
			switch (limit) {
				case 4: valid = valid && Number.isFinite(value[3]);
				case 3: valid = valid && Number.isFinite(value[2]);
				case 2: valid = valid && Number.isFinite(value[1]);
				case 1:
					valid = valid && Number.isFinite(value[0]);
					break;
				default: valid = false;
			}
			if (!valid) throw new Error(`Illegal attribute generated for ${this.id}`);
		}
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/array-utils.js
function padArrayChunk(options) {
	const { source, target, start = 0, size, getData } = options;
	const end = options.end || target.length;
	const sourceLength = source.length;
	const targetLength = end - start;
	if (sourceLength > targetLength) {
		target.set(source.subarray(0, targetLength), start);
		return;
	}
	target.set(source, start);
	if (!getData) return;
	let i$1 = sourceLength;
	while (i$1 < targetLength) {
		const datum = getData(i$1, source);
		for (let j$1 = 0; j$1 < size; j$1++) {
			target[start + i$1] = datum[j$1] || 0;
			i$1++;
		}
	}
}
function padArray({ source, target, size, getData, sourceStartIndices, targetStartIndices }) {
	if (!sourceStartIndices || !targetStartIndices) {
		padArrayChunk({
			source,
			target,
			size,
			getData
		});
		return target;
	}
	let sourceIndex = 0;
	let targetIndex = 0;
	const getChunkData = getData && ((i$1, chunk) => getData(i$1 + targetIndex, chunk));
	const n$1 = Math.min(sourceStartIndices.length, targetStartIndices.length);
	for (let i$1 = 1; i$1 < n$1; i$1++) {
		const nextSourceIndex = sourceStartIndices[i$1] * size;
		const nextTargetIndex = targetStartIndices[i$1] * size;
		padArrayChunk({
			source: source.subarray(sourceIndex, nextSourceIndex),
			target,
			start: targetIndex,
			end: nextTargetIndex,
			size,
			getData: getChunkData
		});
		sourceIndex = nextSourceIndex;
		targetIndex = nextTargetIndex;
	}
	if (targetIndex < target.length) padArrayChunk({
		source: [],
		target,
		start: targetIndex,
		size,
		getData: getChunkData
	});
	return target;
}

//#endregion
//#region node_modules/@deck.gl/core/dist/transitions/gpu-transition-utils.js
/** Create a new empty attribute with the same settings: type, shader layout etc. */
function cloneAttribute(attribute) {
	const { device, settings, value } = attribute;
	const newAttribute = new Attribute(device, settings);
	newAttribute.setData({
		value: value instanceof Float64Array ? new Float64Array(0) : new Float32Array(0),
		normalized: settings.normalized
	});
	return newAttribute;
}
/** Returns the GLSL attribute type for the given number of float32 components. */
function getAttributeTypeFromSize(size) {
	switch (size) {
		case 1: return "float";
		case 2: return "vec2";
		case 3: return "vec3";
		case 4: return "vec4";
		default: throw new Error(`No defined attribute type for size "${size}"`);
	}
}
/** Returns the {@link VertexFormat} for the given number of float32 components. */
function getFloat32VertexFormat(size) {
	switch (size) {
		case 1: return "float32";
		case 2: return "float32x2";
		case 3: return "float32x3";
		case 4: return "float32x4";
		default: throw new Error("invalid type size");
	}
}
function cycleBuffers(buffers) {
	buffers.push(buffers.shift());
}
function getAttributeBufferLength(attribute, numInstances) {
	const { doublePrecision, settings, value, size } = attribute;
	const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;
	let maxVertexOffset = 0;
	const { shaderAttributes } = attribute.settings;
	if (shaderAttributes) for (const shaderAttribute of Object.values(shaderAttributes)) maxVertexOffset = Math.max(maxVertexOffset, shaderAttribute.vertexOffset ?? 0);
	return (settings.noAlloc ? value.length : (numInstances + maxVertexOffset) * size) * multiplier;
}
function matchBuffer({ device, source, target }) {
	if (!target || target.byteLength < source.byteLength) {
		target?.destroy();
		target = device.createBuffer({
			byteLength: source.byteLength,
			usage: source.usage
		});
	}
	return target;
}
function padBuffer({ device, buffer, attribute, fromLength, toLength, fromStartIndices, getData = (x$1) => x$1 }) {
	const precisionMultiplier = attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;
	const size = attribute.size * precisionMultiplier;
	const byteOffset = attribute.byteOffset;
	const targetByteOffset = attribute.settings.bytesPerElement < 4 ? byteOffset / attribute.settings.bytesPerElement * 4 : byteOffset;
	const toStartIndices = attribute.startIndices;
	const hasStartIndices = fromStartIndices && toStartIndices;
	const isConstant = attribute.isConstant;
	if (!hasStartIndices && buffer && fromLength >= toLength) return buffer;
	const ArrayType = attribute.value instanceof Float64Array ? Float32Array : attribute.value.constructor;
	const toData = isConstant ? attribute.value : new ArrayType(attribute.getBuffer().readSyncWebGL(byteOffset, toLength * ArrayType.BYTES_PER_ELEMENT).buffer);
	if (attribute.settings.normalized && !isConstant) {
		const getter = getData;
		getData = (value, chunk) => attribute.normalizeConstant(getter(value, chunk));
	}
	const getMissingData = isConstant ? (i$1, chunk) => getData(toData, chunk) : (i$1, chunk) => getData(toData.subarray(i$1 + byteOffset, i$1 + byteOffset + size), chunk);
	const source = buffer ? new Float32Array(buffer.readSyncWebGL(targetByteOffset, fromLength * 4).buffer) : new Float32Array(0);
	const target = new Float32Array(toLength);
	padArray({
		source,
		target,
		sourceStartIndices: fromStartIndices,
		targetStartIndices: toStartIndices,
		size,
		getData: getMissingData
	});
	if (!buffer || buffer.byteLength < target.byteLength + targetByteOffset) {
		buffer?.destroy();
		buffer = device.createBuffer({
			byteLength: target.byteLength + targetByteOffset,
			usage: 35050
		});
	}
	buffer.write(target, targetByteOffset);
	return buffer;
}

//#endregion
//#region node_modules/@deck.gl/core/dist/transitions/gpu-transition.js
var GPUTransitionBase = class {
	constructor({ device, attribute, timeline }) {
		this.buffers = [];
		/** The vertex count of the last buffer.
		* Buffer may be larger than the actual length we want to use
		* because we only reallocate buffers when they grow, not when they shrink,
		* due to performance costs */
		this.currentLength = 0;
		this.device = device;
		this.transition = new Transition(timeline);
		this.attribute = attribute;
		this.attributeInTransition = cloneAttribute(attribute);
		this.currentStartIndices = attribute.startIndices;
	}
	get inProgress() {
		return this.transition.inProgress;
	}
	start(transitionSettings, numInstances, duration = Infinity) {
		this.settings = transitionSettings;
		this.currentStartIndices = this.attribute.startIndices;
		this.currentLength = getAttributeBufferLength(this.attribute, numInstances);
		this.transition.start({
			...transitionSettings,
			duration
		});
	}
	update() {
		const updated = this.transition.update();
		if (updated) this.onUpdate();
		return updated;
	}
	setBuffer(buffer) {
		this.attributeInTransition.setData({
			buffer,
			normalized: this.attribute.settings.normalized,
			value: this.attributeInTransition.value
		});
	}
	cancel() {
		this.transition.cancel();
	}
	delete() {
		this.cancel();
		for (const buffer of this.buffers) buffer.destroy();
		this.buffers.length = 0;
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/transitions/gpu-interpolation-transition.js
var GPUInterpolationTransition = class extends GPUTransitionBase {
	constructor({ device, attribute, timeline }) {
		super({
			device,
			attribute,
			timeline
		});
		this.type = "interpolation";
		this.transform = getTransform$1(device, attribute);
	}
	start(transitionSettings, numInstances) {
		const prevLength = this.currentLength;
		const prevStartIndices = this.currentStartIndices;
		super.start(transitionSettings, numInstances, transitionSettings.duration);
		if (transitionSettings.duration <= 0) {
			this.transition.cancel();
			return;
		}
		const { buffers, attribute } = this;
		cycleBuffers(buffers);
		buffers[0] = padBuffer({
			device: this.device,
			buffer: buffers[0],
			attribute,
			fromLength: prevLength,
			toLength: this.currentLength,
			fromStartIndices: prevStartIndices,
			getData: transitionSettings.enter
		});
		buffers[1] = matchBuffer({
			device: this.device,
			source: buffers[0],
			target: buffers[1]
		});
		this.setBuffer(buffers[1]);
		const { transform } = this;
		const model = transform.model;
		let vertexCount = Math.floor(this.currentLength / attribute.size);
		if (useFp64(attribute)) vertexCount /= 2;
		model.setVertexCount(vertexCount);
		if (attribute.isConstant) {
			model.setAttributes({ aFrom: buffers[0] });
			model.setConstantAttributes({ aTo: attribute.value });
		} else model.setAttributes({
			aFrom: buffers[0],
			aTo: attribute.getBuffer()
		});
		transform.transformFeedback.setBuffers({ vCurrent: buffers[1] });
	}
	onUpdate() {
		const { duration, easing } = this.settings;
		const { time } = this.transition;
		let t$1 = time / duration;
		if (easing) t$1 = easing(t$1);
		const { model } = this.transform;
		const interpolationProps = { time: t$1 };
		model.shaderInputs.setProps({ interpolation: interpolationProps });
		this.transform.run({ discard: true });
	}
	delete() {
		super.delete();
		this.transform.destroy();
	}
};
var interpolationUniforms = {
	name: "interpolation",
	vs: `\
uniform interpolationUniforms {
  float time;
} interpolation;
`,
	uniformTypes: { time: "f32" }
};
var vs$1 = `\
#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vCurrent;

void main(void) {
  vCurrent = mix(aFrom, aTo, interpolation.time);
  gl_Position = vec4(0.0);
}
`;
var vs64 = `\
#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aFrom64Low;
in ATTRIBUTE_TYPE aTo;
in ATTRIBUTE_TYPE aTo64Low;
out ATTRIBUTE_TYPE vCurrent;
out ATTRIBUTE_TYPE vCurrent64Low;

vec2 mix_fp64(vec2 a, vec2 b, float x) {
  vec2 range = sub_fp64(b, a);
  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}

void main(void) {
  for (int i=0; i<ATTRIBUTE_SIZE; i++) {
    vec2 value = mix_fp64(vec2(aFrom[i], aFrom64Low[i]), vec2(aTo[i], aTo64Low[i]), interpolation.time);
    vCurrent[i] = value.x;
    vCurrent64Low[i] = value.y;
  }
  gl_Position = vec4(0.0);
}
`;
function useFp64(attribute) {
	return attribute.doublePrecision && attribute.value instanceof Float64Array;
}
function getTransform$1(device, attribute) {
	const attributeSize = attribute.size;
	const attributeType = getAttributeTypeFromSize(attributeSize);
	const inputFormat = getFloat32VertexFormat(attributeSize);
	const bufferLayout = attribute.getBufferLayout();
	if (useFp64(attribute)) return new BufferTransform(device, {
		vs: vs64,
		bufferLayout: [{
			name: "aFrom",
			byteStride: 8 * attributeSize,
			attributes: [{
				attribute: "aFrom",
				format: inputFormat,
				byteOffset: 0
			}, {
				attribute: "aFrom64Low",
				format: inputFormat,
				byteOffset: 4 * attributeSize
			}]
		}, {
			name: "aTo",
			byteStride: 8 * attributeSize,
			attributes: [{
				attribute: "aTo",
				format: inputFormat,
				byteOffset: 0
			}, {
				attribute: "aTo64Low",
				format: inputFormat,
				byteOffset: 4 * attributeSize
			}]
		}],
		modules: [fp64arithmetic, interpolationUniforms],
		defines: {
			ATTRIBUTE_TYPE: attributeType,
			ATTRIBUTE_SIZE: attributeSize
		},
		moduleSettings: {},
		varyings: ["vCurrent", "vCurrent64Low"],
		bufferMode: 35980,
		disableWarnings: true
	});
	return new BufferTransform(device, {
		vs: vs$1,
		bufferLayout: [{
			name: "aFrom",
			format: inputFormat
		}, {
			name: "aTo",
			format: bufferLayout.attributes[0].format
		}],
		modules: [interpolationUniforms],
		defines: { ATTRIBUTE_TYPE: attributeType },
		varyings: ["vCurrent"],
		disableWarnings: true
	});
}

//#endregion
//#region node_modules/@deck.gl/core/dist/transitions/gpu-spring-transition.js
var GPUSpringTransition = class extends GPUTransitionBase {
	constructor({ device, attribute, timeline }) {
		super({
			device,
			attribute,
			timeline
		});
		this.type = "spring";
		this.texture = getTexture(device);
		this.framebuffer = getFramebuffer(device, this.texture);
		this.transform = getTransform(device, attribute);
	}
	start(transitionSettings, numInstances) {
		const prevLength = this.currentLength;
		const prevStartIndices = this.currentStartIndices;
		super.start(transitionSettings, numInstances);
		const { buffers, attribute } = this;
		for (let i$1 = 0; i$1 < 2; i$1++) buffers[i$1] = padBuffer({
			device: this.device,
			buffer: buffers[i$1],
			attribute,
			fromLength: prevLength,
			toLength: this.currentLength,
			fromStartIndices: prevStartIndices,
			getData: transitionSettings.enter
		});
		buffers[2] = matchBuffer({
			device: this.device,
			source: buffers[0],
			target: buffers[2]
		});
		this.setBuffer(buffers[1]);
		const { model } = this.transform;
		model.setVertexCount(Math.floor(this.currentLength / attribute.size));
		if (attribute.isConstant) model.setConstantAttributes({ aTo: attribute.value });
		else model.setAttributes({ aTo: attribute.getBuffer() });
	}
	onUpdate() {
		const { buffers, transform, framebuffer, transition } = this;
		const settings = this.settings;
		transform.model.setAttributes({
			aPrev: buffers[0],
			aCur: buffers[1]
		});
		transform.transformFeedback.setBuffers({ vNext: buffers[2] });
		const springProps = {
			stiffness: settings.stiffness,
			damping: settings.damping
		};
		transform.model.shaderInputs.setProps({ spring: springProps });
		transform.run({
			framebuffer,
			discard: false,
			parameters: { viewport: [
				0,
				0,
				1,
				1
			] },
			clearColor: [
				0,
				0,
				0,
				0
			]
		});
		cycleBuffers(buffers);
		this.setBuffer(buffers[1]);
		if (!(this.device.readPixelsToArrayWebGL(framebuffer)[0] > 0)) transition.end();
	}
	delete() {
		super.delete();
		this.transform.destroy();
		this.texture.destroy();
		this.framebuffer.destroy();
	}
};
var springUniforms = {
	name: "spring",
	vs: `\
uniform springUniforms {
  float damping;
  float stiffness;
} spring;
`,
	uniformTypes: {
		damping: "f32",
		stiffness: "f32"
	}
};
var vs = `\
#version 300 es
#define SHADER_NAME spring-transition-vertex-shader

#define EPSILON 0.00001

in ATTRIBUTE_TYPE aPrev;
in ATTRIBUTE_TYPE aCur;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vNext;
out float vIsTransitioningFlag;

ATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {
  ATTRIBUTE_TYPE velocity = cur - prev;
  ATTRIBUTE_TYPE delta = dest - cur;
  ATTRIBUTE_TYPE force = delta * spring.stiffness;
  ATTRIBUTE_TYPE resistance = velocity * spring.damping;
  return force - resistance + velocity + cur;
}

void main(void) {
  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;
  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;

  vNext = getNextValue(aCur, aPrev, aTo);
  gl_Position = vec4(0, 0, 0, 1);
  gl_PointSize = 100.0;
}
`;
var fs = `\
#version 300 es
#define SHADER_NAME spring-transition-is-transitioning-fragment-shader

in float vIsTransitioningFlag;

out vec4 fragColor;

void main(void) {
  if (vIsTransitioningFlag == 0.0) {
    discard;
  }
  fragColor = vec4(1.0);
}`;
function getTransform(device, attribute) {
	const attributeType = getAttributeTypeFromSize(attribute.size);
	const format = getFloat32VertexFormat(attribute.size);
	return new BufferTransform(device, {
		vs,
		fs,
		bufferLayout: [
			{
				name: "aPrev",
				format
			},
			{
				name: "aCur",
				format
			},
			{
				name: "aTo",
				format: attribute.getBufferLayout().attributes[0].format
			}
		],
		varyings: ["vNext"],
		modules: [springUniforms],
		defines: { ATTRIBUTE_TYPE: attributeType },
		parameters: {
			depthCompare: "always",
			blendColorOperation: "max",
			blendColorSrcFactor: "one",
			blendColorDstFactor: "one",
			blendAlphaOperation: "max",
			blendAlphaSrcFactor: "one",
			blendAlphaDstFactor: "one"
		}
	});
}
function getTexture(device) {
	return device.createTexture({
		data: new Uint8Array(4),
		format: "rgba8unorm",
		width: 1,
		height: 1
	});
}
function getFramebuffer(device, texture) {
	return device.createFramebuffer({
		id: "spring-transition-is-transitioning-framebuffer",
		width: 1,
		height: 1,
		colorAttachments: [texture]
	});
}

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/attribute/attribute-transition-manager.js
var TRANSITION_TYPES$1 = {
	interpolation: GPUInterpolationTransition,
	spring: GPUSpringTransition
};
var AttributeTransitionManager = class {
	constructor(device, { id, timeline }) {
		if (!device) throw new Error("AttributeTransitionManager is constructed without device");
		this.id = id;
		this.device = device;
		this.timeline = timeline;
		this.transitions = {};
		this.needsRedraw = false;
		this.numInstances = 1;
	}
	finalize() {
		for (const attributeName in this.transitions) this._removeTransition(attributeName);
	}
	update({ attributes, transitions, numInstances }) {
		this.numInstances = numInstances || 1;
		for (const attributeName in attributes) {
			const attribute = attributes[attributeName];
			const settings = attribute.getTransitionSetting(transitions);
			if (!settings) continue;
			this._updateAttribute(attributeName, attribute, settings);
		}
		for (const attributeName in this.transitions) {
			const attribute = attributes[attributeName];
			if (!attribute || !attribute.getTransitionSetting(transitions)) this._removeTransition(attributeName);
		}
	}
	hasAttribute(attributeName) {
		const transition = this.transitions[attributeName];
		return transition && transition.inProgress;
	}
	getAttributes() {
		const animatedAttributes = {};
		for (const attributeName in this.transitions) {
			const transition = this.transitions[attributeName];
			if (transition.inProgress) animatedAttributes[attributeName] = transition.attributeInTransition;
		}
		return animatedAttributes;
	}
	run() {
		if (this.numInstances === 0) return false;
		for (const attributeName in this.transitions) if (this.transitions[attributeName].update()) this.needsRedraw = true;
		const needsRedraw = this.needsRedraw;
		this.needsRedraw = false;
		return needsRedraw;
	}
	_removeTransition(attributeName) {
		this.transitions[attributeName].delete();
		delete this.transitions[attributeName];
	}
	_updateAttribute(attributeName, attribute, settings) {
		const transition = this.transitions[attributeName];
		let isNew = !transition || transition.type !== settings.type;
		if (isNew) {
			if (transition) this._removeTransition(attributeName);
			const TransitionType = TRANSITION_TYPES$1[settings.type];
			if (TransitionType) this.transitions[attributeName] = new TransitionType({
				attribute,
				timeline: this.timeline,
				device: this.device
			});
			else {
				log_default.error(`unsupported transition type '${settings.type}'`)();
				isNew = false;
			}
		}
		if (isNew || attribute.needsRedraw()) {
			this.needsRedraw = true;
			this.transitions[attributeName].start(settings, this.numInstances);
		}
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/attribute/attribute-manager.js
var TRACE_INVALIDATE = "attributeManager.invalidate";
var TRACE_UPDATE_START = "attributeManager.updateStart";
var TRACE_UPDATE_END = "attributeManager.updateEnd";
var TRACE_ATTRIBUTE_UPDATE_START = "attribute.updateStart";
var TRACE_ATTRIBUTE_ALLOCATE = "attribute.allocate";
var TRACE_ATTRIBUTE_UPDATE_END = "attribute.updateEnd";
var AttributeManager = class {
	constructor(device, { id = "attribute-manager", stats, timeline } = {}) {
		this.mergeBoundsMemoized = memoize(mergeBounds);
		this.id = id;
		this.device = device;
		this.attributes = {};
		this.updateTriggers = {};
		this.needsRedraw = true;
		this.userData = {};
		this.stats = stats;
		this.attributeTransitionManager = new AttributeTransitionManager(device, {
			id: `${id}-transitions`,
			timeline
		});
		Object.seal(this);
	}
	finalize() {
		for (const attributeName in this.attributes) this.attributes[attributeName].delete();
		this.attributeTransitionManager.finalize();
	}
	getNeedsRedraw(opts = { clearRedrawFlags: false }) {
		const redraw = this.needsRedraw;
		this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;
		return redraw && this.id;
	}
	setNeedsRedraw() {
		this.needsRedraw = true;
	}
	add(attributes) {
		this._add(attributes);
	}
	addInstanced(attributes) {
		this._add(attributes, { stepMode: "instance" });
	}
	/**
	* Removes attributes
	* Takes an array of attribute names and delete them from
	* the attribute map if they exists
	*
	* @example
	* attributeManager.remove(['position']);
	*
	* @param {Object} attributeNameArray - attribute name array (see above)
	*/
	remove(attributeNameArray) {
		for (const name of attributeNameArray) if (this.attributes[name] !== void 0) {
			this.attributes[name].delete();
			delete this.attributes[name];
		}
	}
	invalidate(triggerName, dataRange) {
		const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);
		debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);
	}
	invalidateAll(dataRange) {
		for (const attributeName in this.attributes) this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);
		debug(TRACE_INVALIDATE, this, "all");
	}
	update({ data, numInstances, startIndices = null, transitions, props = {}, buffers = {}, context = {} }) {
		let updated = false;
		debug(TRACE_UPDATE_START, this);
		if (this.stats) this.stats.get("Update Attributes").timeStart();
		for (const attributeName in this.attributes) {
			const attribute = this.attributes[attributeName];
			const accessorName = attribute.settings.accessor;
			attribute.startIndices = startIndices;
			attribute.numInstances = numInstances;
			if (props[attributeName]) log_default.removed(`props.${attributeName}`, `data.attributes.${attributeName}`)();
			if (attribute.setExternalBuffer(buffers[attributeName])) {} else if (attribute.setBinaryValue(typeof accessorName === "string" ? buffers[accessorName] : void 0, data.startIndices)) {} else if (typeof accessorName === "string" && !buffers[accessorName] && attribute.setConstantValue(context, props[accessorName])) {} else if (attribute.needsUpdate()) {
				updated = true;
				this._updateAttribute({
					attribute,
					numInstances,
					data,
					props,
					context
				});
			}
			this.needsRedraw = this.needsRedraw || attribute.needsRedraw();
		}
		if (updated) debug(TRACE_UPDATE_END, this, numInstances);
		if (this.stats) this.stats.get("Update Attributes").timeEnd();
		this.attributeTransitionManager.update({
			attributes: this.attributes,
			numInstances,
			transitions
		});
	}
	updateTransition() {
		const { attributeTransitionManager } = this;
		const transitionUpdated = attributeTransitionManager.run();
		this.needsRedraw = this.needsRedraw || transitionUpdated;
		return transitionUpdated;
	}
	/**
	* Returns all attribute descriptors
	* Note: Format matches luma.gl Model/Program.setAttributes()
	* @return {Object} attributes - descriptors
	*/
	getAttributes() {
		return {
			...this.attributes,
			...this.attributeTransitionManager.getAttributes()
		};
	}
	/**
	* Computes the spatial bounds of a given set of attributes
	*/
	getBounds(attributeNames) {
		const bounds = attributeNames.map((attributeName) => this.attributes[attributeName]?.getBounds());
		return this.mergeBoundsMemoized(bounds);
	}
	/**
	* Returns changed attribute descriptors
	* This indicates which WebGLBuffers need to be updated
	* @return {Object} attributes - descriptors
	*/
	getChangedAttributes(opts = { clearChangedFlags: false }) {
		const { attributes, attributeTransitionManager } = this;
		const changedAttributes = { ...attributeTransitionManager.getAttributes() };
		for (const attributeName in attributes) {
			const attribute = attributes[attributeName];
			if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) changedAttributes[attributeName] = attribute;
		}
		return changedAttributes;
	}
	/** Generate WebGPU-style buffer layout descriptors from all attributes */
	getBufferLayouts(modelInfo) {
		return Object.values(this.getAttributes()).map((attribute) => attribute.getBufferLayout(modelInfo));
	}
	/** Register new attributes */
	_add(attributes, overrideOptions) {
		for (const attributeName in attributes) {
			const attribute = attributes[attributeName];
			const props = {
				...attribute,
				id: attributeName,
				size: attribute.isIndexed && 1 || attribute.size || 1,
				...overrideOptions
			};
			this.attributes[attributeName] = new Attribute(this.device, props);
		}
		this._mapUpdateTriggersToAttributes();
	}
	_mapUpdateTriggersToAttributes() {
		const triggers = {};
		for (const attributeName in this.attributes) this.attributes[attributeName].getUpdateTriggers().forEach((triggerName) => {
			if (!triggers[triggerName]) triggers[triggerName] = [];
			triggers[triggerName].push(attributeName);
		});
		this.updateTriggers = triggers;
	}
	_invalidateTrigger(triggerName, dataRange) {
		const { attributes, updateTriggers } = this;
		const invalidatedAttributes = updateTriggers[triggerName];
		if (invalidatedAttributes) invalidatedAttributes.forEach((name) => {
			const attribute = attributes[name];
			if (attribute) attribute.setNeedsUpdate(attribute.id, dataRange);
		});
		return invalidatedAttributes;
	}
	_updateAttribute(opts) {
		const { attribute, numInstances } = opts;
		debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);
		if (attribute.constant) {
			attribute.setConstantValue(opts.context, attribute.value);
			return;
		}
		if (attribute.allocate(numInstances)) debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);
		if (attribute.updateBuffer(opts)) {
			this.needsRedraw = true;
			debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);
		}
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/transitions/cpu-interpolation-transition.js
var CPUInterpolationTransition = class extends Transition {
	get value() {
		return this._value;
	}
	_onUpdate() {
		const { time, settings: { fromValue, toValue, duration, easing } } = this;
		this._value = lerp(fromValue, toValue, easing(time / duration));
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/transitions/cpu-spring-transition.js
var EPSILON = 1e-5;
function updateSpringElement(prev, cur, dest, damping, stiffness) {
	const velocity = cur - prev;
	return (dest - cur) * stiffness + -velocity * damping + velocity + cur;
}
function updateSpring(prev, cur, dest, damping, stiffness) {
	if (Array.isArray(dest)) {
		const next = [];
		for (let i$1 = 0; i$1 < dest.length; i$1++) next[i$1] = updateSpringElement(prev[i$1], cur[i$1], dest[i$1], damping, stiffness);
		return next;
	}
	return updateSpringElement(prev, cur, dest, damping, stiffness);
}
function distance(value1, value2) {
	if (Array.isArray(value1)) {
		let distanceSquare = 0;
		for (let i$1 = 0; i$1 < value1.length; i$1++) {
			const d$1 = value1[i$1] - value2[i$1];
			distanceSquare += d$1 * d$1;
		}
		return Math.sqrt(distanceSquare);
	}
	return Math.abs(value1 - value2);
}
var CPUSpringTransition = class extends Transition {
	get value() {
		return this._currValue;
	}
	_onUpdate() {
		const { fromValue, toValue, damping, stiffness } = this.settings;
		const { _prevValue = fromValue, _currValue = fromValue } = this;
		let nextValue = updateSpring(_prevValue, _currValue, toValue, damping, stiffness);
		const delta = distance(nextValue, toValue);
		const velocity = distance(nextValue, _currValue);
		if (delta < EPSILON && velocity < EPSILON) {
			nextValue = toValue;
			this.end();
		}
		this._prevValue = _currValue;
		this._currValue = nextValue;
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/uniform-transition-manager.js
var TRANSITION_TYPES = {
	interpolation: CPUInterpolationTransition,
	spring: CPUSpringTransition
};
var UniformTransitionManager = class {
	constructor(timeline) {
		this.transitions = /* @__PURE__ */ new Map();
		this.timeline = timeline;
	}
	get active() {
		return this.transitions.size > 0;
	}
	add(key, fromValue, toValue, settings) {
		const { transitions } = this;
		if (transitions.has(key)) {
			const transition$1 = transitions.get(key);
			const { value = transition$1.settings.fromValue } = transition$1;
			fromValue = value;
			this.remove(key);
		}
		settings = normalizeTransitionSettings(settings);
		if (!settings) return;
		const TransitionType = TRANSITION_TYPES[settings.type];
		if (!TransitionType) {
			log_default.error(`unsupported transition type '${settings.type}'`)();
			return;
		}
		const transition = new TransitionType(this.timeline);
		transition.start({
			...settings,
			fromValue,
			toValue
		});
		transitions.set(key, transition);
	}
	remove(key) {
		const { transitions } = this;
		if (transitions.has(key)) {
			transitions.get(key).cancel();
			transitions.delete(key);
		}
	}
	update() {
		const propsInTransition = {};
		for (const [key, transition] of this.transitions) {
			transition.update();
			propsInTransition[key] = transition.value;
			if (!transition.inProgress) this.remove(key);
		}
		return propsInTransition;
	}
	clear() {
		for (const key of this.transitions.keys()) this.remove(key);
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/lifecycle/props.js
function validateProps(props) {
	const propTypes = props[PROP_TYPES_SYMBOL];
	for (const propName in propTypes) {
		const propType = propTypes[propName];
		const { validate: validate$1 } = propType;
		if (validate$1 && !validate$1(props[propName], propType)) throw new Error(`Invalid prop ${propName}: ${props[propName]}`);
	}
}
function diffProps(props, oldProps) {
	const propsChangedReason = compareProps({
		newProps: props,
		oldProps,
		propTypes: props[PROP_TYPES_SYMBOL],
		ignoreProps: {
			data: null,
			updateTriggers: null,
			extensions: null,
			transitions: null
		}
	});
	const dataChangedReason = diffDataProps(props, oldProps);
	let updateTriggersChangedReason = false;
	if (!dataChangedReason) updateTriggersChangedReason = diffUpdateTriggers(props, oldProps);
	return {
		dataChanged: dataChangedReason,
		propsChanged: propsChangedReason,
		updateTriggersChanged: updateTriggersChangedReason,
		extensionsChanged: diffExtensions(props, oldProps),
		transitionsChanged: diffTransitions(props, oldProps)
	};
}
function diffTransitions(props, oldProps) {
	if (!props.transitions) return false;
	const result = {};
	const propTypes = props[PROP_TYPES_SYMBOL];
	let changed = false;
	for (const key in props.transitions) {
		const propType = propTypes[key];
		const type = propType && propType.type;
		if ((type === "number" || type === "color" || type === "array") && comparePropValues(props[key], oldProps[key], propType)) {
			result[key] = true;
			changed = true;
		}
	}
	return changed ? result : false;
}
/**
* Performs equality by iterating through keys on an object and returning false
* when any key has values which are not strictly equal between the arguments.
* @param {Object} opt.oldProps - object with old key/value pairs
* @param {Object} opt.newProps - object with new key/value pairs
* @param {Object} opt.ignoreProps={} - object, keys that should not be compared
* @returns {null|String} - null when values of all keys are strictly equal.
*   if unequal, returns a string explaining what changed.
*/
function compareProps({ newProps, oldProps, ignoreProps = {}, propTypes = {}, triggerName = "props" }) {
	if (oldProps === newProps) return false;
	if (typeof newProps !== "object" || newProps === null) return `${triggerName} changed shallowly`;
	if (typeof oldProps !== "object" || oldProps === null) return `${triggerName} changed shallowly`;
	for (const key of Object.keys(newProps)) if (!(key in ignoreProps)) {
		if (!(key in oldProps)) return `${triggerName}.${key} added`;
		const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);
		if (changed) return `${triggerName}.${key} ${changed}`;
	}
	for (const key of Object.keys(oldProps)) if (!(key in ignoreProps)) {
		if (!(key in newProps)) return `${triggerName}.${key} dropped`;
		if (!Object.hasOwnProperty.call(newProps, key)) {
			const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);
			if (changed) return `${triggerName}.${key} ${changed}`;
		}
	}
	return false;
}
function comparePropValues(newProp, oldProp, propType) {
	let equal = propType && propType.equal;
	if (equal && !equal(newProp, oldProp, propType)) return "changed deeply";
	if (!equal) {
		equal = newProp && oldProp && newProp.equals;
		if (equal && !equal.call(newProp, oldProp)) return "changed deeply";
	}
	if (!equal && oldProp !== newProp) return "changed shallowly";
	return null;
}
function diffDataProps(props, oldProps) {
	if (oldProps === null) return "oldProps is null, initial diff";
	let dataChanged = false;
	const { dataComparator, _dataDiff } = props;
	if (dataComparator) {
		if (!dataComparator(props.data, oldProps.data)) dataChanged = "Data comparator detected a change";
	} else if (props.data !== oldProps.data) dataChanged = "A new data container was supplied";
	if (dataChanged && _dataDiff) dataChanged = _dataDiff(props.data, oldProps.data) || dataChanged;
	return dataChanged;
}
function diffUpdateTriggers(props, oldProps) {
	if (oldProps === null) return { all: true };
	if ("all" in props.updateTriggers) {
		if (diffUpdateTrigger(props, oldProps, "all")) return { all: true };
	}
	const reason = {};
	let changed = false;
	for (const triggerName in props.updateTriggers) if (triggerName !== "all") {
		if (diffUpdateTrigger(props, oldProps, triggerName)) {
			reason[triggerName] = true;
			changed = true;
		}
	}
	return changed ? reason : false;
}
function diffExtensions(props, oldProps) {
	if (oldProps === null) return true;
	const oldExtensions = oldProps.extensions;
	const { extensions } = props;
	if (extensions === oldExtensions) return false;
	if (!oldExtensions || !extensions) return true;
	if (extensions.length !== oldExtensions.length) return true;
	for (let i$1 = 0; i$1 < extensions.length; i$1++) if (!extensions[i$1].equals(oldExtensions[i$1])) return true;
	return false;
}
function diffUpdateTrigger(props, oldProps, triggerName) {
	let newTriggers = props.updateTriggers[triggerName];
	newTriggers = newTriggers === void 0 || newTriggers === null ? {} : newTriggers;
	let oldTriggers = oldProps.updateTriggers[triggerName];
	oldTriggers = oldTriggers === void 0 || oldTriggers === null ? {} : oldTriggers;
	return compareProps({
		oldProps: oldTriggers,
		newProps: newTriggers,
		triggerName
	});
}

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/count.js
var ERR_NOT_OBJECT = "count(): argument not an object";
var ERR_NOT_CONTAINER = "count(): argument not a container";
/**
* Deduces numer of elements in a JavaScript container.
* - Auto-deduction for ES6 containers that define a count() method
* - Auto-deduction for ES6 containers that define a size member
* - Auto-deduction for Classic Arrays via the built-in length attribute
* - Also handles objects, although note that this an O(N) operation
*/
function count(container) {
	if (!isObject(container)) throw new Error(ERR_NOT_OBJECT);
	if (typeof container.count === "function") return container.count();
	if (Number.isFinite(container.size)) return container.size;
	if (Number.isFinite(container.length)) return container.length;
	if (isPlainObject(container)) return Object.keys(container).length;
	throw new Error(ERR_NOT_CONTAINER);
}
/**
* Checks if argument is a plain object (not a class or array etc)
* @param {*} value - JavaScript value to be tested
* @return {Boolean} - true if argument is a plain JavaScript object
*/
function isPlainObject(value) {
	return value !== null && typeof value === "object" && value.constructor === Object;
}
/**
* Checks if argument is an indexable object (not a primitive value, nor null)
* @param {*} value - JavaScript value to be tested
* @return {Boolean} - true if argument is a JavaScript object
*/
function isObject(value) {
	return value !== null && typeof value === "object";
}

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/shader.js
function mergeShaders(target, source) {
	if (!source) return target;
	const result = {
		...target,
		...source
	};
	if ("defines" in source) result.defines = {
		...target.defines,
		...source.defines
	};
	if ("modules" in source) {
		result.modules = (target.modules || []).concat(source.modules);
		if (source.modules.some((module$1) => module$1.name === "project64")) {
			const index = result.modules.findIndex((module$1) => module$1.name === "project32");
			if (index >= 0) result.modules.splice(index, 1);
		}
	}
	if ("inject" in source) if (!target.inject) result.inject = source.inject;
	else {
		const mergedInjection = { ...target.inject };
		for (const key in source.inject) mergedInjection[key] = (mergedInjection[key] || "") + source.inject[key];
		result.inject = mergedInjection;
	}
	return result;
}

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/texture.js
var DEFAULT_TEXTURE_PARAMETERS = {
	minFilter: "linear",
	mipmapFilter: "linear",
	magFilter: "linear",
	addressModeU: "clamp-to-edge",
	addressModeV: "clamp-to-edge"
};
var internalTextures = {};
/**
*
* @param owner
* @param device
* @param image could be one of:
*   - Texture
*   - Browser object: Image, ImageData, ImageData, HTMLCanvasElement, HTMLVideoElement, ImageBitmap
*   - Plain object: {width: <number>, height: <number>, data: <Uint8Array>}
* @param parameters
* @returns
*/
function createTexture(owner, device, image, sampler) {
	if (image instanceof Texture) return image;
	else if (image.constructor && image.constructor.name !== "Object") image = { data: image };
	let samplerParameters = null;
	if (image.compressed) samplerParameters = {
		minFilter: "linear",
		mipmapFilter: image.data.length > 1 ? "nearest" : "linear"
	};
	const { width, height } = image.data;
	const texture = device.createTexture({
		...image,
		sampler: {
			...DEFAULT_TEXTURE_PARAMETERS,
			...samplerParameters,
			...sampler
		},
		mipLevels: device.getMipLevelCount(width, height)
	});
	texture.generateMipmapsWebGL();
	internalTextures[texture.id] = owner;
	return texture;
}
function destroyTexture(owner, texture) {
	if (!texture || !(texture instanceof Texture)) return;
	if (internalTextures[texture.id] === owner) {
		texture.delete();
		delete internalTextures[texture.id];
	}
}

//#endregion
//#region node_modules/@deck.gl/core/dist/lifecycle/prop-types.js
var TYPE_DEFINITIONS = {
	boolean: {
		validate(value, propType) {
			return true;
		},
		equal(value1, value2, propType) {
			return Boolean(value1) === Boolean(value2);
		}
	},
	number: { validate(value, propType) {
		return Number.isFinite(value) && (!("max" in propType) || value <= propType.max) && (!("min" in propType) || value >= propType.min);
	} },
	color: {
		validate(value, propType) {
			return propType.optional && !value || isArray(value) && (value.length === 3 || value.length === 4);
		},
		equal(value1, value2, propType) {
			return deepEqual(value1, value2, 1);
		}
	},
	accessor: {
		validate(value, propType) {
			const valueType = getTypeOf(value);
			return valueType === "function" || valueType === getTypeOf(propType.value);
		},
		equal(value1, value2, propType) {
			if (typeof value2 === "function") return true;
			return deepEqual(value1, value2, 1);
		}
	},
	array: {
		validate(value, propType) {
			return propType.optional && !value || isArray(value);
		},
		equal(value1, value2, propType) {
			const { compare } = propType;
			return compare ? deepEqual(value1, value2, Number.isInteger(compare) ? compare : compare ? 1 : 0) : value1 === value2;
		}
	},
	object: { equal(value1, value2, propType) {
		if (propType.ignore) return true;
		const { compare } = propType;
		return compare ? deepEqual(value1, value2, Number.isInteger(compare) ? compare : compare ? 1 : 0) : value1 === value2;
	} },
	function: {
		validate(value, propType) {
			return propType.optional && !value || typeof value === "function";
		},
		equal(value1, value2, propType) {
			return !propType.compare && propType.ignore !== false || value1 === value2;
		}
	},
	data: { transform: (value, propType, component) => {
		if (!value) return value;
		const { dataTransform } = component.props;
		if (dataTransform) return dataTransform(value);
		if (typeof value.shape === "string" && value.shape.endsWith("-table") && Array.isArray(value.data)) return value.data;
		return value;
	} },
	image: {
		transform: (value, propType, component) => {
			const context = component.context;
			if (!context || !context.device) return null;
			return createTexture(component.id, context.device, value, {
				...propType.parameters,
				...component.props.textureParameters
			});
		},
		release: (value, propType, component) => {
			destroyTexture(component.id, value);
		}
	}
};
function parsePropTypes(propDefs) {
	const propTypes = {};
	const defaultProps$16 = {};
	const deprecatedProps = {};
	for (const [propName, propDef] of Object.entries(propDefs)) {
		const deprecated = propDef?.deprecatedFor;
		if (deprecated) deprecatedProps[propName] = Array.isArray(deprecated) ? deprecated : [deprecated];
		else {
			const propType = parsePropType(propName, propDef);
			propTypes[propName] = propType;
			defaultProps$16[propName] = propType.value;
		}
	}
	return {
		propTypes,
		defaultProps: defaultProps$16,
		deprecatedProps
	};
}
function parsePropType(name, propDef) {
	switch (getTypeOf(propDef)) {
		case "object": return normalizePropDefinition(name, propDef);
		case "array": return normalizePropDefinition(name, {
			type: "array",
			value: propDef,
			compare: false
		});
		case "boolean": return normalizePropDefinition(name, {
			type: "boolean",
			value: propDef
		});
		case "number": return normalizePropDefinition(name, {
			type: "number",
			value: propDef
		});
		case "function": return normalizePropDefinition(name, {
			type: "function",
			value: propDef,
			compare: true
		});
		default: return {
			name,
			type: "unknown",
			value: propDef
		};
	}
}
function normalizePropDefinition(name, propDef) {
	if (!("type" in propDef)) {
		if (!("value" in propDef)) return {
			name,
			type: "object",
			value: propDef
		};
		return {
			name,
			type: getTypeOf(propDef.value),
			...propDef
		};
	}
	return {
		name,
		...TYPE_DEFINITIONS[propDef.type],
		...propDef
	};
}
function isArray(value) {
	return Array.isArray(value) || ArrayBuffer.isView(value);
}
function getTypeOf(value) {
	if (isArray(value)) return "array";
	if (value === null) return "null";
	return typeof value;
}

//#endregion
//#region node_modules/@deck.gl/core/dist/lifecycle/create-props.js
function createProps(component, propObjects) {
	let extensions;
	for (let i$1 = propObjects.length - 1; i$1 >= 0; i$1--) {
		const props = propObjects[i$1];
		if ("extensions" in props) extensions = props.extensions;
	}
	const propsPrototype = getPropsPrototype(component.constructor, extensions);
	const propsInstance = Object.create(propsPrototype);
	propsInstance[COMPONENT_SYMBOL] = component;
	propsInstance[ASYNC_ORIGINAL_SYMBOL] = {};
	propsInstance[ASYNC_RESOLVED_SYMBOL] = {};
	for (let i$1 = 0; i$1 < propObjects.length; ++i$1) {
		const props = propObjects[i$1];
		for (const key in props) propsInstance[key] = props[key];
	}
	Object.freeze(propsInstance);
	return propsInstance;
}
var MergedDefaultPropsCacheKey = "_mergedDefaultProps";
function getPropsPrototype(componentClass, extensions) {
	if (!(componentClass instanceof component_default.constructor)) return {};
	let cacheKey = MergedDefaultPropsCacheKey;
	if (extensions) for (const extension of extensions) {
		const ExtensionClass = extension.constructor;
		if (ExtensionClass) cacheKey += `:${ExtensionClass.extensionName || ExtensionClass.name}`;
	}
	const defaultProps$16 = getOwnProperty(componentClass, cacheKey);
	if (!defaultProps$16) return componentClass[cacheKey] = createPropsPrototypeAndTypes(componentClass, extensions || []);
	return defaultProps$16;
}
function createPropsPrototypeAndTypes(componentClass, extensions) {
	if (!componentClass.prototype) return null;
	const parentDefaultProps = getPropsPrototype(Object.getPrototypeOf(componentClass));
	const componentPropDefs = parsePropTypes(getOwnProperty(componentClass, "defaultProps") || {});
	const defaultProps$16 = Object.assign(Object.create(null), parentDefaultProps, componentPropDefs.defaultProps);
	const propTypes = Object.assign(Object.create(null), parentDefaultProps?.[PROP_TYPES_SYMBOL], componentPropDefs.propTypes);
	const deprecatedProps = Object.assign(Object.create(null), parentDefaultProps?.[DEPRECATED_PROPS_SYMBOL], componentPropDefs.deprecatedProps);
	for (const extension of extensions) {
		const extensionDefaultProps = getPropsPrototype(extension.constructor);
		if (extensionDefaultProps) {
			Object.assign(defaultProps$16, extensionDefaultProps);
			Object.assign(propTypes, extensionDefaultProps[PROP_TYPES_SYMBOL]);
			Object.assign(deprecatedProps, extensionDefaultProps[DEPRECATED_PROPS_SYMBOL]);
		}
	}
	createPropsPrototype(defaultProps$16, componentClass);
	addAsyncPropsToPropPrototype(defaultProps$16, propTypes);
	addDeprecatedPropsToPropPrototype(defaultProps$16, deprecatedProps);
	defaultProps$16[PROP_TYPES_SYMBOL] = propTypes;
	defaultProps$16[DEPRECATED_PROPS_SYMBOL] = deprecatedProps;
	if (extensions.length === 0 && !hasOwnProperty(componentClass, "_propTypes")) componentClass._propTypes = propTypes;
	return defaultProps$16;
}
function createPropsPrototype(defaultProps$16, componentClass) {
	const id = getComponentName(componentClass);
	Object.defineProperties(defaultProps$16, { id: {
		writable: true,
		value: id
	} });
}
function addDeprecatedPropsToPropPrototype(defaultProps$16, deprecatedProps) {
	for (const propName in deprecatedProps) Object.defineProperty(defaultProps$16, propName, {
		enumerable: false,
		set(newValue) {
			const nameStr = `${this.id}: ${propName}`;
			for (const newPropName of deprecatedProps[propName]) if (!hasOwnProperty(this, newPropName)) this[newPropName] = newValue;
			log_default.deprecated(nameStr, deprecatedProps[propName].join("/"))();
		}
	});
}
function addAsyncPropsToPropPrototype(defaultProps$16, propTypes) {
	const defaultValues = {};
	const descriptors = {};
	for (const propName in propTypes) {
		const propType = propTypes[propName];
		const { name, value } = propType;
		if (propType.async) {
			defaultValues[name] = value;
			descriptors[name] = getDescriptorForAsyncProp(name);
		}
	}
	defaultProps$16[ASYNC_DEFAULTS_SYMBOL] = defaultValues;
	defaultProps$16[ASYNC_ORIGINAL_SYMBOL] = {};
	Object.defineProperties(defaultProps$16, descriptors);
}
function getDescriptorForAsyncProp(name) {
	return {
		enumerable: true,
		set(newValue) {
			if (typeof newValue === "string" || newValue instanceof Promise || isAsyncIterable(newValue)) this[ASYNC_ORIGINAL_SYMBOL][name] = newValue;
			else this[ASYNC_RESOLVED_SYMBOL][name] = newValue;
		},
		get() {
			if (this[ASYNC_RESOLVED_SYMBOL]) {
				if (name in this[ASYNC_RESOLVED_SYMBOL]) return this[ASYNC_RESOLVED_SYMBOL][name] || this[ASYNC_DEFAULTS_SYMBOL][name];
				if (name in this[ASYNC_ORIGINAL_SYMBOL]) {
					const state = this[COMPONENT_SYMBOL] && this[COMPONENT_SYMBOL].internalState;
					if (state && state.hasAsyncProp(name)) return state.getAsyncProp(name) || this[ASYNC_DEFAULTS_SYMBOL][name];
				}
			}
			return this[ASYNC_DEFAULTS_SYMBOL][name];
		}
	};
}
function hasOwnProperty(object, prop) {
	return Object.prototype.hasOwnProperty.call(object, prop);
}
function getOwnProperty(object, prop) {
	return hasOwnProperty(object, prop) && object[prop];
}
function getComponentName(componentClass) {
	const componentName = componentClass.componentName;
	if (!componentName) log_default.warn(`${componentClass.name}.componentName not specified`)();
	return componentName || componentClass.name;
}

//#endregion
//#region node_modules/@deck.gl/core/dist/lifecycle/component.js
var counter = 0;
var Component = class {
	constructor(...propObjects) {
		this.props = createProps(this, propObjects);
		this.id = this.props.id;
		this.count = counter++;
	}
	clone(newProps) {
		const { props } = this;
		const asyncProps = {};
		for (const key in props[ASYNC_DEFAULTS_SYMBOL]) if (key in props[ASYNC_RESOLVED_SYMBOL]) asyncProps[key] = props[ASYNC_RESOLVED_SYMBOL][key];
		else if (key in props[ASYNC_ORIGINAL_SYMBOL]) asyncProps[key] = props[ASYNC_ORIGINAL_SYMBOL][key];
		return new this.constructor({
			...props,
			...asyncProps,
			...newProps
		});
	}
};
Component.componentName = "Component";
Component.defaultProps = {};
var component_default = Component;

//#endregion
//#region node_modules/@deck.gl/core/dist/lifecycle/component-state.js
var EMPTY_PROPS = Object.freeze({});
var ComponentState = class {
	constructor(component) {
		this.component = component;
		this.asyncProps = {};
		this.onAsyncPropUpdated = () => {};
		this.oldProps = null;
		this.oldAsyncProps = null;
	}
	finalize() {
		for (const propName in this.asyncProps) {
			const asyncProp = this.asyncProps[propName];
			if (asyncProp && asyncProp.type && asyncProp.type.release) asyncProp.type.release(asyncProp.resolvedValue, asyncProp.type, this.component);
		}
		this.asyncProps = {};
		this.component = null;
		this.resetOldProps();
	}
	getOldProps() {
		return this.oldAsyncProps || this.oldProps || EMPTY_PROPS;
	}
	resetOldProps() {
		this.oldAsyncProps = null;
		this.oldProps = this.component ? this.component.props : null;
	}
	hasAsyncProp(propName) {
		return propName in this.asyncProps;
	}
	getAsyncProp(propName) {
		const asyncProp = this.asyncProps[propName];
		return asyncProp && asyncProp.resolvedValue;
	}
	isAsyncPropLoading(propName) {
		if (propName) {
			const asyncProp = this.asyncProps[propName];
			return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);
		}
		for (const key in this.asyncProps) if (this.isAsyncPropLoading(key)) return true;
		return false;
	}
	reloadAsyncProp(propName, value) {
		this._watchPromise(propName, Promise.resolve(value));
	}
	setAsyncProps(props) {
		this.component = props[COMPONENT_SYMBOL] || this.component;
		const resolvedValues = props[ASYNC_RESOLVED_SYMBOL] || {};
		const originalValues = props[ASYNC_ORIGINAL_SYMBOL] || props;
		const defaultValues = props[ASYNC_DEFAULTS_SYMBOL] || {};
		for (const propName in resolvedValues) {
			const value = resolvedValues[propName];
			this._createAsyncPropData(propName, defaultValues[propName]);
			this._updateAsyncProp(propName, value);
			resolvedValues[propName] = this.getAsyncProp(propName);
		}
		for (const propName in originalValues) {
			const value = originalValues[propName];
			this._createAsyncPropData(propName, defaultValues[propName]);
			this._updateAsyncProp(propName, value);
		}
	}
	_fetch(propName, url) {
		return null;
	}
	_onResolve(propName, value) {}
	_onError(propName, error) {}
	_updateAsyncProp(propName, value) {
		if (!this._didAsyncInputValueChange(propName, value)) return;
		if (typeof value === "string") value = this._fetch(propName, value);
		if (value instanceof Promise) {
			this._watchPromise(propName, value);
			return;
		}
		if (isAsyncIterable(value)) {
			this._resolveAsyncIterable(propName, value);
			return;
		}
		this._setPropValue(propName, value);
	}
	_freezeAsyncOldProps() {
		if (!this.oldAsyncProps && this.oldProps) {
			this.oldAsyncProps = Object.create(this.oldProps);
			for (const propName in this.asyncProps) Object.defineProperty(this.oldAsyncProps, propName, {
				enumerable: true,
				value: this.oldProps[propName]
			});
		}
	}
	_didAsyncInputValueChange(propName, value) {
		const asyncProp = this.asyncProps[propName];
		if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) return false;
		asyncProp.lastValue = value;
		return true;
	}
	_setPropValue(propName, value) {
		this._freezeAsyncOldProps();
		const asyncProp = this.asyncProps[propName];
		if (asyncProp) {
			value = this._postProcessValue(asyncProp, value);
			asyncProp.resolvedValue = value;
			asyncProp.pendingLoadCount++;
			asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;
		}
	}
	_setAsyncPropValue(propName, value, loadCount) {
		const asyncProp = this.asyncProps[propName];
		if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== void 0) {
			this._freezeAsyncOldProps();
			asyncProp.resolvedValue = value;
			asyncProp.resolvedLoadCount = loadCount;
			this.onAsyncPropUpdated(propName, value);
		}
	}
	_watchPromise(propName, promise) {
		const asyncProp = this.asyncProps[propName];
		if (asyncProp) {
			asyncProp.pendingLoadCount++;
			const loadCount = asyncProp.pendingLoadCount;
			promise.then((data) => {
				if (!this.component) return;
				data = this._postProcessValue(asyncProp, data);
				this._setAsyncPropValue(propName, data, loadCount);
				this._onResolve(propName, data);
			}).catch((error) => {
				this._onError(propName, error);
			});
		}
	}
	async _resolveAsyncIterable(propName, iterable) {
		if (propName !== "data") {
			this._setPropValue(propName, iterable);
			return;
		}
		const asyncProp = this.asyncProps[propName];
		if (!asyncProp) return;
		asyncProp.pendingLoadCount++;
		const loadCount = asyncProp.pendingLoadCount;
		let data = [];
		let count$1 = 0;
		for await (const chunk of iterable) {
			if (!this.component) return;
			const { dataTransform } = this.component.props;
			if (dataTransform) data = dataTransform(chunk, data);
			else data = data.concat(chunk);
			Object.defineProperty(data, "__diff", {
				enumerable: false,
				value: [{
					startRow: count$1,
					endRow: data.length
				}]
			});
			count$1 = data.length;
			this._setAsyncPropValue(propName, data, loadCount);
		}
		this._onResolve(propName, data);
	}
	_postProcessValue(asyncProp, value) {
		const propType = asyncProp.type;
		if (propType && this.component) {
			if (propType.release) propType.release(asyncProp.resolvedValue, propType, this.component);
			if (propType.transform) return propType.transform(value, propType, this.component);
		}
		return value;
	}
	_createAsyncPropData(propName, defaultValue) {
		if (!this.asyncProps[propName]) {
			const propTypes = this.component && this.component.props[PROP_TYPES_SYMBOL];
			this.asyncProps[propName] = {
				type: propTypes && propTypes[propName],
				lastValue: null,
				resolvedValue: defaultValue,
				pendingLoadCount: 0,
				resolvedLoadCount: 0
			};
		}
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/layer-state.js
var LayerState = class extends ComponentState {
	constructor({ attributeManager, layer }) {
		super(layer);
		this.attributeManager = attributeManager;
		this.needsRedraw = true;
		this.needsUpdate = true;
		this.subLayers = null;
		this.usesPickingColorCache = false;
	}
	get layer() {
		return this.component;
	}
	_fetch(propName, url) {
		const layer = this.layer;
		const fetch = layer?.props.fetch;
		if (fetch) return fetch(url, {
			propName,
			layer
		});
		return super._fetch(propName, url);
	}
	_onResolve(propName, value) {
		const layer = this.layer;
		if (layer) {
			const onDataLoad = layer.props.onDataLoad;
			if (propName === "data" && onDataLoad) onDataLoad(value, {
				propName,
				layer
			});
		}
	}
	_onError(propName, error) {
		const layer = this.layer;
		if (layer) layer.raiseError(error, `loading ${propName} of ${this.layer}`);
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/layer.js
var TRACE_CHANGE_FLAG = "layer.changeFlag";
var TRACE_INITIALIZE = "layer.initialize";
var TRACE_UPDATE = "layer.update";
var TRACE_FINALIZE = "layer.finalize";
var TRACE_MATCHED = "layer.matched";
var MAX_PICKING_COLOR_CACHE_SIZE = 2 ** 24 - 1;
var EMPTY_ARRAY$1 = Object.freeze([]);
var areViewportsEqual = memoize(({ oldViewport, viewport }) => {
	return oldViewport.equals(viewport);
});
var pickingColorCache = new Uint8ClampedArray(0);
var defaultProps$15 = {
	data: {
		type: "data",
		value: EMPTY_ARRAY$1,
		async: true
	},
	dataComparator: {
		type: "function",
		value: null,
		optional: true
	},
	_dataDiff: {
		type: "function",
		value: (data) => data && data.__diff,
		optional: true
	},
	dataTransform: {
		type: "function",
		value: null,
		optional: true
	},
	onDataLoad: {
		type: "function",
		value: null,
		optional: true
	},
	onError: {
		type: "function",
		value: null,
		optional: true
	},
	fetch: {
		type: "function",
		value: (url, { propName, layer, loaders, loadOptions, signal }) => {
			const { resourceManager } = layer.context;
			loadOptions = loadOptions || layer.getLoadOptions();
			loaders = loaders || layer.props.loaders;
			if (signal) loadOptions = {
				...loadOptions,
				fetch: {
					...loadOptions?.fetch,
					signal
				}
			};
			let inResourceManager = resourceManager.contains(url);
			if (!inResourceManager && !loadOptions) {
				resourceManager.add({
					resourceId: url,
					data: load(url, loaders),
					persistent: false
				});
				inResourceManager = true;
			}
			if (inResourceManager) return resourceManager.subscribe({
				resourceId: url,
				onChange: (data) => layer.internalState?.reloadAsyncProp(propName, data),
				consumerId: layer.id,
				requestId: propName
			});
			return load(url, loaders, loadOptions);
		}
	},
	updateTriggers: {},
	visible: true,
	pickable: false,
	opacity: {
		type: "number",
		min: 0,
		max: 1,
		value: 1
	},
	operation: "draw",
	onHover: {
		type: "function",
		value: null,
		optional: true
	},
	onClick: {
		type: "function",
		value: null,
		optional: true
	},
	onDragStart: {
		type: "function",
		value: null,
		optional: true
	},
	onDrag: {
		type: "function",
		value: null,
		optional: true
	},
	onDragEnd: {
		type: "function",
		value: null,
		optional: true
	},
	coordinateSystem: COORDINATE_SYSTEM.DEFAULT,
	coordinateOrigin: {
		type: "array",
		value: [
			0,
			0,
			0
		],
		compare: true
	},
	modelMatrix: {
		type: "array",
		value: null,
		compare: true,
		optional: true
	},
	wrapLongitude: false,
	positionFormat: "XYZ",
	colorFormat: "RGBA",
	parameters: {
		type: "object",
		value: {},
		optional: true,
		compare: 2
	},
	loadOptions: {
		type: "object",
		value: null,
		optional: true,
		ignore: true
	},
	transitions: null,
	extensions: [],
	loaders: {
		type: "array",
		value: [],
		optional: true,
		ignore: true
	},
	getPolygonOffset: {
		type: "function",
		value: ({ layerIndex }) => [0, -layerIndex * 100]
	},
	highlightedObjectIndex: null,
	autoHighlight: false,
	highlightColor: {
		type: "accessor",
		value: [
			0,
			0,
			128,
			128
		]
	}
};
var Layer = class extends component_default {
	constructor() {
		super(...arguments);
		this.internalState = null;
		this.lifecycle = LIFECYCLE.NO_STATE;
		this.parent = null;
	}
	static get componentName() {
		return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : "";
	}
	get root() {
		let layer = this;
		while (layer.parent) layer = layer.parent;
		return layer;
	}
	toString() {
		return `${this.constructor.layerName || this.constructor.name}({id: '${this.props.id}'})`;
	}
	/** Projects a point with current view state from the current layer's coordinate system to screen */
	project(xyz) {
		assert(this.internalState);
		const viewport = this.internalState.viewport || this.context.viewport;
		const [x$1, y$1, z$1] = worldToPixels(getWorldPosition(xyz, {
			viewport,
			modelMatrix: this.props.modelMatrix,
			coordinateOrigin: this.props.coordinateOrigin,
			coordinateSystem: this.props.coordinateSystem
		}), viewport.pixelProjectionMatrix);
		return xyz.length === 2 ? [x$1, y$1] : [
			x$1,
			y$1,
			z$1
		];
	}
	/** Unprojects a screen pixel to the current view's default coordinate system
	Note: this does not reverse `project`. */
	unproject(xy) {
		assert(this.internalState);
		return (this.internalState.viewport || this.context.viewport).unproject(xy);
	}
	/** Projects a point with current view state from the current layer's coordinate system to the world space */
	projectPosition(xyz, params) {
		assert(this.internalState);
		return projectPosition(xyz, {
			viewport: this.internalState.viewport || this.context.viewport,
			modelMatrix: this.props.modelMatrix,
			coordinateOrigin: this.props.coordinateOrigin,
			coordinateSystem: this.props.coordinateSystem,
			...params
		});
	}
	/** `true` if this layer renders other layers */
	get isComposite() {
		return false;
	}
	/** `true` if the layer renders to screen */
	get isDrawable() {
		return true;
	}
	/** Updates selected state members and marks the layer for redraw */
	setState(partialState) {
		this.setChangeFlags({ stateChanged: true });
		Object.assign(this.state, partialState);
		this.setNeedsRedraw();
	}
	/** Sets the redraw flag for this layer, will trigger a redraw next animation frame */
	setNeedsRedraw() {
		if (this.internalState) this.internalState.needsRedraw = true;
	}
	/** Mark this layer as needs a deep update */
	setNeedsUpdate() {
		if (this.internalState) {
			this.context.layerManager.setNeedsUpdate(String(this));
			this.internalState.needsUpdate = true;
		}
	}
	/** Returns true if all async resources are loaded */
	get isLoaded() {
		return this.internalState ? !this.internalState.isAsyncPropLoading() : false;
	}
	/** Returns true if using shader-based WGS84 longitude wrapping */
	get wrapLongitude() {
		return this.props.wrapLongitude;
	}
	/** @deprecated Returns true if the layer is visible in the picking pass */
	isPickable() {
		return this.props.pickable && this.props.visible;
	}
	/** Returns an array of models used by this layer, can be overriden by layer subclass */
	getModels() {
		const state = this.state;
		return state && (state.models || state.model && [state.model]) || [];
	}
	/** Update shader input parameters */
	setShaderModuleProps(...props) {
		for (const model of this.getModels()) model.shaderInputs.setProps(...props);
	}
	/** Returns the attribute manager of this layer */
	getAttributeManager() {
		return this.internalState && this.internalState.attributeManager;
	}
	/** Returns the most recent layer that matched to this state
	(When reacting to an async event, this layer may no longer be the latest) */
	getCurrentLayer() {
		return this.internalState && this.internalState.layer;
	}
	/** Returns the default parse options for async props */
	getLoadOptions() {
		return this.props.loadOptions;
	}
	use64bitPositions() {
		const { coordinateSystem } = this.props;
		return coordinateSystem === COORDINATE_SYSTEM.DEFAULT || coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN;
	}
	onHover(info, pickingEvent) {
		if (this.props.onHover) return this.props.onHover(info, pickingEvent) || false;
		return false;
	}
	onClick(info, pickingEvent) {
		if (this.props.onClick) return this.props.onClick(info, pickingEvent) || false;
		return false;
	}
	nullPickingColor() {
		return [
			0,
			0,
			0
		];
	}
	encodePickingColor(i$1, target = []) {
		target[0] = i$1 + 1 & 255;
		target[1] = i$1 + 1 >> 8 & 255;
		target[2] = i$1 + 1 >> 8 >> 8 & 255;
		return target;
	}
	decodePickingColor(color) {
		assert(color instanceof Uint8Array);
		const [i1, i2, i3] = color;
		return i1 + i2 * 256 + i3 * 65536 - 1;
	}
	/** Deduces number of instances. Intention is to support:
	- Explicit setting of numInstances
	- Auto-deduction for ES6 containers that define a size member
	- Auto-deduction for Classic Arrays via the built-in length attribute
	- Auto-deduction via arrays */
	getNumInstances() {
		if (Number.isFinite(this.props.numInstances)) return this.props.numInstances;
		if (this.state && this.state.numInstances !== void 0) return this.state.numInstances;
		return count(this.props.data);
	}
	/** Buffer layout describes how many attribute values are packed for each data object
	The default (null) is one value each object.
	Some data formats (e.g. paths, polygons) have various length. Their buffer layout
	is in the form of [L0, L1, L2, ...] */
	getStartIndices() {
		if (this.props.startIndices) return this.props.startIndices;
		if (this.state && this.state.startIndices) return this.state.startIndices;
		return null;
	}
	getBounds() {
		return this.getAttributeManager()?.getBounds(["positions", "instancePositions"]);
	}
	getShaders(shaders) {
		shaders = mergeShaders(shaders, {
			disableWarnings: true,
			modules: this.context.defaultShaderModules
		});
		for (const extension of this.props.extensions) shaders = mergeShaders(shaders, extension.getShaders.call(this, extension));
		return shaders;
	}
	/** Controls if updateState should be called. By default returns true if any prop has changed */
	shouldUpdateState(params) {
		return params.changeFlags.propsOrDataChanged;
	}
	/** Default implementation, all attributes will be invalidated and updated when data changes */
	updateState(params) {
		const attributeManager = this.getAttributeManager();
		const { dataChanged } = params.changeFlags;
		if (dataChanged && attributeManager) if (Array.isArray(dataChanged)) for (const dataRange of dataChanged) attributeManager.invalidateAll(dataRange);
		else attributeManager.invalidateAll();
		if (attributeManager) {
			const { props } = params;
			const hasPickingBuffer = this.internalState.hasPickingBuffer;
			const needsPickingBuffer = Number.isInteger(props.highlightedObjectIndex) || props.pickable || props.extensions.some((extension) => extension.getNeedsPickingBuffer.call(this, extension));
			if (hasPickingBuffer !== needsPickingBuffer) {
				this.internalState.hasPickingBuffer = needsPickingBuffer;
				const { pickingColors, instancePickingColors } = attributeManager.attributes;
				const pickingColorsAttribute = pickingColors || instancePickingColors;
				if (pickingColorsAttribute) {
					if (needsPickingBuffer && pickingColorsAttribute.constant) {
						pickingColorsAttribute.constant = false;
						attributeManager.invalidate(pickingColorsAttribute.id);
					}
					if (!pickingColorsAttribute.value && !needsPickingBuffer) {
						pickingColorsAttribute.constant = true;
						pickingColorsAttribute.value = [
							0,
							0,
							0
						];
					}
				}
			}
		}
	}
	/** Called once when layer is no longer matched and state will be discarded. Layers can destroy WebGL resources here. */
	finalizeState(context) {
		for (const model of this.getModels()) model.destroy();
		const attributeManager = this.getAttributeManager();
		if (attributeManager) attributeManager.finalize();
		if (this.context) this.context.resourceManager.unsubscribe({ consumerId: this.id });
		if (this.internalState) {
			this.internalState.uniformTransitions.clear();
			this.internalState.finalize();
		}
	}
	draw(opts) {
		for (const model of this.getModels()) model.draw(opts.renderPass);
	}
	getPickingInfo({ info, mode, sourceLayer }) {
		const { index } = info;
		if (index >= 0) {
			if (Array.isArray(this.props.data)) info.object = this.props.data[index];
		}
		return info;
	}
	/** (Internal) Propagate an error event through the system */
	raiseError(error, message) {
		if (message) error = new Error(`${message}: ${error.message}`, { cause: error });
		if (!this.props.onError?.(error)) this.context?.onError?.(error, this);
	}
	/** (Internal) Checks if this layer needs redraw */
	getNeedsRedraw(opts = { clearRedrawFlags: false }) {
		return this._getNeedsRedraw(opts);
	}
	/** (Internal) Checks if this layer needs a deep update */
	needsUpdate() {
		if (!this.internalState) return false;
		return this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams());
	}
	/** Checks if this layer has ongoing uniform transition */
	hasUniformTransition() {
		return this.internalState?.uniformTransitions.active || false;
	}
	/** Called when this layer is rendered into the given viewport */
	activateViewport(viewport) {
		if (!this.internalState) return;
		const oldViewport = this.internalState.viewport;
		this.internalState.viewport = viewport;
		if (!oldViewport || !areViewportsEqual({
			oldViewport,
			viewport
		})) {
			this.setChangeFlags({ viewportChanged: true });
			if (this.isComposite) {
				if (this.needsUpdate()) this.setNeedsUpdate();
			} else this._update();
		}
	}
	/** Default implementation of attribute invalidation, can be redefined */
	invalidateAttribute(name = "all") {
		const attributeManager = this.getAttributeManager();
		if (!attributeManager) return;
		if (name === "all") attributeManager.invalidateAll();
		else attributeManager.invalidate(name);
	}
	/** Send updated attributes to the WebGL model */
	updateAttributes(changedAttributes) {
		let bufferLayoutChanged = false;
		for (const id in changedAttributes) if (changedAttributes[id].layoutChanged()) bufferLayoutChanged = true;
		for (const model of this.getModels()) this._setModelAttributes(model, changedAttributes, bufferLayoutChanged);
	}
	/** Recalculate any attributes if needed */
	_updateAttributes() {
		const attributeManager = this.getAttributeManager();
		if (!attributeManager) return;
		const props = this.props;
		const numInstances = this.getNumInstances();
		const startIndices = this.getStartIndices();
		attributeManager.update({
			data: props.data,
			numInstances,
			startIndices,
			props,
			transitions: props.transitions,
			buffers: props.data.attributes,
			context: this
		});
		const changedAttributes = attributeManager.getChangedAttributes({ clearChangedFlags: true });
		this.updateAttributes(changedAttributes);
	}
	/** Update attribute transitions. This is called in drawLayer, no model updates required. */
	_updateAttributeTransition() {
		const attributeManager = this.getAttributeManager();
		if (attributeManager) attributeManager.updateTransition();
	}
	/** Update uniform (prop) transitions. This is called in updateState, may result in model updates. */
	_updateUniformTransition() {
		const { uniformTransitions } = this.internalState;
		if (uniformTransitions.active) {
			const propsInTransition = uniformTransitions.update();
			const props = Object.create(this.props);
			for (const key in propsInTransition) Object.defineProperty(props, key, { value: propsInTransition[key] });
			return props;
		}
		return this.props;
	}
	/** Updater for the automatically populated instancePickingColors attribute */
	calculateInstancePickingColors(attribute, { numInstances }) {
		if (attribute.constant) return;
		const cacheSize = Math.floor(pickingColorCache.length / 4);
		this.internalState.usesPickingColorCache = true;
		if (cacheSize < numInstances) {
			if (numInstances > MAX_PICKING_COLOR_CACHE_SIZE) log_default.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")();
			pickingColorCache = typed_array_manager_default.allocate(pickingColorCache, numInstances, {
				size: 4,
				copy: true,
				maxCount: Math.max(numInstances, MAX_PICKING_COLOR_CACHE_SIZE)
			});
			const newCacheSize = Math.floor(pickingColorCache.length / 4);
			const pickingColor = [
				0,
				0,
				0
			];
			for (let i$1 = cacheSize; i$1 < newCacheSize; i$1++) {
				this.encodePickingColor(i$1, pickingColor);
				pickingColorCache[i$1 * 4 + 0] = pickingColor[0];
				pickingColorCache[i$1 * 4 + 1] = pickingColor[1];
				pickingColorCache[i$1 * 4 + 2] = pickingColor[2];
				pickingColorCache[i$1 * 4 + 3] = 0;
			}
		}
		attribute.value = pickingColorCache.subarray(0, numInstances * 4);
	}
	/** Apply changed attributes to model */
	_setModelAttributes(model, changedAttributes, bufferLayoutChanged = false) {
		if (!Object.keys(changedAttributes).length) return;
		if (bufferLayoutChanged) {
			const attributeManager = this.getAttributeManager();
			model.setBufferLayout(attributeManager.getBufferLayouts(model));
			changedAttributes = attributeManager.getAttributes();
		}
		const excludeAttributes = model.userData?.excludeAttributes || {};
		const attributeBuffers = {};
		const constantAttributes = {};
		for (const name in changedAttributes) {
			if (excludeAttributes[name]) continue;
			const values = changedAttributes[name].getValue();
			for (const attributeName in values) {
				const value = values[attributeName];
				if (value instanceof Buffer) if (changedAttributes[name].settings.isIndexed) model.setIndexBuffer(value);
				else attributeBuffers[attributeName] = value;
				else if (value) constantAttributes[attributeName] = value;
			}
		}
		model.setAttributes(attributeBuffers);
		model.setConstantAttributes(constantAttributes);
	}
	/** (Internal) Sets the picking color at the specified index to null picking color. Used for multi-depth picking.
	This method may be overriden by layer implementations */
	disablePickingIndex(objectIndex) {
		const data = this.props.data;
		if (!("attributes" in data)) {
			this._disablePickingIndex(objectIndex);
			return;
		}
		const { pickingColors, instancePickingColors } = this.getAttributeManager().attributes;
		const colors = pickingColors || instancePickingColors;
		const externalColorAttribute = colors && data.attributes && data.attributes[colors.id];
		if (externalColorAttribute && externalColorAttribute.value) {
			const values = externalColorAttribute.value;
			const objectColor = this.encodePickingColor(objectIndex);
			for (let index = 0; index < data.length; index++) {
				const i$1 = colors.getVertexOffset(index);
				if (values[i$1] === objectColor[0] && values[i$1 + 1] === objectColor[1] && values[i$1 + 2] === objectColor[2]) this._disablePickingIndex(index);
			}
		} else this._disablePickingIndex(objectIndex);
	}
	_disablePickingIndex(objectIndex) {
		const { pickingColors, instancePickingColors } = this.getAttributeManager().attributes;
		const colors = pickingColors || instancePickingColors;
		if (!colors) return;
		const start = colors.getVertexOffset(objectIndex);
		const end = colors.getVertexOffset(objectIndex + 1);
		colors.buffer.write(new Uint8Array(end - start), start);
	}
	/** (Internal) Re-enable all picking indices after multi-depth picking */
	restorePickingColors() {
		const { pickingColors, instancePickingColors } = this.getAttributeManager().attributes;
		const colors = pickingColors || instancePickingColors;
		if (!colors) return;
		if (this.internalState.usesPickingColorCache && colors.value.buffer !== pickingColorCache.buffer) colors.value = pickingColorCache.subarray(0, colors.value.length);
		colors.updateSubBuffer({ startOffset: 0 });
	}
	_initialize() {
		assert(!this.internalState);
		assert(Number.isFinite(this.props.coordinateSystem));
		debug(TRACE_INITIALIZE, this);
		const attributeManager = this._getAttributeManager();
		if (attributeManager) attributeManager.addInstanced({ instancePickingColors: {
			type: "uint8",
			size: 4,
			noAlloc: true,
			update: this.calculateInstancePickingColors
		} });
		this.internalState = new LayerState({
			attributeManager,
			layer: this
		});
		this._clearChangeFlags();
		this.state = {};
		Object.defineProperty(this.state, "attributeManager", { get: () => {
			log_default.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")();
			return attributeManager;
		} });
		this.internalState.uniformTransitions = new UniformTransitionManager(this.context.timeline);
		this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);
		this.internalState.setAsyncProps(this.props);
		this.initializeState(this.context);
		for (const extension of this.props.extensions) extension.initializeState.call(this, this.context, extension);
		this.setChangeFlags({
			dataChanged: "init",
			propsChanged: "init",
			viewportChanged: true,
			extensionsChanged: true
		});
		this._update();
	}
	/** (Internal) Called by layer manager to transfer state from an old layer */
	_transferState(oldLayer) {
		debug(TRACE_MATCHED, this, this === oldLayer);
		const { state, internalState } = oldLayer;
		if (this === oldLayer) return;
		this.internalState = internalState;
		this.state = state;
		this.internalState.setAsyncProps(this.props);
		this._diffProps(this.props, this.internalState.getOldProps());
	}
	/** (Internal) Called by layer manager when a new layer is added or an existing layer is matched with a new instance */
	_update() {
		const stateNeedsUpdate = this.needsUpdate();
		debug(TRACE_UPDATE, this, stateNeedsUpdate);
		if (!stateNeedsUpdate) return;
		const currentProps = this.props;
		const context = this.context;
		const internalState = this.internalState;
		const currentViewport = context.viewport;
		const propsInTransition = this._updateUniformTransition();
		internalState.propsInTransition = propsInTransition;
		context.viewport = internalState.viewport || currentViewport;
		this.props = propsInTransition;
		try {
			const updateParams = this._getUpdateParams();
			const oldModels = this.getModels();
			if (context.device) this.updateState(updateParams);
			else try {
				this.updateState(updateParams);
			} catch (error) {}
			for (const extension of this.props.extensions) extension.updateState.call(this, updateParams, extension);
			this.setNeedsRedraw();
			this._updateAttributes();
			const modelChanged = this.getModels()[0] !== oldModels[0];
			this._postUpdate(updateParams, modelChanged);
		} finally {
			context.viewport = currentViewport;
			this.props = currentProps;
			this._clearChangeFlags();
			internalState.needsUpdate = false;
			internalState.resetOldProps();
		}
	}
	/** (Internal) Called by manager when layer is about to be disposed
	Note: not guaranteed to be called on application shutdown */
	_finalize() {
		debug(TRACE_FINALIZE, this);
		this.finalizeState(this.context);
		for (const extension of this.props.extensions) extension.finalizeState.call(this, this.context, extension);
	}
	_drawLayer({ renderPass, shaderModuleProps = null, uniforms = {}, parameters = {} }) {
		this._updateAttributeTransition();
		const currentProps = this.props;
		const context = this.context;
		this.props = this.internalState.propsInTransition || currentProps;
		try {
			if (shaderModuleProps) this.setShaderModuleProps(shaderModuleProps);
			const { getPolygonOffset } = this.props;
			const offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];
			if (context.device instanceof WebGLDevice) context.device.setParametersWebGL({ polygonOffset: offsets });
			for (const model of this.getModels()) if (model.device.type === "webgpu") model.setParameters({
				...model.parameters,
				...parameters
			});
			else model.setParameters(parameters);
			if (context.device instanceof WebGLDevice) context.device.withParametersWebGL(parameters, () => {
				const opts = {
					renderPass,
					shaderModuleProps,
					uniforms,
					parameters,
					context
				};
				for (const extension of this.props.extensions) extension.draw.call(this, opts, extension);
				this.draw(opts);
			});
			else {
				const opts = {
					renderPass,
					shaderModuleProps,
					uniforms,
					parameters,
					context
				};
				for (const extension of this.props.extensions) extension.draw.call(this, opts, extension);
				this.draw(opts);
			}
		} finally {
			this.props = currentProps;
		}
	}
	/** Returns the current change flags */
	getChangeFlags() {
		return this.internalState?.changeFlags;
	}
	/** Dirty some change flags, will be handled by updateLayer */
	setChangeFlags(flags) {
		if (!this.internalState) return;
		const { changeFlags } = this.internalState;
		for (const key in flags) if (flags[key]) {
			let flagChanged = false;
			switch (key) {
				case "dataChanged":
					const dataChangedReason = flags[key];
					const prevDataChangedReason = changeFlags[key];
					if (dataChangedReason && Array.isArray(prevDataChangedReason)) {
						changeFlags.dataChanged = Array.isArray(dataChangedReason) ? prevDataChangedReason.concat(dataChangedReason) : dataChangedReason;
						flagChanged = true;
					}
				default: if (!changeFlags[key]) {
					changeFlags[key] = flags[key];
					flagChanged = true;
				}
			}
			if (flagChanged) debug(TRACE_CHANGE_FLAG, this, key, flags);
		}
		const propsOrDataChanged = Boolean(changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.propsChanged || changeFlags.extensionsChanged);
		changeFlags.propsOrDataChanged = propsOrDataChanged;
		changeFlags.somethingChanged = propsOrDataChanged || changeFlags.viewportChanged || changeFlags.stateChanged;
	}
	/** Clear all changeFlags, typically after an update */
	_clearChangeFlags() {
		this.internalState.changeFlags = {
			dataChanged: false,
			propsChanged: false,
			updateTriggersChanged: false,
			viewportChanged: false,
			stateChanged: false,
			extensionsChanged: false,
			propsOrDataChanged: false,
			somethingChanged: false
		};
	}
	/** Compares the layers props with old props from a matched older layer
	and extracts change flags that describe what has change so that state
	can be update correctly with minimal effort */
	_diffProps(newProps, oldProps) {
		const changeFlags = diffProps(newProps, oldProps);
		if (changeFlags.updateTriggersChanged) {
			for (const key in changeFlags.updateTriggersChanged) if (changeFlags.updateTriggersChanged[key]) this.invalidateAttribute(key);
		}
		if (changeFlags.transitionsChanged) for (const key in changeFlags.transitionsChanged) this.internalState.uniformTransitions.add(key, oldProps[key], newProps[key], newProps.transitions?.[key]);
		return this.setChangeFlags(changeFlags);
	}
	/** (Internal) called by layer manager to perform extra props validation (in development only) */
	validateProps() {
		validateProps(this.props);
	}
	/** (Internal) Called by deck picker when the hovered object changes to update the auto highlight */
	updateAutoHighlight(info) {
		if (this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex)) this._updateAutoHighlight(info);
	}
	/** Update picking module parameters to highlight the hovered object */
	_updateAutoHighlight(info) {
		const picking = { highlightedObjectColor: info.picked ? info.color : null };
		const { highlightColor } = this.props;
		if (info.picked && typeof highlightColor === "function") picking.highlightColor = highlightColor(info);
		this.setShaderModuleProps({ picking });
		this.setNeedsRedraw();
	}
	/** Create new attribute manager */
	_getAttributeManager() {
		const context = this.context;
		return new AttributeManager(context.device, {
			id: this.props.id,
			stats: context.stats,
			timeline: context.timeline
		});
	}
	/** Called after updateState to perform common tasks */
	_postUpdate(updateParams, forceUpdate) {
		const { props, oldProps } = updateParams;
		const model = this.state.model;
		if (model?.isInstanced) model.setInstanceCount(this.getNumInstances());
		const { autoHighlight, highlightedObjectIndex, highlightColor } = props;
		if (forceUpdate || oldProps.autoHighlight !== autoHighlight || oldProps.highlightedObjectIndex !== highlightedObjectIndex || oldProps.highlightColor !== highlightColor) {
			const picking = {};
			if (Array.isArray(highlightColor)) picking.highlightColor = highlightColor;
			if (forceUpdate || oldProps.autoHighlight !== autoHighlight || highlightedObjectIndex !== oldProps.highlightedObjectIndex) picking.highlightedObjectColor = Number.isFinite(highlightedObjectIndex) && highlightedObjectIndex >= 0 ? this.encodePickingColor(highlightedObjectIndex) : null;
			this.setShaderModuleProps({ picking });
		}
	}
	_getUpdateParams() {
		return {
			props: this.props,
			oldProps: this.internalState.getOldProps(),
			context: this.context,
			changeFlags: this.internalState.changeFlags
		};
	}
	/** Checks state of attributes and model */
	_getNeedsRedraw(opts) {
		if (!this.internalState) return false;
		let redraw = false;
		redraw = redraw || this.internalState.needsRedraw && this.id;
		const attributeManager = this.getAttributeManager();
		const attributeManagerNeedsRedraw = attributeManager ? attributeManager.getNeedsRedraw(opts) : false;
		redraw = redraw || attributeManagerNeedsRedraw;
		if (redraw) for (const extension of this.props.extensions) extension.onNeedsRedraw.call(this, extension);
		this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;
		return redraw;
	}
	/** Callback when asyn prop is loaded */
	_onAsyncPropUpdated() {
		this._diffProps(this.props, this.internalState.getOldProps());
		this.setNeedsUpdate();
	}
};
Layer.defaultProps = defaultProps$15;
Layer.layerName = "Layer";
var layer_default = Layer;

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/composite-layer.js
var TRACE_RENDER_LAYERS = "compositeLayer.renderLayers";
var CompositeLayer = class extends layer_default {
	/** `true` if this layer renders other layers */
	get isComposite() {
		return true;
	}
	/** `true` if the layer renders to screen */
	get isDrawable() {
		return false;
	}
	/** Returns true if all async resources are loaded */
	get isLoaded() {
		return super.isLoaded && this.getSubLayers().every((layer) => layer.isLoaded);
	}
	/** Return last rendered sub layers */
	getSubLayers() {
		return this.internalState && this.internalState.subLayers || [];
	}
	initializeState(context) {}
	/** Updates selected state members and marks the composite layer to need rerender */
	setState(updateObject) {
		super.setState(updateObject);
		this.setNeedsUpdate();
	}
	/** called to augment the info object that is bubbled up from a sublayer
	override Layer.getPickingInfo() because decoding / setting uniform do
	not apply to a composite layer. */
	getPickingInfo({ info }) {
		const { object } = info;
		if (!(object && object.__source && object.__source.parent && object.__source.parent.id === this.id)) return info;
		info.object = object.__source.object;
		info.index = object.__source.index;
		return info;
	}
	/**
	* Filters sub layers at draw time. Return true if the sub layer should be drawn.
	*/
	filterSubLayer(context) {
		return true;
	}
	/** Returns true if sub layer needs to be rendered */
	shouldRenderSubLayer(subLayerId, data) {
		return data && data.length;
	}
	/** Returns sub layer class for a specific sublayer */
	getSubLayerClass(subLayerId, DefaultLayerClass) {
		const { _subLayerProps: overridingProps } = this.props;
		return overridingProps && overridingProps[subLayerId] && overridingProps[subLayerId].type || DefaultLayerClass;
	}
	/** When casting user data into another format to pass to sublayers,
	add reference to the original object and object index */
	getSubLayerRow(row, sourceObject, sourceObjectIndex) {
		row.__source = {
			parent: this,
			object: sourceObject,
			index: sourceObjectIndex
		};
		return row;
	}
	/** Some composite layers cast user data into another format before passing to sublayers
	We need to unwrap them before calling the accessor so that they see the original data
	objects */
	getSubLayerAccessor(accessor) {
		if (typeof accessor === "function") {
			const objectInfo = {
				index: -1,
				data: this.props.data,
				target: []
			};
			return (x$1, i$1) => {
				if (x$1 && x$1.__source) {
					objectInfo.index = x$1.__source.index;
					return accessor(x$1.__source.object, objectInfo);
				}
				return accessor(x$1, i$1);
			};
		}
		return accessor;
	}
	/** Returns sub layer props for a specific sublayer */
	getSubLayerProps(sublayerProps = {}) {
		const { opacity, pickable, visible, parameters, getPolygonOffset, highlightedObjectIndex, autoHighlight, highlightColor, coordinateSystem, coordinateOrigin, wrapLongitude, positionFormat, modelMatrix, extensions, fetch, operation, _subLayerProps: overridingProps } = this.props;
		const newProps = {
			id: "",
			updateTriggers: {},
			opacity,
			pickable,
			visible,
			parameters,
			getPolygonOffset,
			highlightedObjectIndex,
			autoHighlight,
			highlightColor,
			coordinateSystem,
			coordinateOrigin,
			wrapLongitude,
			positionFormat,
			modelMatrix,
			extensions,
			fetch,
			operation
		};
		const overridingSublayerProps = overridingProps && sublayerProps.id && overridingProps[sublayerProps.id];
		const overridingSublayerTriggers = overridingSublayerProps && overridingSublayerProps.updateTriggers;
		const sublayerId = sublayerProps.id || "sublayer";
		if (overridingSublayerProps) {
			const propTypes = this.props[PROP_TYPES_SYMBOL];
			const subLayerPropTypes = sublayerProps.type ? sublayerProps.type._propTypes : {};
			for (const key in overridingSublayerProps) {
				const propType = subLayerPropTypes[key] || propTypes[key];
				if (propType && propType.type === "accessor") overridingSublayerProps[key] = this.getSubLayerAccessor(overridingSublayerProps[key]);
			}
		}
		Object.assign(newProps, sublayerProps, overridingSublayerProps);
		newProps.id = `${this.props.id}-${sublayerId}`;
		newProps.updateTriggers = {
			all: this.props.updateTriggers?.all,
			...sublayerProps.updateTriggers,
			...overridingSublayerTriggers
		};
		for (const extension of extensions) {
			const passThroughProps = extension.getSubLayerProps.call(this, extension);
			if (passThroughProps) Object.assign(newProps, passThroughProps, { updateTriggers: Object.assign(newProps.updateTriggers, passThroughProps.updateTriggers) });
		}
		return newProps;
	}
	/** Update sub layers to highlight the hovered object */
	_updateAutoHighlight(info) {
		for (const layer of this.getSubLayers()) layer.updateAutoHighlight(info);
	}
	/** Override base Layer method */
	_getAttributeManager() {
		return null;
	}
	/** (Internal) Called after an update to rerender sub layers */
	_postUpdate(updateParams, forceUpdate) {
		let subLayers = this.internalState.subLayers;
		const shouldUpdate = !subLayers || this.needsUpdate();
		if (shouldUpdate) {
			subLayers = flatten(this.renderLayers(), Boolean);
			this.internalState.subLayers = subLayers;
		}
		debug(TRACE_RENDER_LAYERS, this, shouldUpdate, subLayers);
		for (const layer of subLayers) layer.parent = this;
	}
};
CompositeLayer.layerName = "CompositeLayer";
var composite_layer_default = CompositeLayer;

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/tesselator.js
var Tesselator = class {
	constructor(opts) {
		this.indexStarts = [0];
		this.vertexStarts = [0];
		this.vertexCount = 0;
		this.instanceCount = 0;
		const { attributes = {} } = opts;
		this.typedArrayManager = typed_array_manager_default;
		this.attributes = {};
		this._attributeDefs = attributes;
		this.opts = opts;
		this.updateGeometry(opts);
	}
	updateGeometry(opts) {
		Object.assign(this.opts, opts);
		const { data, buffers = {}, getGeometry, geometryBuffer, positionFormat, dataChanged, normalize: normalize$1 = true } = this.opts;
		this.data = data;
		this.getGeometry = getGeometry;
		this.positionSize = geometryBuffer && geometryBuffer.size || (positionFormat === "XY" ? 2 : 3);
		this.buffers = buffers;
		this.normalize = normalize$1;
		if (geometryBuffer) {
			assert(data.startIndices);
			this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);
			if (!normalize$1) buffers.vertexPositions = geometryBuffer;
		}
		this.geometryBuffer = buffers.vertexPositions;
		if (Array.isArray(dataChanged)) for (const dataRange of dataChanged) this._rebuildGeometry(dataRange);
		else this._rebuildGeometry();
	}
	updatePartialGeometry({ startRow, endRow }) {
		this._rebuildGeometry({
			startRow,
			endRow
		});
	}
	getGeometryFromBuffer(geometryBuffer) {
		const value = geometryBuffer.value || geometryBuffer;
		if (!ArrayBuffer.isView(value)) return null;
		return getAccessorFromBuffer(value, {
			size: this.positionSize,
			offset: geometryBuffer.offset,
			stride: geometryBuffer.stride,
			startIndices: this.data.startIndices
		});
	}
	_allocate(instanceCount, copy$1) {
		const { attributes, buffers, _attributeDefs, typedArrayManager } = this;
		for (const name in _attributeDefs) if (name in buffers) {
			typedArrayManager.release(attributes[name]);
			attributes[name] = null;
		} else {
			const def = _attributeDefs[name];
			def.copy = copy$1;
			attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);
		}
	}
	/**
	* Visit all objects
	* `data` is expected to be an iterable consistent with the base Layer expectation
	*/
	_forEachGeometry(visitor, startRow, endRow) {
		const { data, getGeometry } = this;
		const { iterable, objectInfo } = createIterable(data, startRow, endRow);
		for (const object of iterable) {
			objectInfo.index++;
			visitor(getGeometry ? getGeometry(object, objectInfo) : null, objectInfo.index);
		}
	}
	_rebuildGeometry(dataRange) {
		if (!this.data) return;
		let { indexStarts, vertexStarts, instanceCount } = this;
		const { data, geometryBuffer } = this;
		const { startRow = 0, endRow = Infinity } = dataRange || {};
		const normalizedData = {};
		if (!dataRange) {
			indexStarts = [0];
			vertexStarts = [0];
		}
		if (this.normalize || !geometryBuffer) {
			this._forEachGeometry((geometry, dataIndex) => {
				const normalizedGeometry = geometry && this.normalizeGeometry(geometry);
				normalizedData[dataIndex] = normalizedGeometry;
				vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);
			}, startRow, endRow);
			instanceCount = vertexStarts[vertexStarts.length - 1];
		} else {
			vertexStarts = data.startIndices;
			instanceCount = vertexStarts[data.length] || 0;
			if (ArrayBuffer.isView(geometryBuffer)) instanceCount = instanceCount || geometryBuffer.length / this.positionSize;
			else if (geometryBuffer instanceof Buffer) {
				const byteStride = this.positionSize * 4;
				instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;
			} else if (geometryBuffer.buffer) {
				const byteStride = geometryBuffer.stride || this.positionSize * 4;
				instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;
			} else if (geometryBuffer.value) {
				const bufferValue = geometryBuffer.value;
				const elementStride = geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;
				instanceCount = instanceCount || bufferValue.length / elementStride;
			}
		}
		this._allocate(instanceCount, Boolean(dataRange));
		this.indexStarts = indexStarts;
		this.vertexStarts = vertexStarts;
		this.instanceCount = instanceCount;
		const context = {};
		this._forEachGeometry((geometry, dataIndex) => {
			const normalizedGeometry = normalizedData[dataIndex] || geometry;
			context.vertexStart = vertexStarts[dataIndex];
			context.indexStart = indexStarts[dataIndex];
			context.geometrySize = (dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount) - vertexStarts[dataIndex];
			context.geometryIndex = dataIndex;
			this.updateGeometryAttributes(normalizedGeometry, context);
		}, startRow, endRow);
		this.vertexCount = indexStarts[indexStarts.length - 1];
	}
};

//#endregion
//#region node_modules/@deck.gl/layers/dist/arc-layer/arc-layer-uniforms.js
var uniformBlock$7 = `\
uniform arcUniforms {
  bool greatCircle;
  bool useShortestPath;
  float numSegments;
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  highp int widthUnits;
} arc;
`;
const arcUniforms = {
	name: "arc",
	vs: uniformBlock$7,
	fs: uniformBlock$7,
	uniformTypes: {
		greatCircle: "f32",
		useShortestPath: "f32",
		numSegments: "f32",
		widthScale: "f32",
		widthMinPixels: "f32",
		widthMaxPixels: "f32",
		widthUnits: "i32"
	}
};

//#endregion
//#region node_modules/@deck.gl/layers/dist/arc-layer/arc-layer-vertex.glsl.js
var arc_layer_vertex_glsl_default = `\
#version 300 es
#define SHADER_NAME arc-layer-vertex-shader
in vec4 instanceSourceColors;
in vec4 instanceTargetColors;
in vec3 instanceSourcePositions;
in vec3 instanceSourcePositions64Low;
in vec3 instanceTargetPositions;
in vec3 instanceTargetPositions64Low;
in vec3 instancePickingColors;
in float instanceWidths;
in float instanceHeights;
in float instanceTilts;
out vec4 vColor;
out vec2 uv;
out float isValid;
float paraboloid(float distance, float sourceZ, float targetZ, float ratio) {
float deltaZ = targetZ - sourceZ;
float dh = distance * instanceHeights;
if (dh == 0.0) {
return sourceZ + deltaZ * ratio;
}
float unitZ = deltaZ / dh;
float p2 = unitZ * unitZ + 1.0;
float dir = step(deltaZ, 0.0);
float z0 = mix(sourceZ, targetZ, dir);
float r = mix(ratio, 1.0 - ratio, dir);
return sqrt(r * (p2 - r)) * dh + z0;
}
vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {
vec2 dir_screenspace = normalize(line_clipspace * project.viewportSize);
dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);
return dir_screenspace * offset_direction * width / 2.0;
}
float getSegmentRatio(float index) {
return smoothstep(0.0, 1.0, index / (arc.numSegments - 1.0));
}
vec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {
float distance = length(source.xy - target.xy);
float z = paraboloid(distance, source.z, target.z, segmentRatio);
float tiltAngle = radians(instanceTilts);
vec2 tiltDirection = normalize(target.xy - source.xy);
vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);
return vec3(
mix(source.xy, target.xy, segmentRatio) + tilt,
z * cos(tiltAngle)
);
}
float getAngularDist (vec2 source, vec2 target) {
vec2 sourceRadians = radians(source);
vec2 targetRadians = radians(target);
vec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);
vec2 shd_sq = sin_half_delta * sin_half_delta;
float a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;
return 2.0 * asin(sqrt(a));
}
vec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {
vec2 lngLat;
if(abs(angularDist - PI) < 0.001) {
lngLat = (1.0 - t) * source.xy + t * target.xy;
} else {
float a = sin((1.0 - t) * angularDist);
float b = sin(t * angularDist);
vec3 p = source3D.yxz * a + target3D.yxz * b;
lngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));
}
float z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);
return vec3(lngLat, z);
}
void main(void) {
geometry.worldPosition = instanceSourcePositions;
geometry.worldPositionAlt = instanceTargetPositions;
float segmentIndex = float(gl_VertexID / 2);
float segmentSide = mod(float(gl_VertexID), 2.) == 0. ? -1. : 1.;
float segmentRatio = getSegmentRatio(segmentIndex);
float prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));
float nextSegmentRatio = getSegmentRatio(min(arc.numSegments - 1.0, segmentIndex + 1.0));
float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));
isValid = 1.0;
uv = vec2(segmentRatio, segmentSide);
geometry.uv = uv;
geometry.pickingColor = instancePickingColors;
vec4 curr;
vec4 next;
vec3 source;
vec3 target;
if ((arc.greatCircle || project.projectionMode == PROJECTION_MODE_GLOBE) && project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
source = project_globe_(vec3(instanceSourcePositions.xy, 0.0));
target = project_globe_(vec3(instanceTargetPositions.xy, 0.0));
float angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);
vec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);
vec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);
vec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);
if (abs(currPos.x - prevPos.x) > 180.0) {
indexDir = -1.0;
isValid = 0.0;
} else if (abs(currPos.x - nextPos.x) > 180.0) {
indexDir = 1.0;
isValid = 0.0;
}
nextPos = indexDir < 0.0 ? prevPos : nextPos;
nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;
if (isValid == 0.0) {
nextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;
float t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);
currPos = mix(currPos, nextPos, t);
segmentRatio = mix(segmentRatio, nextSegmentRatio, t);
}
vec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);
vec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);
curr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);
next = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));
} else {
vec3 source_world = instanceSourcePositions;
vec3 target_world = instanceTargetPositions;
if (arc.useShortestPath) {
source_world.x = mod(source_world.x + 180., 360.0) - 180.;
target_world.x = mod(target_world.x + 180., 360.0) - 180.;
float deltaLng = target_world.x - source_world.x;
if (deltaLng > 180.) target_world.x -= 360.;
if (deltaLng < -180.) source_world.x -= 360.;
}
source = project_position(source_world, instanceSourcePositions64Low);
target = project_position(target_world, instanceTargetPositions64Low);
float antiMeridianX = 0.0;
if (arc.useShortestPath) {
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
antiMeridianX = -(project.coordinateOrigin.x + 180.) / 360. * TILE_SIZE;
}
float thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);
if (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {
isValid = 0.0;
indexDir = sign(segmentRatio - thresholdRatio);
segmentRatio = thresholdRatio;
}
}
nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;
vec3 currPos = interpolateFlat(source, target, segmentRatio);
vec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);
if (arc.useShortestPath) {
if (nextPos.x < antiMeridianX) {
currPos.x += TILE_SIZE;
nextPos.x += TILE_SIZE;
}
}
curr = project_common_position_to_clipspace(vec4(currPos, 1.0));
next = project_common_position_to_clipspace(vec4(nextPos, 1.0));
geometry.position = vec4(currPos, 1.0);
}
float widthPixels = clamp(
project_size_to_pixel(instanceWidths * arc.widthScale, arc.widthUnits),
arc.widthMinPixels, arc.widthMaxPixels
);
vec3 offset = vec3(
getExtrusionOffset((next.xy - curr.xy) * indexDir, segmentSide, widthPixels),
0.0);
DECKGL_FILTER_SIZE(offset, geometry);
DECKGL_FILTER_GL_POSITION(curr, geometry);
gl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);
vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);
vColor = vec4(color.rgb, color.a * layer.opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

//#endregion
//#region node_modules/@deck.gl/layers/dist/arc-layer/arc-layer-fragment.glsl.js
var arc_layer_fragment_glsl_default = `\
#version 300 es
#define SHADER_NAME arc-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 uv;
in float isValid;
out vec4 fragColor;
void main(void) {
if (isValid == 0.0) {
discard;
}
fragColor = vColor;
geometry.uv = uv;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

//#endregion
//#region node_modules/@deck.gl/layers/dist/arc-layer/arc-layer.js
var DEFAULT_COLOR$7 = [
	0,
	0,
	0,
	255
];
var defaultProps$14 = {
	getSourcePosition: {
		type: "accessor",
		value: (x$1) => x$1.sourcePosition
	},
	getTargetPosition: {
		type: "accessor",
		value: (x$1) => x$1.targetPosition
	},
	getSourceColor: {
		type: "accessor",
		value: DEFAULT_COLOR$7
	},
	getTargetColor: {
		type: "accessor",
		value: DEFAULT_COLOR$7
	},
	getWidth: {
		type: "accessor",
		value: 1
	},
	getHeight: {
		type: "accessor",
		value: 1
	},
	getTilt: {
		type: "accessor",
		value: 0
	},
	greatCircle: false,
	numSegments: {
		type: "number",
		value: 50,
		min: 1
	},
	widthUnits: "pixels",
	widthScale: {
		type: "number",
		value: 1,
		min: 0
	},
	widthMinPixels: {
		type: "number",
		value: 0,
		min: 0
	},
	widthMaxPixels: {
		type: "number",
		value: Number.MAX_SAFE_INTEGER,
		min: 0
	}
};
/** Render raised arcs joining pairs of source and target coordinates. */
var ArcLayer = class extends layer_default {
	getBounds() {
		return this.getAttributeManager()?.getBounds(["instanceSourcePositions", "instanceTargetPositions"]);
	}
	getShaders() {
		return super.getShaders({
			vs: arc_layer_vertex_glsl_default,
			fs: arc_layer_fragment_glsl_default,
			modules: [
				project32_default,
				picking_default,
				arcUniforms
			]
		});
	}
	get wrapLongitude() {
		return false;
	}
	initializeState() {
		this.getAttributeManager().addInstanced({
			instanceSourcePositions: {
				size: 3,
				type: "float64",
				fp64: this.use64bitPositions(),
				transition: true,
				accessor: "getSourcePosition"
			},
			instanceTargetPositions: {
				size: 3,
				type: "float64",
				fp64: this.use64bitPositions(),
				transition: true,
				accessor: "getTargetPosition"
			},
			instanceSourceColors: {
				size: this.props.colorFormat.length,
				type: "unorm8",
				transition: true,
				accessor: "getSourceColor",
				defaultValue: DEFAULT_COLOR$7
			},
			instanceTargetColors: {
				size: this.props.colorFormat.length,
				type: "unorm8",
				transition: true,
				accessor: "getTargetColor",
				defaultValue: DEFAULT_COLOR$7
			},
			instanceWidths: {
				size: 1,
				transition: true,
				accessor: "getWidth",
				defaultValue: 1
			},
			instanceHeights: {
				size: 1,
				transition: true,
				accessor: "getHeight",
				defaultValue: 1
			},
			instanceTilts: {
				size: 1,
				transition: true,
				accessor: "getTilt",
				defaultValue: 0
			}
		});
	}
	updateState(params) {
		super.updateState(params);
		if (params.changeFlags.extensionsChanged) {
			this.state.model?.destroy();
			this.state.model = this._getModel();
			this.getAttributeManager().invalidateAll();
		}
	}
	draw({ uniforms }) {
		const { widthUnits, widthScale, widthMinPixels, widthMaxPixels, greatCircle, wrapLongitude, numSegments } = this.props;
		const arcProps = {
			numSegments,
			widthUnits: UNIT[widthUnits],
			widthScale,
			widthMinPixels,
			widthMaxPixels,
			greatCircle,
			useShortestPath: wrapLongitude
		};
		const model = this.state.model;
		model.shaderInputs.setProps({ arc: arcProps });
		model.setVertexCount(numSegments * 2);
		model.draw(this.context.renderPass);
	}
	_getModel() {
		return new Model(this.context.device, {
			...this.getShaders(),
			id: this.props.id,
			bufferLayout: this.getAttributeManager().getBufferLayouts(),
			topology: "triangle-strip",
			isInstanced: true
		});
	}
};
ArcLayer.layerName = "ArcLayer";
ArcLayer.defaultProps = defaultProps$14;
var arc_layer_default = ArcLayer;

//#endregion
//#region node_modules/@deck.gl/layers/dist/bitmap-layer/create-mesh.js
var DEFAULT_INDICES = new Uint32Array([
	0,
	2,
	1,
	0,
	3,
	2
]);
var DEFAULT_TEX_COORDS = new Float32Array([
	0,
	1,
	0,
	0,
	1,
	0,
	1,
	1
]);
function createMesh(bounds, resolution) {
	if (!resolution) return createQuad(bounds);
	const maxXSpan = Math.max(Math.abs(bounds[0][0] - bounds[3][0]), Math.abs(bounds[1][0] - bounds[2][0]));
	const maxYSpan = Math.max(Math.abs(bounds[1][1] - bounds[0][1]), Math.abs(bounds[2][1] - bounds[3][1]));
	const uCount = Math.ceil(maxXSpan / resolution) + 1;
	const vCount = Math.ceil(maxYSpan / resolution) + 1;
	const vertexCount = (uCount - 1) * (vCount - 1) * 6;
	const indices = new Uint32Array(vertexCount);
	const texCoords = new Float32Array(uCount * vCount * 2);
	const positions = new Float64Array(uCount * vCount * 3);
	let vertex = 0;
	let index = 0;
	for (let u$1 = 0; u$1 < uCount; u$1++) {
		const ut$1 = u$1 / (uCount - 1);
		for (let v$1 = 0; v$1 < vCount; v$1++) {
			const vt = v$1 / (vCount - 1);
			const p$1 = interpolateQuad(bounds, ut$1, vt);
			positions[vertex * 3 + 0] = p$1[0];
			positions[vertex * 3 + 1] = p$1[1];
			positions[vertex * 3 + 2] = p$1[2] || 0;
			texCoords[vertex * 2 + 0] = ut$1;
			texCoords[vertex * 2 + 1] = 1 - vt;
			if (u$1 > 0 && v$1 > 0) {
				indices[index++] = vertex - vCount;
				indices[index++] = vertex - vCount - 1;
				indices[index++] = vertex - 1;
				indices[index++] = vertex - vCount;
				indices[index++] = vertex - 1;
				indices[index++] = vertex;
			}
			vertex++;
		}
	}
	return {
		vertexCount,
		positions,
		indices,
		texCoords
	};
}
function createQuad(bounds) {
	const positions = new Float64Array(12);
	for (let i$1 = 0; i$1 < bounds.length; i$1++) {
		positions[i$1 * 3 + 0] = bounds[i$1][0];
		positions[i$1 * 3 + 1] = bounds[i$1][1];
		positions[i$1 * 3 + 2] = bounds[i$1][2] || 0;
	}
	return {
		vertexCount: 6,
		positions,
		indices: DEFAULT_INDICES,
		texCoords: DEFAULT_TEX_COORDS
	};
}
function interpolateQuad(quad, ut$1, vt) {
	return lerp(lerp(quad[0], quad[1], vt), lerp(quad[3], quad[2], vt), ut$1);
}

//#endregion
//#region node_modules/@deck.gl/layers/dist/bitmap-layer/bitmap-layer-uniforms.js
var uniformBlock$6 = `\
uniform bitmapUniforms {
  vec4 bounds;
  float coordinateConversion;
  float desaturate;
  vec3 tintColor;
  vec4 transparentColor;
} bitmap;
`;
const bitmapUniforms = {
	name: "bitmap",
	vs: uniformBlock$6,
	fs: uniformBlock$6,
	uniformTypes: {
		bounds: "vec4<f32>",
		coordinateConversion: "f32",
		desaturate: "f32",
		tintColor: "vec3<f32>",
		transparentColor: "vec4<f32>"
	}
};

//#endregion
//#region node_modules/@deck.gl/layers/dist/bitmap-layer/bitmap-layer-vertex.js
var bitmap_layer_vertex_default = `\
#version 300 es
#define SHADER_NAME bitmap-layer-vertex-shader

in vec2 texCoords;
in vec3 positions;
in vec3 positions64Low;

out vec2 vTexCoord;
out vec2 vTexPos;

const vec3 pickingColor = vec3(1.0, 0.0, 0.0);

void main(void) {
  geometry.worldPosition = positions;
  geometry.uv = texCoords;
  geometry.pickingColor = pickingColor;

  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  vTexCoord = texCoords;

  if (bitmap.coordinateConversion < -0.5) {
    vTexPos = geometry.position.xy + project.commonOrigin.xy;
  } else if (bitmap.coordinateConversion > 0.5) {
    vTexPos = geometry.worldPosition.xy;
  }

  vec4 color = vec4(0.0);
  DECKGL_FILTER_COLOR(color, geometry);
}
`;

//#endregion
//#region node_modules/@deck.gl/layers/dist/bitmap-layer/bitmap-layer-fragment.js
/**
* Pack the top 12 bits of two normalized floats into 3 8-bit (rgb) values
* This enables addressing 4096x4096 individual pixels
*
* returns vec3 encoded RGB colors
*  result.r - top 8 bits of u
*  result.g - top 8 bits of v
*  result.b - next 4 bits of u and v: (u + v * 16)
*/
var packUVsIntoRGB = `
vec3 packUVsIntoRGB(vec2 uv) {
  // Extract the top 8 bits. We want values to be truncated down so we can add a fraction
  vec2 uv8bit = floor(uv * 256.);

  // Calculate the normalized remainders of u and v parts that do not fit into 8 bits
  // Scale and clamp to 0-1 range
  vec2 uvFraction = fract(uv * 256.);
  vec2 uvFraction4bit = floor(uvFraction * 16.);

  // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates
  float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;

  return vec3(uv8bit, fractions) / 255.;
}
`;
var bitmap_layer_fragment_default = `\
#version 300 es
#define SHADER_NAME bitmap-layer-fragment-shader

#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D bitmapTexture;

in vec2 vTexCoord;
in vec2 vTexPos;

out vec4 fragColor;

/* projection utils */
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / PI / 2.0;

// from degrees to Web Mercator
vec2 lnglat_to_mercator(vec2 lnglat) {
  float x = lnglat.x;
  float y = clamp(lnglat.y, -89.9, 89.9);
  return vec2(
    radians(x) + PI,
    PI + log(tan(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

// from Web Mercator to degrees
vec2 mercator_to_lnglat(vec2 xy) {
  xy /= WORLD_SCALE;
  return degrees(vec2(
    xy.x - PI,
    atan(exp(xy.y - PI)) * 2.0 - PI * 0.5
  ));
}
/* End projection utils */

// apply desaturation
vec3 color_desaturate(vec3 color) {
  float luminance = (color.r + color.g + color.b) * 0.333333333;
  return mix(color, vec3(luminance), bitmap.desaturate);
}

// apply tint
vec3 color_tint(vec3 color) {
  return color * bitmap.tintColor;
}

// blend with background color
vec4 apply_opacity(vec3 color, float alpha) {
  if (bitmap.transparentColor.a == 0.0) {
    return vec4(color, alpha);
  }
  float blendedAlpha = alpha + bitmap.transparentColor.a * (1.0 - alpha);
  float highLightRatio = alpha / blendedAlpha;
  vec3 blendedRGB = mix(bitmap.transparentColor.rgb, color, highLightRatio);
  return vec4(blendedRGB, blendedAlpha);
}

vec2 getUV(vec2 pos) {
  return vec2(
    (pos.x - bitmap.bounds[0]) / (bitmap.bounds[2] - bitmap.bounds[0]),
    (pos.y - bitmap.bounds[3]) / (bitmap.bounds[1] - bitmap.bounds[3])
  );
}

${packUVsIntoRGB}

void main(void) {
  vec2 uv = vTexCoord;
  if (bitmap.coordinateConversion < -0.5) {
    vec2 lnglat = mercator_to_lnglat(vTexPos);
    uv = getUV(lnglat);
  } else if (bitmap.coordinateConversion > 0.5) {
    vec2 commonPos = lnglat_to_mercator(vTexPos);
    uv = getUV(commonPos);
  }
  vec4 bitmapColor = texture(bitmapTexture, uv);

  fragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * layer.opacity);

  geometry.uv = uv;
  DECKGL_FILTER_COLOR(fragColor, geometry);

  if (bool(picking.isActive) && !bool(picking.isAttribute)) {
    // Since instance information is not used, we can use picking color for pixel index
    fragColor.rgb = packUVsIntoRGB(uv);
  }
}
`;

//#endregion
//#region node_modules/@deck.gl/layers/dist/bitmap-layer/bitmap-layer.js
var defaultProps$13 = {
	image: {
		type: "image",
		value: null,
		async: true
	},
	bounds: {
		type: "array",
		value: [
			1,
			0,
			0,
			1
		],
		compare: true
	},
	_imageCoordinateSystem: COORDINATE_SYSTEM.DEFAULT,
	desaturate: {
		type: "number",
		min: 0,
		max: 1,
		value: 0
	},
	transparentColor: {
		type: "color",
		value: [
			0,
			0,
			0,
			0
		]
	},
	tintColor: {
		type: "color",
		value: [
			255,
			255,
			255
		]
	},
	textureParameters: {
		type: "object",
		ignore: true,
		value: null
	}
};
/** Render a bitmap at specified boundaries. */
var BitmapLayer = class extends layer_default {
	getShaders() {
		return super.getShaders({
			vs: bitmap_layer_vertex_default,
			fs: bitmap_layer_fragment_default,
			modules: [
				project32_default,
				picking_default,
				bitmapUniforms
			]
		});
	}
	initializeState() {
		const attributeManager = this.getAttributeManager();
		attributeManager.remove(["instancePickingColors"]);
		const noAlloc = true;
		attributeManager.add({
			indices: {
				size: 1,
				isIndexed: true,
				update: (attribute) => attribute.value = this.state.mesh.indices,
				noAlloc
			},
			positions: {
				size: 3,
				type: "float64",
				fp64: this.use64bitPositions(),
				update: (attribute) => attribute.value = this.state.mesh.positions,
				noAlloc
			},
			texCoords: {
				size: 2,
				update: (attribute) => attribute.value = this.state.mesh.texCoords,
				noAlloc
			}
		});
	}
	updateState({ props, oldProps, changeFlags }) {
		const attributeManager = this.getAttributeManager();
		if (changeFlags.extensionsChanged) {
			this.state.model?.destroy();
			this.state.model = this._getModel();
			attributeManager.invalidateAll();
		}
		if (props.bounds !== oldProps.bounds) {
			const oldMesh = this.state.mesh;
			const mesh = this._createMesh();
			this.state.model.setVertexCount(mesh.vertexCount);
			for (const key in mesh) if (oldMesh && oldMesh[key] !== mesh[key]) attributeManager.invalidate(key);
			this.setState({
				mesh,
				...this._getCoordinateUniforms()
			});
		} else if (props._imageCoordinateSystem !== oldProps._imageCoordinateSystem) this.setState(this._getCoordinateUniforms());
	}
	getPickingInfo(params) {
		const { image } = this.props;
		const info = params.info;
		if (!info.color || !image) {
			info.bitmap = null;
			return info;
		}
		const { width, height } = image;
		info.index = 0;
		const uv = unpackUVsFromRGB(info.color);
		info.bitmap = {
			size: {
				width,
				height
			},
			uv,
			pixel: [Math.floor(uv[0] * width), Math.floor(uv[1] * height)]
		};
		return info;
	}
	disablePickingIndex() {
		this.setState({ disablePicking: true });
	}
	restorePickingColors() {
		this.setState({ disablePicking: false });
	}
	_updateAutoHighlight(info) {
		super._updateAutoHighlight({
			...info,
			color: this.encodePickingColor(0)
		});
	}
	_createMesh() {
		const { bounds } = this.props;
		let normalizedBounds = bounds;
		if (isRectangularBounds(bounds)) normalizedBounds = [
			[bounds[0], bounds[1]],
			[bounds[0], bounds[3]],
			[bounds[2], bounds[3]],
			[bounds[2], bounds[1]]
		];
		return createMesh(normalizedBounds, this.context.viewport.resolution);
	}
	_getModel() {
		return new Model(this.context.device, {
			...this.getShaders(),
			id: this.props.id,
			bufferLayout: this.getAttributeManager().getBufferLayouts(),
			topology: "triangle-list",
			isInstanced: false
		});
	}
	draw(opts) {
		const { shaderModuleProps } = opts;
		const { model, coordinateConversion, bounds, disablePicking } = this.state;
		const { image, desaturate, transparentColor, tintColor } = this.props;
		if (shaderModuleProps.picking.isActive && disablePicking) return;
		if (image && model) {
			const bitmapProps = {
				bitmapTexture: image,
				bounds,
				coordinateConversion,
				desaturate,
				tintColor: tintColor.slice(0, 3).map((x$1) => x$1 / 255),
				transparentColor: transparentColor.map((x$1) => x$1 / 255)
			};
			model.shaderInputs.setProps({ bitmap: bitmapProps });
			model.draw(this.context.renderPass);
		}
	}
	_getCoordinateUniforms() {
		const { LNGLAT, CARTESIAN, DEFAULT } = COORDINATE_SYSTEM;
		let { _imageCoordinateSystem: imageCoordinateSystem } = this.props;
		if (imageCoordinateSystem !== DEFAULT) {
			const { bounds } = this.props;
			if (!isRectangularBounds(bounds)) throw new Error("_imageCoordinateSystem only supports rectangular bounds");
			const defaultImageCoordinateSystem = this.context.viewport.resolution ? LNGLAT : CARTESIAN;
			imageCoordinateSystem = imageCoordinateSystem === LNGLAT ? LNGLAT : CARTESIAN;
			if (imageCoordinateSystem === LNGLAT && defaultImageCoordinateSystem === CARTESIAN) return {
				coordinateConversion: -1,
				bounds
			};
			if (imageCoordinateSystem === CARTESIAN && defaultImageCoordinateSystem === LNGLAT) {
				const bottomLeft = lngLatToWorld([bounds[0], bounds[1]]);
				const topRight = lngLatToWorld([bounds[2], bounds[3]]);
				return {
					coordinateConversion: 1,
					bounds: [
						bottomLeft[0],
						bottomLeft[1],
						topRight[0],
						topRight[1]
					]
				};
			}
		}
		return {
			coordinateConversion: 0,
			bounds: [
				0,
				0,
				0,
				0
			]
		};
	}
};
BitmapLayer.layerName = "BitmapLayer";
BitmapLayer.defaultProps = defaultProps$13;
var bitmap_layer_default = BitmapLayer;
/**
* Decode uv floats from rgb bytes where b contains 4-bit fractions of uv
* @param {number[]} color
* @returns {number[]} uvs
* https://stackoverflow.com/questions/30242013/glsl-compressing-packing-multiple-0-1-colours-var4-into-a-single-var4-variab
*/
function unpackUVsFromRGB(color) {
	const [u$1, v$1, fracUV] = color;
	const vFrac = (fracUV & 240) / 256;
	return [(u$1 + (fracUV & 15) / 16) / 256, (v$1 + vFrac) / 256];
}
function isRectangularBounds(bounds) {
	return Number.isFinite(bounds[0]);
}

//#endregion
//#region node_modules/@deck.gl/layers/dist/icon-layer/icon-layer-uniforms.js
var uniformBlock$5 = `\
uniform iconUniforms {
  float sizeScale;
  vec2 iconsTextureDim;
  float sizeBasis;
  float sizeMinPixels;
  float sizeMaxPixels;
  bool billboard;
  highp int sizeUnits;
  float alphaCutoff;
} icon;
`;
const iconUniforms = {
	name: "icon",
	vs: uniformBlock$5,
	fs: uniformBlock$5,
	uniformTypes: {
		sizeScale: "f32",
		iconsTextureDim: "vec2<f32>",
		sizeBasis: "f32",
		sizeMinPixels: "f32",
		sizeMaxPixels: "f32",
		billboard: "f32",
		sizeUnits: "i32",
		alphaCutoff: "f32"
	}
};

//#endregion
//#region node_modules/@deck.gl/layers/dist/icon-layer/icon-layer-vertex.glsl.js
var icon_layer_vertex_glsl_default = `\
#version 300 es
#define SHADER_NAME icon-layer-vertex-shader
in vec2 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in float instanceSizes;
in float instanceAngles;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec4 instanceIconFrames;
in float instanceColorModes;
in vec2 instanceOffsets;
in vec2 instancePixelOffset;
out float vColorMode;
out vec4 vColor;
out vec2 vTextureCoords;
out vec2 uv;
vec2 rotate_by_angle(vec2 vertex, float angle) {
float angle_radian = angle * PI / 180.0;
float cos_angle = cos(angle_radian);
float sin_angle = sin(angle_radian);
mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
return rotationMatrix * vertex;
}
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = positions;
geometry.pickingColor = instancePickingColors;
uv = positions;
vec2 iconSize = instanceIconFrames.zw;
float sizePixels = clamp(
project_size_to_pixel(instanceSizes * icon.sizeScale, icon.sizeUnits),
icon.sizeMinPixels, icon.sizeMaxPixels
);
float iconConstraint = icon.sizeBasis == 0.0 ? iconSize.x : iconSize.y;
float instanceScale = iconConstraint == 0.0 ? 0.0 : sizePixels / iconConstraint;
vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;
pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;
pixelOffset += instancePixelOffset;
pixelOffset.y *= -1.0;
if (icon.billboard)  {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = vec3(pixelOffset, 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
DECKGL_FILTER_SIZE(offset_common, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vTextureCoords = mix(
instanceIconFrames.xy,
instanceIconFrames.xy + iconSize,
(positions.xy + 1.0) / 2.0
) / icon.iconsTextureDim;
vColor = instanceColors;
DECKGL_FILTER_COLOR(vColor, geometry);
vColorMode = instanceColorModes;
}
`;

//#endregion
//#region node_modules/@deck.gl/layers/dist/icon-layer/icon-layer-fragment.glsl.js
var icon_layer_fragment_glsl_default = `\
#version 300 es
#define SHADER_NAME icon-layer-fragment-shader
precision highp float;
uniform sampler2D iconsTexture;
in float vColorMode;
in vec4 vColor;
in vec2 vTextureCoords;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
vec4 texColor = texture(iconsTexture, vTextureCoords);
vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);
float a = texColor.a * layer.opacity * vColor.a;
if (a < icon.alphaCutoff) {
discard;
}
fragColor = vec4(color, a);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

//#endregion
//#region node_modules/@deck.gl/layers/dist/icon-layer/icon-manager.js
var DEFAULT_CANVAS_WIDTH = 1024;
var DEFAULT_BUFFER$1 = 4;
var noop = () => {};
var DEFAULT_SAMPLER_PARAMETERS = {
	minFilter: "linear",
	mipmapFilter: "linear",
	magFilter: "linear",
	addressModeU: "clamp-to-edge",
	addressModeV: "clamp-to-edge"
};
var MISSING_ICON = {
	x: 0,
	y: 0,
	width: 0,
	height: 0
};
function nextPowOfTwo$1(number) {
	return Math.pow(2, Math.ceil(Math.log2(number)));
}
function resizeImage(ctx$1, imageData, maxWidth, maxHeight) {
	const resizeRatio = Math.min(maxWidth / imageData.width, maxHeight / imageData.height);
	const width = Math.floor(imageData.width * resizeRatio);
	const height = Math.floor(imageData.height * resizeRatio);
	if (resizeRatio === 1) return {
		image: imageData,
		width,
		height
	};
	ctx$1.canvas.height = height;
	ctx$1.canvas.width = width;
	ctx$1.clearRect(0, 0, width, height);
	ctx$1.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);
	return {
		image: ctx$1.canvas,
		width,
		height
	};
}
function getIconId(icon) {
	return icon && (icon.id || icon.url);
}
function resizeTexture(texture, width, height, sampler) {
	const { width: oldWidth, height: oldHeight, device } = texture;
	const newTexture = device.createTexture({
		format: "rgba8unorm",
		width,
		height,
		sampler,
		mipLevels: device.getMipLevelCount(width, height)
	});
	const commandEncoder = device.createCommandEncoder();
	commandEncoder.copyTextureToTexture({
		sourceTexture: texture,
		destinationTexture: newTexture,
		width: oldWidth,
		height: oldHeight
	});
	commandEncoder.finish();
	newTexture.generateMipmapsWebGL();
	texture.destroy();
	return newTexture;
}
function buildRowMapping(mapping, columns, yOffset) {
	for (let i$1 = 0; i$1 < columns.length; i$1++) {
		const { icon, xOffset } = columns[i$1];
		const id = getIconId(icon);
		mapping[id] = {
			...icon,
			x: xOffset,
			y: yOffset
		};
	}
}
/**
* Generate coordinate mapping to retrieve icon left-top position from an icon atlas
*/
function buildMapping$1({ icons, buffer, mapping = {}, xOffset = 0, yOffset = 0, rowHeight = 0, canvasWidth }) {
	let columns = [];
	for (let i$1 = 0; i$1 < icons.length; i$1++) {
		const icon = icons[i$1];
		if (!mapping[getIconId(icon)]) {
			const { height, width } = icon;
			if (xOffset + width + buffer > canvasWidth) {
				buildRowMapping(mapping, columns, yOffset);
				xOffset = 0;
				yOffset = rowHeight + yOffset + buffer;
				rowHeight = 0;
				columns = [];
			}
			columns.push({
				icon,
				xOffset
			});
			xOffset = xOffset + width + buffer;
			rowHeight = Math.max(rowHeight, height);
		}
	}
	if (columns.length > 0) buildRowMapping(mapping, columns, yOffset);
	return {
		mapping,
		rowHeight,
		xOffset,
		yOffset,
		canvasWidth,
		canvasHeight: nextPowOfTwo$1(rowHeight + yOffset + buffer)
	};
}
function getDiffIcons(data, getIcon, cachedIcons) {
	if (!data || !getIcon) return null;
	cachedIcons = cachedIcons || {};
	const icons = {};
	const { iterable, objectInfo } = createIterable(data);
	for (const object of iterable) {
		objectInfo.index++;
		const icon = getIcon(object, objectInfo);
		const id = getIconId(icon);
		if (!icon) throw new Error("Icon is missing.");
		if (!icon.url) throw new Error("Icon url is missing.");
		if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) icons[id] = {
			...icon,
			source: object,
			sourceIndex: objectInfo.index
		};
	}
	return icons;
}
var IconManager = class {
	constructor(device, { onUpdate = noop, onError = noop }) {
		this._loadOptions = null;
		this._texture = null;
		this._externalTexture = null;
		this._mapping = {};
		this._samplerParameters = null;
		/** count of pending requests to fetch icons */
		this._pendingCount = 0;
		this._autoPacking = false;
		this._xOffset = 0;
		this._yOffset = 0;
		this._rowHeight = 0;
		this._buffer = DEFAULT_BUFFER$1;
		this._canvasWidth = DEFAULT_CANVAS_WIDTH;
		this._canvasHeight = 0;
		this._canvas = null;
		this.device = device;
		this.onUpdate = onUpdate;
		this.onError = onError;
	}
	finalize() {
		this._texture?.delete();
	}
	getTexture() {
		return this._texture || this._externalTexture;
	}
	getIconMapping(icon) {
		const id = this._autoPacking ? getIconId(icon) : icon;
		return this._mapping[id] || MISSING_ICON;
	}
	setProps({ loadOptions, autoPacking, iconAtlas, iconMapping, textureParameters }) {
		if (loadOptions) this._loadOptions = loadOptions;
		if (autoPacking !== void 0) this._autoPacking = autoPacking;
		if (iconMapping) this._mapping = iconMapping;
		if (iconAtlas) {
			this._texture?.delete();
			this._texture = null;
			this._externalTexture = iconAtlas;
		}
		if (textureParameters) this._samplerParameters = textureParameters;
	}
	get isLoaded() {
		return this._pendingCount === 0;
	}
	packIcons(data, getIcon) {
		if (!this._autoPacking || typeof document === "undefined") return;
		const icons = Object.values(getDiffIcons(data, getIcon, this._mapping) || {});
		if (icons.length > 0) {
			const { mapping, xOffset, yOffset, rowHeight, canvasHeight } = buildMapping$1({
				icons,
				buffer: this._buffer,
				canvasWidth: this._canvasWidth,
				mapping: this._mapping,
				rowHeight: this._rowHeight,
				xOffset: this._xOffset,
				yOffset: this._yOffset
			});
			this._rowHeight = rowHeight;
			this._mapping = mapping;
			this._xOffset = xOffset;
			this._yOffset = yOffset;
			this._canvasHeight = canvasHeight;
			if (!this._texture) this._texture = this.device.createTexture({
				format: "rgba8unorm",
				data: null,
				width: this._canvasWidth,
				height: this._canvasHeight,
				sampler: this._samplerParameters || DEFAULT_SAMPLER_PARAMETERS,
				mipLevels: this.device.getMipLevelCount(this._canvasWidth, this._canvasHeight)
			});
			if (this._texture.height !== this._canvasHeight) this._texture = resizeTexture(this._texture, this._canvasWidth, this._canvasHeight, this._samplerParameters || DEFAULT_SAMPLER_PARAMETERS);
			this.onUpdate(true);
			this._canvas = this._canvas || document.createElement("canvas");
			this._loadIcons(icons);
		}
	}
	_loadIcons(icons) {
		const ctx$1 = this._canvas.getContext("2d", { willReadFrequently: true });
		for (const icon of icons) {
			this._pendingCount++;
			load(icon.url, this._loadOptions).then((imageData) => {
				const id = getIconId(icon);
				const iconDef = this._mapping[id];
				const { x: initialX, y: initialY, width: maxWidth, height: maxHeight } = iconDef;
				const { image, width, height } = resizeImage(ctx$1, imageData, maxWidth, maxHeight);
				const x$1 = initialX + (maxWidth - width) / 2;
				const y$1 = initialY + (maxHeight - height) / 2;
				this._texture?.copyExternalImage({
					image,
					x: x$1,
					y: y$1,
					width,
					height
				});
				iconDef.x = x$1;
				iconDef.y = y$1;
				iconDef.width = width;
				iconDef.height = height;
				this._texture?.generateMipmapsWebGL();
				this.onUpdate(width !== maxWidth || height !== maxHeight);
			}).catch((error) => {
				this.onError({
					url: icon.url,
					source: icon.source,
					sourceIndex: icon.sourceIndex,
					loadOptions: this._loadOptions,
					error
				});
			}).finally(() => {
				this._pendingCount--;
			});
		}
	}
};

//#endregion
//#region node_modules/@deck.gl/layers/dist/icon-layer/icon-layer.js
var DEFAULT_COLOR$6 = [
	0,
	0,
	0,
	255
];
var defaultProps$12 = {
	iconAtlas: {
		type: "image",
		value: null,
		async: true
	},
	iconMapping: {
		type: "object",
		value: {},
		async: true
	},
	sizeScale: {
		type: "number",
		value: 1,
		min: 0
	},
	billboard: true,
	sizeUnits: "pixels",
	sizeBasis: "height",
	sizeMinPixels: {
		type: "number",
		min: 0,
		value: 0
	},
	sizeMaxPixels: {
		type: "number",
		min: 0,
		value: Number.MAX_SAFE_INTEGER
	},
	alphaCutoff: {
		type: "number",
		value: .05,
		min: 0,
		max: 1
	},
	getPosition: {
		type: "accessor",
		value: (x$1) => x$1.position
	},
	getIcon: {
		type: "accessor",
		value: (x$1) => x$1.icon
	},
	getColor: {
		type: "accessor",
		value: DEFAULT_COLOR$6
	},
	getSize: {
		type: "accessor",
		value: 1
	},
	getAngle: {
		type: "accessor",
		value: 0
	},
	getPixelOffset: {
		type: "accessor",
		value: [0, 0]
	},
	onIconError: {
		type: "function",
		value: null,
		optional: true
	},
	textureParameters: {
		type: "object",
		ignore: true,
		value: null
	}
};
/** Render raster icons at given coordinates. */
var IconLayer = class extends layer_default {
	getShaders() {
		return super.getShaders({
			vs: icon_layer_vertex_glsl_default,
			fs: icon_layer_fragment_glsl_default,
			modules: [
				project32_default,
				picking_default,
				iconUniforms
			]
		});
	}
	initializeState() {
		this.state = { iconManager: new IconManager(this.context.device, {
			onUpdate: this._onUpdate.bind(this),
			onError: this._onError.bind(this)
		}) };
		this.getAttributeManager().addInstanced({
			instancePositions: {
				size: 3,
				type: "float64",
				fp64: this.use64bitPositions(),
				transition: true,
				accessor: "getPosition"
			},
			instanceSizes: {
				size: 1,
				transition: true,
				accessor: "getSize",
				defaultValue: 1
			},
			instanceOffsets: {
				size: 2,
				accessor: "getIcon",
				transform: this.getInstanceOffset
			},
			instanceIconFrames: {
				size: 4,
				accessor: "getIcon",
				transform: this.getInstanceIconFrame
			},
			instanceColorModes: {
				size: 1,
				type: "uint8",
				accessor: "getIcon",
				transform: this.getInstanceColorMode
			},
			instanceColors: {
				size: this.props.colorFormat.length,
				type: "unorm8",
				transition: true,
				accessor: "getColor",
				defaultValue: DEFAULT_COLOR$6
			},
			instanceAngles: {
				size: 1,
				transition: true,
				accessor: "getAngle"
			},
			instancePixelOffset: {
				size: 2,
				transition: true,
				accessor: "getPixelOffset"
			}
		});
	}
	updateState(params) {
		super.updateState(params);
		const { props, oldProps, changeFlags } = params;
		const attributeManager = this.getAttributeManager();
		const { iconAtlas, iconMapping, data, getIcon, textureParameters } = props;
		const { iconManager } = this.state;
		if (typeof iconAtlas === "string") return;
		const prePacked = iconAtlas || this.internalState.isAsyncPropLoading("iconAtlas");
		iconManager.setProps({
			loadOptions: props.loadOptions,
			autoPacking: !prePacked,
			iconAtlas,
			iconMapping: prePacked ? iconMapping : null,
			textureParameters
		});
		if (prePacked) {
			if (oldProps.iconMapping !== props.iconMapping) attributeManager.invalidate("getIcon");
		} else if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon)) iconManager.packIcons(data, getIcon);
		if (changeFlags.extensionsChanged) {
			this.state.model?.destroy();
			this.state.model = this._getModel();
			attributeManager.invalidateAll();
		}
	}
	get isLoaded() {
		return super.isLoaded && this.state.iconManager.isLoaded;
	}
	finalizeState(context) {
		super.finalizeState(context);
		this.state.iconManager.finalize();
	}
	draw({ uniforms }) {
		const { sizeScale, sizeBasis, sizeMinPixels, sizeMaxPixels, sizeUnits, billboard, alphaCutoff } = this.props;
		const { iconManager } = this.state;
		const iconsTexture = iconManager.getTexture();
		if (iconsTexture) {
			const model = this.state.model;
			const iconProps = {
				iconsTexture,
				iconsTextureDim: [iconsTexture.width, iconsTexture.height],
				sizeUnits: UNIT[sizeUnits],
				sizeScale,
				sizeBasis: sizeBasis === "height" ? 1 : 0,
				sizeMinPixels,
				sizeMaxPixels,
				billboard,
				alphaCutoff
			};
			model.shaderInputs.setProps({ icon: iconProps });
			model.draw(this.context.renderPass);
		}
	}
	_getModel() {
		const positions = [
			-1,
			-1,
			1,
			-1,
			-1,
			1,
			1,
			1
		];
		return new Model(this.context.device, {
			...this.getShaders(),
			id: this.props.id,
			bufferLayout: this.getAttributeManager().getBufferLayouts(),
			geometry: new Geometry({
				topology: "triangle-strip",
				attributes: { positions: {
					size: 2,
					value: new Float32Array(positions)
				} }
			}),
			isInstanced: true
		});
	}
	_onUpdate(didFrameChange) {
		if (didFrameChange) {
			this.getAttributeManager()?.invalidate("getIcon");
			this.setNeedsUpdate();
		} else this.setNeedsRedraw();
	}
	_onError(evt) {
		const onIconError = this.getCurrentLayer()?.props.onIconError;
		if (onIconError) onIconError(evt);
		else log_default.error(evt.error.message)();
	}
	getInstanceOffset(icon) {
		const { width, height, anchorX = width / 2, anchorY = height / 2 } = this.state.iconManager.getIconMapping(icon);
		return [width / 2 - anchorX, height / 2 - anchorY];
	}
	getInstanceColorMode(icon) {
		return this.state.iconManager.getIconMapping(icon).mask ? 1 : 0;
	}
	getInstanceIconFrame(icon) {
		const { x: x$1, y: y$1, width, height } = this.state.iconManager.getIconMapping(icon);
		return [
			x$1,
			y$1,
			width,
			height
		];
	}
};
IconLayer.defaultProps = defaultProps$12;
IconLayer.layerName = "IconLayer";
var icon_layer_default = IconLayer;

//#endregion
//#region node_modules/@deck.gl/layers/dist/line-layer/line-layer-uniforms.js
var uniformBlockWGSL = `\
struct LineUniforms {
  widthScale: f32,
  widthMinPixels: f32,
  widthMaxPixels: f32,
  useShortestPath: f32,
  widthUnits: i32,
};

@group(0) @binding(1)
var<uniform> line: LineUniforms;
`;
var uniformBlockGLSL = `\
uniform lineUniforms {
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  float useShortestPath;
  highp int widthUnits;
} line;
`;
const lineUniforms = {
	name: "line",
	source: uniformBlockWGSL,
	vs: uniformBlockGLSL,
	fs: uniformBlockGLSL,
	uniformTypes: {
		widthScale: "f32",
		widthMinPixels: "f32",
		widthMaxPixels: "f32",
		useShortestPath: "f32",
		widthUnits: "i32"
	}
};

//#endregion
//#region node_modules/@deck.gl/layers/dist/line-layer/line-layer.wgsl.js
const shaderWGSL = `\
// ---------- Helper Structures & Functions ----------

// Placeholder filter functions.
fn deckgl_filter_size(offset: vec3<f32>, geometry: Geometry) -> vec3<f32> {
  return offset;
}
fn deckgl_filter_gl_position(p: vec4<f32>, geometry: Geometry) -> vec4<f32> {
  return p;
}
fn deckgl_filter_color(color: vec4<f32>, geometry: Geometry) -> vec4<f32> {
  return color;
}

// Compute an extrusion offset given a line direction (in clipspace),
// an offset direction (-1 or 1), and a width in pixels.
// Assumes a uniform "project" with a viewportSize field is available.
fn getExtrusionOffset(line_clipspace: vec2<f32>, offset_direction: f32, width: f32) -> vec2<f32> {
  // project.viewportSize should be provided as a uniform (not shown here)
  let dir_screenspace = normalize(line_clipspace * project.viewportSize);
  // Rotate by 90: (x,y) becomes (-y,x)
  let rotated = vec2<f32>(-dir_screenspace.y, dir_screenspace.x);
  return rotated * offset_direction * width / 2.0;
}

// Splits the line between two points at a given x coordinate.
// Interpolates the y and z components.
fn splitLine(a: vec3<f32>, b: vec3<f32>, x: f32) -> vec3<f32> {
  let t: f32 = (x - a.x) / (b.x - a.x);
  return vec3<f32>(x, a.yz + t * (b.yz - a.yz));
}

// ---------- Uniforms & Global Structures ----------

// Uniforms for line, color, and project are assumed to be defined elsewhere.
// For example:
//
// @group(0) @binding(0)
// var<uniform> line: LineUniform;
//
// struct ColorUniform {
//   opacity: f32,
// };
// @group(0) @binding(1)
// var<uniform> color: ColorUniform;
//
// struct ProjectUniform {
//   viewportSize: vec2<f32>,
// };
// @group(0) @binding(2)
// var<uniform> project: ProjectUniform;



// ---------- Vertex Output Structure ----------

struct Varyings {
  @builtin(position) gl_Position: vec4<f32>,
  @location(0) vColor: vec4<f32>,
  @location(1) uv: vec2<f32>,
};

// ---------- Vertex Shader Entry Point ----------

@vertex
fn vertexMain(
  @location(0) positions: vec3<f32>,
  @location(1) instanceSourcePositions: vec3<f32>,
  @location(2) instanceTargetPositions: vec3<f32>,
  @location(3) instanceSourcePositions64Low: vec3<f32>,
  @location(4) instanceTargetPositions64Low: vec3<f32>,
  @location(5) instanceColors: vec4<f32>,
  @location(6) instancePickingColors: vec3<f32>,
  @location(7) instanceWidths: f32
) -> Varyings {
  var geometry: Geometry;
  geometry.worldPosition = instanceSourcePositions;
  geometry.worldPositionAlt = instanceTargetPositions;

  var source_world: vec3<f32> = instanceSourcePositions;
  var target_world: vec3<f32> = instanceTargetPositions;
  var source_world_64low: vec3<f32> = instanceSourcePositions64Low;
  var target_world_64low: vec3<f32> = instanceTargetPositions64Low;

  // Apply shortest-path adjustments if needed.
  if (line.useShortestPath > 0.5 || line.useShortestPath < -0.5) {
    source_world.x = (source_world.x + 180.0 % 360.0) - 180.0;
    target_world.x = (target_world.x + 180.0 % 360.0) - 180.0;
    let deltaLng: f32 = target_world.x - source_world.x;

    if (deltaLng * line.useShortestPath > 180.0) {
      source_world.x = source_world.x + 360.0 * line.useShortestPath;
      source_world = splitLine(source_world, target_world, 180.0 * line.useShortestPath);
      source_world_64low = vec3<f32>(0.0, 0.0, 0.0);
    } else if (deltaLng * line.useShortestPath < -180.0) {
      target_world.x = target_world.x + 360.0 * line.useShortestPath;
      target_world = splitLine(source_world, target_world, 180.0 * line.useShortestPath);
      target_world_64low = vec3<f32>(0.0, 0.0, 0.0);
    } else if (line.useShortestPath < 0.0) {
      var abortOut: Varyings;
      abortOut.gl_Position = vec4<f32>(0.0);
      abortOut.vColor = vec4<f32>(0.0);
      abortOut.uv = vec2<f32>(0.0);
      return abortOut;
    }
  }

  // Project Pos and target positions to clip space.
  let sourceResult = project_position_to_clipspace_and_commonspace(source_world, source_world_64low, vec3<f32>(0.0));
  let targetResult = project_position_to_clipspace_and_commonspace(target_world, target_world_64low, vec3<f32>(0.0));
  let sourcePos: vec4<f32> = sourceResult.clipPosition;
  let targetPos: vec4<f32> = targetResult.clipPosition;
  let source_commonspace: vec4<f32> = sourceResult.commonPosition;
  let target_commonspace: vec4<f32> = targetResult.commonPosition;

  // Interpolate along the line segment.
  let segmentIndex: f32 = positions.x;
  let p: vec4<f32> = sourcePos + segmentIndex * (targetPos - sourcePos);
  geometry.position = source_commonspace + segmentIndex * (target_commonspace - source_commonspace);
  let uv: vec2<f32> = positions.xy;
  geometry.uv = uv;
  geometry.pickingColor = instancePickingColors;

  // Determine width in pixels.
  let widthPixels: f32 = clamp(
    project_unit_size_to_pixel(instanceWidths * line.widthScale, line.widthUnits),
    line.widthMinPixels, line.widthMaxPixels
  );

  // Compute extrusion offset.
  let extrusion: vec2<f32> = getExtrusionOffset(targetPos.xy - sourcePos.xy, positions.y, widthPixels);
  let offset: vec3<f32> = vec3<f32>(extrusion, 0.0);

  // Apply deck.gl filter functions.
  let filteredOffset = deckgl_filter_size(offset, geometry);
  let filteredP = deckgl_filter_gl_position(p, geometry);

  let clipOffset: vec2<f32> = project_pixel_size_to_clipspace(filteredOffset.xy);
  let finalPosition: vec4<f32> = filteredP + vec4<f32>(clipOffset, 0.0, 0.0);

  // Compute color.
  var vColor: vec4<f32> = vec4<f32>(instanceColors.rgb, instanceColors.a * color.opacity);
  // vColor = deckgl_filter_color(vColor, geometry);

  var output: Varyings;
  output.gl_Position = finalPosition;
  output.vColor = vColor;
  output.uv = uv;
  return output;
}

@fragment
fn fragmentMain(
  @location(0) vColor: vec4<f32>,
  @location(1) uv: vec2<f32>
) -> @location(0) vec4<f32> {
  // Create and initialize geometry with the provided uv.
  var geometry: Geometry;
  geometry.uv = uv;

  // Start with the input color.
  var fragColor: vec4<f32> = vColor;

  // Apply the deck.gl filter to the color.
  fragColor = deckgl_filter_color(fragColor, geometry);

  // Apply premultiplied alpha as required by transparent canvas
  fragColor = deckgl_premultiplied_alpha(fragColor);

  return fragColor;
}
`;

//#endregion
//#region node_modules/@deck.gl/layers/dist/line-layer/line-layer-vertex.glsl.js
var line_layer_vertex_glsl_default = `\
#version 300 es
#define SHADER_NAME line-layer-vertex-shader
in vec3 positions;
in vec3 instanceSourcePositions;
in vec3 instanceTargetPositions;
in vec3 instanceSourcePositions64Low;
in vec3 instanceTargetPositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in float instanceWidths;
out vec4 vColor;
out vec2 uv;
vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {
vec2 dir_screenspace = normalize(line_clipspace * project.viewportSize);
dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);
return dir_screenspace * offset_direction * width / 2.0;
}
vec3 splitLine(vec3 a, vec3 b, float x) {
float t = (x - a.x) / (b.x - a.x);
return vec3(x, mix(a.yz, b.yz, t));
}
void main(void) {
geometry.worldPosition = instanceSourcePositions;
geometry.worldPositionAlt = instanceTargetPositions;
vec3 source_world = instanceSourcePositions;
vec3 target_world = instanceTargetPositions;
vec3 source_world_64low = instanceSourcePositions64Low;
vec3 target_world_64low = instanceTargetPositions64Low;
if (line.useShortestPath > 0.5 || line.useShortestPath < -0.5) {
source_world.x = mod(source_world.x + 180., 360.0) - 180.;
target_world.x = mod(target_world.x + 180., 360.0) - 180.;
float deltaLng = target_world.x - source_world.x;
if (deltaLng * line.useShortestPath > 180.) {
source_world.x += 360. * line.useShortestPath;
source_world = splitLine(source_world, target_world, 180. * line.useShortestPath);
source_world_64low = vec3(0.0);
} else if (deltaLng * line.useShortestPath < -180.) {
target_world.x += 360. * line.useShortestPath;
target_world = splitLine(source_world, target_world, 180. * line.useShortestPath);
target_world_64low = vec3(0.0);
} else if (line.useShortestPath < 0.) {
gl_Position = vec4(0.);
return;
}
}
vec4 source_commonspace;
vec4 target_commonspace;
vec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);
vec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);
float segmentIndex = positions.x;
vec4 p = mix(source, target, segmentIndex);
geometry.position = mix(source_commonspace, target_commonspace, segmentIndex);
uv = positions.xy;
geometry.uv = uv;
geometry.pickingColor = instancePickingColors;
float widthPixels = clamp(
project_size_to_pixel(instanceWidths * line.widthScale, line.widthUnits),
line.widthMinPixels, line.widthMaxPixels
);
vec3 offset = vec3(
getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),
0.0);
DECKGL_FILTER_SIZE(offset, geometry);
DECKGL_FILTER_GL_POSITION(p, geometry);
gl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);
vColor = vec4(instanceColors.rgb, instanceColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

//#endregion
//#region node_modules/@deck.gl/layers/dist/line-layer/line-layer-fragment.glsl.js
var line_layer_fragment_glsl_default = `\
#version 300 es
#define SHADER_NAME line-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

//#endregion
//#region node_modules/@deck.gl/layers/dist/line-layer/line-layer.js
var defaultProps$11 = {
	getSourcePosition: {
		type: "accessor",
		value: (x$1) => x$1.sourcePosition
	},
	getTargetPosition: {
		type: "accessor",
		value: (x$1) => x$1.targetPosition
	},
	getColor: {
		type: "accessor",
		value: [
			0,
			0,
			0,
			255
		]
	},
	getWidth: {
		type: "accessor",
		value: 1
	},
	widthUnits: "pixels",
	widthScale: {
		type: "number",
		value: 1,
		min: 0
	},
	widthMinPixels: {
		type: "number",
		value: 0,
		min: 0
	},
	widthMaxPixels: {
		type: "number",
		value: Number.MAX_SAFE_INTEGER,
		min: 0
	}
};
/**
* A layer that renders straight lines joining pairs of source and target coordinates.
*/
var LineLayer = class extends layer_default {
	getBounds() {
		return this.getAttributeManager()?.getBounds(["instanceSourcePositions", "instanceTargetPositions"]);
	}
	getShaders() {
		return super.getShaders({
			vs: line_layer_vertex_glsl_default,
			fs: line_layer_fragment_glsl_default,
			source: shaderWGSL,
			modules: [
				project32_default,
				color_default,
				picking_default,
				lineUniforms
			]
		});
	}
	get wrapLongitude() {
		return false;
	}
	initializeState() {
		this.getAttributeManager().addInstanced({
			instanceSourcePositions: {
				size: 3,
				type: "float64",
				fp64: this.use64bitPositions(),
				transition: true,
				accessor: "getSourcePosition"
			},
			instanceTargetPositions: {
				size: 3,
				type: "float64",
				fp64: this.use64bitPositions(),
				transition: true,
				accessor: "getTargetPosition"
			},
			instanceColors: {
				size: this.props.colorFormat.length,
				type: "unorm8",
				transition: true,
				accessor: "getColor",
				defaultValue: [
					0,
					0,
					0,
					255
				]
			},
			instanceWidths: {
				size: 1,
				transition: true,
				accessor: "getWidth",
				defaultValue: 1
			}
		});
	}
	updateState(params) {
		super.updateState(params);
		if (params.changeFlags.extensionsChanged) {
			this.state.model?.destroy();
			this.state.model = this._getModel();
			this.getAttributeManager().invalidateAll();
		}
	}
	draw({ uniforms }) {
		const { widthUnits, widthScale, widthMinPixels, widthMaxPixels, wrapLongitude } = this.props;
		const model = this.state.model;
		const lineProps = {
			widthUnits: UNIT[widthUnits],
			widthScale,
			widthMinPixels,
			widthMaxPixels,
			useShortestPath: wrapLongitude ? 1 : 0
		};
		model.shaderInputs.setProps({ line: lineProps });
		model.draw(this.context.renderPass);
		if (wrapLongitude) {
			model.shaderInputs.setProps({ line: {
				...lineProps,
				useShortestPath: -1
			} });
			model.draw(this.context.renderPass);
		}
	}
	_getModel() {
		const parameters = this.context.device.type === "webgpu" ? {
			depthWriteEnabled: true,
			depthCompare: "less-equal"
		} : void 0;
		const positions = [
			0,
			-1,
			0,
			0,
			1,
			0,
			1,
			-1,
			0,
			1,
			1,
			0
		];
		return new Model(this.context.device, {
			...this.getShaders(),
			id: this.props.id,
			bufferLayout: this.getAttributeManager().getBufferLayouts(),
			geometry: new Geometry({
				topology: "triangle-strip",
				attributes: { positions: {
					size: 3,
					value: new Float32Array(positions)
				} }
			}),
			parameters,
			isInstanced: true
		});
	}
};
LineLayer.layerName = "LineLayer";
LineLayer.defaultProps = defaultProps$11;
var line_layer_default = LineLayer;

//#endregion
//#region node_modules/@deck.gl/layers/dist/point-cloud-layer/point-cloud-layer-uniforms.js
var wgslUniformBlock = `\
struct PointCloudUniforms {
  radiusPixels: f32,
  sizeUnits: i32,
};

@group(0) @binding(3)
var<uniform> pointCloud: PointCloudUniforms;
`;
var glslUniformBlock$1 = `\
uniform pointCloudUniforms {
  float radiusPixels;
  highp int sizeUnits;
} pointCloud;
`;
const pointCloudUniforms = {
	name: "pointCloud",
	source: wgslUniformBlock,
	vs: glslUniformBlock$1,
	fs: glslUniformBlock$1,
	uniformTypes: {
		radiusPixels: "f32",
		sizeUnits: "i32"
	}
};

//#endregion
//#region node_modules/@deck.gl/layers/dist/point-cloud-layer/point-cloud-layer-vertex.glsl.js
var point_cloud_layer_vertex_glsl_default = `\
#version 300 es
#define SHADER_NAME point-cloud-layer-vertex-shader
in vec3 positions;
in vec3 instanceNormals;
in vec4 instanceColors;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec3 instancePickingColors;
out vec4 vColor;
out vec2 unitPosition;
void main(void) {
geometry.worldPosition = instancePositions;
geometry.normal = project_normal(instanceNormals);
unitPosition = positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
vec3 offset = vec3(positions.xy * project_size_to_pixel(pointCloud.radiusPixels, pointCloud.sizeUnits), 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, instanceColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

//#endregion
//#region node_modules/@deck.gl/layers/dist/point-cloud-layer/point-cloud-layer-fragment.glsl.js
var point_cloud_layer_fragment_glsl_default = `\
#version 300 es
#define SHADER_NAME point-cloud-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 unitPosition;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition.xy;
float distToCenter = length(unitPosition);
if (distToCenter > 1.0) {
discard;
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

//#endregion
//#region node_modules/@deck.gl/layers/dist/point-cloud-layer/point-cloud-layer.wgsl.js
var point_cloud_layer_wgsl_default = `\
struct ConstantAttributes {
  instanceNormals: vec3<f32>,
  instanceColors: vec4<f32>,
  instancePositions: vec3<f32>,
  instancePositions64Low: vec3<f32>,
  instancePickingColors: vec3<f32>
};

const constants = ConstantAttributes(
  vec3<f32>(1.0, 0.0, 0.0),
  vec4<f32>(0.0, 0.0, 0.0, 1.0),
  vec3<f32>(0.0),
  vec3<f32>(0.0),
  vec3<f32>(0.0)
);

struct Attributes {
  @builtin(instance_index) instanceIndex : u32,
  @builtin(vertex_index) vertexIndex : u32,
  @location(0) positions: vec3<f32>,
  @location(1) instancePositions: vec3<f32>,
  @location(2) instancePositions64Low: vec3<f32>,
  @location(3) instanceNormals: vec3<f32>,
  @location(4) instanceColors: vec4<f32>,
  @location(5) instancePickingColors: vec3<f32>
};

struct Varyings {
  @builtin(position) position: vec4<f32>,
  @location(0) vColor: vec4<f32>,
  @location(1) unitPosition: vec2<f32>,
};

@vertex
fn vertexMain(attributes: Attributes) -> Varyings {
  var varyings: Varyings;
  
  // var geometry: Geometry;
  // geometry.worldPosition = instancePositions;
  // geometry.normal = project_normal(instanceNormals);

  // position on the containing square in [-1, 1] space
  varyings.unitPosition = attributes.positions.xy;
  geometry.uv = varyings.unitPosition;
  geometry.pickingColor = attributes.instancePickingColors;

  // Find the center of the point and add the current vertex
  let offset = vec3<f32>(attributes.positions.xy * project_unit_size_to_pixel(pointCloud.radiusPixels, pointCloud.sizeUnits), 0.0);
  // DECKGL_FILTER_SIZE(offset, geometry);

  varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, vec3<f32>(0.0)); // TODO , geometry.position);
  // DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  let clipPixels = project_pixel_size_to_clipspace(offset.xy);
  varyings.position.x += clipPixels.x;
  varyings.position.y += clipPixels.y;

  // Apply lighting
  let lightColor = lighting_getLightColor2(attributes.instanceColors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);

  // Apply opacity to instance color, or return instance picking color
  varyings.vColor = vec4(lightColor, attributes.instanceColors.a * color.opacity);
  // DECKGL_FILTER_COLOR(vColor, geometry);

  return varyings;
}

@fragment
fn fragmentMain(varyings: Varyings) -> @location(0) vec4<f32> {
  // var geometry: Geometry;
  // geometry.uv = unitPosition.xy;

  let distToCenter = length(varyings.unitPosition);
  if (distToCenter > 1.0) {
    discard;
  }

  var fragColor: vec4<f32>;

  fragColor = varyings.vColor;
  // DECKGL_FILTER_COLOR(fragColor, geometry);

  // Apply premultiplied alpha as required by transparent canvas
  fragColor = deckgl_premultiplied_alpha(fragColor);

  return fragColor;
}
`;

//#endregion
//#region node_modules/@deck.gl/layers/dist/point-cloud-layer/point-cloud-layer.js
var DEFAULT_COLOR$5 = [
	0,
	0,
	0,
	255
];
var DEFAULT_NORMAL = [
	0,
	0,
	1
];
var defaultProps$10 = {
	sizeUnits: "pixels",
	pointSize: {
		type: "number",
		min: 0,
		value: 10
	},
	getPosition: {
		type: "accessor",
		value: (x$1) => x$1.position
	},
	getNormal: {
		type: "accessor",
		value: DEFAULT_NORMAL
	},
	getColor: {
		type: "accessor",
		value: DEFAULT_COLOR$5
	},
	material: true,
	radiusPixels: { deprecatedFor: "pointSize" }
};
function normalizeData(data) {
	const { header, attributes } = data;
	if (!header || !attributes) return;
	data.length = header.vertexCount;
	if (attributes.POSITION) attributes.instancePositions = attributes.POSITION;
	if (attributes.NORMAL) attributes.instanceNormals = attributes.NORMAL;
	if (attributes.COLOR_0) {
		const { size, value } = attributes.COLOR_0;
		attributes.instanceColors = {
			size,
			type: "unorm8",
			value
		};
	}
}
/** Render a point cloud with 3D positions, normals and colors. */
var PointCloudLayer = class extends layer_default {
	getShaders() {
		return super.getShaders({
			vs: point_cloud_layer_vertex_glsl_default,
			fs: point_cloud_layer_fragment_glsl_default,
			source: point_cloud_layer_wgsl_default,
			modules: [
				project32_default,
				color_default,
				gouraudMaterial,
				picking_default,
				pointCloudUniforms
			]
		});
	}
	initializeState() {
		this.getAttributeManager().addInstanced({
			instancePositions: {
				size: 3,
				type: "float64",
				fp64: this.use64bitPositions(),
				transition: true,
				accessor: "getPosition"
			},
			instanceNormals: {
				size: 3,
				transition: true,
				accessor: "getNormal",
				defaultValue: DEFAULT_NORMAL
			},
			instanceColors: {
				size: this.props.colorFormat.length,
				type: "unorm8",
				transition: true,
				accessor: "getColor",
				defaultValue: DEFAULT_COLOR$5
			}
		});
	}
	updateState(params) {
		const { changeFlags, props } = params;
		super.updateState(params);
		if (changeFlags.extensionsChanged) {
			this.state.model?.destroy();
			this.state.model = this._getModel();
			this.getAttributeManager().invalidateAll();
		}
		if (changeFlags.dataChanged) normalizeData(props.data);
	}
	draw({ uniforms }) {
		const { pointSize, sizeUnits } = this.props;
		const model = this.state.model;
		const pointCloudProps = {
			sizeUnits: UNIT[sizeUnits],
			radiusPixels: pointSize
		};
		model.shaderInputs.setProps({ pointCloud: pointCloudProps });
		if (this.context.device.type === "webgpu") model.instanceCount = this.props.data.length;
		model.draw(this.context.renderPass);
	}
	_getModel() {
		const parameters = this.context.device.type === "webgpu" ? {
			depthWriteEnabled: true,
			depthCompare: "less-equal"
		} : void 0;
		const positions = [];
		for (let i$1 = 0; i$1 < 3; i$1++) {
			const angle = i$1 / 3 * Math.PI * 2;
			positions.push(Math.cos(angle) * 2, Math.sin(angle) * 2, 0);
		}
		return new Model(this.context.device, {
			...this.getShaders(),
			id: this.props.id,
			bufferLayout: this.getAttributeManager().getBufferLayouts(),
			geometry: new Geometry({
				topology: "triangle-list",
				attributes: { positions: new Float32Array(positions) }
			}),
			parameters,
			isInstanced: true
		});
	}
};
PointCloudLayer.layerName = "PointCloudLayer";
PointCloudLayer.defaultProps = defaultProps$10;
var point_cloud_layer_default = PointCloudLayer;

//#endregion
//#region node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer-uniforms.js
var glslUniformBlock = `\
uniform scatterplotUniforms {
  float radiusScale;
  float radiusMinPixels;
  float radiusMaxPixels;
  float lineWidthScale;
  float lineWidthMinPixels;
  float lineWidthMaxPixels;
  float stroked;
  float filled;
  bool antialiasing;
  bool billboard;
  highp int radiusUnits;
  highp int lineWidthUnits;
} scatterplot;
`;
const scatterplotUniforms = {
	name: "scatterplot",
	vs: glslUniformBlock,
	fs: glslUniformBlock,
	source: "",
	uniformTypes: {
		radiusScale: "f32",
		radiusMinPixels: "f32",
		radiusMaxPixels: "f32",
		lineWidthScale: "f32",
		lineWidthMinPixels: "f32",
		lineWidthMaxPixels: "f32",
		stroked: "f32",
		filled: "f32",
		antialiasing: "f32",
		billboard: "f32",
		radiusUnits: "i32",
		lineWidthUnits: "i32"
	}
};

//#endregion
//#region node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer-vertex.glsl.js
var scatterplot_layer_vertex_glsl_default = `\
#version 300 es
#define SHADER_NAME scatterplot-layer-vertex-shader
in vec3 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in float instanceRadius;
in float instanceLineWidths;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
out vec4 vFillColor;
out vec4 vLineColor;
out vec2 unitPosition;
out float innerUnitRadius;
out float outerRadiusPixels;
void main(void) {
geometry.worldPosition = instancePositions;
outerRadiusPixels = clamp(
project_size_to_pixel(scatterplot.radiusScale * instanceRadius, scatterplot.radiusUnits),
scatterplot.radiusMinPixels, scatterplot.radiusMaxPixels
);
float lineWidthPixels = clamp(
project_size_to_pixel(scatterplot.lineWidthScale * instanceLineWidths, scatterplot.lineWidthUnits),
scatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels
);
outerRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;
float edgePadding = scatterplot.antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;
unitPosition = edgePadding * positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
innerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / outerRadiusPixels;
if (scatterplot.billboard) {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = edgePadding * positions * outerRadiusPixels;
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vFillColor, geometry);
vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`;

//#endregion
//#region node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer-fragment.glsl.js
var scatterplot_layer_fragment_glsl_default = `\
#version 300 es
#define SHADER_NAME scatterplot-layer-fragment-shader
precision highp float;
in vec4 vFillColor;
in vec4 vLineColor;
in vec2 unitPosition;
in float innerUnitRadius;
in float outerRadiusPixels;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition;
float distToCenter = length(unitPosition) * outerRadiusPixels;
float inCircle = scatterplot.antialiasing ?
smoothedge(distToCenter, outerRadiusPixels) :
step(distToCenter, outerRadiusPixels);
if (inCircle == 0.0) {
discard;
}
if (scatterplot.stroked > 0.5) {
float isLine = scatterplot.antialiasing ?
smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :
step(innerUnitRadius * outerRadiusPixels, distToCenter);
if (scatterplot.filled > 0.5) {
fragColor = mix(vFillColor, vLineColor, isLine);
} else {
if (isLine == 0.0) {
discard;
}
fragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);
}
} else if (scatterplot.filled < 0.5) {
discard;
} else {
fragColor = vFillColor;
}
fragColor.a *= inCircle;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

//#endregion
//#region node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer.wgsl.js
var scatterplot_layer_wgsl_default = `\
// Main shaders

struct ScatterplotUniforms {
  radiusScale: f32,
  radiusMinPixels: f32,
  radiusMaxPixels: f32,
  lineWidthScale: f32,
  lineWidthMinPixels: f32,
  lineWidthMaxPixels: f32,
  stroked: f32,
  filled: i32,
  antialiasing: i32,
  billboard: i32,
  radiusUnits: i32,
  lineWidthUnits: i32,
};

struct ConstantAttributeUniforms {
 instancePositions: vec3<f32>,
 instancePositions64Low: vec3<f32>,
 instanceRadius: f32,
 instanceLineWidths: f32,
 instanceFillColors: vec4<f32>,
 instanceLineColors: vec4<f32>,
 instancePickingColors: vec3<f32>,

 instancePositionsConstant: i32,
 instancePositions64LowConstant: i32,
 instanceRadiusConstant: i32,
 instanceLineWidthsConstant: i32,
 instanceFillColorsConstant: i32,
 instanceLineColorsConstant: i32,
 instancePickingColorsConstant: i32
};

@group(0) @binding(2) var<uniform> scatterplot: ScatterplotUniforms;

struct ConstantAttributes {
  instancePositions: vec3<f32>,
  instancePositions64Low: vec3<f32>,
  instanceRadius: f32,
  instanceLineWidths: f32,
  instanceFillColors: vec4<f32>,
  instanceLineColors: vec4<f32>,
  instancePickingColors: vec3<f32>
};

const constants = ConstantAttributes(
  vec3<f32>(0.0),
  vec3<f32>(0.0),
  0.0,
  0.0,
  vec4<f32>(0.0, 0.0, 0.0, 1.0),
  vec4<f32>(0.0, 0.0, 0.0, 1.0),
  vec3<f32>(0.0)
);

struct Attributes {
  @builtin(instance_index) instanceIndex : u32,
  @builtin(vertex_index) vertexIndex : u32,
  @location(0) positions: vec3<f32>,
  @location(1) instancePositions: vec3<f32>,
  @location(2) instancePositions64Low: vec3<f32>,
  @location(3) instanceRadius: f32,
  @location(4) instanceLineWidths: f32,
  @location(5) instanceFillColors: vec4<f32>,
  @location(6) instanceLineColors: vec4<f32>,
  @location(7) instancePickingColors: vec3<f32>
};

struct Varyings {
  @builtin(position) position: vec4<f32>,
  @location(0) vFillColor: vec4<f32>,
  @location(1) vLineColor: vec4<f32>,
  @location(2) unitPosition: vec2<f32>,
  @location(3) innerUnitRadius: f32,
  @location(4) outerRadiusPixels: f32,
};

@vertex
fn vertexMain(attributes: Attributes) -> Varyings {
  var varyings: Varyings;

  // Draw an inline geometry constant array clip space triangle to verify that rendering works.
  // var positions = array<vec2<f32>, 3>(vec2(0.0, 0.5), vec2(-0.5, -0.5), vec2(0.5, -0.5));
  // if (attributes.instanceIndex == 0) {
  //   varyings.position = vec4<f32>(positions[attributes.vertexIndex], 0.0, 1.0);
  //   return varyings;
  // }

  // var geometry: Geometry;
  // geometry.worldPosition = instancePositions;

  // Multiply out radius and clamp to limits
  varyings.outerRadiusPixels = clamp(
    project_unit_size_to_pixel(scatterplot.radiusScale * attributes.instanceRadius, scatterplot.radiusUnits),
    scatterplot.radiusMinPixels, scatterplot.radiusMaxPixels
  );

  // Multiply out line width and clamp to limits
  let lineWidthPixels = clamp(
    project_unit_size_to_pixel(scatterplot.lineWidthScale * attributes.instanceLineWidths, scatterplot.lineWidthUnits),
    scatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels
  );

  // outer radius needs to offset by half stroke width
  varyings.outerRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;
  // Expand geometry to accommodate edge smoothing
  let edgePadding = select(
    (varyings.outerRadiusPixels + SMOOTH_EDGE_RADIUS) / varyings.outerRadiusPixels,
    1.0,
    scatterplot.antialiasing != 0
  );

  // position on the containing square in [-1, 1] space
  varyings.unitPosition = edgePadding * attributes.positions.xy;
  geometry.uv = varyings.unitPosition;
  geometry.pickingColor = attributes.instancePickingColors;

  varyings.innerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / varyings.outerRadiusPixels;

  if (scatterplot.billboard != 0) {
    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, vec3<f32>(0.0)); // TODO , geometry.position);
    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);
    let offset = attributes.positions; // * edgePadding * varyings.outerRadiusPixels;
    // DECKGL_FILTER_SIZE(offset, geometry);
    let clipPixels = project_pixel_size_to_clipspace(offset.xy);
    varyings.position.x = clipPixels.x;
    varyings.position.y = clipPixels.y;
  } else {
    let offset = edgePadding * attributes.positions * project_pixel_size_float(varyings.outerRadiusPixels);
    // DECKGL_FILTER_SIZE(offset, geometry);
    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, offset); // TODO , geometry.position);
    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);
  }

  // Apply opacity to instance color, or return instance picking color
  varyings.vFillColor = vec4<f32>(attributes.instanceFillColors.rgb, attributes.instanceFillColors.a * color.opacity);
  // DECKGL_FILTER_COLOR(varyings.vFillColor, geometry);
  varyings.vLineColor = vec4<f32>(attributes.instanceLineColors.rgb, attributes.instanceLineColors.a * color.opacity);
  // DECKGL_FILTER_COLOR(varyings.vLineColor, geometry);

  return varyings;
}

@fragment
fn fragmentMain(varyings: Varyings) -> @location(0) vec4<f32> {
  // var geometry: Geometry;
  // geometry.uv = unitPosition;

  let distToCenter = length(varyings.unitPosition) * varyings.outerRadiusPixels;
  let inCircle = select(
    smoothedge(distToCenter, varyings.outerRadiusPixels),
    step(distToCenter, varyings.outerRadiusPixels),
    scatterplot.antialiasing != 0
  );

  if (inCircle == 0.0) {
    discard;
  }

  var fragColor: vec4<f32>;

  if (scatterplot.stroked != 0) {
    let isLine = select(
      smoothedge(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),
      step(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),
      scatterplot.antialiasing != 0
    );

    if (scatterplot.filled != 0) {
      fragColor = mix(varyings.vFillColor, varyings.vLineColor, isLine);
    } else {
      if (isLine == 0.0) {
        discard;
      }
      fragColor = vec4<f32>(varyings.vLineColor.rgb, varyings.vLineColor.a * isLine);
    }
  } else if (scatterplot.filled == 0) {
    discard;
  } else {
    fragColor = varyings.vFillColor;
  }

  fragColor.a *= inCircle;
  // DECKGL_FILTER_COLOR(fragColor, geometry);

  // Apply premultiplied alpha as required by transparent canvas
  fragColor = deckgl_premultiplied_alpha(fragColor);

  return fragColor;
  // return vec4<f32>(0, 0, 1, 1);
}
`;

//#endregion
//#region node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer.js
var DEFAULT_COLOR$4 = [
	0,
	0,
	0,
	255
];
var defaultProps$9 = {
	radiusUnits: "meters",
	radiusScale: {
		type: "number",
		min: 0,
		value: 1
	},
	radiusMinPixels: {
		type: "number",
		min: 0,
		value: 0
	},
	radiusMaxPixels: {
		type: "number",
		min: 0,
		value: Number.MAX_SAFE_INTEGER
	},
	lineWidthUnits: "meters",
	lineWidthScale: {
		type: "number",
		min: 0,
		value: 1
	},
	lineWidthMinPixels: {
		type: "number",
		min: 0,
		value: 0
	},
	lineWidthMaxPixels: {
		type: "number",
		min: 0,
		value: Number.MAX_SAFE_INTEGER
	},
	stroked: false,
	filled: true,
	billboard: false,
	antialiasing: true,
	getPosition: {
		type: "accessor",
		value: (x$1) => x$1.position
	},
	getRadius: {
		type: "accessor",
		value: 1
	},
	getFillColor: {
		type: "accessor",
		value: DEFAULT_COLOR$4
	},
	getLineColor: {
		type: "accessor",
		value: DEFAULT_COLOR$4
	},
	getLineWidth: {
		type: "accessor",
		value: 1
	},
	strokeWidth: { deprecatedFor: "getLineWidth" },
	outline: { deprecatedFor: "stroked" },
	getColor: { deprecatedFor: ["getFillColor", "getLineColor"] }
};
/** Render circles at given coordinates. */
var ScatterplotLayer = class extends layer_default {
	getShaders() {
		return super.getShaders({
			vs: scatterplot_layer_vertex_glsl_default,
			fs: scatterplot_layer_fragment_glsl_default,
			source: scatterplot_layer_wgsl_default,
			modules: [
				project32_default,
				color_default,
				picking_default,
				scatterplotUniforms
			]
		});
	}
	initializeState() {
		this.getAttributeManager().addInstanced({
			instancePositions: {
				size: 3,
				type: "float64",
				fp64: this.use64bitPositions(),
				transition: true,
				accessor: "getPosition"
			},
			instanceRadius: {
				size: 1,
				transition: true,
				accessor: "getRadius",
				defaultValue: 1
			},
			instanceFillColors: {
				size: this.props.colorFormat.length,
				transition: true,
				type: "unorm8",
				accessor: "getFillColor",
				defaultValue: [
					0,
					0,
					0,
					255
				]
			},
			instanceLineColors: {
				size: this.props.colorFormat.length,
				transition: true,
				type: "unorm8",
				accessor: "getLineColor",
				defaultValue: [
					0,
					0,
					0,
					255
				]
			},
			instanceLineWidths: {
				size: 1,
				transition: true,
				accessor: "getLineWidth",
				defaultValue: 1
			}
		});
	}
	updateState(params) {
		super.updateState(params);
		if (params.changeFlags.extensionsChanged) {
			this.state.model?.destroy();
			this.state.model = this._getModel();
			this.getAttributeManager().invalidateAll();
		}
	}
	draw({ uniforms }) {
		const { radiusUnits, radiusScale, radiusMinPixels, radiusMaxPixels, stroked, filled, billboard, antialiasing, lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels } = this.props;
		const scatterplotProps = {
			stroked,
			filled,
			billboard,
			antialiasing,
			radiusUnits: UNIT[radiusUnits],
			radiusScale,
			radiusMinPixels,
			radiusMaxPixels,
			lineWidthUnits: UNIT[lineWidthUnits],
			lineWidthScale,
			lineWidthMinPixels,
			lineWidthMaxPixels
		};
		const model = this.state.model;
		model.shaderInputs.setProps({ scatterplot: scatterplotProps });
		if (this.context.device.type === "webgpu") model.instanceCount = this.props.data.length;
		model.draw(this.context.renderPass);
	}
	_getModel() {
		const parameters = this.context.device.type === "webgpu" ? {
			depthWriteEnabled: true,
			depthCompare: "less-equal"
		} : void 0;
		const positions = [
			-1,
			-1,
			0,
			1,
			-1,
			0,
			-1,
			1,
			0,
			1,
			1,
			0
		];
		return new Model(this.context.device, {
			...this.getShaders(),
			id: this.props.id,
			bufferLayout: this.getAttributeManager().getBufferLayouts(),
			geometry: new Geometry({
				topology: "triangle-strip",
				attributes: { positions: {
					size: 3,
					value: new Float32Array(positions)
				} }
			}),
			isInstanced: true,
			parameters
		});
	}
};
ScatterplotLayer.defaultProps = defaultProps$9;
ScatterplotLayer.layerName = "ScatterplotLayer";
var scatterplot_layer_default = ScatterplotLayer;

//#endregion
//#region node_modules/@math.gl/polygon/dist/polygon-utils.js
const WINDING = {
	CLOCKWISE: 1,
	COUNTER_CLOCKWISE: -1
};
/**
* Checks winding direction of the polygon and reverses the polygon in case of opposite winding direction.
* Note: points are modified in-place.
* @param points An array that represents points of the polygon.
* @param direction Requested winding direction. 1 is for clockwise, -1 for counterclockwise winding direction.
* @param options Parameters of the polygon.
* @return Returns true if the winding direction was changed.
*/
function modifyPolygonWindingDirection(points, direction, options = {}) {
	if (getPolygonWindingDirection(points, options) !== direction) {
		reversePolygon(points, options);
		return true;
	}
	return false;
}
/**
* Returns winding direction of the polygon.
* @param points An array that represents points of the polygon.
* @param options Parameters of the polygon.
* @returns Winding direction of the polygon.
*/
function getPolygonWindingDirection(points, options = {}) {
	return Math.sign(getPolygonSignedArea(points, options));
}
const DimIndex = {
	x: 0,
	y: 1,
	z: 2
};
/**
* Returns signed area of the polygon.
* @param points An array that represents points of the polygon.
* @param options Parameters of the polygon.
* @returns Signed area of the polygon.
* https://en.wikipedia.org/wiki/Shoelace_formula
*/
function getPolygonSignedArea(points, options = {}) {
	const { start = 0, end = points.length, plane = "xy" } = options;
	const dim = options.size || 2;
	let area$1 = 0;
	const i0 = DimIndex[plane[0]];
	const i1 = DimIndex[plane[1]];
	for (let i$1 = start, j$1 = end - dim; i$1 < end; i$1 += dim) {
		area$1 += (points[i$1 + i0] - points[j$1 + i0]) * (points[i$1 + i1] + points[j$1 + i1]);
		j$1 = i$1;
	}
	return area$1 / 2;
}
function reversePolygon(points, options) {
	const { start = 0, end = points.length, size = 2 } = options;
	const numPoints = (end - start) / size;
	const numSwaps = Math.floor(numPoints / 2);
	for (let i$1 = 0; i$1 < numSwaps; ++i$1) {
		const b1 = start + i$1 * size;
		const b2 = start + (numPoints - 1 - i$1) * size;
		for (let j$1 = 0; j$1 < size; ++j$1) {
			const tmp = points[b1 + j$1];
			points[b1 + j$1] = points[b2 + j$1];
			points[b2 + j$1] = tmp;
		}
	}
}

//#endregion
//#region node_modules/@math.gl/polygon/dist/utils.js
function push(target, source) {
	const size = source.length;
	const startIndex = target.length;
	if (startIndex > 0) {
		let isDuplicate = true;
		for (let i$1 = 0; i$1 < size; i$1++) if (target[startIndex - size + i$1] !== source[i$1]) {
			isDuplicate = false;
			break;
		}
		if (isDuplicate) return false;
	}
	for (let i$1 = 0; i$1 < size; i$1++) target[startIndex + i$1] = source[i$1];
	return true;
}
function copy(target, source) {
	const size = source.length;
	for (let i$1 = 0; i$1 < size; i$1++) target[i$1] = source[i$1];
}
function getPointAtIndex(positions, index, size, offset, out = []) {
	const startI = offset + index * size;
	for (let i$1 = 0; i$1 < size; i$1++) out[i$1] = positions[startI + i$1];
	return out;
}

//#endregion
//#region node_modules/@math.gl/polygon/dist/lineclip.js
/** intersect a segment against one of the 4 lines that make up the bbox */
function intersect(a$1, b$1, edge, bbox, out = []) {
	let t$1;
	let snap;
	if (edge & 8) {
		t$1 = (bbox[3] - a$1[1]) / (b$1[1] - a$1[1]);
		snap = 3;
	} else if (edge & 4) {
		t$1 = (bbox[1] - a$1[1]) / (b$1[1] - a$1[1]);
		snap = 1;
	} else if (edge & 2) {
		t$1 = (bbox[2] - a$1[0]) / (b$1[0] - a$1[0]);
		snap = 2;
	} else if (edge & 1) {
		t$1 = (bbox[0] - a$1[0]) / (b$1[0] - a$1[0]);
		snap = 0;
	} else return null;
	for (let i$1 = 0; i$1 < a$1.length; i$1++) out[i$1] = (snap & 1) === i$1 ? bbox[snap] : t$1 * (b$1[i$1] - a$1[i$1]) + a$1[i$1];
	return out;
}
/**
* bit code reflects the point position relative to the bbox:
*         left  mid  right
*    top  1001  1000  1010
*    mid  0001  0000  0010
* bottom  0101  0100  0110
*/
function bitCode(p$1, bbox) {
	let code = 0;
	if (p$1[0] < bbox[0]) code |= 1;
	else if (p$1[0] > bbox[2]) code |= 2;
	if (p$1[1] < bbox[1]) code |= 4;
	else if (p$1[1] > bbox[3]) code |= 8;
	return code;
}

//#endregion
//#region node_modules/@math.gl/polygon/dist/cut-by-grid.js
function cutPolylineByGrid(positions, options) {
	const { size = 2, broken = false, gridResolution = 10, gridOffset = [0, 0], startIndex = 0, endIndex = positions.length } = options || {};
	const numPoints = (endIndex - startIndex) / size;
	let part = [];
	const result = [part];
	const a$1 = getPointAtIndex(positions, 0, size, startIndex);
	let b$1;
	let codeB;
	const cell = getGridCell(a$1, gridResolution, gridOffset, []);
	const scratchPoint = [];
	push(part, a$1);
	for (let i$1 = 1; i$1 < numPoints; i$1++) {
		b$1 = getPointAtIndex(positions, i$1, size, startIndex, b$1);
		codeB = bitCode(b$1, cell);
		while (codeB) {
			intersect(a$1, b$1, codeB, cell, scratchPoint);
			const codeAlt = bitCode(scratchPoint, cell);
			if (codeAlt) {
				intersect(a$1, scratchPoint, codeAlt, cell, scratchPoint);
				codeB = codeAlt;
			}
			push(part, scratchPoint);
			copy(a$1, scratchPoint);
			moveToNeighborCell(cell, gridResolution, codeB);
			if (broken && part.length > size) {
				part = [];
				result.push(part);
				push(part, a$1);
			}
			codeB = bitCode(b$1, cell);
		}
		push(part, b$1);
		copy(a$1, b$1);
	}
	return broken ? result : result[0];
}
var TYPE_INSIDE = 0;
var TYPE_BORDER = 1;
/**
* Cuts a polygon by a pre-defined grid
*/
function cutPolygonByGrid(positions, holeIndices = null, options) {
	if (!positions.length) return [];
	const { size = 2, gridResolution = 10, gridOffset = [0, 0], edgeTypes = false } = options || {};
	const result = [];
	const queue = [{
		pos: positions,
		types: edgeTypes ? new Array(positions.length / size).fill(TYPE_BORDER) : null,
		holes: holeIndices || []
	}];
	const bbox = [[], []];
	let cell = [];
	while (queue.length) {
		const { pos, types, holes } = queue.shift();
		getBoundingBox(pos, size, holes[0] || pos.length, bbox);
		cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);
		const code = bitCode(bbox[1], cell);
		if (code) {
			let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);
			const polygonLow = {
				pos: parts[0].pos,
				types: parts[0].types,
				holes: []
			};
			const polygonHigh = {
				pos: parts[1].pos,
				types: parts[1].types,
				holes: []
			};
			queue.push(polygonLow, polygonHigh);
			for (let i$1 = 0; i$1 < holes.length; i$1++) {
				parts = bisectPolygon(pos, types, size, holes[i$1], holes[i$1 + 1] || pos.length, cell, code);
				if (parts[0]) {
					polygonLow.holes.push(polygonLow.pos.length);
					polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);
					if (edgeTypes) polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);
				}
				if (parts[1]) {
					polygonHigh.holes.push(polygonHigh.pos.length);
					polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);
					if (edgeTypes) polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);
				}
			}
		} else {
			const polygon = { positions: pos };
			if (edgeTypes) polygon.edgeTypes = types;
			if (holes.length) polygon.holeIndices = holes;
			result.push(polygon);
		}
	}
	return result;
}
function bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {
	const numPoints = (endIndex - startIndex) / size;
	const resultLow = [];
	const resultHigh = [];
	const typesLow = [];
	const typesHigh = [];
	const scratchPoint = [];
	let p$1;
	let side;
	let type;
	const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);
	let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);
	let prevType = edgeTypes && edgeTypes[numPoints - 1];
	let lowPointCount = 0;
	let highPointCount = 0;
	for (let i$1 = 0; i$1 < numPoints; i$1++) {
		p$1 = getPointAtIndex(positions, i$1, size, startIndex, p$1);
		side = Math.sign(edge & 8 ? p$1[1] - bbox[3] : p$1[0] - bbox[2]);
		type = edgeTypes && edgeTypes[startIndex / size + i$1];
		if (side && prevSide && prevSide !== side) {
			intersect(prev, p$1, edge, bbox, scratchPoint);
			push(resultLow, scratchPoint) && typesLow.push(prevType);
			push(resultHigh, scratchPoint) && typesHigh.push(prevType);
		}
		if (side <= 0) {
			push(resultLow, p$1) && typesLow.push(type);
			lowPointCount -= side;
		} else if (typesLow.length) typesLow[typesLow.length - 1] = TYPE_INSIDE;
		if (side >= 0) {
			push(resultHigh, p$1) && typesHigh.push(type);
			highPointCount += side;
		} else if (typesHigh.length) typesHigh[typesHigh.length - 1] = TYPE_INSIDE;
		copy(prev, p$1);
		prevSide = side;
		prevType = type;
	}
	return [lowPointCount ? {
		pos: resultLow,
		types: edgeTypes && typesLow
	} : null, highPointCount ? {
		pos: resultHigh,
		types: edgeTypes && typesHigh
	} : null];
}
function getGridCell(p$1, gridResolution, gridOffset, out) {
	const left = Math.floor((p$1[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];
	const bottom = Math.floor((p$1[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];
	out[0] = left;
	out[1] = bottom;
	out[2] = left + gridResolution;
	out[3] = bottom + gridResolution;
	return out;
}
function moveToNeighborCell(cell, gridResolution, edge) {
	if (edge & 8) {
		cell[1] += gridResolution;
		cell[3] += gridResolution;
	} else if (edge & 4) {
		cell[1] -= gridResolution;
		cell[3] -= gridResolution;
	} else if (edge & 2) {
		cell[0] += gridResolution;
		cell[2] += gridResolution;
	} else if (edge & 1) {
		cell[0] -= gridResolution;
		cell[2] -= gridResolution;
	}
}
function getBoundingBox(positions, size, endIndex, out) {
	let minX = Infinity;
	let maxX = -Infinity;
	let minY = Infinity;
	let maxY = -Infinity;
	for (let i$1 = 0; i$1 < endIndex; i$1 += size) {
		const x$1 = positions[i$1];
		const y$1 = positions[i$1 + 1];
		minX = x$1 < minX ? x$1 : minX;
		maxX = x$1 > maxX ? x$1 : maxX;
		minY = y$1 < minY ? y$1 : minY;
		maxY = y$1 > maxY ? y$1 : maxY;
	}
	out[0][0] = minX;
	out[0][1] = minY;
	out[1][0] = maxX;
	out[1][1] = maxY;
	return out;
}
function concatInPlace(arr1, arr2) {
	for (let i$1 = 0; i$1 < arr2.length; i$1++) arr1.push(arr2[i$1]);
	return arr1;
}

//#endregion
//#region node_modules/@math.gl/polygon/dist/cut-by-mercator-bounds.js
var DEFAULT_MAX_LATITUDE = 85.051129;
/** https://user-images.githubusercontent.com/2059298/78465769-938b7a00-76ae-11ea-9b95-1f4c26425ab9.png */
function cutPolylineByMercatorBounds(positions, options) {
	const { size = 2, startIndex = 0, endIndex = positions.length, normalize: normalize$1 = true } = options || {};
	const newPositions = positions.slice(startIndex, endIndex);
	wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);
	const parts = cutPolylineByGrid(newPositions, {
		size,
		broken: true,
		gridResolution: 360,
		gridOffset: [-180, -180]
	});
	if (normalize$1) for (const part of parts) shiftLongitudesIntoRange(part, size);
	return parts;
}
/** https://user-images.githubusercontent.com/2059298/78465770-94241080-76ae-11ea-809a-6a8534dac1d9.png */
function cutPolygonByMercatorBounds(positions, holeIndices = null, options) {
	const { size = 2, normalize: normalize$1 = true, edgeTypes = false } = options || {};
	holeIndices = holeIndices || [];
	const newPositions = [];
	const newHoleIndices = [];
	let srcStartIndex = 0;
	let targetIndex = 0;
	for (let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {
		const srcEndIndex = holeIndices[ringIndex] || positions.length;
		const targetStartIndex = targetIndex;
		const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);
		for (let i$1 = splitIndex; i$1 < srcEndIndex; i$1++) newPositions[targetIndex++] = positions[i$1];
		for (let i$1 = srcStartIndex; i$1 < splitIndex; i$1++) newPositions[targetIndex++] = positions[i$1];
		wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);
		insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options?.maxLatitude);
		srcStartIndex = srcEndIndex;
		newHoleIndices[ringIndex] = targetIndex;
	}
	newHoleIndices.pop();
	const parts = cutPolygonByGrid(newPositions, newHoleIndices, {
		size,
		gridResolution: 360,
		gridOffset: [-180, -180],
		edgeTypes
	});
	if (normalize$1) for (const part of parts) shiftLongitudesIntoRange(part.positions, size);
	return parts;
}
function findSplitIndex(positions, size, startIndex, endIndex) {
	let maxLat = -1;
	let pointIndex = -1;
	for (let i$1 = startIndex + 1; i$1 < endIndex; i$1 += size) {
		const lat = Math.abs(positions[i$1]);
		if (lat > maxLat) {
			maxLat = lat;
			pointIndex = i$1 - 1;
		}
	}
	return pointIndex;
}
function insertPoleVertices(positions, size, startIndex, endIndex, maxLatitude = DEFAULT_MAX_LATITUDE) {
	const firstLng = positions[startIndex];
	const lastLng = positions[endIndex - size];
	if (Math.abs(firstLng - lastLng) > 180) {
		const p$1 = getPointAtIndex(positions, 0, size, startIndex);
		p$1[0] += Math.round((lastLng - firstLng) / 360) * 360;
		push(positions, p$1);
		p$1[1] = Math.sign(p$1[1]) * maxLatitude;
		push(positions, p$1);
		p$1[0] = firstLng;
		push(positions, p$1);
	}
}
function wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {
	let prevLng = positions[0];
	let lng;
	for (let i$1 = startIndex; i$1 < endIndex; i$1 += size) {
		lng = positions[i$1];
		const delta = lng - prevLng;
		if (delta > 180 || delta < -180) lng -= Math.round(delta / 360) * 360;
		positions[i$1] = prevLng = lng;
	}
}
function shiftLongitudesIntoRange(positions, size) {
	let refLng;
	const pointCount = positions.length / size;
	for (let i$1 = 0; i$1 < pointCount; i$1++) {
		refLng = positions[i$1 * size];
		if ((refLng + 180) % 360 !== 0) break;
	}
	const delta = -Math.round(refLng / 360) * 360;
	if (delta === 0) return;
	for (let i$1 = 0; i$1 < pointCount; i$1++) positions[i$1 * size] += delta;
}

//#endregion
//#region node_modules/@deck.gl/layers/dist/column-layer/column-geometry.js
var ColumnGeometry = class extends Geometry {
	constructor(props) {
		const { indices, attributes } = tesselateColumn(props);
		super({
			...props,
			indices,
			attributes
		});
	}
};
function tesselateColumn(props) {
	const { radius, height = 1, nradial = 10 } = props;
	let { vertices } = props;
	if (vertices) {
		log_default.assert(vertices.length >= nradial);
		vertices = vertices.flatMap((v$1) => [v$1[0], v$1[1]]);
		modifyPolygonWindingDirection(vertices, WINDING.COUNTER_CLOCKWISE);
	}
	const isExtruded = height > 0;
	const vertsAroundEdge = nradial + 1;
	const numVertices = isExtruded ? vertsAroundEdge * 3 + 1 : nradial;
	const stepAngle = Math.PI * 2 / nradial;
	const indices = new Uint16Array(isExtruded ? nradial * 3 * 2 : 0);
	const positions = new Float32Array(numVertices * 3);
	const normals = new Float32Array(numVertices * 3);
	let i$1 = 0;
	if (isExtruded) {
		for (let j$1 = 0; j$1 < vertsAroundEdge; j$1++) {
			const a$1 = j$1 * stepAngle;
			const vertexIndex = j$1 % nradial;
			const sin = Math.sin(a$1);
			const cos = Math.cos(a$1);
			for (let k$1 = 0; k$1 < 2; k$1++) {
				positions[i$1 + 0] = vertices ? vertices[vertexIndex * 2] : cos * radius;
				positions[i$1 + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin * radius;
				positions[i$1 + 2] = (1 / 2 - k$1) * height;
				normals[i$1 + 0] = vertices ? vertices[vertexIndex * 2] : cos;
				normals[i$1 + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin;
				i$1 += 3;
			}
		}
		positions[i$1 + 0] = positions[i$1 - 3];
		positions[i$1 + 1] = positions[i$1 - 2];
		positions[i$1 + 2] = positions[i$1 - 1];
		i$1 += 3;
	}
	for (let j$1 = isExtruded ? 0 : 1; j$1 < vertsAroundEdge; j$1++) {
		const v$1 = Math.floor(j$1 / 2) * Math.sign(.5 - j$1 % 2);
		const a$1 = v$1 * stepAngle;
		const vertexIndex = (v$1 + nradial) % nradial;
		const sin = Math.sin(a$1);
		const cos = Math.cos(a$1);
		positions[i$1 + 0] = vertices ? vertices[vertexIndex * 2] : cos * radius;
		positions[i$1 + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin * radius;
		positions[i$1 + 2] = height / 2;
		normals[i$1 + 2] = 1;
		i$1 += 3;
	}
	if (isExtruded) {
		let index = 0;
		for (let j$1 = 0; j$1 < nradial; j$1++) {
			indices[index++] = j$1 * 2 + 0;
			indices[index++] = j$1 * 2 + 2;
			indices[index++] = j$1 * 2 + 0;
			indices[index++] = j$1 * 2 + 1;
			indices[index++] = j$1 * 2 + 1;
			indices[index++] = j$1 * 2 + 3;
		}
	}
	return {
		indices,
		attributes: {
			POSITION: {
				size: 3,
				value: positions
			},
			NORMAL: {
				size: 3,
				value: normals
			}
		}
	};
}

//#endregion
//#region node_modules/@deck.gl/layers/dist/column-layer/column-layer-uniforms.js
var uniformBlock$4 = `\
uniform columnUniforms {
  float radius;
  float angle;
  vec2 offset;
  bool extruded;
  bool stroked;
  bool isStroke;
  float coverage;
  float elevationScale;
  float edgeDistance;
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  highp int radiusUnits;
  highp int widthUnits;
} column;
`;
const columnUniforms = {
	name: "column",
	vs: uniformBlock$4,
	fs: uniformBlock$4,
	uniformTypes: {
		radius: "f32",
		angle: "f32",
		offset: "vec2<f32>",
		extruded: "f32",
		stroked: "f32",
		isStroke: "f32",
		coverage: "f32",
		elevationScale: "f32",
		edgeDistance: "f32",
		widthScale: "f32",
		widthMinPixels: "f32",
		widthMaxPixels: "f32",
		radiusUnits: "i32",
		widthUnits: "i32"
	}
};

//#endregion
//#region node_modules/@deck.gl/layers/dist/column-layer/column-layer-vertex.glsl.js
var column_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME column-layer-vertex-shader
in vec3 positions;
in vec3 normals;
in vec3 instancePositions;
in float instanceElevations;
in vec3 instancePositions64Low;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in float instanceStrokeWidths;
in vec3 instancePickingColors;
out vec4 vColor;
#ifdef FLAT_SHADING
out vec3 cameraPosition;
out vec4 position_commonspace;
#endif
void main(void) {
geometry.worldPosition = instancePositions;
vec4 color = column.isStroke ? instanceLineColors : instanceFillColors;
mat2 rotationMatrix = mat2(cos(column.angle), sin(column.angle), -sin(column.angle), cos(column.angle));
float elevation = 0.0;
float strokeOffsetRatio = 1.0;
if (column.extruded) {
elevation = instanceElevations * (positions.z + 1.0) / 2.0 * column.elevationScale;
} else if (column.stroked) {
float widthPixels = clamp(
project_size_to_pixel(instanceStrokeWidths * column.widthScale, column.widthUnits),
column.widthMinPixels, column.widthMaxPixels) / 2.0;
float halfOffset = project_pixel_size(widthPixels) / project_size(column.edgeDistance * column.coverage * column.radius);
if (column.isStroke) {
strokeOffsetRatio -= sign(positions.z) * halfOffset;
} else {
strokeOffsetRatio -= halfOffset;
}
}
float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);
float dotRadius = column.radius * column.coverage * shouldRender;
geometry.pickingColor = instancePickingColors;
vec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);
vec3 centroidPosition64Low = instancePositions64Low;
vec2 offset = (rotationMatrix * positions.xy * strokeOffsetRatio + column.offset) * dotRadius;
if (column.radiusUnits == UNIT_METERS) {
offset = project_size(offset);
}
vec3 pos = vec3(offset, 0.);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);
geometry.normal = project_normal(vec3(rotationMatrix * normals.xy, normals.z));
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
if (column.extruded && !column.isStroke) {
#ifdef FLAT_SHADING
cameraPosition = project.cameraPosition;
position_commonspace = geometry.position;
vColor = vec4(color.rgb, color.a * layer.opacity);
#else
vec3 lightColor = lighting_getLightColor(color.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, color.a * layer.opacity);
#endif
} else {
vColor = vec4(color.rgb, color.a * layer.opacity);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

//#endregion
//#region node_modules/@deck.gl/layers/dist/column-layer/column-layer-fragment.glsl.js
var column_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME column-layer-fragment-shader
precision highp float;
out vec4 fragColor;
in vec4 vColor;
#ifdef FLAT_SHADING
in vec3 cameraPosition;
in vec4 position_commonspace;
#endif
void main(void) {
fragColor = vColor;
geometry.uv = vec2(0.);
#ifdef FLAT_SHADING
if (column.extruded && !column.isStroke && !bool(picking.isActive)) {
vec3 normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
fragColor.rgb = lighting_getLightColor(vColor.rgb, cameraPosition, position_commonspace.xyz, normal);
}
#endif
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

//#endregion
//#region node_modules/@deck.gl/layers/dist/column-layer/column-layer.js
var DEFAULT_COLOR$3 = [
	0,
	0,
	0,
	255
];
var defaultProps$8 = {
	diskResolution: {
		type: "number",
		min: 4,
		value: 20
	},
	vertices: null,
	radius: {
		type: "number",
		min: 0,
		value: 1e3
	},
	angle: {
		type: "number",
		value: 0
	},
	offset: {
		type: "array",
		value: [0, 0]
	},
	coverage: {
		type: "number",
		min: 0,
		max: 1,
		value: 1
	},
	elevationScale: {
		type: "number",
		min: 0,
		value: 1
	},
	radiusUnits: "meters",
	lineWidthUnits: "meters",
	lineWidthScale: 1,
	lineWidthMinPixels: 0,
	lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
	extruded: true,
	wireframe: false,
	filled: true,
	stroked: false,
	flatShading: false,
	getPosition: {
		type: "accessor",
		value: (x$1) => x$1.position
	},
	getFillColor: {
		type: "accessor",
		value: DEFAULT_COLOR$3
	},
	getLineColor: {
		type: "accessor",
		value: DEFAULT_COLOR$3
	},
	getLineWidth: {
		type: "accessor",
		value: 1
	},
	getElevation: {
		type: "accessor",
		value: 1e3
	},
	material: true,
	getColor: { deprecatedFor: ["getFillColor", "getLineColor"] }
};
/** Render extruded cylinders (tessellated regular polygons) at given coordinates. */
var ColumnLayer = class extends layer_default {
	getShaders() {
		const defines = {};
		const { flatShading } = this.props;
		if (flatShading) defines.FLAT_SHADING = 1;
		return super.getShaders({
			vs: column_layer_vertex_glsl_default,
			fs: column_layer_fragment_glsl_default,
			defines,
			modules: [
				project32_default,
				flatShading ? phongMaterial : gouraudMaterial,
				picking_default,
				columnUniforms
			]
		});
	}
	/**
	* DeckGL calls initializeState when GL context is available
	* Essentially a deferred constructor
	*/
	initializeState() {
		this.getAttributeManager().addInstanced({
			instancePositions: {
				size: 3,
				type: "float64",
				fp64: this.use64bitPositions(),
				transition: true,
				accessor: "getPosition"
			},
			instanceElevations: {
				size: 1,
				transition: true,
				accessor: "getElevation"
			},
			instanceFillColors: {
				size: this.props.colorFormat.length,
				type: "unorm8",
				transition: true,
				accessor: "getFillColor",
				defaultValue: DEFAULT_COLOR$3
			},
			instanceLineColors: {
				size: this.props.colorFormat.length,
				type: "unorm8",
				transition: true,
				accessor: "getLineColor",
				defaultValue: DEFAULT_COLOR$3
			},
			instanceStrokeWidths: {
				size: 1,
				accessor: "getLineWidth",
				transition: true
			}
		});
	}
	updateState(params) {
		super.updateState(params);
		const { props, oldProps, changeFlags } = params;
		const regenerateModels = changeFlags.extensionsChanged || props.flatShading !== oldProps.flatShading;
		if (regenerateModels) {
			this.state.models?.forEach((model) => model.destroy());
			this.setState(this._getModels());
			this.getAttributeManager().invalidateAll();
		}
		const instanceCount = this.getNumInstances();
		this.state.fillModel.setInstanceCount(instanceCount);
		this.state.wireframeModel.setInstanceCount(instanceCount);
		if (regenerateModels || props.diskResolution !== oldProps.diskResolution || props.vertices !== oldProps.vertices || (props.extruded || props.stroked) !== (oldProps.extruded || oldProps.stroked)) this._updateGeometry(props);
	}
	getGeometry(diskResolution, vertices, hasThinkness) {
		const geometry = new ColumnGeometry({
			radius: 1,
			height: hasThinkness ? 2 : 0,
			vertices,
			nradial: diskResolution
		});
		let meanVertexDistance = 0;
		if (vertices) for (let i$1 = 0; i$1 < diskResolution; i$1++) {
			const p$1 = vertices[i$1];
			const d$1 = Math.sqrt(p$1[0] * p$1[0] + p$1[1] * p$1[1]);
			meanVertexDistance += d$1 / diskResolution;
		}
		else meanVertexDistance = 1;
		this.setState({ edgeDistance: Math.cos(Math.PI / diskResolution) * meanVertexDistance });
		return geometry;
	}
	_getModels() {
		const shaders = this.getShaders();
		const bufferLayout = this.getAttributeManager().getBufferLayouts();
		const fillModel = new Model(this.context.device, {
			...shaders,
			id: `${this.props.id}-fill`,
			bufferLayout,
			isInstanced: true
		});
		const wireframeModel = new Model(this.context.device, {
			...shaders,
			id: `${this.props.id}-wireframe`,
			bufferLayout,
			isInstanced: true
		});
		return {
			fillModel,
			wireframeModel,
			models: [wireframeModel, fillModel]
		};
	}
	_updateGeometry({ diskResolution, vertices, extruded, stroked }) {
		const geometry = this.getGeometry(diskResolution, vertices, extruded || stroked);
		this.setState({ fillVertexCount: geometry.attributes.POSITION.value.length / 3 });
		const fillModel = this.state.fillModel;
		const wireframeModel = this.state.wireframeModel;
		fillModel.setGeometry(geometry);
		fillModel.setTopology("triangle-strip");
		fillModel.setIndexBuffer(null);
		wireframeModel.setGeometry(geometry);
		wireframeModel.setTopology("line-list");
	}
	draw({ uniforms }) {
		const { lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels, radiusUnits, elevationScale, extruded, filled, stroked, wireframe, offset, coverage, radius, angle } = this.props;
		const fillModel = this.state.fillModel;
		const wireframeModel = this.state.wireframeModel;
		const { fillVertexCount, edgeDistance } = this.state;
		const columnProps = {
			radius,
			angle: angle / 180 * Math.PI,
			offset,
			extruded,
			stroked,
			coverage,
			elevationScale,
			edgeDistance,
			radiusUnits: UNIT[radiusUnits],
			widthUnits: UNIT[lineWidthUnits],
			widthScale: lineWidthScale,
			widthMinPixels: lineWidthMinPixels,
			widthMaxPixels: lineWidthMaxPixels
		};
		if (extruded && wireframe) {
			wireframeModel.shaderInputs.setProps({ column: {
				...columnProps,
				isStroke: true
			} });
			wireframeModel.draw(this.context.renderPass);
		}
		if (filled) {
			fillModel.setVertexCount(fillVertexCount);
			fillModel.shaderInputs.setProps({ column: {
				...columnProps,
				isStroke: false
			} });
			fillModel.draw(this.context.renderPass);
		}
		if (!extruded && stroked) {
			fillModel.setVertexCount(fillVertexCount * 2 / 3);
			fillModel.shaderInputs.setProps({ column: {
				...columnProps,
				isStroke: true
			} });
			fillModel.draw(this.context.renderPass);
		}
	}
};
ColumnLayer.layerName = "ColumnLayer";
ColumnLayer.defaultProps = defaultProps$8;
var column_layer_default = ColumnLayer;

//#endregion
//#region node_modules/@deck.gl/layers/dist/column-layer/grid-cell-layer.js
var defaultProps$7 = {
	cellSize: {
		type: "number",
		min: 0,
		value: 1e3
	},
	offset: {
		type: "array",
		value: [1, 1]
	}
};
var GridCellLayer = class extends column_layer_default {
	_updateGeometry() {
		const geometry = new CubeGeometry();
		this.state.fillModel.setGeometry(geometry);
	}
	draw({ uniforms }) {
		const { elevationScale, extruded, offset, coverage, cellSize, angle, radiusUnits } = this.props;
		const fillModel = this.state.fillModel;
		const columnProps = {
			radius: cellSize / 2,
			radiusUnits: UNIT[radiusUnits],
			angle,
			offset,
			extruded,
			stroked: false,
			coverage,
			elevationScale,
			edgeDistance: 1,
			isStroke: false,
			widthUnits: 0,
			widthScale: 0,
			widthMinPixels: 0,
			widthMaxPixels: 0
		};
		fillModel.shaderInputs.setProps({ column: columnProps });
		fillModel.draw(this.context.renderPass);
	}
};
GridCellLayer.layerName = "GridCellLayer";
GridCellLayer.defaultProps = defaultProps$7;
var grid_cell_layer_default = GridCellLayer;

//#endregion
//#region node_modules/@deck.gl/layers/dist/path-layer/path.js
/**
* Flattens a nested path object
* Cut the feature if needed (globe projection, wrap longitude, etc.)
* Returns a flat array of path positions, or a list of flat arrays representing multiple paths
*/
function normalizePath(path, size, gridResolution, wrapLongitude) {
	let flatPath;
	if (Array.isArray(path[0])) {
		const length = path.length * size;
		flatPath = new Array(length);
		for (let i$1 = 0; i$1 < path.length; i$1++) for (let j$1 = 0; j$1 < size; j$1++) flatPath[i$1 * size + j$1] = path[i$1][j$1] || 0;
	} else flatPath = path;
	if (gridResolution) return cutPolylineByGrid(flatPath, {
		size,
		gridResolution
	});
	if (wrapLongitude) return cutPolylineByMercatorBounds(flatPath, { size });
	return flatPath;
}

//#endregion
//#region node_modules/@deck.gl/layers/dist/path-layer/path-tesselator.js
var START_CAP = 1;
var END_CAP = 2;
var INVALID = 4;
var PathTesselator = class extends Tesselator {
	constructor(opts) {
		super({
			...opts,
			attributes: {
				positions: {
					size: 3,
					padding: 18,
					initialize: true,
					type: opts.fp64 ? Float64Array : Float32Array
				},
				segmentTypes: {
					size: 1,
					type: Uint8ClampedArray
				}
			}
		});
	}
	/** Get packed attribute by name */
	get(attributeName) {
		return this.attributes[attributeName];
	}
	getGeometryFromBuffer(buffer) {
		if (this.normalize) return super.getGeometryFromBuffer(buffer);
		return null;
	}
	normalizeGeometry(path) {
		if (this.normalize) return normalizePath(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);
		return path;
	}
	getGeometrySize(path) {
		if (isCut$1(path)) {
			let size = 0;
			for (const subPath of path) size += this.getGeometrySize(subPath);
			return size;
		}
		const numPoints = this.getPathLength(path);
		if (numPoints < 2) return 0;
		if (this.isClosed(path)) return numPoints < 3 ? 0 : numPoints + 2;
		return numPoints;
	}
	updateGeometryAttributes(path, context) {
		if (context.geometrySize === 0) return;
		if (path && isCut$1(path)) for (const subPath of path) {
			const geometrySize = this.getGeometrySize(subPath);
			context.geometrySize = geometrySize;
			this.updateGeometryAttributes(subPath, context);
			context.vertexStart += geometrySize;
		}
		else {
			this._updateSegmentTypes(path, context);
			this._updatePositions(path, context);
		}
	}
	_updateSegmentTypes(path, context) {
		const segmentTypes = this.attributes.segmentTypes;
		const isPathClosed = path ? this.isClosed(path) : false;
		const { vertexStart, geometrySize } = context;
		segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);
		if (isPathClosed) {
			segmentTypes[vertexStart] = INVALID;
			segmentTypes[vertexStart + geometrySize - 2] = INVALID;
		} else {
			segmentTypes[vertexStart] += START_CAP;
			segmentTypes[vertexStart + geometrySize - 2] += END_CAP;
		}
		segmentTypes[vertexStart + geometrySize - 1] = INVALID;
	}
	_updatePositions(path, context) {
		const { positions } = this.attributes;
		if (!positions || !path) return;
		const { vertexStart, geometrySize } = context;
		const p$1 = new Array(3);
		for (let i$1 = vertexStart, ptIndex = 0; ptIndex < geometrySize; i$1++, ptIndex++) {
			this.getPointOnPath(path, ptIndex, p$1);
			positions[i$1 * 3] = p$1[0];
			positions[i$1 * 3 + 1] = p$1[1];
			positions[i$1 * 3 + 2] = p$1[2];
		}
	}
	/** Returns the number of points in the path */
	getPathLength(path) {
		return path.length / this.positionSize;
	}
	/** Returns a point on the path at the specified index */
	getPointOnPath(path, index, target = []) {
		const { positionSize } = this;
		if (index * positionSize >= path.length) index += 1 - path.length / positionSize;
		const i$1 = index * positionSize;
		target[0] = path[i$1];
		target[1] = path[i$1 + 1];
		target[2] = positionSize === 3 && path[i$1 + 2] || 0;
		return target;
	}
	isClosed(path) {
		if (!this.normalize) return Boolean(this.opts.loop);
		const { positionSize } = this;
		const lastPointIndex = path.length - positionSize;
		return path[0] === path[lastPointIndex] && path[1] === path[lastPointIndex + 1] && (positionSize === 2 || path[2] === path[lastPointIndex + 2]);
	}
};
function isCut$1(path) {
	return Array.isArray(path[0]);
}

//#endregion
//#region node_modules/@deck.gl/layers/dist/path-layer/path-layer-uniforms.js
var uniformBlock$3 = `\
uniform pathUniforms {
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  float jointType;
  float capType;
  float miterLimit;
  bool billboard;
  highp int widthUnits;
} path;
`;
const pathUniforms = {
	name: "path",
	vs: uniformBlock$3,
	fs: uniformBlock$3,
	uniformTypes: {
		widthScale: "f32",
		widthMinPixels: "f32",
		widthMaxPixels: "f32",
		jointType: "f32",
		capType: "f32",
		miterLimit: "f32",
		billboard: "f32",
		widthUnits: "i32"
	}
};

//#endregion
//#region node_modules/@deck.gl/layers/dist/path-layer/path-layer-vertex.glsl.js
var path_layer_vertex_glsl_default = `\
#version 300 es
#define SHADER_NAME path-layer-vertex-shader
in vec2 positions;
in float instanceTypes;
in vec3 instanceStartPositions;
in vec3 instanceEndPositions;
in vec3 instanceLeftPositions;
in vec3 instanceRightPositions;
in vec3 instanceLeftPositions64Low;
in vec3 instanceStartPositions64Low;
in vec3 instanceEndPositions64Low;
in vec3 instanceRightPositions64Low;
in float instanceStrokeWidths;
in vec4 instanceColors;
in vec3 instancePickingColors;
uniform float opacity;
out vec4 vColor;
out vec2 vCornerOffset;
out float vMiterLength;
out vec2 vPathPosition;
out float vPathLength;
out float vJointType;
const float EPSILON = 0.001;
const vec3 ZERO_OFFSET = vec3(0.0);
float flipIfTrue(bool flag) {
return -(float(flag) * 2. - 1.);
}
vec3 getLineJoinOffset(
vec3 prevPoint, vec3 currPoint, vec3 nextPoint,
vec2 width
) {
bool isEnd = positions.x > 0.0;
float sideOfPath = positions.y;
float isJoint = float(sideOfPath == 0.0);
vec3 deltaA3 = (currPoint - prevPoint);
vec3 deltaB3 = (nextPoint - currPoint);
mat3 rotationMatrix;
bool needsRotation = !path.billboard && project_needs_rotation(currPoint, rotationMatrix);
if (needsRotation) {
deltaA3 = deltaA3 * rotationMatrix;
deltaB3 = deltaB3 * rotationMatrix;
}
vec2 deltaA = deltaA3.xy / width;
vec2 deltaB = deltaB3.xy / width;
float lenA = length(deltaA);
float lenB = length(deltaB);
vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);
vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);
vec2 perpA = vec2(-dirA.y, dirA.x);
vec2 perpB = vec2(-dirB.y, dirB.x);
vec2 tangent = dirA + dirB;
tangent = length(tangent) > 0. ? normalize(tangent) : perpA;
vec2 miterVec = vec2(-tangent.y, tangent.x);
vec2 dir = isEnd ? dirA : dirB;
vec2 perp = isEnd ? perpA : perpB;
float L = isEnd ? lenA : lenB;
float sinHalfA = abs(dot(miterVec, perp));
float cosHalfA = abs(dot(dirA, miterVec));
float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);
float cornerPosition = sideOfPath * turnDirection;
float miterSize = 1.0 / max(sinHalfA, EPSILON);
miterSize = mix(
min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),
miterSize,
step(0.0, cornerPosition)
);
vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))
* (sideOfPath + isJoint * turnDirection);
bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));
bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));
bool isCap = isStartCap || isEndCap;
if (isCap) {
offsetVec = mix(perp * sideOfPath, dir * path.capType * 4.0 * flipIfTrue(isStartCap), isJoint);
vJointType = path.capType;
} else {
vJointType = path.jointType;
}
vPathLength = L;
vCornerOffset = offsetVec;
vMiterLength = dot(vCornerOffset, miterVec * turnDirection);
vMiterLength = isCap ? isJoint : vMiterLength;
vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);
vPathPosition = vec2(
dot(offsetFromStartOfPath, perp),
dot(offsetFromStartOfPath, dir)
);
geometry.uv = vPathPosition;
float isValid = step(instanceTypes, 3.5);
vec3 offset = vec3(offsetVec * width * isValid, 0.0);
if (needsRotation) {
offset = rotationMatrix * offset;
}
return offset;
}
void clipLine(inout vec4 position, vec4 refPosition) {
if (position.w < EPSILON) {
float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);
position = refPosition + (position - refPosition) * r;
}
}
void main() {
geometry.pickingColor = instancePickingColors;
vColor = vec4(instanceColors.rgb, instanceColors.a * layer.opacity);
float isEnd = positions.x;
vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);
vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);
vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);
vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);
vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);
vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);
geometry.worldPosition = currPosition;
vec2 widthPixels = vec2(clamp(
project_size_to_pixel(instanceStrokeWidths * path.widthScale, path.widthUnits),
path.widthMinPixels, path.widthMaxPixels) / 2.0);
vec3 width;
if (path.billboard) {
vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);
vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);
vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);
clipLine(prevPositionScreen, currPositionScreen);
clipLine(nextPositionScreen, currPositionScreen);
clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));
width = vec3(widthPixels, 0.0);
DECKGL_FILTER_SIZE(width, geometry);
vec3 offset = getLineJoinOffset(
prevPositionScreen.xyz / prevPositionScreen.w,
currPositionScreen.xyz / currPositionScreen.w,
nextPositionScreen.xyz / nextPositionScreen.w,
project_pixel_size_to_clipspace(width.xy)
);
DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);
gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);
} else {
prevPosition = project_position(prevPosition, prevPosition64Low);
currPosition = project_position(currPosition, currPosition64Low);
nextPosition = project_position(nextPosition, nextPosition64Low);
width = vec3(project_pixel_size(widthPixels), 0.0);
DECKGL_FILTER_SIZE(width, geometry);
vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);
geometry.position = vec4(currPosition + offset, 1.0);
gl_Position = project_common_position_to_clipspace(geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

//#endregion
//#region node_modules/@deck.gl/layers/dist/path-layer/path-layer-fragment.glsl.js
var path_layer_fragment_glsl_default = `\
#version 300 es
#define SHADER_NAME path-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 vCornerOffset;
in float vMiterLength;
in vec2 vPathPosition;
in float vPathLength;
in float vJointType;
out vec4 fragColor;
void main(void) {
geometry.uv = vPathPosition;
if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {
if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {
discard;
}
if (vJointType < 0.5 && vMiterLength > path.miterLimit + 1.0) {
discard;
}
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

//#endregion
//#region node_modules/@deck.gl/layers/dist/path-layer/path-layer.js
var DEFAULT_COLOR$2 = [
	0,
	0,
	0,
	255
];
var defaultProps$6 = {
	widthUnits: "meters",
	widthScale: {
		type: "number",
		min: 0,
		value: 1
	},
	widthMinPixels: {
		type: "number",
		min: 0,
		value: 0
	},
	widthMaxPixels: {
		type: "number",
		min: 0,
		value: Number.MAX_SAFE_INTEGER
	},
	jointRounded: false,
	capRounded: false,
	miterLimit: {
		type: "number",
		min: 0,
		value: 4
	},
	billboard: false,
	_pathType: null,
	getPath: {
		type: "accessor",
		value: (object) => object.path
	},
	getColor: {
		type: "accessor",
		value: DEFAULT_COLOR$2
	},
	getWidth: {
		type: "accessor",
		value: 1
	},
	rounded: { deprecatedFor: ["jointRounded", "capRounded"] }
};
var ATTRIBUTE_TRANSITION$1 = { enter: (value, chunk) => {
	return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
} };
/** Render lists of coordinate points as extruded polylines with mitering. */
var PathLayer = class extends layer_default {
	getShaders() {
		return super.getShaders({
			vs: path_layer_vertex_glsl_default,
			fs: path_layer_fragment_glsl_default,
			modules: [
				project32_default,
				picking_default,
				pathUniforms
			]
		});
	}
	get wrapLongitude() {
		return false;
	}
	getBounds() {
		return this.getAttributeManager()?.getBounds(["vertexPositions"]);
	}
	initializeState() {
		const noAlloc = true;
		this.getAttributeManager().addInstanced({
			vertexPositions: {
				size: 3,
				vertexOffset: 1,
				type: "float64",
				fp64: this.use64bitPositions(),
				transition: ATTRIBUTE_TRANSITION$1,
				accessor: "getPath",
				update: this.calculatePositions,
				noAlloc,
				shaderAttributes: {
					instanceLeftPositions: { vertexOffset: 0 },
					instanceStartPositions: { vertexOffset: 1 },
					instanceEndPositions: { vertexOffset: 2 },
					instanceRightPositions: { vertexOffset: 3 }
				}
			},
			instanceTypes: {
				size: 1,
				type: "uint8",
				update: this.calculateSegmentTypes,
				noAlloc
			},
			instanceStrokeWidths: {
				size: 1,
				accessor: "getWidth",
				transition: ATTRIBUTE_TRANSITION$1,
				defaultValue: 1
			},
			instanceColors: {
				size: this.props.colorFormat.length,
				type: "unorm8",
				accessor: "getColor",
				transition: ATTRIBUTE_TRANSITION$1,
				defaultValue: DEFAULT_COLOR$2
			},
			instancePickingColors: {
				size: 4,
				type: "uint8",
				accessor: (object, { index, target: value }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value)
			}
		});
		this.setState({ pathTesselator: new PathTesselator({ fp64: this.use64bitPositions() }) });
	}
	updateState(params) {
		super.updateState(params);
		const { props, changeFlags } = params;
		const attributeManager = this.getAttributeManager();
		if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath)) {
			const { pathTesselator } = this.state;
			const buffers = props.data.attributes || {};
			pathTesselator.updateGeometry({
				data: props.data,
				geometryBuffer: buffers.getPath,
				buffers,
				normalize: !props._pathType,
				loop: props._pathType === "loop",
				getGeometry: props.getPath,
				positionFormat: props.positionFormat,
				wrapLongitude: props.wrapLongitude,
				resolution: this.context.viewport.resolution,
				dataChanged: changeFlags.dataChanged
			});
			this.setState({
				numInstances: pathTesselator.instanceCount,
				startIndices: pathTesselator.vertexStarts
			});
			if (!changeFlags.dataChanged) attributeManager.invalidateAll();
		}
		if (changeFlags.extensionsChanged) {
			this.state.model?.destroy();
			this.state.model = this._getModel();
			attributeManager.invalidateAll();
		}
	}
	getPickingInfo(params) {
		const info = super.getPickingInfo(params);
		const { index } = info;
		const data = this.props.data;
		if (data[0] && data[0].__source) info.object = data.find((d$1) => d$1.__source.index === index);
		return info;
	}
	/** Override base Layer method */
	disablePickingIndex(objectIndex) {
		const data = this.props.data;
		if (data[0] && data[0].__source) {
			for (let i$1 = 0; i$1 < data.length; i$1++) if (data[i$1].__source.index === objectIndex) this._disablePickingIndex(i$1);
		} else super.disablePickingIndex(objectIndex);
	}
	draw({ uniforms }) {
		const { jointRounded, capRounded, billboard, miterLimit, widthUnits, widthScale, widthMinPixels, widthMaxPixels } = this.props;
		const model = this.state.model;
		const pathProps = {
			jointType: Number(jointRounded),
			capType: Number(capRounded),
			billboard,
			widthUnits: UNIT[widthUnits],
			widthScale,
			miterLimit,
			widthMinPixels,
			widthMaxPixels
		};
		model.shaderInputs.setProps({ path: pathProps });
		model.draw(this.context.renderPass);
	}
	_getModel() {
		const SEGMENT_INDICES = [
			0,
			1,
			2,
			1,
			4,
			2,
			1,
			3,
			4,
			3,
			5,
			4
		];
		const SEGMENT_POSITIONS = [
			0,
			0,
			0,
			-1,
			0,
			1,
			1,
			-1,
			1,
			1,
			1,
			0
		];
		return new Model(this.context.device, {
			...this.getShaders(),
			id: this.props.id,
			bufferLayout: this.getAttributeManager().getBufferLayouts(),
			geometry: new Geometry({
				topology: "triangle-list",
				attributes: {
					indices: new Uint16Array(SEGMENT_INDICES),
					positions: {
						value: new Float32Array(SEGMENT_POSITIONS),
						size: 2
					}
				}
			}),
			isInstanced: true
		});
	}
	calculatePositions(attribute) {
		const { pathTesselator } = this.state;
		attribute.startIndices = pathTesselator.vertexStarts;
		attribute.value = pathTesselator.get("positions");
	}
	calculateSegmentTypes(attribute) {
		const { pathTesselator } = this.state;
		attribute.startIndices = pathTesselator.vertexStarts;
		attribute.value = pathTesselator.get("segmentTypes");
	}
};
PathLayer.defaultProps = defaultProps$6;
PathLayer.layerName = "PathLayer";
var path_layer_default = PathLayer;

//#endregion
//#region node_modules/@deck.gl/layers/node_modules/earcut/src/earcut.js
var require_earcut = /* @__PURE__ */ __commonJS({ "node_modules/@deck.gl/layers/node_modules/earcut/src/earcut.js": ((exports, module) => {
	module.exports = earcut$1;
	module.exports.default = earcut$1;
	function earcut$1(data, holeIndices, dim) {
		dim = dim || 2;
		var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
		if (!outerNode || outerNode.next === outerNode.prev) return triangles;
		var minX, minY, maxX, maxY, x$1, y$1, invSize;
		if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
		if (data.length > 80 * dim) {
			minX = maxX = data[0];
			minY = maxY = data[1];
			for (var i$1 = dim; i$1 < outerLen; i$1 += dim) {
				x$1 = data[i$1];
				y$1 = data[i$1 + 1];
				if (x$1 < minX) minX = x$1;
				if (y$1 < minY) minY = y$1;
				if (x$1 > maxX) maxX = x$1;
				if (y$1 > maxY) maxY = y$1;
			}
			invSize = Math.max(maxX - minX, maxY - minY);
			invSize = invSize !== 0 ? 32767 / invSize : 0;
		}
		earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
		return triangles;
	}
	function linkedList(data, start, end, dim, clockwise) {
		var i$1, last;
		if (clockwise === signedArea(data, start, end, dim) > 0) for (i$1 = start; i$1 < end; i$1 += dim) last = insertNode(i$1, data[i$1], data[i$1 + 1], last);
		else for (i$1 = end - dim; i$1 >= start; i$1 -= dim) last = insertNode(i$1, data[i$1], data[i$1 + 1], last);
		if (last && equals(last, last.next)) {
			removeNode(last);
			last = last.next;
		}
		return last;
	}
	function filterPoints(start, end) {
		if (!start) return start;
		if (!end) end = start;
		var p$1 = start, again;
		do {
			again = false;
			if (!p$1.steiner && (equals(p$1, p$1.next) || area(p$1.prev, p$1, p$1.next) === 0)) {
				removeNode(p$1);
				p$1 = end = p$1.prev;
				if (p$1 === p$1.next) break;
				again = true;
			} else p$1 = p$1.next;
		} while (again || p$1 !== end);
		return end;
	}
	function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
		if (!ear) return;
		if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
		var stop = ear, prev, next;
		while (ear.prev !== ear.next) {
			prev = ear.prev;
			next = ear.next;
			if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
				triangles.push(prev.i / dim | 0);
				triangles.push(ear.i / dim | 0);
				triangles.push(next.i / dim | 0);
				removeNode(ear);
				ear = next.next;
				stop = next.next;
				continue;
			}
			ear = next;
			if (ear === stop) {
				if (!pass) earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
				else if (pass === 1) {
					ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
					earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
				} else if (pass === 2) splitEarcut(ear, triangles, dim, minX, minY, invSize);
				break;
			}
		}
	}
	function isEar(ear) {
		var a$1 = ear.prev, b$1 = ear, c$1 = ear.next;
		if (area(a$1, b$1, c$1) >= 0) return false;
		var ax = a$1.x, bx = b$1.x, cx = c$1.x, ay = a$1.y, by = b$1.y, cy = c$1.y;
		var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
		var p$1 = c$1.next;
		while (p$1 !== a$1) {
			if (p$1.x >= x0 && p$1.x <= x1 && p$1.y >= y0 && p$1.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p$1.x, p$1.y) && area(p$1.prev, p$1, p$1.next) >= 0) return false;
			p$1 = p$1.next;
		}
		return true;
	}
	function isEarHashed(ear, minX, minY, invSize) {
		var a$1 = ear.prev, b$1 = ear, c$1 = ear.next;
		if (area(a$1, b$1, c$1) >= 0) return false;
		var ax = a$1.x, bx = b$1.x, cx = c$1.x, ay = a$1.y, by = b$1.y, cy = c$1.y;
		var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
		var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
		var p$1 = ear.prevZ, n$1 = ear.nextZ;
		while (p$1 && p$1.z >= minZ && n$1 && n$1.z <= maxZ) {
			if (p$1.x >= x0 && p$1.x <= x1 && p$1.y >= y0 && p$1.y <= y1 && p$1 !== a$1 && p$1 !== c$1 && pointInTriangle(ax, ay, bx, by, cx, cy, p$1.x, p$1.y) && area(p$1.prev, p$1, p$1.next) >= 0) return false;
			p$1 = p$1.prevZ;
			if (n$1.x >= x0 && n$1.x <= x1 && n$1.y >= y0 && n$1.y <= y1 && n$1 !== a$1 && n$1 !== c$1 && pointInTriangle(ax, ay, bx, by, cx, cy, n$1.x, n$1.y) && area(n$1.prev, n$1, n$1.next) >= 0) return false;
			n$1 = n$1.nextZ;
		}
		while (p$1 && p$1.z >= minZ) {
			if (p$1.x >= x0 && p$1.x <= x1 && p$1.y >= y0 && p$1.y <= y1 && p$1 !== a$1 && p$1 !== c$1 && pointInTriangle(ax, ay, bx, by, cx, cy, p$1.x, p$1.y) && area(p$1.prev, p$1, p$1.next) >= 0) return false;
			p$1 = p$1.prevZ;
		}
		while (n$1 && n$1.z <= maxZ) {
			if (n$1.x >= x0 && n$1.x <= x1 && n$1.y >= y0 && n$1.y <= y1 && n$1 !== a$1 && n$1 !== c$1 && pointInTriangle(ax, ay, bx, by, cx, cy, n$1.x, n$1.y) && area(n$1.prev, n$1, n$1.next) >= 0) return false;
			n$1 = n$1.nextZ;
		}
		return true;
	}
	function cureLocalIntersections(start, triangles, dim) {
		var p$1 = start;
		do {
			var a$1 = p$1.prev, b$1 = p$1.next.next;
			if (!equals(a$1, b$1) && intersects(a$1, p$1, p$1.next, b$1) && locallyInside(a$1, b$1) && locallyInside(b$1, a$1)) {
				triangles.push(a$1.i / dim | 0);
				triangles.push(p$1.i / dim | 0);
				triangles.push(b$1.i / dim | 0);
				removeNode(p$1);
				removeNode(p$1.next);
				p$1 = start = b$1;
			}
			p$1 = p$1.next;
		} while (p$1 !== start);
		return filterPoints(p$1);
	}
	function splitEarcut(start, triangles, dim, minX, minY, invSize) {
		var a$1 = start;
		do {
			var b$1 = a$1.next.next;
			while (b$1 !== a$1.prev) {
				if (a$1.i !== b$1.i && isValidDiagonal(a$1, b$1)) {
					var c$1 = splitPolygon(a$1, b$1);
					a$1 = filterPoints(a$1, a$1.next);
					c$1 = filterPoints(c$1, c$1.next);
					earcutLinked(a$1, triangles, dim, minX, minY, invSize, 0);
					earcutLinked(c$1, triangles, dim, minX, minY, invSize, 0);
					return;
				}
				b$1 = b$1.next;
			}
			a$1 = a$1.next;
		} while (a$1 !== start);
	}
	function eliminateHoles(data, holeIndices, outerNode, dim) {
		var queue = [], i$1, len, start, end, list;
		for (i$1 = 0, len = holeIndices.length; i$1 < len; i$1++) {
			start = holeIndices[i$1] * dim;
			end = i$1 < len - 1 ? holeIndices[i$1 + 1] * dim : data.length;
			list = linkedList(data, start, end, dim, false);
			if (list === list.next) list.steiner = true;
			queue.push(getLeftmost(list));
		}
		queue.sort(compareX);
		for (i$1 = 0; i$1 < queue.length; i$1++) outerNode = eliminateHole(queue[i$1], outerNode);
		return outerNode;
	}
	function compareX(a$1, b$1) {
		return a$1.x - b$1.x;
	}
	function eliminateHole(hole, outerNode) {
		var bridge = findHoleBridge(hole, outerNode);
		if (!bridge) return outerNode;
		var bridgeReverse = splitPolygon(bridge, hole);
		filterPoints(bridgeReverse, bridgeReverse.next);
		return filterPoints(bridge, bridge.next);
	}
	function findHoleBridge(hole, outerNode) {
		var p$1 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m$1;
		do {
			if (hy <= p$1.y && hy >= p$1.next.y && p$1.next.y !== p$1.y) {
				var x$1 = p$1.x + (hy - p$1.y) * (p$1.next.x - p$1.x) / (p$1.next.y - p$1.y);
				if (x$1 <= hx && x$1 > qx) {
					qx = x$1;
					m$1 = p$1.x < p$1.next.x ? p$1 : p$1.next;
					if (x$1 === hx) return m$1;
				}
			}
			p$1 = p$1.next;
		} while (p$1 !== outerNode);
		if (!m$1) return null;
		var stop = m$1, mx = m$1.x, my = m$1.y, tanMin = Infinity, tan;
		p$1 = m$1;
		do {
			if (hx >= p$1.x && p$1.x >= mx && hx !== p$1.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p$1.x, p$1.y)) {
				tan = Math.abs(hy - p$1.y) / (hx - p$1.x);
				if (locallyInside(p$1, hole) && (tan < tanMin || tan === tanMin && (p$1.x > m$1.x || p$1.x === m$1.x && sectorContainsSector(m$1, p$1)))) {
					m$1 = p$1;
					tanMin = tan;
				}
			}
			p$1 = p$1.next;
		} while (p$1 !== stop);
		return m$1;
	}
	function sectorContainsSector(m$1, p$1) {
		return area(m$1.prev, m$1, p$1.prev) < 0 && area(p$1.next, m$1, m$1.next) < 0;
	}
	function indexCurve(start, minX, minY, invSize) {
		var p$1 = start;
		do {
			if (p$1.z === 0) p$1.z = zOrder(p$1.x, p$1.y, minX, minY, invSize);
			p$1.prevZ = p$1.prev;
			p$1.nextZ = p$1.next;
			p$1 = p$1.next;
		} while (p$1 !== start);
		p$1.prevZ.nextZ = null;
		p$1.prevZ = null;
		sortLinked(p$1);
	}
	function sortLinked(list) {
		var i$1, p$1, q$1, e$1, tail, numMerges, pSize, qSize, inSize = 1;
		do {
			p$1 = list;
			list = null;
			tail = null;
			numMerges = 0;
			while (p$1) {
				numMerges++;
				q$1 = p$1;
				pSize = 0;
				for (i$1 = 0; i$1 < inSize; i$1++) {
					pSize++;
					q$1 = q$1.nextZ;
					if (!q$1) break;
				}
				qSize = inSize;
				while (pSize > 0 || qSize > 0 && q$1) {
					if (pSize !== 0 && (qSize === 0 || !q$1 || p$1.z <= q$1.z)) {
						e$1 = p$1;
						p$1 = p$1.nextZ;
						pSize--;
					} else {
						e$1 = q$1;
						q$1 = q$1.nextZ;
						qSize--;
					}
					if (tail) tail.nextZ = e$1;
					else list = e$1;
					e$1.prevZ = tail;
					tail = e$1;
				}
				p$1 = q$1;
			}
			tail.nextZ = null;
			inSize *= 2;
		} while (numMerges > 1);
		return list;
	}
	function zOrder(x$1, y$1, minX, minY, invSize) {
		x$1 = (x$1 - minX) * invSize | 0;
		y$1 = (y$1 - minY) * invSize | 0;
		x$1 = (x$1 | x$1 << 8) & 16711935;
		x$1 = (x$1 | x$1 << 4) & 252645135;
		x$1 = (x$1 | x$1 << 2) & 858993459;
		x$1 = (x$1 | x$1 << 1) & 1431655765;
		y$1 = (y$1 | y$1 << 8) & 16711935;
		y$1 = (y$1 | y$1 << 4) & 252645135;
		y$1 = (y$1 | y$1 << 2) & 858993459;
		y$1 = (y$1 | y$1 << 1) & 1431655765;
		return x$1 | y$1 << 1;
	}
	function getLeftmost(start) {
		var p$1 = start, leftmost = start;
		do {
			if (p$1.x < leftmost.x || p$1.x === leftmost.x && p$1.y < leftmost.y) leftmost = p$1;
			p$1 = p$1.next;
		} while (p$1 !== start);
		return leftmost;
	}
	function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
		return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
	}
	function isValidDiagonal(a$1, b$1) {
		return a$1.next.i !== b$1.i && a$1.prev.i !== b$1.i && !intersectsPolygon(a$1, b$1) && (locallyInside(a$1, b$1) && locallyInside(b$1, a$1) && middleInside(a$1, b$1) && (area(a$1.prev, a$1, b$1.prev) || area(a$1, b$1.prev, b$1)) || equals(a$1, b$1) && area(a$1.prev, a$1, a$1.next) > 0 && area(b$1.prev, b$1, b$1.next) > 0);
	}
	function area(p$1, q$1, r$1) {
		return (q$1.y - p$1.y) * (r$1.x - q$1.x) - (q$1.x - p$1.x) * (r$1.y - q$1.y);
	}
	function equals(p1, p2) {
		return p1.x === p2.x && p1.y === p2.y;
	}
	function intersects(p1, q1, p2, q2) {
		var o1 = sign(area(p1, q1, p2));
		var o2 = sign(area(p1, q1, q2));
		var o3 = sign(area(p2, q2, p1));
		var o4 = sign(area(p2, q2, q1));
		if (o1 !== o2 && o3 !== o4) return true;
		if (o1 === 0 && onSegment(p1, p2, q1)) return true;
		if (o2 === 0 && onSegment(p1, q2, q1)) return true;
		if (o3 === 0 && onSegment(p2, p1, q2)) return true;
		if (o4 === 0 && onSegment(p2, q1, q2)) return true;
		return false;
	}
	function onSegment(p$1, q$1, r$1) {
		return q$1.x <= Math.max(p$1.x, r$1.x) && q$1.x >= Math.min(p$1.x, r$1.x) && q$1.y <= Math.max(p$1.y, r$1.y) && q$1.y >= Math.min(p$1.y, r$1.y);
	}
	function sign(num) {
		return num > 0 ? 1 : num < 0 ? -1 : 0;
	}
	function intersectsPolygon(a$1, b$1) {
		var p$1 = a$1;
		do {
			if (p$1.i !== a$1.i && p$1.next.i !== a$1.i && p$1.i !== b$1.i && p$1.next.i !== b$1.i && intersects(p$1, p$1.next, a$1, b$1)) return true;
			p$1 = p$1.next;
		} while (p$1 !== a$1);
		return false;
	}
	function locallyInside(a$1, b$1) {
		return area(a$1.prev, a$1, a$1.next) < 0 ? area(a$1, b$1, a$1.next) >= 0 && area(a$1, a$1.prev, b$1) >= 0 : area(a$1, b$1, a$1.prev) < 0 || area(a$1, a$1.next, b$1) < 0;
	}
	function middleInside(a$1, b$1) {
		var p$1 = a$1, inside = false, px = (a$1.x + b$1.x) / 2, py = (a$1.y + b$1.y) / 2;
		do {
			if (p$1.y > py !== p$1.next.y > py && p$1.next.y !== p$1.y && px < (p$1.next.x - p$1.x) * (py - p$1.y) / (p$1.next.y - p$1.y) + p$1.x) inside = !inside;
			p$1 = p$1.next;
		} while (p$1 !== a$1);
		return inside;
	}
	function splitPolygon(a$1, b$1) {
		var a2 = new Node(a$1.i, a$1.x, a$1.y), b2 = new Node(b$1.i, b$1.x, b$1.y), an = a$1.next, bp = b$1.prev;
		a$1.next = b$1;
		b$1.prev = a$1;
		a2.next = an;
		an.prev = a2;
		b2.next = a2;
		a2.prev = b2;
		bp.next = b2;
		b2.prev = bp;
		return b2;
	}
	function insertNode(i$1, x$1, y$1, last) {
		var p$1 = new Node(i$1, x$1, y$1);
		if (!last) {
			p$1.prev = p$1;
			p$1.next = p$1;
		} else {
			p$1.next = last.next;
			p$1.prev = last;
			last.next.prev = p$1;
			last.next = p$1;
		}
		return p$1;
	}
	function removeNode(p$1) {
		p$1.next.prev = p$1.prev;
		p$1.prev.next = p$1.next;
		if (p$1.prevZ) p$1.prevZ.nextZ = p$1.nextZ;
		if (p$1.nextZ) p$1.nextZ.prevZ = p$1.prevZ;
	}
	function Node(i$1, x$1, y$1) {
		this.i = i$1;
		this.x = x$1;
		this.y = y$1;
		this.prev = null;
		this.next = null;
		this.z = 0;
		this.prevZ = null;
		this.nextZ = null;
		this.steiner = false;
	}
	earcut$1.deviation = function(data, holeIndices, dim, triangles) {
		var hasHoles = holeIndices && holeIndices.length;
		var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
		var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
		if (hasHoles) for (var i$1 = 0, len = holeIndices.length; i$1 < len; i$1++) {
			var start = holeIndices[i$1] * dim;
			var end = i$1 < len - 1 ? holeIndices[i$1 + 1] * dim : data.length;
			polygonArea -= Math.abs(signedArea(data, start, end, dim));
		}
		var trianglesArea = 0;
		for (i$1 = 0; i$1 < triangles.length; i$1 += 3) {
			var a$1 = triangles[i$1] * dim;
			var b$1 = triangles[i$1 + 1] * dim;
			var c$1 = triangles[i$1 + 2] * dim;
			trianglesArea += Math.abs((data[a$1] - data[c$1]) * (data[b$1 + 1] - data[a$1 + 1]) - (data[a$1] - data[b$1]) * (data[c$1 + 1] - data[a$1 + 1]));
		}
		return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
	};
	function signedArea(data, start, end, dim) {
		var sum = 0;
		for (var i$1 = start, j$1 = end - dim; i$1 < end; i$1 += dim) {
			sum += (data[j$1] - data[i$1]) * (data[i$1 + 1] + data[j$1 + 1]);
			j$1 = i$1;
		}
		return sum;
	}
	earcut$1.flatten = function(data) {
		var dim = data[0][0].length, result = {
			vertices: [],
			holes: [],
			dimensions: dim
		}, holeIndex = 0;
		for (var i$1 = 0; i$1 < data.length; i$1++) {
			for (var j$1 = 0; j$1 < data[i$1].length; j$1++) for (var d$1 = 0; d$1 < dim; d$1++) result.vertices.push(data[i$1][j$1][d$1]);
			if (i$1 > 0) {
				holeIndex += data[i$1 - 1].length;
				result.holes.push(holeIndex);
			}
		}
		return result;
	};
}) });

//#endregion
//#region node_modules/@deck.gl/layers/dist/solid-polygon-layer/polygon.js
var import_earcut = /* @__PURE__ */ __toESM(require_earcut(), 1);
var OUTER_POLYGON_WINDING = WINDING.CLOCKWISE;
var HOLE_POLYGON_WINDING = WINDING.COUNTER_CLOCKWISE;
/** A scratch object for sending winding options */
var windingOptions = { isClosed: true };
/**
* Ensure a polygon is valid format
*/
function validate(polygon) {
	polygon = polygon && polygon.positions || polygon;
	if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) throw new Error("invalid polygon");
}
/** Get the positions from a normalized polygon */
function getPositions(polygon) {
	return "positions" in polygon ? polygon.positions : polygon;
}
/** Get the hole indices from a normalized polygon */
function getHoleIndices(polygon) {
	return "holeIndices" in polygon ? polygon.holeIndices : null;
}
/**
* Check if a polygon is nested or flat
* Returns true if the polygon is a flat polygon (i.e. not an array of polygons)
*/
function isNested(polygon) {
	return Array.isArray(polygon[0]);
}
/**
* Check if a polygon is simple or complex
* Returns true if the polygon is a simple polygon (i.e. not an array of polygons)
*/
function isSimple(polygon) {
	return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);
}
/**
* Check if a simple polygon is a closed ring
* Returns true if the simple polygon is a closed ring
*/
function isNestedRingClosed(simplePolygon) {
	const p0 = simplePolygon[0];
	const p1 = simplePolygon[simplePolygon.length - 1];
	return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];
}
/**
* Check if a simple flat array is a closed ring
* Returns true if the simple flat array is a closed ring
*/
function isFlatRingClosed(positions, size, startIndex, endIndex) {
	for (let i$1 = 0; i$1 < size; i$1++) if (positions[startIndex + i$1] !== positions[endIndex - size + i$1]) return false;
	return true;
}
/**
* Copy a simple polygon coordinates into a flat array, closes the ring if needed.
* Returns the index of the write head in the destination
*/
function copyNestedRing(target, targetStartIndex, simplePolygon, size, windingDirection) {
	let targetIndex = targetStartIndex;
	const len = simplePolygon.length;
	for (let i$1 = 0; i$1 < len; i$1++) for (let j$1 = 0; j$1 < size; j$1++) target[targetIndex++] = simplePolygon[i$1][j$1] || 0;
	if (!isNestedRingClosed(simplePolygon)) for (let j$1 = 0; j$1 < size; j$1++) target[targetIndex++] = simplePolygon[0][j$1] || 0;
	windingOptions.start = targetStartIndex;
	windingOptions.end = targetIndex;
	windingOptions.size = size;
	modifyPolygonWindingDirection(target, windingDirection, windingOptions);
	return targetIndex;
}
/**
* Copy a simple flat array into another flat array, closes the ring if needed.
* Returns the index of the write head in the destination
*/
function copyFlatRing(target, targetStartIndex, positions, size, srcStartIndex = 0, srcEndIndex, windingDirection) {
	srcEndIndex = srcEndIndex || positions.length;
	const srcLength = srcEndIndex - srcStartIndex;
	if (srcLength <= 0) return targetStartIndex;
	let targetIndex = targetStartIndex;
	for (let i$1 = 0; i$1 < srcLength; i$1++) target[targetIndex++] = positions[srcStartIndex + i$1];
	if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) for (let i$1 = 0; i$1 < size; i$1++) target[targetIndex++] = positions[srcStartIndex + i$1];
	windingOptions.start = targetStartIndex;
	windingOptions.end = targetIndex;
	windingOptions.size = size;
	modifyPolygonWindingDirection(target, windingDirection, windingOptions);
	return targetIndex;
}
/**
* Normalize any polygon representation into the "complex flat" format
*/
function normalize(polygon, positionSize) {
	validate(polygon);
	const positions = [];
	const holeIndices = [];
	if ("positions" in polygon) {
		const { positions: srcPositions, holeIndices: srcHoleIndices } = polygon;
		if (srcHoleIndices) {
			let targetIndex = 0;
			for (let i$1 = 0; i$1 <= srcHoleIndices.length; i$1++) {
				targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i$1 - 1], srcHoleIndices[i$1], i$1 === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
				holeIndices.push(targetIndex);
			}
			holeIndices.pop();
			return {
				positions,
				holeIndices
			};
		}
		polygon = srcPositions;
	}
	if (!isNested(polygon)) {
		copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);
		return positions;
	}
	if (!isSimple(polygon)) {
		let targetIndex = 0;
		for (const [polygonIndex, simplePolygon] of polygon.entries()) {
			targetIndex = copyNestedRing(positions, targetIndex, simplePolygon, positionSize, polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
			holeIndices.push(targetIndex);
		}
		holeIndices.pop();
		return {
			positions,
			holeIndices
		};
	}
	copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);
	return positions;
}
function getPlaneArea(positions, xIndex, yIndex) {
	const numVerts = positions.length / 3;
	let area$1 = 0;
	for (let i$1 = 0; i$1 < numVerts; i$1++) {
		const j$1 = (i$1 + 1) % numVerts;
		area$1 += positions[i$1 * 3 + xIndex] * positions[j$1 * 3 + yIndex];
		area$1 -= positions[j$1 * 3 + xIndex] * positions[i$1 * 3 + yIndex];
	}
	return Math.abs(area$1 / 2);
}
function permutePositions(positions, xIndex, yIndex, zIndex) {
	const numVerts = positions.length / 3;
	for (let i$1 = 0; i$1 < numVerts; i$1++) {
		const o$1 = i$1 * 3;
		const x$1 = positions[o$1 + 0];
		const y$1 = positions[o$1 + 1];
		const z$1 = positions[o$1 + 2];
		positions[o$1 + xIndex] = x$1;
		positions[o$1 + yIndex] = y$1;
		positions[o$1 + zIndex] = z$1;
	}
}
/**
* Get vertex indices for drawing polygon mesh (triangulation)
*/
function getSurfaceIndices(polygon, positionSize, preproject, full3d) {
	let holeIndices = getHoleIndices(polygon);
	if (holeIndices) holeIndices = holeIndices.map((positionIndex) => positionIndex / positionSize);
	let positions = getPositions(polygon);
	const is3d = full3d && positionSize === 3;
	if (preproject) {
		const n$1 = positions.length;
		positions = positions.slice();
		const p$1 = [];
		for (let i$1 = 0; i$1 < n$1; i$1 += positionSize) {
			p$1[0] = positions[i$1];
			p$1[1] = positions[i$1 + 1];
			if (is3d) p$1[2] = positions[i$1 + 2];
			const xy = preproject(p$1);
			positions[i$1] = xy[0];
			positions[i$1 + 1] = xy[1];
			if (is3d) positions[i$1 + 2] = xy[2];
		}
	}
	if (is3d) {
		const xyArea = getPlaneArea(positions, 0, 1);
		const xzArea = getPlaneArea(positions, 0, 2);
		const yzArea = getPlaneArea(positions, 1, 2);
		if (!xyArea && !xzArea && !yzArea) return [];
		if (xyArea > xzArea && xyArea > yzArea) {} else if (xzArea > yzArea) {
			if (!preproject) positions = positions.slice();
			permutePositions(positions, 0, 2, 1);
		} else {
			if (!preproject) positions = positions.slice();
			permutePositions(positions, 2, 0, 1);
		}
	}
	return (0, import_earcut.default)(positions, holeIndices, positionSize);
}

//#endregion
//#region node_modules/@deck.gl/layers/dist/solid-polygon-layer/polygon-tesselator.js
var PolygonTesselator = class extends Tesselator {
	constructor(opts) {
		const { fp64, IndexType = Uint32Array } = opts;
		super({
			...opts,
			attributes: {
				positions: {
					size: 3,
					type: fp64 ? Float64Array : Float32Array
				},
				vertexValid: {
					type: Uint16Array,
					size: 1
				},
				indices: {
					type: IndexType,
					size: 1
				}
			}
		});
	}
	/** Get attribute by name */
	get(attributeName) {
		const { attributes } = this;
		if (attributeName === "indices") return attributes.indices && attributes.indices.subarray(0, this.vertexCount);
		return attributes[attributeName];
	}
	/** Override base Tesselator method */
	updateGeometry(opts) {
		super.updateGeometry(opts);
		const externalIndices = this.buffers.indices;
		if (externalIndices) this.vertexCount = (externalIndices.value || externalIndices).length;
		else if (this.data && !this.getGeometry) throw new Error("missing indices buffer");
	}
	/** Implement base Tesselator interface */
	normalizeGeometry(polygon) {
		if (this.normalize) {
			const normalizedPolygon = normalize(polygon, this.positionSize);
			if (this.opts.resolution) return cutPolygonByGrid(getPositions(normalizedPolygon), getHoleIndices(normalizedPolygon), {
				size: this.positionSize,
				gridResolution: this.opts.resolution,
				edgeTypes: true
			});
			if (this.opts.wrapLongitude) return cutPolygonByMercatorBounds(getPositions(normalizedPolygon), getHoleIndices(normalizedPolygon), {
				size: this.positionSize,
				maxLatitude: 86,
				edgeTypes: true
			});
			return normalizedPolygon;
		}
		return polygon;
	}
	/** Implement base Tesselator interface */
	getGeometrySize(polygon) {
		if (isCut(polygon)) {
			let size = 0;
			for (const subPolygon of polygon) size += this.getGeometrySize(subPolygon);
			return size;
		}
		return getPositions(polygon).length / this.positionSize;
	}
	/** Override base Tesselator method */
	getGeometryFromBuffer(buffer) {
		if (this.normalize || !this.buffers.indices) return super.getGeometryFromBuffer(buffer);
		return null;
	}
	/** Implement base Tesselator interface */
	updateGeometryAttributes(polygon, context) {
		if (polygon && isCut(polygon)) for (const subPolygon of polygon) {
			const geometrySize = this.getGeometrySize(subPolygon);
			context.geometrySize = geometrySize;
			this.updateGeometryAttributes(subPolygon, context);
			context.vertexStart += geometrySize;
			context.indexStart = this.indexStarts[context.geometryIndex + 1];
		}
		else {
			const normalizedPolygon = polygon;
			this._updateIndices(normalizedPolygon, context);
			this._updatePositions(normalizedPolygon, context);
			this._updateVertexValid(normalizedPolygon, context);
		}
	}
	_updateIndices(polygon, { geometryIndex, vertexStart: offset, indexStart }) {
		const { attributes, indexStarts, typedArrayManager } = this;
		let target = attributes.indices;
		if (!target || !polygon) return;
		let i$1 = indexStart;
		const indices = getSurfaceIndices(polygon, this.positionSize, this.opts.preproject, this.opts.full3d);
		target = typedArrayManager.allocate(target, indexStart + indices.length, { copy: true });
		for (let j$1 = 0; j$1 < indices.length; j$1++) target[i$1++] = indices[j$1] + offset;
		indexStarts[geometryIndex + 1] = indexStart + indices.length;
		attributes.indices = target;
	}
	_updatePositions(polygon, { vertexStart, geometrySize }) {
		const { attributes: { positions }, positionSize } = this;
		if (!positions || !polygon) return;
		const polygonPositions = getPositions(polygon);
		for (let i$1 = vertexStart, j$1 = 0; j$1 < geometrySize; i$1++, j$1++) {
			const x$1 = polygonPositions[j$1 * positionSize];
			const y$1 = polygonPositions[j$1 * positionSize + 1];
			const z$1 = positionSize > 2 ? polygonPositions[j$1 * positionSize + 2] : 0;
			positions[i$1 * 3] = x$1;
			positions[i$1 * 3 + 1] = y$1;
			positions[i$1 * 3 + 2] = z$1;
		}
	}
	_updateVertexValid(polygon, { vertexStart, geometrySize }) {
		const { positionSize } = this;
		const vertexValid = this.attributes.vertexValid;
		const holeIndices = polygon && getHoleIndices(polygon);
		if (polygon && polygon.edgeTypes) vertexValid.set(polygon.edgeTypes, vertexStart);
		else vertexValid.fill(1, vertexStart, vertexStart + geometrySize);
		if (holeIndices) for (let j$1 = 0; j$1 < holeIndices.length; j$1++) vertexValid[vertexStart + holeIndices[j$1] / positionSize - 1] = 0;
		vertexValid[vertexStart + geometrySize - 1] = 0;
	}
};
function isCut(polygon) {
	return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);
}

//#endregion
//#region node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-uniforms.js
var uniformBlock$2 = `\
uniform solidPolygonUniforms {
  bool extruded;
  bool isWireframe;
  float elevationScale;
} solidPolygon;
`;
const solidPolygonUniforms = {
	name: "solidPolygon",
	vs: uniformBlock$2,
	fs: uniformBlock$2,
	uniformTypes: {
		extruded: "f32",
		isWireframe: "f32",
		elevationScale: "f32"
	}
};

//#endregion
//#region node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js
var solid_polygon_layer_vertex_main_glsl_default = `\
in vec4 fillColors;
in vec4 lineColors;
in vec3 pickingColors;
out vec4 vColor;
struct PolygonProps {
vec3 positions;
vec3 positions64Low;
vec3 normal;
float elevations;
};
vec3 project_offset_normal(vec3 vector) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {
return normalize(vector * project.commonUnitsPerWorldUnit);
}
return project_normal(vector);
}
void calculatePosition(PolygonProps props) {
vec3 pos = props.positions;
vec3 pos64Low = props.positions64Low;
vec3 normal = props.normal;
vec4 colors = solidPolygon.isWireframe ? lineColors : fillColors;
geometry.worldPosition = props.positions;
geometry.pickingColor = pickingColors;
if (solidPolygon.extruded) {
pos.z += props.elevations * solidPolygon.elevationScale;
}
gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
if (solidPolygon.extruded) {
#ifdef IS_SIDE_VERTEX
normal = project_offset_normal(normal);
#else
normal = project_normal(normal);
#endif
geometry.normal = normal;
vec3 lightColor = lighting_getLightColor(colors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, colors.a * layer.opacity);
} else {
vColor = vec4(colors.rgb, colors.a * layer.opacity);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

//#endregion
//#region node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js
var solid_polygon_layer_vertex_top_glsl_default = `\
#version 300 es
#define SHADER_NAME solid-polygon-layer-vertex-shader
in vec3 vertexPositions;
in vec3 vertexPositions64Low;
in float elevations;
${solid_polygon_layer_vertex_main_glsl_default}
void main(void) {
PolygonProps props;
props.positions = vertexPositions;
props.positions64Low = vertexPositions64Low;
props.elevations = elevations;
props.normal = vec3(0.0, 0.0, 1.0);
calculatePosition(props);
}
`;

//#endregion
//#region node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js
var solid_polygon_layer_vertex_side_glsl_default = `\
#version 300 es
#define SHADER_NAME solid-polygon-layer-vertex-shader-side
#define IS_SIDE_VERTEX
in vec2 positions;
in vec3 vertexPositions;
in vec3 nextVertexPositions;
in vec3 vertexPositions64Low;
in vec3 nextVertexPositions64Low;
in float elevations;
in float instanceVertexValid;
${solid_polygon_layer_vertex_main_glsl_default}
void main(void) {
if(instanceVertexValid < 0.5){
gl_Position = vec4(0.);
return;
}
PolygonProps props;
vec3 pos;
vec3 pos64Low;
vec3 nextPos;
vec3 nextPos64Low;
#if RING_WINDING_ORDER_CW == 1
pos = vertexPositions;
pos64Low = vertexPositions64Low;
nextPos = nextVertexPositions;
nextPos64Low = nextVertexPositions64Low;
#else
pos = nextVertexPositions;
pos64Low = nextVertexPositions64Low;
nextPos = vertexPositions;
nextPos64Low = vertexPositions64Low;
#endif
props.positions = mix(pos, nextPos, positions.x);
props.positions64Low = mix(pos64Low, nextPos64Low, positions.x);
props.normal = vec3(
pos.y - nextPos.y + (pos64Low.y - nextPos64Low.y),
nextPos.x - pos.x + (nextPos64Low.x - pos64Low.x),
0.0);
props.elevations = elevations * positions.y;
calculatePosition(props);
}
`;

//#endregion
//#region node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js
var solid_polygon_layer_fragment_glsl_default = `\
#version 300 es
#define SHADER_NAME solid-polygon-layer-fragment-shader
precision highp float;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
fragColor = vColor;
geometry.uv = vec2(0.);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

//#endregion
//#region node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer.js
var DEFAULT_COLOR$1 = [
	0,
	0,
	0,
	255
];
var defaultProps$5 = {
	filled: true,
	extruded: false,
	wireframe: false,
	_normalize: true,
	_windingOrder: "CW",
	_full3d: false,
	elevationScale: {
		type: "number",
		min: 0,
		value: 1
	},
	getPolygon: {
		type: "accessor",
		value: (f$1) => f$1.polygon
	},
	getElevation: {
		type: "accessor",
		value: 1e3
	},
	getFillColor: {
		type: "accessor",
		value: DEFAULT_COLOR$1
	},
	getLineColor: {
		type: "accessor",
		value: DEFAULT_COLOR$1
	},
	material: true
};
var ATTRIBUTE_TRANSITION = { enter: (value, chunk) => {
	return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
} };
var SolidPolygonLayer = class extends layer_default {
	getShaders(type) {
		return super.getShaders({
			vs: type === "top" ? solid_polygon_layer_vertex_top_glsl_default : solid_polygon_layer_vertex_side_glsl_default,
			fs: solid_polygon_layer_fragment_glsl_default,
			defines: { RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === "CCW" ? 0 : 1 },
			modules: [
				project32_default,
				gouraudMaterial,
				picking_default,
				solidPolygonUniforms
			]
		});
	}
	get wrapLongitude() {
		return false;
	}
	getBounds() {
		return this.getAttributeManager()?.getBounds(["vertexPositions"]);
	}
	initializeState() {
		const { viewport } = this.context;
		let { coordinateSystem } = this.props;
		const { _full3d } = this.props;
		if (viewport.isGeospatial && coordinateSystem === COORDINATE_SYSTEM.DEFAULT) coordinateSystem = COORDINATE_SYSTEM.LNGLAT;
		let preproject;
		if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) if (_full3d) preproject = viewport.projectPosition.bind(viewport);
		else preproject = viewport.projectFlat.bind(viewport);
		this.setState({
			numInstances: 0,
			polygonTesselator: new PolygonTesselator({
				preproject,
				fp64: this.use64bitPositions(),
				IndexType: Uint32Array
			})
		});
		const attributeManager = this.getAttributeManager();
		const noAlloc = true;
		attributeManager.remove(["instancePickingColors"]);
		attributeManager.add({
			indices: {
				size: 1,
				isIndexed: true,
				update: this.calculateIndices,
				noAlloc
			},
			vertexPositions: {
				size: 3,
				type: "float64",
				stepMode: "dynamic",
				fp64: this.use64bitPositions(),
				transition: ATTRIBUTE_TRANSITION,
				accessor: "getPolygon",
				update: this.calculatePositions,
				noAlloc,
				shaderAttributes: { nextVertexPositions: { vertexOffset: 1 } }
			},
			instanceVertexValid: {
				size: 1,
				type: "uint16",
				stepMode: "instance",
				update: this.calculateVertexValid,
				noAlloc
			},
			elevations: {
				size: 1,
				stepMode: "dynamic",
				transition: ATTRIBUTE_TRANSITION,
				accessor: "getElevation"
			},
			fillColors: {
				size: this.props.colorFormat.length,
				type: "unorm8",
				stepMode: "dynamic",
				transition: ATTRIBUTE_TRANSITION,
				accessor: "getFillColor",
				defaultValue: DEFAULT_COLOR$1
			},
			lineColors: {
				size: this.props.colorFormat.length,
				type: "unorm8",
				stepMode: "dynamic",
				transition: ATTRIBUTE_TRANSITION,
				accessor: "getLineColor",
				defaultValue: DEFAULT_COLOR$1
			},
			pickingColors: {
				size: 4,
				type: "uint8",
				stepMode: "dynamic",
				accessor: (object, { index, target: value }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value)
			}
		});
	}
	getPickingInfo(params) {
		const info = super.getPickingInfo(params);
		const { index } = info;
		const data = this.props.data;
		if (data[0] && data[0].__source) info.object = data.find((d$1) => d$1.__source.index === index);
		return info;
	}
	disablePickingIndex(objectIndex) {
		const data = this.props.data;
		if (data[0] && data[0].__source) {
			for (let i$1 = 0; i$1 < data.length; i$1++) if (data[i$1].__source.index === objectIndex) this._disablePickingIndex(i$1);
		} else super.disablePickingIndex(objectIndex);
	}
	draw({ uniforms }) {
		const { extruded, filled, wireframe, elevationScale } = this.props;
		const { topModel, sideModel, wireframeModel, polygonTesselator } = this.state;
		const renderUniforms = {
			extruded: Boolean(extruded),
			elevationScale,
			isWireframe: false
		};
		if (wireframeModel && wireframe) {
			wireframeModel.setInstanceCount(polygonTesselator.instanceCount - 1);
			wireframeModel.shaderInputs.setProps({ solidPolygon: {
				...renderUniforms,
				isWireframe: true
			} });
			wireframeModel.draw(this.context.renderPass);
		}
		if (sideModel && filled) {
			sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);
			sideModel.shaderInputs.setProps({ solidPolygon: renderUniforms });
			sideModel.draw(this.context.renderPass);
		}
		if (topModel && filled) {
			topModel.setVertexCount(polygonTesselator.vertexCount);
			topModel.shaderInputs.setProps({ solidPolygon: renderUniforms });
			topModel.draw(this.context.renderPass);
		}
	}
	updateState(updateParams) {
		super.updateState(updateParams);
		this.updateGeometry(updateParams);
		const { props, oldProps, changeFlags } = updateParams;
		const attributeManager = this.getAttributeManager();
		if (changeFlags.extensionsChanged || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded) {
			this.state.models?.forEach((model) => model.destroy());
			this.setState(this._getModels());
			attributeManager.invalidateAll();
		}
	}
	updateGeometry({ props, oldProps, changeFlags }) {
		if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon)) {
			const { polygonTesselator } = this.state;
			const buffers = props.data.attributes || {};
			polygonTesselator.updateGeometry({
				data: props.data,
				normalize: props._normalize,
				geometryBuffer: buffers.getPolygon,
				buffers,
				getGeometry: props.getPolygon,
				positionFormat: props.positionFormat,
				wrapLongitude: props.wrapLongitude,
				resolution: this.context.viewport.resolution,
				fp64: this.use64bitPositions(),
				dataChanged: changeFlags.dataChanged,
				full3d: props._full3d
			});
			this.setState({
				numInstances: polygonTesselator.instanceCount,
				startIndices: polygonTesselator.vertexStarts
			});
			if (!changeFlags.dataChanged) this.getAttributeManager().invalidateAll();
		}
	}
	_getModels() {
		const { id, filled, extruded } = this.props;
		let topModel;
		let sideModel;
		let wireframeModel;
		if (filled) {
			const shaders = this.getShaders("top");
			shaders.defines.NON_INSTANCED_MODEL = 1;
			const bufferLayout = this.getAttributeManager().getBufferLayouts({ isInstanced: false });
			topModel = new Model(this.context.device, {
				...shaders,
				id: `${id}-top`,
				topology: "triangle-list",
				bufferLayout,
				isIndexed: true,
				userData: { excludeAttributes: { instanceVertexValid: true } }
			});
		}
		if (extruded) {
			const bufferLayout = this.getAttributeManager().getBufferLayouts({ isInstanced: true });
			sideModel = new Model(this.context.device, {
				...this.getShaders("side"),
				id: `${id}-side`,
				bufferLayout,
				geometry: new Geometry({
					topology: "triangle-strip",
					attributes: { positions: {
						size: 2,
						value: new Float32Array([
							1,
							0,
							0,
							0,
							1,
							1,
							0,
							1
						])
					} }
				}),
				isInstanced: true,
				userData: { excludeAttributes: { indices: true } }
			});
			wireframeModel = new Model(this.context.device, {
				...this.getShaders("side"),
				id: `${id}-wireframe`,
				bufferLayout,
				geometry: new Geometry({
					topology: "line-strip",
					attributes: { positions: {
						size: 2,
						value: new Float32Array([
							1,
							0,
							0,
							0,
							0,
							1,
							1,
							1
						])
					} }
				}),
				isInstanced: true,
				userData: { excludeAttributes: { indices: true } }
			});
		}
		return {
			models: [
				sideModel,
				wireframeModel,
				topModel
			].filter(Boolean),
			topModel,
			sideModel,
			wireframeModel
		};
	}
	calculateIndices(attribute) {
		const { polygonTesselator } = this.state;
		attribute.startIndices = polygonTesselator.indexStarts;
		attribute.value = polygonTesselator.get("indices");
	}
	calculatePositions(attribute) {
		const { polygonTesselator } = this.state;
		attribute.startIndices = polygonTesselator.vertexStarts;
		attribute.value = polygonTesselator.get("positions");
	}
	calculateVertexValid(attribute) {
		attribute.value = this.state.polygonTesselator.get("vertexValid");
	}
};
SolidPolygonLayer.defaultProps = defaultProps$5;
SolidPolygonLayer.layerName = "SolidPolygonLayer";
var solid_polygon_layer_default = SolidPolygonLayer;

//#endregion
//#region node_modules/@deck.gl/layers/dist/utils.js
function replaceInRange({ data, getIndex, dataRange, replace }) {
	const { startRow = 0, endRow = Infinity } = dataRange;
	const count$1 = data.length;
	let replaceStart = count$1;
	let replaceEnd = count$1;
	for (let i$1 = 0; i$1 < count$1; i$1++) {
		const row = getIndex(data[i$1]);
		if (replaceStart > i$1 && row >= startRow) replaceStart = i$1;
		if (row >= endRow) {
			replaceEnd = i$1;
			break;
		}
	}
	let index = replaceStart;
	const endChunk = replaceEnd - replaceStart !== replace.length ? data.slice(replaceEnd) : void 0;
	for (let i$1 = 0; i$1 < replace.length; i$1++) data[index++] = replace[i$1];
	if (endChunk) {
		for (let i$1 = 0; i$1 < endChunk.length; i$1++) data[index++] = endChunk[i$1];
		data.length = index;
	}
	return {
		startRow: replaceStart,
		endRow: replaceStart + replace.length
	};
}

//#endregion
//#region node_modules/@deck.gl/layers/dist/polygon-layer/polygon-layer.js
var defaultLineColor = [
	0,
	0,
	0,
	255
];
var defaultProps$4 = {
	stroked: true,
	filled: true,
	extruded: false,
	elevationScale: 1,
	wireframe: false,
	_normalize: true,
	_windingOrder: "CW",
	lineWidthUnits: "meters",
	lineWidthScale: 1,
	lineWidthMinPixels: 0,
	lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
	lineJointRounded: false,
	lineMiterLimit: 4,
	getPolygon: {
		type: "accessor",
		value: (f$1) => f$1.polygon
	},
	getFillColor: {
		type: "accessor",
		value: [
			0,
			0,
			0,
			255
		]
	},
	getLineColor: {
		type: "accessor",
		value: defaultLineColor
	},
	getLineWidth: {
		type: "accessor",
		value: 1
	},
	getElevation: {
		type: "accessor",
		value: 1e3
	},
	material: true
};
/** A composite layer that renders filled, stroked and/or extruded polygons. */
var PolygonLayer = class extends composite_layer_default {
	initializeState() {
		this.state = {
			paths: [],
			pathsDiff: null
		};
		if (this.props.getLineDashArray) log_default.removed("getLineDashArray", "PathStyleExtension")();
	}
	updateState({ changeFlags }) {
		const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
		if (geometryChanged && Array.isArray(changeFlags.dataChanged)) {
			const paths = this.state.paths.slice();
			const pathsDiff = changeFlags.dataChanged.map((dataRange) => replaceInRange({
				data: paths,
				getIndex: (p$1) => p$1.__source.index,
				dataRange,
				replace: this._getPaths(dataRange)
			}));
			this.setState({
				paths,
				pathsDiff
			});
		} else if (geometryChanged) this.setState({
			paths: this._getPaths(),
			pathsDiff: null
		});
	}
	_getPaths(dataRange = {}) {
		const { data, getPolygon, positionFormat, _normalize } = this.props;
		const paths = [];
		const positionSize = positionFormat === "XY" ? 2 : 3;
		const { startRow, endRow } = dataRange;
		const { iterable, objectInfo } = createIterable(data, startRow, endRow);
		for (const object of iterable) {
			objectInfo.index++;
			let polygon = getPolygon(object, objectInfo);
			if (_normalize) polygon = normalize(polygon, positionSize);
			const { holeIndices } = polygon;
			const positions = polygon.positions || polygon;
			if (holeIndices) for (let i$1 = 0; i$1 <= holeIndices.length; i$1++) {
				const path = positions.slice(holeIndices[i$1 - 1] || 0, holeIndices[i$1] || positions.length);
				paths.push(this.getSubLayerRow({ path }, object, objectInfo.index));
			}
			else paths.push(this.getSubLayerRow({ path: positions }, object, objectInfo.index));
		}
		return paths;
	}
	renderLayers() {
		const { data, _dataDiff, stroked, filled, extruded, wireframe, _normalize, _windingOrder, elevationScale, transitions, positionFormat } = this.props;
		const { lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels, lineJointRounded, lineMiterLimit, lineDashJustified } = this.props;
		const { getFillColor, getLineColor, getLineWidth, getLineDashArray, getElevation, getPolygon, updateTriggers, material } = this.props;
		const { paths, pathsDiff } = this.state;
		const FillLayer = this.getSubLayerClass("fill", solid_polygon_layer_default);
		const StrokeLayer = this.getSubLayerClass("stroke", path_layer_default);
		const polygonLayer = this.shouldRenderSubLayer("fill", paths) && new FillLayer({
			_dataDiff,
			extruded,
			elevationScale,
			filled,
			wireframe,
			_normalize,
			_windingOrder,
			getElevation,
			getFillColor,
			getLineColor: extruded && wireframe ? getLineColor : defaultLineColor,
			material,
			transitions
		}, this.getSubLayerProps({
			id: "fill",
			updateTriggers: updateTriggers && {
				getPolygon: updateTriggers.getPolygon,
				getElevation: updateTriggers.getElevation,
				getFillColor: updateTriggers.getFillColor,
				lineColors: extruded && wireframe,
				getLineColor: updateTriggers.getLineColor
			}
		}), {
			data,
			positionFormat,
			getPolygon
		});
		const polygonLineLayer = !extruded && stroked && this.shouldRenderSubLayer("stroke", paths) && new StrokeLayer({
			_dataDiff: pathsDiff && (() => pathsDiff),
			widthUnits: lineWidthUnits,
			widthScale: lineWidthScale,
			widthMinPixels: lineWidthMinPixels,
			widthMaxPixels: lineWidthMaxPixels,
			jointRounded: lineJointRounded,
			miterLimit: lineMiterLimit,
			dashJustified: lineDashJustified,
			_pathType: "loop",
			transitions: transitions && {
				getWidth: transitions.getLineWidth,
				getColor: transitions.getLineColor,
				getPath: transitions.getPolygon
			},
			getColor: this.getSubLayerAccessor(getLineColor),
			getWidth: this.getSubLayerAccessor(getLineWidth),
			getDashArray: this.getSubLayerAccessor(getLineDashArray)
		}, this.getSubLayerProps({
			id: "stroke",
			updateTriggers: updateTriggers && {
				getWidth: updateTriggers.getLineWidth,
				getColor: updateTriggers.getLineColor,
				getDashArray: updateTriggers.getLineDashArray
			}
		}), {
			data: paths,
			positionFormat,
			getPath: (x$1) => x$1.path
		});
		return [
			!extruded && polygonLayer,
			polygonLineLayer,
			extruded && polygonLayer
		];
	}
};
PolygonLayer.layerName = "PolygonLayer";
PolygonLayer.defaultProps = defaultProps$4;
var polygon_layer_default = PolygonLayer;

//#endregion
//#region node_modules/@deck.gl/layers/dist/geojson-layer/geojson-binary.js
/**
* Return the feature for an accesor
*/
function binaryToFeatureForAccesor(data, index) {
	if (!data) return null;
	const featureIndex = "startIndices" in data ? data.startIndices[index] : index;
	const geometryIndex = data.featureIds.value[featureIndex];
	if (featureIndex !== -1) return getPropertiesForIndex(data, geometryIndex, featureIndex);
	return null;
}
function getPropertiesForIndex(data, propertiesIndex, numericPropsIndex) {
	const feature = { properties: { ...data.properties[propertiesIndex] } };
	for (const prop in data.numericProps) feature.properties[prop] = data.numericProps[prop].value[numericPropsIndex];
	return feature;
}
function calculatePickingColors(geojsonBinary, encodePickingColor) {
	const pickingColors = {
		points: null,
		lines: null,
		polygons: null
	};
	for (const key in pickingColors) {
		const featureIds = geojsonBinary[key].globalFeatureIds.value;
		pickingColors[key] = new Uint8ClampedArray(featureIds.length * 4);
		const pickingColor = [];
		for (let i$1 = 0; i$1 < featureIds.length; i$1++) {
			encodePickingColor(featureIds[i$1], pickingColor);
			pickingColors[key][i$1 * 4 + 0] = pickingColor[0];
			pickingColors[key][i$1 * 4 + 1] = pickingColor[1];
			pickingColors[key][i$1 * 4 + 2] = pickingColor[2];
			pickingColors[key][i$1 * 4 + 3] = 255;
		}
	}
	return pickingColors;
}

//#endregion
//#region node_modules/@deck.gl/layers/dist/text-layer/multi-icon-layer/sdf-uniforms.js
var uniformBlock$1 = `\
uniform sdfUniforms {
  float gamma;
  bool enabled;
  float buffer;
  float outlineBuffer;
  vec4 outlineColor;
} sdf;
`;
const sdfUniforms = {
	name: "sdf",
	vs: uniformBlock$1,
	fs: uniformBlock$1,
	uniformTypes: {
		gamma: "f32",
		enabled: "f32",
		buffer: "f32",
		outlineBuffer: "f32",
		outlineColor: "vec4<f32>"
	}
};

//#endregion
//#region node_modules/@deck.gl/layers/dist/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.js
var multi_icon_layer_fragment_glsl_default = `\
#version 300 es
#define SHADER_NAME multi-icon-layer-fragment-shader
precision highp float;
uniform sampler2D iconsTexture;
in vec4 vColor;
in vec2 vTextureCoords;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
if (!bool(picking.isActive)) {
float alpha = texture(iconsTexture, vTextureCoords).a;
vec4 color = vColor;
if (sdf.enabled) {
float distance = alpha;
alpha = smoothstep(sdf.buffer - sdf.gamma, sdf.buffer + sdf.gamma, distance);
if (sdf.outlineBuffer > 0.0) {
float inFill = alpha;
float inBorder = smoothstep(sdf.outlineBuffer - sdf.gamma, sdf.outlineBuffer + sdf.gamma, distance);
color = mix(sdf.outlineColor, vColor, inFill);
alpha = inBorder;
}
}
float a = alpha * color.a;
if (a < icon.alphaCutoff) {
discard;
}
fragColor = vec4(color.rgb, a * layer.opacity);
}
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

//#endregion
//#region node_modules/@deck.gl/layers/dist/text-layer/multi-icon-layer/multi-icon-layer.js
var DEFAULT_BUFFER = 192 / 256;
var EMPTY_ARRAY = [];
var defaultProps$3 = {
	getIconOffsets: {
		type: "accessor",
		value: (x$1) => x$1.offsets
	},
	alphaCutoff: .001,
	smoothing: .1,
	outlineWidth: 0,
	outlineColor: {
		type: "color",
		value: [
			0,
			0,
			0,
			255
		]
	}
};
var MultiIconLayer = class extends icon_layer_default {
	getShaders() {
		const shaders = super.getShaders();
		return {
			...shaders,
			modules: [...shaders.modules, sdfUniforms],
			fs: multi_icon_layer_fragment_glsl_default
		};
	}
	initializeState() {
		super.initializeState();
		this.getAttributeManager().addInstanced({
			instanceOffsets: {
				size: 2,
				accessor: "getIconOffsets"
			},
			instancePickingColors: {
				type: "uint8",
				size: 3,
				accessor: (object, { index, target: value }) => this.encodePickingColor(index, value)
			}
		});
	}
	updateState(params) {
		super.updateState(params);
		const { props, oldProps } = params;
		let { outlineColor } = props;
		if (outlineColor !== oldProps.outlineColor) {
			outlineColor = outlineColor.map((x$1) => x$1 / 255);
			outlineColor[3] = Number.isFinite(outlineColor[3]) ? outlineColor[3] : 1;
			this.setState({ outlineColor });
		}
		if (!props.sdf && props.outlineWidth) log_default.warn(`${this.id}: fontSettings.sdf is required to render outline`)();
	}
	draw(params) {
		const { sdf, smoothing, outlineWidth } = this.props;
		const { outlineColor } = this.state;
		const outlineBuffer = outlineWidth ? Math.max(smoothing, DEFAULT_BUFFER * (1 - outlineWidth)) : -1;
		const model = this.state.model;
		const sdfProps = {
			buffer: DEFAULT_BUFFER,
			outlineBuffer,
			gamma: smoothing,
			enabled: Boolean(sdf),
			outlineColor
		};
		model.shaderInputs.setProps({ sdf: sdfProps });
		super.draw(params);
		if (sdf && outlineWidth) {
			const { iconManager } = this.state;
			if (iconManager.getTexture()) {
				model.shaderInputs.setProps({ sdf: {
					...sdfProps,
					outlineBuffer: DEFAULT_BUFFER
				} });
				model.draw(this.context.renderPass);
			}
		}
	}
	getInstanceOffset(icons) {
		return icons ? Array.from(icons).flatMap((icon) => super.getInstanceOffset(icon)) : EMPTY_ARRAY;
	}
	getInstanceColorMode(icons) {
		return 1;
	}
	getInstanceIconFrame(icons) {
		return icons ? Array.from(icons).flatMap((icon) => super.getInstanceIconFrame(icon)) : EMPTY_ARRAY;
	}
};
MultiIconLayer.defaultProps = defaultProps$3;
MultiIconLayer.layerName = "MultiIconLayer";
var multi_icon_layer_default = MultiIconLayer;

//#endregion
//#region node_modules/@mapbox/tiny-sdf/index.js
var INF = 0x56bc75e2d63100000;
var TinySDF = class {
	constructor({ fontSize = 24, buffer = 3, radius = 8, cutoff = .25, fontFamily = "sans-serif", fontWeight = "normal", fontStyle = "normal", lang = null } = {}) {
		this.buffer = buffer;
		this.cutoff = cutoff;
		this.radius = radius;
		this.lang = lang;
		const size = this.size = fontSize + buffer * 4;
		const ctx$1 = this.ctx = this._createCanvas(size).getContext("2d", { willReadFrequently: true });
		ctx$1.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
		ctx$1.textBaseline = "alphabetic";
		ctx$1.textAlign = "left";
		ctx$1.fillStyle = "black";
		this.gridOuter = new Float64Array(size * size);
		this.gridInner = new Float64Array(size * size);
		this.f = new Float64Array(size);
		this.z = new Float64Array(size + 1);
		this.v = new Uint16Array(size);
	}
	_createCanvas(size) {
		const canvas$1 = document.createElement("canvas");
		canvas$1.width = canvas$1.height = size;
		return canvas$1;
	}
	draw(char) {
		const { width: glyphAdvance, actualBoundingBoxAscent, actualBoundingBoxDescent, actualBoundingBoxLeft, actualBoundingBoxRight } = this.ctx.measureText(char);
		const glyphTop = Math.ceil(actualBoundingBoxAscent);
		const glyphLeft = 0;
		const glyphWidth = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(actualBoundingBoxRight - actualBoundingBoxLeft)));
		const glyphHeight = Math.min(this.size - this.buffer, glyphTop + Math.ceil(actualBoundingBoxDescent));
		const width = glyphWidth + 2 * this.buffer;
		const height = glyphHeight + 2 * this.buffer;
		const len = Math.max(width * height, 0);
		const data = new Uint8ClampedArray(len);
		const glyph = {
			data,
			width,
			height,
			glyphWidth,
			glyphHeight,
			glyphTop,
			glyphLeft,
			glyphAdvance
		};
		if (glyphWidth === 0 || glyphHeight === 0) return glyph;
		const { ctx: ctx$1, buffer, gridInner, gridOuter } = this;
		if (this.lang) ctx$1.lang = this.lang;
		ctx$1.clearRect(buffer, buffer, glyphWidth, glyphHeight);
		ctx$1.fillText(char, buffer, buffer + glyphTop);
		const imgData = ctx$1.getImageData(buffer, buffer, glyphWidth, glyphHeight);
		gridOuter.fill(INF, 0, len);
		gridInner.fill(0, 0, len);
		for (let y$1 = 0; y$1 < glyphHeight; y$1++) for (let x$1 = 0; x$1 < glyphWidth; x$1++) {
			const a$1 = imgData.data[4 * (y$1 * glyphWidth + x$1) + 3] / 255;
			if (a$1 === 0) continue;
			const j$1 = (y$1 + buffer) * width + x$1 + buffer;
			if (a$1 === 1) {
				gridOuter[j$1] = 0;
				gridInner[j$1] = INF;
			} else {
				const d$1 = .5 - a$1;
				gridOuter[j$1] = d$1 > 0 ? d$1 * d$1 : 0;
				gridInner[j$1] = d$1 < 0 ? d$1 * d$1 : 0;
			}
		}
		edt(gridOuter, 0, 0, width, height, width, this.f, this.v, this.z);
		edt(gridInner, buffer, buffer, glyphWidth, glyphHeight, width, this.f, this.v, this.z);
		for (let i$1 = 0; i$1 < len; i$1++) {
			const d$1 = Math.sqrt(gridOuter[i$1]) - Math.sqrt(gridInner[i$1]);
			data[i$1] = Math.round(255 - 255 * (d$1 / this.radius + this.cutoff));
		}
		return glyph;
	}
};
function edt(data, x0, y0, width, height, gridSize, f$1, v$1, z$1) {
	for (let x$1 = x0; x$1 < x0 + width; x$1++) edt1d(data, y0 * gridSize + x$1, gridSize, height, f$1, v$1, z$1);
	for (let y$1 = y0; y$1 < y0 + height; y$1++) edt1d(data, y$1 * gridSize + x0, 1, width, f$1, v$1, z$1);
}
function edt1d(grid, offset, stride, length, f$1, v$1, z$1) {
	v$1[0] = 0;
	z$1[0] = -INF;
	z$1[1] = INF;
	f$1[0] = grid[offset];
	for (let q$1 = 1, k$1 = 0, s$1 = 0; q$1 < length; q$1++) {
		f$1[q$1] = grid[offset + q$1 * stride];
		const q2 = q$1 * q$1;
		do {
			const r$1 = v$1[k$1];
			s$1 = (f$1[q$1] - f$1[r$1] + q2 - r$1 * r$1) / (q$1 - r$1) / 2;
		} while (s$1 <= z$1[k$1] && --k$1 > -1);
		k$1++;
		v$1[k$1] = q$1;
		z$1[k$1] = s$1;
		z$1[k$1 + 1] = INF;
	}
	for (let q$1 = 0, k$1 = 0; q$1 < length; q$1++) {
		while (z$1[k$1 + 1] < q$1) k$1++;
		const r$1 = v$1[k$1];
		const qr = q$1 - r$1;
		grid[offset + q$1 * stride] = f$1[r$1] + qr * qr;
	}
}

//#endregion
//#region node_modules/@deck.gl/layers/dist/text-layer/utils.js
var MISSING_CHAR_WIDTH = 32;
var SINGLE_LINE = [];
function nextPowOfTwo(number) {
	return Math.pow(2, Math.ceil(Math.log2(number)));
}
/**
* Generate character mapping table or update from an existing mapping table
*/
function buildMapping({ characterSet, getFontWidth, fontHeight, buffer, maxCanvasWidth, mapping = {}, xOffset = 0, yOffset = 0 }) {
	let row = 0;
	let x$1 = xOffset;
	const rowHeight = fontHeight + buffer * 2;
	for (const char of characterSet) if (!mapping[char]) {
		const width = getFontWidth(char);
		if (x$1 + width + buffer * 2 > maxCanvasWidth) {
			x$1 = 0;
			row++;
		}
		mapping[char] = {
			x: x$1 + buffer,
			y: yOffset + row * rowHeight + buffer,
			width,
			height: rowHeight,
			layoutWidth: width,
			layoutHeight: fontHeight
		};
		x$1 += width + buffer * 2;
	}
	return {
		mapping,
		xOffset: x$1,
		yOffset: yOffset + row * rowHeight,
		canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)
	};
}
function getTextWidth(text, startIndex, endIndex, mapping) {
	let width = 0;
	for (let i$1 = startIndex; i$1 < endIndex; i$1++) {
		const character = text[i$1];
		width += mapping[character]?.layoutWidth || 0;
	}
	return width;
}
function breakAll(text, startIndex, endIndex, maxWidth, iconMapping, target) {
	let rowStartCharIndex = startIndex;
	let rowOffsetLeft = 0;
	for (let i$1 = startIndex; i$1 < endIndex; i$1++) {
		const textWidth = getTextWidth(text, i$1, i$1 + 1, iconMapping);
		if (rowOffsetLeft + textWidth > maxWidth) {
			if (rowStartCharIndex < i$1) target.push(i$1);
			rowStartCharIndex = i$1;
			rowOffsetLeft = 0;
		}
		rowOffsetLeft += textWidth;
	}
	return rowOffsetLeft;
}
function breakWord(text, startIndex, endIndex, maxWidth, iconMapping, target) {
	let rowStartCharIndex = startIndex;
	let groupStartCharIndex = startIndex;
	let groupEndCharIndex = startIndex;
	let rowOffsetLeft = 0;
	for (let i$1 = startIndex; i$1 < endIndex; i$1++) {
		if (text[i$1] === " ") groupEndCharIndex = i$1 + 1;
		else if (text[i$1 + 1] === " " || i$1 + 1 === endIndex) groupEndCharIndex = i$1 + 1;
		if (groupEndCharIndex > groupStartCharIndex) {
			let groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);
			if (rowOffsetLeft + groupWidth > maxWidth) {
				if (rowStartCharIndex < groupStartCharIndex) {
					target.push(groupStartCharIndex);
					rowStartCharIndex = groupStartCharIndex;
					rowOffsetLeft = 0;
				}
				if (groupWidth > maxWidth) {
					groupWidth = breakAll(text, groupStartCharIndex, groupEndCharIndex, maxWidth, iconMapping, target);
					rowStartCharIndex = target[target.length - 1];
				}
			}
			groupStartCharIndex = groupEndCharIndex;
			rowOffsetLeft += groupWidth;
		}
	}
	return rowOffsetLeft;
}
/**
* Wrap the given text so that each line does not exceed the given max width.
* Returns a list of indices where line breaks should be inserted.
*/
function autoWrapping(text, wordBreak, maxWidth, iconMapping, startIndex = 0, endIndex) {
	if (endIndex === void 0) endIndex = text.length;
	const result = [];
	if (wordBreak === "break-all") breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);
	else breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);
	return result;
}
function transformRow(line, startIndex, endIndex, iconMapping, leftOffsets, rowSize) {
	let x$1 = 0;
	let rowHeight = 0;
	for (let i$1 = startIndex; i$1 < endIndex; i$1++) {
		const character = line[i$1];
		const frame = iconMapping[character];
		if (frame) {
			if (!rowHeight) rowHeight = frame.layoutHeight;
			leftOffsets[i$1] = x$1 + frame.layoutWidth / 2;
			x$1 += frame.layoutWidth;
		} else {
			log_default.warn(`Missing character: ${character} (${character.codePointAt(0)})`)();
			leftOffsets[i$1] = x$1;
			x$1 += MISSING_CHAR_WIDTH;
		}
	}
	rowSize[0] = x$1;
	rowSize[1] = rowHeight;
}
/**
* Transform a text paragraph to an array of characters, each character contains
*/
function transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {
	const characters = Array.from(paragraph);
	const numCharacters = characters.length;
	const x$1 = new Array(numCharacters);
	const y$1 = new Array(numCharacters);
	const rowWidth = new Array(numCharacters);
	const autoWrappingEnabled = (wordBreak === "break-word" || wordBreak === "break-all") && isFinite(maxWidth) && maxWidth > 0;
	const size = [0, 0];
	const rowSize = [0, 0];
	let rowOffsetTop = 0;
	let lineStartIndex = 0;
	let lineEndIndex = 0;
	for (let i$1 = 0; i$1 <= numCharacters; i$1++) {
		const char = characters[i$1];
		if (char === "\n" || i$1 === numCharacters) lineEndIndex = i$1;
		if (lineEndIndex > lineStartIndex) {
			const rows = autoWrappingEnabled ? autoWrapping(characters, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex) : SINGLE_LINE;
			for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {
				const rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];
				const rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;
				transformRow(characters, rowStart, rowEnd, iconMapping, x$1, rowSize);
				for (let j$1 = rowStart; j$1 < rowEnd; j$1++) {
					const layoutOffsetY = iconMapping[characters[j$1]]?.layoutOffsetY || 0;
					y$1[j$1] = rowOffsetTop + rowSize[1] / 2 + layoutOffsetY;
					rowWidth[j$1] = rowSize[0];
				}
				rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;
				size[0] = Math.max(size[0], rowSize[0]);
			}
			lineStartIndex = lineEndIndex;
		}
		if (char === "\n") {
			x$1[lineStartIndex] = 0;
			y$1[lineStartIndex] = 0;
			rowWidth[lineStartIndex] = 0;
			lineStartIndex++;
		}
	}
	size[1] = rowOffsetTop;
	return {
		x: x$1,
		y: y$1,
		rowWidth,
		size
	};
}
function getTextFromBuffer({ value, length, stride, offset, startIndices, characterSet }) {
	const bytesPerElement = value.BYTES_PER_ELEMENT;
	const elementStride = stride ? stride / bytesPerElement : 1;
	const elementOffset = offset ? offset / bytesPerElement : 0;
	const characterCount = startIndices[length] || Math.ceil((value.length - elementOffset) / elementStride);
	const autoCharacterSet = characterSet && /* @__PURE__ */ new Set();
	const texts = new Array(length);
	let codes = value;
	if (elementStride > 1 || elementOffset > 0) {
		const ArrayType = value.constructor;
		codes = new ArrayType(characterCount);
		for (let i$1 = 0; i$1 < characterCount; i$1++) codes[i$1] = value[i$1 * elementStride + elementOffset];
	}
	for (let index = 0; index < length; index++) {
		const startIndex = startIndices[index];
		const endIndex = startIndices[index + 1] || characterCount;
		const codesAtIndex = codes.subarray(startIndex, endIndex);
		texts[index] = String.fromCodePoint.apply(null, codesAtIndex);
		if (autoCharacterSet) codesAtIndex.forEach(autoCharacterSet.add, autoCharacterSet);
	}
	if (autoCharacterSet) for (const charCode of autoCharacterSet) characterSet.add(String.fromCodePoint(charCode));
	return {
		texts,
		characterCount
	};
}

//#endregion
//#region node_modules/@deck.gl/layers/dist/text-layer/lru-cache.js
/**
* LRU Cache class with limit
*
* Update order for each get/set operation
* Delete oldest when reach given limit
*/
var LRUCache = class {
	constructor(limit = 5) {
		this._cache = {};
		/** access/update order, first item is oldest, last item is newest */
		this._order = [];
		this.limit = limit;
	}
	get(key) {
		const value = this._cache[key];
		if (value) {
			this._deleteOrder(key);
			this._appendOrder(key);
		}
		return value;
	}
	set(key, value) {
		if (!this._cache[key]) {
			if (Object.keys(this._cache).length === this.limit) this.delete(this._order[0]);
			this._cache[key] = value;
			this._appendOrder(key);
		} else {
			this.delete(key);
			this._cache[key] = value;
			this._appendOrder(key);
		}
	}
	delete(key) {
		if (this._cache[key]) {
			delete this._cache[key];
			this._deleteOrder(key);
		}
	}
	_deleteOrder(key) {
		const index = this._order.indexOf(key);
		if (index >= 0) this._order.splice(index, 1);
	}
	_appendOrder(key) {
		this._order.push(key);
	}
};

//#endregion
//#region node_modules/@deck.gl/layers/dist/text-layer/font-atlas-manager.js
function getDefaultCharacterSet() {
	const charSet = [];
	for (let i$1 = 32; i$1 < 128; i$1++) charSet.push(String.fromCharCode(i$1));
	return charSet;
}
const DEFAULT_FONT_SETTINGS = {
	fontFamily: "Monaco, monospace",
	fontWeight: "normal",
	characterSet: getDefaultCharacterSet(),
	fontSize: 64,
	buffer: 4,
	sdf: false,
	cutoff: .25,
	radius: 12,
	smoothing: .1
};
var MAX_CANVAS_WIDTH = 1024;
var BASELINE_SCALE = .9;
var HEIGHT_SCALE = 1.2;
var CACHE_LIMIT = 3;
var cache = new LRUCache(CACHE_LIMIT);
/**
* get all the chars not in cache
* @returns chars not in cache
*/
function getNewChars(cacheKey, characterSet) {
	let newCharSet;
	if (typeof characterSet === "string") newCharSet = new Set(Array.from(characterSet));
	else newCharSet = new Set(characterSet);
	const cachedFontAtlas = cache.get(cacheKey);
	if (!cachedFontAtlas) return newCharSet;
	for (const char in cachedFontAtlas.mapping) if (newCharSet.has(char)) newCharSet.delete(char);
	return newCharSet;
}
function populateAlphaChannel(alphaChannel, imageData) {
	for (let i$1 = 0; i$1 < alphaChannel.length; i$1++) imageData.data[4 * i$1 + 3] = alphaChannel[i$1];
}
function setTextStyle(ctx$1, fontFamily, fontSize, fontWeight) {
	ctx$1.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
	ctx$1.fillStyle = "#000";
	ctx$1.textBaseline = "alphabetic";
	ctx$1.textAlign = "left";
}
/**
* Sets the Font Atlas LRU Cache Limit
* @param {number} limit LRU Cache limit
*/
function setFontAtlasCacheLimit(limit) {
	log_default.assert(Number.isFinite(limit) && limit >= CACHE_LIMIT, "Invalid cache limit");
	cache = new LRUCache(limit);
}
var FontAtlasManager = class {
	constructor() {
		/** Font settings */
		this.props = { ...DEFAULT_FONT_SETTINGS };
	}
	get atlas() {
		return this._atlas;
	}
	get mapping() {
		return this._atlas && this._atlas.mapping;
	}
	get scale() {
		const { fontSize, buffer } = this.props;
		return (fontSize * HEIGHT_SCALE + buffer * 2) / fontSize;
	}
	setProps(props = {}) {
		Object.assign(this.props, props);
		this._key = this._getKey();
		const charSet = getNewChars(this._key, this.props.characterSet);
		const cachedFontAtlas = cache.get(this._key);
		if (cachedFontAtlas && charSet.size === 0) {
			if (this._atlas !== cachedFontAtlas) this._atlas = cachedFontAtlas;
			return;
		}
		const fontAtlas = this._generateFontAtlas(charSet, cachedFontAtlas);
		this._atlas = fontAtlas;
		cache.set(this._key, fontAtlas);
	}
	_generateFontAtlas(characterSet, cachedFontAtlas) {
		const { fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff } = this.props;
		let canvas$1 = cachedFontAtlas && cachedFontAtlas.data;
		if (!canvas$1) {
			canvas$1 = document.createElement("canvas");
			canvas$1.width = MAX_CANVAS_WIDTH;
		}
		const ctx$1 = canvas$1.getContext("2d", { willReadFrequently: true });
		setTextStyle(ctx$1, fontFamily, fontSize, fontWeight);
		const { mapping, canvasHeight, xOffset, yOffset } = buildMapping({
			getFontWidth: (char) => ctx$1.measureText(char).width,
			fontHeight: fontSize * HEIGHT_SCALE,
			buffer,
			characterSet,
			maxCanvasWidth: MAX_CANVAS_WIDTH,
			...cachedFontAtlas && {
				mapping: cachedFontAtlas.mapping,
				xOffset: cachedFontAtlas.xOffset,
				yOffset: cachedFontAtlas.yOffset
			}
		});
		if (canvas$1.height !== canvasHeight) {
			const imageData = ctx$1.getImageData(0, 0, canvas$1.width, canvas$1.height);
			canvas$1.height = canvasHeight;
			ctx$1.putImageData(imageData, 0, 0);
		}
		setTextStyle(ctx$1, fontFamily, fontSize, fontWeight);
		if (sdf) {
			const tinySDF = new TinySDF({
				fontSize,
				buffer,
				radius,
				cutoff,
				fontFamily,
				fontWeight: `${fontWeight}`
			});
			for (const char of characterSet) {
				const { data, width, height, glyphTop } = tinySDF.draw(char);
				mapping[char].width = width;
				mapping[char].layoutOffsetY = fontSize * BASELINE_SCALE - glyphTop;
				const imageData = ctx$1.createImageData(width, height);
				populateAlphaChannel(data, imageData);
				ctx$1.putImageData(imageData, mapping[char].x, mapping[char].y);
			}
		} else for (const char of characterSet) ctx$1.fillText(char, mapping[char].x, mapping[char].y + buffer + fontSize * BASELINE_SCALE);
		return {
			xOffset,
			yOffset,
			mapping,
			data: canvas$1,
			width: canvas$1.width,
			height: canvas$1.height
		};
	}
	_getKey() {
		const { fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff } = this.props;
		if (sdf) return `${fontFamily} ${fontWeight} ${fontSize} ${buffer} ${radius} ${cutoff}`;
		return `${fontFamily} ${fontWeight} ${fontSize} ${buffer}`;
	}
};

//#endregion
//#region node_modules/@deck.gl/layers/dist/text-layer/text-background-layer/text-background-layer-uniforms.js
var uniformBlock = `\
uniform textBackgroundUniforms {
  bool billboard;
  float sizeScale;
  float sizeMinPixels;
  float sizeMaxPixels;
  vec4 borderRadius;
  vec4 padding;
  highp int sizeUnits;
  bool stroked;
} textBackground;
`;
const textBackgroundUniforms = {
	name: "textBackground",
	vs: uniformBlock,
	fs: uniformBlock,
	uniformTypes: {
		billboard: "f32",
		sizeScale: "f32",
		sizeMinPixels: "f32",
		sizeMaxPixels: "f32",
		borderRadius: "vec4<f32>",
		padding: "vec4<f32>",
		sizeUnits: "i32",
		stroked: "f32"
	}
};

//#endregion
//#region node_modules/@deck.gl/layers/dist/text-layer/text-background-layer/text-background-layer-vertex.glsl.js
var text_background_layer_vertex_glsl_default = `\
#version 300 es
#define SHADER_NAME text-background-layer-vertex-shader
in vec2 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceRects;
in float instanceSizes;
in float instanceAngles;
in vec2 instancePixelOffsets;
in float instanceLineWidths;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
out vec4 vFillColor;
out vec4 vLineColor;
out float vLineWidth;
out vec2 uv;
out vec2 dimensions;
vec2 rotate_by_angle(vec2 vertex, float angle) {
float angle_radian = radians(angle);
float cos_angle = cos(angle_radian);
float sin_angle = sin(angle_radian);
mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
return rotationMatrix * vertex;
}
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = positions;
geometry.pickingColor = instancePickingColors;
uv = positions;
vLineWidth = instanceLineWidths;
float sizePixels = clamp(
project_size_to_pixel(instanceSizes * textBackground.sizeScale, textBackground.sizeUnits),
textBackground.sizeMinPixels, textBackground.sizeMaxPixels
);
dimensions = instanceRects.zw * sizePixels + textBackground.padding.xy + textBackground.padding.zw;
vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-textBackground.padding.xy, textBackground.padding.zw, positions);
pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);
pixelOffset += instancePixelOffsets;
pixelOffset.y *= -1.0;
if (textBackground.billboard)  {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = vec3(pixelOffset, 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
DECKGL_FILTER_SIZE(offset_common, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vFillColor, geometry);
vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`;

//#endregion
//#region node_modules/@deck.gl/layers/dist/text-layer/text-background-layer/text-background-layer-fragment.glsl.js
var text_background_layer_fragment_glsl_default = `\
#version 300 es
#define SHADER_NAME text-background-layer-fragment-shader
precision highp float;
in vec4 vFillColor;
in vec4 vLineColor;
in float vLineWidth;
in vec2 uv;
in vec2 dimensions;
out vec4 fragColor;
float round_rect(vec2 p, vec2 size, vec4 radii) {
vec2 pixelPositionCB = (p - 0.5) * size;
vec2 sizeCB = size * 0.5;
float maxBorderRadius = min(size.x, size.y) * 0.5;
vec4 borderRadius = vec4(min(radii, maxBorderRadius));
borderRadius.xy =
(pixelPositionCB.x > 0.0) ? borderRadius.xy : borderRadius.zw;
borderRadius.x = (pixelPositionCB.y > 0.0) ? borderRadius.x : borderRadius.y;
vec2 q = abs(pixelPositionCB) - sizeCB + borderRadius.x;
return -(min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - borderRadius.x);
}
float rect(vec2 p, vec2 size) {
vec2 pixelPosition = p * size;
return min(min(pixelPosition.x, size.x - pixelPosition.x),
min(pixelPosition.y, size.y - pixelPosition.y));
}
vec4 get_stroked_fragColor(float dist) {
float isBorder = smoothedge(dist, vLineWidth);
return mix(vFillColor, vLineColor, isBorder);
}
void main(void) {
geometry.uv = uv;
if (textBackground.borderRadius != vec4(0.0)) {
float distToEdge = round_rect(uv, dimensions, textBackground.borderRadius);
if (textBackground.stroked) {
fragColor = get_stroked_fragColor(distToEdge);
} else {
fragColor = vFillColor;
}
float shapeAlpha = smoothedge(-distToEdge, 0.0);
fragColor.a *= shapeAlpha;
} else {
if (textBackground.stroked) {
float distToEdge = rect(uv, dimensions);
fragColor = get_stroked_fragColor(distToEdge);
} else {
fragColor = vFillColor;
}
}
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

//#endregion
//#region node_modules/@deck.gl/layers/dist/text-layer/text-background-layer/text-background-layer.js
var defaultProps$2 = {
	billboard: true,
	sizeScale: 1,
	sizeUnits: "pixels",
	sizeMinPixels: 0,
	sizeMaxPixels: Number.MAX_SAFE_INTEGER,
	borderRadius: {
		type: "object",
		value: 0
	},
	padding: {
		type: "array",
		value: [
			0,
			0,
			0,
			0
		]
	},
	getPosition: {
		type: "accessor",
		value: (x$1) => x$1.position
	},
	getSize: {
		type: "accessor",
		value: 1
	},
	getAngle: {
		type: "accessor",
		value: 0
	},
	getPixelOffset: {
		type: "accessor",
		value: [0, 0]
	},
	getBoundingRect: {
		type: "accessor",
		value: [
			0,
			0,
			0,
			0
		]
	},
	getFillColor: {
		type: "accessor",
		value: [
			0,
			0,
			0,
			255
		]
	},
	getLineColor: {
		type: "accessor",
		value: [
			0,
			0,
			0,
			255
		]
	},
	getLineWidth: {
		type: "accessor",
		value: 1
	}
};
var TextBackgroundLayer = class extends layer_default {
	getShaders() {
		return super.getShaders({
			vs: text_background_layer_vertex_glsl_default,
			fs: text_background_layer_fragment_glsl_default,
			modules: [
				project32_default,
				picking_default,
				textBackgroundUniforms
			]
		});
	}
	initializeState() {
		this.getAttributeManager().addInstanced({
			instancePositions: {
				size: 3,
				type: "float64",
				fp64: this.use64bitPositions(),
				transition: true,
				accessor: "getPosition"
			},
			instanceSizes: {
				size: 1,
				transition: true,
				accessor: "getSize",
				defaultValue: 1
			},
			instanceAngles: {
				size: 1,
				transition: true,
				accessor: "getAngle"
			},
			instanceRects: {
				size: 4,
				accessor: "getBoundingRect"
			},
			instancePixelOffsets: {
				size: 2,
				transition: true,
				accessor: "getPixelOffset"
			},
			instanceFillColors: {
				size: 4,
				transition: true,
				type: "unorm8",
				accessor: "getFillColor",
				defaultValue: [
					0,
					0,
					0,
					255
				]
			},
			instanceLineColors: {
				size: 4,
				transition: true,
				type: "unorm8",
				accessor: "getLineColor",
				defaultValue: [
					0,
					0,
					0,
					255
				]
			},
			instanceLineWidths: {
				size: 1,
				transition: true,
				accessor: "getLineWidth",
				defaultValue: 1
			}
		});
	}
	updateState(params) {
		super.updateState(params);
		const { changeFlags } = params;
		if (changeFlags.extensionsChanged) {
			this.state.model?.destroy();
			this.state.model = this._getModel();
			this.getAttributeManager().invalidateAll();
		}
	}
	draw({ uniforms }) {
		const { billboard, sizeScale, sizeUnits, sizeMinPixels, sizeMaxPixels, getLineWidth } = this.props;
		let { padding, borderRadius } = this.props;
		if (padding.length < 4) padding = [
			padding[0],
			padding[1],
			padding[0],
			padding[1]
		];
		if (!Array.isArray(borderRadius)) borderRadius = [
			borderRadius,
			borderRadius,
			borderRadius,
			borderRadius
		];
		const model = this.state.model;
		const textBackgroundProps = {
			billboard,
			stroked: Boolean(getLineWidth),
			borderRadius,
			padding,
			sizeUnits: UNIT[sizeUnits],
			sizeScale,
			sizeMinPixels,
			sizeMaxPixels
		};
		model.shaderInputs.setProps({ textBackground: textBackgroundProps });
		model.draw(this.context.renderPass);
	}
	_getModel() {
		const positions = [
			0,
			0,
			1,
			0,
			0,
			1,
			1,
			1
		];
		return new Model(this.context.device, {
			...this.getShaders(),
			id: this.props.id,
			bufferLayout: this.getAttributeManager().getBufferLayouts(),
			geometry: new Geometry({
				topology: "triangle-strip",
				vertexCount: 4,
				attributes: { positions: {
					size: 2,
					value: new Float32Array(positions)
				} }
			}),
			isInstanced: true
		});
	}
};
TextBackgroundLayer.defaultProps = defaultProps$2;
TextBackgroundLayer.layerName = "TextBackgroundLayer";
var text_background_layer_default = TextBackgroundLayer;

//#endregion
//#region node_modules/@deck.gl/layers/dist/text-layer/text-layer.js
var TEXT_ANCHOR = {
	start: 1,
	middle: 0,
	end: -1
};
var ALIGNMENT_BASELINE = {
	top: 1,
	center: 0,
	bottom: -1
};
var DEFAULT_COLOR = [
	0,
	0,
	0,
	255
];
var defaultProps$1 = {
	billboard: true,
	sizeScale: 1,
	sizeUnits: "pixels",
	sizeMinPixels: 0,
	sizeMaxPixels: Number.MAX_SAFE_INTEGER,
	background: false,
	getBackgroundColor: {
		type: "accessor",
		value: [
			255,
			255,
			255,
			255
		]
	},
	getBorderColor: {
		type: "accessor",
		value: DEFAULT_COLOR
	},
	getBorderWidth: {
		type: "accessor",
		value: 0
	},
	backgroundBorderRadius: {
		type: "object",
		value: 0
	},
	backgroundPadding: {
		type: "array",
		value: [
			0,
			0,
			0,
			0
		]
	},
	characterSet: {
		type: "object",
		value: DEFAULT_FONT_SETTINGS.characterSet
	},
	fontFamily: DEFAULT_FONT_SETTINGS.fontFamily,
	fontWeight: DEFAULT_FONT_SETTINGS.fontWeight,
	lineHeight: 1,
	outlineWidth: {
		type: "number",
		value: 0,
		min: 0
	},
	outlineColor: {
		type: "color",
		value: DEFAULT_COLOR
	},
	fontSettings: {
		type: "object",
		value: {},
		compare: 1
	},
	wordBreak: "break-word",
	maxWidth: {
		type: "number",
		value: -1
	},
	getText: {
		type: "accessor",
		value: (x$1) => x$1.text
	},
	getPosition: {
		type: "accessor",
		value: (x$1) => x$1.position
	},
	getColor: {
		type: "accessor",
		value: DEFAULT_COLOR
	},
	getSize: {
		type: "accessor",
		value: 32
	},
	getAngle: {
		type: "accessor",
		value: 0
	},
	getTextAnchor: {
		type: "accessor",
		value: "middle"
	},
	getAlignmentBaseline: {
		type: "accessor",
		value: "center"
	},
	getPixelOffset: {
		type: "accessor",
		value: [0, 0]
	},
	backgroundColor: { deprecatedFor: ["background", "getBackgroundColor"] }
};
/** Render text labels at given coordinates. */
var TextLayer = class extends composite_layer_default {
	constructor() {
		super(...arguments);
		/** Returns the x, y, width, height of each text string, relative to pixel size.
		* Used to render the background.
		*/
		this.getBoundingRect = (object, objectInfo) => {
			let { size: [width, height] } = this.transformParagraph(object, objectInfo);
			const { fontSize } = this.state.fontAtlasManager.props;
			width /= fontSize;
			height /= fontSize;
			const { getTextAnchor, getAlignmentBaseline } = this.props;
			const anchorX = TEXT_ANCHOR[typeof getTextAnchor === "function" ? getTextAnchor(object, objectInfo) : getTextAnchor];
			const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === "function" ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
			return [
				(anchorX - 1) * width / 2,
				(anchorY - 1) * height / 2,
				width,
				height
			];
		};
		/** Returns the x, y offsets of each character in a text string, in texture size.
		* Used to layout characters in the vertex shader.
		*/
		this.getIconOffsets = (object, objectInfo) => {
			const { getTextAnchor, getAlignmentBaseline } = this.props;
			const { x: x$1, y: y$1, rowWidth, size: [width, height] } = this.transformParagraph(object, objectInfo);
			const anchorX = TEXT_ANCHOR[typeof getTextAnchor === "function" ? getTextAnchor(object, objectInfo) : getTextAnchor];
			const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === "function" ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
			const numCharacters = x$1.length;
			const offsets = new Array(numCharacters * 2);
			let index = 0;
			for (let i$1 = 0; i$1 < numCharacters; i$1++) {
				const rowOffset = (1 - anchorX) * (width - rowWidth[i$1]) / 2;
				offsets[index++] = (anchorX - 1) * width / 2 + rowOffset + x$1[i$1];
				offsets[index++] = (anchorY - 1) * height / 2 + y$1[i$1];
			}
			return offsets;
		};
	}
	initializeState() {
		this.state = {
			styleVersion: 0,
			fontAtlasManager: new FontAtlasManager()
		};
		if (this.props.maxWidth > 0) log_default.once(1, "v8.9 breaking change: TextLayer maxWidth is now relative to text size")();
	}
	updateState(params) {
		const { props, oldProps, changeFlags } = params;
		if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText)) this._updateText();
		if (this._updateFontAtlas() || props.lineHeight !== oldProps.lineHeight || props.wordBreak !== oldProps.wordBreak || props.maxWidth !== oldProps.maxWidth) this.setState({ styleVersion: this.state.styleVersion + 1 });
	}
	getPickingInfo({ info }) {
		info.object = info.index >= 0 ? this.props.data[info.index] : null;
		return info;
	}
	/** Returns true if font has changed */
	_updateFontAtlas() {
		const { fontSettings, fontFamily, fontWeight } = this.props;
		const { fontAtlasManager, characterSet } = this.state;
		const fontProps = {
			...fontSettings,
			characterSet,
			fontFamily,
			fontWeight
		};
		if (!fontAtlasManager.mapping) {
			fontAtlasManager.setProps(fontProps);
			return true;
		}
		for (const key in fontProps) if (fontProps[key] !== fontAtlasManager.props[key]) {
			fontAtlasManager.setProps(fontProps);
			return true;
		}
		return false;
	}
	_updateText() {
		const { data, characterSet } = this.props;
		const textBuffer = data.attributes?.getText;
		let { getText } = this.props;
		let startIndices = data.startIndices;
		let numInstances;
		const autoCharacterSet = characterSet === "auto" && /* @__PURE__ */ new Set();
		if (textBuffer && startIndices) {
			const { texts, characterCount } = getTextFromBuffer({
				...ArrayBuffer.isView(textBuffer) ? { value: textBuffer } : textBuffer,
				length: data.length,
				startIndices,
				characterSet: autoCharacterSet
			});
			numInstances = characterCount;
			getText = (_$1, { index }) => texts[index];
		} else {
			const { iterable, objectInfo } = createIterable(data);
			startIndices = [0];
			numInstances = 0;
			for (const object of iterable) {
				objectInfo.index++;
				const text = Array.from(getText(object, objectInfo) || "");
				if (autoCharacterSet) text.forEach(autoCharacterSet.add, autoCharacterSet);
				numInstances += text.length;
				startIndices.push(numInstances);
			}
		}
		this.setState({
			getText,
			startIndices,
			numInstances,
			characterSet: autoCharacterSet || characterSet
		});
	}
	/** There are two size systems in this layer:
	
	+ Pixel size: user-specified text size, via getSize, sizeScale, sizeUnits etc.
	The layer roughly matches the output of the layer to CSS pixels, e.g. getSize: 12, sizeScale: 2
	in layer props is roughly equivalent to font-size: 24px in CSS.
	+ Texture size: internally, character positions in a text blob are calculated using the sizes of iconMapping,
	which depends on how large each character is drawn into the font atlas. This is controlled by
	fontSettings.fontSize (default 64) and most users do not set it manually.
	These numbers are intended to be used in the vertex shader and never to be exposed to the end user.
	
	All surfaces exposed to the user should either use the pixel size or a multiplier relative to the pixel size. */
	/** Calculate the size and position of each character in a text string.
	* Values are in texture size */
	transformParagraph(object, objectInfo) {
		const { fontAtlasManager } = this.state;
		const iconMapping = fontAtlasManager.mapping;
		const getText = this.state.getText;
		const { wordBreak, lineHeight, maxWidth } = this.props;
		return transformParagraph(getText(object, objectInfo) || "", lineHeight, wordBreak, maxWidth * fontAtlasManager.props.fontSize, iconMapping);
	}
	renderLayers() {
		const { startIndices, numInstances, getText, fontAtlasManager: { scale, atlas, mapping }, styleVersion } = this.state;
		const { data, _dataDiff, getPosition, getColor, getSize, getAngle, getPixelOffset, getBackgroundColor, getBorderColor, getBorderWidth, backgroundBorderRadius, backgroundPadding, background, billboard, fontSettings, outlineWidth, outlineColor, sizeScale, sizeUnits, sizeMinPixels, sizeMaxPixels, transitions, updateTriggers } = this.props;
		const CharactersLayerClass = this.getSubLayerClass("characters", multi_icon_layer_default);
		const BackgroundLayerClass = this.getSubLayerClass("background", text_background_layer_default);
		return [background && new BackgroundLayerClass({
			getFillColor: getBackgroundColor,
			getLineColor: getBorderColor,
			getLineWidth: getBorderWidth,
			borderRadius: backgroundBorderRadius,
			padding: backgroundPadding,
			getPosition,
			getSize,
			getAngle,
			getPixelOffset,
			billboard,
			sizeScale,
			sizeUnits,
			sizeMinPixels,
			sizeMaxPixels,
			transitions: transitions && {
				getPosition: transitions.getPosition,
				getAngle: transitions.getAngle,
				getSize: transitions.getSize,
				getFillColor: transitions.getBackgroundColor,
				getLineColor: transitions.getBorderColor,
				getLineWidth: transitions.getBorderWidth,
				getPixelOffset: transitions.getPixelOffset
			}
		}, this.getSubLayerProps({
			id: "background",
			updateTriggers: {
				getPosition: updateTriggers.getPosition,
				getAngle: updateTriggers.getAngle,
				getSize: updateTriggers.getSize,
				getFillColor: updateTriggers.getBackgroundColor,
				getLineColor: updateTriggers.getBorderColor,
				getLineWidth: updateTriggers.getBorderWidth,
				getPixelOffset: updateTriggers.getPixelOffset,
				getBoundingRect: {
					getText: updateTriggers.getText,
					getTextAnchor: updateTriggers.getTextAnchor,
					getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
					styleVersion
				}
			}
		}), {
			data: data.attributes && data.attributes.background ? {
				length: data.length,
				attributes: data.attributes.background
			} : data,
			_dataDiff,
			autoHighlight: false,
			getBoundingRect: this.getBoundingRect
		}), new CharactersLayerClass({
			sdf: fontSettings.sdf,
			smoothing: Number.isFinite(fontSettings.smoothing) ? fontSettings.smoothing : DEFAULT_FONT_SETTINGS.smoothing,
			outlineWidth: outlineWidth / (fontSettings.radius || DEFAULT_FONT_SETTINGS.radius),
			outlineColor,
			iconAtlas: atlas,
			iconMapping: mapping,
			getPosition,
			getColor,
			getSize,
			getAngle,
			getPixelOffset,
			billboard,
			sizeScale: sizeScale * scale,
			sizeUnits,
			sizeMinPixels: sizeMinPixels * scale,
			sizeMaxPixels: sizeMaxPixels * scale,
			transitions: transitions && {
				getPosition: transitions.getPosition,
				getAngle: transitions.getAngle,
				getColor: transitions.getColor,
				getSize: transitions.getSize,
				getPixelOffset: transitions.getPixelOffset
			}
		}, this.getSubLayerProps({
			id: "characters",
			updateTriggers: {
				all: updateTriggers.getText,
				getPosition: updateTriggers.getPosition,
				getAngle: updateTriggers.getAngle,
				getColor: updateTriggers.getColor,
				getSize: updateTriggers.getSize,
				getPixelOffset: updateTriggers.getPixelOffset,
				getIconOffsets: {
					getTextAnchor: updateTriggers.getTextAnchor,
					getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
					styleVersion
				}
			}
		}), {
			data,
			_dataDiff,
			startIndices,
			numInstances,
			getIconOffsets: this.getIconOffsets,
			getIcon: getText
		})];
	}
	static set fontAtlasCacheLimit(limit) {
		setFontAtlasCacheLimit(limit);
	}
};
TextLayer.defaultProps = defaultProps$1;
TextLayer.layerName = "TextLayer";
var text_layer_default = TextLayer;

//#endregion
//#region node_modules/@deck.gl/layers/dist/geojson-layer/sub-layer-map.js
const POINT_LAYER = {
	circle: {
		type: scatterplot_layer_default,
		props: {
			filled: "filled",
			stroked: "stroked",
			lineWidthMaxPixels: "lineWidthMaxPixels",
			lineWidthMinPixels: "lineWidthMinPixels",
			lineWidthScale: "lineWidthScale",
			lineWidthUnits: "lineWidthUnits",
			pointRadiusMaxPixels: "radiusMaxPixels",
			pointRadiusMinPixels: "radiusMinPixels",
			pointRadiusScale: "radiusScale",
			pointRadiusUnits: "radiusUnits",
			pointAntialiasing: "antialiasing",
			pointBillboard: "billboard",
			getFillColor: "getFillColor",
			getLineColor: "getLineColor",
			getLineWidth: "getLineWidth",
			getPointRadius: "getRadius"
		}
	},
	icon: {
		type: icon_layer_default,
		props: {
			iconAtlas: "iconAtlas",
			iconMapping: "iconMapping",
			iconSizeMaxPixels: "sizeMaxPixels",
			iconSizeMinPixels: "sizeMinPixels",
			iconSizeScale: "sizeScale",
			iconSizeUnits: "sizeUnits",
			iconAlphaCutoff: "alphaCutoff",
			iconBillboard: "billboard",
			getIcon: "getIcon",
			getIconAngle: "getAngle",
			getIconColor: "getColor",
			getIconPixelOffset: "getPixelOffset",
			getIconSize: "getSize"
		}
	},
	text: {
		type: text_layer_default,
		props: {
			textSizeMaxPixels: "sizeMaxPixels",
			textSizeMinPixels: "sizeMinPixels",
			textSizeScale: "sizeScale",
			textSizeUnits: "sizeUnits",
			textBackground: "background",
			textBackgroundPadding: "backgroundPadding",
			textFontFamily: "fontFamily",
			textFontWeight: "fontWeight",
			textLineHeight: "lineHeight",
			textMaxWidth: "maxWidth",
			textOutlineColor: "outlineColor",
			textOutlineWidth: "outlineWidth",
			textWordBreak: "wordBreak",
			textCharacterSet: "characterSet",
			textBillboard: "billboard",
			textFontSettings: "fontSettings",
			getText: "getText",
			getTextAngle: "getAngle",
			getTextColor: "getColor",
			getTextPixelOffset: "getPixelOffset",
			getTextSize: "getSize",
			getTextAnchor: "getTextAnchor",
			getTextAlignmentBaseline: "getAlignmentBaseline",
			getTextBackgroundColor: "getBackgroundColor",
			getTextBorderColor: "getBorderColor",
			getTextBorderWidth: "getBorderWidth"
		}
	}
};
const LINE_LAYER = {
	type: path_layer_default,
	props: {
		lineWidthUnits: "widthUnits",
		lineWidthScale: "widthScale",
		lineWidthMinPixels: "widthMinPixels",
		lineWidthMaxPixels: "widthMaxPixels",
		lineJointRounded: "jointRounded",
		lineCapRounded: "capRounded",
		lineMiterLimit: "miterLimit",
		lineBillboard: "billboard",
		getLineColor: "getColor",
		getLineWidth: "getWidth"
	}
};
const POLYGON_LAYER = {
	type: solid_polygon_layer_default,
	props: {
		extruded: "extruded",
		filled: "filled",
		wireframe: "wireframe",
		elevationScale: "elevationScale",
		material: "material",
		_full3d: "_full3d",
		getElevation: "getElevation",
		getFillColor: "getFillColor",
		getLineColor: "getLineColor"
	}
};
function getDefaultProps({ type, props }) {
	const result = {};
	for (const key in props) result[key] = type.defaultProps[props[key]];
	return result;
}
function forwardProps(layer, mapping) {
	const { transitions, updateTriggers } = layer.props;
	const result = {
		updateTriggers: {},
		transitions: transitions && { getPosition: transitions.geometry }
	};
	for (const sourceKey in mapping) {
		const targetKey = mapping[sourceKey];
		let value = layer.props[sourceKey];
		if (sourceKey.startsWith("get")) {
			value = layer.getSubLayerAccessor(value);
			result.updateTriggers[targetKey] = updateTriggers[sourceKey];
			if (transitions) result.transitions[targetKey] = transitions[sourceKey];
		}
		result[targetKey] = value;
	}
	return result;
}

//#endregion
//#region node_modules/@deck.gl/layers/dist/geojson-layer/geojson.js
/**
* "Normalizes" complete or partial GeoJSON data into iterable list of features
* Can accept GeoJSON geometry or "Feature", "FeatureCollection" in addition
* to plain arrays and iterables.
* Works by extracting the feature array or wrapping single objects in an array,
* so that subsequent code can simply iterate over features.
*
* @param {object} geojson - geojson data
* @param {Object|Array} data - geojson object (FeatureCollection, Feature or
*  Geometry) or array of features
* @return {Array|"iteratable"} - iterable list of features
*/
function getGeojsonFeatures(geojson) {
	if (Array.isArray(geojson)) return geojson;
	log_default.assert(geojson.type, "GeoJSON does not have type");
	switch (geojson.type) {
		case "Feature": return [geojson];
		case "FeatureCollection":
			log_default.assert(Array.isArray(geojson.features), "GeoJSON does not have features array");
			return geojson.features;
		default: return [{ geometry: geojson }];
	}
}
function separateGeojsonFeatures(features, wrapFeature, dataRange = {}) {
	const separated = {
		pointFeatures: [],
		lineFeatures: [],
		polygonFeatures: [],
		polygonOutlineFeatures: []
	};
	const { startRow = 0, endRow = features.length } = dataRange;
	for (let featureIndex = startRow; featureIndex < endRow; featureIndex++) {
		const feature = features[featureIndex];
		const { geometry } = feature;
		if (!geometry) continue;
		if (geometry.type === "GeometryCollection") {
			log_default.assert(Array.isArray(geometry.geometries), "GeoJSON does not have geometries array");
			const { geometries } = geometry;
			for (let i$1 = 0; i$1 < geometries.length; i$1++) {
				const subGeometry = geometries[i$1];
				separateGeometry(subGeometry, separated, wrapFeature, feature, featureIndex);
			}
		} else separateGeometry(geometry, separated, wrapFeature, feature, featureIndex);
	}
	return separated;
}
function separateGeometry(geometry, separated, wrapFeature, sourceFeature, sourceFeatureIndex) {
	const { type, coordinates } = geometry;
	const { pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures } = separated;
	if (!validateGeometry(type, coordinates)) {
		log_default.warn(`${type} coordinates are malformed`)();
		return;
	}
	switch (type) {
		case "Point":
			pointFeatures.push(wrapFeature({ geometry }, sourceFeature, sourceFeatureIndex));
			break;
		case "MultiPoint":
			coordinates.forEach((point) => {
				pointFeatures.push(wrapFeature({ geometry: {
					type: "Point",
					coordinates: point
				} }, sourceFeature, sourceFeatureIndex));
			});
			break;
		case "LineString":
			lineFeatures.push(wrapFeature({ geometry }, sourceFeature, sourceFeatureIndex));
			break;
		case "MultiLineString":
			coordinates.forEach((path) => {
				lineFeatures.push(wrapFeature({ geometry: {
					type: "LineString",
					coordinates: path
				} }, sourceFeature, sourceFeatureIndex));
			});
			break;
		case "Polygon":
			polygonFeatures.push(wrapFeature({ geometry }, sourceFeature, sourceFeatureIndex));
			coordinates.forEach((path) => {
				polygonOutlineFeatures.push(wrapFeature({ geometry: {
					type: "LineString",
					coordinates: path
				} }, sourceFeature, sourceFeatureIndex));
			});
			break;
		case "MultiPolygon":
			coordinates.forEach((polygon) => {
				polygonFeatures.push(wrapFeature({ geometry: {
					type: "Polygon",
					coordinates: polygon
				} }, sourceFeature, sourceFeatureIndex));
				polygon.forEach((path) => {
					polygonOutlineFeatures.push(wrapFeature({ geometry: {
						type: "LineString",
						coordinates: path
					} }, sourceFeature, sourceFeatureIndex));
				});
			});
			break;
		default:
	}
}
/**
* Simple GeoJSON validation util. For perf reasons we do not validate against the full spec,
* only the following:
- geometry.type is supported
- geometry.coordinate has correct nesting level
*/
var COORDINATE_NEST_LEVEL = {
	Point: 1,
	MultiPoint: 2,
	LineString: 2,
	MultiLineString: 3,
	Polygon: 3,
	MultiPolygon: 4
};
function validateGeometry(type, coordinates) {
	let nestLevel = COORDINATE_NEST_LEVEL[type];
	log_default.assert(nestLevel, `Unknown GeoJSON type ${type}`);
	while (coordinates && --nestLevel > 0) coordinates = coordinates[0];
	return coordinates && Number.isFinite(coordinates[0]);
}

//#endregion
//#region node_modules/@deck.gl/layers/dist/geojson-layer/geojson-layer-props.js
function createEmptyLayerProps() {
	return {
		points: {},
		lines: {},
		polygons: {},
		polygonsOutline: {}
	};
}
function getCoordinates(f$1) {
	return f$1.geometry.coordinates;
}
function createLayerPropsFromFeatures(features, featuresDiff) {
	const layerProps = createEmptyLayerProps();
	const { pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures } = features;
	layerProps.points.data = pointFeatures;
	layerProps.points._dataDiff = featuresDiff.pointFeatures && (() => featuresDiff.pointFeatures);
	layerProps.points.getPosition = getCoordinates;
	layerProps.lines.data = lineFeatures;
	layerProps.lines._dataDiff = featuresDiff.lineFeatures && (() => featuresDiff.lineFeatures);
	layerProps.lines.getPath = getCoordinates;
	layerProps.polygons.data = polygonFeatures;
	layerProps.polygons._dataDiff = featuresDiff.polygonFeatures && (() => featuresDiff.polygonFeatures);
	layerProps.polygons.getPolygon = getCoordinates;
	layerProps.polygonsOutline.data = polygonOutlineFeatures;
	layerProps.polygonsOutline._dataDiff = featuresDiff.polygonOutlineFeatures && (() => featuresDiff.polygonOutlineFeatures);
	layerProps.polygonsOutline.getPath = getCoordinates;
	return layerProps;
}
function createLayerPropsFromBinary(geojsonBinary, encodePickingColor) {
	const layerProps = createEmptyLayerProps();
	const { points, lines, polygons } = geojsonBinary;
	const customPickingColors = calculatePickingColors(geojsonBinary, encodePickingColor);
	layerProps.points.data = {
		length: points.positions.value.length / points.positions.size,
		attributes: {
			...points.attributes,
			getPosition: points.positions,
			instancePickingColors: {
				size: 4,
				value: customPickingColors.points
			}
		},
		properties: points.properties,
		numericProps: points.numericProps,
		featureIds: points.featureIds
	};
	layerProps.lines.data = {
		length: lines.pathIndices.value.length - 1,
		startIndices: lines.pathIndices.value,
		attributes: {
			...lines.attributes,
			getPath: lines.positions,
			instancePickingColors: {
				size: 4,
				value: customPickingColors.lines
			}
		},
		properties: lines.properties,
		numericProps: lines.numericProps,
		featureIds: lines.featureIds
	};
	layerProps.lines._pathType = "open";
	const vertexCount = polygons.positions.value.length / polygons.positions.size;
	const vertexValid = Array(vertexCount).fill(1);
	for (const index of polygons.primitivePolygonIndices.value) vertexValid[index - 1] = 0;
	layerProps.polygons.data = {
		length: polygons.polygonIndices.value.length - 1,
		startIndices: polygons.polygonIndices.value,
		attributes: {
			...polygons.attributes,
			getPolygon: polygons.positions,
			instanceVertexValid: {
				size: 1,
				value: new Uint16Array(vertexValid)
			},
			pickingColors: {
				size: 4,
				value: customPickingColors.polygons
			}
		},
		properties: polygons.properties,
		numericProps: polygons.numericProps,
		featureIds: polygons.featureIds
	};
	layerProps.polygons._normalize = false;
	if (polygons.triangles) layerProps.polygons.data.attributes.indices = polygons.triangles.value;
	layerProps.polygonsOutline.data = {
		length: polygons.primitivePolygonIndices.value.length - 1,
		startIndices: polygons.primitivePolygonIndices.value,
		attributes: {
			...polygons.attributes,
			getPath: polygons.positions,
			instancePickingColors: {
				size: 4,
				value: customPickingColors.polygons
			}
		},
		properties: polygons.properties,
		numericProps: polygons.numericProps,
		featureIds: polygons.featureIds
	};
	layerProps.polygonsOutline._pathType = "open";
	return layerProps;
}

//#endregion
//#region node_modules/@deck.gl/layers/dist/geojson-layer/geojson-layer.js
var FEATURE_TYPES = [
	"points",
	"linestrings",
	"polygons"
];
var defaultProps = {
	...getDefaultProps(POINT_LAYER.circle),
	...getDefaultProps(POINT_LAYER.icon),
	...getDefaultProps(POINT_LAYER.text),
	...getDefaultProps(LINE_LAYER),
	...getDefaultProps(POLYGON_LAYER),
	stroked: true,
	filled: true,
	extruded: false,
	wireframe: false,
	_full3d: false,
	iconAtlas: {
		type: "object",
		value: null
	},
	iconMapping: {
		type: "object",
		value: {}
	},
	getIcon: {
		type: "accessor",
		value: (f$1) => f$1.properties.icon
	},
	getText: {
		type: "accessor",
		value: (f$1) => f$1.properties.text
	},
	pointType: "circle",
	getRadius: { deprecatedFor: "getPointRadius" }
};
/** Render GeoJSON formatted data as polygons, lines and points (circles, icons and/or texts). */
var GeoJsonLayer = class extends composite_layer_default {
	initializeState() {
		this.state = {
			layerProps: {},
			features: {},
			featuresDiff: {}
		};
	}
	updateState({ props, changeFlags }) {
		if (!changeFlags.dataChanged) return;
		const { data } = this.props;
		const binary = data && "points" in data && "polygons" in data && "lines" in data;
		this.setState({ binary });
		if (binary) this._updateStateBinary({
			props,
			changeFlags
		});
		else this._updateStateJSON({
			props,
			changeFlags
		});
	}
	_updateStateBinary({ props, changeFlags }) {
		const layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);
		this.setState({ layerProps });
	}
	_updateStateJSON({ props, changeFlags }) {
		const features = getGeojsonFeatures(props.data);
		const wrapFeature = this.getSubLayerRow.bind(this);
		let newFeatures = {};
		const featuresDiff = {};
		if (Array.isArray(changeFlags.dataChanged)) {
			const oldFeatures = this.state.features;
			for (const key in oldFeatures) {
				newFeatures[key] = oldFeatures[key].slice();
				featuresDiff[key] = [];
			}
			for (const dataRange of changeFlags.dataChanged) {
				const partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);
				for (const key in oldFeatures) featuresDiff[key].push(replaceInRange({
					data: newFeatures[key],
					getIndex: (f$1) => f$1.__source.index,
					dataRange,
					replace: partialFeatures[key]
				}));
			}
		} else newFeatures = separateGeojsonFeatures(features, wrapFeature);
		const layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);
		this.setState({
			features: newFeatures,
			featuresDiff,
			layerProps
		});
	}
	getPickingInfo(params) {
		const info = super.getPickingInfo(params);
		const { index, sourceLayer } = info;
		info.featureType = FEATURE_TYPES.find((ft$1) => sourceLayer.id.startsWith(`${this.id}-${ft$1}-`));
		if (index >= 0 && sourceLayer.id.startsWith(`${this.id}-points-text`) && this.state.binary) info.index = this.props.data.points.globalFeatureIds.value[index];
		return info;
	}
	_updateAutoHighlight(info) {
		const pointLayerIdPrefix = `${this.id}-points-`;
		const sourceIsPoints = info.featureType === "points";
		for (const layer of this.getSubLayers()) if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) layer.updateAutoHighlight(info);
	}
	_renderPolygonLayer() {
		const { extruded, wireframe } = this.props;
		const { layerProps } = this.state;
		const id = "polygons-fill";
		const PolygonFillLayer = this.shouldRenderSubLayer(id, layerProps.polygons?.data) && this.getSubLayerClass(id, POLYGON_LAYER.type);
		if (PolygonFillLayer) {
			const forwardedProps = forwardProps(this, POLYGON_LAYER.props);
			const useLineColor = extruded && wireframe;
			if (!useLineColor) delete forwardedProps.getLineColor;
			forwardedProps.updateTriggers.lineColors = useLineColor;
			return new PolygonFillLayer(forwardedProps, this.getSubLayerProps({
				id,
				updateTriggers: forwardedProps.updateTriggers
			}), layerProps.polygons);
		}
		return null;
	}
	_renderLineLayers() {
		const { extruded, stroked } = this.props;
		const { layerProps } = this.state;
		const polygonStrokeLayerId = "polygons-stroke";
		const lineStringsLayerId = "linestrings";
		const PolygonStrokeLayer = !extruded && stroked && this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline?.data) && this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);
		const LineStringsLayer = this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines?.data) && this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);
		if (PolygonStrokeLayer || LineStringsLayer) {
			const forwardedProps = forwardProps(this, LINE_LAYER.props);
			return [PolygonStrokeLayer && new PolygonStrokeLayer(forwardedProps, this.getSubLayerProps({
				id: polygonStrokeLayerId,
				updateTriggers: forwardedProps.updateTriggers
			}), layerProps.polygonsOutline), LineStringsLayer && new LineStringsLayer(forwardedProps, this.getSubLayerProps({
				id: lineStringsLayerId,
				updateTriggers: forwardedProps.updateTriggers
			}), layerProps.lines)];
		}
		return null;
	}
	_renderPointLayers() {
		const { pointType } = this.props;
		const { layerProps, binary } = this.state;
		let { highlightedObjectIndex } = this.props;
		if (!binary && Number.isFinite(highlightedObjectIndex)) highlightedObjectIndex = layerProps.points.data.findIndex((d$1) => d$1.__source.index === highlightedObjectIndex);
		const types = new Set(pointType.split("+"));
		const pointLayers = [];
		for (const type of types) {
			const id = `points-${type}`;
			const PointLayerMapping = POINT_LAYER[type];
			const PointsLayer = PointLayerMapping && this.shouldRenderSubLayer(id, layerProps.points?.data) && this.getSubLayerClass(id, PointLayerMapping.type);
			if (PointsLayer) {
				const forwardedProps = forwardProps(this, PointLayerMapping.props);
				let pointsLayerProps = layerProps.points;
				if (type === "text" && binary) {
					const { instancePickingColors, ...rest } = pointsLayerProps.data.attributes;
					pointsLayerProps = {
						...pointsLayerProps,
						data: {
							...pointsLayerProps.data,
							attributes: rest
						}
					};
				}
				pointLayers.push(new PointsLayer(forwardedProps, this.getSubLayerProps({
					id,
					updateTriggers: forwardedProps.updateTriggers,
					highlightedObjectIndex
				}), pointsLayerProps));
			}
		}
		return pointLayers;
	}
	renderLayers() {
		const { extruded } = this.props;
		const polygonFillLayer = this._renderPolygonLayer();
		const lineLayers = this._renderLineLayers();
		const pointLayers = this._renderPointLayers();
		return [
			!extruded && polygonFillLayer,
			lineLayers,
			pointLayers,
			extruded && polygonFillLayer
		];
	}
	getSubLayerAccessor(accessor) {
		const { binary } = this.state;
		if (!binary || typeof accessor !== "function") return super.getSubLayerAccessor(accessor);
		return (object, info) => {
			const { data, index } = info;
			return accessor(binaryToFeatureForAccesor(data, index), info);
		};
	}
};
GeoJsonLayer.layerName = "GeoJsonLayer";
GeoJsonLayer.defaultProps = defaultProps;
var geojson_layer_default = GeoJsonLayer;

//#endregion
export { arc_layer_default as ArcLayer, bitmap_layer_default as BitmapLayer, column_layer_default as ColumnLayer, geojson_layer_default as GeoJsonLayer, grid_cell_layer_default as GridCellLayer, icon_layer_default as IconLayer, line_layer_default as LineLayer, path_layer_default as PathLayer, point_cloud_layer_default as PointCloudLayer, polygon_layer_default as PolygonLayer, scatterplot_layer_default as ScatterplotLayer, solid_polygon_layer_default as SolidPolygonLayer, text_layer_default as TextLayer, multi_icon_layer_default as _MultiIconLayer, text_background_layer_default as _TextBackgroundLayer };
//# sourceMappingURL=@deck__gl_layers.js.map