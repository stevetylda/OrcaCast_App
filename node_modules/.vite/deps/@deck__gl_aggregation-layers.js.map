{"version":3,"file":"@deck__gl_aggregation-layers.js","names":["min","max","uniformBlock","MAX_FLOAT32","uniformBlock","count","AggregationLayer","CompositeLayer","uniformBlock","Layer","picking","uniformBlock","binOptionsUniforms","defaultProps","AggregationLayer","project32","binOptionsUniforms","ScreenGridCellLayer","uniformBlock","ColumnLayer","uniformBlock","binOptionsUniforms","noop","defaultProps","AggregationLayer","project32","binOptionsUniforms","Viewport","HexagonCellLayer","threshold","threshold","count","uniformBlock","binOptionsUniforms","defaultProps","GridLayer","AggregationLayer","project32","binOptionsUniforms","_deepEqual","Viewport","PathLayer","SolidPolygonLayer","uniformBlock","ColumnLayer","uniformBlock","defaultProps","AggregationLayer","project32","Viewport","uniformBlock","Layer","project32","CompositeLayer","AggregationLayer","project32","weightsVs","weightsFs","TriangleLayer","maxVs","maxFs","viewport"],"sources":["../../@luma.gl/engine/dist/compute/texture-transform.js","../../@deck.gl/aggregation-layers/dist/common/aggregator/cpu-aggregator/sort-bins.js","../../@deck.gl/aggregation-layers/dist/common/aggregator/cpu-aggregator/aggregate.js","../../@deck.gl/aggregation-layers/dist/common/aggregator/cpu-aggregator/vertex-accessor.js","../../@deck.gl/aggregation-layers/dist/common/aggregator/cpu-aggregator/cpu-aggregator.js","../../@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/utils.js","../../@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/bin-sorter-uniforms.js","../../@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/webgl-bin-sorter.js","../../@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/aggregation-transform-uniforms.js","../../@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/webgl-aggregation-transform.js","../../@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/webgl-aggregator.js","../../@deck.gl/aggregation-layers/dist/common/aggregation-layer.js","../../@deck.gl/aggregation-layers/dist/common/utils/color-utils.js","../../@deck.gl/aggregation-layers/dist/screen-grid-layer/screen-grid-layer-vertex.glsl.js","../../@deck.gl/aggregation-layers/dist/screen-grid-layer/screen-grid-layer-fragment.glsl.js","../../@deck.gl/aggregation-layers/dist/screen-grid-layer/screen-grid-layer-uniforms.js","../../@deck.gl/aggregation-layers/dist/screen-grid-layer/screen-grid-cell-layer.js","../../@deck.gl/aggregation-layers/dist/screen-grid-layer/bin-options-uniforms.js","../../@deck.gl/aggregation-layers/dist/screen-grid-layer/screen-grid-layer.js","../../@deck.gl/aggregation-layers/dist/common/utils/scale-utils.js","../../@deck.gl/aggregation-layers/dist/common/utils/bounds-utils.js","../../@deck.gl/aggregation-layers/dist/hexagon-layer/hexbin.js","../../@deck.gl/aggregation-layers/dist/hexagon-layer/hexagon-cell-layer-vertex.glsl.js","../../@deck.gl/aggregation-layers/dist/hexagon-layer/hexagon-layer-uniforms.js","../../@deck.gl/aggregation-layers/dist/hexagon-layer/hexagon-cell-layer.js","../../@deck.gl/aggregation-layers/dist/hexagon-layer/bin-options-uniforms.js","../../@deck.gl/aggregation-layers/dist/hexagon-layer/hexagon-layer.js","../../@deck.gl/aggregation-layers/dist/contour-layer/marching-squares-codes.js","../../@deck.gl/aggregation-layers/dist/contour-layer/marching-squares.js","../../@deck.gl/aggregation-layers/dist/contour-layer/contour-utils.js","../../@deck.gl/aggregation-layers/dist/contour-layer/value-reader.js","../../@deck.gl/aggregation-layers/dist/contour-layer/bin-options-uniforms.js","../../@deck.gl/aggregation-layers/dist/contour-layer/contour-layer.js","../../@deck.gl/aggregation-layers/dist/grid-layer/grid-cell-layer-vertex.glsl.js","../../@deck.gl/aggregation-layers/dist/grid-layer/grid-layer-uniforms.js","../../@deck.gl/aggregation-layers/dist/grid-layer/grid-cell-layer.js","../../@deck.gl/aggregation-layers/dist/grid-layer/bin-options-uniforms.js","../../@deck.gl/aggregation-layers/dist/grid-layer/grid-layer.js","../../@deck.gl/aggregation-layers/dist/heatmap-layer/heatmap-layer-utils.js","../../@deck.gl/aggregation-layers/dist/heatmap-layer/triangle-layer-vertex.glsl.js","../../@deck.gl/aggregation-layers/dist/heatmap-layer/triangle-layer-fragment.glsl.js","../../@deck.gl/aggregation-layers/dist/heatmap-layer/triangle-layer-uniforms.js","../../@deck.gl/aggregation-layers/dist/heatmap-layer/triangle-layer.js","../../@deck.gl/aggregation-layers/dist/common/utils/prop-utils.js","../../@deck.gl/aggregation-layers/dist/heatmap-layer/aggregation-layer.js","../../@deck.gl/aggregation-layers/dist/heatmap-layer/weights-vs.glsl.js","../../@deck.gl/aggregation-layers/dist/heatmap-layer/weights-fs.glsl.js","../../@deck.gl/aggregation-layers/dist/heatmap-layer/max-vs.glsl.js","../../@deck.gl/aggregation-layers/dist/heatmap-layer/max-fs.glsl.js","../../@deck.gl/aggregation-layers/dist/heatmap-layer/heatmap-layer-uniforms.js","../../@deck.gl/aggregation-layers/dist/heatmap-layer/heatmap-layer.js"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getPassthroughFS } from '@luma.gl/shadertools';\nimport { Model } from \"../model/model.js\";\nimport { uid } from \"../utils/uid.js\";\nconst FS_OUTPUT_VARIABLE = 'transform_output';\n/**\n * Creates a pipeline for textureâ†’texture transforms.\n * @deprecated\n */\nexport class TextureTransform {\n    device;\n    model;\n    sampler;\n    currentIndex = 0;\n    samplerTextureMap = null;\n    bindings = []; // each element is an object : {sourceTextures, targetTexture, framebuffer}\n    resources = {}; // resources to be deleted\n    constructor(device, props) {\n        this.device = device;\n        // For precise picking of element IDs.\n        this.sampler = device.createSampler({\n            addressModeU: 'clamp-to-edge',\n            addressModeV: 'clamp-to-edge',\n            minFilter: 'nearest',\n            magFilter: 'nearest',\n            mipmapFilter: 'nearest'\n        });\n        this.model = new Model(this.device, {\n            id: props.id || uid('texture-transform-model'),\n            fs: props.fs ||\n                getPassthroughFS({\n                    input: props.targetTextureVarying,\n                    inputChannels: props.targetTextureChannels,\n                    output: FS_OUTPUT_VARIABLE\n                }),\n            vertexCount: props.vertexCount, // TODO(donmccurdy): Naming?\n            ...props\n        });\n        this._initialize(props);\n        Object.seal(this);\n    }\n    // Delete owned resources.\n    destroy() {\n        this.model.destroy();\n        for (const binding of this.bindings) {\n            binding.framebuffer?.destroy();\n        }\n    }\n    /** @deprecated Use {@link destroy}. */\n    delete() {\n        this.destroy();\n    }\n    run(options) {\n        const { framebuffer } = this.bindings[this.currentIndex];\n        const renderPass = this.device.beginRenderPass({ framebuffer, ...options });\n        this.model.draw(renderPass);\n        renderPass.end();\n        this.device.submit();\n    }\n    getTargetTexture() {\n        const { targetTexture } = this.bindings[this.currentIndex];\n        return targetTexture;\n    }\n    getFramebuffer() {\n        const currentResources = this.bindings[this.currentIndex];\n        return currentResources.framebuffer;\n    }\n    // Private\n    _initialize(props) {\n        this._updateBindings(props);\n    }\n    _updateBindings(props) {\n        this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], props);\n    }\n    _updateBinding(binding, { sourceBuffers, sourceTextures, targetTexture }) {\n        if (!binding) {\n            binding = {\n                sourceBuffers: {},\n                sourceTextures: {},\n                // @ts-expect-error\n                targetTexture: null\n            };\n        }\n        Object.assign(binding.sourceTextures, sourceTextures);\n        Object.assign(binding.sourceBuffers, sourceBuffers);\n        if (targetTexture) {\n            binding.targetTexture = targetTexture;\n            const { width, height } = targetTexture;\n            // TODO(donmccurdy): When is this called, and is this expected?\n            if (binding.framebuffer) {\n                binding.framebuffer.destroy();\n            }\n            binding.framebuffer = this.device.createFramebuffer({\n                id: 'transform-framebuffer',\n                width,\n                height,\n                colorAttachments: [targetTexture]\n            });\n            binding.framebuffer.resize({ width, height });\n        }\n        return binding;\n    }\n    // set texture filtering parameters on source textures.\n    _setSourceTextureParameters() {\n        const index = this.currentIndex;\n        const { sourceTextures } = this.bindings[index];\n        for (const name in sourceTextures) {\n            sourceTextures[name].sampler = this.sampler;\n        }\n    }\n}\n//# sourceMappingURL=texture-transform.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/** Group data points into bins */\nexport function sortBins({ pointCount, getBinId }) {\n    const binsById = new Map();\n    for (let i = 0; i < pointCount; i++) {\n        const id = getBinId(i);\n        if (id === null) {\n            continue;\n        }\n        let bin = binsById.get(String(id));\n        if (bin) {\n            bin.points.push(i);\n        }\n        else {\n            bin = {\n                id,\n                index: binsById.size,\n                points: [i]\n            };\n            binsById.set(String(id), bin);\n        }\n    }\n    return Array.from(binsById.values());\n}\n/** Pack bin ids into a typed array */\nexport function packBinIds({ bins, dimensions, target }) {\n    const targetLength = bins.length * dimensions;\n    if (!target || target.length < targetLength) {\n        target = new Float32Array(targetLength);\n    }\n    for (let i = 0; i < bins.length; i++) {\n        const { id } = bins[i];\n        if (Array.isArray(id)) {\n            target.set(id, i * dimensions);\n        }\n        else {\n            target[i] = id;\n        }\n    }\n    return target;\n}\n//# sourceMappingURL=sort-bins.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst count = pointIndices => {\n    return pointIndices.length;\n};\nconst sum = (pointIndices, getValue) => {\n    let result = 0;\n    for (const i of pointIndices) {\n        result += getValue(i);\n    }\n    return result;\n};\nconst mean = (pointIndices, getValue) => {\n    if (pointIndices.length === 0) {\n        return NaN;\n    }\n    return sum(pointIndices, getValue) / pointIndices.length;\n};\nconst min = (pointIndices, getValue) => {\n    let result = Infinity;\n    for (const i of pointIndices) {\n        const value = getValue(i);\n        if (value < result) {\n            result = value;\n        }\n    }\n    return result;\n};\nconst max = (pointIndices, getValue) => {\n    let result = -Infinity;\n    for (const i of pointIndices) {\n        const value = getValue(i);\n        if (value > result) {\n            result = value;\n        }\n    }\n    return result;\n};\nexport const BUILT_IN_OPERATIONS = {\n    COUNT: count,\n    SUM: sum,\n    MEAN: mean,\n    MIN: min,\n    MAX: max\n};\n/**\n * Performs the aggregation step. See interface Aggregator comments.\n * @returns Floa32Array of aggregated values, one for each bin, and the [min,max] of the values\n */\nexport function aggregate({ bins, getValue, operation, target }) {\n    if (!target || target.length < bins.length) {\n        target = new Float32Array(bins.length);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    let min = Infinity;\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    let max = -Infinity;\n    for (let j = 0; j < bins.length; j++) {\n        const { points } = bins[j];\n        target[j] = operation(points, getValue);\n        if (target[j] < min)\n            min = target[j];\n        if (target[j] > max)\n            max = target[j];\n    }\n    return { value: target, domain: [min, max] };\n}\n//# sourceMappingURL=aggregate.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/** Evaluate a VertexAccessor with a set of attributes */\nexport function evaluateVertexAccessor(accessor, attributes, options) {\n    const vertexReaders = {};\n    for (const id of accessor.sources || []) {\n        const attribute = attributes[id];\n        if (attribute) {\n            vertexReaders[id] = getVertexReader(attribute);\n        }\n        else {\n            throw new Error(`Cannot find attribute ${id}`);\n        }\n    }\n    const data = {};\n    return (vertexIndex) => {\n        for (const id in vertexReaders) {\n            data[id] = vertexReaders[id](vertexIndex);\n        }\n        return accessor.getValue(data, vertexIndex, options);\n    };\n}\n/** Read value out of a deck.gl Attribute by vertex */\nfunction getVertexReader(attribute) {\n    const value = attribute.value;\n    const { offset = 0, stride, size } = attribute.getAccessor();\n    const bytesPerElement = value.BYTES_PER_ELEMENT;\n    const elementOffset = offset / bytesPerElement;\n    const elementStride = stride ? stride / bytesPerElement : size;\n    if (size === 1) {\n        // Size 1, returns (i: number) => number\n        if (attribute.isConstant) {\n            return () => value[0];\n        }\n        return (vertexIndex) => {\n            const i = elementOffset + elementStride * vertexIndex;\n            return value[i];\n        };\n    }\n    // Size >1, returns (i: number) => number[]\n    let result;\n    if (attribute.isConstant) {\n        result = Array.from(value);\n        return () => result;\n    }\n    result = new Array(size);\n    return (vertexIndex) => {\n        const i = elementOffset + elementStride * vertexIndex;\n        for (let j = 0; j < size; j++) {\n            result[j] = value[i + j];\n        }\n        return result;\n    };\n}\n//# sourceMappingURL=vertex-accessor.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { _deepEqual as deepEqual } from '@deck.gl/core';\nimport { sortBins, packBinIds } from \"./sort-bins.js\";\nimport { aggregate, BUILT_IN_OPERATIONS } from \"./aggregate.js\";\nimport { evaluateVertexAccessor } from \"./vertex-accessor.js\";\n/** An Aggregator implementation that calculates aggregation on the CPU */\nexport class CPUAggregator {\n    constructor(props) {\n        this.bins = [];\n        this.binIds = null;\n        this.results = [];\n        this.dimensions = props.dimensions;\n        this.channelCount = props.getValue.length;\n        this.props = {\n            ...props,\n            binOptions: {},\n            pointCount: 0,\n            operations: [],\n            customOperations: [],\n            attributes: {}\n        };\n        this.needsUpdate = true;\n        this.setProps(props);\n    }\n    destroy() { }\n    get binCount() {\n        return this.bins.length;\n    }\n    /** Update aggregation props */\n    // eslint-disable-next-line complexity\n    setProps(props) {\n        const oldProps = this.props;\n        if (props.binOptions) {\n            if (!deepEqual(props.binOptions, oldProps.binOptions, 2)) {\n                this.setNeedsUpdate();\n            }\n        }\n        if (props.operations) {\n            for (let channel = 0; channel < this.channelCount; channel++) {\n                if (props.operations[channel] !== oldProps.operations[channel]) {\n                    this.setNeedsUpdate(channel);\n                }\n            }\n        }\n        if (props.customOperations) {\n            for (let channel = 0; channel < this.channelCount; channel++) {\n                if (Boolean(props.customOperations[channel]) !== Boolean(oldProps.customOperations[channel])) {\n                    this.setNeedsUpdate(channel);\n                }\n            }\n        }\n        if (props.pointCount !== undefined && props.pointCount !== oldProps.pointCount) {\n            this.setNeedsUpdate();\n        }\n        if (props.attributes) {\n            props.attributes = { ...oldProps.attributes, ...props.attributes };\n        }\n        Object.assign(this.props, props);\n    }\n    /** Flags a channel to need update\n     * This is called internally by setProps() if certain props change\n     * Users of this class still need to manually set the dirty flag sometimes, because even if no props changed\n     * the underlying buffers could have been updated and require rerunning the aggregation\n     * @param {number} channel - mark the given channel as dirty. If not provided, all channels will be updated.\n     */\n    setNeedsUpdate(channel) {\n        if (channel === undefined) {\n            this.needsUpdate = true;\n        }\n        else if (this.needsUpdate !== true) {\n            this.needsUpdate = this.needsUpdate || [];\n            this.needsUpdate[channel] = true;\n        }\n    }\n    /** Run aggregation */\n    update() {\n        if (this.needsUpdate === true) {\n            this.bins = sortBins({\n                pointCount: this.props.pointCount,\n                getBinId: evaluateVertexAccessor(this.props.getBin, this.props.attributes, this.props.binOptions)\n            });\n            const value = packBinIds({\n                bins: this.bins,\n                dimensions: this.dimensions,\n                // Reuse allocated typed array\n                target: this.binIds?.value\n            });\n            this.binIds = { value, type: 'float32', size: this.dimensions };\n        }\n        for (let channel = 0; channel < this.channelCount; channel++) {\n            if (this.needsUpdate === true || this.needsUpdate[channel]) {\n                const operation = this.props.customOperations[channel] ||\n                    BUILT_IN_OPERATIONS[this.props.operations[channel]];\n                const { value, domain } = aggregate({\n                    bins: this.bins,\n                    getValue: evaluateVertexAccessor(this.props.getValue[channel], this.props.attributes, undefined),\n                    operation,\n                    // Reuse allocated typed array\n                    target: this.results[channel]?.value\n                });\n                this.results[channel] = { value, domain, type: 'float32', size: 1 };\n                this.props.onUpdate?.({ channel });\n            }\n        }\n        this.needsUpdate = false;\n    }\n    preDraw() { }\n    /** Returns an accessor to the bins. */\n    getBins() {\n        return this.binIds;\n    }\n    /** Returns an accessor to the output for a given channel. */\n    getResult(channel) {\n        return this.results[channel];\n    }\n    /** Returns the [min, max] of aggregated values for a given channel. */\n    getResultDomain(channel) {\n        return this.results[channel]?.domain ?? [Infinity, -Infinity];\n    }\n    /** Returns the information for a given bin. */\n    getBin(index) {\n        const bin = this.bins[index];\n        if (!bin) {\n            return null;\n        }\n        const value = new Array(this.channelCount);\n        for (let i = 0; i < value.length; i++) {\n            const result = this.results[i];\n            value[i] = result?.value[index];\n        }\n        return {\n            id: bin.id,\n            value,\n            count: bin.points.length,\n            pointIndices: bin.points\n        };\n    }\n}\n//# sourceMappingURL=cpu-aggregator.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n * Create a float texture to store aggregation result\n */\nexport function createRenderTarget(device, width, height) {\n    return device.createFramebuffer({\n        width,\n        height,\n        colorAttachments: [\n            device.createTexture({\n                width,\n                height,\n                format: 'rgba32float',\n                sampler: {\n                    minFilter: 'nearest',\n                    magFilter: 'nearest'\n                }\n            })\n        ]\n    });\n}\n//# sourceMappingURL=utils.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst uniformBlock = /* glsl */ `\\\nuniform binSorterUniforms {\n  ivec4 binIdRange;\n  ivec2 targetSize;\n} binSorter;\n`;\nexport const binSorterUniforms = {\n    name: 'binSorter',\n    vs: uniformBlock,\n    uniformTypes: {\n        binIdRange: 'vec4<i32>',\n        targetSize: 'vec2<i32>'\n    }\n};\n//# sourceMappingURL=bin-sorter-uniforms.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Model } from '@luma.gl/engine';\nimport { createRenderTarget } from \"./utils.js\";\nimport { binSorterUniforms } from \"./bin-sorter-uniforms.js\";\nconst COLOR_CHANNELS = [0x1, 0x2, 0x4, 0x8]; // GPU color mask RED, GREEN, BLUE, ALPHA\nconst MAX_FLOAT32 = 3e38;\nconst EMPTY_MASKS = { SUM: 0, MEAN: 0, MIN: 0, MAX: 0, COUNT: 0 };\nexport const TEXTURE_WIDTH = 1024;\n/**\n * This class manages the resources for performing the first step of aggregation\n * Sort a list of data points into a number of bins\n */\nexport class WebGLBinSorter {\n    constructor(device, props) {\n        /**\n         * A packed texture in which each pixel represents a bin.\n         * The index of the pixel in the memory layout is the bin index.\n         * Alpha value is the count of data points that fall into this bin\n         * R,G,B values are the aggregated values of each channel:\n         *   - Sum of all data points if operation is 'SUM', or 'MEAN'\n         *   - Min of all data points if operation is 'MIN'\n         *   - Max of all data points if operation is 'MAX'\n         */\n        this.binsFBO = null;\n        this.device = device;\n        this.model = createModel(device, props);\n    }\n    get texture() {\n        return this.binsFBO ? this.binsFBO.colorAttachments[0].texture : null;\n    }\n    destroy() {\n        this.model.destroy();\n        this.binsFBO?.colorAttachments[0].texture.destroy();\n        this.binsFBO?.destroy();\n    }\n    getBinValues(index) {\n        if (!this.binsFBO) {\n            return null;\n        }\n        const x = index % TEXTURE_WIDTH;\n        const y = Math.floor(index / TEXTURE_WIDTH);\n        const buffer = this.device.readPixelsToArrayWebGL(this.binsFBO, {\n            sourceX: x,\n            sourceY: y,\n            sourceWidth: 1,\n            sourceHeight: 1\n        }).buffer;\n        return new Float32Array(buffer);\n    }\n    setDimensions(binCount, binIdRange) {\n        const width = TEXTURE_WIDTH;\n        const height = Math.ceil(binCount / width);\n        // Only destroy existing texture if it is not large enough\n        if (!this.binsFBO) {\n            this.binsFBO = createRenderTarget(this.device, width, height);\n        }\n        else if (this.binsFBO.height < height) {\n            this.binsFBO.resize({ width, height });\n        }\n        const binSorterProps = {\n            binIdRange: [\n                binIdRange[0][0],\n                binIdRange[0][1],\n                binIdRange[1]?.[0] || 0,\n                binIdRange[1]?.[1] || 0\n            ],\n            targetSize: [this.binsFBO.width, this.binsFBO.height]\n        };\n        this.model.shaderInputs.setProps({ binSorter: binSorterProps });\n    }\n    setModelProps(props) {\n        const model = this.model;\n        if (props.attributes) {\n            model.setAttributes(props.attributes);\n        }\n        if (props.constantAttributes) {\n            model.setConstantAttributes(props.constantAttributes);\n        }\n        if (props.vertexCount !== undefined) {\n            model.setVertexCount(props.vertexCount);\n        }\n        if (props.shaderModuleProps) {\n            model.shaderInputs.setProps(props.shaderModuleProps);\n        }\n    }\n    /** Update aggregation */\n    update(\n    /** The aggregation operation for each channel. Use null to skip update. */\n    operations) {\n        if (!this.binsFBO) {\n            return;\n        }\n        const masks = getMaskByOperation(operations);\n        this._updateBins('SUM', masks.SUM + masks.MEAN);\n        this._updateBins('MIN', masks.MIN);\n        this._updateBins('MAX', masks.MAX);\n    }\n    /** Recalculate aggregation on the given channels using the given operation */\n    _updateBins(operation, \n    /** GPU bit mask of one or more channels that should be updated */\n    colorMask) {\n        if (colorMask === 0) {\n            return;\n        }\n        colorMask |= COLOR_CHANNELS[3]; // Also renders to the alpha channel (point count)\n        const model = this.model;\n        const target = this.binsFBO;\n        const initialValue = operation === 'MAX' ? -MAX_FLOAT32 : operation === 'MIN' ? MAX_FLOAT32 : 0;\n        const renderPass = this.device.beginRenderPass({\n            id: `gpu-aggregation-${operation}`,\n            framebuffer: target,\n            parameters: {\n                viewport: [0, 0, target.width, target.height],\n                colorMask\n            },\n            clearColor: [initialValue, initialValue, initialValue, 0],\n            clearDepth: false,\n            clearStencil: false\n        });\n        model.setParameters({\n            blend: true,\n            blendColorSrcFactor: 'one',\n            blendColorDstFactor: 'one',\n            blendAlphaSrcFactor: 'one',\n            blendAlphaDstFactor: 'one',\n            blendColorOperation: operation === 'MAX' ? 'max' : operation === 'MIN' ? 'min' : 'add',\n            blendAlphaOperation: 'add'\n        });\n        model.draw(renderPass);\n        renderPass.end();\n    }\n}\n/** Convert a [channel -> operation] map to a [operation -> GPU color mask] map */\nfunction getMaskByOperation(operations) {\n    const result = { ...EMPTY_MASKS };\n    for (let channel = 0; channel < operations.length; channel++) {\n        const op = operations[channel];\n        if (op) {\n            result[op] += COLOR_CHANNELS[channel];\n        }\n    }\n    return result;\n}\nfunction createModel(device, props) {\n    let userVs = props.vs;\n    if (props.dimensions === 2) {\n        // If user provides 2d bin IDs, convert them to 1d indices for data packing\n        userVs += /* glsl */ `\nvoid getBin(out int binId) {\n  ivec2 binId2;\n  getBin(binId2);\n  if (binId2.x < binSorter.binIdRange.x || binId2.x >= binSorter.binIdRange.y) {\n    binId = -1;\n  } else {\n    binId = (binId2.y - binSorter.binIdRange.z) * (binSorter.binIdRange.y - binSorter.binIdRange.x) + binId2.x;\n  }\n}\n`;\n    }\n    const vs = `\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-sort-bins-vertex\n\n${userVs}\n\nout vec3 v_Value;\n\nvoid main() {\n  int binIndex;\n  getBin(binIndex);\n  binIndex = binIndex - binSorter.binIdRange.x;\n  if (binIndex < 0) {\n    gl_Position = vec4(0.);\n    return;\n  }\n  int row = binIndex / binSorter.targetSize.x;\n  int col = binIndex - row * binSorter.targetSize.x;\n  vec2 position = (vec2(col, row) + 0.5) / vec2(binSorter.targetSize) * 2.0 - 1.0;\n  gl_Position = vec4(position, 0.0, 1.0);\n  gl_PointSize = 1.0;\n\n#if NUM_CHANNELS == 3\n  getValue(v_Value);\n#elif NUM_CHANNELS == 2\n  getValue(v_Value.xy);\n#else\n  getValue(v_Value.x);\n#endif\n}\n`;\n    const fs = /* glsl */ `\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-sort-bins-fragment\n\nprecision highp float;\n\nin vec3 v_Value;\nout vec4 fragColor;\n\nvoid main() {\n  fragColor.xyz = v_Value;\n\n  #ifdef MODULE_GEOMETRY\n  geometry.uv = vec2(0.);\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n  #endif\n\n  fragColor.w = 1.0;\n}\n`;\n    const model = new Model(device, {\n        bufferLayout: props.bufferLayout,\n        modules: [...(props.modules || []), binSorterUniforms],\n        // @ts-expect-error TODO fix luma type\n        defines: { ...props.defines, NON_INSTANCED_MODEL: 1, NUM_CHANNELS: props.channelCount },\n        isInstanced: false,\n        vs,\n        fs,\n        topology: 'point-list',\n        disableWarnings: true\n    });\n    return model;\n}\n//# sourceMappingURL=webgl-bin-sorter.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst uniformBlock = /* glsl */ `\\\nuniform aggregatorTransformUniforms {\n  ivec4 binIdRange;\n  bvec3 isCount;\n  bvec3 isMean;\n  float naN;\n} aggregatorTransform;\n`;\nexport const aggregatorTransformUniforms = {\n    name: 'aggregatorTransform',\n    vs: uniformBlock,\n    uniformTypes: {\n        binIdRange: 'vec4<i32>',\n        isCount: 'vec3<f32>',\n        isMean: 'vec3<f32>'\n    }\n};\n//# sourceMappingURL=aggregation-transform-uniforms.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { BufferTransform } from '@luma.gl/engine';\nimport { createRenderTarget } from \"./utils.js\";\nimport { TEXTURE_WIDTH } from \"./webgl-bin-sorter.js\";\nimport { aggregatorTransformUniforms } from \"./aggregation-transform-uniforms.js\";\nconst MAX_FLOAT32 = 3e38;\nexport class WebGLAggregationTransform {\n    constructor(device, props) {\n        /** Packed from bin ids */\n        this.binBuffer = null;\n        /** Packed values from each channel of each bin\n         * Stride is number of channels * 4 bytes (float32)\n         */\n        this.valueBuffer = null;\n        /** Aggregated [min, max] for each channel */\n        this._domains = null;\n        this.device = device;\n        this.channelCount = props.channelCount;\n        this.transform = createTransform(device, props);\n        this.domainFBO = createRenderTarget(device, 2, 1);\n    }\n    destroy() {\n        this.transform.destroy();\n        this.binBuffer?.destroy();\n        this.valueBuffer?.destroy();\n        this.domainFBO.colorAttachments[0].texture.destroy();\n        this.domainFBO.destroy();\n    }\n    get domains() {\n        if (!this._domains) {\n            // Domain model has run, but result has not been read to CPU\n            const buffer = this.device.readPixelsToArrayWebGL(this.domainFBO).buffer;\n            const domain = new Float32Array(buffer);\n            this._domains = [\n                [-domain[4], domain[0]],\n                [-domain[5], domain[1]],\n                [-domain[6], domain[2]]\n            ].slice(0, this.channelCount);\n        }\n        return this._domains;\n    }\n    setDimensions(binCount, binIdRange) {\n        const { model, transformFeedback } = this.transform;\n        model.setVertexCount(binCount);\n        const aggregatorTransformProps = {\n            binIdRange: [\n                binIdRange[0][0],\n                binIdRange[0][1],\n                binIdRange[1]?.[0] || 0,\n                binIdRange[1]?.[1] || 0\n            ]\n        };\n        model.shaderInputs.setProps({ aggregatorTransform: aggregatorTransformProps });\n        // Only destroy existing buffer if it is not large enough\n        const binBufferByteLength = binCount * binIdRange.length * 4;\n        if (!this.binBuffer || this.binBuffer.byteLength < binBufferByteLength) {\n            this.binBuffer?.destroy();\n            this.binBuffer = this.device.createBuffer({ byteLength: binBufferByteLength });\n            transformFeedback.setBuffer('binIds', this.binBuffer);\n        }\n        const valueBufferByteLength = binCount * this.channelCount * 4;\n        if (!this.valueBuffer || this.valueBuffer.byteLength < valueBufferByteLength) {\n            this.valueBuffer?.destroy();\n            this.valueBuffer = this.device.createBuffer({ byteLength: valueBufferByteLength });\n            transformFeedback.setBuffer('values', this.valueBuffer);\n        }\n    }\n    update(bins, operations) {\n        if (!bins) {\n            return;\n        }\n        const transform = this.transform;\n        const target = this.domainFBO;\n        const isCount = [0, 1, 2].map(i => (operations[i] === 'COUNT' ? 1 : 0));\n        const isMean = [0, 1, 2].map(i => (operations[i] === 'MEAN' ? 1 : 0));\n        const aggregatorTransformProps = {\n            isCount: isCount,\n            isMean: isMean,\n            bins\n        };\n        transform.model.shaderInputs.setProps({ aggregatorTransform: aggregatorTransformProps });\n        transform.run({\n            id: 'gpu-aggregation-domain',\n            framebuffer: target,\n            parameters: {\n                viewport: [0, 0, 2, 1]\n            },\n            clearColor: [-MAX_FLOAT32, -MAX_FLOAT32, -MAX_FLOAT32, 0],\n            clearDepth: false,\n            clearStencil: false\n        });\n        // Clear the last read results. This will be lazy-populated if used.\n        this._domains = null;\n    }\n}\nfunction createTransform(device, props) {\n    const vs = /* glsl */ `\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-domain-vertex\n\nuniform sampler2D bins;\n\n#if NUM_DIMS == 1\nout float binIds;\n#else\nout vec2 binIds;\n#endif\n\n#if NUM_CHANNELS == 1\nflat out float values;\n#elif NUM_CHANNELS == 2\nflat out vec2 values;\n#else\nflat out vec3 values;\n#endif\n\nconst float NAN = intBitsToFloat(-1);\n\nvoid main() {\n  int row = gl_VertexID / SAMPLER_WIDTH;\n  int col = gl_VertexID - row * SAMPLER_WIDTH;\n  vec4 weights = texelFetch(bins, ivec2(col, row), 0);\n  vec3 value3 = mix(\n    mix(weights.rgb, vec3(weights.a), aggregatorTransform.isCount),\n    weights.rgb / max(weights.a, 1.0),\n    aggregatorTransform.isMean\n  );\n  if (weights.a == 0.0) {\n    value3 = vec3(NAN);\n  }\n\n#if NUM_DIMS == 1\n  binIds = float(gl_VertexID + aggregatorTransform.binIdRange.x);\n#else\n  int y = gl_VertexID / (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);\n  int x = gl_VertexID - y * (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);\n  binIds.y = float(y + aggregatorTransform.binIdRange.z);\n  binIds.x = float(x + aggregatorTransform.binIdRange.x);\n#endif\n\n#if NUM_CHANNELS == 3\n  values = value3;\n#elif NUM_CHANNELS == 2\n  values = value3.xy;\n#else\n  values = value3.x;\n#endif\n\n  gl_Position = vec4(0., 0., 0., 1.);\n  // This model renders into a 2x1 texture to obtain min and max simultaneously.\n  // See comments in fragment shader\n  gl_PointSize = 2.0;\n}\n`;\n    const fs = /* glsl */ `\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-domain-fragment\n\nprecision highp float;\n\n#if NUM_CHANNELS == 1\nflat in float values;\n#elif NUM_CHANNELS == 2\nflat in vec2 values;\n#else\nflat in vec3 values;\n#endif\n\nout vec4 fragColor;\n\nvoid main() {\n  vec3 value3;\n#if NUM_CHANNELS == 3\n  value3 = values;\n#elif NUM_CHANNELS == 2\n  value3.xy = values;\n#else\n  value3.x = values;\n#endif\n  if (isnan(value3.x)) discard;\n  // This shader renders into a 2x1 texture with blending=max\n  // The left pixel yields the max value of each channel\n  // The right pixel yields the min value of each channel\n  if (gl_FragCoord.x < 1.0) {\n    fragColor = vec4(value3, 1.0);\n  } else {\n    fragColor = vec4(-value3, 1.0);\n  }\n}\n`;\n    return new BufferTransform(device, {\n        vs,\n        fs,\n        topology: 'point-list',\n        modules: [aggregatorTransformUniforms],\n        parameters: {\n            blend: true,\n            blendColorSrcFactor: 'one',\n            blendColorDstFactor: 'one',\n            blendColorOperation: 'max',\n            blendAlphaSrcFactor: 'one',\n            blendAlphaDstFactor: 'one',\n            blendAlphaOperation: 'max'\n        },\n        defines: {\n            // @ts-expect-error TODO fix luma type\n            NUM_DIMS: props.dimensions,\n            // @ts-expect-error TODO fix luma type\n            NUM_CHANNELS: props.channelCount,\n            // @ts-expect-error TODO fix luma type\n            SAMPLER_WIDTH: TEXTURE_WIDTH\n        },\n        varyings: ['binIds', 'values'],\n        disableWarnings: true\n    });\n}\n//# sourceMappingURL=webgl-aggregation-transform.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { WebGLBinSorter } from \"./webgl-bin-sorter.js\";\nimport { WebGLAggregationTransform } from \"./webgl-aggregation-transform.js\";\nimport { _deepEqual as deepEqual, log } from '@deck.gl/core';\n/** An Aggregator implementation that calculates aggregation on the GPU */\nexport class WebGLAggregator {\n    /** Checks if the current device supports GPU aggregation */\n    static isSupported(device) {\n        return (device.features.has('float32-renderable-webgl') &&\n            device.features.has('texture-blend-float-webgl'));\n    }\n    constructor(device, props) {\n        this.binCount = 0;\n        /** Cached outputs */\n        this.binIds = null;\n        this.results = [];\n        this.device = device;\n        this.dimensions = props.dimensions;\n        this.channelCount = props.channelCount;\n        this.props = {\n            ...props,\n            pointCount: 0,\n            binIdRange: [[0, 0]],\n            operations: [],\n            attributes: {},\n            binOptions: {}\n        };\n        this.needsUpdate = new Array(this.channelCount).fill(true);\n        this.binSorter = new WebGLBinSorter(device, props);\n        this.aggregationTransform = new WebGLAggregationTransform(device, props);\n        this.setProps(props);\n    }\n    getBins() {\n        const buffer = this.aggregationTransform.binBuffer;\n        if (!buffer) {\n            return null;\n        }\n        if (this.binIds?.buffer !== buffer) {\n            // deck.gl Attribute.setBinaryValue uses shallow comparison to determine if attribute value has changed\n            // For performance, only create a new binary attribute descriptor when Buffer changes\n            this.binIds = { buffer, type: 'float32', size: this.dimensions };\n        }\n        return this.binIds;\n    }\n    /** Returns an accessor to the output for a given channel. */\n    getResult(channel) {\n        const buffer = this.aggregationTransform.valueBuffer;\n        if (!buffer || channel >= this.channelCount) {\n            return null;\n        }\n        if (this.results[channel]?.buffer !== buffer) {\n            this.results[channel] = {\n                buffer,\n                type: 'float32',\n                size: 1,\n                stride: this.channelCount * 4,\n                offset: channel * 4\n            };\n        }\n        return this.results[channel];\n    }\n    /** Returns the [min, max] of aggregated values for a given channel. */\n    getResultDomain(channel) {\n        return this.aggregationTransform.domains[channel];\n    }\n    /** Returns the information for a given bin. */\n    getBin(index) {\n        if (index < 0 || index >= this.binCount) {\n            return null;\n        }\n        const { binIdRange } = this.props;\n        let id;\n        if (this.dimensions === 1) {\n            id = [index + binIdRange[0][0]];\n        }\n        else {\n            const [[x0, x1], [y0]] = binIdRange;\n            const width = x1 - x0;\n            id = [(index % width) + x0, Math.floor(index / width) + y0];\n        }\n        const pixel = this.binSorter.getBinValues(index);\n        if (!pixel) {\n            return null;\n        }\n        const count = pixel[3];\n        const value = [];\n        for (let channel = 0; channel < this.channelCount; channel++) {\n            const operation = this.props.operations[channel];\n            if (operation === 'COUNT') {\n                value[channel] = count;\n            }\n            else if (count === 0) {\n                value[channel] = NaN;\n            }\n            else {\n                value[channel] = operation === 'MEAN' ? pixel[channel] / count : pixel[channel];\n            }\n        }\n        return { id, value, count };\n    }\n    /** Release GPU resources */\n    destroy() {\n        this.binSorter.destroy();\n        this.aggregationTransform.destroy();\n    }\n    /** Update aggregation props. Normalize prop values and set change flags. */\n    // eslint-disable-next-line complexity, max-statements\n    setProps(props) {\n        const oldProps = this.props;\n        // Update local settings. These will set the flag this._needsUpdate\n        if ('binIdRange' in props && !deepEqual(props.binIdRange, oldProps.binIdRange, 2)) {\n            const binIdRange = props.binIdRange;\n            log.assert(binIdRange.length === this.dimensions);\n            if (this.dimensions === 1) {\n                const [[x0, x1]] = binIdRange;\n                this.binCount = x1 - x0;\n            }\n            else {\n                const [[x0, x1], [y0, y1]] = binIdRange;\n                this.binCount = (x1 - x0) * (y1 - y0);\n            }\n            this.binSorter.setDimensions(this.binCount, binIdRange);\n            this.aggregationTransform.setDimensions(this.binCount, binIdRange);\n            this.setNeedsUpdate();\n        }\n        if (props.operations) {\n            for (let channel = 0; channel < this.channelCount; channel++) {\n                if (props.operations[channel] !== oldProps.operations[channel]) {\n                    this.setNeedsUpdate(channel);\n                }\n            }\n        }\n        if (props.pointCount !== undefined && props.pointCount !== oldProps.pointCount) {\n            this.binSorter.setModelProps({ vertexCount: props.pointCount });\n            this.setNeedsUpdate();\n        }\n        if (props.binOptions) {\n            if (!deepEqual(props.binOptions, oldProps.binOptions, 2)) {\n                this.setNeedsUpdate();\n            }\n            this.binSorter.model.shaderInputs.setProps({ binOptions: props.binOptions });\n        }\n        if (props.attributes) {\n            const attributeBuffers = {};\n            const constantAttributes = {};\n            for (const attribute of Object.values(props.attributes)) {\n                for (const [attributeName, value] of Object.entries(attribute.getValue())) {\n                    if (ArrayBuffer.isView(value)) {\n                        constantAttributes[attributeName] = value;\n                    }\n                    else if (value) {\n                        attributeBuffers[attributeName] = value;\n                    }\n                }\n            }\n            this.binSorter.setModelProps({ attributes: attributeBuffers, constantAttributes });\n        }\n        if (props.shaderModuleProps) {\n            this.binSorter.setModelProps({ shaderModuleProps: props.shaderModuleProps });\n        }\n        Object.assign(this.props, props);\n    }\n    /** Flags a channel to need update.\n     * This is called internally by setProps() if certain props change\n     * Users of this class still need to manually set the dirty flag sometimes, because even if no props changed\n     * the underlying buffers could have been updated and require rerunning the aggregation\n     * @param {number} channel - mark the given channel as dirty. If not provided, all channels will be updated.\n     */\n    setNeedsUpdate(channel) {\n        if (channel === undefined) {\n            this.needsUpdate.fill(true);\n        }\n        else {\n            this.needsUpdate[channel] = true;\n        }\n    }\n    update() { }\n    /** Run aggregation */\n    preDraw() {\n        if (!this.needsUpdate.some(Boolean)) {\n            return;\n        }\n        const { operations } = this.props;\n        const operationsToUpdate = this.needsUpdate.map((needsUpdate, i) => needsUpdate ? operations[i] : null);\n        // Render data to bins\n        this.binSorter.update(operationsToUpdate);\n        // Read to buffer and calculate domain\n        this.aggregationTransform.update(this.binSorter.texture, operations);\n        for (let i = 0; i < this.channelCount; i++) {\n            if (this.needsUpdate[i]) {\n                this.needsUpdate[i] = false;\n                this.props.onUpdate?.({ channel: i });\n            }\n        }\n        // Uncomment to debug\n        // console.log('binsFBO', new Float32Array(this.device.readPixelsToArrayWebGL(this.binSorter.texture!).buffer));\n        // console.log('binsBuffer', new Float32Array(this.aggregationTransform.binBuffer?.readSyncWebGL().buffer!));\n        // console.log('resultBuffer', new Float32Array(this.aggregationTransform.valueBuffer?.readSyncWebGL().buffer!));\n    }\n}\n//# sourceMappingURL=webgl-aggregator.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { CompositeLayer, AttributeManager } from '@deck.gl/core';\nclass AggregationLayer extends CompositeLayer {\n    /** Allow this layer to participates in the draw cycle */\n    get isDrawable() {\n        return true;\n    }\n    initializeState() {\n        this.getAttributeManager().remove(['instancePickingColors']);\n    }\n    // Extend Layer.updateState to update the Aggregator instance\n    // returns true if aggregator is changed\n    updateState(params) {\n        super.updateState(params);\n        const aggregatorType = this.getAggregatorType();\n        if (params.changeFlags.extensionsChanged || this.state.aggregatorType !== aggregatorType) {\n            this.state.aggregator?.destroy();\n            const aggregator = this.createAggregator(aggregatorType);\n            aggregator.setProps({\n                attributes: this.getAttributeManager()?.attributes\n            });\n            this.setState({ aggregator, aggregatorType });\n            return true;\n        }\n        return false;\n    }\n    // Override Layer.finalizeState to dispose the Aggregator instance\n    finalizeState(context) {\n        super.finalizeState(context);\n        this.state.aggregator.destroy();\n    }\n    // Override Layer.updateAttributes to update the aggregator\n    updateAttributes(changedAttributes) {\n        const { aggregator } = this.state;\n        aggregator.setProps({\n            attributes: changedAttributes\n        });\n        for (const id in changedAttributes) {\n            this.onAttributeChange(id);\n        }\n        // In aggregator.update() the aggregator allocates the buffers to store its output\n        // These buffers will be exposed by aggregator.getResults() and passed to the sublayers\n        // Therefore update() must be called before renderLayers()\n        // CPUAggregator's output is populated right here in update()\n        // GPUAggregator's output is pre-allocated and populated in preDraw(), see comments below\n        aggregator.update();\n    }\n    draw({ shaderModuleProps }) {\n        // GPU aggregation needs `shaderModuleProps` for projection/filter uniforms which are only accessible at draw time\n        // GPUAggregator's Buffers are pre-allocated during `update()` and passed down to the sublayer attributes in renderLayers()\n        // Although the Buffers have been bound to the sublayer's Model, their content are not populated yet\n        // GPUAggregator.preDraw() is called in the draw cycle here right before Buffers are used by sublayer.draw()\n        const { aggregator } = this.state;\n        // @ts-expect-error only used by GPU aggregators\n        aggregator.setProps({ shaderModuleProps });\n        aggregator.preDraw();\n    }\n    // override CompositeLayer._getAttributeManager to create AttributeManager instance\n    _getAttributeManager() {\n        return new AttributeManager(this.context.device, {\n            id: this.props.id,\n            stats: this.context.stats\n        });\n    }\n}\nAggregationLayer.layerName = 'AggregationLayer';\nexport default AggregationLayer;\n//# sourceMappingURL=aggregation-layer.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport const defaultColorRange = [\n    [255, 255, 178],\n    [254, 217, 118],\n    [254, 178, 76],\n    [253, 141, 60],\n    [240, 59, 32],\n    [189, 0, 38]\n];\n// Converts a colorRange array to a flat array with 4 components per color\nexport function colorRangeToFlatArray(colorRange, normalize = false, ArrayType = Float32Array) {\n    let flatArray;\n    if (Number.isFinite(colorRange[0])) {\n        // its already a flat array.\n        flatArray = new ArrayType(colorRange);\n    }\n    else {\n        // flatten it\n        flatArray = new ArrayType(colorRange.length * 4);\n        let index = 0;\n        for (let i = 0; i < colorRange.length; i++) {\n            const color = colorRange[i];\n            flatArray[index++] = color[0];\n            flatArray[index++] = color[1];\n            flatArray[index++] = color[2];\n            flatArray[index++] = Number.isFinite(color[3]) ? color[3] : 255;\n        }\n    }\n    if (normalize) {\n        for (let i = 0; i < flatArray.length; i++) {\n            flatArray[i] /= 255;\n        }\n    }\n    return flatArray;\n}\nexport const COLOR_RANGE_FILTER = {\n    linear: 'linear',\n    quantile: 'nearest',\n    quantize: 'nearest',\n    ordinal: 'nearest'\n};\nexport function updateColorRangeTexture(texture, type) {\n    texture.setSampler({\n        minFilter: COLOR_RANGE_FILTER[type],\n        magFilter: COLOR_RANGE_FILTER[type]\n    });\n}\nexport function createColorRangeTexture(device, colorRange, type = 'linear') {\n    const colors = colorRangeToFlatArray(colorRange, false, Uint8Array);\n    return device.createTexture({\n        format: 'rgba8unorm',\n        sampler: {\n            minFilter: COLOR_RANGE_FILTER[type],\n            magFilter: COLOR_RANGE_FILTER[type],\n            addressModeU: 'clamp-to-edge',\n            addressModeV: 'clamp-to-edge'\n        },\n        data: colors,\n        width: colors.length / 4,\n        height: 1\n    });\n}\n//# sourceMappingURL=color-utils.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport default /* glsl */ `\\\n#version 300 es\n#define SHADER_NAME screen-grid-layer-vertex-shader\n#define RANGE_COUNT 6\nin vec2 positions;\nin vec2 instancePositions;\nin float instanceWeights;\nin vec3 instancePickingColors;\nuniform sampler2D colorRange;\nout vec4 vColor;\nvec4 interp(float value, vec2 domain, sampler2D range) {\nfloat r = (value - domain.x) / (domain.y - domain.x);\nreturn texture(range, vec2(r, 0.5));\n}\nvoid main(void) {\nif (isnan(instanceWeights)) {\ngl_Position = vec4(0.);\nreturn;\n}\nvec2 pos = instancePositions * screenGrid.gridSizeClipspace + positions * screenGrid.cellSizeClipspace;\npos.x = pos.x - 1.0;\npos.y = 1.0 - pos.y;\ngl_Position = vec4(pos, 0., 1.);\nvColor = interp(instanceWeights, screenGrid.colorDomain, colorRange);\nvColor.a *= layer.opacity;\npicking_setPickingColor(instancePickingColors);\n}\n`;\n//# sourceMappingURL=screen-grid-layer-vertex.glsl.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/* fragment shader for the grid-layer */\nexport default /* glsl */ `\\\n#version 300 es\n#define SHADER_NAME screen-grid-layer-fragment-shader\nprecision highp float;\nin vec4 vColor;\nout vec4 fragColor;\nvoid main(void) {\nfragColor = vColor;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n`;\n//# sourceMappingURL=screen-grid-layer-fragment.glsl.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst uniformBlock = /* glsl */ `\\\nuniform screenGridUniforms {\n  vec2 cellSizeClipspace;\n  vec2 gridSizeClipspace;\n  vec2 colorDomain;\n} screenGrid;\n`;\nexport const screenGridUniforms = {\n    name: 'screenGrid',\n    vs: uniformBlock,\n    uniformTypes: {\n        cellSizeClipspace: 'vec2<f32>',\n        gridSizeClipspace: 'vec2<f32>',\n        colorDomain: 'vec2<f32>'\n    }\n};\n//# sourceMappingURL=screen-grid-layer-uniforms.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Model, Geometry } from '@luma.gl/engine';\nimport { Layer, picking } from '@deck.gl/core';\nimport { createColorRangeTexture, updateColorRangeTexture } from \"../common/utils/color-utils.js\";\nimport vs from \"./screen-grid-layer-vertex.glsl.js\";\nimport fs from \"./screen-grid-layer-fragment.glsl.js\";\nimport { screenGridUniforms } from \"./screen-grid-layer-uniforms.js\";\nclass ScreenGridCellLayer extends Layer {\n    getShaders() {\n        return super.getShaders({ vs, fs, modules: [picking, screenGridUniforms] });\n    }\n    initializeState() {\n        this.getAttributeManager().addInstanced({\n            instancePositions: {\n                size: 2,\n                type: 'float32',\n                accessor: 'getBin'\n            },\n            instanceWeights: {\n                size: 1,\n                type: 'float32',\n                accessor: 'getWeight'\n            }\n        });\n        this.state.model = this._getModel();\n    }\n    updateState(params) {\n        super.updateState(params);\n        const { props, oldProps, changeFlags } = params;\n        const model = this.state.model;\n        if (oldProps.colorRange !== props.colorRange) {\n            this.state.colorTexture?.destroy();\n            this.state.colorTexture = createColorRangeTexture(this.context.device, props.colorRange, props.colorScaleType);\n            const screenGridProps = { colorRange: this.state.colorTexture };\n            model.shaderInputs.setProps({ screenGrid: screenGridProps });\n        }\n        else if (oldProps.colorScaleType !== props.colorScaleType) {\n            updateColorRangeTexture(this.state.colorTexture, props.colorScaleType);\n        }\n        if (oldProps.cellMarginPixels !== props.cellMarginPixels ||\n            oldProps.cellSizePixels !== props.cellSizePixels ||\n            changeFlags.viewportChanged) {\n            const { width, height } = this.context.viewport;\n            const { cellSizePixels: gridSize, cellMarginPixels } = this.props;\n            const cellSize = Math.max(gridSize - cellMarginPixels, 0);\n            const screenGridProps = {\n                gridSizeClipspace: [(gridSize / width) * 2, (gridSize / height) * 2],\n                cellSizeClipspace: [(cellSize / width) * 2, (cellSize / height) * 2]\n            };\n            model.shaderInputs.setProps({ screenGrid: screenGridProps });\n        }\n    }\n    finalizeState(context) {\n        super.finalizeState(context);\n        this.state.colorTexture?.destroy();\n    }\n    draw({ uniforms }) {\n        const colorDomain = this.props.colorDomain();\n        const model = this.state.model;\n        const screenGridProps = { colorDomain };\n        model.shaderInputs.setProps({ screenGrid: screenGridProps });\n        model.draw(this.context.renderPass);\n    }\n    // Private Methods\n    _getModel() {\n        return new Model(this.context.device, {\n            ...this.getShaders(),\n            id: this.props.id,\n            bufferLayout: this.getAttributeManager().getBufferLayouts(),\n            geometry: new Geometry({\n                topology: 'triangle-strip',\n                attributes: {\n                    positions: {\n                        value: new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]),\n                        size: 2\n                    }\n                }\n            }),\n            isInstanced: true\n        });\n    }\n}\nScreenGridCellLayer.layerName = 'ScreenGridCellLayer';\nexport default ScreenGridCellLayer;\n//# sourceMappingURL=screen-grid-cell-layer.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst uniformBlock = /* glsl */ `\\\nuniform binOptionsUniforms {\n  float cellSizePixels;\n} binOptions;\n`;\nexport const binOptionsUniforms = {\n    name: 'binOptions',\n    vs: uniformBlock,\n    uniformTypes: {\n        cellSizePixels: 'f32'\n    }\n};\n//# sourceMappingURL=bin-options-uniforms.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { project32 } from '@deck.gl/core';\nimport { WebGLAggregator, CPUAggregator } from \"../common/aggregator/index.js\";\nimport AggregationLayer from \"../common/aggregation-layer.js\";\nimport ScreenGridCellLayer from \"./screen-grid-cell-layer.js\";\nimport { binOptionsUniforms } from \"./bin-options-uniforms.js\";\nimport { defaultColorRange } from \"../common/utils/color-utils.js\";\nconst defaultProps = {\n    cellSizePixels: { type: 'number', value: 100, min: 1 },\n    cellMarginPixels: { type: 'number', value: 2, min: 0 },\n    colorRange: defaultColorRange,\n    colorScaleType: 'linear',\n    getPosition: { type: 'accessor', value: (d) => d.position },\n    getWeight: { type: 'accessor', value: 1 },\n    gpuAggregation: true,\n    aggregation: 'SUM'\n};\n/** Aggregates data into histogram bins and renders them as a grid. */\nclass ScreenGridLayer extends AggregationLayer {\n    getAggregatorType() {\n        return this.props.gpuAggregation && WebGLAggregator.isSupported(this.context.device)\n            ? 'gpu'\n            : 'cpu';\n    }\n    createAggregator(type) {\n        if (type === 'cpu' || !WebGLAggregator.isSupported(this.context.device)) {\n            return new CPUAggregator({\n                dimensions: 2,\n                getBin: {\n                    sources: ['positions'],\n                    getValue: ({ positions }, index, opts) => {\n                        const viewport = this.context.viewport;\n                        const p = viewport.project(positions);\n                        const cellSizePixels = opts.cellSizePixels;\n                        if (p[0] < 0 || p[0] >= viewport.width || p[1] < 0 || p[1] >= viewport.height) {\n                            // Not on screen\n                            return null;\n                        }\n                        return [Math.floor(p[0] / cellSizePixels), Math.floor(p[1] / cellSizePixels)];\n                    }\n                },\n                getValue: [{ sources: ['counts'], getValue: ({ counts }) => counts }]\n            });\n        }\n        return new WebGLAggregator(this.context.device, {\n            dimensions: 2,\n            channelCount: 1,\n            bufferLayout: this.getAttributeManager().getBufferLayouts({ isInstanced: false }),\n            ...super.getShaders({\n                modules: [project32, binOptionsUniforms],\n                vs: `\n  in vec3 positions;\n  in vec3 positions64Low;\n  in float counts;\n  \n  void getBin(out ivec2 binId) {\n    vec4 pos = project_position_to_clipspace(positions, positions64Low, vec3(0.0));\n    vec2 screenCoords = vec2(pos.x / pos.w + 1.0, 1.0 - pos.y / pos.w) / 2.0 * project.viewportSize / project.devicePixelRatio;\n    vec2 gridCoords = floor(screenCoords / binOptions.cellSizePixels);\n    binId = ivec2(gridCoords);\n  }\n  void getValue(out float weight) {\n    weight = counts;\n  }\n  `\n            })\n        });\n    }\n    initializeState() {\n        super.initializeState();\n        const attributeManager = this.getAttributeManager();\n        attributeManager.add({\n            positions: {\n                size: 3,\n                accessor: 'getPosition',\n                type: 'float64',\n                fp64: this.use64bitPositions()\n            },\n            // this attribute is used in gpu aggregation path only\n            counts: { size: 1, accessor: 'getWeight' }\n        });\n    }\n    shouldUpdateState({ changeFlags }) {\n        return changeFlags.somethingChanged;\n    }\n    updateState(params) {\n        const aggregatorChanged = super.updateState(params);\n        const { props, oldProps, changeFlags } = params;\n        const { cellSizePixels, aggregation } = props;\n        if (aggregatorChanged ||\n            changeFlags.dataChanged ||\n            changeFlags.updateTriggersChanged ||\n            changeFlags.viewportChanged ||\n            aggregation !== oldProps.aggregation ||\n            cellSizePixels !== oldProps.cellSizePixels) {\n            const { width, height } = this.context.viewport;\n            const { aggregator } = this.state;\n            if (aggregator instanceof WebGLAggregator) {\n                aggregator.setProps({\n                    binIdRange: [\n                        [0, Math.ceil(width / cellSizePixels)],\n                        [0, Math.ceil(height / cellSizePixels)]\n                    ]\n                });\n            }\n            aggregator.setProps({\n                pointCount: this.getNumInstances(),\n                operations: [aggregation],\n                binOptions: {\n                    cellSizePixels\n                }\n            });\n        }\n        if (changeFlags.viewportChanged) {\n            // Rerun aggregation on viewport change\n            this.state.aggregator.setNeedsUpdate();\n        }\n        return aggregatorChanged;\n    }\n    onAttributeChange(id) {\n        const { aggregator } = this.state;\n        switch (id) {\n            case 'positions':\n                aggregator.setNeedsUpdate();\n                break;\n            case 'counts':\n                aggregator.setNeedsUpdate(0);\n                break;\n            default:\n            // This should not happen\n        }\n    }\n    renderLayers() {\n        const { aggregator } = this.state;\n        const CellLayerClass = this.getSubLayerClass('cells', ScreenGridCellLayer);\n        const binAttribute = aggregator.getBins();\n        const weightAttribute = aggregator.getResult(0);\n        return new CellLayerClass(this.props, this.getSubLayerProps({\n            id: 'cell-layer'\n        }), {\n            data: {\n                length: aggregator.binCount,\n                attributes: {\n                    getBin: binAttribute,\n                    getWeight: weightAttribute\n                }\n            },\n            // Data has changed shallowly, but we likely don't need to update the attributes\n            dataComparator: (data, oldData) => data.length === oldData.length,\n            updateTriggers: {\n                getBin: [binAttribute],\n                getWeight: [weightAttribute]\n            },\n            parameters: {\n                depthWriteEnabled: false,\n                ...this.props.parameters\n            },\n            // Evaluate domain at draw() time\n            colorDomain: () => this.props.colorDomain || aggregator.getResultDomain(0),\n            // Extensions are already handled by the GPUAggregator, do not pass it down\n            extensions: []\n        });\n    }\n    getPickingInfo(params) {\n        const info = params.info;\n        const { index } = info;\n        if (index >= 0) {\n            const bin = this.state.aggregator.getBin(index);\n            let object;\n            if (bin) {\n                object = {\n                    col: bin.id[0],\n                    row: bin.id[1],\n                    value: bin.value[0],\n                    count: bin.count\n                };\n                if (bin.pointIndices) {\n                    object.pointIndices = bin.pointIndices;\n                    object.points = Array.isArray(this.props.data)\n                        ? bin.pointIndices.map(i => this.props.data[i])\n                        : [];\n                }\n            }\n            info.object = object;\n        }\n        return info;\n    }\n}\nScreenGridLayer.layerName = 'ScreenGridLayer';\nScreenGridLayer.defaultProps = defaultProps;\nexport default ScreenGridLayer;\n//# sourceMappingURL=screen-grid-layer.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/** Applies a scale to BinaryAttribute */\nexport class AttributeWithScale {\n    constructor(input, inputLength) {\n        this.props = {\n            scaleType: 'linear',\n            lowerPercentile: 0,\n            upperPercentile: 100\n        };\n        /** [min, max] of attribute values, or null if unknown */\n        this.domain = null;\n        /** Valid domain if lower/upper percentile are defined */\n        this.cutoff = null;\n        this.input = input;\n        this.inputLength = inputLength;\n        // No processing is needed with the default scale\n        this.attribute = input;\n    }\n    getScalePercentile() {\n        if (!this._percentile) {\n            const value = getAttributeValue(this.input, this.inputLength);\n            this._percentile = applyScaleQuantile(value);\n        }\n        return this._percentile;\n    }\n    getScaleOrdinal() {\n        if (!this._ordinal) {\n            const value = getAttributeValue(this.input, this.inputLength);\n            this._ordinal = applyScaleOrdinal(value);\n        }\n        return this._ordinal;\n    }\n    /** Returns the [lowerCutoff, upperCutoff] of scaled values, or null if not applicable */\n    getCutoff({ scaleType, lowerPercentile, upperPercentile }) {\n        if (scaleType === 'quantile') {\n            return [lowerPercentile, upperPercentile - 1];\n        }\n        if (lowerPercentile > 0 || upperPercentile < 100) {\n            const { domain: thresholds } = this.getScalePercentile();\n            let lowValue = thresholds[Math.floor(lowerPercentile) - 1] ?? -Infinity;\n            let highValue = thresholds[Math.floor(upperPercentile) - 1] ?? Infinity;\n            if (scaleType === 'ordinal') {\n                const { domain: sortedUniqueValues } = this.getScaleOrdinal();\n                lowValue = sortedUniqueValues.findIndex(x => x >= lowValue);\n                highValue = sortedUniqueValues.findIndex(x => x > highValue) - 1;\n                if (highValue === -2) {\n                    highValue = sortedUniqueValues.length - 1;\n                }\n            }\n            return [lowValue, highValue];\n        }\n        return null;\n    }\n    update(props) {\n        const oldProps = this.props;\n        if (props.scaleType !== oldProps.scaleType) {\n            switch (props.scaleType) {\n                case 'quantile': {\n                    const { attribute } = this.getScalePercentile();\n                    this.attribute = attribute;\n                    this.domain = [0, 99];\n                    break;\n                }\n                case 'ordinal': {\n                    const { attribute, domain } = this.getScaleOrdinal();\n                    this.attribute = attribute;\n                    this.domain = [0, domain.length - 1];\n                    break;\n                }\n                default:\n                    this.attribute = this.input;\n                    this.domain = null;\n            }\n        }\n        if (props.scaleType !== oldProps.scaleType ||\n            props.lowerPercentile !== oldProps.lowerPercentile ||\n            props.upperPercentile !== oldProps.upperPercentile) {\n            this.cutoff = this.getCutoff(props);\n        }\n        this.props = props;\n        return this;\n    }\n}\n/**\n * Transform an array of values to ordinal indices\n */\nexport function applyScaleOrdinal(values) {\n    const uniqueValues = new Set();\n    for (const x of values) {\n        if (Number.isFinite(x)) {\n            uniqueValues.add(x);\n        }\n    }\n    const sortedUniqueValues = Array.from(uniqueValues).sort();\n    const domainMap = new Map();\n    for (let i = 0; i < sortedUniqueValues.length; i++) {\n        domainMap.set(sortedUniqueValues[i], i);\n    }\n    return {\n        attribute: {\n            value: values.map(x => (Number.isFinite(x) ? domainMap.get(x) : NaN)),\n            type: 'float32',\n            size: 1\n        },\n        domain: sortedUniqueValues\n    };\n}\n/**\n * Transform an array of values to percentiles\n */\nexport function applyScaleQuantile(values, rangeLength = 100) {\n    const sortedValues = Array.from(values).filter(Number.isFinite).sort(ascending);\n    let i = 0;\n    const n = Math.max(1, rangeLength);\n    const thresholds = new Array(n - 1);\n    while (++i < n) {\n        thresholds[i - 1] = threshold(sortedValues, i / n);\n    }\n    return {\n        attribute: {\n            value: values.map(x => (Number.isFinite(x) ? bisectRight(thresholds, x) : NaN)),\n            type: 'float32',\n            size: 1\n        },\n        domain: thresholds\n    };\n}\nfunction getAttributeValue(attribute, length) {\n    const elementStride = (attribute.stride ?? 4) / 4;\n    const elementOffset = (attribute.offset ?? 0) / 4;\n    let value = attribute.value;\n    if (!value) {\n        const bytes = attribute.buffer?.readSyncWebGL(0, elementStride * 4 * length);\n        if (bytes) {\n            value = new Float32Array(bytes.buffer);\n            attribute.value = value;\n        }\n    }\n    if (elementStride === 1) {\n        return value.subarray(0, length);\n    }\n    const result = new Float32Array(length);\n    for (let i = 0; i < length; i++) {\n        result[i] = value[i * elementStride + elementOffset];\n    }\n    return result;\n}\nfunction ascending(a, b) {\n    return a - b;\n}\nfunction threshold(domain, fraction) {\n    const domainLength = domain.length;\n    if (fraction <= 0 || domainLength < 2) {\n        return domain[0];\n    }\n    if (fraction >= 1) {\n        return domain[domainLength - 1];\n    }\n    const domainFraction = (domainLength - 1) * fraction;\n    const lowIndex = Math.floor(domainFraction);\n    const low = domain[lowIndex];\n    const high = domain[lowIndex + 1];\n    return low + (high - low) * (domainFraction - lowIndex);\n}\nfunction bisectRight(a, x) {\n    let lo = 0;\n    let hi = a.length;\n    while (lo < hi) {\n        const mid = (lo + hi) >>> 1;\n        if (a[mid] > x) {\n            hi = mid;\n        }\n        else {\n            lo = mid + 1;\n        }\n    }\n    return lo;\n}\n//# sourceMappingURL=scale-utils.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/** Utility to estimate binIdRange as expected by AggregatorProps */\nexport function getBinIdRange({ dataBounds, getBinId, padding = 0 }) {\n    const corners = [\n        dataBounds[0],\n        dataBounds[1],\n        [dataBounds[0][0], dataBounds[1][1]],\n        [dataBounds[1][0], dataBounds[0][1]]\n    ].map(p => getBinId(p));\n    const minX = Math.min(...corners.map(p => p[0])) - padding;\n    const minY = Math.min(...corners.map(p => p[1])) - padding;\n    const maxX = Math.max(...corners.map(p => p[0])) + padding + 1;\n    const maxY = Math.max(...corners.map(p => p[1])) + padding + 1;\n    return [\n        [minX, maxX],\n        [minY, maxY]\n    ];\n}\n//# sourceMappingURL=bounds-utils.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst THIRD_PI = Math.PI / 3;\nconst DIST_X = 2 * Math.sin(THIRD_PI);\nconst DIST_Y = 1.5;\nexport const HexbinVertices = Array.from({ length: 6 }, (_, i) => {\n    const angle = i * THIRD_PI;\n    return [Math.sin(angle), -Math.cos(angle)];\n});\n/**\n * Adapted from d3-hexbin\n * Copyright Mike Bostock, 2012-2016\n   All rights reserved.\n * https://github.com/d3/d3-hexbin/blob/master/src/hexbin.js\n *\n * Returns the hexbin that a point (x,y) falls into\n */\nexport function pointToHexbin([px, py], radius) {\n    let pj = Math.round((py = py / radius / DIST_Y));\n    let pi = Math.round((px = px / radius / DIST_X - (pj & 1) / 2));\n    const py1 = py - pj;\n    if (Math.abs(py1) * 3 > 1) {\n        const px1 = px - pi;\n        const pi2 = pi + (px < pi ? -1 : 1) / 2;\n        const pj2 = pj + (py < pj ? -1 : 1);\n        const px2 = px - pi2;\n        const py2 = py - pj2;\n        if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2) {\n            pi = pi2 + (pj & 1 ? 1 : -1) / 2;\n            pj = pj2;\n        }\n    }\n    return [pi, pj];\n}\nexport const pointToHexbinGLSL = /* glsl */ `\nconst vec2 DIST = vec2(${DIST_X}, ${DIST_Y});\n\nivec2 pointToHexbin(vec2 p, float radius) {\n  p /= radius * DIST;\n  float pj = round(p.y);\n  float pjm2 = mod(pj, 2.0);\n  p.x -= pjm2 * 0.5;\n  float pi = round(p.x);\n  vec2 d1 = p - vec2(pi, pj);\n\n  if (abs(d1.y) * 3. > 1.) {\n    vec2 v2 = step(0.0, d1) - 0.5;\n    v2.y *= 2.0;\n    vec2 d2 = d1 - v2;\n    if (dot(d1, d1) > dot(d2, d2)) {\n      pi += v2.x + pjm2 - 0.5;\n      pj += v2.y;\n    }\n  }\n  return ivec2(pi, pj);\n}\n`;\nexport function getHexbinCentroid([i, j], radius) {\n    return [(i + (j & 1) / 2) * radius * DIST_X, j * radius * DIST_Y];\n}\nexport const getHexbinCentroidGLSL = `\nconst vec2 DIST = vec2(${DIST_X}, ${DIST_Y});\n\nvec2 hexbinCentroid(vec2 binId, float radius) {\n  binId.x += fract(binId.y * 0.5);\n  return binId * DIST * radius;\n}\n`;\n//# sourceMappingURL=hexbin.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getHexbinCentroidGLSL } from \"./hexbin.js\";\nexport default /* glsl */ `\\\n#version 300 es\n#define SHADER_NAME hexagon-cell-layer-vertex-shader\nin vec3 positions;\nin vec3 normals;\nin vec2 instancePositions;\nin float instanceElevationValues;\nin float instanceColorValues;\nin vec3 instancePickingColors;\nuniform sampler2D colorRange;\nout vec4 vColor;\n${getHexbinCentroidGLSL}\nfloat interp(float value, vec2 domain, vec2 range) {\nfloat r = min(max((value - domain.x) / (domain.y - domain.x), 0.), 1.);\nreturn mix(range.x, range.y, r);\n}\nvec4 interp(float value, vec2 domain, sampler2D range) {\nfloat r = (value - domain.x) / (domain.y - domain.x);\nreturn texture(range, vec2(r, 0.5));\n}\nvoid main(void) {\ngeometry.pickingColor = instancePickingColors;\nif (isnan(instanceColorValues) ||\ninstanceColorValues < hexagon.colorDomain.z ||\ninstanceColorValues > hexagon.colorDomain.w ||\ninstanceElevationValues < hexagon.elevationDomain.z ||\ninstanceElevationValues > hexagon.elevationDomain.w\n) {\ngl_Position = vec4(0.);\nreturn;\n}\nvec2 commonPosition = hexbinCentroid(instancePositions, column.radius) + (hexagon.originCommon - project.commonOrigin.xy);\ncommonPosition += positions.xy * column.radius * column.coverage;\ngeometry.position = vec4(commonPosition, 0.0, 1.0);\ngeometry.normal = project_normal(normals);\nfloat elevation = 0.0;\nif (column.extruded) {\nelevation = interp(instanceElevationValues, hexagon.elevationDomain.xy, hexagon.elevationRange);\nelevation = project_size(elevation);\ngeometry.position.z = (positions.z + 1.0) / 2.0 * elevation;\n}\ngl_Position = project_common_position_to_clipspace(geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nvColor = interp(instanceColorValues, hexagon.colorDomain.xy, colorRange);\nvColor.a *= layer.opacity;\nif (column.extruded) {\nvColor.rgb = lighting_getLightColor(vColor.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);\n}\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n//# sourceMappingURL=hexagon-cell-layer-vertex.glsl.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst uniformBlock = /* glsl */ `\\\nuniform hexagonUniforms {\n  vec4 colorDomain;\n  vec4 elevationDomain;\n  vec2 elevationRange;\n  vec2 originCommon;\n} hexagon;\n`;\nexport const hexagonUniforms = {\n    name: 'hexagon',\n    vs: uniformBlock,\n    uniformTypes: {\n        colorDomain: 'vec4<f32>',\n        elevationDomain: 'vec4<f32>',\n        elevationRange: 'vec2<f32>',\n        originCommon: 'vec2<f32>'\n    }\n};\n//# sourceMappingURL=hexagon-layer-uniforms.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { ColumnLayer } from '@deck.gl/layers';\nimport { createColorRangeTexture, updateColorRangeTexture } from \"../common/utils/color-utils.js\";\nimport vs from \"./hexagon-cell-layer-vertex.glsl.js\";\nimport { hexagonUniforms } from \"./hexagon-layer-uniforms.js\";\nclass HexagonCellLayer extends ColumnLayer {\n    getShaders() {\n        const shaders = super.getShaders();\n        shaders.modules.push(hexagonUniforms);\n        return { ...shaders, vs };\n    }\n    initializeState() {\n        super.initializeState();\n        const attributeManager = this.getAttributeManager();\n        attributeManager.remove([\n            'instanceElevations',\n            'instanceFillColors',\n            'instanceLineColors',\n            'instanceStrokeWidths'\n        ]);\n        attributeManager.addInstanced({\n            instancePositions: {\n                size: 2,\n                type: 'float32',\n                accessor: 'getBin'\n            },\n            instanceColorValues: {\n                size: 1,\n                type: 'float32',\n                accessor: 'getColorValue'\n            },\n            instanceElevationValues: {\n                size: 1,\n                type: 'float32',\n                accessor: 'getElevationValue'\n            }\n        });\n    }\n    updateState(params) {\n        super.updateState(params);\n        const { props, oldProps } = params;\n        const model = this.state.fillModel;\n        if (oldProps.colorRange !== props.colorRange) {\n            this.state.colorTexture?.destroy();\n            this.state.colorTexture = createColorRangeTexture(this.context.device, props.colorRange, props.colorScaleType);\n            const hexagonProps = { colorRange: this.state.colorTexture };\n            model.shaderInputs.setProps({ hexagon: hexagonProps });\n        }\n        else if (oldProps.colorScaleType !== props.colorScaleType) {\n            updateColorRangeTexture(this.state.colorTexture, props.colorScaleType);\n        }\n    }\n    finalizeState(context) {\n        super.finalizeState(context);\n        this.state.colorTexture?.destroy();\n    }\n    draw({ uniforms }) {\n        const { radius, hexOriginCommon, elevationRange, elevationScale, extruded, coverage, colorDomain, elevationDomain } = this.props;\n        const colorCutoff = this.props.colorCutoff || [-Infinity, Infinity];\n        const elevationCutoff = this.props.elevationCutoff || [-Infinity, Infinity];\n        const fillModel = this.state.fillModel;\n        if (fillModel.vertexArray.indexBuffer) {\n            // indices are for drawing wireframe, disable them\n            // TODO - this should be handled in ColumnLayer?\n            fillModel.setIndexBuffer(null);\n        }\n        fillModel.setVertexCount(this.state.fillVertexCount);\n        const hexagonProps = {\n            colorDomain: [\n                Math.max(colorDomain[0], colorCutoff[0]), // instanceColorValue that maps to colorRange[0]\n                Math.min(colorDomain[1], colorCutoff[1]), // instanceColorValue that maps to colorRange[colorRange.length - 1]\n                Math.max(colorDomain[0] - 1, colorCutoff[0]), // hide cell if instanceColorValue is less than this\n                Math.min(colorDomain[1] + 1, colorCutoff[1]) // hide cell if instanceColorValue is greater than this\n            ],\n            elevationDomain: [\n                Math.max(elevationDomain[0], elevationCutoff[0]), // instanceElevationValue that maps to elevationRange[0]\n                Math.min(elevationDomain[1], elevationCutoff[1]), // instanceElevationValue that maps to elevationRange[elevationRange.length - 1]\n                Math.max(elevationDomain[0] - 1, elevationCutoff[0]), // hide cell if instanceElevationValue is less than this\n                Math.min(elevationDomain[1] + 1, elevationCutoff[1]) // hide cell if instanceElevationValue is greater than this\n            ],\n            elevationRange: [elevationRange[0] * elevationScale, elevationRange[1] * elevationScale],\n            originCommon: hexOriginCommon\n        };\n        fillModel.shaderInputs.setProps({\n            column: { extruded, coverage, radius },\n            hexagon: hexagonProps\n        });\n        fillModel.draw(this.context.renderPass);\n    }\n}\nHexagonCellLayer.layerName = 'HexagonCellLayer';\nexport default HexagonCellLayer;\n//# sourceMappingURL=hexagon-cell-layer.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst uniformBlock = /* glsl */ `\\\nuniform binOptionsUniforms {\n  vec2 hexOriginCommon;\n  float radiusCommon;\n} binOptions;\n`;\nexport const binOptionsUniforms = {\n    name: 'binOptions',\n    vs: uniformBlock,\n    uniformTypes: {\n        hexOriginCommon: 'vec2<f32>',\n        radiusCommon: 'f32'\n    }\n};\n//# sourceMappingURL=bin-options-uniforms.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log, createIterable, project32, Viewport } from '@deck.gl/core';\nimport { WebGLAggregator, CPUAggregator } from \"../common/aggregator/index.js\";\nimport AggregationLayer from \"../common/aggregation-layer.js\";\nimport { defaultColorRange } from \"../common/utils/color-utils.js\";\nimport { AttributeWithScale } from \"../common/utils/scale-utils.js\";\nimport { getBinIdRange } from \"../common/utils/bounds-utils.js\";\nimport HexagonCellLayer from \"./hexagon-cell-layer.js\";\nimport { pointToHexbin, HexbinVertices, getHexbinCentroid, pointToHexbinGLSL } from \"./hexbin.js\";\nimport { binOptionsUniforms } from \"./bin-options-uniforms.js\";\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() { }\nconst defaultProps = {\n    gpuAggregation: true,\n    // color\n    colorDomain: null,\n    colorRange: defaultColorRange,\n    getColorValue: { type: 'accessor', value: null }, // default value is calculated from `getColorWeight` and `colorAggregation`\n    getColorWeight: { type: 'accessor', value: 1 },\n    colorAggregation: 'SUM',\n    lowerPercentile: { type: 'number', min: 0, max: 100, value: 0 },\n    upperPercentile: { type: 'number', min: 0, max: 100, value: 100 },\n    colorScaleType: 'quantize',\n    onSetColorDomain: noop,\n    // elevation\n    elevationDomain: null,\n    elevationRange: [0, 1000],\n    getElevationValue: { type: 'accessor', value: null }, // default value is calculated from `getElevationWeight` and `elevationAggregation`\n    getElevationWeight: { type: 'accessor', value: 1 },\n    elevationAggregation: 'SUM',\n    elevationScale: { type: 'number', min: 0, value: 1 },\n    elevationLowerPercentile: { type: 'number', min: 0, max: 100, value: 0 },\n    elevationUpperPercentile: { type: 'number', min: 0, max: 100, value: 100 },\n    elevationScaleType: 'linear',\n    onSetElevationDomain: noop,\n    // hexbin\n    radius: { type: 'number', min: 1, value: 1000 },\n    coverage: { type: 'number', min: 0, max: 1, value: 1 },\n    getPosition: { type: 'accessor', value: (x) => x.position },\n    hexagonAggregator: { type: 'function', optional: true, value: null },\n    extruded: false,\n    // Optional material for 'lighting' shader module\n    material: true\n};\n/** Aggregate data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. */\nclass HexagonLayer extends AggregationLayer {\n    getAggregatorType() {\n        const { gpuAggregation, hexagonAggregator, getColorValue, getElevationValue } = this.props;\n        if (gpuAggregation && (hexagonAggregator || getColorValue || getElevationValue)) {\n            // If these features are desired by the app, the user should explicitly use CPU aggregation\n            log.warn('Features not supported by GPU aggregation, falling back to CPU')();\n            return 'cpu';\n        }\n        if (\n        // GPU aggregation is requested\n        gpuAggregation &&\n            // GPU aggregation is supported by the device\n            WebGLAggregator.isSupported(this.context.device)) {\n            return 'gpu';\n        }\n        return 'cpu';\n    }\n    createAggregator(type) {\n        if (type === 'cpu') {\n            const { hexagonAggregator, radius } = this.props;\n            return new CPUAggregator({\n                dimensions: 2,\n                getBin: {\n                    sources: ['positions'],\n                    getValue: ({ positions }, index, opts) => {\n                        if (hexagonAggregator) {\n                            return hexagonAggregator(positions, radius);\n                        }\n                        const viewport = this.state.aggregatorViewport;\n                        // project to common space\n                        const p = viewport.projectPosition(positions);\n                        const { radiusCommon, hexOriginCommon } = opts;\n                        return pointToHexbin([p[0] - hexOriginCommon[0], p[1] - hexOriginCommon[1]], radiusCommon);\n                    }\n                },\n                getValue: [\n                    { sources: ['colorWeights'], getValue: ({ colorWeights }) => colorWeights },\n                    { sources: ['elevationWeights'], getValue: ({ elevationWeights }) => elevationWeights }\n                ]\n            });\n        }\n        return new WebGLAggregator(this.context.device, {\n            dimensions: 2,\n            channelCount: 2,\n            bufferLayout: this.getAttributeManager().getBufferLayouts({ isInstanced: false }),\n            ...super.getShaders({\n                modules: [project32, binOptionsUniforms],\n                vs: /* glsl */ `\n  in vec3 positions;\n  in vec3 positions64Low;\n  in float colorWeights;\n  in float elevationWeights;\n  \n  ${pointToHexbinGLSL}\n\n  void getBin(out ivec2 binId) {\n    vec3 positionCommon = project_position(positions, positions64Low);\n    binId = pointToHexbin(positionCommon.xy, binOptions.radiusCommon);\n  }\n  void getValue(out vec2 value) {\n    value = vec2(colorWeights, elevationWeights);\n  }\n  `\n            })\n        });\n    }\n    initializeState() {\n        super.initializeState();\n        const attributeManager = this.getAttributeManager();\n        attributeManager.add({\n            positions: {\n                size: 3,\n                accessor: 'getPosition',\n                type: 'float64',\n                fp64: this.use64bitPositions()\n            },\n            colorWeights: { size: 1, accessor: 'getColorWeight' },\n            elevationWeights: { size: 1, accessor: 'getElevationWeight' }\n        });\n    }\n    // eslint-disable-next-line complexity\n    updateState(params) {\n        const aggregatorChanged = super.updateState(params);\n        const { props, oldProps, changeFlags } = params;\n        const { aggregator } = this.state;\n        if ((changeFlags.dataChanged || !this.state.dataAsArray) &&\n            (props.getColorValue || props.getElevationValue)) {\n            // Convert data to array\n            this.state.dataAsArray = Array.from(createIterable(props.data).iterable);\n        }\n        if (aggregatorChanged ||\n            changeFlags.dataChanged ||\n            props.radius !== oldProps.radius ||\n            props.getColorValue !== oldProps.getColorValue ||\n            props.getElevationValue !== oldProps.getElevationValue ||\n            props.colorAggregation !== oldProps.colorAggregation ||\n            props.elevationAggregation !== oldProps.elevationAggregation) {\n            this._updateBinOptions();\n            const { radiusCommon, hexOriginCommon, binIdRange, dataAsArray } = this.state;\n            aggregator.setProps({\n                // @ts-expect-error only used by GPUAggregator\n                binIdRange,\n                pointCount: this.getNumInstances(),\n                operations: [props.colorAggregation, props.elevationAggregation],\n                binOptions: {\n                    radiusCommon,\n                    hexOriginCommon\n                },\n                onUpdate: this._onAggregationUpdate.bind(this)\n            });\n            if (dataAsArray) {\n                const { getColorValue, getElevationValue } = this.props;\n                aggregator.setProps({\n                    // @ts-expect-error only used by CPUAggregator\n                    customOperations: [\n                        getColorValue &&\n                            ((indices) => getColorValue(indices.map(i => dataAsArray[i]), { indices, data: props.data })),\n                        getElevationValue &&\n                            ((indices) => getElevationValue(indices.map(i => dataAsArray[i]), { indices, data: props.data }))\n                    ]\n                });\n            }\n        }\n        if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getColorValue) {\n            aggregator.setNeedsUpdate(0);\n        }\n        if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getElevationValue) {\n            aggregator.setNeedsUpdate(1);\n        }\n        return aggregatorChanged;\n    }\n    _updateBinOptions() {\n        const bounds = this.getBounds();\n        let radiusCommon = 1;\n        let hexOriginCommon = [0, 0];\n        let binIdRange = [\n            [0, 1],\n            [0, 1]\n        ];\n        let viewport = this.context.viewport;\n        if (bounds && Number.isFinite(bounds[0][0])) {\n            let centroid = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];\n            const { radius } = this.props;\n            const { unitsPerMeter } = viewport.getDistanceScales(centroid);\n            radiusCommon = unitsPerMeter[0] * radius;\n            // Use the centroid of the hex at the center of the data\n            // This offsets the common space without changing the bins\n            const centerHex = pointToHexbin(viewport.projectFlat(centroid), radiusCommon);\n            centroid = viewport.unprojectFlat(getHexbinCentroid(centerHex, radiusCommon));\n            const ViewportType = viewport.constructor;\n            // We construct a viewport for the GPU aggregator's project module\n            // This viewport is determined by data\n            // removes arbitrary precision variance that depends on initial view state\n            viewport = viewport.isGeospatial\n                ? new ViewportType({ longitude: centroid[0], latitude: centroid[1], zoom: 12 })\n                : new Viewport({ position: [centroid[0], centroid[1], 0], zoom: 12 });\n            hexOriginCommon = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1])];\n            binIdRange = getBinIdRange({\n                dataBounds: bounds,\n                getBinId: (p) => {\n                    const positionCommon = viewport.projectFlat(p);\n                    positionCommon[0] -= hexOriginCommon[0];\n                    positionCommon[1] -= hexOriginCommon[1];\n                    return pointToHexbin(positionCommon, radiusCommon);\n                },\n                padding: 1\n            });\n        }\n        this.setState({ radiusCommon, hexOriginCommon, binIdRange, aggregatorViewport: viewport });\n    }\n    draw(opts) {\n        // Replaces render time viewport with our own\n        if (opts.shaderModuleProps.project) {\n            opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;\n        }\n        super.draw(opts);\n    }\n    _onAggregationUpdate({ channel }) {\n        const props = this.getCurrentLayer().props;\n        const { aggregator } = this.state;\n        if (channel === 0) {\n            const result = aggregator.getResult(0);\n            this.setState({\n                colors: new AttributeWithScale(result, aggregator.binCount)\n            });\n            props.onSetColorDomain(aggregator.getResultDomain(0));\n        }\n        else if (channel === 1) {\n            const result = aggregator.getResult(1);\n            this.setState({\n                elevations: new AttributeWithScale(result, aggregator.binCount)\n            });\n            props.onSetElevationDomain(aggregator.getResultDomain(1));\n        }\n    }\n    onAttributeChange(id) {\n        const { aggregator } = this.state;\n        switch (id) {\n            case 'positions':\n                aggregator.setNeedsUpdate();\n                this._updateBinOptions();\n                const { radiusCommon, hexOriginCommon, binIdRange } = this.state;\n                aggregator.setProps({\n                    // @ts-expect-error only used by GPUAggregator\n                    binIdRange,\n                    binOptions: {\n                        radiusCommon,\n                        hexOriginCommon\n                    }\n                });\n                break;\n            case 'colorWeights':\n                aggregator.setNeedsUpdate(0);\n                break;\n            case 'elevationWeights':\n                aggregator.setNeedsUpdate(1);\n                break;\n            default:\n            // This should not happen\n        }\n    }\n    renderLayers() {\n        const { aggregator, radiusCommon, hexOriginCommon } = this.state;\n        const { elevationScale, colorRange, elevationRange, extruded, coverage, material, transitions, colorScaleType, lowerPercentile, upperPercentile, colorDomain, elevationScaleType, elevationLowerPercentile, elevationUpperPercentile, elevationDomain } = this.props;\n        const CellLayerClass = this.getSubLayerClass('cells', HexagonCellLayer);\n        const binAttribute = aggregator.getBins();\n        const colors = this.state.colors?.update({\n            scaleType: colorScaleType,\n            lowerPercentile,\n            upperPercentile\n        });\n        const elevations = this.state.elevations?.update({\n            scaleType: elevationScaleType,\n            lowerPercentile: elevationLowerPercentile,\n            upperPercentile: elevationUpperPercentile\n        });\n        if (!colors || !elevations) {\n            return null;\n        }\n        return new CellLayerClass(this.getSubLayerProps({\n            id: 'cells'\n        }), {\n            data: {\n                length: aggregator.binCount,\n                attributes: {\n                    getBin: binAttribute,\n                    getColorValue: colors.attribute,\n                    getElevationValue: elevations.attribute\n                }\n            },\n            // Data has changed shallowly, but we likely don't need to update the attributes\n            dataComparator: (data, oldData) => data.length === oldData.length,\n            updateTriggers: {\n                getBin: [binAttribute],\n                getColorValue: [colors.attribute],\n                getElevationValue: [elevations.attribute]\n            },\n            diskResolution: 6,\n            vertices: HexbinVertices,\n            radius: radiusCommon,\n            hexOriginCommon,\n            elevationScale,\n            colorRange,\n            colorScaleType,\n            elevationRange,\n            extruded,\n            coverage,\n            material,\n            colorDomain: colors.domain || colorDomain || aggregator.getResultDomain(0),\n            elevationDomain: elevations.domain || elevationDomain || aggregator.getResultDomain(1),\n            colorCutoff: colors.cutoff,\n            elevationCutoff: elevations.cutoff,\n            transitions: transitions && {\n                getFillColor: transitions.getColorValue || transitions.getColorWeight,\n                getElevation: transitions.getElevationValue || transitions.getElevationWeight\n            },\n            // Extensions are already handled by the GPUAggregator, do not pass it down\n            extensions: []\n        });\n    }\n    getPickingInfo(params) {\n        const info = params.info;\n        const { index } = info;\n        if (index >= 0) {\n            const bin = this.state.aggregator.getBin(index);\n            let object;\n            if (bin) {\n                const centroidCommon = getHexbinCentroid(bin.id, this.state.radiusCommon);\n                const centroid = this.context.viewport.unprojectFlat(centroidCommon);\n                object = {\n                    col: bin.id[0],\n                    row: bin.id[1],\n                    position: centroid,\n                    colorValue: bin.value[0],\n                    elevationValue: bin.value[1],\n                    count: bin.count\n                };\n                if (bin.pointIndices) {\n                    object.pointIndices = bin.pointIndices;\n                    object.points = Array.isArray(this.props.data)\n                        ? bin.pointIndices.map(i => this.props.data[i])\n                        : [];\n                }\n            }\n            info.object = object;\n        }\n        return info;\n    }\n}\nHexagonLayer.layerName = 'HexagonLayer';\nHexagonLayer.defaultProps = defaultProps;\nexport default HexagonLayer;\n//# sourceMappingURL=hexagon-layer.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Code to Offsets Map needed to implement Marching Squares algorithm\n// Ref: https://en.wikipedia.org/wiki/Marching_squares\n// Table to map code to the intersection offsets\n// All offsets are relative to the center of marching cell (which is top right corner of grid-cell, and center of marching-square)\nconst HALF = 0.5;\nconst ONE6TH = 1 / 6;\nconst OFFSET = {\n    N: [0, HALF], // NORTH\n    E: [HALF, 0], // EAST\n    S: [0, -HALF], // SOUTH\n    W: [-HALF, 0], // WEST\n    // CORNERS\n    NE: [HALF, HALF],\n    NW: [-HALF, HALF],\n    SE: [HALF, -HALF],\n    SW: [-HALF, -HALF]\n};\n// NOTE: vertices are ordered in CCW direction, starting from NW corner\n// Triangles\nconst SW_TRIANGLE = [OFFSET.W, OFFSET.SW, OFFSET.S];\nconst SE_TRIANGLE = [OFFSET.S, OFFSET.SE, OFFSET.E];\nconst NE_TRIANGLE = [OFFSET.E, OFFSET.NE, OFFSET.N];\nconst NW_TRIANGLE = [OFFSET.NW, OFFSET.W, OFFSET.N];\n// Trapezoids\nconst SW_TRAPEZOID = [\n    [-HALF, ONE6TH],\n    [-HALF, -ONE6TH],\n    [-ONE6TH, -HALF],\n    [ONE6TH, -HALF]\n];\nconst SE_TRAPEZOID = [\n    [-ONE6TH, -HALF],\n    [ONE6TH, -HALF],\n    [HALF, -ONE6TH],\n    [HALF, ONE6TH]\n];\nconst NE_TRAPEZOID = [\n    [HALF, -ONE6TH],\n    [HALF, ONE6TH],\n    [ONE6TH, HALF],\n    [-ONE6TH, HALF]\n];\nconst NW_TRAPEZOID = [\n    [-HALF, ONE6TH],\n    [-HALF, -ONE6TH],\n    [ONE6TH, HALF],\n    [-ONE6TH, HALF]\n];\n// Rectangles\nconst S_RECTANGLE = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.E];\nconst E_RECTANGLE = [OFFSET.S, OFFSET.SE, OFFSET.NE, OFFSET.N];\nconst N_RECTANGLE = [OFFSET.NW, OFFSET.W, OFFSET.E, OFFSET.NE];\nconst W_RECTANGLE = [OFFSET.NW, OFFSET.SW, OFFSET.S, OFFSET.N];\nconst EW_RECTANGEL = [\n    [-HALF, ONE6TH],\n    [-HALF, -ONE6TH],\n    [HALF, -ONE6TH],\n    [HALF, ONE6TH]\n];\nconst SN_RECTANGEL = [\n    [-ONE6TH, -HALF],\n    [ONE6TH, -HALF],\n    [ONE6TH, HALF],\n    [-ONE6TH, HALF]\n];\n// Square\nconst SQUARE = [OFFSET.NW, OFFSET.SW, OFFSET.SE, OFFSET.NE];\n// Pentagons\nconst SW_PENTAGON = [OFFSET.NW, OFFSET.SW, OFFSET.SE, OFFSET.E, OFFSET.N];\nconst SE_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.NE, OFFSET.N];\nconst NE_PENTAGON = [OFFSET.NW, OFFSET.W, OFFSET.S, OFFSET.SE, OFFSET.NE];\nconst NW_PENTAGON = [OFFSET.NW, OFFSET.SW, OFFSET.S, OFFSET.E, OFFSET.NE];\nconst NW_N_PENTAGON = [OFFSET.NW, OFFSET.W, [HALF, -ONE6TH], [HALF, ONE6TH], OFFSET.N];\nconst NE_E_PENTAGON = [[-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.E, OFFSET.NE, OFFSET.N];\nconst SE_S_PENTAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.S, OFFSET.SE, OFFSET.E];\nconst SW_W_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, [ONE6TH, HALF], [-ONE6TH, HALF]];\nconst NW_W_PENTAGON = [OFFSET.NW, OFFSET.W, [-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.N];\nconst NE_N_PENTAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.E, OFFSET.NE, OFFSET.N];\nconst SE_E_PENTAGON = [OFFSET.S, OFFSET.SE, OFFSET.E, [ONE6TH, HALF], [-ONE6TH, HALF]];\nconst SW_S_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, [HALF, -ONE6TH], [HALF, ONE6TH]];\n// Hexagon\nconst S_HEXAGON = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.E, [ONE6TH, HALF], [-ONE6TH, HALF]];\nconst E_HEXAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.S, OFFSET.SE, OFFSET.NE, OFFSET.N];\nconst N_HEXAGON = [OFFSET.NW, OFFSET.W, [-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.E, OFFSET.NE];\nconst W_HEXAGON = [OFFSET.NW, OFFSET.SW, OFFSET.S, [HALF, -ONE6TH], [HALF, ONE6TH], OFFSET.N];\nconst SW_NE_HEXAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, OFFSET.E, OFFSET.NE, OFFSET.N];\nconst NW_SE_HEXAGON = [OFFSET.NW, OFFSET.W, OFFSET.S, OFFSET.SE, OFFSET.E, OFFSET.N];\n// Heptagon (7-sided)\nconst NE_HEPTAGON = [\n    [-HALF, ONE6TH],\n    [-HALF, -ONE6TH],\n    [-ONE6TH, -HALF],\n    [ONE6TH, -HALF],\n    OFFSET.E,\n    OFFSET.NE,\n    OFFSET.N\n];\nconst SW_HEPTAGON = [\n    OFFSET.W,\n    OFFSET.SW,\n    OFFSET.S,\n    [HALF, -ONE6TH],\n    [HALF, ONE6TH],\n    [ONE6TH, HALF],\n    [-ONE6TH, HALF]\n];\nconst NW_HEPTAGON = [\n    OFFSET.NW,\n    OFFSET.W,\n    [-ONE6TH, -HALF],\n    [ONE6TH, -HALF],\n    [HALF, -ONE6TH],\n    [HALF, ONE6TH],\n    OFFSET.N\n];\nconst SE_HEPTAGON = [\n    [-HALF, ONE6TH],\n    [-HALF, -ONE6TH],\n    OFFSET.S,\n    OFFSET.SE,\n    OFFSET.E,\n    [ONE6TH, HALF],\n    [-ONE6TH, HALF]\n];\n// Octagon\nconst OCTAGON = [\n    [-HALF, ONE6TH],\n    [-HALF, -ONE6TH],\n    [-ONE6TH, -HALF],\n    [ONE6TH, -HALF],\n    [HALF, -ONE6TH],\n    [HALF, ONE6TH],\n    [ONE6TH, HALF],\n    [-ONE6TH, HALF]\n];\n// Note: above wiki page invertes white/black dots for generating the code, we don't\nexport const ISOLINES_CODE_OFFSET_MAP = {\n    // key is equal to the code of 4 vertices (invert the code specified in wiki)\n    // value can be an array or an Object\n    // Array : [line] or [line, line], where each line is [start-point, end-point], and each point is [x, y]\n    // Object : to handle saddle cases, whos output depends on mean value of all 4 corners\n    //  key: code of mean value (0 or 1)\n    //  value: Array , as above defines one or two line segments\n    0: [],\n    1: [[OFFSET.W, OFFSET.S]],\n    2: [[OFFSET.S, OFFSET.E]],\n    3: [[OFFSET.W, OFFSET.E]],\n    4: [[OFFSET.N, OFFSET.E]],\n    5: {\n        0: [\n            [OFFSET.W, OFFSET.S],\n            [OFFSET.N, OFFSET.E]\n        ],\n        1: [\n            [OFFSET.W, OFFSET.N],\n            [OFFSET.S, OFFSET.E]\n        ]\n    },\n    6: [[OFFSET.N, OFFSET.S]],\n    7: [[OFFSET.W, OFFSET.N]],\n    8: [[OFFSET.W, OFFSET.N]],\n    9: [[OFFSET.N, OFFSET.S]],\n    10: {\n        0: [\n            [OFFSET.W, OFFSET.N],\n            [OFFSET.S, OFFSET.E]\n        ],\n        1: [\n            [OFFSET.W, OFFSET.S],\n            [OFFSET.N, OFFSET.E]\n        ]\n    },\n    11: [[OFFSET.N, OFFSET.E]],\n    12: [[OFFSET.W, OFFSET.E]],\n    13: [[OFFSET.S, OFFSET.E]],\n    14: [[OFFSET.W, OFFSET.S]],\n    15: []\n};\nfunction ternaryToIndex(ternary) {\n    return parseInt(ternary, 4);\n}\nexport const ISOBANDS_CODE_OFFSET_MAP = {\n    // Below list of cases, follow the same order as in above mentioned wiki page.\n    // Each case has its code on first commented line // T,TR,R,C\n    // where T: Top, TR: Top-right, R: Right and C: current, each will be either 0, 1 or 2\n    // final code is binary representation of above code , where takes 2 digits\n    // for example:  code 2-2-2-1 => 10-10-10-01 => 10101001 => 169\n    // no contours\n    [ternaryToIndex('0000')]: [],\n    [ternaryToIndex('2222')]: [],\n    // single triangle\n    [ternaryToIndex('2221')]: [SW_TRIANGLE],\n    [ternaryToIndex('2212')]: [SE_TRIANGLE],\n    [ternaryToIndex('2122')]: [NE_TRIANGLE],\n    [ternaryToIndex('1222')]: [NW_TRIANGLE],\n    [ternaryToIndex('0001')]: [SW_TRIANGLE],\n    [ternaryToIndex('0010')]: [SE_TRIANGLE],\n    [ternaryToIndex('0100')]: [NE_TRIANGLE],\n    [ternaryToIndex('1000')]: [NW_TRIANGLE],\n    // single trapezoid\n    [ternaryToIndex('2220')]: [SW_TRAPEZOID],\n    [ternaryToIndex('2202')]: [SE_TRAPEZOID],\n    [ternaryToIndex('2022')]: [NE_TRAPEZOID],\n    [ternaryToIndex('0222')]: [NW_TRAPEZOID],\n    [ternaryToIndex('0002')]: [SW_TRAPEZOID],\n    [ternaryToIndex('0020')]: [SE_TRAPEZOID],\n    [ternaryToIndex('0200')]: [NE_TRAPEZOID],\n    [ternaryToIndex('2000')]: [NW_TRAPEZOID],\n    // single rectangle\n    [ternaryToIndex('0011')]: [S_RECTANGLE],\n    [ternaryToIndex('0110')]: [E_RECTANGLE],\n    [ternaryToIndex('1100')]: [N_RECTANGLE],\n    [ternaryToIndex('1001')]: [W_RECTANGLE],\n    [ternaryToIndex('2211')]: [S_RECTANGLE],\n    [ternaryToIndex('2112')]: [E_RECTANGLE],\n    [ternaryToIndex('1122')]: [N_RECTANGLE],\n    [ternaryToIndex('1221')]: [W_RECTANGLE],\n    [ternaryToIndex('2200')]: [EW_RECTANGEL],\n    [ternaryToIndex('2002')]: [SN_RECTANGEL],\n    [ternaryToIndex('0022')]: [EW_RECTANGEL],\n    [ternaryToIndex('0220')]: [SN_RECTANGEL],\n    // single square\n    // 1111\n    [ternaryToIndex('1111')]: [SQUARE],\n    // single pentagon\n    [ternaryToIndex('1211')]: [SW_PENTAGON],\n    [ternaryToIndex('2111')]: [SE_PENTAGON],\n    [ternaryToIndex('1112')]: [NE_PENTAGON],\n    [ternaryToIndex('1121')]: [NW_PENTAGON],\n    [ternaryToIndex('1011')]: [SW_PENTAGON],\n    [ternaryToIndex('0111')]: [SE_PENTAGON],\n    [ternaryToIndex('1110')]: [NE_PENTAGON],\n    [ternaryToIndex('1101')]: [NW_PENTAGON],\n    [ternaryToIndex('1200')]: [NW_N_PENTAGON],\n    [ternaryToIndex('0120')]: [NE_E_PENTAGON],\n    [ternaryToIndex('0012')]: [SE_S_PENTAGON],\n    [ternaryToIndex('2001')]: [SW_W_PENTAGON],\n    [ternaryToIndex('1022')]: [NW_N_PENTAGON],\n    [ternaryToIndex('2102')]: [NE_E_PENTAGON],\n    [ternaryToIndex('2210')]: [SE_S_PENTAGON],\n    [ternaryToIndex('0221')]: [SW_W_PENTAGON],\n    [ternaryToIndex('1002')]: [NW_W_PENTAGON],\n    [ternaryToIndex('2100')]: [NE_N_PENTAGON],\n    [ternaryToIndex('0210')]: [SE_E_PENTAGON],\n    [ternaryToIndex('0021')]: [SW_S_PENTAGON],\n    [ternaryToIndex('1220')]: [NW_W_PENTAGON],\n    [ternaryToIndex('0122')]: [NE_N_PENTAGON],\n    [ternaryToIndex('2012')]: [SE_E_PENTAGON],\n    [ternaryToIndex('2201')]: [SW_S_PENTAGON],\n    // single hexagon\n    [ternaryToIndex('0211')]: [S_HEXAGON],\n    [ternaryToIndex('2110')]: [E_HEXAGON],\n    [ternaryToIndex('1102')]: [N_HEXAGON],\n    [ternaryToIndex('1021')]: [W_HEXAGON],\n    [ternaryToIndex('2011')]: [S_HEXAGON],\n    [ternaryToIndex('0112')]: [E_HEXAGON],\n    [ternaryToIndex('1120')]: [N_HEXAGON],\n    [ternaryToIndex('1201')]: [W_HEXAGON],\n    [ternaryToIndex('2101')]: [SW_NE_HEXAGON],\n    [ternaryToIndex('0121')]: [SW_NE_HEXAGON],\n    [ternaryToIndex('1012')]: [NW_SE_HEXAGON],\n    [ternaryToIndex('1210')]: [NW_SE_HEXAGON],\n    // 6-sided polygons based on mean weight\n    // NOTE: merges mean value codes for extreme changes (as per above Wiki doc)\n    [ternaryToIndex('0101')]: {\n        0: [SW_TRIANGLE, NE_TRIANGLE],\n        1: [SW_NE_HEXAGON],\n        2: [SW_NE_HEXAGON]\n    },\n    [ternaryToIndex('1010')]: {\n        0: [NW_TRIANGLE, SE_TRIANGLE],\n        1: [NW_SE_HEXAGON],\n        2: [NW_SE_HEXAGON]\n    },\n    [ternaryToIndex('2121')]: {\n        0: [SW_NE_HEXAGON],\n        1: [SW_NE_HEXAGON],\n        2: [SW_TRIANGLE, NE_TRIANGLE]\n    },\n    [ternaryToIndex('1212')]: {\n        0: [NW_SE_HEXAGON],\n        1: [NW_SE_HEXAGON],\n        2: [NW_TRIANGLE, SE_TRIANGLE]\n    },\n    // 7-sided polygons based on mean weight\n    [ternaryToIndex('2120')]: {\n        0: [NE_HEPTAGON],\n        1: [NE_HEPTAGON],\n        2: [SW_TRAPEZOID, NE_TRIANGLE]\n    },\n    [ternaryToIndex('2021')]: {\n        0: [SW_HEPTAGON],\n        1: [SW_HEPTAGON],\n        2: [SW_TRIANGLE, NE_TRAPEZOID]\n    },\n    [ternaryToIndex('1202')]: {\n        0: [NW_HEPTAGON],\n        1: [NW_HEPTAGON],\n        2: [NW_TRIANGLE, SE_TRAPEZOID]\n    },\n    [ternaryToIndex('0212')]: {\n        0: [SE_HEPTAGON],\n        1: [SE_HEPTAGON],\n        2: [SE_TRIANGLE, NW_TRAPEZOID]\n    },\n    [ternaryToIndex('0102')]: {\n        0: [SW_TRAPEZOID, NE_TRIANGLE],\n        1: [NE_HEPTAGON],\n        2: [NE_HEPTAGON]\n    },\n    [ternaryToIndex('0201')]: {\n        0: [SW_TRIANGLE, NE_TRAPEZOID],\n        1: [SW_HEPTAGON],\n        2: [SW_HEPTAGON]\n    },\n    [ternaryToIndex('1020')]: {\n        0: [NW_TRIANGLE, SE_TRAPEZOID],\n        1: [NW_HEPTAGON],\n        2: [NW_HEPTAGON]\n    },\n    [ternaryToIndex('2010')]: {\n        0: [SE_TRIANGLE, NW_TRAPEZOID],\n        1: [SE_HEPTAGON],\n        2: [SE_HEPTAGON]\n    },\n    // 8-sided polygons based on mean weight\n    [ternaryToIndex('2020')]: {\n        0: [NW_TRAPEZOID, SE_TRAPEZOID],\n        1: [OCTAGON],\n        2: [SW_TRAPEZOID, NE_TRAPEZOID]\n    },\n    [ternaryToIndex('0202')]: {\n        0: [NE_TRAPEZOID, SW_TRAPEZOID],\n        1: [OCTAGON],\n        2: [NW_TRAPEZOID, SE_TRAPEZOID]\n    }\n};\n//# sourceMappingURL=marching-squares-codes.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// All utility methods needed to implement Marching Squares algorithm\n// Ref: https://en.wikipedia.org/wiki/Marching_squares\nimport { ISOLINES_CODE_OFFSET_MAP, ISOBANDS_CODE_OFFSET_MAP } from \"./marching-squares-codes.js\";\n// Utility methods\nfunction getVertexCode(weight, threshold) {\n    // threshold must be a single value or a range (array of size 2)\n    if (Number.isNaN(weight)) {\n        return 0;\n    }\n    // Iso-bands\n    if (Array.isArray(threshold)) {\n        if (weight < threshold[0]) {\n            return 0;\n        }\n        return weight < threshold[1] ? 1 : 2;\n    }\n    // Iso-lines\n    return weight >= threshold ? 1 : 0;\n}\n// Returns marching square code for given cell\n/* eslint-disable complexity, max-statements*/\nexport function getCode(opts) {\n    // Assumptions\n    // Origin is on bottom-left , and X increase to right, Y to top\n    // When processing one cell, we process 4 cells, by extending row to top and on column to right\n    // to create a 2X2 cell grid\n    const { x, y, xRange, yRange, getValue, threshold } = opts;\n    const isLeftBoundary = x < xRange[0];\n    const isRightBoundary = x >= xRange[1] - 1;\n    const isBottomBoundary = y < yRange[0];\n    const isTopBoundary = y >= yRange[1] - 1;\n    const isBoundary = isLeftBoundary || isRightBoundary || isBottomBoundary || isTopBoundary;\n    let weights = 0;\n    let current;\n    let right;\n    let top;\n    let topRight;\n    // TOP\n    if (isLeftBoundary || isTopBoundary) {\n        top = 0;\n    }\n    else {\n        const w = getValue(x, y + 1);\n        top = getVertexCode(w, threshold);\n        weights += w;\n    }\n    // TOP-RIGHT\n    if (isRightBoundary || isTopBoundary) {\n        topRight = 0;\n    }\n    else {\n        const w = getValue(x + 1, y + 1);\n        topRight = getVertexCode(w, threshold);\n        weights += w;\n    }\n    // RIGHT\n    if (isRightBoundary || isBottomBoundary) {\n        right = 0;\n    }\n    else {\n        const w = getValue(x + 1, y);\n        right = getVertexCode(w, threshold);\n        weights += w;\n    }\n    // CURRENT\n    if (isLeftBoundary || isBottomBoundary) {\n        current = 0;\n    }\n    else {\n        const w = getValue(x, y);\n        current = getVertexCode(w, threshold);\n        weights += w;\n    }\n    let code = -1;\n    if (Number.isFinite(threshold)) {\n        code = (top << 3) | (topRight << 2) | (right << 1) | current;\n    }\n    if (Array.isArray(threshold)) {\n        code = (top << 6) | (topRight << 4) | (right << 2) | current;\n    }\n    let meanCode = 0;\n    // meanCode is only needed for saddle cases, and they should\n    // only occur when we are not processing a cell on boundary\n    // because when on a boundary either, bottom-row, top-row, left-column or right-column will have both 0 codes\n    if (!isBoundary) {\n        meanCode = getVertexCode(weights / 4, threshold);\n    }\n    return { code, meanCode };\n}\n/* eslint-enable complexity, max-statements*/\n// Returns intersection vertices for given cellindex\n// [x, y] refers current marching cell, reference vertex is always top-right corner\nexport function getPolygons(opts) {\n    const { x, y, z, code, meanCode } = opts;\n    let offsets = ISOBANDS_CODE_OFFSET_MAP[code];\n    // handle saddle cases\n    if (!Array.isArray(offsets)) {\n        offsets = offsets[meanCode];\n    }\n    // Reference vertex is at top-right move to top-right corner\n    const rX = x + 1;\n    const rY = y + 1;\n    // offsets format\n    // [[1A, 1B, 1C, ...], [2A, 2B, 2C, ...]],\n    // vertices format\n    // [\n    //   [[x1A, y1A], [x1B, y1B], [x1C, y1C] ... ],\n    //        ...\n    // ]\n    const polygons = [];\n    offsets.forEach(polygonOffsets => {\n        const polygon = [];\n        polygonOffsets.forEach(xyOffset => {\n            const vX = rX + xyOffset[0];\n            const vY = rY + xyOffset[1];\n            polygon.push([vX, vY, z]);\n        });\n        polygons.push(polygon);\n    });\n    return polygons;\n}\n// Returns intersection vertices for given cellindex\n// [x, y] refers current marching cell, reference vertex is always top-right corner\nexport function getLines(opts) {\n    const { x, y, z, code, meanCode } = opts;\n    let offsets = ISOLINES_CODE_OFFSET_MAP[code];\n    // handle saddle cases\n    if (!Array.isArray(offsets)) {\n        offsets = offsets[meanCode];\n    }\n    // Reference vertex is at top-right move to top-right corner\n    const rX = x + 1;\n    const rY = y + 1;\n    // offsets format\n    // [[1A, 1B], [2A, 2B]],\n    // vertices format\n    // [[x1A, y1A], [x1B, y1B], [x2A, x2B], ...],\n    const lines = [];\n    offsets.forEach(xyOffsets => {\n        xyOffsets.forEach(offset => {\n            const vX = rX + offset[0];\n            const vY = rY + offset[1];\n            lines.push([vX, vY, z]);\n        });\n    });\n    return lines;\n}\n//# sourceMappingURL=marching-squares.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getCode, getLines, getPolygons } from \"./marching-squares.js\";\n// Given all the cell weights, generates contours for each threshold.\n/* eslint-disable max-depth */\nexport function generateContours({ contours, getValue, xRange, yRange }) {\n    const contourLines = [];\n    const contourPolygons = [];\n    let segmentIndex = 0;\n    let polygonIndex = 0;\n    for (let i = 0; i < contours.length; i++) {\n        const contour = contours[i];\n        const z = contour.zIndex ?? i;\n        const { threshold } = contour;\n        for (let x = xRange[0] - 1; x < xRange[1]; x++) {\n            for (let y = yRange[0] - 1; y < yRange[1]; y++) {\n                // Get the MarchingSquares code based on neighbor cell weights.\n                const { code, meanCode } = getCode({\n                    getValue,\n                    threshold,\n                    x,\n                    y,\n                    xRange,\n                    yRange\n                });\n                const opts = {\n                    x,\n                    y,\n                    z,\n                    code,\n                    meanCode\n                };\n                if (Array.isArray(threshold)) {\n                    // ISO bands\n                    const polygons = getPolygons(opts);\n                    for (const polygon of polygons) {\n                        contourPolygons[polygonIndex++] = {\n                            vertices: polygon,\n                            contour\n                        };\n                    }\n                }\n                else {\n                    // ISO lines\n                    const path = getLines(opts);\n                    if (path.length > 0) {\n                        contourLines[segmentIndex++] = {\n                            vertices: path,\n                            contour\n                        };\n                    }\n                }\n            }\n        }\n    }\n    return { lines: contourLines, polygons: contourPolygons };\n}\n/* eslint-enable max-depth */\n//# sourceMappingURL=contour-utils.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { CPUAggregator, WebGLAggregator } from \"../common/aggregator/index.js\";\n/** Returns an accessor to the aggregated values from bin id */\nexport function getAggregatorValueReader(opts) {\n    const { aggregator, binIdRange, channel } = opts;\n    if (aggregator instanceof WebGLAggregator) {\n        const buffer = aggregator.getResult(channel)?.buffer;\n        if (buffer) {\n            const values = new Float32Array(buffer.readSyncWebGL().buffer);\n            return getWebGLAggregatorValueReader(values, binIdRange);\n        }\n    }\n    if (aggregator instanceof CPUAggregator) {\n        const values = aggregator.getResult(channel)?.value;\n        const ids = aggregator.getBins()?.value;\n        if (ids && values) {\n            return getCPUAggregatorValueReader(values, ids, aggregator.binCount);\n        }\n    }\n    return null;\n}\nfunction getWebGLAggregatorValueReader(values, binIdRange) {\n    const [[minX, maxX], [minY, maxY]] = binIdRange;\n    const width = maxX - minX;\n    const height = maxY - minY;\n    return (x, y) => {\n        x -= minX;\n        y -= minY;\n        if (x < 0 || x >= width || y < 0 || y >= height) {\n            return NaN;\n        }\n        return values[y * width + x];\n    };\n}\nfunction getCPUAggregatorValueReader(values, ids, count) {\n    const idMap = {};\n    for (let i = 0; i < count; i++) {\n        const x = ids[i * 2];\n        const y = ids[i * 2 + 1];\n        idMap[x] = idMap[x] || {};\n        idMap[x][y] = values[i];\n    }\n    return (x, y) => idMap[x]?.[y] ?? NaN;\n}\n//# sourceMappingURL=value-reader.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst uniformBlock = /* glsl */ `\\\nuniform binOptionsUniforms {\n  vec2 cellOriginCommon;\n  vec2 cellSizeCommon;\n} binOptions;\n`;\nexport const binOptionsUniforms = {\n    name: 'binOptions',\n    vs: uniformBlock,\n    uniformTypes: {\n        cellOriginCommon: 'vec2<f32>',\n        cellSizeCommon: 'vec2<f32>'\n    }\n};\n//# sourceMappingURL=bin-options-uniforms.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { COORDINATE_SYSTEM, project32, Viewport, _deepEqual } from '@deck.gl/core';\nimport { PathLayer, SolidPolygonLayer } from '@deck.gl/layers';\nimport { WebGLAggregator, CPUAggregator } from \"../common/aggregator/index.js\";\nimport AggregationLayer from \"../common/aggregation-layer.js\";\nimport { generateContours } from \"./contour-utils.js\";\nimport { getAggregatorValueReader } from \"./value-reader.js\";\nimport { getBinIdRange } from \"../common/utils/bounds-utils.js\";\nimport { Matrix4 } from '@math.gl/core';\nimport { binOptionsUniforms } from \"./bin-options-uniforms.js\";\nconst DEFAULT_COLOR = [255, 255, 255, 255];\nconst DEFAULT_STROKE_WIDTH = 1;\nconst defaultProps = {\n    // grid aggregation\n    cellSize: { type: 'number', min: 1, value: 1000 },\n    gridOrigin: { type: 'array', compare: true, value: [0, 0] },\n    getPosition: { type: 'accessor', value: (x) => x.position },\n    getWeight: { type: 'accessor', value: 1 },\n    gpuAggregation: true,\n    aggregation: 'SUM',\n    // contour lines\n    contours: {\n        type: 'object',\n        value: [{ threshold: 1 }],\n        optional: true,\n        compare: 3\n    },\n    zOffset: 0.005\n};\n/** Aggregate data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. */\nclass GridLayer extends AggregationLayer {\n    getAggregatorType() {\n        return this.props.gpuAggregation && WebGLAggregator.isSupported(this.context.device)\n            ? 'gpu'\n            : 'cpu';\n    }\n    createAggregator(type) {\n        if (type === 'cpu') {\n            return new CPUAggregator({\n                dimensions: 2,\n                getBin: {\n                    sources: ['positions'],\n                    getValue: ({ positions }, index, opts) => {\n                        const viewport = this.state.aggregatorViewport;\n                        // project to common space\n                        const p = viewport.projectPosition(positions);\n                        const { cellSizeCommon, cellOriginCommon } = opts;\n                        return [\n                            Math.floor((p[0] - cellOriginCommon[0]) / cellSizeCommon[0]),\n                            Math.floor((p[1] - cellOriginCommon[1]) / cellSizeCommon[1])\n                        ];\n                    }\n                },\n                getValue: [{ sources: ['counts'], getValue: ({ counts }) => counts }],\n                onUpdate: this._onAggregationUpdate.bind(this)\n            });\n        }\n        return new WebGLAggregator(this.context.device, {\n            dimensions: 2,\n            channelCount: 1,\n            bufferLayout: this.getAttributeManager().getBufferLayouts({ isInstanced: false }),\n            ...super.getShaders({\n                modules: [project32, binOptionsUniforms],\n                vs: /* glsl */ `\n  in vec3 positions;\n  in vec3 positions64Low;\n  in float counts;\n\n  void getBin(out ivec2 binId) {\n    vec3 positionCommon = project_position(positions, positions64Low);\n    vec2 gridCoords = floor(positionCommon.xy / binOptions.cellSizeCommon);\n    binId = ivec2(gridCoords);\n  }\n  void getValue(out float value) {\n    value = counts;\n  }\n  `\n            }),\n            onUpdate: this._onAggregationUpdate.bind(this)\n        });\n    }\n    initializeState() {\n        super.initializeState();\n        const attributeManager = this.getAttributeManager();\n        attributeManager.add({\n            positions: {\n                size: 3,\n                accessor: 'getPosition',\n                type: 'float64',\n                fp64: this.use64bitPositions()\n            },\n            counts: { size: 1, accessor: 'getWeight' }\n        });\n    }\n    updateState(params) {\n        const aggregatorChanged = super.updateState(params);\n        const { props, oldProps, changeFlags } = params;\n        const { aggregator } = this.state;\n        if (aggregatorChanged ||\n            changeFlags.dataChanged ||\n            props.cellSize !== oldProps.cellSize ||\n            !_deepEqual(props.gridOrigin, oldProps.gridOrigin, 1) ||\n            props.aggregation !== oldProps.aggregation) {\n            this._updateBinOptions();\n            const { cellSizeCommon, cellOriginCommon, binIdRange } = this.state;\n            aggregator.setProps({\n                // @ts-expect-error only used by GPUAggregator\n                binIdRange,\n                pointCount: this.getNumInstances(),\n                operations: [props.aggregation],\n                binOptions: {\n                    cellSizeCommon,\n                    cellOriginCommon\n                }\n            });\n        }\n        if (!_deepEqual(oldProps.contours, props.contours, 2)) {\n            // Recalculate contours\n            this.setState({ contourData: null });\n        }\n        return aggregatorChanged;\n    }\n    _updateBinOptions() {\n        const bounds = this.getBounds();\n        const cellSizeCommon = [1, 1];\n        let cellOriginCommon = [0, 0];\n        let binIdRange = [\n            [0, 1],\n            [0, 1]\n        ];\n        let viewport = this.context.viewport;\n        if (bounds && Number.isFinite(bounds[0][0])) {\n            let centroid = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];\n            const { cellSize, gridOrigin } = this.props;\n            const { unitsPerMeter } = viewport.getDistanceScales(centroid);\n            cellSizeCommon[0] = unitsPerMeter[0] * cellSize;\n            cellSizeCommon[1] = unitsPerMeter[1] * cellSize;\n            // Offset common space to center at the origin of the grid cell where the data center is in\n            // This improves precision without affecting the cell positions\n            const centroidCommon = viewport.projectFlat(centroid);\n            cellOriginCommon = [\n                Math.floor((centroidCommon[0] - gridOrigin[0]) / cellSizeCommon[0]) * cellSizeCommon[0] +\n                    gridOrigin[0],\n                Math.floor((centroidCommon[1] - gridOrigin[1]) / cellSizeCommon[1]) * cellSizeCommon[1] +\n                    gridOrigin[1]\n            ];\n            centroid = viewport.unprojectFlat(cellOriginCommon);\n            const ViewportType = viewport.constructor;\n            // We construct a viewport for the GPU aggregator's project module\n            // This viewport is determined by data\n            // removes arbitrary precision variance that depends on initial view state\n            viewport = viewport.isGeospatial\n                ? new ViewportType({ longitude: centroid[0], latitude: centroid[1], zoom: 12 })\n                : new Viewport({ position: [centroid[0], centroid[1], 0], zoom: 12 });\n            // Round to the nearest 32-bit float to match CPU and GPU results\n            cellOriginCommon = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1])];\n            binIdRange = getBinIdRange({\n                dataBounds: bounds,\n                getBinId: (p) => {\n                    const positionCommon = viewport.projectFlat(p);\n                    return [\n                        Math.floor((positionCommon[0] - cellOriginCommon[0]) / cellSizeCommon[0]),\n                        Math.floor((positionCommon[1] - cellOriginCommon[1]) / cellSizeCommon[1])\n                    ];\n                }\n            });\n        }\n        this.setState({ cellSizeCommon, cellOriginCommon, binIdRange, aggregatorViewport: viewport });\n    }\n    draw(opts) {\n        // Replaces render time viewport with our own\n        if (opts.shaderModuleProps.project) {\n            opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;\n        }\n        super.draw(opts);\n    }\n    _onAggregationUpdate() {\n        const { aggregator, binIdRange } = this.state;\n        this.setState({\n            aggregatedValueReader: getAggregatorValueReader({ aggregator, binIdRange, channel: 0 }),\n            contourData: null\n        });\n    }\n    _getContours() {\n        const { aggregatedValueReader } = this.state;\n        if (!aggregatedValueReader) {\n            return null;\n        }\n        if (!this.state.contourData) {\n            const { binIdRange } = this.state;\n            const { contours } = this.props;\n            const contourData = generateContours({\n                contours,\n                getValue: aggregatedValueReader,\n                xRange: binIdRange[0],\n                yRange: binIdRange[1]\n            });\n            this.state.contourData = contourData;\n        }\n        return this.state.contourData;\n    }\n    onAttributeChange(id) {\n        const { aggregator } = this.state;\n        switch (id) {\n            case 'positions':\n                aggregator.setNeedsUpdate();\n                this._updateBinOptions();\n                const { cellSizeCommon, cellOriginCommon, binIdRange } = this.state;\n                aggregator.setProps({\n                    // @ts-expect-error only used by GPUAggregator\n                    binIdRange,\n                    binOptions: {\n                        cellSizeCommon,\n                        cellOriginCommon\n                    }\n                });\n                break;\n            case 'counts':\n                aggregator.setNeedsUpdate(0);\n                break;\n            default:\n            // This should not happen\n        }\n    }\n    renderLayers() {\n        const contourData = this._getContours();\n        if (!contourData) {\n            return null;\n        }\n        const { lines, polygons } = contourData;\n        const { zOffset } = this.props;\n        const { cellOriginCommon, cellSizeCommon } = this.state;\n        const LinesSubLayerClass = this.getSubLayerClass('lines', PathLayer);\n        const BandsSubLayerClass = this.getSubLayerClass('bands', SolidPolygonLayer);\n        const modelMatrix = new Matrix4()\n            .translate([cellOriginCommon[0], cellOriginCommon[1], 0])\n            .scale([cellSizeCommon[0], cellSizeCommon[1], zOffset]);\n        // Contour lines layer\n        const lineLayer = lines &&\n            lines.length > 0 &&\n            new LinesSubLayerClass(this.getSubLayerProps({\n                id: 'lines'\n            }), {\n                data: lines,\n                coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,\n                modelMatrix,\n                getPath: d => d.vertices,\n                getColor: d => d.contour.color ?? DEFAULT_COLOR,\n                getWidth: d => d.contour.strokeWidth ?? DEFAULT_STROKE_WIDTH,\n                widthUnits: 'pixels'\n            });\n        // Contour bands layer\n        const bandsLayer = polygons &&\n            polygons.length > 0 &&\n            new BandsSubLayerClass(this.getSubLayerProps({\n                id: 'bands'\n            }), {\n                data: polygons,\n                coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,\n                modelMatrix,\n                getPolygon: d => d.vertices,\n                getFillColor: d => d.contour.color ?? DEFAULT_COLOR\n            });\n        return [lineLayer, bandsLayer];\n    }\n    getPickingInfo(params) {\n        const info = params.info;\n        const { object } = info;\n        if (object) {\n            info.object = {\n                contour: object.contour\n            };\n        }\n        return info;\n    }\n}\nGridLayer.layerName = 'ContourLayer';\nGridLayer.defaultProps = defaultProps;\nexport default GridLayer;\n//# sourceMappingURL=contour-layer.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport default /* glsl */ `#version 300 es\n#define SHADER_NAME grid-cell-layer-vertex-shader\nin vec3 positions;\nin vec3 normals;\nin vec2 instancePositions;\nin float instanceElevationValues;\nin float instanceColorValues;\nin vec3 instancePickingColors;\nuniform sampler2D colorRange;\nout vec4 vColor;\nfloat interp(float value, vec2 domain, vec2 range) {\nfloat r = min(max((value - domain.x) / (domain.y - domain.x), 0.), 1.);\nreturn mix(range.x, range.y, r);\n}\nvec4 interp(float value, vec2 domain, sampler2D range) {\nfloat r = (value - domain.x) / (domain.y - domain.x);\nreturn texture(range, vec2(r, 0.5));\n}\nvoid main(void) {\ngeometry.pickingColor = instancePickingColors;\nif (isnan(instanceColorValues) ||\ninstanceColorValues < grid.colorDomain.z ||\ninstanceColorValues > grid.colorDomain.w ||\ninstanceElevationValues < grid.elevationDomain.z ||\ninstanceElevationValues > grid.elevationDomain.w\n) {\ngl_Position = vec4(0.);\nreturn;\n}\nvec2 commonPosition = (instancePositions + (positions.xy + 1.0) / 2.0 * column.coverage) * grid.sizeCommon + grid.originCommon - project.commonOrigin.xy;\ngeometry.position = vec4(commonPosition, 0.0, 1.0);\ngeometry.normal = project_normal(normals);\nfloat elevation = 0.0;\nif (column.extruded) {\nelevation = interp(instanceElevationValues, grid.elevationDomain.xy, grid.elevationRange);\nelevation = project_size(elevation);\ngeometry.position.z = (positions.z + 1.0) / 2.0 * elevation;\n}\ngl_Position = project_common_position_to_clipspace(geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nvColor = interp(instanceColorValues, grid.colorDomain.xy, colorRange);\nvColor.a *= layer.opacity;\nif (column.extruded) {\nvColor.rgb = lighting_getLightColor(vColor.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);\n}\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n//# sourceMappingURL=grid-cell-layer-vertex.glsl.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst uniformBlock = /* glsl */ `\\\nuniform gridUniforms {\n  vec4 colorDomain;\n  vec4 elevationDomain;\n  vec2 elevationRange;\n  vec2 originCommon;\n  vec2 sizeCommon;\n} grid;\n`;\nexport const gridUniforms = {\n    name: 'grid',\n    vs: uniformBlock,\n    uniformTypes: {\n        colorDomain: 'vec4<f32>',\n        elevationDomain: 'vec4<f32>',\n        elevationRange: 'vec2<f32>',\n        originCommon: 'vec2<f32>',\n        sizeCommon: 'vec2<f32>'\n    }\n};\n//# sourceMappingURL=grid-layer-uniforms.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { ColumnLayer } from '@deck.gl/layers';\nimport { CubeGeometry } from '@luma.gl/engine';\nimport { createColorRangeTexture, updateColorRangeTexture } from \"../common/utils/color-utils.js\";\nimport vs from \"./grid-cell-layer-vertex.glsl.js\";\nimport { gridUniforms } from \"./grid-layer-uniforms.js\";\nexport class GridCellLayer extends ColumnLayer {\n    getShaders() {\n        const shaders = super.getShaders();\n        shaders.modules.push(gridUniforms);\n        return { ...shaders, vs };\n    }\n    initializeState() {\n        super.initializeState();\n        const attributeManager = this.getAttributeManager();\n        attributeManager.remove([\n            'instanceElevations',\n            'instanceFillColors',\n            'instanceLineColors',\n            'instanceStrokeWidths'\n        ]);\n        attributeManager.addInstanced({\n            instancePositions: {\n                size: 2,\n                type: 'float32',\n                accessor: 'getBin'\n            },\n            instanceColorValues: {\n                size: 1,\n                type: 'float32',\n                accessor: 'getColorValue'\n            },\n            instanceElevationValues: {\n                size: 1,\n                type: 'float32',\n                accessor: 'getElevationValue'\n            }\n        });\n    }\n    updateState(params) {\n        super.updateState(params);\n        const { props, oldProps } = params;\n        const model = this.state.fillModel;\n        if (oldProps.colorRange !== props.colorRange) {\n            this.state.colorTexture?.destroy();\n            this.state.colorTexture = createColorRangeTexture(this.context.device, props.colorRange, props.colorScaleType);\n            const gridProps = { colorRange: this.state.colorTexture };\n            model.shaderInputs.setProps({ grid: gridProps });\n        }\n        else if (oldProps.colorScaleType !== props.colorScaleType) {\n            updateColorRangeTexture(this.state.colorTexture, props.colorScaleType);\n        }\n    }\n    finalizeState(context) {\n        super.finalizeState(context);\n        this.state.colorTexture?.destroy();\n    }\n    _updateGeometry() {\n        const geometry = new CubeGeometry();\n        this.state.fillModel.setGeometry(geometry);\n    }\n    draw({ uniforms }) {\n        const { cellOriginCommon, cellSizeCommon, elevationRange, elevationScale, extruded, coverage, colorDomain, elevationDomain } = this.props;\n        const colorCutoff = this.props.colorCutoff || [-Infinity, Infinity];\n        const elevationCutoff = this.props.elevationCutoff || [-Infinity, Infinity];\n        const fillModel = this.state.fillModel;\n        const gridProps = {\n            colorDomain: [\n                Math.max(colorDomain[0], colorCutoff[0]), // instanceColorValue that maps to colorRange[0]\n                Math.min(colorDomain[1], colorCutoff[1]), // instanceColorValue that maps to colorRange[colorRange.length - 1]\n                Math.max(colorDomain[0] - 1, colorCutoff[0]), // hide cell if instanceColorValue is less than this\n                Math.min(colorDomain[1] + 1, colorCutoff[1]) // hide cell if instanceColorValue is greater than this\n            ],\n            elevationDomain: [\n                Math.max(elevationDomain[0], elevationCutoff[0]), // instanceElevationValue that maps to elevationRange[0]\n                Math.min(elevationDomain[1], elevationCutoff[1]), // instanceElevationValue that maps to elevationRange[elevationRange.length - 1]\n                Math.max(elevationDomain[0] - 1, elevationCutoff[0]), // hide cell if instanceElevationValue is less than this\n                Math.min(elevationDomain[1] + 1, elevationCutoff[1]) // hide cell if instanceElevationValue is greater than this\n            ],\n            elevationRange: [elevationRange[0] * elevationScale, elevationRange[1] * elevationScale],\n            originCommon: cellOriginCommon,\n            sizeCommon: cellSizeCommon\n        };\n        fillModel.shaderInputs.setProps({\n            column: { extruded, coverage },\n            grid: gridProps\n        });\n        fillModel.draw(this.context.renderPass);\n    }\n}\nGridCellLayer.layerName = 'GridCellLayer';\n//# sourceMappingURL=grid-cell-layer.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst uniformBlock = /* glsl */ `\\\nuniform binOptionsUniforms {\n  vec2 cellOriginCommon;\n  vec2 cellSizeCommon;\n} binOptions;\n`;\nexport const binOptionsUniforms = {\n    name: 'binOptions',\n    vs: uniformBlock,\n    uniformTypes: {\n        cellOriginCommon: 'vec2<f32>',\n        cellSizeCommon: 'vec2<f32>'\n    }\n};\n//# sourceMappingURL=bin-options-uniforms.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log, createIterable, project32, Viewport } from '@deck.gl/core';\nimport { WebGLAggregator, CPUAggregator } from \"../common/aggregator/index.js\";\nimport AggregationLayer from \"../common/aggregation-layer.js\";\nimport { defaultColorRange } from \"../common/utils/color-utils.js\";\nimport { AttributeWithScale } from \"../common/utils/scale-utils.js\";\nimport { getBinIdRange } from \"../common/utils/bounds-utils.js\";\nimport { GridCellLayer } from \"./grid-cell-layer.js\";\nimport { binOptionsUniforms } from \"./bin-options-uniforms.js\";\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() { }\nconst defaultProps = {\n    gpuAggregation: true,\n    // color\n    colorDomain: null,\n    colorRange: defaultColorRange,\n    getColorValue: { type: 'accessor', value: null }, // default value is calculated from `getColorWeight` and `colorAggregation`\n    getColorWeight: { type: 'accessor', value: 1 },\n    colorAggregation: 'SUM',\n    lowerPercentile: { type: 'number', min: 0, max: 100, value: 0 },\n    upperPercentile: { type: 'number', min: 0, max: 100, value: 100 },\n    colorScaleType: 'quantize',\n    onSetColorDomain: noop,\n    // elevation\n    elevationDomain: null,\n    elevationRange: [0, 1000],\n    getElevationValue: { type: 'accessor', value: null }, // default value is calculated from `getElevationWeight` and `elevationAggregation`\n    getElevationWeight: { type: 'accessor', value: 1 },\n    elevationAggregation: 'SUM',\n    elevationScale: { type: 'number', min: 0, value: 1 },\n    elevationLowerPercentile: { type: 'number', min: 0, max: 100, value: 0 },\n    elevationUpperPercentile: { type: 'number', min: 0, max: 100, value: 100 },\n    elevationScaleType: 'linear',\n    onSetElevationDomain: noop,\n    // grid\n    cellSize: { type: 'number', min: 0, value: 1000 },\n    coverage: { type: 'number', min: 0, max: 1, value: 1 },\n    getPosition: { type: 'accessor', value: (x) => x.position },\n    gridAggregator: { type: 'function', optional: true, value: null },\n    extruded: false,\n    // Optional material for 'lighting' shader module\n    material: true\n};\n/** Aggregate data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. */\nclass GridLayer extends AggregationLayer {\n    getAggregatorType() {\n        const { gpuAggregation, gridAggregator, getColorValue, getElevationValue } = this.props;\n        if (gpuAggregation && (gridAggregator || getColorValue || getElevationValue)) {\n            // If these features are desired by the app, the user should explicitly use CPU aggregation\n            log.warn('Features not supported by GPU aggregation, falling back to CPU')();\n            return 'cpu';\n        }\n        if (\n        // GPU aggregation is requested\n        gpuAggregation &&\n            // GPU aggregation is supported by the device\n            WebGLAggregator.isSupported(this.context.device)) {\n            return 'gpu';\n        }\n        return 'cpu';\n    }\n    createAggregator(type) {\n        if (type === 'cpu') {\n            const { gridAggregator, cellSize } = this.props;\n            return new CPUAggregator({\n                dimensions: 2,\n                getBin: {\n                    sources: ['positions'],\n                    getValue: ({ positions }, index, opts) => {\n                        if (gridAggregator) {\n                            return gridAggregator(positions, cellSize);\n                        }\n                        const viewport = this.state.aggregatorViewport;\n                        // project to common space\n                        const p = viewport.projectPosition(positions);\n                        const { cellSizeCommon, cellOriginCommon } = opts;\n                        return [\n                            Math.floor((p[0] - cellOriginCommon[0]) / cellSizeCommon[0]),\n                            Math.floor((p[1] - cellOriginCommon[1]) / cellSizeCommon[1])\n                        ];\n                    }\n                },\n                getValue: [\n                    { sources: ['colorWeights'], getValue: ({ colorWeights }) => colorWeights },\n                    { sources: ['elevationWeights'], getValue: ({ elevationWeights }) => elevationWeights }\n                ]\n            });\n        }\n        return new WebGLAggregator(this.context.device, {\n            dimensions: 2,\n            channelCount: 2,\n            bufferLayout: this.getAttributeManager().getBufferLayouts({ isInstanced: false }),\n            ...super.getShaders({\n                modules: [project32, binOptionsUniforms],\n                vs: /* glsl */ `\n  in vec3 positions;\n  in vec3 positions64Low;\n  in float colorWeights;\n  in float elevationWeights;\n\n  void getBin(out ivec2 binId) {\n    vec3 positionCommon = project_position(positions, positions64Low);\n    vec2 gridCoords = floor(positionCommon.xy / binOptions.cellSizeCommon);\n    binId = ivec2(gridCoords);\n  }\n  void getValue(out vec2 value) {\n    value = vec2(colorWeights, elevationWeights);\n  }\n  `\n            })\n        });\n    }\n    initializeState() {\n        super.initializeState();\n        const attributeManager = this.getAttributeManager();\n        attributeManager.add({\n            positions: {\n                size: 3,\n                accessor: 'getPosition',\n                type: 'float64',\n                fp64: this.use64bitPositions()\n            },\n            colorWeights: { size: 1, accessor: 'getColorWeight' },\n            elevationWeights: { size: 1, accessor: 'getElevationWeight' }\n        });\n    }\n    // eslint-disable-next-line complexity\n    updateState(params) {\n        const aggregatorChanged = super.updateState(params);\n        const { props, oldProps, changeFlags } = params;\n        const { aggregator } = this.state;\n        if ((changeFlags.dataChanged || !this.state.dataAsArray) &&\n            (props.getColorValue || props.getElevationValue)) {\n            // Convert data to array\n            this.state.dataAsArray = Array.from(createIterable(props.data).iterable);\n        }\n        if (aggregatorChanged ||\n            changeFlags.dataChanged ||\n            props.cellSize !== oldProps.cellSize ||\n            props.getColorValue !== oldProps.getColorValue ||\n            props.getElevationValue !== oldProps.getElevationValue ||\n            props.colorAggregation !== oldProps.colorAggregation ||\n            props.elevationAggregation !== oldProps.elevationAggregation) {\n            this._updateBinOptions();\n            const { cellSizeCommon, cellOriginCommon, binIdRange, dataAsArray } = this.state;\n            aggregator.setProps({\n                // @ts-expect-error only used by GPUAggregator\n                binIdRange,\n                pointCount: this.getNumInstances(),\n                operations: [props.colorAggregation, props.elevationAggregation],\n                binOptions: {\n                    cellSizeCommon,\n                    cellOriginCommon\n                },\n                onUpdate: this._onAggregationUpdate.bind(this)\n            });\n            if (dataAsArray) {\n                const { getColorValue, getElevationValue } = this.props;\n                aggregator.setProps({\n                    // @ts-expect-error only used by CPUAggregator\n                    customOperations: [\n                        getColorValue &&\n                            ((indices) => getColorValue(indices.map(i => dataAsArray[i]), { indices, data: props.data })),\n                        getElevationValue &&\n                            ((indices) => getElevationValue(indices.map(i => dataAsArray[i]), { indices, data: props.data }))\n                    ]\n                });\n            }\n        }\n        if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getColorValue) {\n            aggregator.setNeedsUpdate(0);\n        }\n        if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getElevationValue) {\n            aggregator.setNeedsUpdate(1);\n        }\n        return aggregatorChanged;\n    }\n    _updateBinOptions() {\n        const bounds = this.getBounds();\n        const cellSizeCommon = [1, 1];\n        let cellOriginCommon = [0, 0];\n        let binIdRange = [\n            [0, 1],\n            [0, 1]\n        ];\n        let viewport = this.context.viewport;\n        if (bounds && Number.isFinite(bounds[0][0])) {\n            let centroid = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];\n            const { cellSize } = this.props;\n            const { unitsPerMeter } = viewport.getDistanceScales(centroid);\n            cellSizeCommon[0] = unitsPerMeter[0] * cellSize;\n            cellSizeCommon[1] = unitsPerMeter[1] * cellSize;\n            // Offset common space to center at the origin of the grid cell where the data center is in\n            // This improves precision without affecting the cell positions\n            const centroidCommon = viewport.projectFlat(centroid);\n            cellOriginCommon = [\n                Math.floor(centroidCommon[0] / cellSizeCommon[0]) * cellSizeCommon[0],\n                Math.floor(centroidCommon[1] / cellSizeCommon[1]) * cellSizeCommon[1]\n            ];\n            centroid = viewport.unprojectFlat(cellOriginCommon);\n            const ViewportType = viewport.constructor;\n            // We construct a viewport for the GPU aggregator's project module\n            // This viewport is determined by data\n            // removes arbitrary precision variance that depends on initial view state\n            viewport = viewport.isGeospatial\n                ? new ViewportType({ longitude: centroid[0], latitude: centroid[1], zoom: 12 })\n                : new Viewport({ position: [centroid[0], centroid[1], 0], zoom: 12 });\n            // Round to the nearest 32-bit float to match CPU and GPU results\n            cellOriginCommon = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1])];\n            binIdRange = getBinIdRange({\n                dataBounds: bounds,\n                getBinId: (p) => {\n                    const positionCommon = viewport.projectFlat(p);\n                    return [\n                        Math.floor((positionCommon[0] - cellOriginCommon[0]) / cellSizeCommon[0]),\n                        Math.floor((positionCommon[1] - cellOriginCommon[1]) / cellSizeCommon[1])\n                    ];\n                }\n            });\n        }\n        this.setState({ cellSizeCommon, cellOriginCommon, binIdRange, aggregatorViewport: viewport });\n    }\n    draw(opts) {\n        // Replaces render time viewport with our own\n        if (opts.shaderModuleProps.project) {\n            opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;\n        }\n        super.draw(opts);\n    }\n    _onAggregationUpdate({ channel }) {\n        const props = this.getCurrentLayer().props;\n        const { aggregator } = this.state;\n        if (channel === 0) {\n            const result = aggregator.getResult(0);\n            this.setState({\n                colors: new AttributeWithScale(result, aggregator.binCount)\n            });\n            props.onSetColorDomain(aggregator.getResultDomain(0));\n        }\n        else if (channel === 1) {\n            const result = aggregator.getResult(1);\n            this.setState({\n                elevations: new AttributeWithScale(result, aggregator.binCount)\n            });\n            props.onSetElevationDomain(aggregator.getResultDomain(1));\n        }\n    }\n    onAttributeChange(id) {\n        const { aggregator } = this.state;\n        switch (id) {\n            case 'positions':\n                aggregator.setNeedsUpdate();\n                this._updateBinOptions();\n                const { cellSizeCommon, cellOriginCommon, binIdRange } = this.state;\n                aggregator.setProps({\n                    // @ts-expect-error only used by GPUAggregator\n                    binIdRange,\n                    binOptions: {\n                        cellSizeCommon,\n                        cellOriginCommon\n                    }\n                });\n                break;\n            case 'colorWeights':\n                aggregator.setNeedsUpdate(0);\n                break;\n            case 'elevationWeights':\n                aggregator.setNeedsUpdate(1);\n                break;\n            default:\n            // This should not happen\n        }\n    }\n    renderLayers() {\n        const { aggregator, cellOriginCommon, cellSizeCommon } = this.state;\n        const { elevationScale, colorRange, elevationRange, extruded, coverage, material, transitions, colorScaleType, lowerPercentile, upperPercentile, colorDomain, elevationScaleType, elevationLowerPercentile, elevationUpperPercentile, elevationDomain } = this.props;\n        const CellLayerClass = this.getSubLayerClass('cells', GridCellLayer);\n        const binAttribute = aggregator.getBins();\n        const colors = this.state.colors?.update({\n            scaleType: colorScaleType,\n            lowerPercentile,\n            upperPercentile\n        });\n        const elevations = this.state.elevations?.update({\n            scaleType: elevationScaleType,\n            lowerPercentile: elevationLowerPercentile,\n            upperPercentile: elevationUpperPercentile\n        });\n        if (!colors || !elevations) {\n            return null;\n        }\n        return new CellLayerClass(this.getSubLayerProps({\n            id: 'cells'\n        }), {\n            data: {\n                length: aggregator.binCount,\n                attributes: {\n                    getBin: binAttribute,\n                    getColorValue: colors.attribute,\n                    getElevationValue: elevations.attribute\n                }\n            },\n            // Data has changed shallowly, but we likely don't need to update the attributes\n            dataComparator: (data, oldData) => data.length === oldData.length,\n            updateTriggers: {\n                getBin: [binAttribute],\n                getColorValue: [colors.attribute],\n                getElevationValue: [elevations.attribute]\n            },\n            cellOriginCommon,\n            cellSizeCommon,\n            elevationScale,\n            colorRange,\n            colorScaleType,\n            elevationRange,\n            extruded,\n            coverage,\n            material,\n            colorDomain: colors.domain || colorDomain || aggregator.getResultDomain(0),\n            elevationDomain: elevations.domain || elevationDomain || aggregator.getResultDomain(1),\n            colorCutoff: colors.cutoff,\n            elevationCutoff: elevations.cutoff,\n            transitions: transitions && {\n                getFillColor: transitions.getColorValue || transitions.getColorWeight,\n                getElevation: transitions.getElevationValue || transitions.getElevationWeight\n            },\n            // Extensions are already handled by the GPUAggregator, do not pass it down\n            extensions: []\n        });\n    }\n    getPickingInfo(params) {\n        const info = params.info;\n        const { index } = info;\n        if (index >= 0) {\n            const bin = this.state.aggregator.getBin(index);\n            let object;\n            if (bin) {\n                object = {\n                    col: bin.id[0],\n                    row: bin.id[1],\n                    colorValue: bin.value[0],\n                    elevationValue: bin.value[1],\n                    count: bin.count\n                };\n                if (bin.pointIndices) {\n                    object.pointIndices = bin.pointIndices;\n                    object.points = Array.isArray(this.props.data)\n                        ? bin.pointIndices.map(i => this.props.data[i])\n                        : [];\n                }\n            }\n            info.object = object;\n        }\n        return info;\n    }\n}\nGridLayer.layerName = 'GridLayer';\nGridLayer.defaultProps = defaultProps;\nexport default GridLayer;\n//# sourceMappingURL=grid-layer.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport function getBounds(points) {\n    // Now build bounding box in world space (aligned to world coordiante system)\n    const x = points.map(p => p[0]);\n    const y = points.map(p => p[1]);\n    const xMin = Math.min.apply(null, x);\n    const xMax = Math.max.apply(null, x);\n    const yMin = Math.min.apply(null, y);\n    const yMax = Math.max.apply(null, y);\n    return [xMin, yMin, xMax, yMax];\n}\n// true if currentBounds contains targetBounds, false otherwise\nexport function boundsContain(currentBounds, targetBounds) {\n    if (targetBounds[0] >= currentBounds[0] &&\n        targetBounds[2] <= currentBounds[2] &&\n        targetBounds[1] >= currentBounds[1] &&\n        targetBounds[3] <= currentBounds[3]) {\n        return true;\n    }\n    return false;\n}\nconst scratchArray = new Float32Array(12);\n// For given rectangle bounds generates two triangles vertices that coverit completely\nexport function packVertices(points, dimensions = 2) {\n    let index = 0;\n    for (const point of points) {\n        for (let i = 0; i < dimensions; i++) {\n            scratchArray[index++] = point[i] || 0;\n        }\n    }\n    return scratchArray;\n}\n// Expands boundingBox:[xMin, yMin, xMax, yMax] to match aspect ratio of given width and height\nexport function scaleToAspectRatio(boundingBox, width, height) {\n    const [xMin, yMin, xMax, yMax] = boundingBox;\n    const currentWidth = xMax - xMin;\n    const currentHeight = yMax - yMin;\n    let newWidth = currentWidth;\n    let newHeight = currentHeight;\n    if (currentWidth / currentHeight < width / height) {\n        // expand bounding box width\n        newWidth = (width / height) * currentHeight;\n    }\n    else {\n        newHeight = (height / width) * currentWidth;\n    }\n    if (newWidth < width) {\n        newWidth = width;\n        newHeight = height;\n    }\n    const xCenter = (xMax + xMin) / 2;\n    const yCenter = (yMax + yMin) / 2;\n    return [\n        xCenter - newWidth / 2,\n        yCenter - newHeight / 2,\n        xCenter + newWidth / 2,\n        yCenter + newHeight / 2\n    ];\n}\n// Get texture coordiante of point inside a bounding box\nexport function getTextureCoordinates(point, bounds) {\n    const [xMin, yMin, xMax, yMax] = bounds;\n    return [(point[0] - xMin) / (xMax - xMin), (point[1] - yMin) / (yMax - yMin)];\n}\n//# sourceMappingURL=heatmap-layer-utils.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Inspired by screen-grid-layer vertex shader in deck.gl\nexport default `\\\n#version 300 es\n#define SHADER_NAME heatp-map-layer-vertex-shader\nuniform sampler2D maxTexture;\nin vec3 positions;\nin vec2 texCoords;\nout vec2 vTexCoords;\nout float vIntensityMin;\nout float vIntensityMax;\nvoid main(void) {\ngl_Position = project_position_to_clipspace(positions, vec3(0.0), vec3(0.0));\nvTexCoords = texCoords;\nvec4 maxTexture = texture(maxTexture, vec2(0.5));\nfloat maxValue = triangle.aggregationMode < 0.5 ? maxTexture.r : maxTexture.g;\nfloat minValue = maxValue * triangle.threshold;\nif (triangle.colorDomain[1] > 0.) {\nmaxValue = triangle.colorDomain[1];\nminValue = triangle.colorDomain[0];\n}\nvIntensityMax = triangle.intensity / maxValue;\nvIntensityMin = triangle.intensity / minValue;\n}\n`;\n//# sourceMappingURL=triangle-layer-vertex.glsl.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport default `\\\n#version 300 es\n#define SHADER_NAME triangle-layer-fragment-shader\nprecision highp float;\nuniform sampler2D weightsTexture;\nuniform sampler2D colorTexture;\nin vec2 vTexCoords;\nin float vIntensityMin;\nin float vIntensityMax;\nout vec4 fragColor;\nvec4 getLinearColor(float value) {\nfloat factor = clamp(value * vIntensityMax, 0., 1.);\nvec4 color = texture(colorTexture, vec2(factor, 0.5));\ncolor.a *= min(value * vIntensityMin, 1.0);\nreturn color;\n}\nvoid main(void) {\nvec4 weights = texture(weightsTexture, vTexCoords);\nfloat weight = weights.r;\nif (triangle.aggregationMode > 0.5) {\nweight /= max(1.0, weights.a);\n}\nif (weight <= 0.) {\ndiscard;\n}\nvec4 linearColor = getLinearColor(weight);\nlinearColor.a *= layer.opacity;\nfragColor = linearColor;\n}\n`;\n//# sourceMappingURL=triangle-layer-fragment.glsl.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst uniformBlock = `\\\nuniform triangleUniforms {\n  float aggregationMode;\n  vec2 colorDomain;\n  float intensity;\n  float threshold;\n} triangle;\n`;\nexport const triangleUniforms = {\n    name: 'triangle',\n    vs: uniformBlock,\n    fs: uniformBlock,\n    uniformTypes: {\n        aggregationMode: 'f32',\n        colorDomain: 'vec2<f32>',\n        intensity: 'f32',\n        threshold: 'f32'\n    }\n};\n//# sourceMappingURL=triangle-layer-uniforms.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Model } from '@luma.gl/engine';\nimport { Layer, project32 } from '@deck.gl/core';\nimport vs from \"./triangle-layer-vertex.glsl.js\";\nimport fs from \"./triangle-layer-fragment.glsl.js\";\nimport { triangleUniforms } from \"./triangle-layer-uniforms.js\";\nclass TriangleLayer extends Layer {\n    getShaders() {\n        return super.getShaders({ vs, fs, modules: [project32, triangleUniforms] });\n    }\n    initializeState({ device }) {\n        this.setState({ model: this._getModel(device) });\n    }\n    _getModel(device) {\n        const { vertexCount, data } = this.props;\n        return new Model(device, {\n            ...this.getShaders(),\n            id: this.props.id,\n            attributes: data.attributes,\n            bufferLayout: [\n                { name: 'positions', format: 'float32x3' },\n                { name: 'texCoords', format: 'float32x2' }\n            ],\n            topology: 'triangle-strip',\n            vertexCount\n        });\n    }\n    draw() {\n        const { model } = this.state;\n        const { aggregationMode, colorDomain, intensity, threshold, colorTexture, maxTexture, weightsTexture } = this.props;\n        const triangleProps = {\n            aggregationMode,\n            colorDomain,\n            intensity,\n            threshold,\n            colorTexture,\n            maxTexture,\n            weightsTexture\n        };\n        model.shaderInputs.setProps({ triangle: triangleProps });\n        model.draw(this.context.renderPass);\n    }\n}\nTriangleLayer.layerName = 'TriangleLayer';\nexport default TriangleLayer;\n//# sourceMappingURL=triangle-layer.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport function filterProps(props, filterKeys) {\n    const filteredProps = {};\n    for (const key in props) {\n        if (!filterKeys.includes(key)) {\n            filteredProps[key] = props[key];\n        }\n    }\n    return filteredProps;\n}\n//# sourceMappingURL=prop-utils.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { CompositeLayer, AttributeManager, _compareProps as compareProps } from '@deck.gl/core';\nimport { filterProps } from \"../common/utils/prop-utils.js\";\n/** Legacy AggregationLayer, to be removed in v9.1 */\nclass AggregationLayer extends CompositeLayer {\n    initializeAggregationLayer(dimensions) {\n        super.initializeState(this.context);\n        this.setState({\n            // Layer props , when changed doesn't require updating aggregation\n            ignoreProps: filterProps(this.constructor._propTypes, dimensions.data.props),\n            dimensions\n        });\n    }\n    updateState(opts) {\n        super.updateState(opts);\n        const { changeFlags } = opts;\n        if (changeFlags.extensionsChanged) {\n            const shaders = this.getShaders({});\n            if (shaders && shaders.defines) {\n                shaders.defines.NON_INSTANCED_MODEL = 1;\n            }\n            this.updateShaders(shaders);\n        }\n        // Explictly call to update attributes as 'CompositeLayer' doesn't call this\n        this._updateAttributes();\n    }\n    updateAttributes(changedAttributes) {\n        // Super classes, can refer to state.changedAttributes to determine what\n        // attributes changed\n        this.setState({ changedAttributes });\n    }\n    getAttributes() {\n        return this.getAttributeManager().getAttributes();\n    }\n    getModuleSettings() {\n        // For regular layer draw this happens during draw cycle (_drawLayersInViewport) not during update cycle\n        // For aggregation layers this is called during updateState to update aggregation data\n        // NOTE: it is similar to LayerPass._getShaderModuleProps() but doesn't inlcude `effects` it is not needed for aggregation\n        const { viewport, mousePosition, device } = this.context;\n        const moduleSettings = Object.assign(Object.create(this.props), {\n            viewport,\n            mousePosition,\n            picking: {\n                isActive: 0\n            },\n            // @ts-expect-error TODO - assuming WebGL context\n            devicePixelRatio: device.canvasContext.cssToDeviceRatio()\n        });\n        return moduleSettings;\n    }\n    updateShaders(shaders) {\n        // Default implemention is empty, subclasses can update their Model objects if needed\n    }\n    /**\n     * Checks if aggregation is dirty\n     * @param {Object} updateOpts - object {props, oldProps, changeFlags}\n     * @param {Object} params - object {dimension, compareAll}\n     * @param {Object} params.dimension - {props, accessors} array of props and/or accessors\n     * @param {Boolean} params.compareAll - when `true` it will include non layer props for comparision\n     * @returns {Boolean} - returns true if dimensions' prop or accessor is changed\n     **/\n    isAggregationDirty(updateOpts, params = {}) {\n        const { props, oldProps, changeFlags } = updateOpts;\n        const { compareAll = false, dimension } = params;\n        const { ignoreProps } = this.state;\n        const { props: dataProps, accessors = [] } = dimension;\n        const { updateTriggersChanged } = changeFlags;\n        if (changeFlags.dataChanged) {\n            return true;\n        }\n        if (updateTriggersChanged) {\n            if (updateTriggersChanged.all) {\n                return true;\n            }\n            for (const accessor of accessors) {\n                if (updateTriggersChanged[accessor]) {\n                    return true;\n                }\n            }\n        }\n        if (compareAll) {\n            if (changeFlags.extensionsChanged) {\n                return true;\n            }\n            // Compare non layer props too (like extension props)\n            // ignoreprops refers to all Layer props other than aggregation props that need to be comapred\n            return compareProps({\n                oldProps,\n                newProps: props,\n                ignoreProps,\n                propTypes: this.constructor._propTypes\n            });\n        }\n        // Compare props of the dimension\n        for (const name of dataProps) {\n            if (props[name] !== oldProps[name]) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Checks if an attribute is changed\n     * @param {String} name - name of the attribute\n     * @returns {Boolean} - `true` if attribute `name` is changed, `false` otherwise,\n     *                       If `name` is not passed or `undefiend`, `true` if any attribute is changed, `false` otherwise\n     **/\n    isAttributeChanged(name) {\n        const { changedAttributes } = this.state;\n        if (!name) {\n            // if name not specified return true if any attribute is changed\n            return !isObjectEmpty(changedAttributes);\n        }\n        return changedAttributes && changedAttributes[name] !== undefined;\n    }\n    // Private\n    // override Composite layer private method to create AttributeManager instance\n    _getAttributeManager() {\n        return new AttributeManager(this.context.device, {\n            id: this.props.id,\n            stats: this.context.stats\n        });\n    }\n}\nAggregationLayer.layerName = 'AggregationLayer';\nexport default AggregationLayer;\n// Helper methods\n// Returns true if given object is empty, false otherwise.\nfunction isObjectEmpty(obj) {\n    let isEmpty = true;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    for (const key in obj) {\n        isEmpty = false;\n        break;\n    }\n    return isEmpty;\n}\n//# sourceMappingURL=aggregation-layer.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport default `\\\n#version 300 es\nin vec3 positions;\nin vec3 positions64Low;\nin float weights;\nout vec4 weightsTexture;\nvoid main()\n{\nweightsTexture = vec4(weights * weight.weightsScale, 0., 0., 1.);\nfloat radiusTexels = project_pixel_size(weight.radiusPixels) * weight.textureWidth / (weight.commonBounds.z - weight.commonBounds.x);\ngl_PointSize = radiusTexels * 2.;\nvec3 commonPosition = project_position(positions, positions64Low);\ngl_Position.xy = (commonPosition.xy - weight.commonBounds.xy) / (weight.commonBounds.zw - weight.commonBounds.xy) ;\ngl_Position.xy = (gl_Position.xy * 2.) - (1.);\ngl_Position.w = 1.0;\n}\n`;\n//# sourceMappingURL=weights-vs.glsl.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport default `\\\n#version 300 es\nin vec4 weightsTexture;\nout vec4 fragColor;\nfloat gaussianKDE(float u){\nreturn pow(2.71828, -u*u/0.05555)/(1.77245385*0.166666);\n}\nvoid main()\n{\nfloat dist = length(gl_PointCoord - vec2(0.5, 0.5));\nif (dist > 0.5) {\ndiscard;\n}\nfragColor = weightsTexture * gaussianKDE(2. * dist);\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n`;\n//# sourceMappingURL=weights-fs.glsl.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport default `\\\n#version 300 es\nuniform sampler2D inTexture;\nout vec4 outTexture;\nvoid main()\n{\nint yIndex = gl_VertexID / int(maxWeight.textureSize);\nint xIndex = gl_VertexID - (yIndex * int(maxWeight.textureSize));\nvec2 uv = (0.5 + vec2(float(xIndex), float(yIndex))) / maxWeight.textureSize;\noutTexture = texture(inTexture, uv);\ngl_Position = vec4(0.0, 0.0, 0.0, 1.0);\ngl_PointSize = 1.0;\n}\n`;\n//# sourceMappingURL=max-vs.glsl.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport default `\\\n#version 300 es\nin vec4 outTexture;\nout vec4 fragColor;\nvoid main() {\nfragColor = outTexture;\nfragColor.g = outTexture.r / max(1.0, outTexture.a);\n}\n`;\n//# sourceMappingURL=max-fs.glsl.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst uniformBlock = `\\\nuniform weightUniforms {\n  vec4 commonBounds;\n  float radiusPixels;\n  float textureWidth;\n  float weightsScale;\n} weight;\n`;\nexport const weightUniforms = {\n    name: 'weight',\n    vs: uniformBlock,\n    uniformTypes: {\n        commonBounds: 'vec4<f32>',\n        radiusPixels: 'f32',\n        textureWidth: 'f32',\n        weightsScale: 'f32'\n    }\n};\nexport const maxWeightUniforms = {\n    name: 'maxWeight',\n    vs: `\\\nuniform maxWeightUniforms {\n  float textureSize;\n} maxWeight;\n`,\n    uniformTypes: {\n        textureSize: 'f32'\n    }\n};\n//# sourceMappingURL=heatmap-layer-uniforms.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/* global setTimeout clearTimeout */\nimport { getBounds, boundsContain, packVertices, scaleToAspectRatio, getTextureCoordinates } from \"./heatmap-layer-utils.js\";\nimport { TextureTransform } from '@luma.gl/engine';\nimport { AttributeManager, COORDINATE_SYSTEM, log, project32 } from '@deck.gl/core';\nimport TriangleLayer from \"./triangle-layer.js\";\nimport AggregationLayer from \"./aggregation-layer.js\";\nimport { defaultColorRange, colorRangeToFlatArray } from \"../common/utils/color-utils.js\";\nimport weightsVs from \"./weights-vs.glsl.js\";\nimport weightsFs from \"./weights-fs.glsl.js\";\nimport maxVs from \"./max-vs.glsl.js\";\nimport maxFs from \"./max-fs.glsl.js\";\nimport { maxWeightUniforms, weightUniforms } from \"./heatmap-layer-uniforms.js\";\nconst RESOLUTION = 2; // (number of common space pixels) / (number texels)\nconst TEXTURE_PROPS = {\n    format: 'rgba8unorm',\n    dimension: '2d',\n    width: 1,\n    height: 1,\n    sampler: {\n        minFilter: 'linear',\n        magFilter: 'linear',\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'clamp-to-edge'\n    }\n};\nconst DEFAULT_COLOR_DOMAIN = [0, 0];\nconst AGGREGATION_MODE = {\n    SUM: 0,\n    MEAN: 1\n};\nconst defaultProps = {\n    getPosition: { type: 'accessor', value: (x) => x.position },\n    getWeight: { type: 'accessor', value: 1 },\n    intensity: { type: 'number', min: 0, value: 1 },\n    radiusPixels: { type: 'number', min: 1, max: 100, value: 50 },\n    colorRange: defaultColorRange,\n    threshold: { type: 'number', min: 0, max: 1, value: 0.05 },\n    colorDomain: { type: 'array', value: null, optional: true },\n    // 'SUM' or 'MEAN'\n    aggregation: 'SUM',\n    weightsTextureSize: { type: 'number', min: 128, max: 2048, value: 2048 },\n    debounceTimeout: { type: 'number', min: 0, max: 1000, value: 500 }\n};\nconst FLOAT_TARGET_FEATURES = [\n    'float32-renderable-webgl', // ability to render to float texture\n    'texture-blend-float-webgl' // ability to blend when rendering to float texture\n];\nconst DIMENSIONS = {\n    data: {\n        props: ['radiusPixels']\n    }\n};\n/** Visualizes the spatial distribution of data. */\nclass HeatmapLayer extends AggregationLayer {\n    getShaders(shaders) {\n        let modules = [project32];\n        if (shaders.modules) {\n            modules = [...modules, ...shaders.modules];\n        }\n        return super.getShaders({ ...shaders, modules });\n    }\n    initializeState() {\n        super.initializeAggregationLayer(DIMENSIONS);\n        this.setState({ colorDomain: DEFAULT_COLOR_DOMAIN });\n        this._setupTextureParams();\n        this._setupAttributes();\n        this._setupResources();\n    }\n    shouldUpdateState({ changeFlags }) {\n        // Need to be updated when viewport changes\n        return changeFlags.somethingChanged;\n    }\n    /* eslint-disable max-statements,complexity */\n    updateState(opts) {\n        super.updateState(opts);\n        this._updateHeatmapState(opts);\n    }\n    _updateHeatmapState(opts) {\n        const { props, oldProps } = opts;\n        const changeFlags = this._getChangeFlags(opts);\n        if (changeFlags.dataChanged || changeFlags.viewportChanged) {\n            // if data is changed, do not debounce and immediately update the weight map\n            changeFlags.boundsChanged = this._updateBounds(changeFlags.dataChanged);\n            this._updateTextureRenderingBounds();\n        }\n        if (changeFlags.dataChanged || changeFlags.boundsChanged) {\n            // Update weight map immediately\n            clearTimeout(this.state.updateTimer);\n            this.setState({ isWeightMapDirty: true });\n            if (changeFlags.dataChanged) {\n                // Recreate weights transform if data changed, as buffer layout may have changed,\n                // happens when binary attibutes passed.\n                const weightsTransformShaders = this.getShaders({ vs: weightsVs, fs: weightsFs });\n                this._createWeightsTransform(weightsTransformShaders);\n            }\n        }\n        else if (changeFlags.viewportZoomChanged) {\n            // Update weight map when zoom stops\n            this._debouncedUpdateWeightmap();\n        }\n        if (props.colorRange !== oldProps.colorRange) {\n            this._updateColorTexture(opts);\n        }\n        if (this.state.isWeightMapDirty) {\n            this._updateWeightmap();\n        }\n        this.setState({ zoom: opts.context.viewport.zoom });\n    }\n    renderLayers() {\n        const { weightsTexture, triPositionBuffer, triTexCoordBuffer, maxWeightsTexture, colorTexture, colorDomain } = this.state;\n        const { updateTriggers, intensity, threshold, aggregation } = this.props;\n        const TriangleLayerClass = this.getSubLayerClass('triangle', TriangleLayer);\n        return new TriangleLayerClass(this.getSubLayerProps({\n            id: 'triangle-layer',\n            updateTriggers\n        }), {\n            // position buffer is filled with world coordinates generated from viewport.unproject\n            // i.e. LNGLAT if geospatial, CARTESIAN otherwise\n            coordinateSystem: COORDINATE_SYSTEM.DEFAULT,\n            data: {\n                attributes: {\n                    positions: triPositionBuffer,\n                    texCoords: triTexCoordBuffer\n                }\n            },\n            vertexCount: 4,\n            maxTexture: maxWeightsTexture,\n            colorTexture,\n            aggregationMode: AGGREGATION_MODE[aggregation] || 0,\n            weightsTexture,\n            intensity,\n            threshold,\n            colorDomain\n        });\n    }\n    finalizeState(context) {\n        super.finalizeState(context);\n        const { weightsTransform, weightsTexture, maxWeightTransform, maxWeightsTexture, triPositionBuffer, triTexCoordBuffer, colorTexture, updateTimer } = this.state;\n        weightsTransform?.destroy();\n        weightsTexture?.destroy();\n        maxWeightTransform?.destroy();\n        maxWeightsTexture?.destroy();\n        triPositionBuffer?.destroy();\n        triTexCoordBuffer?.destroy();\n        colorTexture?.destroy();\n        if (updateTimer) {\n            clearTimeout(updateTimer);\n        }\n    }\n    // PRIVATE\n    // override Composite layer private method to create AttributeManager instance\n    _getAttributeManager() {\n        return new AttributeManager(this.context.device, {\n            id: this.props.id,\n            stats: this.context.stats\n        });\n    }\n    _getChangeFlags(opts) {\n        const changeFlags = {};\n        const { dimensions } = this.state;\n        changeFlags.dataChanged =\n            (this.isAttributeChanged() && 'attribute changed') || // if any attribute is changed\n                (this.isAggregationDirty(opts, {\n                    compareAll: true,\n                    dimension: dimensions.data\n                }) &&\n                    'aggregation is dirty');\n        changeFlags.viewportChanged = opts.changeFlags.viewportChanged;\n        const { zoom } = this.state;\n        if (!opts.context.viewport || opts.context.viewport.zoom !== zoom) {\n            changeFlags.viewportZoomChanged = true;\n        }\n        return changeFlags;\n    }\n    _createTextures() {\n        const { textureSize, format } = this.state;\n        this.setState({\n            weightsTexture: this.context.device.createTexture({\n                ...TEXTURE_PROPS,\n                width: textureSize,\n                height: textureSize,\n                format\n            }),\n            maxWeightsTexture: this.context.device.createTexture({\n                ...TEXTURE_PROPS,\n                width: 1,\n                height: 1,\n                format\n            })\n        });\n    }\n    _setupAttributes() {\n        const attributeManager = this.getAttributeManager();\n        attributeManager.add({\n            positions: { size: 3, type: 'float64', accessor: 'getPosition' },\n            weights: { size: 1, accessor: 'getWeight' }\n        });\n        this.setState({ positionAttributeName: 'positions' });\n    }\n    _setupTextureParams() {\n        const { device } = this.context;\n        const { weightsTextureSize } = this.props;\n        const textureSize = Math.min(weightsTextureSize, device.limits.maxTextureDimension2D);\n        const floatTargetSupport = FLOAT_TARGET_FEATURES.every(feature => device.features.has(feature));\n        const format = floatTargetSupport ? 'rgba32float' : 'rgba8unorm';\n        const weightsScale = floatTargetSupport ? 1 : 1 / 255;\n        this.setState({ textureSize, format, weightsScale });\n        if (!floatTargetSupport) {\n            log.warn(`HeatmapLayer: ${this.id} rendering to float texture not supported, falling back to low precision format`)();\n        }\n    }\n    _createWeightsTransform(shaders) {\n        let { weightsTransform } = this.state;\n        const { weightsTexture } = this.state;\n        const attributeManager = this.getAttributeManager();\n        weightsTransform?.destroy();\n        weightsTransform = new TextureTransform(this.context.device, {\n            id: `${this.id}-weights-transform`,\n            bufferLayout: attributeManager.getBufferLayouts(),\n            vertexCount: 1,\n            targetTexture: weightsTexture,\n            parameters: {\n                depthWriteEnabled: false,\n                blendColorOperation: 'add',\n                blendColorSrcFactor: 'one',\n                blendColorDstFactor: 'one',\n                blendAlphaSrcFactor: 'one',\n                blendAlphaDstFactor: 'one'\n            },\n            topology: 'point-list',\n            ...shaders,\n            modules: [...shaders.modules, weightUniforms]\n        });\n        this.setState({ weightsTransform });\n    }\n    _setupResources() {\n        this._createTextures();\n        const { device } = this.context;\n        const { textureSize, weightsTexture, maxWeightsTexture } = this.state;\n        const weightsTransformShaders = this.getShaders({\n            vs: weightsVs,\n            fs: weightsFs\n        });\n        this._createWeightsTransform(weightsTransformShaders);\n        const maxWeightsTransformShaders = this.getShaders({\n            vs: maxVs,\n            fs: maxFs,\n            modules: [maxWeightUniforms]\n        });\n        const maxWeightTransform = new TextureTransform(device, {\n            id: `${this.id}-max-weights-transform`,\n            targetTexture: maxWeightsTexture,\n            ...maxWeightsTransformShaders,\n            vertexCount: textureSize * textureSize,\n            topology: 'point-list',\n            parameters: {\n                depthWriteEnabled: false,\n                blendColorOperation: 'max',\n                blendAlphaOperation: 'max',\n                blendColorSrcFactor: 'one',\n                blendColorDstFactor: 'one',\n                blendAlphaSrcFactor: 'one',\n                blendAlphaDstFactor: 'one'\n            }\n        });\n        const maxWeightProps = { inTexture: weightsTexture, textureSize };\n        maxWeightTransform.model.shaderInputs.setProps({\n            maxWeight: maxWeightProps\n        });\n        this.setState({\n            weightsTexture,\n            maxWeightsTexture,\n            maxWeightTransform,\n            zoom: null,\n            triPositionBuffer: device.createBuffer({ byteLength: 48 }),\n            triTexCoordBuffer: device.createBuffer({ byteLength: 48 })\n        });\n    }\n    // overwrite super class method to update transform model\n    updateShaders(shaderOptions) {\n        // shader params (modules, injects) changed, update model object\n        this._createWeightsTransform({\n            vs: weightsVs,\n            fs: weightsFs,\n            ...shaderOptions\n        });\n    }\n    _updateMaxWeightValue() {\n        const { maxWeightTransform } = this.state;\n        maxWeightTransform.run({\n            parameters: { viewport: [0, 0, 1, 1] },\n            clearColor: [0, 0, 0, 0]\n        });\n    }\n    // Computes world bounds area that needs to be processed for generate heatmap\n    _updateBounds(forceUpdate = false) {\n        const { viewport } = this.context;\n        // Unproject all 4 corners of the current screen coordinates into world coordinates (lng/lat)\n        // Takes care of viewport has non zero bearing/pitch (i.e axis not aligned with world coordiante system)\n        const viewportCorners = [\n            viewport.unproject([0, 0]),\n            viewport.unproject([viewport.width, 0]),\n            viewport.unproject([0, viewport.height]),\n            viewport.unproject([viewport.width, viewport.height])\n        ].map(p => p.map(Math.fround));\n        // #1: get world bounds for current viewport extends\n        const visibleWorldBounds = getBounds(viewportCorners); // TODO: Change to visible bounds\n        const newState = { visibleWorldBounds, viewportCorners };\n        let boundsChanged = false;\n        if (forceUpdate ||\n            !this.state.worldBounds ||\n            !boundsContain(this.state.worldBounds, visibleWorldBounds)) {\n            // #2 : convert world bounds to common (Flat) bounds\n            // #3 : extend common bounds to match aspect ratio with viewport\n            const scaledCommonBounds = this._worldToCommonBounds(visibleWorldBounds);\n            // #4 :convert aligned common bounds to world bounds\n            const worldBounds = this._commonToWorldBounds(scaledCommonBounds);\n            // Clip webmercator projection limits\n            if (this.props.coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n                worldBounds[1] = Math.max(worldBounds[1], -85.051129);\n                worldBounds[3] = Math.min(worldBounds[3], 85.051129);\n                worldBounds[0] = Math.max(worldBounds[0], -360);\n                worldBounds[2] = Math.min(worldBounds[2], 360);\n            }\n            // #5: now convert world bounds to common using Layer's coordiante system and origin\n            const normalizedCommonBounds = this._worldToCommonBounds(worldBounds);\n            newState.worldBounds = worldBounds;\n            newState.normalizedCommonBounds = normalizedCommonBounds;\n            boundsChanged = true;\n        }\n        this.setState(newState);\n        return boundsChanged;\n    }\n    _updateTextureRenderingBounds() {\n        // Just render visible portion of the texture\n        const { triPositionBuffer, triTexCoordBuffer, normalizedCommonBounds, viewportCorners } = this.state;\n        const { viewport } = this.context;\n        triPositionBuffer.write(packVertices(viewportCorners, 3));\n        const textureBounds = viewportCorners.map(p => getTextureCoordinates(viewport.projectPosition(p), normalizedCommonBounds));\n        triTexCoordBuffer.write(packVertices(textureBounds, 2));\n    }\n    _updateColorTexture(opts) {\n        const { colorRange } = opts.props;\n        let { colorTexture } = this.state;\n        const colors = colorRangeToFlatArray(colorRange, false, Uint8Array);\n        colorTexture?.destroy();\n        colorTexture = this.context.device.createTexture({\n            ...TEXTURE_PROPS,\n            data: colors,\n            width: colorRange.length,\n            height: 1\n        });\n        this.setState({ colorTexture });\n    }\n    _updateWeightmap() {\n        const { radiusPixels, colorDomain, aggregation } = this.props;\n        const { worldBounds, textureSize, weightsScale, weightsTexture } = this.state;\n        const weightsTransform = this.state.weightsTransform;\n        this.state.isWeightMapDirty = false;\n        // convert world bounds to common using Layer's coordiante system and origin\n        const commonBounds = this._worldToCommonBounds(worldBounds, {\n            useLayerCoordinateSystem: true\n        });\n        if (colorDomain && aggregation === 'SUM') {\n            // scale color domain to weight per pixel\n            const { viewport } = this.context;\n            const metersPerPixel = (viewport.distanceScales.metersPerUnit[2] * (commonBounds[2] - commonBounds[0])) /\n                textureSize;\n            this.state.colorDomain = colorDomain.map(x => x * metersPerPixel * weightsScale);\n        }\n        else {\n            this.state.colorDomain = colorDomain || DEFAULT_COLOR_DOMAIN;\n        }\n        const attributeManager = this.getAttributeManager();\n        const attributes = attributeManager.getAttributes();\n        const moduleSettings = this.getModuleSettings();\n        this._setModelAttributes(weightsTransform.model, attributes);\n        weightsTransform.model.setVertexCount(this.getNumInstances());\n        const weightProps = {\n            radiusPixels,\n            commonBounds,\n            textureWidth: textureSize,\n            weightsScale,\n            weightsTexture: weightsTexture\n        };\n        const { viewport, devicePixelRatio, coordinateSystem, coordinateOrigin } = moduleSettings;\n        const { modelMatrix } = this.props;\n        weightsTransform.model.shaderInputs.setProps({\n            project: { viewport, devicePixelRatio, modelMatrix, coordinateSystem, coordinateOrigin },\n            weight: weightProps\n        });\n        weightsTransform.run({\n            parameters: { viewport: [0, 0, textureSize, textureSize] },\n            clearColor: [0, 0, 0, 0]\n        });\n        this._updateMaxWeightValue();\n    }\n    _debouncedUpdateWeightmap(fromTimer = false) {\n        let { updateTimer } = this.state;\n        const { debounceTimeout } = this.props;\n        if (fromTimer) {\n            updateTimer = null;\n            // update\n            this._updateBounds(true);\n            this._updateTextureRenderingBounds();\n            this.setState({ isWeightMapDirty: true });\n        }\n        else {\n            this.setState({ isWeightMapDirty: false });\n            clearTimeout(updateTimer);\n            updateTimer = setTimeout(this._debouncedUpdateWeightmap.bind(this, true), debounceTimeout);\n        }\n        this.setState({ updateTimer });\n    }\n    // input: worldBounds: [minLong, minLat, maxLong, maxLat]\n    // input: opts.useLayerCoordinateSystem : layers coordiante system is used\n    // optput: commonBounds: [minX, minY, maxX, maxY] scaled to fit the current texture\n    _worldToCommonBounds(worldBounds, opts = {}) {\n        const { useLayerCoordinateSystem = false } = opts;\n        const [minLong, minLat, maxLong, maxLat] = worldBounds;\n        const { viewport } = this.context;\n        const { textureSize } = this.state;\n        const { coordinateSystem } = this.props;\n        const offsetMode = useLayerCoordinateSystem &&\n            (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS ||\n                coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS);\n        const offsetOriginCommon = offsetMode\n            ? viewport.projectPosition(this.props.coordinateOrigin)\n            : [0, 0];\n        const size = (textureSize * RESOLUTION) / viewport.scale;\n        let bottomLeftCommon;\n        let topRightCommon;\n        // Y-axis is flipped between World and Common bounds\n        if (useLayerCoordinateSystem && !offsetMode) {\n            bottomLeftCommon = this.projectPosition([minLong, minLat, 0]);\n            topRightCommon = this.projectPosition([maxLong, maxLat, 0]);\n        }\n        else {\n            bottomLeftCommon = viewport.projectPosition([minLong, minLat, 0]);\n            topRightCommon = viewport.projectPosition([maxLong, maxLat, 0]);\n        }\n        // Ignore z component\n        return scaleToAspectRatio([\n            bottomLeftCommon[0] - offsetOriginCommon[0],\n            bottomLeftCommon[1] - offsetOriginCommon[1],\n            topRightCommon[0] - offsetOriginCommon[0],\n            topRightCommon[1] - offsetOriginCommon[1]\n        ], size, size);\n    }\n    // input commonBounds: [xMin, yMin, xMax, yMax]\n    // output worldBounds: [minLong, minLat, maxLong, maxLat]\n    _commonToWorldBounds(commonBounds) {\n        const [xMin, yMin, xMax, yMax] = commonBounds;\n        const { viewport } = this.context;\n        const bottomLeftWorld = viewport.unprojectPosition([xMin, yMin]);\n        const topRightWorld = viewport.unprojectPosition([xMax, yMax]);\n        return bottomLeftWorld.slice(0, 2).concat(topRightWorld.slice(0, 2));\n    }\n}\nHeatmapLayer.layerName = 'HeatmapLayer';\nHeatmapLayer.defaultProps = defaultProps;\nexport default HeatmapLayer;\n//# sourceMappingURL=heatmap-layer.js.map"],"mappings":"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"}