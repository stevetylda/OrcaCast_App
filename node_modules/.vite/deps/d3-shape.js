//#region node_modules/d3-shape/src/constant.js
function constant_default(x$1) {
	return function constant() {
		return x$1;
	};
}

//#endregion
//#region node_modules/d3-shape/src/math.js
const abs = Math.abs;
const atan2 = Math.atan2;
const cos = Math.cos;
const max = Math.max;
const min = Math.min;
const sin = Math.sin;
const sqrt = Math.sqrt;
const epsilon = 1e-12;
const pi = Math.PI;
const halfPi = pi / 2;
const tau = 2 * pi;
function acos(x$1) {
	return x$1 > 1 ? 0 : x$1 < -1 ? pi : Math.acos(x$1);
}
function asin(x$1) {
	return x$1 >= 1 ? halfPi : x$1 <= -1 ? -halfPi : Math.asin(x$1);
}

//#endregion
//#region node_modules/d3-path/src/path.js
var pi$1 = Math.PI, tau$1 = 2 * pi$1, epsilon$1 = 1e-6, tauEpsilon = tau$1 - epsilon$1;
function append(strings) {
	this._ += strings[0];
	for (let i = 1, n = strings.length; i < n; ++i) this._ += arguments[i] + strings[i];
}
function appendRound(digits) {
	let d = Math.floor(digits);
	if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
	if (d > 15) return append;
	const k$1 = 10 ** d;
	return function(strings) {
		this._ += strings[0];
		for (let i = 1, n = strings.length; i < n; ++i) this._ += Math.round(arguments[i] * k$1) / k$1 + strings[i];
	};
}
var Path = class {
	constructor(digits) {
		this._x0 = this._y0 = this._x1 = this._y1 = null;
		this._ = "";
		this._append = digits == null ? append : appendRound(digits);
	}
	moveTo(x$1, y$1) {
		this._append`M${this._x0 = this._x1 = +x$1},${this._y0 = this._y1 = +y$1}`;
	}
	closePath() {
		if (this._x1 !== null) {
			this._x1 = this._x0, this._y1 = this._y0;
			this._append`Z`;
		}
	}
	lineTo(x$1, y$1) {
		this._append`L${this._x1 = +x$1},${this._y1 = +y$1}`;
	}
	quadraticCurveTo(x1, y1, x$1, y$1) {
		this._append`Q${+x1},${+y1},${this._x1 = +x$1},${this._y1 = +y$1}`;
	}
	bezierCurveTo(x1, y1, x2, y2, x$1, y$1) {
		this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x$1},${this._y1 = +y$1}`;
	}
	arcTo(x1, y1, x2, y2, r) {
		x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
		if (r < 0) throw new Error(`negative radius: ${r}`);
		let x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
		if (this._x1 === null) this._append`M${this._x1 = x1},${this._y1 = y1}`;
		else if (!(l01_2 > epsilon$1));
		else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$1) || !r) this._append`L${this._x1 = x1},${this._y1 = y1}`;
		else {
			let x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi$1 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
			if (Math.abs(t01 - 1) > epsilon$1) this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
			this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
		}
	}
	arc(x$1, y$1, r, a0, a1, ccw) {
		x$1 = +x$1, y$1 = +y$1, r = +r, ccw = !!ccw;
		if (r < 0) throw new Error(`negative radius: ${r}`);
		let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x$1 + dx, y0 = y$1 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
		if (this._x1 === null) this._append`M${x0},${y0}`;
		else if (Math.abs(this._x1 - x0) > epsilon$1 || Math.abs(this._y1 - y0) > epsilon$1) this._append`L${x0},${y0}`;
		if (!r) return;
		if (da < 0) da = da % tau$1 + tau$1;
		if (da > tauEpsilon) this._append`A${r},${r},0,1,${cw},${x$1 - dx},${y$1 - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
		else if (da > epsilon$1) this._append`A${r},${r},0,${+(da >= pi$1)},${cw},${this._x1 = x$1 + r * Math.cos(a1)},${this._y1 = y$1 + r * Math.sin(a1)}`;
	}
	rect(x$1, y$1, w, h) {
		this._append`M${this._x0 = this._x1 = +x$1},${this._y0 = this._y1 = +y$1}h${w = +w}v${+h}h${-w}Z`;
	}
	toString() {
		return this._;
	}
};
function path() {
	return new Path();
}
path.prototype = Path.prototype;

//#endregion
//#region node_modules/d3-shape/src/path.js
function withPath(shape) {
	let digits = 3;
	shape.digits = function(_) {
		if (!arguments.length) return digits;
		if (_ == null) digits = null;
		else {
			const d = Math.floor(_);
			if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
			digits = d;
		}
		return shape;
	};
	return () => new Path(digits);
}

//#endregion
//#region node_modules/d3-shape/src/arc.js
function arcInnerRadius(d) {
	return d.innerRadius;
}
function arcOuterRadius(d) {
	return d.outerRadius;
}
function arcStartAngle(d) {
	return d.startAngle;
}
function arcEndAngle(d) {
	return d.endAngle;
}
function arcPadAngle(d) {
	return d && d.padAngle;
}
function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
	var x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2, t = y32 * x10 - x32 * y10;
	if (t * t < epsilon) return;
	t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
	return [x0 + t * x10, y0 + t * y10];
}
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
	var x01 = x0 - x1, y01 = y0 - y1, lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
	if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
	return {
		cx: cx0,
		cy: cy0,
		x01: -ox,
		y01: -oy,
		x11: cx0 * (r1 / r - 1),
		y11: cy0 * (r1 / r - 1)
	};
}
function arc_default() {
	var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null, path$1 = withPath(arc);
	function arc() {
		var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs(a1 - a0), cw = a1 > a0;
		if (!context) context = buffer = path$1();
		if (r1 < r0) r = r1, r1 = r0, r0 = r;
		if (!(r1 > epsilon)) context.moveTo(0, 0);
		else if (da > tau - epsilon) {
			context.moveTo(r1 * cos(a0), r1 * sin(a0));
			context.arc(0, 0, r1, a0, a1, !cw);
			if (r0 > epsilon) {
				context.moveTo(r0 * cos(a1), r0 * sin(a1));
				context.arc(0, 0, r0, a1, a0, cw);
			}
		} else {
			var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t0, t1;
			if (rp > epsilon) {
				var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
				if ((da0 -= p0 * 2) > epsilon) p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;
				else da0 = 0, a00 = a10 = (a0 + a1) / 2;
				if ((da1 -= p1 * 2) > epsilon) p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
				else da1 = 0, a01 = a11 = (a0 + a1) / 2;
			}
			var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
			if (rc > epsilon) {
				var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x00 = r0 * cos(a00), y00 = r0 * sin(a00), oc;
				if (da < pi) if (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10)) {
					var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
					rc0 = min(rc, (r0 - lc) / (kc - 1));
					rc1 = min(rc, (r1 - lc) / (kc + 1));
				} else rc0 = rc1 = 0;
			}
			if (!(da1 > epsilon)) context.moveTo(x01, y01);
			else if (rc1 > epsilon) {
				t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
				t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
				context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);
				if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);
				else {
					context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
					context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
					context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
				}
			} else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
			if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);
			else if (rc0 > epsilon) {
				t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
				t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
				context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);
				if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);
				else {
					context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
					context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
					context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
				}
			} else context.arc(0, 0, r0, a10, a00, cw);
		}
		context.closePath();
		if (buffer) return context = null, buffer + "" || null;
	}
	arc.centroid = function() {
		var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a$1 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
		return [cos(a$1) * r, sin(a$1) * r];
	};
	arc.innerRadius = function(_) {
		return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant_default(+_), arc) : innerRadius;
	};
	arc.outerRadius = function(_) {
		return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant_default(+_), arc) : outerRadius;
	};
	arc.cornerRadius = function(_) {
		return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant_default(+_), arc) : cornerRadius;
	};
	arc.padRadius = function(_) {
		return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant_default(+_), arc) : padRadius;
	};
	arc.startAngle = function(_) {
		return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default(+_), arc) : startAngle;
	};
	arc.endAngle = function(_) {
		return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default(+_), arc) : endAngle;
	};
	arc.padAngle = function(_) {
		return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default(+_), arc) : padAngle;
	};
	arc.context = function(_) {
		return arguments.length ? (context = _ == null ? null : _, arc) : context;
	};
	return arc;
}

//#endregion
//#region node_modules/d3-shape/src/array.js
var slice = Array.prototype.slice;
function array_default(x$1) {
	return typeof x$1 === "object" && "length" in x$1 ? x$1 : Array.from(x$1);
}

//#endregion
//#region node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
	this._context = context;
}
Linear.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._point = 0;
	},
	lineEnd: function() {
		if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
		this._line = 1 - this._line;
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		switch (this._point) {
			case 0:
				this._point = 1;
				this._line ? this._context.lineTo(x$1, y$1) : this._context.moveTo(x$1, y$1);
				break;
			case 1: this._point = 2;
			default:
				this._context.lineTo(x$1, y$1);
				break;
		}
	}
};
function linear_default(context) {
	return new Linear(context);
}

//#endregion
//#region node_modules/d3-shape/src/point.js
function x(p) {
	return p[0];
}
function y(p) {
	return p[1];
}

//#endregion
//#region node_modules/d3-shape/src/line.js
function line_default(x$1, y$1) {
	var defined = constant_default(true), context = null, curve = linear_default, output = null, path$1 = withPath(line);
	x$1 = typeof x$1 === "function" ? x$1 : x$1 === void 0 ? x : constant_default(x$1);
	y$1 = typeof y$1 === "function" ? y$1 : y$1 === void 0 ? y : constant_default(y$1);
	function line(data) {
		var i, n = (data = array_default(data)).length, d, defined0 = false, buffer;
		if (context == null) output = curve(buffer = path$1());
		for (i = 0; i <= n; ++i) {
			if (!(i < n && defined(d = data[i], i, data)) === defined0) if (defined0 = !defined0) output.lineStart();
			else output.lineEnd();
			if (defined0) output.point(+x$1(d, i, data), +y$1(d, i, data));
		}
		if (buffer) return output = null, buffer + "" || null;
	}
	line.x = function(_) {
		return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant_default(+_), line) : x$1;
	};
	line.y = function(_) {
		return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant_default(+_), line) : y$1;
	};
	line.defined = function(_) {
		return arguments.length ? (defined = typeof _ === "function" ? _ : constant_default(!!_), line) : defined;
	};
	line.curve = function(_) {
		return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
	};
	line.context = function(_) {
		return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
	};
	return line;
}

//#endregion
//#region node_modules/d3-shape/src/area.js
function area_default(x0, y0, y1) {
	var x1 = null, defined = constant_default(true), context = null, curve = linear_default, output = null, path$1 = withPath(area);
	x0 = typeof x0 === "function" ? x0 : x0 === void 0 ? x : constant_default(+x0);
	y0 = typeof y0 === "function" ? y0 : y0 === void 0 ? constant_default(0) : constant_default(+y0);
	y1 = typeof y1 === "function" ? y1 : y1 === void 0 ? y : constant_default(+y1);
	function area(data) {
		var i, j, k$1, n = (data = array_default(data)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
		if (context == null) output = curve(buffer = path$1());
		for (i = 0; i <= n; ++i) {
			if (!(i < n && defined(d = data[i], i, data)) === defined0) if (defined0 = !defined0) {
				j = i;
				output.areaStart();
				output.lineStart();
			} else {
				output.lineEnd();
				output.lineStart();
				for (k$1 = i - 1; k$1 >= j; --k$1) output.point(x0z[k$1], y0z[k$1]);
				output.lineEnd();
				output.areaEnd();
			}
			if (defined0) {
				x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
				output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
			}
		}
		if (buffer) return output = null, buffer + "" || null;
	}
	function arealine() {
		return line_default().defined(defined).curve(curve).context(context);
	}
	area.x = function(_) {
		return arguments.length ? (x0 = typeof _ === "function" ? _ : constant_default(+_), x1 = null, area) : x0;
	};
	area.x0 = function(_) {
		return arguments.length ? (x0 = typeof _ === "function" ? _ : constant_default(+_), area) : x0;
	};
	area.x1 = function(_) {
		return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant_default(+_), area) : x1;
	};
	area.y = function(_) {
		return arguments.length ? (y0 = typeof _ === "function" ? _ : constant_default(+_), y1 = null, area) : y0;
	};
	area.y0 = function(_) {
		return arguments.length ? (y0 = typeof _ === "function" ? _ : constant_default(+_), area) : y0;
	};
	area.y1 = function(_) {
		return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant_default(+_), area) : y1;
	};
	area.lineX0 = area.lineY0 = function() {
		return arealine().x(x0).y(y0);
	};
	area.lineY1 = function() {
		return arealine().x(x0).y(y1);
	};
	area.lineX1 = function() {
		return arealine().x(x1).y(y0);
	};
	area.defined = function(_) {
		return arguments.length ? (defined = typeof _ === "function" ? _ : constant_default(!!_), area) : defined;
	};
	area.curve = function(_) {
		return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
	};
	area.context = function(_) {
		return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
	};
	return area;
}

//#endregion
//#region node_modules/d3-shape/src/descending.js
function descending_default$1(a$1, b) {
	return b < a$1 ? -1 : b > a$1 ? 1 : b >= a$1 ? 0 : NaN;
}

//#endregion
//#region node_modules/d3-shape/src/identity.js
function identity_default(d) {
	return d;
}

//#endregion
//#region node_modules/d3-shape/src/pie.js
function pie_default() {
	var value = identity_default, sortValues = descending_default$1, sort = null, startAngle = constant_default(0), endAngle = constant_default(tau), padAngle = constant_default(0);
	function pie(data) {
		var i, n = (data = array_default(data)).length, j, k$1, sum$1 = 0, index = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)), pa = p * (da < 0 ? -1 : 1), v;
		for (i = 0; i < n; ++i) if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) sum$1 += v;
		if (sortValues != null) index.sort(function(i$1, j$1) {
			return sortValues(arcs[i$1], arcs[j$1]);
		});
		else if (sort != null) index.sort(function(i$1, j$1) {
			return sort(data[i$1], data[j$1]);
		});
		for (i = 0, k$1 = sum$1 ? (da - n * pa) / sum$1 : 0; i < n; ++i, a0 = a1) j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k$1 : 0) + pa, arcs[j] = {
			data: data[j],
			index: i,
			value: v,
			startAngle: a0,
			endAngle: a1,
			padAngle: p
		};
		return arcs;
	}
	pie.value = function(_) {
		return arguments.length ? (value = typeof _ === "function" ? _ : constant_default(+_), pie) : value;
	};
	pie.sortValues = function(_) {
		return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
	};
	pie.sort = function(_) {
		return arguments.length ? (sort = _, sortValues = null, pie) : sort;
	};
	pie.startAngle = function(_) {
		return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default(+_), pie) : startAngle;
	};
	pie.endAngle = function(_) {
		return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default(+_), pie) : endAngle;
	};
	pie.padAngle = function(_) {
		return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default(+_), pie) : padAngle;
	};
	return pie;
}

//#endregion
//#region node_modules/d3-shape/src/curve/radial.js
var curveRadialLinear = curveRadial(linear_default);
function Radial(curve) {
	this._curve = curve;
}
Radial.prototype = {
	areaStart: function() {
		this._curve.areaStart();
	},
	areaEnd: function() {
		this._curve.areaEnd();
	},
	lineStart: function() {
		this._curve.lineStart();
	},
	lineEnd: function() {
		this._curve.lineEnd();
	},
	point: function(a$1, r) {
		this._curve.point(r * Math.sin(a$1), r * -Math.cos(a$1));
	}
};
function curveRadial(curve) {
	function radial(context) {
		return new Radial(curve(context));
	}
	radial._curve = curve;
	return radial;
}

//#endregion
//#region node_modules/d3-shape/src/lineRadial.js
function lineRadial(l) {
	var c$1 = l.curve;
	l.angle = l.x, delete l.x;
	l.radius = l.y, delete l.y;
	l.curve = function(_) {
		return arguments.length ? c$1(curveRadial(_)) : c$1()._curve;
	};
	return l;
}
function lineRadial_default() {
	return lineRadial(line_default().curve(curveRadialLinear));
}

//#endregion
//#region node_modules/d3-shape/src/areaRadial.js
function areaRadial_default() {
	var a$1 = area_default().curve(curveRadialLinear), c$1 = a$1.curve, x0 = a$1.lineX0, x1 = a$1.lineX1, y0 = a$1.lineY0, y1 = a$1.lineY1;
	a$1.angle = a$1.x, delete a$1.x;
	a$1.startAngle = a$1.x0, delete a$1.x0;
	a$1.endAngle = a$1.x1, delete a$1.x1;
	a$1.radius = a$1.y, delete a$1.y;
	a$1.innerRadius = a$1.y0, delete a$1.y0;
	a$1.outerRadius = a$1.y1, delete a$1.y1;
	a$1.lineStartAngle = function() {
		return lineRadial(x0());
	}, delete a$1.lineX0;
	a$1.lineEndAngle = function() {
		return lineRadial(x1());
	}, delete a$1.lineX1;
	a$1.lineInnerRadius = function() {
		return lineRadial(y0());
	}, delete a$1.lineY0;
	a$1.lineOuterRadius = function() {
		return lineRadial(y1());
	}, delete a$1.lineY1;
	a$1.curve = function(_) {
		return arguments.length ? c$1(curveRadial(_)) : c$1()._curve;
	};
	return a$1;
}

//#endregion
//#region node_modules/d3-shape/src/pointRadial.js
function pointRadial_default(x$1, y$1) {
	return [(y$1 = +y$1) * Math.cos(x$1 -= Math.PI / 2), y$1 * Math.sin(x$1)];
}

//#endregion
//#region node_modules/d3-shape/src/curve/bump.js
var Bump = class {
	constructor(context, x$1) {
		this._context = context;
		this._x = x$1;
	}
	areaStart() {
		this._line = 0;
	}
	areaEnd() {
		this._line = NaN;
	}
	lineStart() {
		this._point = 0;
	}
	lineEnd() {
		if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
		this._line = 1 - this._line;
	}
	point(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		switch (this._point) {
			case 0:
				this._point = 1;
				if (this._line) this._context.lineTo(x$1, y$1);
				else this._context.moveTo(x$1, y$1);
				break;
			case 1: this._point = 2;
			default:
				if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x$1) / 2, this._y0, this._x0, y$1, x$1, y$1);
				else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y$1) / 2, x$1, this._y0, x$1, y$1);
				break;
		}
		this._x0 = x$1, this._y0 = y$1;
	}
};
var BumpRadial = class {
	constructor(context) {
		this._context = context;
	}
	lineStart() {
		this._point = 0;
	}
	lineEnd() {}
	point(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		if (this._point === 0) this._point = 1;
		else {
			const p0 = pointRadial_default(this._x0, this._y0);
			const p1 = pointRadial_default(this._x0, this._y0 = (this._y0 + y$1) / 2);
			const p2 = pointRadial_default(x$1, this._y0);
			const p3 = pointRadial_default(x$1, y$1);
			this._context.moveTo(...p0);
			this._context.bezierCurveTo(...p1, ...p2, ...p3);
		}
		this._x0 = x$1, this._y0 = y$1;
	}
};
function bumpX(context) {
	return new Bump(context, true);
}
function bumpY(context) {
	return new Bump(context, false);
}
function bumpRadial(context) {
	return new BumpRadial(context);
}

//#endregion
//#region node_modules/d3-shape/src/link.js
function linkSource(d) {
	return d.source;
}
function linkTarget(d) {
	return d.target;
}
function link(curve) {
	let source = linkSource, target = linkTarget, x$1 = x, y$1 = y, context = null, output = null, path$1 = withPath(link$1);
	function link$1() {
		let buffer;
		const argv = slice.call(arguments);
		const s$1 = source.apply(this, argv);
		const t = target.apply(this, argv);
		if (context == null) output = curve(buffer = path$1());
		output.lineStart();
		argv[0] = s$1, output.point(+x$1.apply(this, argv), +y$1.apply(this, argv));
		argv[0] = t, output.point(+x$1.apply(this, argv), +y$1.apply(this, argv));
		output.lineEnd();
		if (buffer) return output = null, buffer + "" || null;
	}
	link$1.source = function(_) {
		return arguments.length ? (source = _, link$1) : source;
	};
	link$1.target = function(_) {
		return arguments.length ? (target = _, link$1) : target;
	};
	link$1.x = function(_) {
		return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant_default(+_), link$1) : x$1;
	};
	link$1.y = function(_) {
		return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant_default(+_), link$1) : y$1;
	};
	link$1.context = function(_) {
		return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), link$1) : context;
	};
	return link$1;
}
function linkHorizontal() {
	return link(bumpX);
}
function linkVertical() {
	return link(bumpY);
}
function linkRadial() {
	const l = link(bumpRadial);
	l.angle = l.x, delete l.x;
	l.radius = l.y, delete l.y;
	return l;
}

//#endregion
//#region node_modules/d3-shape/src/symbol/asterisk.js
var sqrt3$2 = sqrt(3);
var asterisk_default = { draw(context, size) {
	const r = sqrt(size + min(size / 28, .75)) * .59436;
	const t = r / 2;
	const u = t * sqrt3$2;
	context.moveTo(0, r);
	context.lineTo(0, -r);
	context.moveTo(-u, -t);
	context.lineTo(u, t);
	context.moveTo(-u, t);
	context.lineTo(u, -t);
} };

//#endregion
//#region node_modules/d3-shape/src/symbol/circle.js
var circle_default = { draw(context, size) {
	const r = sqrt(size / pi);
	context.moveTo(r, 0);
	context.arc(0, 0, r, 0, tau);
} };

//#endregion
//#region node_modules/d3-shape/src/symbol/cross.js
var cross_default = { draw(context, size) {
	const r = sqrt(size / 5) / 2;
	context.moveTo(-3 * r, -r);
	context.lineTo(-r, -r);
	context.lineTo(-r, -3 * r);
	context.lineTo(r, -3 * r);
	context.lineTo(r, -r);
	context.lineTo(3 * r, -r);
	context.lineTo(3 * r, r);
	context.lineTo(r, r);
	context.lineTo(r, 3 * r);
	context.lineTo(-r, 3 * r);
	context.lineTo(-r, r);
	context.lineTo(-3 * r, r);
	context.closePath();
} };

//#endregion
//#region node_modules/d3-shape/src/symbol/diamond.js
var tan30 = sqrt(1 / 3);
var tan30_2 = tan30 * 2;
var diamond_default = { draw(context, size) {
	const y$1 = sqrt(size / tan30_2);
	const x$1 = y$1 * tan30;
	context.moveTo(0, -y$1);
	context.lineTo(x$1, 0);
	context.lineTo(0, y$1);
	context.lineTo(-x$1, 0);
	context.closePath();
} };

//#endregion
//#region node_modules/d3-shape/src/symbol/diamond2.js
var diamond2_default = { draw(context, size) {
	const r = sqrt(size) * .62625;
	context.moveTo(0, -r);
	context.lineTo(r, 0);
	context.lineTo(0, r);
	context.lineTo(-r, 0);
	context.closePath();
} };

//#endregion
//#region node_modules/d3-shape/src/symbol/plus.js
var plus_default = { draw(context, size) {
	const r = sqrt(size - min(size / 7, 2)) * .87559;
	context.moveTo(-r, 0);
	context.lineTo(r, 0);
	context.moveTo(0, r);
	context.lineTo(0, -r);
} };

//#endregion
//#region node_modules/d3-shape/src/symbol/square.js
var square_default = { draw(context, size) {
	const w = sqrt(size);
	const x$1 = -w / 2;
	context.rect(x$1, x$1, w, w);
} };

//#endregion
//#region node_modules/d3-shape/src/symbol/square2.js
var square2_default = { draw(context, size) {
	const r = sqrt(size) * .4431;
	context.moveTo(r, r);
	context.lineTo(r, -r);
	context.lineTo(-r, -r);
	context.lineTo(-r, r);
	context.closePath();
} };

//#endregion
//#region node_modules/d3-shape/src/symbol/star.js
var ka = .8908130915292852;
var kr = sin(pi / 10) / sin(7 * pi / 10);
var kx = sin(tau / 10) * kr;
var ky = -cos(tau / 10) * kr;
var star_default = { draw(context, size) {
	const r = sqrt(size * ka);
	const x$1 = kx * r;
	const y$1 = ky * r;
	context.moveTo(0, -r);
	context.lineTo(x$1, y$1);
	for (let i = 1; i < 5; ++i) {
		const a$1 = tau * i / 5;
		const c$1 = cos(a$1);
		const s$1 = sin(a$1);
		context.lineTo(s$1 * r, -c$1 * r);
		context.lineTo(c$1 * x$1 - s$1 * y$1, s$1 * x$1 + c$1 * y$1);
	}
	context.closePath();
} };

//#endregion
//#region node_modules/d3-shape/src/symbol/triangle.js
var sqrt3$1 = sqrt(3);
var triangle_default = { draw(context, size) {
	const y$1 = -sqrt(size / (sqrt3$1 * 3));
	context.moveTo(0, y$1 * 2);
	context.lineTo(-sqrt3$1 * y$1, -y$1);
	context.lineTo(sqrt3$1 * y$1, -y$1);
	context.closePath();
} };

//#endregion
//#region node_modules/d3-shape/src/symbol/triangle2.js
var sqrt3 = sqrt(3);
var triangle2_default = { draw(context, size) {
	const s$1 = sqrt(size) * .6824;
	const t = s$1 / 2;
	const u = s$1 * sqrt3 / 2;
	context.moveTo(0, -s$1);
	context.lineTo(u, t);
	context.lineTo(-u, t);
	context.closePath();
} };

//#endregion
//#region node_modules/d3-shape/src/symbol/wye.js
var c = -.5;
var s = sqrt(3) / 2;
var k = 1 / sqrt(12);
var a = (k / 2 + 1) * 3;
var wye_default = { draw(context, size) {
	const r = sqrt(size / a);
	const x0 = r / 2, y0 = r * k;
	const x1 = x0, y1 = r * k + r;
	const x2 = -x1, y2 = y1;
	context.moveTo(x0, y0);
	context.lineTo(x1, y1);
	context.lineTo(x2, y2);
	context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
	context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
	context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
	context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
	context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
	context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
	context.closePath();
} };

//#endregion
//#region node_modules/d3-shape/src/symbol/times.js
var times_default = { draw(context, size) {
	const r = sqrt(size - min(size / 6, 1.7)) * .6189;
	context.moveTo(-r, -r);
	context.lineTo(r, r);
	context.moveTo(-r, r);
	context.lineTo(r, -r);
} };

//#endregion
//#region node_modules/d3-shape/src/symbol.js
const symbolsFill = [
	circle_default,
	cross_default,
	diamond_default,
	square_default,
	star_default,
	triangle_default,
	wye_default
];
const symbolsStroke = [
	circle_default,
	plus_default,
	times_default,
	triangle2_default,
	asterisk_default,
	square2_default,
	diamond2_default
];
function Symbol(type, size) {
	let context = null, path$1 = withPath(symbol);
	type = typeof type === "function" ? type : constant_default(type || circle_default);
	size = typeof size === "function" ? size : constant_default(size === void 0 ? 64 : +size);
	function symbol() {
		let buffer;
		if (!context) context = buffer = path$1();
		type.apply(this, arguments).draw(context, +size.apply(this, arguments));
		if (buffer) return context = null, buffer + "" || null;
	}
	symbol.type = function(_) {
		return arguments.length ? (type = typeof _ === "function" ? _ : constant_default(_), symbol) : type;
	};
	symbol.size = function(_) {
		return arguments.length ? (size = typeof _ === "function" ? _ : constant_default(+_), symbol) : size;
	};
	symbol.context = function(_) {
		return arguments.length ? (context = _ == null ? null : _, symbol) : context;
	};
	return symbol;
}

//#endregion
//#region node_modules/d3-shape/src/noop.js
function noop_default() {}

//#endregion
//#region node_modules/d3-shape/src/curve/basis.js
function point$3(that, x$1, y$1) {
	that._context.bezierCurveTo((2 * that._x0 + that._x1) / 3, (2 * that._y0 + that._y1) / 3, (that._x0 + 2 * that._x1) / 3, (that._y0 + 2 * that._y1) / 3, (that._x0 + 4 * that._x1 + x$1) / 6, (that._y0 + 4 * that._y1 + y$1) / 6);
}
function Basis(context) {
	this._context = context;
}
Basis.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._x0 = this._x1 = this._y0 = this._y1 = NaN;
		this._point = 0;
	},
	lineEnd: function() {
		switch (this._point) {
			case 3: point$3(this, this._x1, this._y1);
			case 2:
				this._context.lineTo(this._x1, this._y1);
				break;
		}
		if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
		this._line = 1 - this._line;
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		switch (this._point) {
			case 0:
				this._point = 1;
				this._line ? this._context.lineTo(x$1, y$1) : this._context.moveTo(x$1, y$1);
				break;
			case 1:
				this._point = 2;
				break;
			case 2:
				this._point = 3;
				this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
			default:
				point$3(this, x$1, y$1);
				break;
		}
		this._x0 = this._x1, this._x1 = x$1;
		this._y0 = this._y1, this._y1 = y$1;
	}
};
function basis_default(context) {
	return new Basis(context);
}

//#endregion
//#region node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context) {
	this._context = context;
}
BasisClosed.prototype = {
	areaStart: noop_default,
	areaEnd: noop_default,
	lineStart: function() {
		this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
		this._point = 0;
	},
	lineEnd: function() {
		switch (this._point) {
			case 1:
				this._context.moveTo(this._x2, this._y2);
				this._context.closePath();
				break;
			case 2:
				this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
				this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
				this._context.closePath();
				break;
			case 3:
				this.point(this._x2, this._y2);
				this.point(this._x3, this._y3);
				this.point(this._x4, this._y4);
				break;
		}
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		switch (this._point) {
			case 0:
				this._point = 1;
				this._x2 = x$1, this._y2 = y$1;
				break;
			case 1:
				this._point = 2;
				this._x3 = x$1, this._y3 = y$1;
				break;
			case 2:
				this._point = 3;
				this._x4 = x$1, this._y4 = y$1;
				this._context.moveTo((this._x0 + 4 * this._x1 + x$1) / 6, (this._y0 + 4 * this._y1 + y$1) / 6);
				break;
			default:
				point$3(this, x$1, y$1);
				break;
		}
		this._x0 = this._x1, this._x1 = x$1;
		this._y0 = this._y1, this._y1 = y$1;
	}
};
function basisClosed_default(context) {
	return new BasisClosed(context);
}

//#endregion
//#region node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context) {
	this._context = context;
}
BasisOpen.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._x0 = this._x1 = this._y0 = this._y1 = NaN;
		this._point = 0;
	},
	lineEnd: function() {
		if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
		this._line = 1 - this._line;
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		switch (this._point) {
			case 0:
				this._point = 1;
				break;
			case 1:
				this._point = 2;
				break;
			case 2:
				this._point = 3;
				var x0 = (this._x0 + 4 * this._x1 + x$1) / 6, y0 = (this._y0 + 4 * this._y1 + y$1) / 6;
				this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
				break;
			case 3: this._point = 4;
			default:
				point$3(this, x$1, y$1);
				break;
		}
		this._x0 = this._x1, this._x1 = x$1;
		this._y0 = this._y1, this._y1 = y$1;
	}
};
function basisOpen_default(context) {
	return new BasisOpen(context);
}

//#endregion
//#region node_modules/d3-shape/src/curve/bundle.js
function Bundle(context, beta) {
	this._basis = new Basis(context);
	this._beta = beta;
}
Bundle.prototype = {
	lineStart: function() {
		this._x = [];
		this._y = [];
		this._basis.lineStart();
	},
	lineEnd: function() {
		var x$1 = this._x, y$1 = this._y, j = x$1.length - 1;
		if (j > 0) {
			var x0 = x$1[0], y0 = y$1[0], dx = x$1[j] - x0, dy = y$1[j] - y0, i = -1, t;
			while (++i <= j) {
				t = i / j;
				this._basis.point(this._beta * x$1[i] + (1 - this._beta) * (x0 + t * dx), this._beta * y$1[i] + (1 - this._beta) * (y0 + t * dy));
			}
		}
		this._x = this._y = null;
		this._basis.lineEnd();
	},
	point: function(x$1, y$1) {
		this._x.push(+x$1);
		this._y.push(+y$1);
	}
};
var bundle_default = (function custom(beta) {
	function bundle(context) {
		return beta === 1 ? new Basis(context) : new Bundle(context, beta);
	}
	bundle.beta = function(beta$1) {
		return custom(+beta$1);
	};
	return bundle;
})(.85);

//#endregion
//#region node_modules/d3-shape/src/curve/cardinal.js
function point$2(that, x$1, y$1) {
	that._context.bezierCurveTo(that._x1 + that._k * (that._x2 - that._x0), that._y1 + that._k * (that._y2 - that._y0), that._x2 + that._k * (that._x1 - x$1), that._y2 + that._k * (that._y1 - y$1), that._x2, that._y2);
}
function Cardinal(context, tension) {
	this._context = context;
	this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
		this._point = 0;
	},
	lineEnd: function() {
		switch (this._point) {
			case 2:
				this._context.lineTo(this._x2, this._y2);
				break;
			case 3:
				point$2(this, this._x1, this._y1);
				break;
		}
		if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
		this._line = 1 - this._line;
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		switch (this._point) {
			case 0:
				this._point = 1;
				this._line ? this._context.lineTo(x$1, y$1) : this._context.moveTo(x$1, y$1);
				break;
			case 1:
				this._point = 2;
				this._x1 = x$1, this._y1 = y$1;
				break;
			case 2: this._point = 3;
			default:
				point$2(this, x$1, y$1);
				break;
		}
		this._x0 = this._x1, this._x1 = this._x2, this._x2 = x$1;
		this._y0 = this._y1, this._y1 = this._y2, this._y2 = y$1;
	}
};
var cardinal_default = (function custom(tension) {
	function cardinal(context) {
		return new Cardinal(context, tension);
	}
	cardinal.tension = function(tension$1) {
		return custom(+tension$1);
	};
	return cardinal;
})(0);

//#endregion
//#region node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context, tension) {
	this._context = context;
	this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
	areaStart: noop_default,
	areaEnd: noop_default,
	lineStart: function() {
		this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
		this._point = 0;
	},
	lineEnd: function() {
		switch (this._point) {
			case 1:
				this._context.moveTo(this._x3, this._y3);
				this._context.closePath();
				break;
			case 2:
				this._context.lineTo(this._x3, this._y3);
				this._context.closePath();
				break;
			case 3:
				this.point(this._x3, this._y3);
				this.point(this._x4, this._y4);
				this.point(this._x5, this._y5);
				break;
		}
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		switch (this._point) {
			case 0:
				this._point = 1;
				this._x3 = x$1, this._y3 = y$1;
				break;
			case 1:
				this._point = 2;
				this._context.moveTo(this._x4 = x$1, this._y4 = y$1);
				break;
			case 2:
				this._point = 3;
				this._x5 = x$1, this._y5 = y$1;
				break;
			default:
				point$2(this, x$1, y$1);
				break;
		}
		this._x0 = this._x1, this._x1 = this._x2, this._x2 = x$1;
		this._y0 = this._y1, this._y1 = this._y2, this._y2 = y$1;
	}
};
var cardinalClosed_default = (function custom(tension) {
	function cardinal(context) {
		return new CardinalClosed(context, tension);
	}
	cardinal.tension = function(tension$1) {
		return custom(+tension$1);
	};
	return cardinal;
})(0);

//#endregion
//#region node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context, tension) {
	this._context = context;
	this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
		this._point = 0;
	},
	lineEnd: function() {
		if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
		this._line = 1 - this._line;
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		switch (this._point) {
			case 0:
				this._point = 1;
				break;
			case 1:
				this._point = 2;
				break;
			case 2:
				this._point = 3;
				this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
				break;
			case 3: this._point = 4;
			default:
				point$2(this, x$1, y$1);
				break;
		}
		this._x0 = this._x1, this._x1 = this._x2, this._x2 = x$1;
		this._y0 = this._y1, this._y1 = this._y2, this._y2 = y$1;
	}
};
var cardinalOpen_default = (function custom(tension) {
	function cardinal(context) {
		return new CardinalOpen(context, tension);
	}
	cardinal.tension = function(tension$1) {
		return custom(+tension$1);
	};
	return cardinal;
})(0);

//#endregion
//#region node_modules/d3-shape/src/curve/catmullRom.js
function point$1(that, x$1, y$1) {
	var x1 = that._x1, y1 = that._y1, x2 = that._x2, y2 = that._y2;
	if (that._l01_a > epsilon) {
		var a$1 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
		x1 = (x1 * a$1 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
		y1 = (y1 * a$1 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
	}
	if (that._l23_a > epsilon) {
		var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m = 3 * that._l23_a * (that._l23_a + that._l12_a);
		x2 = (x2 * b + that._x1 * that._l23_2a - x$1 * that._l12_2a) / m;
		y2 = (y2 * b + that._y1 * that._l23_2a - y$1 * that._l12_2a) / m;
	}
	that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
	this._context = context;
	this._alpha = alpha;
}
CatmullRom.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
		this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
	},
	lineEnd: function() {
		switch (this._point) {
			case 2:
				this._context.lineTo(this._x2, this._y2);
				break;
			case 3:
				this.point(this._x2, this._y2);
				break;
		}
		if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
		this._line = 1 - this._line;
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		if (this._point) {
			var x23 = this._x2 - x$1, y23 = this._y2 - y$1;
			this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
		}
		switch (this._point) {
			case 0:
				this._point = 1;
				this._line ? this._context.lineTo(x$1, y$1) : this._context.moveTo(x$1, y$1);
				break;
			case 1:
				this._point = 2;
				break;
			case 2: this._point = 3;
			default:
				point$1(this, x$1, y$1);
				break;
		}
		this._l01_a = this._l12_a, this._l12_a = this._l23_a;
		this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
		this._x0 = this._x1, this._x1 = this._x2, this._x2 = x$1;
		this._y0 = this._y1, this._y1 = this._y2, this._y2 = y$1;
	}
};
var catmullRom_default = (function custom(alpha) {
	function catmullRom(context) {
		return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
	}
	catmullRom.alpha = function(alpha$1) {
		return custom(+alpha$1);
	};
	return catmullRom;
})(.5);

//#endregion
//#region node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context, alpha) {
	this._context = context;
	this._alpha = alpha;
}
CatmullRomClosed.prototype = {
	areaStart: noop_default,
	areaEnd: noop_default,
	lineStart: function() {
		this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
		this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
	},
	lineEnd: function() {
		switch (this._point) {
			case 1:
				this._context.moveTo(this._x3, this._y3);
				this._context.closePath();
				break;
			case 2:
				this._context.lineTo(this._x3, this._y3);
				this._context.closePath();
				break;
			case 3:
				this.point(this._x3, this._y3);
				this.point(this._x4, this._y4);
				this.point(this._x5, this._y5);
				break;
		}
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		if (this._point) {
			var x23 = this._x2 - x$1, y23 = this._y2 - y$1;
			this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
		}
		switch (this._point) {
			case 0:
				this._point = 1;
				this._x3 = x$1, this._y3 = y$1;
				break;
			case 1:
				this._point = 2;
				this._context.moveTo(this._x4 = x$1, this._y4 = y$1);
				break;
			case 2:
				this._point = 3;
				this._x5 = x$1, this._y5 = y$1;
				break;
			default:
				point$1(this, x$1, y$1);
				break;
		}
		this._l01_a = this._l12_a, this._l12_a = this._l23_a;
		this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
		this._x0 = this._x1, this._x1 = this._x2, this._x2 = x$1;
		this._y0 = this._y1, this._y1 = this._y2, this._y2 = y$1;
	}
};
var catmullRomClosed_default = (function custom(alpha) {
	function catmullRom(context) {
		return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
	}
	catmullRom.alpha = function(alpha$1) {
		return custom(+alpha$1);
	};
	return catmullRom;
})(.5);

//#endregion
//#region node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context, alpha) {
	this._context = context;
	this._alpha = alpha;
}
CatmullRomOpen.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
		this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
	},
	lineEnd: function() {
		if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
		this._line = 1 - this._line;
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		if (this._point) {
			var x23 = this._x2 - x$1, y23 = this._y2 - y$1;
			this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
		}
		switch (this._point) {
			case 0:
				this._point = 1;
				break;
			case 1:
				this._point = 2;
				break;
			case 2:
				this._point = 3;
				this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
				break;
			case 3: this._point = 4;
			default:
				point$1(this, x$1, y$1);
				break;
		}
		this._l01_a = this._l12_a, this._l12_a = this._l23_a;
		this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
		this._x0 = this._x1, this._x1 = this._x2, this._x2 = x$1;
		this._y0 = this._y1, this._y1 = this._y2, this._y2 = y$1;
	}
};
var catmullRomOpen_default = (function custom(alpha) {
	function catmullRom(context) {
		return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
	}
	catmullRom.alpha = function(alpha$1) {
		return custom(+alpha$1);
	};
	return catmullRom;
})(.5);

//#endregion
//#region node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context) {
	this._context = context;
}
LinearClosed.prototype = {
	areaStart: noop_default,
	areaEnd: noop_default,
	lineStart: function() {
		this._point = 0;
	},
	lineEnd: function() {
		if (this._point) this._context.closePath();
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		if (this._point) this._context.lineTo(x$1, y$1);
		else this._point = 1, this._context.moveTo(x$1, y$1);
	}
};
function linearClosed_default(context) {
	return new LinearClosed(context);
}

//#endregion
//#region node_modules/d3-shape/src/curve/monotone.js
function sign(x$1) {
	return x$1 < 0 ? -1 : 1;
}
function slope3(that, x2, y2) {
	var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
	return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), .5 * Math.abs(p)) || 0;
}
function slope2(that, t) {
	var h = that._x1 - that._x0;
	return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
function point(that, t0, t1) {
	var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
	that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}
function MonotoneX(context) {
	this._context = context;
}
MonotoneX.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
		this._point = 0;
	},
	lineEnd: function() {
		switch (this._point) {
			case 2:
				this._context.lineTo(this._x1, this._y1);
				break;
			case 3:
				point(this, this._t0, slope2(this, this._t0));
				break;
		}
		if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
		this._line = 1 - this._line;
	},
	point: function(x$1, y$1) {
		var t1 = NaN;
		x$1 = +x$1, y$1 = +y$1;
		if (x$1 === this._x1 && y$1 === this._y1) return;
		switch (this._point) {
			case 0:
				this._point = 1;
				this._line ? this._context.lineTo(x$1, y$1) : this._context.moveTo(x$1, y$1);
				break;
			case 1:
				this._point = 2;
				break;
			case 2:
				this._point = 3;
				point(this, slope2(this, t1 = slope3(this, x$1, y$1)), t1);
				break;
			default:
				point(this, this._t0, t1 = slope3(this, x$1, y$1));
				break;
		}
		this._x0 = this._x1, this._x1 = x$1;
		this._y0 = this._y1, this._y1 = y$1;
		this._t0 = t1;
	}
};
function MonotoneY(context) {
	this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x$1, y$1) {
	MonotoneX.prototype.point.call(this, y$1, x$1);
};
function ReflectContext(context) {
	this._context = context;
}
ReflectContext.prototype = {
	moveTo: function(x$1, y$1) {
		this._context.moveTo(y$1, x$1);
	},
	closePath: function() {
		this._context.closePath();
	},
	lineTo: function(x$1, y$1) {
		this._context.lineTo(y$1, x$1);
	},
	bezierCurveTo: function(x1, y1, x2, y2, x$1, y$1) {
		this._context.bezierCurveTo(y1, x1, y2, x2, y$1, x$1);
	}
};
function monotoneX(context) {
	return new MonotoneX(context);
}
function monotoneY(context) {
	return new MonotoneY(context);
}

//#endregion
//#region node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
	this._context = context;
}
Natural.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._x = [];
		this._y = [];
	},
	lineEnd: function() {
		var x$1 = this._x, y$1 = this._y, n = x$1.length;
		if (n) {
			this._line ? this._context.lineTo(x$1[0], y$1[0]) : this._context.moveTo(x$1[0], y$1[0]);
			if (n === 2) this._context.lineTo(x$1[1], y$1[1]);
			else {
				var px = controlPoints(x$1), py = controlPoints(y$1);
				for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x$1[i1], y$1[i1]);
			}
		}
		if (this._line || this._line !== 0 && n === 1) this._context.closePath();
		this._line = 1 - this._line;
		this._x = this._y = null;
	},
	point: function(x$1, y$1) {
		this._x.push(+x$1);
		this._y.push(+y$1);
	}
};
function controlPoints(x$1) {
	var i, n = x$1.length - 1, m, a$1 = new Array(n), b = new Array(n), r = new Array(n);
	a$1[0] = 0, b[0] = 2, r[0] = x$1[0] + 2 * x$1[1];
	for (i = 1; i < n - 1; ++i) a$1[i] = 1, b[i] = 4, r[i] = 4 * x$1[i] + 2 * x$1[i + 1];
	a$1[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x$1[n - 1] + x$1[n];
	for (i = 1; i < n; ++i) m = a$1[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
	a$1[n - 1] = r[n - 1] / b[n - 1];
	for (i = n - 2; i >= 0; --i) a$1[i] = (r[i] - a$1[i + 1]) / b[i];
	b[n - 1] = (x$1[n] + a$1[n - 1]) / 2;
	for (i = 0; i < n - 1; ++i) b[i] = 2 * x$1[i + 1] - a$1[i + 1];
	return [a$1, b];
}
function natural_default(context) {
	return new Natural(context);
}

//#endregion
//#region node_modules/d3-shape/src/curve/step.js
function Step(context, t) {
	this._context = context;
	this._t = t;
}
Step.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._x = this._y = NaN;
		this._point = 0;
	},
	lineEnd: function() {
		if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
		if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
		if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		switch (this._point) {
			case 0:
				this._point = 1;
				this._line ? this._context.lineTo(x$1, y$1) : this._context.moveTo(x$1, y$1);
				break;
			case 1: this._point = 2;
			default:
				if (this._t <= 0) {
					this._context.lineTo(this._x, y$1);
					this._context.lineTo(x$1, y$1);
				} else {
					var x1 = this._x * (1 - this._t) + x$1 * this._t;
					this._context.lineTo(x1, this._y);
					this._context.lineTo(x1, y$1);
				}
				break;
		}
		this._x = x$1, this._y = y$1;
	}
};
function step_default(context) {
	return new Step(context, .5);
}
function stepBefore(context) {
	return new Step(context, 0);
}
function stepAfter(context) {
	return new Step(context, 1);
}

//#endregion
//#region node_modules/d3-shape/src/offset/none.js
function none_default(series, order) {
	if (!((n = series.length) > 1)) return;
	for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
		s0 = s1, s1 = series[order[i]];
		for (j = 0; j < m; ++j) s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
	}
}

//#endregion
//#region node_modules/d3-shape/src/order/none.js
function none_default$1(series) {
	var n = series.length, o = new Array(n);
	while (--n >= 0) o[n] = n;
	return o;
}

//#endregion
//#region node_modules/d3-shape/src/stack.js
function stackValue(d, key) {
	return d[key];
}
function stackSeries(key) {
	const series = [];
	series.key = key;
	return series;
}
function stack_default() {
	var keys = constant_default([]), order = none_default$1, offset = none_default, value = stackValue;
	function stack(data) {
		var sz = Array.from(keys.apply(this, arguments), stackSeries), i, n = sz.length, j = -1, oz;
		for (const d of data) for (i = 0, ++j; i < n; ++i) (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
		for (i = 0, oz = array_default(order(sz)); i < n; ++i) sz[oz[i]].index = i;
		offset(sz, oz);
		return sz;
	}
	stack.keys = function(_) {
		return arguments.length ? (keys = typeof _ === "function" ? _ : constant_default(Array.from(_)), stack) : keys;
	};
	stack.value = function(_) {
		return arguments.length ? (value = typeof _ === "function" ? _ : constant_default(+_), stack) : value;
	};
	stack.order = function(_) {
		return arguments.length ? (order = _ == null ? none_default$1 : typeof _ === "function" ? _ : constant_default(Array.from(_)), stack) : order;
	};
	stack.offset = function(_) {
		return arguments.length ? (offset = _ == null ? none_default : _, stack) : offset;
	};
	return stack;
}

//#endregion
//#region node_modules/d3-shape/src/offset/expand.js
function expand_default(series, order) {
	if (!((n = series.length) > 0)) return;
	for (var i, n, j = 0, m = series[0].length, y$1; j < m; ++j) {
		for (y$1 = i = 0; i < n; ++i) y$1 += series[i][j][1] || 0;
		if (y$1) for (i = 0; i < n; ++i) series[i][j][1] /= y$1;
	}
	none_default(series, order);
}

//#endregion
//#region node_modules/d3-shape/src/offset/diverging.js
function diverging_default(series, order) {
	if (!((n = series.length) > 0)) return;
	for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) for (yp = yn = 0, i = 0; i < n; ++i) if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) d[0] = yp, d[1] = yp += dy;
	else if (dy < 0) d[1] = yn, d[0] = yn += dy;
	else d[0] = 0, d[1] = dy;
}

//#endregion
//#region node_modules/d3-shape/src/offset/silhouette.js
function silhouette_default(series, order) {
	if (!((n = series.length) > 0)) return;
	for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
		for (var i = 0, y$1 = 0; i < n; ++i) y$1 += series[i][j][1] || 0;
		s0[j][1] += s0[j][0] = -y$1 / 2;
	}
	none_default(series, order);
}

//#endregion
//#region node_modules/d3-shape/src/offset/wiggle.js
function wiggle_default(series, order) {
	if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
	for (var y$1 = 0, j = 1, s0, m, n; j < m; ++j) {
		for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
			var si = series[order[i]], sij0 = si[j][1] || 0, s3 = (sij0 - (si[j - 1][1] || 0)) / 2;
			for (var k$1 = 0; k$1 < i; ++k$1) {
				var sk = series[order[k$1]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;
				s3 += skj0 - skj1;
			}
			s1 += sij0, s2 += s3 * sij0;
		}
		s0[j - 1][1] += s0[j - 1][0] = y$1;
		if (s1) y$1 -= s2 / s1;
	}
	s0[j - 1][1] += s0[j - 1][0] = y$1;
	none_default(series, order);
}

//#endregion
//#region node_modules/d3-shape/src/order/appearance.js
function appearance_default(series) {
	var peaks = series.map(peak);
	return none_default$1(series).sort(function(a$1, b) {
		return peaks[a$1] - peaks[b];
	});
}
function peak(series) {
	var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
	while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
	return j;
}

//#endregion
//#region node_modules/d3-shape/src/order/ascending.js
function ascending_default(series) {
	var sums = series.map(sum);
	return none_default$1(series).sort(function(a$1, b) {
		return sums[a$1] - sums[b];
	});
}
function sum(series) {
	var s$1 = 0, i = -1, n = series.length, v;
	while (++i < n) if (v = +series[i][1]) s$1 += v;
	return s$1;
}

//#endregion
//#region node_modules/d3-shape/src/order/descending.js
function descending_default(series) {
	return ascending_default(series).reverse();
}

//#endregion
//#region node_modules/d3-shape/src/order/insideOut.js
function insideOut_default(series) {
	var n = series.length, i, j, sums = series.map(sum), order = appearance_default(series), top = 0, bottom = 0, tops = [], bottoms = [];
	for (i = 0; i < n; ++i) {
		j = order[i];
		if (top < bottom) {
			top += sums[j];
			tops.push(j);
		} else {
			bottom += sums[j];
			bottoms.push(j);
		}
	}
	return bottoms.reverse().concat(tops);
}

//#endregion
//#region node_modules/d3-shape/src/order/reverse.js
function reverse_default(series) {
	return none_default$1(series).reverse();
}

//#endregion
export { arc_default as arc, area_default as area, areaRadial_default as areaRadial, areaRadial_default as radialArea, basis_default as curveBasis, basisClosed_default as curveBasisClosed, basisOpen_default as curveBasisOpen, bumpX as curveBumpX, bumpY as curveBumpY, bundle_default as curveBundle, cardinal_default as curveCardinal, cardinalClosed_default as curveCardinalClosed, cardinalOpen_default as curveCardinalOpen, catmullRom_default as curveCatmullRom, catmullRomClosed_default as curveCatmullRomClosed, catmullRomOpen_default as curveCatmullRomOpen, linear_default as curveLinear, linearClosed_default as curveLinearClosed, monotoneX as curveMonotoneX, monotoneY as curveMonotoneY, natural_default as curveNatural, step_default as curveStep, stepAfter as curveStepAfter, stepBefore as curveStepBefore, line_default as line, lineRadial_default as lineRadial, lineRadial_default as radialLine, link, linkHorizontal, linkRadial, linkVertical, pie_default as pie, pointRadial_default as pointRadial, stack_default as stack, diverging_default as stackOffsetDiverging, expand_default as stackOffsetExpand, none_default as stackOffsetNone, silhouette_default as stackOffsetSilhouette, wiggle_default as stackOffsetWiggle, appearance_default as stackOrderAppearance, ascending_default as stackOrderAscending, descending_default as stackOrderDescending, insideOut_default as stackOrderInsideOut, none_default$1 as stackOrderNone, reverse_default as stackOrderReverse, Symbol as symbol, asterisk_default as symbolAsterisk, circle_default as symbolCircle, cross_default as symbolCross, diamond_default as symbolDiamond, diamond2_default as symbolDiamond2, plus_default as symbolPlus, square_default as symbolSquare, square2_default as symbolSquare2, star_default as symbolStar, times_default as symbolTimes, times_default as symbolX, triangle_default as symbolTriangle, triangle2_default as symbolTriangle2, wye_default as symbolWye, symbolsFill as symbols, symbolsFill, symbolsStroke };
//# sourceMappingURL=d3-shape.js.map