import { C as Log, S as Stats, _ as getTypedArrayConstructor, a as getScratchArrayBuffer, b as log, c as RenderPipeline, d as Texture, f as Sampler, g as getDataType, h as alignTo, i as loadSpectorJS, l as Shader, m as getVertexFormatFromAttribute, n as loadWebGLDeveloperTools, o as getAttributeInfosFromLayouts, p as Device, r as DEFAULT_SPECTOR_PROPS, s as getVariableShaderTypeInfo, t as WebGLDevice, u as TextureView, v as Buffer, w as isBrowser, x as lumaStats, y as Resource$1 } from "./webgl-device-BEeceotL.js";

//#region node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js
/**
* Throws an `Error` with the optional `message` if `condition` is falsy
* @note Replacement for the external assert method to reduce bundle size
*/
function assert$4(condition, message) {
	if (!condition) throw new Error(message || "loader assertion failed.");
}

//#endregion
//#region node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js
var globals$1 = {
	self: typeof self !== "undefined" && self,
	window: typeof window !== "undefined" && window,
	global: typeof global !== "undefined" && global,
	document: typeof document !== "undefined" && document
};
var self_$1 = globals$1.self || globals$1.window || globals$1.global || {};
var window_$2 = globals$1.window || globals$1.self || globals$1.global || {};
var global_$1 = globals$1.global || globals$1.self || globals$1.window || {};
var document_$1 = globals$1.document || {};
/** true if running in a browser */
const isBrowser$1 = Boolean(typeof process !== "object" || String(process) !== "[object process]" || process.browser);
var matches$1 = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
/** Major Node version (as a number) */
const nodeVersion$1 = matches$1 && parseFloat(matches$1[1]) || 0;

//#endregion
//#region node_modules/@loaders.gl/loader-utils/dist/lib/log-utils/log.js
const VERSION$3 = "4.3.3";
var version = VERSION$3[0] >= "0" && VERSION$3[0] <= "9" ? `v${VERSION$3}` : "";
function createLog() {
	const log$2 = new Log({ id: "loaders.gl" });
	globalThis.loaders = globalThis.loaders || {};
	globalThis.loaders.log = log$2;
	globalThis.loaders.version = version;
	globalThis.probe = globalThis.probe || {};
	globalThis.probe.loaders = log$2;
	return log$2;
}
const log$1 = createLog();

//#endregion
//#region node_modules/@loaders.gl/loader-utils/dist/lib/option-utils/merge-loader-options.js
/**
*
* @param baseOptions Can be undefined, in which case a fresh options object will be minted
* @param newOptions
* @returns
*/
function mergeLoaderOptions(baseOptions, newOptions) {
	return mergeOptionsRecursively(baseOptions || {}, newOptions);
}
function mergeOptionsRecursively(baseOptions, newOptions, level = 0) {
	if (level > 3) return newOptions;
	const options = { ...baseOptions };
	for (const [key, newValue] of Object.entries(newOptions)) if (newValue && typeof newValue === "object" && !Array.isArray(newValue)) options[key] = mergeOptionsRecursively(options[key] || {}, newOptions[key], level + 1);
	else options[key] = newOptions[key];
	return options;
}

//#endregion
//#region node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/version.js
/**
* TODO - unpkg.com doesn't seem to have a `latest` specifier for alpha releases...
* 'beta' on beta branch, 'latest' on prod branch
*/
const NPM_TAG = "latest";
function getVersion() {
	if (!globalThis._loadersgl_?.version) {
		globalThis._loadersgl_ = globalThis._loadersgl_ || {};
		globalThis._loadersgl_.version = "4.3.3";
	}
	return globalThis._loadersgl_.version;
}
const VERSION$2 = getVersion();

//#endregion
//#region node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js
/** Throws an `Error` with the optional `message` if `condition` is falsy */
function assert$5(condition, message) {
	if (!condition) throw new Error(message || "loaders.gl assertion failed.");
}

//#endregion
//#region node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js
var globals = {
	self: typeof self !== "undefined" && self,
	window: typeof window !== "undefined" && window,
	global: typeof global !== "undefined" && global,
	document: typeof document !== "undefined" && document
};
var self_ = globals.self || globals.window || globals.global || {};
var window_$1 = globals.window || globals.self || globals.global || {};
var global_ = globals.global || globals.self || globals.window || {};
var document_ = globals.document || {};
/** true if running in the browser, false if running in Node.js */
const isBrowser$2 = typeof process !== "object" || String(process) !== "[object process]" || process.browser;
/** true if running on a mobile device */
const isMobile = typeof window !== "undefined" && typeof window.orientation !== "undefined";
var matches = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
/** Version of Node.js if running under Node, otherwise 0 */
const nodeVersion = matches && parseFloat(matches[1]) || 0;

//#endregion
//#region node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-job.js
/**
* Represents one Job handled by a WorkerPool or WorkerFarm
*/
var WorkerJob = class {
	name;
	workerThread;
	isRunning = true;
	/** Promise that resolves when Job is done */
	result;
	_resolve = () => {};
	_reject = () => {};
	constructor(jobName, workerThread) {
		this.name = jobName;
		this.workerThread = workerThread;
		this.result = new Promise((resolve, reject) => {
			this._resolve = resolve;
			this._reject = reject;
		});
	}
	/**
	* Send a message to the job's worker thread
	* @param data any data structure, ideally consisting mostly of transferrable objects
	*/
	postMessage(type, payload) {
		this.workerThread.postMessage({
			source: "loaders.gl",
			type,
			payload
		});
	}
	/**
	* Call to resolve the `result` Promise with the supplied value
	*/
	done(value) {
		assert$5(this.isRunning);
		this.isRunning = false;
		this._resolve(value);
	}
	/**
	* Call to reject the `result` Promise with the supplied error
	*/
	error(error) {
		assert$5(this.isRunning);
		this.isRunning = false;
		this._reject(error);
	}
};

//#endregion
//#region node_modules/@loaders.gl/worker-utils/dist/lib/node/worker_threads-browser.js
/** Browser polyfill for Node.js built-in `worker_threads` module.
* These fills are non-functional, and just intended to ensure that
* `import 'worker_threads` doesn't break browser builds.
* The replacement is done in package.json browser field
*/
var NodeWorker = class {
	terminate() {}
};

//#endregion
//#region node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-loadable-worker-url.js
var workerURLCache = /* @__PURE__ */ new Map();
/**
* Creates a loadable URL from worker source or URL
* that can be used to create `Worker` instances.
* Due to CORS issues it may be necessary to wrap a URL in a small importScripts
* @param props
* @param props.source Worker source
* @param props.url Worker URL
* @returns loadable url
*/
function getLoadableWorkerURL(props) {
	assert$5(props.source && !props.url || !props.source && props.url);
	let workerURL = workerURLCache.get(props.source || props.url);
	if (!workerURL) {
		if (props.url) {
			workerURL = getLoadableWorkerURLFromURL(props.url);
			workerURLCache.set(props.url, workerURL);
		}
		if (props.source) {
			workerURL = getLoadableWorkerURLFromSource(props.source);
			workerURLCache.set(props.source, workerURL);
		}
	}
	assert$5(workerURL);
	return workerURL;
}
/**
* Build a loadable worker URL from worker URL
* @param url
* @returns loadable URL
*/
function getLoadableWorkerURLFromURL(url) {
	if (!url.startsWith("http")) return url;
	return getLoadableWorkerURLFromSource(buildScriptSource(url));
}
/**
* Build a loadable worker URL from worker source
* @param workerSource
* @returns loadable url
*/
function getLoadableWorkerURLFromSource(workerSource) {
	const blob = new Blob([workerSource], { type: "application/javascript" });
	return URL.createObjectURL(blob);
}
/**
* Per spec, worker cannot be initialized with a script from a different origin
* However a local worker script can still import scripts from other origins,
* so we simply build a wrapper script.
*
* @param workerUrl
* @returns source
*/
function buildScriptSource(workerUrl) {
	return `\
try {
  importScripts('${workerUrl}');
} catch (error) {
  console.error(error);
  throw error;
}`;
}

//#endregion
//#region node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-transfer-list.js
/**
* Returns an array of Transferrable objects that can be used with postMessage
* https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage
* @param object data to be sent via postMessage
* @param recursive - not for application use
* @param transfers - not for application use
* @returns a transfer list that can be passed to postMessage
*/
function getTransferList(object, recursive = true, transfers) {
	const transfersSet = transfers || /* @__PURE__ */ new Set();
	if (!object) {} else if (isTransferable(object)) transfersSet.add(object);
	else if (isTransferable(object.buffer)) transfersSet.add(object.buffer);
	else if (ArrayBuffer.isView(object)) {} else if (recursive && typeof object === "object") for (const key in object) getTransferList(object[key], recursive, transfersSet);
	return transfers === void 0 ? Array.from(transfersSet) : [];
}
function isTransferable(object) {
	if (!object) return false;
	if (object instanceof ArrayBuffer) return true;
	if (typeof MessagePort !== "undefined" && object instanceof MessagePort) return true;
	if (typeof ImageBitmap !== "undefined" && object instanceof ImageBitmap) return true;
	if (typeof OffscreenCanvas !== "undefined" && object instanceof OffscreenCanvas) return true;
	return false;
}

//#endregion
//#region node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-thread.js
var NOOP = () => {};
/**
* Represents one worker thread
*/
var WorkerThread = class {
	name;
	source;
	url;
	terminated = false;
	worker;
	onMessage;
	onError;
	_loadableURL = "";
	/** Checks if workers are supported on this platform */
	static isSupported() {
		return typeof Worker !== "undefined" && isBrowser$2 || typeof NodeWorker !== "undefined" && !isBrowser$2;
	}
	constructor(props) {
		const { name, source: source$2, url } = props;
		assert$5(source$2 || url);
		this.name = name;
		this.source = source$2;
		this.url = url;
		this.onMessage = NOOP;
		this.onError = (error) => console.log(error);
		this.worker = isBrowser$2 ? this._createBrowserWorker() : this._createNodeWorker();
	}
	/**
	* Terminate this worker thread
	* @note Can free up significant memory
	*/
	destroy() {
		this.onMessage = NOOP;
		this.onError = NOOP;
		this.worker.terminate();
		this.terminated = true;
	}
	get isRunning() {
		return Boolean(this.onMessage);
	}
	/**
	* Send a message to this worker thread
	* @param data any data structure, ideally consisting mostly of transferrable objects
	* @param transferList If not supplied, calculated automatically by traversing data
	*/
	postMessage(data, transferList) {
		transferList = transferList || getTransferList(data);
		this.worker.postMessage(data, transferList);
	}
	/**
	* Generate a standard Error from an ErrorEvent
	* @param event
	*/
	_getErrorFromErrorEvent(event) {
		let message = "Failed to load ";
		message += `worker ${this.name} from ${this.url}. `;
		if (event.message) message += `${event.message} in `;
		if (event.lineno) message += `:${event.lineno}:${event.colno}`;
		return new Error(message);
	}
	/**
	* Creates a worker thread on the browser
	*/
	_createBrowserWorker() {
		this._loadableURL = getLoadableWorkerURL({
			source: this.source,
			url: this.url
		});
		const worker = new Worker(this._loadableURL, { name: this.name });
		worker.onmessage = (event) => {
			if (!event.data) this.onError(/* @__PURE__ */ new Error("No data received"));
			else this.onMessage(event.data);
		};
		worker.onerror = (error) => {
			this.onError(this._getErrorFromErrorEvent(error));
			this.terminated = true;
		};
		worker.onmessageerror = (event) => console.error(event);
		return worker;
	}
	/**
	* Creates a worker thread in node.js
	* @todo https://nodejs.org/api/async_hooks.html#async-resource-worker-pool
	*/
	_createNodeWorker() {
		let worker;
		if (this.url) worker = new NodeWorker(this.url.includes(":/") || this.url.startsWith("/") ? this.url : `./${this.url}`, { eval: false });
		else if (this.source) worker = new NodeWorker(this.source, { eval: true });
		else throw new Error("no worker");
		worker.on("message", (data) => {
			this.onMessage(data);
		});
		worker.on("error", (error) => {
			this.onError(error);
		});
		worker.on("exit", (code) => {});
		return worker;
	}
};

//#endregion
//#region node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-pool.js
/**
* Process multiple data messages with small pool of identical workers
*/
var WorkerPool = class {
	name = "unnamed";
	source;
	url;
	maxConcurrency = 1;
	maxMobileConcurrency = 1;
	onDebug = () => {};
	reuseWorkers = true;
	props = {};
	jobQueue = [];
	idleQueue = [];
	count = 0;
	isDestroyed = false;
	/** Checks if workers are supported on this platform */
	static isSupported() {
		return WorkerThread.isSupported();
	}
	/**
	* @param processor - worker function
	* @param maxConcurrency - max count of workers
	*/
	constructor(props) {
		this.source = props.source;
		this.url = props.url;
		this.setProps(props);
	}
	/**
	* Terminates all workers in the pool
	* @note Can free up significant memory
	*/
	destroy() {
		this.idleQueue.forEach((worker) => worker.destroy());
		this.isDestroyed = true;
	}
	setProps(props) {
		this.props = {
			...this.props,
			...props
		};
		if (props.name !== void 0) this.name = props.name;
		if (props.maxConcurrency !== void 0) this.maxConcurrency = props.maxConcurrency;
		if (props.maxMobileConcurrency !== void 0) this.maxMobileConcurrency = props.maxMobileConcurrency;
		if (props.reuseWorkers !== void 0) this.reuseWorkers = props.reuseWorkers;
		if (props.onDebug !== void 0) this.onDebug = props.onDebug;
	}
	async startJob(name, onMessage$1 = (job, type, data) => job.done(data), onError = (job, error) => job.error(error)) {
		const startPromise = new Promise((onStart) => {
			this.jobQueue.push({
				name,
				onMessage: onMessage$1,
				onError,
				onStart
			});
			return this;
		});
		this._startQueuedJob();
		return await startPromise;
	}
	/**
	* Starts first queued job if worker is available or can be created
	* Called when job is started and whenever a worker returns to the idleQueue
	*/
	async _startQueuedJob() {
		if (!this.jobQueue.length) return;
		const workerThread = this._getAvailableWorker();
		if (!workerThread) return;
		const queuedJob = this.jobQueue.shift();
		if (queuedJob) {
			this.onDebug({
				message: "Starting job",
				name: queuedJob.name,
				workerThread,
				backlog: this.jobQueue.length
			});
			const job = new WorkerJob(queuedJob.name, workerThread);
			workerThread.onMessage = (data) => queuedJob.onMessage(job, data.type, data.payload);
			workerThread.onError = (error) => queuedJob.onError(job, error);
			queuedJob.onStart(job);
			try {
				await job.result;
			} catch (error) {
				console.error(`Worker exception: ${error}`);
			} finally {
				this.returnWorkerToQueue(workerThread);
			}
		}
	}
	/**
	* Returns a worker to the idle queue
	* Destroys the worker if
	*  - pool is destroyed
	*  - if this pool doesn't reuse workers
	*  - if maxConcurrency has been lowered
	* @param worker
	*/
	returnWorkerToQueue(worker) {
		if (!isBrowser$2 || this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency()) {
			worker.destroy();
			this.count--;
		} else this.idleQueue.push(worker);
		if (!this.isDestroyed) this._startQueuedJob();
	}
	/**
	* Returns idle worker or creates new worker if maxConcurrency has not been reached
	*/
	_getAvailableWorker() {
		if (this.idleQueue.length > 0) return this.idleQueue.shift() || null;
		if (this.count < this._getMaxConcurrency()) {
			this.count++;
			return new WorkerThread({
				name: `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`,
				source: this.source,
				url: this.url
			});
		}
		return null;
	}
	_getMaxConcurrency() {
		return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;
	}
};

//#endregion
//#region node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-farm.js
var DEFAULT_PROPS$1 = {
	maxConcurrency: 3,
	maxMobileConcurrency: 1,
	reuseWorkers: true,
	onDebug: () => {}
};
/**
* Process multiple jobs with a "farm" of different workers in worker pools.
*/
var WorkerFarm = class WorkerFarm {
	props;
	workerPools = /* @__PURE__ */ new Map();
	static _workerFarm;
	/** Checks if workers are supported on this platform */
	static isSupported() {
		return WorkerThread.isSupported();
	}
	/** Get the singleton instance of the global worker farm */
	static getWorkerFarm(props = {}) {
		WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});
		WorkerFarm._workerFarm.setProps(props);
		return WorkerFarm._workerFarm;
	}
	/** get global instance with WorkerFarm.getWorkerFarm() */
	constructor(props) {
		this.props = { ...DEFAULT_PROPS$1 };
		this.setProps(props);
		/** @type Map<string, WorkerPool>} */
		this.workerPools = /* @__PURE__ */ new Map();
	}
	/**
	* Terminate all workers in the farm
	* @note Can free up significant memory
	*/
	destroy() {
		for (const workerPool of this.workerPools.values()) workerPool.destroy();
		this.workerPools = /* @__PURE__ */ new Map();
	}
	/**
	* Set props used when initializing worker pools
	* @param props
	*/
	setProps(props) {
		this.props = {
			...this.props,
			...props
		};
		for (const workerPool of this.workerPools.values()) workerPool.setProps(this._getWorkerPoolProps());
	}
	/**
	* Returns a worker pool for the specified worker
	* @param options - only used first time for a specific worker name
	* @param options.name - the name of the worker - used to identify worker pool
	* @param options.url -
	* @param options.source -
	* @example
	*   const job = WorkerFarm.getWorkerFarm().getWorkerPool({name, url}).startJob(...);
	*/
	getWorkerPool(options) {
		const { name, source: source$2, url } = options;
		let workerPool = this.workerPools.get(name);
		if (!workerPool) {
			workerPool = new WorkerPool({
				name,
				source: source$2,
				url
			});
			workerPool.setProps(this._getWorkerPoolProps());
			this.workerPools.set(name, workerPool);
		}
		return workerPool;
	}
	_getWorkerPoolProps() {
		return {
			maxConcurrency: this.props.maxConcurrency,
			maxMobileConcurrency: this.props.maxMobileConcurrency,
			reuseWorkers: this.props.reuseWorkers,
			onDebug: this.props.onDebug
		};
	}
};

//#endregion
//#region node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/get-worker-url.js
/**
* Generate a worker URL based on worker object and options
* @returns A URL to one of the following:
* - a published worker on unpkg CDN
* - a local test worker
* - a URL provided by the user in options
*/
function getWorkerURL(worker, options = {}) {
	const workerOptions = options[worker.id] || {};
	const workerFile = isBrowser$2 ? `${worker.id}-worker.js` : `${worker.id}-worker-node.js`;
	let url = workerOptions.workerUrl;
	if (!url && worker.id === "compression") url = options.workerUrl;
	if (options._workerType === "test") if (isBrowser$2) url = `modules/${worker.module}/dist/${workerFile}`;
	else url = `modules/${worker.module}/src/workers/${worker.id}-worker-node.ts`;
	if (!url) {
		let version$1 = worker.version;
		if (version$1 === "latest") version$1 = NPM_TAG;
		const versionTag = version$1 ? `@${version$1}` : "";
		url = `https://unpkg.com/@loaders.gl/${worker.module}${versionTag}/dist/${workerFile}`;
	}
	assert$5(url);
	return url;
}

//#endregion
//#region node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/validate-worker-version.js
/**
* Check if worker is compatible with this library version
* @param worker
* @param libVersion
* @returns `true` if the two versions are compatible
*/
function validateWorkerVersion(worker, coreVersion = VERSION$2) {
	assert$5(worker, "no worker provided");
	const workerVersion = worker.version;
	if (!coreVersion || !workerVersion) return false;
	return true;
}

//#endregion
//#region node_modules/@loaders.gl/loader-utils/dist/lib/worker-loader-utils/parse-with-worker.js
/**
* Determines if a loader can parse with worker
* @param loader
* @param options
*/
function canParseWithWorker(loader, options) {
	if (!WorkerFarm.isSupported()) return false;
	if (!isBrowser$2 && !options?._nodeWorkers) return false;
	return loader.worker && options?.worker;
}
/**
* this function expects that the worker function sends certain messages,
* this can be automated if the worker is wrapper by a call to createLoaderWorker in @loaders.gl/loader-utils.
*/
async function parseWithWorker(loader, data, options, context, parseOnMainThread) {
	const name = loader.id;
	const url = getWorkerURL(loader, options);
	const workerPool = WorkerFarm.getWorkerFarm(options).getWorkerPool({
		name,
		url
	});
	options = JSON.parse(JSON.stringify(options));
	context = JSON.parse(JSON.stringify(context || {}));
	const job = await workerPool.startJob("process-on-worker", onMessage.bind(null, parseOnMainThread));
	job.postMessage("process", {
		input: data,
		options,
		context
	});
	return await (await job.result).result;
}
/**
* Handle worker's responses to the main thread
* @param job
* @param type
* @param payload
*/
async function onMessage(parseOnMainThread, job, type, payload) {
	switch (type) {
		case "done":
			job.done(payload);
			break;
		case "error":
			job.error(new Error(payload.error));
			break;
		case "process":
			const { id, input, options } = payload;
			try {
				const result = await parseOnMainThread(input, options);
				job.postMessage("done", {
					id,
					result
				});
			} catch (error) {
				const message = error instanceof Error ? error.message : "unknown error";
				job.postMessage("error", {
					id,
					error: message
				});
			}
			break;
		default: console.warn(`parse-with-worker unknown message ${type}`);
	}
}

//#endregion
//#region node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/array-buffer-utils.js
/**
* compare two binary arrays for equality
* @param a
* @param b
* @param byteLength
*/
function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
	byteLength = byteLength || arrayBuffer1.byteLength;
	if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) return false;
	const array1 = new Uint8Array(arrayBuffer1);
	const array2 = new Uint8Array(arrayBuffer2);
	for (let i$1 = 0; i$1 < array1.length; ++i$1) if (array1[i$1] !== array2[i$1]) return false;
	return true;
}
/**
* Concatenate a sequence of ArrayBuffers from arguments
* @return A concatenated ArrayBuffer
*/
function concatenateArrayBuffers(...sources) {
	return concatenateArrayBuffersFromArray(sources);
}
/**
* Concatenate a sequence of ArrayBuffers from array
* @return A concatenated ArrayBuffer
*/
function concatenateArrayBuffersFromArray(sources) {
	const sourceArrays = sources.map((source2) => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);
	const byteLength = sourceArrays.reduce((length$2, typedArray) => length$2 + typedArray.byteLength, 0);
	const result = new Uint8Array(byteLength);
	let offset = 0;
	for (const sourceArray of sourceArrays) {
		result.set(sourceArray, offset);
		offset += sourceArray.byteLength;
	}
	return result.buffer;
}

//#endregion
//#region node_modules/@loaders.gl/loader-utils/dist/lib/iterators/async-iteration.js
/**
* Concatenates all data chunks yielded by an (async) iterator
* This function can e.g. be used to enable atomic parsers to work on (async) iterator inputs
*/
async function concatenateArrayBuffersAsync(asyncIterator) {
	const arrayBuffers = [];
	for await (const chunk of asyncIterator) arrayBuffers.push(chunk);
	return concatenateArrayBuffers(...arrayBuffers);
}

//#endregion
//#region node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/file-aliases.js
var pathPrefix$1 = "";
var fileAliases = {};
/**
* Resolves aliases and adds path-prefix to paths
*/
function resolvePath(filename$1) {
	for (const alias in fileAliases) if (filename$1.startsWith(alias)) {
		const replacement = fileAliases[alias];
		filename$1 = filename$1.replace(alias, replacement);
	}
	if (!filename$1.startsWith("http://") && !filename$1.startsWith("https://")) filename$1 = `${pathPrefix$1}${filename$1}`;
	return filename$1;
}

//#endregion
//#region node_modules/@loaders.gl/loader-utils/dist/lib/node/buffer.browser.js
/**
* Convert Buffer to ArrayBuffer
* Converts Node.js `Buffer` to `ArrayBuffer` (without triggering bundler to include Buffer polyfill on browser)
* @todo better data type
*/
function toArrayBuffer$1(buffer) {
	return buffer;
}

//#endregion
//#region node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-conversion-utils.js
/**
* Check for Node.js `Buffer` (without triggering bundler to include Buffer polyfill on browser)
*/
function isBuffer$1(value) {
	return value && typeof value === "object" && value.isBuffer;
}
/**
* Convert an object to an array buffer
*/
function toArrayBuffer(data) {
	if (isBuffer$1(data)) return toArrayBuffer$1(data);
	if (data instanceof ArrayBuffer) return data;
	if (ArrayBuffer.isView(data)) {
		if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) return data.buffer;
		return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
	}
	if (typeof data === "string") {
		const text = data;
		return new TextEncoder().encode(text).buffer;
	}
	if (data && typeof data === "object" && data._toArrayBuffer) return data._toArrayBuffer();
	throw new Error("toArrayBuffer");
}

//#endregion
//#region node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js
/**
* Replacement for Node.js path.filename
* @param url
*/
function filename(url) {
	const slashIndex = url ? url.lastIndexOf("/") : -1;
	return slashIndex >= 0 ? url.substr(slashIndex + 1) : "";
}
/**
* Replacement for Node.js path.dirname
* @param url
*/
function dirname(url) {
	const slashIndex = url ? url.lastIndexOf("/") : -1;
	return slashIndex >= 0 ? url.substr(0, slashIndex) : "";
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js
var isBoolean = (x$1) => typeof x$1 === "boolean";
var isFunction = (x$1) => typeof x$1 === "function";
const isObject$1 = (x$1) => x$1 !== null && typeof x$1 === "object";
const isPureObject = (x$1) => isObject$1(x$1) && x$1.constructor === {}.constructor;
const isIterable = (x$1) => Boolean(x$1) && typeof x$1[Symbol.iterator] === "function";
const isAsyncIterable$1 = (x$1) => x$1 && typeof x$1[Symbol.asyncIterator] === "function";
const isResponse = (x$1) => typeof Response !== "undefined" && x$1 instanceof Response || x$1 && x$1.arrayBuffer && x$1.text && x$1.json;
const isBlob = (x$1) => typeof Blob !== "undefined" && x$1 instanceof Blob;
/** Check for Node.js `Buffer` without triggering bundler to include buffer polyfill */
const isBuffer = (x$1) => x$1 && typeof x$1 === "object" && x$1.isBuffer;
const isReadableDOMStream = (x$1) => typeof ReadableStream !== "undefined" && x$1 instanceof ReadableStream || isObject$1(x$1) && isFunction(x$1.tee) && isFunction(x$1.cancel) && isFunction(x$1.getReader);
const isReadableNodeStream = (x$1) => isObject$1(x$1) && isFunction(x$1.read) && isFunction(x$1.pipe) && isBoolean(x$1.readable);
const isReadableStream = (x$1) => isReadableDOMStream(x$1) || isReadableNodeStream(x$1);

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/fetch/fetch-error.js
var FetchError = class extends Error {
	constructor(message, info) {
		super(message);
		this.reason = info.reason;
		this.url = info.url;
		this.response = info.response;
	}
	/** A best effort reason for why the fetch failed */
	reason;
	/** The URL that failed to load. Empty string if not available. */
	url;
	/** The Response object, if any. */
	response;
};

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/utils/mime-type-utils.js
var DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
var MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;
/**
* Compare two MIME types, case insensitively etc.
* @param mimeType1
* @param mimeType2
* @returns true if the MIME types are equivalent
* @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#structure_of_a_mime_type
*/
function compareMIMETypes(mimeType1, mimeType2) {
	if (mimeType1.toLowerCase() === mimeType2.toLowerCase()) return true;
	return false;
}
/**
* Remove extra data like `charset` from MIME types
* @param mimeString
* @returns A clean MIME type, or an empty string
*
* @todo - handle more advanced MIMETYpes, multiple types
* @todo - extract charset etc
*/
function parseMIMEType(mimeString) {
	const matches$2 = MIME_TYPE_PATTERN.exec(mimeString);
	if (matches$2) return matches$2[1];
	return mimeString;
}
/**
* Extract MIME type from data URL
*
* @param mimeString
* @returns A clean MIME type, or an empty string
*
* @todo - handle more advanced MIMETYpes, multiple types
* @todo - extract charset etc
*/
function parseMIMETypeFromURL(url) {
	const matches$2 = DATA_URL_PATTERN.exec(url);
	if (matches$2) return matches$2[1];
	return "";
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js
var QUERY_STRING_PATTERN = /\?.*/;
function extractQueryString(url) {
	const matches$2 = url.match(QUERY_STRING_PATTERN);
	return matches$2 && matches$2[0];
}
function stripQueryString(url) {
	return url.replace(QUERY_STRING_PATTERN, "");
}
function shortenUrlForDisplay(url) {
	if (url.length < 50) return url;
	const urlEnd = url.slice(url.length - 15);
	return `${url.substr(0, 32)}...${urlEnd}`;
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/utils/resource-utils.js
/**
* Returns the URL associated with this resource.
* The returned value may include a query string and need further processing.
* If it cannot determine url, the corresponding value will be an empty string
*
* @todo string parameters are assumed to be URLs
*/
function getResourceUrl(resource) {
	if (isResponse(resource)) return resource.url;
	if (isBlob(resource)) return resource.name || "";
	if (typeof resource === "string") return resource;
	return "";
}
/**
* Returns the URL associated with this resource.
* The returned value may include a query string and need further processing.
* If it cannot determine url, the corresponding value will be an empty string
*
* @todo string parameters are assumed to be URLs
*/
function getResourceMIMEType(resource) {
	if (isResponse(resource)) {
		const response = resource;
		const contentTypeHeader = response.headers.get("content-type") || "";
		const noQueryUrl = stripQueryString(response.url);
		return parseMIMEType(contentTypeHeader) || parseMIMETypeFromURL(noQueryUrl);
	}
	if (isBlob(resource)) return resource.type || "";
	if (typeof resource === "string") return parseMIMETypeFromURL(resource);
	return "";
}
/**
* Returns (approximate) content length for a resource if it can be determined.
* Returns -1 if content length cannot be determined.
* @param resource

* @note string parameters are NOT assumed to be URLs
*/
function getResourceContentLength(resource) {
	if (isResponse(resource)) return resource.headers["content-length"] || -1;
	if (isBlob(resource)) return resource.size;
	if (typeof resource === "string") return resource.length;
	if (resource instanceof ArrayBuffer) return resource.byteLength;
	if (ArrayBuffer.isView(resource)) return resource.byteLength;
	return -1;
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/utils/response-utils.js
/**
* Returns a Response object
* Adds content-length header when possible
*
* @param resource
*/
async function makeResponse(resource) {
	if (isResponse(resource)) return resource;
	const headers = {};
	const contentLength = getResourceContentLength(resource);
	if (contentLength >= 0) headers["content-length"] = String(contentLength);
	const url = getResourceUrl(resource);
	const type = getResourceMIMEType(resource);
	if (type) headers["content-type"] = type;
	const initialDataUrl = await getInitialDataUrl(resource);
	if (initialDataUrl) headers["x-first-bytes"] = initialDataUrl;
	if (typeof resource === "string") resource = new TextEncoder().encode(resource);
	const response = new Response(resource, { headers });
	Object.defineProperty(response, "url", { value: url });
	return response;
}
/**
* Checks response status (async) and throws a helpful error message if status is not OK.
* @param response
*/
async function checkResponse(response) {
	if (!response.ok) throw await getResponseError(response);
}
async function getResponseError(response) {
	const shortUrl = shortenUrlForDisplay(response.url);
	let message = `Failed to fetch resource (${response.status}) ${response.statusText}: ${shortUrl}`;
	message = message.length > 100 ? `${message.slice(0, 100)}...` : message;
	const info = {
		reason: response.statusText,
		url: response.url,
		response
	};
	try {
		const contentType = response.headers.get("Content-Type");
		info.reason = !response.bodyUsed && contentType?.includes("application/json") ? await response.json() : await response.text();
	} catch (error) {}
	return new FetchError(message, info);
}
async function getInitialDataUrl(resource) {
	const INITIAL_DATA_LENGTH = 5;
	if (typeof resource === "string") return `data:,${resource.slice(0, INITIAL_DATA_LENGTH)}`;
	if (resource instanceof Blob) {
		const blobSlice = resource.slice(0, 5);
		return await new Promise((resolve) => {
			const reader = new FileReader();
			reader.onload = (event) => resolve(event?.target?.result);
			reader.readAsDataURL(blobSlice);
		});
	}
	if (resource instanceof ArrayBuffer) return `data:base64,${arrayBufferToBase64(resource.slice(0, INITIAL_DATA_LENGTH))}`;
	return null;
}
function arrayBufferToBase64(buffer) {
	let binary = "";
	const bytes = new Uint8Array(buffer);
	for (let i$1 = 0; i$1 < bytes.byteLength; i$1++) binary += String.fromCharCode(bytes[i$1]);
	return btoa(binary);
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/fetch/fetch-file.js
function isNodePath(url) {
	return !isRequestURL(url) && !isDataURL(url);
}
function isRequestURL(url) {
	return url.startsWith("http:") || url.startsWith("https:");
}
function isDataURL(url) {
	return url.startsWith("data:");
}
/**
* fetch API compatible function
* - Supports fetching from Node.js local file system paths
* - Respects pathPrefix and file aliases
*/
async function fetchFile(urlOrData, fetchOptions) {
	if (typeof urlOrData === "string") {
		const url = resolvePath(urlOrData);
		if (isNodePath(url)) {
			if (globalThis.loaders?.fetchNode) return globalThis.loaders?.fetchNode(url, fetchOptions);
		}
		return await fetch(url, fetchOptions);
	}
	return await makeResponse(urlOrData);
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/loader-utils/loggers.js
const probeLog = new Log({ id: "loaders.gl" });
var NullLog = class {
	log() {
		return () => {};
	}
	info() {
		return () => {};
	}
	warn() {
		return () => {};
	}
	error() {
		return () => {};
	}
};
var ConsoleLog = class {
	console;
	constructor() {
		this.console = console;
	}
	log(...args) {
		return this.console.log.bind(this.console, ...args);
	}
	info(...args) {
		return this.console.info.bind(this.console, ...args);
	}
	warn(...args) {
		return this.console.warn.bind(this.console, ...args);
	}
	error(...args) {
		return this.console.error.bind(this.console, ...args);
	}
};

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/loader-utils/option-defaults.js
const DEFAULT_LOADER_OPTIONS = {
	fetch: null,
	mimeType: void 0,
	nothrow: false,
	log: new ConsoleLog(),
	useLocalLibraries: false,
	CDN: "https://unpkg.com/@loaders.gl",
	worker: true,
	maxConcurrency: 3,
	maxMobileConcurrency: 1,
	reuseWorkers: isBrowser$1,
	_nodeWorkers: false,
	_workerType: "",
	limit: 0,
	_limitMB: 0,
	batchSize: "auto",
	batchDebounceMs: 0,
	metadata: false,
	transforms: []
};
const REMOVED_LOADER_OPTIONS = {
	throws: "nothrow",
	dataType: "(no longer used)",
	uri: "baseUri",
	method: "fetch.method",
	headers: "fetch.headers",
	body: "fetch.body",
	mode: "fetch.mode",
	credentials: "fetch.credentials",
	cache: "fetch.cache",
	redirect: "fetch.redirect",
	referrer: "fetch.referrer",
	referrerPolicy: "fetch.referrerPolicy",
	integrity: "fetch.integrity",
	keepalive: "fetch.keepalive",
	signal: "fetch.signal"
};

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/loader-utils/option-utils.js
/**
* Helper for safely accessing global loaders.gl variables
* Wraps initialization of global variable in function to defeat overly aggressive tree-shakers
*/
function getGlobalLoaderState() {
	globalThis.loaders = globalThis.loaders || {};
	const { loaders } = globalThis;
	if (!loaders._state) loaders._state = {};
	return loaders._state;
}
/**
* Store global loader options on the global object to increase chances of cross loaders-version interoperability
* NOTE: This use case is not reliable but can help when testing new versions of loaders.gl with existing frameworks
* @returns global loader options merged with default loader options
*/
function getGlobalLoaderOptions() {
	const state = getGlobalLoaderState();
	state.globalOptions = state.globalOptions || { ...DEFAULT_LOADER_OPTIONS };
	return state.globalOptions;
}
/**
* Merges options with global opts and loader defaults, also injects baseUri
* @param options
* @param loader
* @param loaders
* @param url
*/
function normalizeOptions(options, loader, loaders, url) {
	loaders = loaders || [];
	loaders = Array.isArray(loaders) ? loaders : [loaders];
	validateOptions(options, loaders);
	return normalizeOptionsInternal(loader, options, url);
}
/**
* Warn for unsupported options
* @param options
* @param loaders
*/
function validateOptions(options, loaders) {
	validateOptionsObject(options, null, DEFAULT_LOADER_OPTIONS, REMOVED_LOADER_OPTIONS, loaders);
	for (const loader of loaders) {
		const idOptions = options && options[loader.id] || {};
		const loaderOptions = loader.options && loader.options[loader.id] || {};
		const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};
		validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);
	}
}
function validateOptionsObject(options, id, defaultOptions$1, deprecatedOptions, loaders) {
	const loaderName = id || "Top level";
	const prefix = id ? `${id}.` : "";
	for (const key in options) {
		const isSubOptions = !id && isObject$1(options[key]);
		const isBaseUriOption = key === "baseUri" && !id;
		const isWorkerUrlOption = key === "workerUrl" && id;
		if (!(key in defaultOptions$1) && !isBaseUriOption && !isWorkerUrlOption) {
			if (key in deprecatedOptions) probeLog.warn(`${loaderName} loader option \'${prefix}${key}\' no longer supported, use \'${deprecatedOptions[key]}\'`)();
			else if (!isSubOptions) {
				const suggestion = findSimilarOption(key, loaders);
				probeLog.warn(`${loaderName} loader option \'${prefix}${key}\' not recognized. ${suggestion}`)();
			}
		}
	}
}
function findSimilarOption(optionKey, loaders) {
	const lowerCaseOptionKey = optionKey.toLowerCase();
	let bestSuggestion = "";
	for (const loader of loaders) for (const key in loader.options) {
		if (optionKey === key) return `Did you mean \'${loader.id}.${key}\'?`;
		const lowerCaseKey = key.toLowerCase();
		if (lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey)) bestSuggestion = bestSuggestion || `Did you mean \'${loader.id}.${key}\'?`;
	}
	return bestSuggestion;
}
function normalizeOptionsInternal(loader, options, url) {
	const mergedOptions = { ...loader.options || {} };
	addUrlOptions(mergedOptions, url);
	if (mergedOptions.log === null) mergedOptions.log = new NullLog();
	mergeNestedFields(mergedOptions, getGlobalLoaderOptions());
	mergeNestedFields(mergedOptions, options);
	return mergedOptions;
}
function mergeNestedFields(mergedOptions, options) {
	for (const key in options) if (key in options) {
		const value = options[key];
		if (isPureObject(value) && isPureObject(mergedOptions[key])) mergedOptions[key] = {
			...mergedOptions[key],
			...options[key]
		};
		else mergedOptions[key] = options[key];
	}
}
/**
* Harvest information from the url
* @deprecated This is mainly there to support a hack in the GLTFLoader
* TODO - baseUri should be a directory, i.e. remove file component from baseUri
* TODO - extract extension?
* TODO - extract query parameters?
* TODO - should these be injected on context instead of options?
*/
function addUrlOptions(options, url) {
	if (url && !("baseUri" in options)) options.baseUri = url;
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js
function isLoaderObject(loader) {
	if (!loader) return false;
	if (Array.isArray(loader)) loader = loader[0];
	return Array.isArray(loader?.extensions);
}
function normalizeLoader(loader) {
	assert$4(loader, "null loader");
	assert$4(isLoaderObject(loader), "invalid loader");
	let options;
	if (Array.isArray(loader)) {
		options = loader[1];
		loader = loader[0];
		loader = {
			...loader,
			options: {
				...loader.options,
				...options
			}
		};
	}
	if (loader?.parseTextSync || loader?.parseText) loader.text = true;
	if (!loader.text) loader.binary = true;
	return loader;
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/api/register-loaders.js
/**
* Store global registered loaders on the global object to increase chances of cross loaders-version interoperability
* This use case is not reliable but can help when testing new versions of loaders.gl with existing frameworks
*/
var getGlobalLoaderRegistry = () => {
	const state = getGlobalLoaderState();
	state.loaderRegistry = state.loaderRegistry || [];
	return state.loaderRegistry;
};
/**
* Register a list of global loaders
* @note Registration erases loader type information.
* @deprecated It is recommended that applications manage loader registration. This function will likely be remove in loaders.gl v5
*/
function registerLoaders(loaders) {
	const loaderRegistry = getGlobalLoaderRegistry();
	loaders = Array.isArray(loaders) ? loaders : [loaders];
	for (const loader of loaders) {
		const normalizedLoader = normalizeLoader(loader);
		if (!loaderRegistry.find((registeredLoader) => normalizedLoader === registeredLoader)) loaderRegistry.unshift(normalizedLoader);
	}
}
/**
* @deprecated It is recommended that applications manage loader registration. This function will likely be remove in loaders.gl v5
*/
function getRegisteredLoaders() {
	return getGlobalLoaderRegistry();
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/api/select-loader.js
var EXT_PATTERN = /\.([^.]+)$/;
/**
* Find a loader that matches file extension and/or initial file content
* Search the loaders array argument for a loader that matches url extension or initial data
* Returns: a normalized loader
* @param data data to assist
* @param loaders
* @param options
* @param context used internally, applications should not provide this parameter
*/
async function selectLoader(data, loaders = [], options, context) {
	if (!validHTTPResponse(data)) return null;
	let loader = selectLoaderSync(data, loaders, {
		...options,
		nothrow: true
	}, context);
	if (loader) return loader;
	if (isBlob(data)) {
		data = await data.slice(0, 10).arrayBuffer();
		loader = selectLoaderSync(data, loaders, options, context);
	}
	if (!loader && !options?.nothrow) throw new Error(getNoValidLoaderMessage(data));
	return loader;
}
/**
* Find a loader that matches file extension and/or initial file content
* Search the loaders array argument for a loader that matches url extension or initial data
* Returns: a normalized loader
* @param data data to assist
* @param loaders
* @param options
* @param context used internally, applications should not provide this parameter
*/
function selectLoaderSync(data, loaders = [], options, context) {
	if (!validHTTPResponse(data)) return null;
	if (loaders && !Array.isArray(loaders)) return normalizeLoader(loaders);
	let candidateLoaders = [];
	if (loaders) candidateLoaders = candidateLoaders.concat(loaders);
	if (!options?.ignoreRegisteredLoaders) candidateLoaders.push(...getRegisteredLoaders());
	normalizeLoaders(candidateLoaders);
	const loader = selectLoaderInternal(data, candidateLoaders, options, context);
	if (!loader && !options?.nothrow) throw new Error(getNoValidLoaderMessage(data));
	return loader;
}
/** Implements loaders selection logic */
function selectLoaderInternal(data, loaders, options, context) {
	const url = getResourceUrl(data);
	const type = getResourceMIMEType(data);
	const testUrl = stripQueryString(url) || context?.url;
	let loader = null;
	let reason = "";
	if (options?.mimeType) {
		loader = findLoaderByMIMEType(loaders, options?.mimeType);
		reason = `match forced by supplied MIME type ${options?.mimeType}`;
	}
	loader = loader || findLoaderByUrl(loaders, testUrl);
	reason = reason || (loader ? `matched url ${testUrl}` : "");
	loader = loader || findLoaderByMIMEType(loaders, type);
	reason = reason || (loader ? `matched MIME type ${type}` : "");
	loader = loader || findLoaderByInitialBytes(loaders, data);
	reason = reason || (loader ? `matched initial data ${getFirstCharacters(data)}` : "");
	if (options?.fallbackMimeType) {
		loader = loader || findLoaderByMIMEType(loaders, options?.fallbackMimeType);
		reason = reason || (loader ? `matched fallback MIME type ${type}` : "");
	}
	if (reason) log$1.log(1, `selectLoader selected ${loader?.name}: ${reason}.`);
	return loader;
}
/** Check HTTP Response */
function validHTTPResponse(data) {
	if (data instanceof Response) {
		if (data.status === 204) return false;
	}
	return true;
}
/** Generate a helpful message to help explain why loader selection failed. */
function getNoValidLoaderMessage(data) {
	const url = getResourceUrl(data);
	const type = getResourceMIMEType(data);
	let message = "No valid loader found (";
	message += url ? `${filename(url)}, ` : "no url provided, ";
	message += `MIME type: ${type ? `"${type}"` : "not provided"}, `;
	const firstCharacters = data ? getFirstCharacters(data) : "";
	message += firstCharacters ? ` first bytes: "${firstCharacters}"` : "first bytes: not available";
	message += ")";
	return message;
}
function normalizeLoaders(loaders) {
	for (const loader of loaders) normalizeLoader(loader);
}
function findLoaderByUrl(loaders, url) {
	const match = url && EXT_PATTERN.exec(url);
	const extension = match && match[1];
	return extension ? findLoaderByExtension(loaders, extension) : null;
}
function findLoaderByExtension(loaders, extension) {
	extension = extension.toLowerCase();
	for (const loader of loaders) for (const loaderExtension of loader.extensions) if (loaderExtension.toLowerCase() === extension) return loader;
	return null;
}
function findLoaderByMIMEType(loaders, mimeType) {
	for (const loader of loaders) {
		if (loader.mimeTypes?.some((mimeType1) => compareMIMETypes(mimeType, mimeType1))) return loader;
		if (compareMIMETypes(mimeType, `application/x.${loader.id}`)) return loader;
	}
	return null;
}
function findLoaderByInitialBytes(loaders, data) {
	if (!data) return null;
	for (const loader of loaders) if (typeof data === "string") {
		if (testDataAgainstText(data, loader)) return loader;
	} else if (ArrayBuffer.isView(data)) {
		if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) return loader;
	} else if (data instanceof ArrayBuffer) {
		if (testDataAgainstBinary(data, 0, loader)) return loader;
	}
	return null;
}
function testDataAgainstText(data, loader) {
	if (loader.testText) return loader.testText(data);
	return (Array.isArray(loader.tests) ? loader.tests : [loader.tests]).some((test) => data.startsWith(test));
}
function testDataAgainstBinary(data, byteOffset, loader) {
	return (Array.isArray(loader.tests) ? loader.tests : [loader.tests]).some((test) => testBinary(data, byteOffset, loader, test));
}
function testBinary(data, byteOffset, loader, test) {
	if (test instanceof ArrayBuffer) return compareArrayBuffers(test, data, test.byteLength);
	switch (typeof test) {
		case "function": return test(data);
		case "string": return test === getMagicString(data, byteOffset, test.length);
		default: return false;
	}
}
function getFirstCharacters(data, length$2 = 5) {
	if (typeof data === "string") return data.slice(0, length$2);
	else if (ArrayBuffer.isView(data)) return getMagicString(data.buffer, data.byteOffset, length$2);
	else if (data instanceof ArrayBuffer) return getMagicString(data, 0, length$2);
	return "";
}
function getMagicString(arrayBuffer, byteOffset, length$2) {
	if (arrayBuffer.byteLength < byteOffset + length$2) return "";
	const dataView = new DataView(arrayBuffer);
	let magic = "";
	for (let i$1 = 0; i$1 < length$2; i$1++) magic += String.fromCharCode(dataView.getUint8(byteOffset + i$1));
	return magic;
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-string-iterator.js
var DEFAULT_CHUNK_SIZE$2 = 256 * 1024;
/**
* Returns an iterator that breaks a big string into chunks and yields them one-by-one as ArrayBuffers
* @param blob string to iterate over
* @param options
* @param options.chunkSize
*/
function* makeStringIterator(string, options) {
	const chunkSize = options?.chunkSize || DEFAULT_CHUNK_SIZE$2;
	let offset = 0;
	const textEncoder = new TextEncoder();
	while (offset < string.length) {
		const chunkLength = Math.min(string.length - offset, chunkSize);
		const chunk = string.slice(offset, offset + chunkLength);
		offset += chunkLength;
		yield textEncoder.encode(chunk);
	}
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-array-buffer-iterator.js
var DEFAULT_CHUNK_SIZE$1 = 256 * 1024;
/**
* Returns an iterator that breaks a big ArrayBuffer into chunks and yields them one-by-one
* @param blob ArrayBuffer to iterate over
* @param options
* @param options.chunkSize
*/
function* makeArrayBufferIterator(arrayBuffer, options = {}) {
	const { chunkSize = DEFAULT_CHUNK_SIZE$1 } = options;
	let byteOffset = 0;
	while (byteOffset < arrayBuffer.byteLength) {
		const chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);
		const chunk = new ArrayBuffer(chunkByteLength);
		const sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);
		new Uint8Array(chunk).set(sourceArray);
		byteOffset += chunkByteLength;
		yield chunk;
	}
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-blob-iterator.js
var DEFAULT_CHUNK_SIZE = 1024 * 1024;
/**
* Returns an iterator that breaks a big Blob into chunks and yields them one-by-one
* @param blob Blob or File object
* @param options
* @param options.chunkSize
*/
async function* makeBlobIterator(blob, options) {
	const chunkSize = options?.chunkSize || DEFAULT_CHUNK_SIZE;
	let offset = 0;
	while (offset < blob.size) {
		const end = offset + chunkSize;
		const chunk = await blob.slice(offset, end).arrayBuffer();
		offset = end;
		yield chunk;
	}
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-stream-iterator.js
/**
* Returns an async iterable that reads from a stream (works in both Node.js and browsers)
* @param stream stream to iterator over
*/
function makeStreamIterator(stream, options) {
	return isBrowser$1 ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream, options);
}
/**
* Returns an async iterable that reads from a DOM (browser) stream
* @param stream stream to iterate from
* @see https://jakearchibald.com/2017/async-iterators-and-generators/#making-streams-iterate
*/
async function* makeBrowserStreamIterator(stream, options) {
	const reader = stream.getReader();
	let nextBatchPromise;
	try {
		while (true) {
			const currentBatchPromise = nextBatchPromise || reader.read();
			if (options?._streamReadAhead) nextBatchPromise = reader.read();
			const { done, value } = await currentBatchPromise;
			if (done) return;
			yield toArrayBuffer(value);
		}
	} catch (error) {
		reader.releaseLock();
	}
}
/**
* Returns an async iterable that reads from a DOM (browser) stream
* @param stream stream to iterate from
* @note Requires Node.js >= 10
*/
async function* makeNodeStreamIterator(stream, options) {
	for await (const chunk of stream) yield toArrayBuffer(chunk);
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-iterator.js
/**
* Returns an iterator that breaks its input into chunks and yields them one-by-one.
* @param data
* @param options
* @returns
* This function can e.g. be used to enable data sources that can only be read atomically
* (such as `Blob` and `File` via `FileReader`) to still be parsed in batches.
*/
function makeIterator(data, options) {
	if (typeof data === "string") return makeStringIterator(data, options);
	if (data instanceof ArrayBuffer) return makeArrayBufferIterator(data, options);
	if (isBlob(data)) return makeBlobIterator(data, options);
	if (isReadableStream(data)) return makeStreamIterator(data, options);
	if (isResponse(data)) return makeStreamIterator(data.body, options);
	throw new Error("makeIterator");
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/loader-utils/get-data.js
var ERR_DATA = "Cannot convert supplied data type";
function getArrayBufferOrStringFromDataSync(data, loader, options) {
	if (loader.text && typeof data === "string") return data;
	if (isBuffer(data)) data = data.buffer;
	if (data instanceof ArrayBuffer) {
		const arrayBuffer = data;
		if (loader.text && !loader.binary) return new TextDecoder("utf8").decode(arrayBuffer);
		return arrayBuffer;
	}
	if (ArrayBuffer.isView(data)) {
		if (loader.text && !loader.binary) return new TextDecoder("utf8").decode(data);
		let arrayBuffer = data.buffer;
		const byteLength = data.byteLength || data.length;
		if (data.byteOffset !== 0 || byteLength !== arrayBuffer.byteLength) arrayBuffer = arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);
		return arrayBuffer;
	}
	throw new Error(ERR_DATA);
}
async function getArrayBufferOrStringFromData(data, loader, options) {
	const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);
	if (typeof data === "string" || isArrayBuffer) return getArrayBufferOrStringFromDataSync(data, loader, options);
	if (isBlob(data)) data = await makeResponse(data);
	if (isResponse(data)) {
		const response = data;
		await checkResponse(response);
		return loader.binary ? await response.arrayBuffer() : await response.text();
	}
	if (isReadableStream(data)) data = makeIterator(data, options);
	if (isIterable(data) || isAsyncIterable$1(data)) return concatenateArrayBuffersAsync(data);
	throw new Error(ERR_DATA);
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/loader-utils/get-fetch-function.js
/**
* Gets the current fetch function from options and context
* @param options
* @param context
*/
function getFetchFunction(options, context) {
	const globalOptions = getGlobalLoaderOptions();
	const loaderOptions = options || globalOptions;
	if (typeof loaderOptions.fetch === "function") return loaderOptions.fetch;
	if (isObject$1(loaderOptions.fetch)) return (url) => fetchFile(url, loaderOptions.fetch);
	if (context?.fetch) return context?.fetch;
	return fetchFile;
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/loader-utils/loader-context.js
/**
* "sub" loaders invoked by other loaders get a "context" injected on `this`
* The context will inject core methods like `parse` and contain information
* about loaders and options passed in to the top-level `parse` call.
*
* @param context
* @param options
* @param previousContext
*/
function getLoaderContext(context, options, parentContext) {
	if (parentContext) return parentContext;
	const newContext = {
		fetch: getFetchFunction(options, context),
		...context
	};
	if (newContext.url) {
		const baseUrl = stripQueryString(newContext.url);
		newContext.baseUrl = baseUrl;
		newContext.queryString = extractQueryString(newContext.url);
		newContext.filename = filename(baseUrl);
		newContext.baseUrl = dirname(baseUrl);
	}
	if (!Array.isArray(newContext.loaders)) newContext.loaders = null;
	return newContext;
}
function getLoadersFromContext(loaders, context) {
	if (loaders && !Array.isArray(loaders)) return loaders;
	let candidateLoaders;
	if (loaders) candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];
	if (context && context.loaders) {
		const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];
		candidateLoaders = candidateLoaders ? [...candidateLoaders, ...contextLoaders] : contextLoaders;
	}
	return candidateLoaders && candidateLoaders.length ? candidateLoaders : void 0;
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/api/parse.js
/**
* Parses `data` using a specified loader
* @param data
* @param loaders
* @param options
* @param context
*/
async function parse(data, loaders, options, context) {
	if (loaders && !Array.isArray(loaders) && !isLoaderObject(loaders)) {
		context = void 0;
		options = loaders;
		loaders = void 0;
	}
	data = await data;
	options = options || {};
	const url = getResourceUrl(data);
	const candidateLoaders = getLoadersFromContext(loaders, context);
	const loader = await selectLoader(data, candidateLoaders, options);
	if (!loader) return null;
	options = normalizeOptions(options, loader, candidateLoaders, url);
	context = getLoaderContext({
		url,
		_parse: parse,
		loaders: candidateLoaders
	}, options, context || null);
	return await parseWithLoader(loader, data, options, context);
}
async function parseWithLoader(loader, data, options, context) {
	validateWorkerVersion(loader);
	options = mergeLoaderOptions(loader.options, options);
	if (isResponse(data)) {
		const response = data;
		const { ok, redirected, status, statusText, type, url } = response;
		context.response = {
			headers: Object.fromEntries(response.headers.entries()),
			ok,
			redirected,
			status,
			statusText,
			type,
			url
		};
	}
	data = await getArrayBufferOrStringFromData(data, loader, options);
	const loaderWithParser = loader;
	if (loaderWithParser.parseTextSync && typeof data === "string") return loaderWithParser.parseTextSync(data, options, context);
	if (canParseWithWorker(loader, options)) return await parseWithWorker(loader, data, options, context, parse);
	if (loaderWithParser.parseText && typeof data === "string") return await loaderWithParser.parseText(data, options, context);
	if (loaderWithParser.parse) return await loaderWithParser.parse(data, options, context);
	assert$5(!loaderWithParser.parseSync);
	throw new Error(`${loader.id} loader - no parser found and worker is disabled`);
}

//#endregion
//#region node_modules/@loaders.gl/core/dist/lib/api/load.js
async function load(url, loaders, options, context) {
	let resolvedLoaders;
	let resolvedOptions;
	if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {
		resolvedLoaders = [];
		resolvedOptions = loaders;
		context = void 0;
	} else {
		resolvedLoaders = loaders;
		resolvedOptions = options;
	}
	const fetch$1 = getFetchFunction(resolvedOptions);
	let data = url;
	if (typeof url === "string") data = await fetch$1(url);
	if (isBlob(url)) data = await fetch$1(url);
	return Array.isArray(resolvedLoaders) ? await parse(data, resolvedLoaders, resolvedOptions) : await parse(data, resolvedLoaders, resolvedOptions);
}

//#endregion
//#region node_modules/@loaders.gl/images/dist/lib/utils/version.js
const VERSION$1 = "4.3.3";

//#endregion
//#region node_modules/@loaders.gl/images/dist/lib/category-api/image-type.js
var parseImageNode = globalThis.loaders?.parseImageNode;
var IMAGE_SUPPORTED = typeof Image !== "undefined";
var IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== "undefined";
var DATA_SUPPORTED = isBrowser$1 ? true : Boolean(parseImageNode);
/**
* Checks if a loaders.gl image type is supported
* @param type image type string
*/
function isImageTypeSupported(type) {
	switch (type) {
		case "auto": return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;
		case "imagebitmap": return IMAGE_BITMAP_SUPPORTED;
		case "image": return IMAGE_SUPPORTED;
		case "data": return DATA_SUPPORTED;
		default: throw new Error(`@loaders.gl/images: image ${type} not supported in this environment`);
	}
}
/**
* Returns the "most performant" supported image type on this platform
* @returns image type string
*/
function getDefaultImageType() {
	if (IMAGE_BITMAP_SUPPORTED) return "imagebitmap";
	if (IMAGE_SUPPORTED) return "image";
	if (DATA_SUPPORTED) return "data";
	throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
}

//#endregion
//#region node_modules/@loaders.gl/images/dist/lib/category-api/parsed-image-api.js
function getImageType(image) {
	const format = getImageTypeOrNull(image);
	if (!format) throw new Error("Not an image");
	return format;
}
function getImageData(image) {
	switch (getImageType(image)) {
		case "data": return image;
		case "image":
		case "imagebitmap":
			const canvas$1 = document.createElement("canvas");
			const context = canvas$1.getContext("2d");
			if (!context) throw new Error("getImageData");
			canvas$1.width = image.width;
			canvas$1.height = image.height;
			context.drawImage(image, 0, 0);
			return context.getImageData(0, 0, image.width, image.height);
		default: throw new Error("getImageData");
	}
}
function getImageTypeOrNull(image) {
	if (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) return "imagebitmap";
	if (typeof Image !== "undefined" && image instanceof Image) return "image";
	if (image && typeof image === "object" && image.data && image.width && image.height) return "data";
	return null;
}

//#endregion
//#region node_modules/@loaders.gl/images/dist/lib/parsers/svg-utils.js
var SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
var SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
function isSVG(url) {
	return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
}
function getBlobOrSVGDataUrl(arrayBuffer, url) {
	if (isSVG(url)) {
		let xmlText = new TextDecoder().decode(arrayBuffer);
		try {
			if (typeof unescape === "function" && typeof encodeURIComponent === "function") xmlText = unescape(encodeURIComponent(xmlText));
		} catch (error) {
			throw new Error(error.message);
		}
		return `data:image/svg+xml;base64,${btoa(xmlText)}`;
	}
	return getBlob(arrayBuffer, url);
}
function getBlob(arrayBuffer, url) {
	if (isSVG(url)) throw new Error("SVG cannot be parsed directly to imagebitmap");
	return new Blob([new Uint8Array(arrayBuffer)]);
}

//#endregion
//#region node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-image.js
async function parseToImage(arrayBuffer, options, url) {
	const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);
	const URL$1 = self.URL || self.webkitURL;
	const objectUrl = typeof blobOrDataUrl !== "string" && URL$1.createObjectURL(blobOrDataUrl);
	try {
		return await loadToImage(objectUrl || blobOrDataUrl, options);
	} finally {
		if (objectUrl) URL$1.revokeObjectURL(objectUrl);
	}
}
async function loadToImage(url, options) {
	const image = new Image();
	image.src = url;
	if (options.image && options.image.decode && image.decode) {
		await image.decode();
		return image;
	}
	return await new Promise((resolve, reject) => {
		try {
			image.onload = () => resolve(image);
			image.onerror = (error) => {
				const message = error instanceof Error ? error.message : "error";
				reject(new Error(message));
			};
		} catch (error) {
			reject(error);
		}
	});
}

//#endregion
//#region node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-image-bitmap.js
var EMPTY_OBJECT = {};
var imagebitmapOptionsSupported = true;
/**
* Asynchronously parses an array buffer into an ImageBitmap - this contains the decoded data
* ImageBitmaps are supported on worker threads, but not supported on Edge, IE11 and Safari
* https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap#Browser_compatibility
*
* TODO - createImageBitmap supports source rect (5 param overload), pass through?
*/
async function parseToImageBitmap(arrayBuffer, options, url) {
	let blob;
	if (isSVG(url)) blob = await parseToImage(arrayBuffer, options, url);
	else blob = getBlob(arrayBuffer, url);
	const imagebitmapOptions = options && options.imagebitmap;
	return await safeCreateImageBitmap(blob, imagebitmapOptions);
}
/**
* Safely creates an imageBitmap with options
* *
* Firefox crashes if imagebitmapOptions is supplied
* Avoid supplying if not provided or supported, remember if not supported
*/
async function safeCreateImageBitmap(blob, imagebitmapOptions = null) {
	if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) imagebitmapOptions = null;
	if (imagebitmapOptions) try {
		return await createImageBitmap(blob, imagebitmapOptions);
	} catch (error) {
		console.warn(error);
		imagebitmapOptionsSupported = false;
	}
	return await createImageBitmap(blob);
}
function isEmptyObject(object) {
	for (const key in object || EMPTY_OBJECT) return false;
	return true;
}

//#endregion
//#region node_modules/@loaders.gl/images/dist/lib/category-api/parse-isobmff-binary.js
/**
* Tests if a buffer is in ISO base media file format (ISOBMFF) @see https://en.wikipedia.org/wiki/ISO_base_media_file_format
* (ISOBMFF is a media container standard based on the Apple QuickTime container format)
*/
function getISOBMFFMediaType(buffer) {
	if (!checkString(buffer, "ftyp", 4)) return null;
	if ((buffer[8] & 96) === 0) return null;
	return decodeMajorBrand(buffer);
}
/**
* brands explained @see https://github.com/strukturag/libheif/issues/83
* code adapted from @see https://github.com/sindresorhus/file-type/blob/main/core.js#L489-L492
*/
function decodeMajorBrand(buffer) {
	switch (getUTF8String(buffer, 8, 12).replace("\0", " ").trim()) {
		case "avif":
		case "avis": return {
			extension: "avif",
			mimeType: "image/avif"
		};
		default: return null;
	}
}
/** Interpret a chunk of bytes as a UTF8 string */
function getUTF8String(array, start, end) {
	return String.fromCharCode(...array.slice(start, end));
}
function stringToBytes(string) {
	return [...string].map((character) => character.charCodeAt(0));
}
function checkString(buffer, header, offset = 0) {
	const headerBytes = stringToBytes(header);
	for (let i$1 = 0; i$1 < headerBytes.length; ++i$1) if (headerBytes[i$1] !== buffer[i$1 + offset]) return false;
	return true;
}

//#endregion
//#region node_modules/@loaders.gl/images/dist/lib/category-api/binary-image-api.js
var BIG_ENDIAN = false;
var LITTLE_ENDIAN = true;
/**
* Extracts `{mimeType, width and height}` from a memory buffer containing a known image format
* Currently supports `image/png`, `image/jpeg`, `image/bmp` and `image/gif`.
* @param binaryData: DataView | ArrayBuffer image file memory to parse
* @returns metadata or null if memory is not a valid image file format layout.
*/
function getBinaryImageMetadata(binaryData) {
	const dataView = toDataView(binaryData);
	return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView) || getISOBMFFMetadata(dataView);
}
function getISOBMFFMetadata(binaryData) {
	const mediaType = getISOBMFFMediaType(new Uint8Array(binaryData instanceof DataView ? binaryData.buffer : binaryData));
	if (!mediaType) return null;
	return {
		mimeType: mediaType.mimeType,
		width: 0,
		height: 0
	};
}
function getPngMetadata(binaryData) {
	const dataView = toDataView(binaryData);
	if (!(dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 2303741511)) return null;
	return {
		mimeType: "image/png",
		width: dataView.getUint32(16, BIG_ENDIAN),
		height: dataView.getUint32(20, BIG_ENDIAN)
	};
}
function getGifMetadata(binaryData) {
	const dataView = toDataView(binaryData);
	if (!(dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 1195984440)) return null;
	return {
		mimeType: "image/gif",
		width: dataView.getUint16(6, LITTLE_ENDIAN),
		height: dataView.getUint16(8, LITTLE_ENDIAN)
	};
}
function getBmpMetadata(binaryData) {
	const dataView = toDataView(binaryData);
	if (!(dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 16973 && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength)) return null;
	return {
		mimeType: "image/bmp",
		width: dataView.getUint32(18, LITTLE_ENDIAN),
		height: dataView.getUint32(22, LITTLE_ENDIAN)
	};
}
function getJpegMetadata(binaryData) {
	const dataView = toDataView(binaryData);
	if (!(dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 65496 && dataView.getUint8(2) === 255)) return null;
	const { tableMarkers, sofMarkers } = getJpegMarkers();
	let i$1 = 2;
	while (i$1 + 9 < dataView.byteLength) {
		const marker = dataView.getUint16(i$1, BIG_ENDIAN);
		if (sofMarkers.has(marker)) return {
			mimeType: "image/jpeg",
			height: dataView.getUint16(i$1 + 5, BIG_ENDIAN),
			width: dataView.getUint16(i$1 + 7, BIG_ENDIAN)
		};
		if (!tableMarkers.has(marker)) return null;
		i$1 += 2;
		i$1 += dataView.getUint16(i$1, BIG_ENDIAN);
	}
	return null;
}
function getJpegMarkers() {
	const tableMarkers = new Set([
		65499,
		65476,
		65484,
		65501,
		65534
	]);
	for (let i$1 = 65504; i$1 < 65520; ++i$1) tableMarkers.add(i$1);
	return {
		tableMarkers,
		sofMarkers: new Set([
			65472,
			65473,
			65474,
			65475,
			65477,
			65478,
			65479,
			65481,
			65482,
			65483,
			65485,
			65486,
			65487,
			65502
		])
	};
}
function toDataView(data) {
	if (data instanceof DataView) return data;
	if (ArrayBuffer.isView(data)) return new DataView(data.buffer);
	if (data instanceof ArrayBuffer) return new DataView(data);
	throw new Error("toDataView");
}

//#endregion
//#region node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-node-image.js
async function parseToNodeImage(arrayBuffer, options) {
	const { mimeType } = getBinaryImageMetadata(arrayBuffer) || {};
	const parseImageNode$1 = globalThis.loaders?.parseImageNode;
	assert$4(parseImageNode$1);
	return await parseImageNode$1(arrayBuffer, mimeType);
}

//#endregion
//#region node_modules/@loaders.gl/images/dist/lib/parsers/parse-image.js
async function parseImage(arrayBuffer, options, context) {
	options = options || {};
	const imageType = (options.image || {}).type || "auto";
	const { url } = context || {};
	const loadType = getLoadableImageType(imageType);
	let image;
	switch (loadType) {
		case "imagebitmap":
			image = await parseToImageBitmap(arrayBuffer, options, url);
			break;
		case "image":
			image = await parseToImage(arrayBuffer, options, url);
			break;
		case "data":
			image = await parseToNodeImage(arrayBuffer, options);
			break;
		default: assert$4(false);
	}
	if (imageType === "data") image = getImageData(image);
	return image;
}
function getLoadableImageType(type) {
	switch (type) {
		case "auto":
		case "data": return getDefaultImageType();
		default:
			isImageTypeSupported(type);
			return type;
	}
}

//#endregion
//#region node_modules/@loaders.gl/images/dist/image-loader.js
var EXTENSIONS = [
	"png",
	"jpg",
	"jpeg",
	"gif",
	"webp",
	"bmp",
	"ico",
	"svg",
	"avif"
];
var MIME_TYPES = [
	"image/png",
	"image/jpeg",
	"image/gif",
	"image/webp",
	"image/avif",
	"image/bmp",
	"image/vnd.microsoft.icon",
	"image/svg+xml"
];
var DEFAULT_IMAGE_LOADER_OPTIONS = { image: {
	type: "auto",
	decode: true
} };
/**
* Loads a platform-specific image type
* Note: This type can be used as input data to WebGL texture creation
*/
const ImageLoader = {
	dataType: null,
	batchType: null,
	id: "image",
	module: "images",
	name: "Images",
	version: VERSION$1,
	mimeTypes: MIME_TYPES,
	extensions: EXTENSIONS,
	parse: parseImage,
	tests: [(arrayBuffer) => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer)))],
	options: DEFAULT_IMAGE_LOADER_OPTIONS
};

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/log.js
var defaultLogger = new Log({ id: "deck" });
var log_default = defaultLogger;

//#endregion
//#region node_modules/@deck.gl/core/dist/debug/loggers.js
var logState = {
	attributeUpdateStart: -1,
	attributeManagerUpdateStart: -1,
	attributeUpdateMessages: []
};
var LOG_LEVEL_MAJOR_UPDATE = 1;
var LOG_LEVEL_MINOR_UPDATE = 2;
var LOG_LEVEL_UPDATE_DETAIL = 3;
var LOG_LEVEL_INFO = 4;
var LOG_LEVEL_DRAW = 2;
const getLoggers = (log$2) => ({
	"layer.changeFlag": (layer, key, flags) => {
		log$2.log(LOG_LEVEL_UPDATE_DETAIL, `${layer.id} ${key}: `, flags[key])();
	},
	"layer.initialize": (layer) => {
		log$2.log(LOG_LEVEL_MAJOR_UPDATE, `Initializing ${layer}`)();
	},
	"layer.update": (layer, needsUpdate) => {
		if (needsUpdate) {
			const flags = layer.getChangeFlags();
			log$2.log(LOG_LEVEL_MINOR_UPDATE, `Updating ${layer} because: ${Object.keys(flags).filter((key) => flags[key]).join(", ")}`)();
		} else log$2.log(LOG_LEVEL_INFO, `${layer} does not need update`)();
	},
	"layer.matched": (layer, changed) => {
		if (changed) log$2.log(LOG_LEVEL_INFO, `Matched ${layer}, state transfered`)();
	},
	"layer.finalize": (layer) => {
		log$2.log(LOG_LEVEL_MAJOR_UPDATE, `Finalizing ${layer}`)();
	},
	"compositeLayer.renderLayers": (layer, updated, subLayers) => {
		if (updated) log$2.log(LOG_LEVEL_MINOR_UPDATE, `Composite layer rendered new subLayers ${layer}`, subLayers)();
		else log$2.log(LOG_LEVEL_INFO, `Composite layer reused subLayers ${layer}`, subLayers)();
	},
	"layerManager.setLayers": (layerManager, updated, layers) => {
		if (updated) log$2.log(LOG_LEVEL_MINOR_UPDATE, `Updating ${layers.length} deck layers`)();
	},
	"layerManager.activateViewport": (layerManager, viewport) => {
		log$2.log(LOG_LEVEL_UPDATE_DETAIL, "Viewport changed", viewport)();
	},
	"attributeManager.invalidate": (attributeManager, trigger, attributeNames) => {
		log$2.log(LOG_LEVEL_MAJOR_UPDATE, attributeNames ? `invalidated attributes ${attributeNames} (${trigger}) for ${attributeManager.id}` : `invalidated all attributes for ${attributeManager.id}`)();
	},
	"attributeManager.updateStart": (attributeManager) => {
		logState.attributeUpdateMessages.length = 0;
		logState.attributeManagerUpdateStart = Date.now();
	},
	"attributeManager.updateEnd": (attributeManager, numInstances) => {
		const timeMs = Math.round(Date.now() - logState.attributeManagerUpdateStart);
		log$2.groupCollapsed(LOG_LEVEL_MINOR_UPDATE, `Updated attributes for ${numInstances} instances in ${attributeManager.id} in ${timeMs}ms`)();
		for (const updateMessage of logState.attributeUpdateMessages) log$2.log(LOG_LEVEL_UPDATE_DETAIL, updateMessage)();
		log$2.groupEnd(LOG_LEVEL_MINOR_UPDATE)();
	},
	"attribute.updateStart": (attribute) => {
		logState.attributeUpdateStart = Date.now();
	},
	"attribute.allocate": (attribute, numInstances) => {
		const message = `${attribute.id} allocated ${numInstances}`;
		logState.attributeUpdateMessages.push(message);
	},
	"attribute.updateEnd": (attribute, numInstances) => {
		const timeMs = Math.round(Date.now() - logState.attributeUpdateStart);
		const message = `${attribute.id} updated ${numInstances} in ${timeMs}ms`;
		logState.attributeUpdateMessages.push(message);
	},
	"deckRenderer.renderLayers": (deckRenderer, renderStats, opts) => {
		const { pass, redrawReason, stats } = opts;
		for (const status of renderStats) {
			const { totalCount, visibleCount, compositeCount, pickableCount } = status;
			const hiddenCount = totalCount - compositeCount - visibleCount;
			log$2.log(LOG_LEVEL_DRAW, `RENDER #${deckRenderer.renderCount} \
  ${visibleCount} (of ${totalCount} layers) to ${pass} because ${redrawReason} \
  (${hiddenCount} hidden, ${compositeCount} composite ${pickableCount} pickable)`)();
			if (stats) stats.get("Redraw Layers").add(visibleCount);
		}
	}
});

//#endregion
//#region node_modules/@deck.gl/core/dist/debug/index.js
var loggers = {};
loggers = getLoggers(log_default);
function register(handlers) {
	loggers = handlers;
}
function debug(eventType, arg1, arg2, arg3) {
	if (log_default.level > 0 && loggers[eventType]) loggers[eventType].call(null, arg1, arg2, arg3);
}

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/json-loader.js
function isJSON(text) {
	const firstChar = text[0];
	const lastChar = text[text.length - 1];
	return firstChar === "{" && lastChar === "}" || firstChar === "[" && lastChar === "]";
}
var json_loader_default = {
	dataType: null,
	batchType: null,
	id: "JSON",
	name: "JSON",
	module: "",
	version: "",
	options: {},
	extensions: ["json", "geojson"],
	mimeTypes: ["application/json", "application/geo+json"],
	testText: isJSON,
	parseTextSync: JSON.parse
};

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/init.js
function checkVersion() {
	const version$1 = "9.2.6";
	const existingVersion = globalThis.deck && globalThis.deck.VERSION;
	if (existingVersion && existingVersion !== version$1) throw new Error(`deck.gl - multiple versions detected: ${existingVersion} vs ${version$1}`);
	if (!existingVersion) {
		log_default.log(1, `deck.gl ${version$1}`)();
		globalThis.deck = {
			...globalThis.deck,
			VERSION: version$1,
			version: version$1,
			log: log_default,
			_registerLoggers: register
		};
		registerLoaders([json_loader_default, [ImageLoader, { imagebitmap: { premultiplyAlpha: "none" } }]]);
	}
	return version$1;
}
const VERSION = checkVersion();

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/lib/utils/assert.js
function assert$3(condition, message) {
	if (!condition) throw new Error(message || "shadertools: assertion failed.");
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/lib/filters/prop-types.js
/** Minimal validators for number and array types */
var DEFAULT_PROP_VALIDATORS = {
	number: {
		type: "number",
		validate(value, propType) {
			return Number.isFinite(value) && typeof propType === "object" && (propType.max === void 0 || value <= propType.max) && (propType.min === void 0 || value >= propType.min);
		}
	},
	array: {
		type: "array",
		validate(value, propType) {
			return Array.isArray(value) || ArrayBuffer.isView(value);
		}
	}
};
/**
* Parse a list of property types into property definitions that can be used to validate
* values passed in by applications.
* @param propTypes
* @returns
*/
function makePropValidators(propTypes) {
	const propValidators = {};
	for (const [name, propType] of Object.entries(propTypes)) propValidators[name] = makePropValidator(propType);
	return propValidators;
}
/**
* Creates a property validator for a prop type. Either contains:
* - a valid prop type object ({type, ...})
* - or just a default value, in which case type and name inference is used
*/
function makePropValidator(propType) {
	let type = getTypeOf$1(propType);
	if (type !== "object") return {
		value: propType,
		...DEFAULT_PROP_VALIDATORS[type],
		type
	};
	if (typeof propType === "object") {
		if (!propType) return {
			type: "object",
			value: null
		};
		if (propType.type !== void 0) return {
			...propType,
			...DEFAULT_PROP_VALIDATORS[propType.type],
			type: propType.type
		};
		if (propType.value === void 0) return {
			type: "object",
			value: propType
		};
		type = getTypeOf$1(propType.value);
		return {
			...propType,
			...DEFAULT_PROP_VALIDATORS[type],
			type
		};
	}
	throw new Error("props");
}
/**
* "improved" version of javascript typeof that can distinguish arrays and null values
*/
function getTypeOf$1(value) {
	if (Array.isArray(value) || ArrayBuffer.isView(value)) return "array";
	return typeof value;
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/module-injectors.js
const MODULE_INJECTORS_VS = `\
#ifdef MODULE_LOGDEPTH
  logdepth_adjustPosition(gl_Position);
#endif
`;
const MODULE_INJECTORS_FS = `\
#ifdef MODULE_MATERIAL
  fragColor = material_filterColor(fragColor);
#endif

#ifdef MODULE_LIGHTING
  fragColor = lighting_filterColor(fragColor);
#endif

#ifdef MODULE_FOG
  fragColor = fog_filterColor(fragColor);
#endif

#ifdef MODULE_PICKING
  fragColor = picking_filterHighlightColor(fragColor);
  fragColor = picking_filterPickingColor(fragColor);
#endif

#ifdef MODULE_LOGDEPTH
  logdepth_setFragDepth();
#endif
`;

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/shader-injections.js
var MODULE_INJECTORS = {
	vertex: MODULE_INJECTORS_VS,
	fragment: MODULE_INJECTORS_FS
};
var REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
var REGEX_END_OF_MAIN = /}\n?[^{}]*$/;
var fragments = [];
const DECLARATION_INJECT_MARKER = "__LUMA_INJECT_DECLARATIONS__";
/**
*
*/
function normalizeInjections(injections) {
	const result = {
		vertex: {},
		fragment: {}
	};
	for (const hook in injections) {
		let injection = injections[hook];
		const stage = getHookStage(hook);
		if (typeof injection === "string") injection = {
			order: 0,
			injection
		};
		result[stage][hook] = injection;
	}
	return result;
}
function getHookStage(hook) {
	const type = hook.slice(0, 2);
	switch (type) {
		case "vs": return "vertex";
		case "fs": return "fragment";
		default: throw new Error(type);
	}
}
/**
// A minimal shader injection/templating system.
// RFC: https://github.com/visgl/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/shader-injection-rfc.md
* @param source
* @param type
* @param inject
* @param injectStandardStubs
* @returns
*/
function injectShader(source$2, stage, inject, injectStandardStubs = false) {
	const isVertex = stage === "vertex";
	for (const key in inject) {
		const fragmentData = inject[key];
		fragmentData.sort((a$1, b$1) => a$1.order - b$1.order);
		fragments.length = fragmentData.length;
		for (let i$1 = 0, len$1 = fragmentData.length; i$1 < len$1; ++i$1) fragments[i$1] = fragmentData[i$1].injection;
		const fragmentString = `${fragments.join("\n")}\n`;
		switch (key) {
			case "vs:#decl":
				if (isVertex) source$2 = source$2.replace(DECLARATION_INJECT_MARKER, fragmentString);
				break;
			case "vs:#main-start":
				if (isVertex) source$2 = source$2.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
				break;
			case "vs:#main-end":
				if (isVertex) source$2 = source$2.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
				break;
			case "fs:#decl":
				if (!isVertex) source$2 = source$2.replace(DECLARATION_INJECT_MARKER, fragmentString);
				break;
			case "fs:#main-start":
				if (!isVertex) source$2 = source$2.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
				break;
			case "fs:#main-end":
				if (!isVertex) source$2 = source$2.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
				break;
			default: source$2 = source$2.replace(key, (match) => match + fragmentString);
		}
	}
	source$2 = source$2.replace(DECLARATION_INJECT_MARKER, "");
	if (injectStandardStubs) source$2 = source$2.replace(/\}\s*$/, (match) => match + MODULE_INJECTORS[stage]);
	return source$2;
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/lib/shader-module/shader-module.js
function initializeShaderModules(modules) {
	modules.map((module) => initializeShaderModule(module));
}
function initializeShaderModule(module) {
	if (module.instance) return;
	initializeShaderModules(module.dependencies || []);
	const { propTypes = {}, deprecations = [], inject = {} } = module;
	const instance = {
		normalizedInjections: normalizeInjections(inject),
		parsedDeprecations: parseDeprecationDefinitions(deprecations)
	};
	if (propTypes) instance.propValidators = makePropValidators(propTypes);
	module.instance = instance;
	let defaultProps$2 = {};
	if (propTypes) defaultProps$2 = Object.entries(propTypes).reduce((obj, [key, propType]) => {
		const value = propType?.value;
		if (value) obj[key] = value;
		return obj;
	}, {});
	module.defaultUniforms = {
		...module.defaultUniforms,
		...defaultProps$2
	};
}
function checkShaderModuleDeprecations(shaderModule, shaderSource, log$2) {
	shaderModule.deprecations?.forEach((def) => {
		if (def.regex?.test(shaderSource)) if (def.deprecated) log$2.deprecated(def.old, def.new)();
		else log$2.removed(def.old, def.new)();
	});
}
function parseDeprecationDefinitions(deprecations) {
	deprecations.forEach((def) => {
		switch (def.type) {
			case "function":
				def.regex = /* @__PURE__ */ new RegExp(`\\b${def.old}\\(`);
				break;
			default: def.regex = /* @__PURE__ */ new RegExp(`${def.type} ${def.old};`);
		}
	});
	return deprecations;
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/lib/shader-module/shader-module-dependencies.js
/**
* Takes a list of shader module names and returns a new list of
* shader module names that includes all dependencies, sorted so
* that modules that are dependencies of other modules come first.
*
* If the shader glsl code from the returned modules is concatenated
* in the reverse order, it is guaranteed that all functions be resolved and
* that all function and variable definitions come before use.
*
* @param modules - Array of modules (inline modules or module names)
* @return - Array of modules
*/
function getShaderModuleDependencies(modules) {
	initializeShaderModules(modules);
	const moduleMap = {};
	const moduleDepth = {};
	getDependencyGraph({
		modules,
		level: 0,
		moduleMap,
		moduleDepth
	});
	const dependencies = Object.keys(moduleDepth).sort((a$1, b$1) => moduleDepth[b$1] - moduleDepth[a$1]).map((name) => moduleMap[name]);
	initializeShaderModules(dependencies);
	return dependencies;
}
/**
* Recursively checks module dependencies to calculate dependency level of each module.
*
* @param options.modules - Array of modules
* @param options.level - Current level
* @param options.moduleMap -
* @param options.moduleDepth - Current level
* @return - Map of module name to its level
*/
function getDependencyGraph(options) {
	const { modules, level, moduleMap, moduleDepth } = options;
	if (level >= 5) throw new Error("Possible loop in shader dependency graph");
	for (const module of modules) {
		moduleMap[module.name] = module;
		if (moduleDepth[module.name] === void 0 || moduleDepth[module.name] < level) moduleDepth[module.name] = level;
	}
	for (const module of modules) if (module.dependencies) getDependencyGraph({
		modules: module.dependencies,
		level: level + 1,
		moduleMap,
		moduleDepth
	});
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/platform-defines.js
/** Adds defines to help identify GPU architecture / platform */
function getPlatformShaderDefines(platformInfo) {
	switch (platformInfo?.gpu.toLowerCase()) {
		case "apple": return `\
#define APPLE_GPU
// Apple optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
		case "nvidia": return `\
#define NVIDIA_GPU
// Nvidia optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`;
		case "intel": return `\
#define INTEL_GPU
// Intel optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Intel's built-in 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
		case "amd": return `\
#define AMD_GPU
`;
		default: return `\
#define DEFAULT_GPU
// Prevent driver from optimizing away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Headless Chrome's software shader 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// If the GPU doesn't have full 32 bits precision, will causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
	}
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/lib/shader-transpiler/transpile-glsl-shader.js
/**
* Transpiles GLSL 3.00 shader source code to target GLSL version (3.00 or 1.00)
*
* @note We always run transpiler even if same version e.g. 3.00 => 3.00
* @note For texture sampling transpilation, apps need to use non-standard texture* calls in GLSL 3.00 source
* RFC: https://github.com/visgl/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/portable-glsl-300-rfc.md
*/
function transpileGLSLShader(source$2, stage) {
	if (Number(source$2.match(/^#version[ \t]+(\d+)/m)?.[1] || 100) !== 300) throw new Error("luma.gl v9 only supports GLSL 3.00 shader sources");
	switch (stage) {
		case "vertex":
			source$2 = convertShader(source$2, ES300_VERTEX_REPLACEMENTS);
			return source$2;
		case "fragment":
			source$2 = convertShader(source$2, ES300_FRAGMENT_REPLACEMENTS);
			return source$2;
		default: throw new Error(stage);
	}
}
/** Simple regex replacements for GLSL ES 1.00 syntax that has changed in GLSL ES 3.00 */
var ES300_REPLACEMENTS = [
	[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, "#version 300 es\n"],
	[/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("],
	[/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]
];
var ES300_VERTEX_REPLACEMENTS = [
	...ES300_REPLACEMENTS,
	[makeVariableTextRegExp("attribute"), "in $1"],
	[makeVariableTextRegExp("varying"), "out $1"]
];
/** Simple regex replacements for GLSL ES 1.00 syntax that has changed in GLSL ES 3.00 */
var ES300_FRAGMENT_REPLACEMENTS = [...ES300_REPLACEMENTS, [makeVariableTextRegExp("varying"), "in $1"]];
function convertShader(source$2, replacements) {
	for (const [pattern, replacement] of replacements) source$2 = source$2.replace(pattern, replacement);
	return source$2;
}
/**
* Creates a regexp that tests for a specific variable type
* @example
*   should match:
*     in float weight;
*     out vec4 positions[2];
*   should not match:
*     void f(out float a, in float b) {}
*/
function makeVariableTextRegExp(qualifier) {
	return new RegExp(`\\b${qualifier}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`, "g");
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/shader-hooks.js
/** Generate hook source code */
function getShaderHooks(hookFunctions, hookInjections) {
	let result = "";
	for (const hookName in hookFunctions) {
		const hookFunction = hookFunctions[hookName];
		result += `void ${hookFunction.signature} {\n`;
		if (hookFunction.header) result += `  ${hookFunction.header}`;
		if (hookInjections[hookName]) {
			const injections = hookInjections[hookName];
			injections.sort((a$1, b$1) => a$1.order - b$1.order);
			for (const injection of injections) result += `  ${injection.injection}\n`;
		}
		if (hookFunction.footer) result += `  ${hookFunction.footer}`;
		result += "}\n";
	}
	return result;
}
/**
* Parse string based hook functions
* And split per shader
*/
function normalizeShaderHooks(hookFunctions) {
	const result = {
		vertex: {},
		fragment: {}
	};
	for (const hookFunction of hookFunctions) {
		let opts;
		let hook;
		if (typeof hookFunction !== "string") {
			opts = hookFunction;
			hook = opts.hook;
		} else {
			opts = {};
			hook = hookFunction;
		}
		hook = hook.trim();
		const [shaderStage, signature] = hook.split(":");
		const name = hook.replace(/\(.+/, "");
		const normalizedHook = Object.assign(opts, { signature });
		switch (shaderStage) {
			case "vs":
				result.vertex[name] = normalizedHook;
				break;
			case "fs":
				result.fragment[name] = normalizedHook;
				break;
			default: throw new Error(shaderStage);
		}
	}
	return result;
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/lib/glsl-utils/get-shader-info.js
/** Extracts information from shader source code */
function getShaderInfo(source$2, defaultName) {
	return {
		name: getShaderName(source$2, defaultName),
		language: "glsl",
		version: getShaderVersion(source$2)
	};
}
/** Extracts GLSLIFY style naming of shaders: `#define SHADER_NAME ...` */
function getShaderName(shader, defaultName = "unnamed") {
	const match = /#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/.exec(shader);
	return match ? match[1] : defaultName;
}
/** returns GLSL shader version of given shader string */
function getShaderVersion(source$2) {
	let version$1 = 100;
	const words = source$2.match(/[^\s]+/g);
	if (words && words.length >= 2 && words[0] === "#version") {
		const parsedVersion = parseInt(words[1], 10);
		if (Number.isFinite(parsedVersion)) version$1 = parsedVersion;
	}
	if (version$1 !== 100 && version$1 !== 300) throw new Error(`Invalid GLSL version ${version$1}`);
	return version$1;
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/assemble-shaders.js
var INJECT_SHADER_DECLARATIONS = `\n\n${DECLARATION_INJECT_MARKER}\n`;
/**
* Precision prologue to inject before functions are injected in shader
* TODO - extract any existing prologue in the fragment source and move it up...
*/
var FRAGMENT_SHADER_PROLOGUE = `\
precision highp float;
`;
/**
* Inject a list of shader modules into a single shader source for WGSL
*/
function assembleWGSLShader(options) {
	const modules = getShaderModuleDependencies(options.modules || []);
	return {
		source: assembleShaderWGSL(options.platformInfo, {
			...options,
			source: options.source,
			stage: "vertex",
			modules
		}),
		getUniforms: assembleGetUniforms(modules)
	};
}
/**
* Injects dependent shader module sources into pair of main vertex/fragment shader sources for GLSL
*/
function assembleGLSLShaderPair(options) {
	const { vs: vs$6, fs: fs$4 } = options;
	const modules = getShaderModuleDependencies(options.modules || []);
	return {
		vs: assembleShaderGLSL(options.platformInfo, {
			...options,
			source: vs$6,
			stage: "vertex",
			modules
		}),
		fs: assembleShaderGLSL(options.platformInfo, {
			...options,
			source: fs$4,
			stage: "fragment",
			modules
		}),
		getUniforms: assembleGetUniforms(modules)
	};
}
/**
* Pulls together complete source code for either a vertex or a fragment shader
* adding prologues, requested module chunks, and any final injections.
* @param gl
* @param options
* @returns
*/
function assembleShaderWGSL(platformInfo, options) {
	const { source: source$2, stage, modules, hookFunctions = [], inject = {}, log: log$2 } = options;
	assert$3(typeof source$2 === "string", "shader source must be a string");
	const coreSource = source$2;
	let assembledSource = "";
	const hookFunctionMap = normalizeShaderHooks(hookFunctions);
	const hookInjections = {};
	const declInjections = {};
	const mainInjections = {};
	for (const key in inject) {
		const injection = typeof inject[key] === "string" ? {
			injection: inject[key],
			order: 0
		} : inject[key];
		const match = /^(v|f)s:(#)?([\w-]+)$/.exec(key);
		if (match) {
			const hash = match[2];
			const name = match[3];
			if (hash) if (name === "decl") declInjections[key] = [injection];
			else mainInjections[key] = [injection];
			else hookInjections[key] = [injection];
		} else mainInjections[key] = [injection];
	}
	const modulesToInject = modules;
	for (const module of modulesToInject) {
		if (log$2) checkShaderModuleDeprecations(module, coreSource, log$2);
		const moduleSource = getShaderModuleSource(module, "wgsl");
		assembledSource += moduleSource;
		const injections = module.injections?.[stage] || {};
		for (const key in injections) {
			const match = /^(v|f)s:#([\w-]+)$/.exec(key);
			if (match) {
				const injectionType = match[2] === "decl" ? declInjections : mainInjections;
				injectionType[key] = injectionType[key] || [];
				injectionType[key].push(injections[key]);
			} else {
				hookInjections[key] = hookInjections[key] || [];
				hookInjections[key].push(injections[key]);
			}
		}
	}
	assembledSource += INJECT_SHADER_DECLARATIONS;
	assembledSource = injectShader(assembledSource, stage, declInjections);
	assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);
	assembledSource += coreSource;
	assembledSource = injectShader(assembledSource, stage, mainInjections);
	return assembledSource;
}
/**
* Pulls together complete source code for either a vertex or a fragment shader
* adding prologues, requested module chunks, and any final injections.
* @param gl
* @param options
* @returns
*/
function assembleShaderGLSL(platformInfo, options) {
	const { source: source$2, stage, language = "glsl", modules, defines: defines$1 = {}, hookFunctions = [], inject = {}, prologue = true, log: log$2 } = options;
	assert$3(typeof source$2 === "string", "shader source must be a string");
	const sourceVersion = language === "glsl" ? getShaderInfo(source$2).version : -1;
	const targetVersion = platformInfo.shaderLanguageVersion;
	const sourceVersionDirective = sourceVersion === 100 ? "#version 100" : "#version 300 es";
	const coreSource = source$2.split("\n").slice(1).join("\n");
	const allDefines = {};
	modules.forEach((module) => {
		Object.assign(allDefines, module.defines);
	});
	Object.assign(allDefines, defines$1);
	let assembledSource = "";
	switch (language) {
		case "wgsl": break;
		case "glsl":
			assembledSource = prologue ? `\
${sourceVersionDirective}

// ----- PROLOGUE -------------------------
${`#define SHADER_TYPE_${stage.toUpperCase()}`}

${getPlatformShaderDefines(platformInfo)}
${stage === "fragment" ? FRAGMENT_SHADER_PROLOGUE : ""}

// ----- APPLICATION DEFINES -------------------------

${getApplicationDefines(allDefines)}

` : `${sourceVersionDirective}
`;
			break;
	}
	const hookFunctionMap = normalizeShaderHooks(hookFunctions);
	const hookInjections = {};
	const declInjections = {};
	const mainInjections = {};
	for (const key in inject) {
		const injection = typeof inject[key] === "string" ? {
			injection: inject[key],
			order: 0
		} : inject[key];
		const match = /^(v|f)s:(#)?([\w-]+)$/.exec(key);
		if (match) {
			const hash = match[2];
			const name = match[3];
			if (hash) if (name === "decl") declInjections[key] = [injection];
			else mainInjections[key] = [injection];
			else hookInjections[key] = [injection];
		} else mainInjections[key] = [injection];
	}
	for (const module of modules) {
		if (log$2) checkShaderModuleDeprecations(module, coreSource, log$2);
		const moduleSource = getShaderModuleSource(module, stage);
		assembledSource += moduleSource;
		const injections = module.instance?.normalizedInjections[stage] || {};
		for (const key in injections) {
			const match = /^(v|f)s:#([\w-]+)$/.exec(key);
			if (match) {
				const injectionType = match[2] === "decl" ? declInjections : mainInjections;
				injectionType[key] = injectionType[key] || [];
				injectionType[key].push(injections[key]);
			} else {
				hookInjections[key] = hookInjections[key] || [];
				hookInjections[key].push(injections[key]);
			}
		}
	}
	assembledSource += "// ----- MAIN SHADER SOURCE -------------------------";
	assembledSource += INJECT_SHADER_DECLARATIONS;
	assembledSource = injectShader(assembledSource, stage, declInjections);
	assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);
	assembledSource += coreSource;
	assembledSource = injectShader(assembledSource, stage, mainInjections);
	if (language === "glsl" && sourceVersion !== targetVersion) assembledSource = transpileGLSLShader(assembledSource, stage);
	return assembledSource.trim();
}
/**
* Returns a combined `getUniforms` covering the options for all the modules,
* the created function will pass on options to the inidividual `getUniforms`
* function of each shader module and combine the results into one object that
* can be passed to setUniforms.
* @param modules
* @returns
*/
function assembleGetUniforms(modules) {
	return function getUniforms$3(opts) {
		const uniforms = {};
		for (const module of modules) {
			const moduleUniforms = module.getUniforms?.(opts, uniforms);
			Object.assign(uniforms, moduleUniforms);
		}
		return uniforms;
	};
}
/**
* NOTE: Removed as id injection defeated caching of shaders
*
* Generate "glslify-compatible" SHADER_NAME defines
* These are understood by the GLSL error parsing function
* If id is provided and no SHADER_NAME constant is present in source, create one
unction getShaderNameDefine(options: {
id?: string;
source: string;
stage: 'vertex' | 'fragment';
}): string {
const {id, source, stage} = options;
const injectShaderName = id && source.indexOf('SHADER_NAME') === -1;
return injectShaderName
? `
#define SHADER_NAME ${id}_${stage}`
: '';
}
*/
/** Generates application defines from an object of key value pairs */
function getApplicationDefines(defines$1 = {}) {
	let sourceText = "";
	for (const define in defines$1) {
		const value = defines$1[define];
		if (value || Number.isFinite(value)) sourceText += `#define ${define.toUpperCase()} ${defines$1[define]}\n`;
	}
	return sourceText;
}
/** Extracts the source code chunk for the specified shader type from the named shader module */
function getShaderModuleSource(module, stage) {
	let moduleSource;
	switch (stage) {
		case "vertex":
			moduleSource = module.vs || "";
			break;
		case "fragment":
			moduleSource = module.fs || "";
			break;
		case "wgsl":
			moduleSource = module.source || "";
			break;
		default: assert$3(false);
	}
	if (!module.name) throw new Error("Shader module must have a name");
	const moduleName = module.name.toUpperCase().replace(/[^0-9a-z]/gi, "_");
	let source$2 = `\
// ----- MODULE ${module.name} ---------------

`;
	if (stage !== "wgsl") source$2 += `#define MODULE_${moduleName}\n`;
	source$2 += `${moduleSource}\n`;
	return source$2;
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/lib/preprocessor/preprocessor.js
var IFDEF_REGEXP = /^\s*\#\s*ifdef\s*([a-zA-Z_]+)\s*$/;
var ENDIF_REGEXP = /^\s*\#\s*endif\s*$/;
function preprocess(source$2, options) {
	const lines = source$2.split("\n");
	const output = [];
	let conditional = true;
	let currentDefine = null;
	for (const line of lines) {
		const matchIf = line.match(IFDEF_REGEXP);
		const matchEnd = line.match(ENDIF_REGEXP);
		if (matchIf) {
			currentDefine = matchIf[1];
			conditional = Boolean(options?.defines?.[currentDefine]);
		} else if (matchEnd) conditional = true;
		else if (conditional) output.push(line);
	}
	return output.join("\n");
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/lib/shader-assembler.js
/**
* A stateful version of `assembleShaders` that can be used to assemble shaders.
* Supports setting of default modules and hooks.
*/
var ShaderAssembler = class ShaderAssembler {
	/** Default ShaderAssembler instance */
	static defaultShaderAssembler;
	/** Hook functions */
	_hookFunctions = [];
	/** Shader modules */
	_defaultModules = [];
	/**
	* A default shader assembler instance - the natural place to register default modules and hooks
	* @returns
	*/
	static getDefaultShaderAssembler() {
		ShaderAssembler.defaultShaderAssembler = ShaderAssembler.defaultShaderAssembler || new ShaderAssembler();
		return ShaderAssembler.defaultShaderAssembler;
	}
	/**
	* Add a default module that does not have to be provided with every call to assembleShaders()
	*/
	addDefaultModule(module) {
		if (!this._defaultModules.find((m$1) => m$1.name === (typeof module === "string" ? module : module.name))) this._defaultModules.push(module);
	}
	/**
	* Remove a default module
	*/
	removeDefaultModule(module) {
		const moduleName = typeof module === "string" ? module : module.name;
		this._defaultModules = this._defaultModules.filter((m$1) => m$1.name !== moduleName);
	}
	/**
	* Register a shader hook
	* @param hook
	* @param opts
	*/
	addShaderHook(hook, opts) {
		if (opts) hook = Object.assign(opts, { hook });
		this._hookFunctions.push(hook);
	}
	/**
	* Assemble a WGSL unified shader
	* @param platformInfo
	* @param props
	* @returns
	*/
	assembleWGSLShader(props) {
		const modules = this._getModuleList(props.modules);
		const hookFunctions = this._hookFunctions;
		const { source: source$2, getUniforms: getUniforms$3 } = assembleWGSLShader({
			...props,
			source: props.source,
			modules,
			hookFunctions
		});
		return {
			source: props.platformInfo.shaderLanguage === "wgsl" ? preprocess(source$2) : source$2,
			getUniforms: getUniforms$3,
			modules
		};
	}
	/**
	* Assemble a pair of shaders into a single shader program
	* @param platformInfo
	* @param props
	* @returns
	*/
	assembleGLSLShaderPair(props) {
		const modules = this._getModuleList(props.modules);
		const hookFunctions = this._hookFunctions;
		return {
			...assembleGLSLShaderPair({
				...props,
				vs: props.vs,
				fs: props.fs,
				modules,
				hookFunctions
			}),
			modules
		};
	}
	/**
	* Dedupe and combine with default modules
	*/
	_getModuleList(appModules = []) {
		const modules = new Array(this._defaultModules.length + appModules.length);
		const seen = {};
		let count$1 = 0;
		for (let i$1 = 0, len$1 = this._defaultModules.length; i$1 < len$1; ++i$1) {
			const module = this._defaultModules[i$1];
			const name = module.name;
			modules[count$1++] = module;
			seen[name] = true;
		}
		for (let i$1 = 0, len$1 = appModules.length; i$1 < len$1; ++i$1) {
			const module = appModules[i$1];
			const name = module.name;
			if (!seen[name]) {
				modules[count$1++] = module;
				seen[name] = true;
			}
		}
		modules.length = count$1;
		initializeShaderModules(modules);
		return modules;
	}
};

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/lib/glsl-utils/shader-utils.js
var FS300 = `#version 300 es\nout vec4 transform_output;
void main() {
  transform_output = vec4(0);
}`;
/**
* Given the shader input and output variable names,
* builds and return a pass through fragment shader.
*/
function getPassthroughFS(options) {
	const { input, inputChannels, output } = options || {};
	if (!input) return FS300;
	if (!inputChannels) throw new Error("inputChannels");
	return `\
#version 300 es
in ${channelCountToType(inputChannels)} ${input};
out vec4 ${output};
void main() {
  ${output} = ${convertToVec4(input, inputChannels)};
}`;
}
function channelCountToType(channels) {
	switch (channels) {
		case 1: return "float";
		case 2: return "vec2";
		case 3: return "vec3";
		case 4: return "vec4";
		default: throw new Error(`invalid channels: ${channels}`);
	}
}
/** Returns glsl instruction for converting to vec4 */
function convertToVec4(variable, channels) {
	switch (channels) {
		case 1: return `vec4(${variable}, 0.0, 0.0, 1.0)`;
		case 2: return `vec4(${variable}, 0.0, 1.0)`;
		case 3: return `vec4(${variable}, 1.0)`;
		case 4: return variable;
		default: throw new Error(`invalid channels: ${channels}`);
	}
}

//#endregion
//#region node_modules/@luma.gl/core/dist/adapter/luma.js
var STARTUP_MESSAGE = "set luma.log.level=1 (or higher) to trace rendering";
var ERROR_MESSAGE = "No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.";
/**
* Entry point to the luma.gl GPU abstraction
* Register WebGPU and/or WebGL adapters (controls application bundle size)
* Run-time selection of the first available Device
*/
var Luma = class Luma {
	static defaultProps = {
		...Device.defaultProps,
		type: "best-available",
		adapters: void 0,
		waitForPageLoad: true
	};
	/** Global stats for all devices */
	stats = lumaStats;
	/**
	* Global log
	*
	* Assign luma.log.level in console to control logging: \
	* 0: none, 1: minimal, 2: verbose, 3: attribute/uniforms, 4: gl logs
	* luma.log.break[], set to gl funcs, luma.log.profile[] set to model names`;
	*/
	log = log;
	/** Version of luma.gl */
	VERSION = "9.2.6";
	spector;
	preregisteredAdapters = /* @__PURE__ */ new Map();
	constructor() {
		if (globalThis.luma) {
			if (globalThis.luma.VERSION !== this.VERSION) {
				log.error(`Found luma.gl ${globalThis.luma.VERSION} while initialzing ${this.VERSION}`)();
				log.error(`'yarn why @luma.gl/core' can help identify the source of the conflict`)();
				throw new Error(`luma.gl - multiple versions detected: see console log`);
			}
			log.error("This version of luma.gl has already been initialized")();
		}
		log.log(1, `${this.VERSION} - ${STARTUP_MESSAGE}`)();
		globalThis.luma = this;
	}
	/** Creates a device. Asynchronously. */
	async createDevice(props_ = {}) {
		const props = {
			...Luma.defaultProps,
			...props_
		};
		const adapter = this.selectAdapter(props.type, props.adapters);
		if (!adapter) throw new Error(ERROR_MESSAGE);
		if (props.waitForPageLoad) await adapter.pageLoaded;
		return await adapter.create(props);
	}
	/**
	* Attach to an existing GPU API handle (WebGL2RenderingContext or GPUDevice).
	* @param handle Externally created WebGL context or WebGPU device
	*/
	async attachDevice(handle, props) {
		const type = this._getTypeFromHandle(handle, props.adapters);
		const adapter = type && this.selectAdapter(type, props.adapters);
		if (!adapter) throw new Error(ERROR_MESSAGE);
		return await adapter?.attach?.(handle, props);
	}
	/**
	* Global adapter registration.
	* @deprecated Use props.adapters instead
	*/
	registerAdapters(adapters) {
		for (const deviceClass of adapters) this.preregisteredAdapters.set(deviceClass.type, deviceClass);
	}
	/** Get type strings for supported Devices */
	getSupportedAdapters(adapters = []) {
		const adapterMap = this._getAdapterMap(adapters);
		return Array.from(adapterMap).map(([, adapter]) => adapter).filter((adapter) => adapter.isSupported?.()).map((adapter) => adapter.type);
	}
	/** Get type strings for best available Device */
	getBestAvailableAdapterType(adapters = []) {
		const KNOWN_ADAPTERS = [
			"webgpu",
			"webgl",
			"null"
		];
		const adapterMap = this._getAdapterMap(adapters);
		for (const type of KNOWN_ADAPTERS) if (adapterMap.get(type)?.isSupported?.()) return type;
		return null;
	}
	/** Select adapter of type from registered adapters */
	selectAdapter(type, adapters = []) {
		let selectedType = type;
		if (type === "best-available") selectedType = this.getBestAvailableAdapterType(adapters);
		const adapterMap = this._getAdapterMap(adapters);
		return selectedType && adapterMap.get(selectedType) || null;
	}
	/**
	* Override `HTMLCanvasContext.getCanvas()` to always create WebGL2 contexts with additional WebGL1 compatibility.
	* Useful when attaching luma to a context from an external library does not support creating WebGL2 contexts.
	*/
	enforceWebGL2(enforce = true, adapters = []) {
		const webgl2Adapter$1 = this._getAdapterMap(adapters).get("webgl");
		if (!webgl2Adapter$1) log.warn("enforceWebGL2: webgl adapter not found")();
		webgl2Adapter$1?.enforceWebGL2?.(enforce);
	}
	/** @deprecated */
	setDefaultDeviceProps(props) {
		Object.assign(Luma.defaultProps, props);
	}
	/** Convert a list of adapters to a map */
	_getAdapterMap(adapters = []) {
		const map$1 = new Map(this.preregisteredAdapters);
		for (const adapter of adapters) map$1.set(adapter.type, adapter);
		return map$1;
	}
	/** Get type of a handle (for attachDevice) */
	_getTypeFromHandle(handle, adapters = []) {
		if (handle instanceof WebGL2RenderingContext) return "webgl";
		if (typeof GPUDevice !== "undefined" && handle instanceof GPUDevice) return "webgpu";
		if (handle?.queue) return "webgpu";
		if (handle === null) return "null";
		if (handle instanceof WebGLRenderingContext) log.warn("WebGL1 is not supported", handle)();
		else log.warn("Unknown handle type", handle)();
		return null;
	}
};
/**
* Entry point to the luma.gl GPU abstraction
* Register WebGPU and/or WebGL adapters (controls application bundle size)
* Run-time selection of the first available Device
*/
const luma = new Luma();

//#endregion
//#region node_modules/@luma.gl/core/dist/adapter/adapter.js
/**
* Create and attach devices for a specific backend.
*/
var Adapter = class {
	/**
	* Page load promise
	* Resolves when the DOM is loaded.
	* @note Since are be limitations on number of `load` event listeners,
	* it is recommended avoid calling this accessor until actually needed.
	* I.e. we don't call it unless you know that you will be looking up a string in the DOM.
	*/
	get pageLoaded() {
		return getPageLoadPromise();
	}
};
var isPage = isBrowser() && typeof document !== "undefined";
var isPageLoaded = () => isPage && document.readyState === "complete";
var pageLoadPromise = null;
/** Returns a promise that resolves when the page is loaded */
function getPageLoadPromise() {
	if (!pageLoadPromise) if (isPageLoaded() || typeof window === "undefined") pageLoadPromise = Promise.resolve();
	else pageLoadPromise = new Promise((resolve) => window.addEventListener("load", () => resolve()));
	return pageLoadPromise;
}

//#endregion
//#region node_modules/@luma.gl/core/dist/adapter/resources/compute-pipeline.js
/**
* A compiled and linked shader program for compute
*/
var ComputePipeline = class ComputePipeline extends Resource$1 {
	get [Symbol.toStringTag]() {
		return "ComputePipeline";
	}
	hash = "";
	/** The merged shader layout */
	shaderLayout;
	constructor(device, props) {
		super(device, props, ComputePipeline.defaultProps);
		this.shaderLayout = props.shaderLayout;
	}
	static defaultProps = {
		...Resource$1.defaultProps,
		shader: void 0,
		entryPoint: void 0,
		constants: {},
		shaderLayout: void 0
	};
};

//#endregion
//#region node_modules/@luma.gl/core/dist/utils/is-array.js
/**
* Check is an array is a typed array
* @param value value to be tested
* @returns input as TypedArray, or null
* @todo this should be provided by @math.gl/types
*/
function isTypedArray$1(value) {
	return ArrayBuffer.isView(value) && !(value instanceof DataView);
}
/**
* Check is an array is a numeric array (typed array or array of numbers)
* @param value value to be tested
* @returns input as NumberArray, or null
* @todo this should be provided by @math.gl/types
*/
function isNumberArray$1(value) {
	if (Array.isArray(value)) return value.length === 0 || typeof value[0] === "number";
	return isTypedArray$1(value);
}

//#endregion
//#region node_modules/@luma.gl/core/dist/portable/uniform-buffer-layout.js
/**
* Smallest buffer size that can be used for uniform buffers.
* TODO - does this depend on device?
*/
var minBufferSize = 1024;
/**
* Std140 layout for uniform buffers
* Supports manual listing of uniforms
*/
var UniformBufferLayout = class {
	layout = {};
	/** number of bytes needed for buffer allocation */
	byteLength;
	/** Create a new UniformBufferLayout given a map of attributes. */
	constructor(uniformTypes, uniformSizes = {}) {
		/** number of 4 byte slots taken */
		let size = 0;
		for (const [key, uniformType] of Object.entries(uniformTypes)) {
			const { type, components } = getVariableShaderTypeInfo(uniformType);
			const count$1 = components * (uniformSizes?.[key] ?? 1);
			size = alignTo(size, count$1);
			const offset = size;
			size += count$1;
			this.layout[key] = {
				type,
				size: count$1,
				offset
			};
		}
		size += (4 - size % 4) % 4;
		const actualByteLength = size * 4;
		this.byteLength = Math.max(actualByteLength, minBufferSize);
	}
	/** Get the data for the complete buffer */
	getData(uniformValues) {
		const arrayBuffer = getScratchArrayBuffer(this.byteLength);
		const typedArrays = {
			i32: new Int32Array(arrayBuffer),
			u32: new Uint32Array(arrayBuffer),
			f32: new Float32Array(arrayBuffer),
			f16: new Uint16Array(arrayBuffer)
		};
		for (const [name, value] of Object.entries(uniformValues)) {
			const uniformLayout = this.layout[name];
			if (!uniformLayout) {
				log.warn(`Supplied uniform value ${name} not present in uniform block layout`)();
				continue;
			}
			const { type, size, offset } = uniformLayout;
			const typedArray = typedArrays[type];
			if (size === 1) {
				if (typeof value !== "number" && typeof value !== "boolean") {
					log.warn(`Supplied value for single component uniform ${name} is not a number: ${value}`)();
					continue;
				}
				typedArray[offset] = Number(value);
			} else {
				if (!isNumberArray$1(value)) {
					log.warn(`Supplied value for multi component / array uniform ${name} is not a numeric array: ${value}`)();
					continue;
				}
				typedArray.set(value, offset);
			}
		}
		return new Uint8Array(arrayBuffer, 0, this.byteLength);
	}
	/** Does this layout have a field with specified name */
	has(name) {
		return Boolean(this.layout[name]);
	}
	/** Get offset and size for a field with specified name */
	get(name) {
		return this.layout[name];
	}
};

//#endregion
//#region node_modules/@luma.gl/core/dist/utils/array-equal.js
/** Test if two arrays are deep equal, with a length limit that defaults to 16 */
function arrayEqual(a$1, b$1, limit = 16) {
	if (a$1 !== b$1) return false;
	const arrayA = a$1;
	const arrayB = b$1;
	if (!isNumberArray$1(arrayA)) return false;
	if (isNumberArray$1(arrayB) && arrayA.length === arrayB.length) {
		for (let i$1 = 0; i$1 < arrayA.length; ++i$1) if (arrayB[i$1] !== arrayA[i$1]) return false;
	}
	return true;
}
/** Copy a value */
function arrayCopy(a$1) {
	if (isNumberArray$1(a$1)) return a$1.slice();
	return a$1;
}

//#endregion
//#region node_modules/@luma.gl/core/dist/portable/uniform-block.js
/**
* A uniform block holds values of the of uniform values for one uniform block / buffer.
* It also does some book keeping on what has changed, to minimize unnecessary writes to uniform buffers.
*/
var UniformBlock = class {
	name;
	uniforms = {};
	modifiedUniforms = {};
	modified = true;
	bindingLayout = {};
	needsRedraw = "initialized";
	constructor(props) {
		this.name = props?.name || "unnamed";
		if (props?.name && props?.shaderLayout) {
			const binding = props?.shaderLayout.bindings?.find((binding_) => binding_.type === "uniform" && binding_.name === props?.name);
			if (!binding) throw new Error(props?.name);
			const uniformBlock$3 = binding;
			for (const uniform of uniformBlock$3.uniforms || []) this.bindingLayout[uniform.name] = uniform;
		}
	}
	/** Set a map of uniforms */
	setUniforms(uniforms) {
		for (const [key, value] of Object.entries(uniforms)) {
			this._setUniform(key, value);
			if (!this.needsRedraw) this.setNeedsRedraw(`${this.name}.${key}=${value}`);
		}
	}
	setNeedsRedraw(reason) {
		this.needsRedraw = this.needsRedraw || reason;
	}
	/** Returns all uniforms */
	getAllUniforms() {
		this.modifiedUniforms = {};
		this.needsRedraw = false;
		return this.uniforms || {};
	}
	/** Set a single uniform */
	_setUniform(key, value) {
		if (arrayEqual(this.uniforms[key], value)) return;
		this.uniforms[key] = arrayCopy(value);
		this.modifiedUniforms[key] = true;
		this.modified = true;
	}
};

//#endregion
//#region node_modules/@luma.gl/core/dist/portable/uniform-store.js
/**
* A uniform store holds a uniform values for one or more uniform blocks,
* - It can generate binary data for any uniform buffer
* - It can manage a uniform buffer for each block
* - It can update managed uniform buffers with a single call
* - It performs some book keeping on what has changed to minimize unnecessary writes to uniform buffers.
*/
var UniformStore = class {
	/** Stores the uniform values for each uniform block */
	uniformBlocks = /* @__PURE__ */ new Map();
	/** Can generate data for a uniform buffer for each block from data */
	uniformBufferLayouts = /* @__PURE__ */ new Map();
	/** Actual buffer for the blocks */
	uniformBuffers = /* @__PURE__ */ new Map();
	/**
	* Create a new UniformStore instance
	* @param blocks
	*/
	constructor(blocks) {
		for (const [bufferName, block] of Object.entries(blocks)) {
			const uniformBufferName = bufferName;
			const uniformBufferLayout = new UniformBufferLayout(block.uniformTypes ?? {}, block.uniformSizes ?? {});
			this.uniformBufferLayouts.set(uniformBufferName, uniformBufferLayout);
			const uniformBlock$3 = new UniformBlock({ name: bufferName });
			uniformBlock$3.setUniforms(block.defaultUniforms || {});
			this.uniformBlocks.set(uniformBufferName, uniformBlock$3);
		}
	}
	/** Destroy any managed uniform buffers */
	destroy() {
		for (const uniformBuffer of this.uniformBuffers.values()) uniformBuffer.destroy();
	}
	/**
	* Set uniforms
	* Makes all properties partial
	*/
	setUniforms(uniforms) {
		for (const [blockName, uniformValues] of Object.entries(uniforms)) this.uniformBlocks.get(blockName)?.setUniforms(uniformValues);
		this.updateUniformBuffers();
	}
	/** Get the required minimum length of the uniform buffer */
	getUniformBufferByteLength(uniformBufferName) {
		return this.uniformBufferLayouts.get(uniformBufferName)?.byteLength || 0;
	}
	/** Get formatted binary memory that can be uploaded to a buffer */
	getUniformBufferData(uniformBufferName) {
		const uniformValues = this.uniformBlocks.get(uniformBufferName)?.getAllUniforms() || {};
		return this.uniformBufferLayouts.get(uniformBufferName)?.getData(uniformValues);
	}
	/**
	* Creates an unmanaged uniform buffer (umnanaged means that application is responsible for destroying it)
	* The new buffer is initialized with current / supplied values
	*/
	createUniformBuffer(device, uniformBufferName, uniforms) {
		if (uniforms) this.setUniforms(uniforms);
		const byteLength = this.getUniformBufferByteLength(uniformBufferName);
		const uniformBuffer = device.createBuffer({
			usage: Buffer.UNIFORM | Buffer.COPY_DST,
			byteLength
		});
		const uniformBufferData = this.getUniformBufferData(uniformBufferName);
		uniformBuffer.write(uniformBufferData);
		return uniformBuffer;
	}
	/** Get the managed uniform buffer. "managed" resources are destroyed when the uniformStore is destroyed. */
	getManagedUniformBuffer(device, uniformBufferName) {
		if (!this.uniformBuffers.get(uniformBufferName)) {
			const byteLength = this.getUniformBufferByteLength(uniformBufferName);
			const uniformBuffer = device.createBuffer({
				usage: Buffer.UNIFORM | Buffer.COPY_DST,
				byteLength
			});
			this.uniformBuffers.set(uniformBufferName, uniformBuffer);
		}
		return this.uniformBuffers.get(uniformBufferName);
	}
	/** Updates all uniform buffers where values have changed */
	updateUniformBuffers() {
		let reason = false;
		for (const uniformBufferName of this.uniformBlocks.keys()) {
			const bufferReason = this.updateUniformBuffer(uniformBufferName);
			reason ||= bufferReason;
		}
		if (reason) log.log(3, `UniformStore.updateUniformBuffers(): ${reason}`)();
		return reason;
	}
	/** Update one uniform buffer. Only updates if values have changed */
	updateUniformBuffer(uniformBufferName) {
		const uniformBlock$3 = this.uniformBlocks.get(uniformBufferName);
		let uniformBuffer = this.uniformBuffers.get(uniformBufferName);
		let reason = false;
		if (uniformBuffer && uniformBlock$3?.needsRedraw) {
			reason ||= uniformBlock$3.needsRedraw;
			const uniformBufferData = this.getUniformBufferData(uniformBufferName);
			uniformBuffer = this.uniformBuffers.get(uniformBufferName);
			uniformBuffer?.write(uniformBufferData);
			const uniformValues = this.uniformBlocks.get(uniformBufferName)?.getAllUniforms();
			log.log(4, `Writing to uniform buffer ${String(uniformBufferName)}`, uniformBufferData, uniformValues)();
		}
		return reason;
	}
};

//#endregion
//#region node_modules/wgsl_reflect/wgsl_reflect.module.js
var e$1 = class {
	constructor(e$2, t$1) {
		this.name = e$2, this.attributes = t$1, this.size = 0;
	}
	get isArray() {
		return !1;
	}
	get isStruct() {
		return !1;
	}
	get isTemplate() {
		return !1;
	}
	get isPointer() {
		return !1;
	}
	getTypeName() {
		return this.name;
	}
};
var t = class {
	constructor(e$2, t$1, n$1) {
		this.name = e$2, this.type = t$1, this.attributes = n$1, this.offset = 0, this.size = 0;
	}
	get isArray() {
		return this.type.isArray;
	}
	get isStruct() {
		return this.type.isStruct;
	}
	get isTemplate() {
		return this.type.isTemplate;
	}
	get align() {
		return this.type.isStruct ? this.type.align : 0;
	}
	get members() {
		return this.type.isStruct ? this.type.members : null;
	}
	get format() {
		return this.type.isArray || this.type.isTemplate ? this.type.format : null;
	}
	get count() {
		return this.type.isArray ? this.type.count : 0;
	}
	get stride() {
		return this.type.isArray ? this.type.stride : this.size;
	}
};
var n = class extends e$1 {
	constructor(e$2, t$1) {
		super(e$2, t$1), this.members = [], this.align = 0, this.startLine = -1, this.endLine = -1, this.inUse = !1;
	}
	get isStruct() {
		return !0;
	}
};
var s = class extends e$1 {
	constructor(e$2, t$1) {
		super(e$2, t$1), this.count = 0, this.stride = 0;
	}
	get isArray() {
		return !0;
	}
	getTypeName() {
		return `array<${this.format.getTypeName()}, ${this.count}>`;
	}
};
var r = class extends e$1 {
	constructor(e$2, t$1, n$1) {
		super(e$2, n$1), this.format = t$1;
	}
	get isPointer() {
		return !0;
	}
	getTypeName() {
		return `&${this.format.getTypeName()}`;
	}
};
var a = class extends e$1 {
	constructor(e$2, t$1, n$1, s$1) {
		super(e$2, n$1), this.format = t$1, this.access = s$1;
	}
	get isTemplate() {
		return !0;
	}
	getTypeName() {
		let e$2 = this.name;
		if (null !== this.format) {
			if ("vec2" === e$2 || "vec3" === e$2 || "vec4" === e$2 || "mat2x2" === e$2 || "mat2x3" === e$2 || "mat2x4" === e$2 || "mat3x2" === e$2 || "mat3x3" === e$2 || "mat3x4" === e$2 || "mat4x2" === e$2 || "mat4x3" === e$2 || "mat4x4" === e$2) {
				if ("f32" === this.format.name) return e$2 += "f", e$2;
				if ("i32" === this.format.name) return e$2 += "i", e$2;
				if ("u32" === this.format.name) return e$2 += "u", e$2;
				if ("bool" === this.format.name) return e$2 += "b", e$2;
				if ("f16" === this.format.name) return e$2 += "h", e$2;
			}
			e$2 += `<${this.format.name}>`;
		} else if ("vec2" === e$2 || "vec3" === e$2 || "vec4" === e$2) return e$2;
		return e$2;
	}
};
var i;
((e$2) => {
	e$2[e$2.Uniform = 0] = "Uniform", e$2[e$2.Storage = 1] = "Storage", e$2[e$2.Texture = 2] = "Texture", e$2[e$2.Sampler = 3] = "Sampler", e$2[e$2.StorageTexture = 4] = "StorageTexture";
})(i || (i = {}));
var o = class {
	constructor(e$2, t$1, n$1, s$1, r$1, a$1, i$1) {
		this.name = e$2, this.type = t$1, this.group = n$1, this.binding = s$1, this.attributes = r$1, this.resourceType = a$1, this.access = i$1;
	}
	get isArray() {
		return this.type.isArray;
	}
	get isStruct() {
		return this.type.isStruct;
	}
	get isTemplate() {
		return this.type.isTemplate;
	}
	get size() {
		return this.type.size;
	}
	get align() {
		return this.type.isStruct ? this.type.align : 0;
	}
	get members() {
		return this.type.isStruct ? this.type.members : null;
	}
	get format() {
		return this.type.isArray || this.type.isTemplate ? this.type.format : null;
	}
	get count() {
		return this.type.isArray ? this.type.count : 0;
	}
	get stride() {
		return this.type.isArray ? this.type.stride : this.size;
	}
};
var c = class {
	constructor(e$2, t$1) {
		this.name = e$2, this.type = t$1;
	}
};
var l = class {
	constructor(e$2, t$1, n$1, s$1) {
		this.name = e$2, this.type = t$1, this.locationType = n$1, this.location = s$1, this.interpolation = null;
	}
};
var u = class {
	constructor(e$2, t$1, n$1, s$1) {
		this.name = e$2, this.type = t$1, this.locationType = n$1, this.location = s$1;
	}
};
var h = class {
	constructor(e$2, t$1, n$1, s$1) {
		this.name = e$2, this.type = t$1, this.attributes = n$1, this.id = s$1;
	}
};
var f = class {
	constructor(e$2, t$1, n$1) {
		this.name = e$2, this.type = t$1, this.attributes = n$1;
	}
};
var p = class {
	constructor(e$2, t$1 = null, n$1) {
		this.stage = null, this.inputs = [], this.outputs = [], this.arguments = [], this.returnType = null, this.resources = [], this.overrides = [], this.startLine = -1, this.endLine = -1, this.inUse = !1, this.calls = /* @__PURE__ */ new Set(), this.name = e$2, this.stage = t$1, this.attributes = n$1;
	}
};
var d = class {
	constructor() {
		this.vertex = [], this.fragment = [], this.compute = [];
	}
};
function m(e$2) {
	var t$1 = (32768 & e$2) >> 15, n$1 = (31744 & e$2) >> 10, s$1 = 1023 & e$2;
	return 0 == n$1 ? (t$1 ? -1 : 1) * Math.pow(2, -14) * (s$1 / Math.pow(2, 10)) : 31 == n$1 ? s$1 ? NaN : Infinity * (t$1 ? -1 : 1) : (t$1 ? -1 : 1) * Math.pow(2, n$1 - 15) * (1 + s$1 / Math.pow(2, 10));
}
var g = new Float32Array(1), _ = new Int32Array(g.buffer), x = new Uint16Array(1);
function y(e$2) {
	g[0] = e$2;
	const t$1 = _[0], n$1 = t$1 >> 31 & 1;
	let s$1 = t$1 >> 23 & 255, r$1 = 8388607 & t$1;
	if (255 === s$1) return x[0] = n$1 << 15 | 31744 | (0 !== r$1 ? 512 : 0), x[0];
	if (0 === s$1) {
		if (0 === r$1) return x[0] = n$1 << 15, x[0];
		r$1 |= 8388608;
		let e$3 = 113;
		for (; !(8388608 & r$1);) r$1 <<= 1, e$3--;
		return s$1 = 127 - e$3, r$1 &= 8388607, s$1 > 0 ? (r$1 = (r$1 >> 126 - s$1) + (r$1 >> 127 - s$1 & 1), x[0] = n$1 << 15 | s$1 << 10 | r$1 >> 13, x[0]) : (x[0] = n$1 << 15, x[0]);
	}
	return s$1 = s$1 - 127 + 15, s$1 >= 31 ? (x[0] = n$1 << 15 | 31744, x[0]) : s$1 <= 0 ? s$1 < -10 ? (x[0] = n$1 << 15, x[0]) : (r$1 = (8388608 | r$1) >> 1 - s$1, x[0] = n$1 << 15 | r$1 >> 13, x[0]) : (r$1 >>= 13, x[0] = n$1 << 15 | s$1 << 10 | r$1, x[0]);
}
var b = new Uint32Array(1), v = new Float32Array(b.buffer, 0, 1);
function w(e$2) {
	return b[0] = 112 + (e$2 >> 6 & 31) << 23 | (63 & e$2) << 17, v[0];
}
function k(e$2, t$1, n$1, s$1, r$1, a$1, i$1, o$1, c$1) {
	const l$1 = s$1 * (i$1 >>= r$1) * (a$1 >>= r$1) + n$1 * i$1 + t$1 * o$1;
	switch (c$1) {
		case "r8unorm": return [I(e$2, l$1, "8unorm", 1)[0]];
		case "r8snorm": return [I(e$2, l$1, "8snorm", 1)[0]];
		case "r8uint": return [I(e$2, l$1, "8uint", 1)[0]];
		case "r8sint": return [I(e$2, l$1, "8sint", 1)[0]];
		case "rg8unorm": {
			const t$2 = I(e$2, l$1, "8unorm", 2);
			return [t$2[0], t$2[1]];
		}
		case "rg8snorm": {
			const t$2 = I(e$2, l$1, "8snorm", 2);
			return [t$2[0], t$2[1]];
		}
		case "rg8uint": {
			const t$2 = I(e$2, l$1, "8uint", 2);
			return [t$2[0], t$2[1]];
		}
		case "rg8sint": {
			const t$2 = I(e$2, l$1, "8sint", 2);
			return [t$2[0], t$2[1]];
		}
		case "rgba8unorm-srgb":
		case "rgba8unorm": {
			const t$2 = I(e$2, l$1, "8unorm", 4);
			return [
				t$2[0],
				t$2[1],
				t$2[2],
				t$2[3]
			];
		}
		case "rgba8snorm": {
			const t$2 = I(e$2, l$1, "8snorm", 4);
			return [
				t$2[0],
				t$2[1],
				t$2[2],
				t$2[3]
			];
		}
		case "rgba8uint": {
			const t$2 = I(e$2, l$1, "8uint", 4);
			return [
				t$2[0],
				t$2[1],
				t$2[2],
				t$2[3]
			];
		}
		case "rgba8sint": {
			const t$2 = I(e$2, l$1, "8sint", 4);
			return [
				t$2[0],
				t$2[1],
				t$2[2],
				t$2[3]
			];
		}
		case "bgra8unorm-srgb":
		case "bgra8unorm": {
			const t$2 = I(e$2, l$1, "8unorm", 4);
			return [
				t$2[2],
				t$2[1],
				t$2[0],
				t$2[3]
			];
		}
		case "r16uint": return [I(e$2, l$1, "16uint", 1)[0]];
		case "r16sint": return [I(e$2, l$1, "16sint", 1)[0]];
		case "r16float": return [I(e$2, l$1, "16float", 1)[0]];
		case "rg16uint": {
			const t$2 = I(e$2, l$1, "16uint", 2);
			return [t$2[0], t$2[1]];
		}
		case "rg16sint": {
			const t$2 = I(e$2, l$1, "16sint", 2);
			return [t$2[0], t$2[1]];
		}
		case "rg16float": {
			const t$2 = I(e$2, l$1, "16float", 2);
			return [t$2[0], t$2[1]];
		}
		case "rgba16uint": {
			const t$2 = I(e$2, l$1, "16uint", 4);
			return [
				t$2[0],
				t$2[1],
				t$2[2],
				t$2[3]
			];
		}
		case "rgba16sint": {
			const t$2 = I(e$2, l$1, "16sint", 4);
			return [
				t$2[0],
				t$2[1],
				t$2[2],
				t$2[3]
			];
		}
		case "rgba16float": {
			const t$2 = I(e$2, l$1, "16float", 4);
			return [
				t$2[0],
				t$2[1],
				t$2[2],
				t$2[3]
			];
		}
		case "r32uint": return [I(e$2, l$1, "32uint", 1)[0]];
		case "r32sint": return [I(e$2, l$1, "32sint", 1)[0]];
		case "depth16unorm":
		case "depth24plus":
		case "depth24plus-stencil8":
		case "depth32float":
		case "depth32float-stencil8":
		case "r32float": return [I(e$2, l$1, "32float", 1)[0]];
		case "rg32uint": {
			const t$2 = I(e$2, l$1, "32uint", 2);
			return [t$2[0], t$2[1]];
		}
		case "rg32sint": {
			const t$2 = I(e$2, l$1, "32sint", 2);
			return [t$2[0], t$2[1]];
		}
		case "rg32float": {
			const t$2 = I(e$2, l$1, "32float", 2);
			return [t$2[0], t$2[1]];
		}
		case "rgba32uint": {
			const t$2 = I(e$2, l$1, "32uint", 4);
			return [
				t$2[0],
				t$2[1],
				t$2[2],
				t$2[3]
			];
		}
		case "rgba32sint": {
			const t$2 = I(e$2, l$1, "32sint", 4);
			return [
				t$2[0],
				t$2[1],
				t$2[2],
				t$2[3]
			];
		}
		case "rgba32float": {
			const t$2 = I(e$2, l$1, "32float", 4);
			return [
				t$2[0],
				t$2[1],
				t$2[2],
				t$2[3]
			];
		}
		case "rg11b10ufloat": {
			const t$2 = new Uint32Array(e$2.buffer, l$1, 1)[0], n$2 = (4192256 & t$2) >> 11, s$2 = (4290772992 & t$2) >> 22;
			return [
				w(2047 & t$2),
				w(n$2),
				function(e$3) {
					return b[0] = 112 + (e$3 >> 5 & 31) << 23 | (31 & e$3) << 18, v[0];
				}(s$2),
				1
			];
		}
	}
	return null;
}
function I(e$2, t$1, n$1, s$1) {
	const r$1 = [
		0,
		0,
		0,
		0
	];
	for (let a$1 = 0; a$1 < s$1; ++a$1) switch (n$1) {
		case "8unorm":
			r$1[a$1] = e$2[t$1] / 255, t$1++;
			break;
		case "8snorm":
			r$1[a$1] = e$2[t$1] / 255 * 2 - 1, t$1++;
			break;
		case "8uint":
			r$1[a$1] = e$2[t$1], t$1++;
			break;
		case "8sint":
			r$1[a$1] = e$2[t$1] - 127, t$1++;
			break;
		case "16uint":
			r$1[a$1] = e$2[t$1] | e$2[t$1 + 1] << 8, t$1 += 2;
			break;
		case "16sint":
			r$1[a$1] = (e$2[t$1] | e$2[t$1 + 1] << 8) - 32768, t$1 += 2;
			break;
		case "16float":
			r$1[a$1] = m(e$2[t$1] | e$2[t$1 + 1] << 8), t$1 += 2;
			break;
		case "32uint":
		case "32sint":
			r$1[a$1] = e$2[t$1] | e$2[t$1 + 1] << 8 | e$2[t$1 + 2] << 16 | e$2[t$1 + 3] << 24, t$1 += 4;
			break;
		case "32float": r$1[a$1] = new Float32Array(e$2.buffer, t$1, 1)[0], t$1 += 4;
	}
	return r$1;
}
function T(e$2, t$1, n$1, s$1, r$1) {
	for (let a$1 = 0; a$1 < s$1; ++a$1) switch (n$1) {
		case "8unorm":
			e$2[t$1] = 255 * r$1[a$1], t$1++;
			break;
		case "8snorm":
			e$2[t$1] = .5 * (r$1[a$1] + 1) * 255, t$1++;
			break;
		case "8uint":
			e$2[t$1] = r$1[a$1], t$1++;
			break;
		case "8sint":
			e$2[t$1] = r$1[a$1] + 127, t$1++;
			break;
		case "16uint":
			new Uint16Array(e$2.buffer, t$1, 1)[0] = r$1[a$1], t$1 += 2;
			break;
		case "16sint":
			new Int16Array(e$2.buffer, t$1, 1)[0] = r$1[a$1], t$1 += 2;
			break;
		case "16float": {
			const n$2 = y(r$1[a$1]);
			new Uint16Array(e$2.buffer, t$1, 1)[0] = n$2, t$1 += 2;
			break;
		}
		case "32uint":
			new Uint32Array(e$2.buffer, t$1, 1)[0] = r$1[a$1], t$1 += 4;
			break;
		case "32sint":
			new Int32Array(e$2.buffer, t$1, 1)[0] = r$1[a$1], t$1 += 4;
			break;
		case "32float": new Float32Array(e$2.buffer, t$1, 1)[0] = r$1[a$1], t$1 += 4;
	}
	return r$1;
}
var S = {
	r8unorm: {
		bytesPerBlock: 1,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 1
	},
	r8snorm: {
		bytesPerBlock: 1,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 1
	},
	r8uint: {
		bytesPerBlock: 1,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 1
	},
	r8sint: {
		bytesPerBlock: 1,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 1
	},
	rg8unorm: {
		bytesPerBlock: 2,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 2
	},
	rg8snorm: {
		bytesPerBlock: 2,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 2
	},
	rg8uint: {
		bytesPerBlock: 2,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 2
	},
	rg8sint: {
		bytesPerBlock: 2,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 2
	},
	rgba8unorm: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	"rgba8unorm-srgb": {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	rgba8snorm: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	rgba8uint: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	rgba8sint: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	bgra8unorm: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	"bgra8unorm-srgb": {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	r16uint: {
		bytesPerBlock: 2,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 1
	},
	r16sint: {
		bytesPerBlock: 2,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 1
	},
	r16float: {
		bytesPerBlock: 2,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 1
	},
	rg16uint: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 2
	},
	rg16sint: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 2
	},
	rg16float: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 2
	},
	rgba16uint: {
		bytesPerBlock: 8,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	rgba16sint: {
		bytesPerBlock: 8,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	rgba16float: {
		bytesPerBlock: 8,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	r32uint: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 1
	},
	r32sint: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 1
	},
	r32float: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 1
	},
	rg32uint: {
		bytesPerBlock: 8,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 2
	},
	rg32sint: {
		bytesPerBlock: 8,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 2
	},
	rg32float: {
		bytesPerBlock: 8,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 2
	},
	rgba32uint: {
		bytesPerBlock: 16,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	rgba32sint: {
		bytesPerBlock: 16,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	rgba32float: {
		bytesPerBlock: 16,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	rgb10a2uint: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	rgb10a2unorm: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	rg11b10ufloat: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	stencil8: {
		bytesPerBlock: 1,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		isDepthStencil: !0,
		hasDepth: !1,
		hasStencil: !0,
		channels: 1
	},
	depth16unorm: {
		bytesPerBlock: 2,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		isDepthStencil: !0,
		hasDepth: !0,
		hasStencil: !1,
		channels: 1
	},
	depth24plus: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		isDepthStencil: !0,
		hasDepth: !0,
		hasStencil: !1,
		depthOnlyFormat: "depth32float",
		channels: 1
	},
	"depth24plus-stencil8": {
		bytesPerBlock: 8,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		isDepthStencil: !0,
		hasDepth: !0,
		hasStencil: !0,
		depthOnlyFormat: "depth32float",
		channels: 1
	},
	depth32float: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		isDepthStencil: !0,
		hasDepth: !0,
		hasStencil: !1,
		channels: 1
	},
	"depth32float-stencil8": {
		bytesPerBlock: 8,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		isDepthStencil: !0,
		hasDepth: !0,
		hasStencil: !0,
		stencilOnlyFormat: "depth32float",
		channels: 1
	},
	rgb9e5ufloat: {
		bytesPerBlock: 4,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !1,
		channels: 4
	},
	"bc1-rgba-unorm": {
		bytesPerBlock: 8,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"bc1-rgba-unorm-srgb": {
		bytesPerBlock: 8,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"bc2-rgba-unorm": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"bc2-rgba-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"bc3-rgba-unorm": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"bc3-rgba-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"bc4-r-unorm": {
		bytesPerBlock: 8,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 1
	},
	"bc4-r-snorm": {
		bytesPerBlock: 8,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 1
	},
	"bc5-rg-unorm": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 2
	},
	"bc5-rg-snorm": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 2
	},
	"bc6h-rgb-ufloat": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"bc6h-rgb-float": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"bc7-rgba-unorm": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"bc7-rgba-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"etc2-rgb8unorm": {
		bytesPerBlock: 8,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"etc2-rgb8unorm-srgb": {
		bytesPerBlock: 8,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"etc2-rgb8a1unorm": {
		bytesPerBlock: 8,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"etc2-rgb8a1unorm-srgb": {
		bytesPerBlock: 8,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"etc2-rgba8unorm": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"etc2-rgba8unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"eac-r11unorm": {
		bytesPerBlock: 8,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !0,
		channels: 1
	},
	"eac-r11snorm": {
		bytesPerBlock: 8,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !0,
		channels: 1
	},
	"eac-rg11unorm": {
		bytesPerBlock: 16,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !0,
		channels: 2
	},
	"eac-rg11snorm": {
		bytesPerBlock: 16,
		blockWidth: 1,
		blockHeight: 1,
		isCompressed: !0,
		channels: 2
	},
	"astc-4x4-unorm": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"astc-4x4-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 4,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"astc-5x4-unorm": {
		bytesPerBlock: 16,
		blockWidth: 5,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"astc-5x4-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 5,
		blockHeight: 4,
		isCompressed: !0,
		channels: 4
	},
	"astc-5x5-unorm": {
		bytesPerBlock: 16,
		blockWidth: 5,
		blockHeight: 5,
		isCompressed: !0,
		channels: 4
	},
	"astc-5x5-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 5,
		blockHeight: 5,
		isCompressed: !0,
		channels: 4
	},
	"astc-6x5-unorm": {
		bytesPerBlock: 16,
		blockWidth: 6,
		blockHeight: 5,
		isCompressed: !0,
		channels: 4
	},
	"astc-6x5-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 6,
		blockHeight: 5,
		isCompressed: !0,
		channels: 4
	},
	"astc-6x6-unorm": {
		bytesPerBlock: 16,
		blockWidth: 6,
		blockHeight: 6,
		isCompressed: !0,
		channels: 4
	},
	"astc-6x6-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 6,
		blockHeight: 6,
		isCompressed: !0,
		channels: 4
	},
	"astc-8x5-unorm": {
		bytesPerBlock: 16,
		blockWidth: 8,
		blockHeight: 5,
		isCompressed: !0,
		channels: 4
	},
	"astc-8x5-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 8,
		blockHeight: 5,
		isCompressed: !0,
		channels: 4
	},
	"astc-8x6-unorm": {
		bytesPerBlock: 16,
		blockWidth: 8,
		blockHeight: 6,
		isCompressed: !0,
		channels: 4
	},
	"astc-8x6-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 8,
		blockHeight: 6,
		isCompressed: !0,
		channels: 4
	},
	"astc-8x8-unorm": {
		bytesPerBlock: 16,
		blockWidth: 8,
		blockHeight: 8,
		isCompressed: !0,
		channels: 4
	},
	"astc-8x8-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 8,
		blockHeight: 8,
		isCompressed: !0,
		channels: 4
	},
	"astc-10x5-unorm": {
		bytesPerBlock: 16,
		blockWidth: 10,
		blockHeight: 5,
		isCompressed: !0,
		channels: 4
	},
	"astc-10x5-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 10,
		blockHeight: 5,
		isCompressed: !0,
		channels: 4
	},
	"astc-10x6-unorm": {
		bytesPerBlock: 16,
		blockWidth: 10,
		blockHeight: 6,
		isCompressed: !0,
		channels: 4
	},
	"astc-10x6-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 10,
		blockHeight: 6,
		isCompressed: !0,
		channels: 4
	},
	"astc-10x8-unorm": {
		bytesPerBlock: 16,
		blockWidth: 10,
		blockHeight: 8,
		isCompressed: !0,
		channels: 4
	},
	"astc-10x8-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 10,
		blockHeight: 8,
		isCompressed: !0,
		channels: 4
	},
	"astc-10x10-unorm": {
		bytesPerBlock: 16,
		blockWidth: 10,
		blockHeight: 10,
		isCompressed: !0,
		channels: 4
	},
	"astc-10x10-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 10,
		blockHeight: 10,
		isCompressed: !0,
		channels: 4
	},
	"astc-12x10-unorm": {
		bytesPerBlock: 16,
		blockWidth: 12,
		blockHeight: 10,
		isCompressed: !0,
		channels: 4
	},
	"astc-12x10-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 12,
		blockHeight: 10,
		isCompressed: !0,
		channels: 4
	},
	"astc-12x12-unorm": {
		bytesPerBlock: 16,
		blockWidth: 12,
		blockHeight: 12,
		isCompressed: !0,
		channels: 4
	},
	"astc-12x12-unorm-srgb": {
		bytesPerBlock: 16,
		blockWidth: 12,
		blockHeight: 12,
		isCompressed: !0,
		channels: 4
	}
};
var A = class A {
	constructor() {
		this.id = A._id++, this.line = 0;
	}
	get isAstNode() {
		return !0;
	}
	get astNodeType() {
		return "";
	}
	search(e$2) {
		e$2(this);
	}
	searchBlock(e$2, t$1) {
		if (e$2) {
			t$1(E.instance);
			for (const n$1 of e$2) n$1 instanceof Array ? this.searchBlock(n$1, t$1) : n$1.search(t$1);
			t$1($.instance);
		}
	}
	constEvaluate(e$2, t$1) {
		throw new Error("Cannot evaluate node");
	}
	constEvaluateString(e$2) {
		return this.constEvaluate(e$2).toString();
	}
};
A._id = 0;
var E = class extends A {};
E.instance = new E();
var $ = class extends A {};
$.instance = new $();
var L = new Set([
	"all",
	"all",
	"any",
	"select",
	"arrayLength",
	"abs",
	"acos",
	"acosh",
	"asin",
	"asinh",
	"atan",
	"atanh",
	"atan2",
	"ceil",
	"clamp",
	"cos",
	"cosh",
	"countLeadingZeros",
	"countOneBits",
	"countTrailingZeros",
	"cross",
	"degrees",
	"determinant",
	"distance",
	"dot",
	"dot4U8Packed",
	"dot4I8Packed",
	"exp",
	"exp2",
	"extractBits",
	"faceForward",
	"firstLeadingBit",
	"firstTrailingBit",
	"floor",
	"fma",
	"fract",
	"frexp",
	"insertBits",
	"inverseSqrt",
	"ldexp",
	"length",
	"log",
	"log2",
	"max",
	"min",
	"mix",
	"modf",
	"normalize",
	"pow",
	"quantizeToF16",
	"radians",
	"reflect",
	"refract",
	"reverseBits",
	"round",
	"saturate",
	"sign",
	"sin",
	"sinh",
	"smoothStep",
	"sqrt",
	"step",
	"tan",
	"tanh",
	"transpose",
	"trunc",
	"dpdx",
	"dpdxCoarse",
	"dpdxFine",
	"dpdy",
	"dpdyCoarse",
	"dpdyFine",
	"fwidth",
	"fwidthCoarse",
	"fwidthFine",
	"textureDimensions",
	"textureGather",
	"textureGatherCompare",
	"textureLoad",
	"textureNumLayers",
	"textureNumLevels",
	"textureNumSamples",
	"textureSample",
	"textureSampleBias",
	"textureSampleCompare",
	"textureSampleCompareLevel",
	"textureSampleGrad",
	"textureSampleLevel",
	"textureSampleBaseClampToEdge",
	"textureStore",
	"atomicLoad",
	"atomicStore",
	"atomicAdd",
	"atomicSub",
	"atomicMax",
	"atomicMin",
	"atomicAnd",
	"atomicOr",
	"atomicXor",
	"atomicExchange",
	"atomicCompareExchangeWeak",
	"pack4x8snorm",
	"pack4x8unorm",
	"pack4xI8",
	"pack4xU8",
	"pack4x8Clamp",
	"pack4xU8Clamp",
	"pack2x16snorm",
	"pack2x16unorm",
	"pack2x16float",
	"unpack4x8snorm",
	"unpack4x8unorm",
	"unpack4xI8",
	"unpack4xU8",
	"unpack2x16snorm",
	"unpack2x16unorm",
	"unpack2x16float",
	"storageBarrier",
	"textureBarrier",
	"workgroupBarrier",
	"workgroupUniformLoad",
	"subgroupAdd",
	"subgroupExclusiveAdd",
	"subgroupInclusiveAdd",
	"subgroupAll",
	"subgroupAnd",
	"subgroupAny",
	"subgroupBallot",
	"subgroupBroadcast",
	"subgroupBroadcastFirst",
	"subgroupElect",
	"subgroupMax",
	"subgroupMin",
	"subgroupMul",
	"subgroupExclusiveMul",
	"subgroupInclusiveMul",
	"subgroupOr",
	"subgroupShuffle",
	"subgroupShuffleDown",
	"subgroupShuffleUp",
	"subgroupShuffleXor",
	"subgroupXor",
	"quadBroadcast",
	"quadSwapDiagonal",
	"quadSwapX",
	"quadSwapY"
]);
var C = class extends A {
	constructor() {
		super();
	}
};
var D = class extends C {
	constructor(e$2, t$1, n$1, s$1, r$1, a$1) {
		super(), this.calls = /* @__PURE__ */ new Set(), this.name = e$2, this.args = t$1, this.returnType = n$1, this.body = s$1, this.startLine = r$1, this.endLine = a$1;
	}
	get astNodeType() {
		return "function";
	}
	search(e$2) {
		if (this.attributes) for (const t$1 of this.attributes) e$2(t$1);
		e$2(this);
		for (const t$1 of this.args) e$2(t$1);
		this.searchBlock(this.body, e$2);
	}
};
var N = class extends C {
	constructor(e$2) {
		super(), this.expression = e$2;
	}
	get astNodeType() {
		return "staticAssert";
	}
	search(e$2) {
		this.expression.search(e$2);
	}
};
var V = class extends C {
	constructor(e$2, t$1) {
		super(), this.condition = e$2, this.body = t$1;
	}
	get astNodeType() {
		return "while";
	}
	search(e$2) {
		this.condition.search(e$2), this.searchBlock(this.body, e$2);
	}
};
var O = class extends C {
	constructor(e$2, t$1) {
		super(), this.body = e$2, this.loopId = t$1;
	}
	get astNodeType() {
		return "continuing";
	}
	search(e$2) {
		this.searchBlock(this.body, e$2);
	}
};
var B = class extends C {
	constructor(e$2, t$1, n$1, s$1) {
		super(), this.init = e$2, this.condition = t$1, this.increment = n$1, this.body = s$1;
	}
	get astNodeType() {
		return "for";
	}
	search(e$2) {
		var t$1, n$1, s$1;
		null === (t$1 = this.init) || void 0 === t$1 || t$1.search(e$2), null === (n$1 = this.condition) || void 0 === n$1 || n$1.search(e$2), null === (s$1 = this.increment) || void 0 === s$1 || s$1.search(e$2), this.searchBlock(this.body, e$2);
	}
};
var F = class extends C {
	constructor(e$2, t$1, n$1, s$1, r$1) {
		super(), this.attributes = null, this.name = e$2, this.type = t$1, this.storage = n$1, this.access = s$1, this.value = r$1;
	}
	get astNodeType() {
		return "var";
	}
	search(e$2) {
		var t$1;
		e$2(this), null === (t$1 = this.value) || void 0 === t$1 || t$1.search(e$2);
	}
};
var M = class extends C {
	constructor(e$2, t$1, n$1) {
		super(), this.attributes = null, this.name = e$2, this.type = t$1, this.value = n$1;
	}
	get astNodeType() {
		return "override";
	}
	search(e$2) {
		var t$1;
		null === (t$1 = this.value) || void 0 === t$1 || t$1.search(e$2);
	}
};
var U = class extends C {
	constructor(e$2, t$1, n$1, s$1, r$1) {
		super(), this.attributes = null, this.name = e$2, this.type = t$1, this.storage = n$1, this.access = s$1, this.value = r$1;
	}
	get astNodeType() {
		return "let";
	}
	search(e$2) {
		var t$1;
		e$2(this), null === (t$1 = this.value) || void 0 === t$1 || t$1.search(e$2);
	}
};
var P = class extends C {
	constructor(e$2, t$1, n$1, s$1, r$1) {
		super(), this.attributes = null, this.name = e$2, this.type = t$1, this.storage = n$1, this.access = s$1, this.value = r$1;
	}
	get astNodeType() {
		return "const";
	}
	constEvaluate(e$2, t$1) {
		return this.value.constEvaluate(e$2, t$1);
	}
	search(e$2) {
		var t$1;
		e$2(this), null === (t$1 = this.value) || void 0 === t$1 || t$1.search(e$2);
	}
};
var W, q, H, z;
((e$2) => {
	e$2.increment = "++", e$2.decrement = "--";
})(W || (W = {})), ((e$2) => {
	e$2.parse = function(t$1) {
		const n$1 = t$1;
		if ("parse" == n$1) throw new Error("Invalid value for IncrementOperator");
		return e$2[n$1];
	};
})(W || (W = {}));
var R = class extends C {
	constructor(e$2, t$1) {
		super(), this.operator = e$2, this.variable = t$1;
	}
	get astNodeType() {
		return "increment";
	}
	search(e$2) {
		this.variable.search(e$2);
	}
};
((e$2) => {
	e$2.assign = "=", e$2.addAssign = "+=", e$2.subtractAssin = "-=", e$2.multiplyAssign = "*=", e$2.divideAssign = "/=", e$2.moduloAssign = "%=", e$2.andAssign = "&=", e$2.orAssign = "|=", e$2.xorAssign = "^=", e$2.shiftLeftAssign = "<<=", e$2.shiftRightAssign = ">>=";
})(q || (q = {})), ((e$2) => {
	e$2.parse = function(e$3) {
		const t$1 = e$3;
		if ("parse" == t$1) throw new Error("Invalid value for AssignOperator");
		return t$1;
	};
})(q || (q = {}));
var G = class extends C {
	constructor(e$2, t$1, n$1) {
		super(), this.operator = e$2, this.variable = t$1, this.value = n$1;
	}
	get astNodeType() {
		return "assign";
	}
	search(e$2) {
		this.variable.search(e$2), this.value.search(e$2);
	}
};
var X = class extends C {
	constructor(e$2, t$1) {
		super(), this.name = e$2, this.args = t$1;
	}
	get astNodeType() {
		return "call";
	}
	isBuiltin() {
		return L.has(this.name);
	}
	search(e$2) {
		for (const t$1 of this.args) t$1.search(e$2);
		e$2(this);
	}
};
var j = class extends C {
	constructor(e$2, t$1) {
		super(), this.body = e$2, this.continuing = t$1;
	}
	get astNodeType() {
		return "loop";
	}
	search(e$2) {
		var t$1;
		this.searchBlock(this.body, e$2), null === (t$1 = this.continuing) || void 0 === t$1 || t$1.search(e$2);
	}
};
var Z = class extends C {
	constructor(e$2, t$1) {
		super(), this.condition = e$2, this.cases = t$1;
	}
	get astNodeType() {
		return "switch";
	}
	search(e$2) {
		e$2(this);
		for (const t$1 of this.cases) t$1.search(e$2);
	}
};
var Q = class extends C {
	constructor(e$2, t$1, n$1, s$1) {
		super(), this.condition = e$2, this.body = t$1, this.elseif = n$1, this.else = s$1;
	}
	get astNodeType() {
		return "if";
	}
	search(e$2) {
		this.condition.search(e$2), this.searchBlock(this.body, e$2), this.searchBlock(this.elseif, e$2), this.searchBlock(this.else, e$2);
	}
};
var Y = class extends C {
	constructor(e$2) {
		super(), this.value = e$2;
	}
	get astNodeType() {
		return "return";
	}
	search(e$2) {
		var t$1;
		null === (t$1 = this.value) || void 0 === t$1 || t$1.search(e$2);
	}
};
var K = class extends C {
	constructor(e$2) {
		super(), this.name = e$2;
	}
	get astNodeType() {
		return "enable";
	}
};
var J = class extends C {
	constructor(e$2) {
		super(), this.extensions = e$2;
	}
	get astNodeType() {
		return "requires";
	}
};
var ee = class extends C {
	constructor(e$2, t$1) {
		super(), this.severity = e$2, this.rule = t$1;
	}
	get astNodeType() {
		return "diagnostic";
	}
};
var te = class extends C {
	constructor(e$2, t$1) {
		super(), this.name = e$2, this.type = t$1;
	}
	get astNodeType() {
		return "alias";
	}
};
var ne = class extends C {
	constructor() {
		super();
	}
	get astNodeType() {
		return "discard";
	}
};
var se = class extends C {
	constructor() {
		super(), this.condition = null, this.loopId = -1;
	}
	get astNodeType() {
		return "break";
	}
};
var re = class extends C {
	constructor() {
		super(), this.loopId = -1;
	}
	get astNodeType() {
		return "continue";
	}
};
var ae = class ae extends C {
	constructor(e$2) {
		super(), this.attributes = null, this.name = e$2;
	}
	get astNodeType() {
		return "type";
	}
	get isStruct() {
		return !1;
	}
	get isArray() {
		return !1;
	}
	static maxFormatType(e$2) {
		let t$1 = e$2[0];
		if ("f32" === t$1.name) return t$1;
		for (let n$1 = 1; n$1 < e$2.length; ++n$1) {
			const s$1 = ae._priority.get(t$1.name);
			ae._priority.get(e$2[n$1].name) < s$1 && (t$1 = e$2[n$1]);
		}
		return "x32" === t$1.name ? ae.i32 : t$1;
	}
	getTypeName() {
		return this.name;
	}
};
ae.x32 = new ae("x32"), ae.f32 = new ae("f32"), ae.i32 = new ae("i32"), ae.u32 = new ae("u32"), ae.f16 = new ae("f16"), ae.bool = new ae("bool"), ae.void = new ae("void"), ae._priority = new Map([
	["f32", 0],
	["f16", 1],
	["u32", 2],
	["i32", 3],
	["x32", 3]
]);
var ie = class extends ae {
	constructor(e$2) {
		super(e$2);
	}
};
var oe = class extends ae {
	constructor(e$2, t$1, n$1, s$1) {
		super(e$2), this.members = t$1, this.startLine = n$1, this.endLine = s$1;
	}
	get astNodeType() {
		return "struct";
	}
	get isStruct() {
		return !0;
	}
	getMemberIndex(e$2) {
		for (let t$1 = 0; t$1 < this.members.length; t$1++) if (this.members[t$1].name == e$2) return t$1;
		return -1;
	}
	search(e$2) {
		for (const t$1 of this.members) e$2(t$1);
	}
};
var ce = class extends ae {
	constructor(e$2, t$1, n$1) {
		super(e$2), this.format = t$1, this.access = n$1;
	}
	get astNodeType() {
		return "template";
	}
	getTypeName() {
		let e$2 = this.name;
		if (null !== this.format) {
			if ("vec2" === e$2 || "vec3" === e$2 || "vec4" === e$2 || "mat2x2" === e$2 || "mat2x3" === e$2 || "mat2x4" === e$2 || "mat3x2" === e$2 || "mat3x3" === e$2 || "mat3x4" === e$2 || "mat4x2" === e$2 || "mat4x3" === e$2 || "mat4x4" === e$2) {
				if ("f32" === this.format.name) return e$2 += "f", e$2;
				if ("i32" === this.format.name) return e$2 += "i", e$2;
				if ("u32" === this.format.name) return e$2 += "u", e$2;
				if ("bool" === this.format.name) return e$2 += "b", e$2;
				if ("f16" === this.format.name) return e$2 += "h", e$2;
			}
			e$2 += `<${this.format.name}>`;
		} else if ("vec2" === e$2 || "vec3" === e$2 || "vec4" === e$2) return e$2;
		return e$2;
	}
};
ce.vec2f = new ce("vec2", ae.f32, null), ce.vec3f = new ce("vec3", ae.f32, null), ce.vec4f = new ce("vec4", ae.f32, null), ce.vec2i = new ce("vec2", ae.i32, null), ce.vec3i = new ce("vec3", ae.i32, null), ce.vec4i = new ce("vec4", ae.i32, null), ce.vec2u = new ce("vec2", ae.u32, null), ce.vec3u = new ce("vec3", ae.u32, null), ce.vec4u = new ce("vec4", ae.u32, null), ce.vec2h = new ce("vec2", ae.f16, null), ce.vec3h = new ce("vec3", ae.f16, null), ce.vec4h = new ce("vec4", ae.f16, null), ce.vec2b = new ce("vec2", ae.bool, null), ce.vec3b = new ce("vec3", ae.bool, null), ce.vec4b = new ce("vec4", ae.bool, null), ce.mat2x2f = new ce("mat2x2", ae.f32, null), ce.mat2x3f = new ce("mat2x3", ae.f32, null), ce.mat2x4f = new ce("mat2x4", ae.f32, null), ce.mat3x2f = new ce("mat3x2", ae.f32, null), ce.mat3x3f = new ce("mat3x3", ae.f32, null), ce.mat3x4f = new ce("mat3x4", ae.f32, null), ce.mat4x2f = new ce("mat4x2", ae.f32, null), ce.mat4x3f = new ce("mat4x3", ae.f32, null), ce.mat4x4f = new ce("mat4x4", ae.f32, null), ce.mat2x2h = new ce("mat2x2", ae.f16, null), ce.mat2x3h = new ce("mat2x3", ae.f16, null), ce.mat2x4h = new ce("mat2x4", ae.f16, null), ce.mat3x2h = new ce("mat3x2", ae.f16, null), ce.mat3x3h = new ce("mat3x3", ae.f16, null), ce.mat3x4h = new ce("mat3x4", ae.f16, null), ce.mat4x2h = new ce("mat4x2", ae.f16, null), ce.mat4x3h = new ce("mat4x3", ae.f16, null), ce.mat4x4h = new ce("mat4x4", ae.f16, null), ce.mat2x2i = new ce("mat2x2", ae.i32, null), ce.mat2x3i = new ce("mat2x3", ae.i32, null), ce.mat2x4i = new ce("mat2x4", ae.i32, null), ce.mat3x2i = new ce("mat3x2", ae.i32, null), ce.mat3x3i = new ce("mat3x3", ae.i32, null), ce.mat3x4i = new ce("mat3x4", ae.i32, null), ce.mat4x2i = new ce("mat4x2", ae.i32, null), ce.mat4x3i = new ce("mat4x3", ae.i32, null), ce.mat4x4i = new ce("mat4x4", ae.i32, null), ce.mat2x2u = new ce("mat2x2", ae.u32, null), ce.mat2x3u = new ce("mat2x3", ae.u32, null), ce.mat2x4u = new ce("mat2x4", ae.u32, null), ce.mat3x2u = new ce("mat3x2", ae.u32, null), ce.mat3x3u = new ce("mat3x3", ae.u32, null), ce.mat3x4u = new ce("mat3x4", ae.u32, null), ce.mat4x2u = new ce("mat4x2", ae.u32, null), ce.mat4x3u = new ce("mat4x3", ae.u32, null), ce.mat4x4u = new ce("mat4x4", ae.u32, null);
var le = class extends ae {
	constructor(e$2, t$1, n$1, s$1) {
		super(e$2), this.storage = t$1, this.type = n$1, this.access = s$1;
	}
	get astNodeType() {
		return "pointer";
	}
};
var ue = class extends ae {
	constructor(e$2, t$1, n$1, s$1) {
		super(e$2), this.attributes = t$1, this.format = n$1, this.count = s$1;
	}
	get astNodeType() {
		return "array";
	}
	get isArray() {
		return !0;
	}
};
var he = class extends ae {
	constructor(e$2, t$1, n$1) {
		super(e$2), this.format = t$1, this.access = n$1;
	}
	get astNodeType() {
		return "sampler";
	}
};
var fe = class extends A {
	constructor() {
		super(), this.postfix = null;
	}
};
var pe = class extends fe {
	constructor(e$2) {
		super(), this.value = e$2;
	}
	get astNodeType() {
		return "stringExpr";
	}
	toString() {
		return this.value;
	}
	constEvaluateString() {
		return this.value;
	}
};
var de = class extends fe {
	constructor(e$2, t$1) {
		super(), this.type = e$2, this.args = t$1;
	}
	get astNodeType() {
		return "createExpr";
	}
	search(e$2) {
		if (e$2(this), this.args) for (const t$1 of this.args) t$1.search(e$2);
	}
	constEvaluate(e$2, t$1) {
		return t$1 && (t$1[0] = this.type), e$2.evalExpression(this, e$2.context);
	}
};
var me = class extends fe {
	constructor(e$2, t$1) {
		super(), this.cachedReturnValue = null, this.name = e$2, this.args = t$1;
	}
	get astNodeType() {
		return "callExpr";
	}
	setCachedReturnValue(e$2) {
		this.cachedReturnValue = e$2;
	}
	get isBuiltin() {
		return L.has(this.name);
	}
	constEvaluate(e$2, t$1) {
		return e$2.evalExpression(this, e$2.context);
	}
	search(e$2) {
		for (const t$1 of this.args) t$1.search(e$2);
		e$2(this);
	}
};
var ge = class extends fe {
	constructor(e$2) {
		super(), this.name = e$2;
	}
	get astNodeType() {
		return "varExpr";
	}
	search(e$2) {
		e$2(this), this.postfix && this.postfix.search(e$2);
	}
	constEvaluate(e$2, t$1) {
		return e$2.evalExpression(this, e$2.context);
	}
};
var _e = class extends fe {
	constructor(e$2, t$1) {
		super(), this.name = e$2, this.initializer = t$1;
	}
	get astNodeType() {
		return "constExpr";
	}
	constEvaluate(e$2, t$1) {
		if (this.initializer) {
			const t$2 = e$2.evalExpression(this.initializer, e$2.context);
			return null !== t$2 && this.postfix ? t$2.getSubData(e$2, this.postfix, e$2.context) : t$2;
		}
		return null;
	}
	search(e$2) {
		this.initializer.search(e$2);
	}
};
var xe = class extends fe {
	constructor(e$2, t$1) {
		super(), this.value = e$2, this.type = t$1;
	}
	get astNodeType() {
		return "literalExpr";
	}
	constEvaluate(e$2, t$1) {
		return void 0 !== t$1 && (t$1[0] = this.type), this.value;
	}
	get isScalar() {
		return this.value instanceof Be;
	}
	get isVector() {
		return this.value instanceof Me || this.value instanceof Ue;
	}
	get scalarValue() {
		return this.value instanceof Be ? this.value.value : (console.error("Value is not scalar."), 0);
	}
	get vectorValue() {
		return this.value instanceof Me || this.value instanceof Ue ? this.value.data : (console.error("Value is not a vector or matrix."), new Float32Array(0));
	}
};
var ye = class extends fe {
	constructor(e$2, t$1) {
		super(), this.type = e$2, this.value = t$1;
	}
	get astNodeType() {
		return "bitcastExpr";
	}
	search(e$2) {
		this.value.search(e$2);
	}
};
var ve = class extends fe {
	constructor(e$2) {
		super(), this.index = e$2;
	}
	search(e$2) {
		this.index.search(e$2);
	}
};
var we = class extends fe {
	constructor() {
		super();
	}
};
var ke = class extends we {
	constructor(e$2, t$1) {
		super(), this.operator = e$2, this.right = t$1;
	}
	get astNodeType() {
		return "unaryOp";
	}
	constEvaluate(e$2, t$1) {
		return e$2.evalExpression(this, e$2.context);
	}
	search(e$2) {
		this.right.search(e$2);
	}
};
var Ie = class extends we {
	constructor(e$2, t$1, n$1) {
		super(), this.operator = e$2, this.left = t$1, this.right = n$1;
	}
	get astNodeType() {
		return "binaryOp";
	}
	_getPromotedType(e$2, t$1) {
		return e$2.name === t$1.name ? e$2 : "f32" === e$2.name || "f32" === t$1.name ? ae.f32 : "u32" === e$2.name || "u32" === t$1.name ? ae.u32 : ae.i32;
	}
	constEvaluate(e$2, t$1) {
		return e$2.evalExpression(this, e$2.context);
	}
	search(e$2) {
		this.left.search(e$2), this.right.search(e$2);
	}
};
var Te = class extends A {
	constructor(e$2) {
		super(), this.body = e$2;
	}
	search(e$2) {
		e$2(this), this.searchBlock(this.body, e$2);
	}
};
var Se = class extends fe {
	constructor() {
		super();
	}
	get astNodeType() {
		return "default";
	}
};
var Ae = class extends Te {
	constructor(e$2, t$1) {
		super(t$1), this.selectors = e$2;
	}
	get astNodeType() {
		return "case";
	}
	search(e$2) {
		this.searchBlock(this.body, e$2);
	}
};
var Ee = class extends Te {
	constructor(e$2) {
		super(e$2);
	}
	get astNodeType() {
		return "default";
	}
	search(e$2) {
		this.searchBlock(this.body, e$2);
	}
};
var $e = class extends A {
	constructor(e$2, t$1, n$1) {
		super(), this.name = e$2, this.type = t$1, this.attributes = n$1;
	}
	get astNodeType() {
		return "argument";
	}
};
var Le = class extends A {
	constructor(e$2, t$1) {
		super(), this.condition = e$2, this.body = t$1;
	}
	get astNodeType() {
		return "elseif";
	}
	search(e$2) {
		this.condition.search(e$2), this.searchBlock(this.body, e$2);
	}
};
var Ce = class extends A {
	constructor(e$2, t$1, n$1) {
		super(), this.name = e$2, this.type = t$1, this.attributes = n$1;
	}
	get astNodeType() {
		return "member";
	}
};
var De = class extends A {
	constructor(e$2, t$1) {
		super(), this.name = e$2, this.value = t$1;
	}
	get astNodeType() {
		return "attribute";
	}
};
var Ne = class Ne {
	constructor(e$2, t$1) {
		this.parent = null, this.typeInfo = e$2, this.parent = t$1, this.id = Ne._id++;
	}
	clone() {
		throw `Clone: Not implemented for ${this.constructor.name}`;
	}
	setDataValue(e$2, t$1, n$1, s$1) {
		console.error(`SetDataValue: Not implemented for ${this.constructor.name}`);
	}
	getSubData(e$2, t$1, n$1) {
		return console.error(`GetDataValue: Not implemented for ${this.constructor.name}`), null;
	}
	toString() {
		return `<${this.typeInfo.getTypeName()}>`;
	}
};
Ne._id = 0;
var Ve = class extends Ne {
	constructor() {
		super(new e$1("void", null), null);
	}
	toString() {
		return "void";
	}
};
Ve.void = new Ve();
var Oe = class extends Ne {
	constructor(e$2) {
		super(new r("pointer", e$2.typeInfo, null), null), this.reference = e$2;
	}
	clone() {
		return this;
	}
	setDataValue(e$2, t$1, n$1, s$1) {
		this.reference.setDataValue(e$2, t$1, n$1, s$1);
	}
	getSubData(e$2, t$1, n$1) {
		return t$1 ? this.reference.getSubData(e$2, t$1, n$1) : this;
	}
	toString() {
		return `&${this.reference.toString()}`;
	}
};
var Be = class Be extends Ne {
	constructor(e$2, t$1, n$1 = null) {
		super(t$1, n$1), e$2 instanceof Int32Array || e$2 instanceof Uint32Array || e$2 instanceof Float32Array ? this.data = e$2 : "x32" === this.typeInfo.name ? e$2 - Math.floor(e$2) !== 0 ? this.data = new Float32Array([e$2]) : this.data = e$2 >= 0 ? new Uint32Array([e$2]) : new Int32Array([e$2]) : "i32" === this.typeInfo.name || "bool" === this.typeInfo.name ? this.data = new Int32Array([e$2]) : "u32" === this.typeInfo.name ? this.data = new Uint32Array([e$2]) : "f32" === this.typeInfo.name || "f16" === this.typeInfo.name ? this.data = new Float32Array([e$2]) : console.error("ScalarData2: Invalid type", t$1);
	}
	clone() {
		if (this.data instanceof Float32Array) return new Be(new Float32Array(this.data), this.typeInfo, null);
		if (this.data instanceof Int32Array) return new Be(new Int32Array(this.data), this.typeInfo, null);
		if (this.data instanceof Uint32Array) return new Be(new Uint32Array(this.data), this.typeInfo, null);
		throw "ScalarData: Invalid data type";
	}
	get value() {
		return this.data[0];
	}
	set value(e$2) {
		this.data[0] = e$2;
	}
	setDataValue(e$2, t$1, n$1, s$1) {
		if (n$1) return void console.error("SetDataValue: Scalar data does not support postfix", n$1);
		if (!(t$1 instanceof Be)) return void console.error("SetDataValue: Invalid value", t$1);
		let r$1 = t$1.data[0];
		"i32" === this.typeInfo.name || "u32" === this.typeInfo.name ? r$1 = Math.floor(r$1) : "bool" === this.typeInfo.name && (r$1 = r$1 ? 1 : 0), this.data[0] = r$1;
	}
	getSubData(e$2, t$1, n$1) {
		return t$1 ? (console.error("getSubData: Scalar data does not support postfix", t$1), null) : this;
	}
	toString() {
		return `${this.value}`;
	}
};
function Fe(e$2, t$1, n$1) {
	const s$1 = t$1.length;
	return 2 === s$1 ? "f32" === n$1 ? new Me(new Float32Array(t$1), e$2.getTypeInfo("vec2f")) : "i32" === n$1 || "bool" === n$1 ? new Me(new Int32Array(t$1), e$2.getTypeInfo("vec2i")) : "u32" === n$1 ? new Me(new Uint32Array(t$1), e$2.getTypeInfo("vec2u")) : "f16" === n$1 ? new Me(new Float32Array(t$1), e$2.getTypeInfo("vec2h")) : (console.error(`getSubData: Unknown format ${n$1}`), null) : 3 === s$1 ? "f32" === n$1 ? new Me(new Float32Array(t$1), e$2.getTypeInfo("vec3f")) : "i32" === n$1 || "bool" === n$1 ? new Me(new Int32Array(t$1), e$2.getTypeInfo("vec3i")) : "u32" === n$1 ? new Me(new Uint32Array(t$1), e$2.getTypeInfo("vec3u")) : "f16" === n$1 ? new Me(new Float32Array(t$1), e$2.getTypeInfo("vec3h")) : (console.error(`getSubData: Unknown format ${n$1}`), null) : 4 === s$1 ? "f32" === n$1 ? new Me(new Float32Array(t$1), e$2.getTypeInfo("vec4f")) : "i32" === n$1 || "bool" === n$1 ? new Me(new Int32Array(t$1), e$2.getTypeInfo("vec4i")) : "u32" === n$1 ? new Me(new Uint32Array(t$1), e$2.getTypeInfo("vec4u")) : "f16" === n$1 ? new Me(new Float32Array(t$1), e$2.getTypeInfo("vec4h")) : (console.error(`getSubData: Unknown format ${n$1}`), null) : (console.error(`getSubData: Invalid vector size ${t$1.length}`), null);
}
var Me = class Me extends Ne {
	constructor(e$2, t$1, n$1 = null) {
		if (super(t$1, n$1), e$2 instanceof Float32Array || e$2 instanceof Uint32Array || e$2 instanceof Int32Array) this.data = e$2;
		else {
			const t$2 = this.typeInfo.name;
			"vec2f" === t$2 || "vec3f" === t$2 || "vec4f" === t$2 ? this.data = new Float32Array(e$2) : "vec2i" === t$2 || "vec3i" === t$2 || "vec4i" === t$2 ? this.data = new Int32Array(e$2) : "vec2u" === t$2 || "vec3u" === t$2 || "vec4u" === t$2 ? this.data = new Uint32Array(e$2) : "vec2h" === t$2 || "vec3h" === t$2 || "vec4h" === t$2 ? this.data = new Float32Array(e$2) : "vec2b" === t$2 || "vec3b" === t$2 || "vec4b" === t$2 ? this.data = new Int32Array(e$2) : "vec2" === t$2 || "vec3" === t$2 || "vec4" === t$2 ? this.data = new Float32Array(e$2) : console.error(`VectorData: Invalid type ${t$2}`);
		}
	}
	clone() {
		if (this.data instanceof Float32Array) return new Me(new Float32Array(this.data), this.typeInfo, null);
		if (this.data instanceof Int32Array) return new Me(new Int32Array(this.data), this.typeInfo, null);
		if (this.data instanceof Uint32Array) return new Me(new Uint32Array(this.data), this.typeInfo, null);
		throw "VectorData: Invalid data type";
	}
	setDataValue(e$2, t$1, n$1, s$1) {
		n$1 instanceof pe ? console.error("TODO: Set vector postfix") : t$1 instanceof Me ? this.data = t$1.data : console.error("SetDataValue: Invalid value", t$1);
	}
	getSubData(e$2, t$1, n$1) {
		if (null === t$1) return this;
		let s$1 = e$2.getTypeInfo("f32");
		if (this.typeInfo instanceof a) s$1 = this.typeInfo.format || s$1;
		else {
			const t$2 = this.typeInfo.name;
			"vec2f" === t$2 || "vec3f" === t$2 || "vec4f" === t$2 ? s$1 = e$2.getTypeInfo("f32") : "vec2i" === t$2 || "vec3i" === t$2 || "vec4i" === t$2 ? s$1 = e$2.getTypeInfo("i32") : "vec2b" === t$2 || "vec3b" === t$2 || "vec4b" === t$2 ? s$1 = e$2.getTypeInfo("bool") : "vec2u" === t$2 || "vec3u" === t$2 || "vec4u" === t$2 ? s$1 = e$2.getTypeInfo("u32") : "vec2h" === t$2 || "vec3h" === t$2 || "vec4h" === t$2 ? s$1 = e$2.getTypeInfo("f16") : console.error(`GetSubData: Unknown type ${t$2}`);
		}
		let r$1 = this;
		for (; null !== t$1 && null !== r$1;) {
			if (t$1 instanceof ve) {
				const a$1 = t$1.index;
				let i$1 = -1;
				if (a$1 instanceof xe) {
					if (!(a$1.value instanceof Be)) return console.error(`GetSubData: Invalid array index ${a$1.value}`), null;
					i$1 = a$1.value.value;
				} else {
					const t$2 = e$2.evalExpression(a$1, n$1);
					if (!(t$2 instanceof Be)) return console.error("GetSubData: Unknown index type", a$1), null;
					i$1 = t$2.value;
				}
				if (i$1 < 0 || i$1 >= r$1.data.length) return console.error("GetSubData: Index out of range", i$1), null;
				if (r$1.data instanceof Float32Array) return new Be(new Float32Array(r$1.data.buffer, r$1.data.byteOffset + 4 * i$1, 1), s$1);
				if (r$1.data instanceof Int32Array) return new Be(new Int32Array(r$1.data.buffer, r$1.data.byteOffset + 4 * i$1, 1), s$1);
				if (r$1.data instanceof Uint32Array) return new Be(new Uint32Array(r$1.data.buffer, r$1.data.byteOffset + 4 * i$1, 1), s$1);
				throw "GetSubData: Invalid data type";
			}
			if (!(t$1 instanceof pe)) return console.error("GetSubData: Unknown postfix", t$1), null;
			{
				const n$2 = t$1.value.toLowerCase();
				if (1 === n$2.length) {
					let e$3 = 0;
					if ("x" === n$2 || "r" === n$2) e$3 = 0;
					else if ("y" === n$2 || "g" === n$2) e$3 = 1;
					else if ("z" === n$2 || "b" === n$2) e$3 = 2;
					else {
						if ("w" !== n$2 && "a" !== n$2) return console.error(`GetSubData: Unknown member ${n$2}`), null;
						e$3 = 3;
					}
					if (this.data instanceof Float32Array) return new Be(new Float32Array(this.data.buffer, this.data.byteOffset + 4 * e$3, 1), s$1, this);
					if (this.data instanceof Int32Array) return new Be(new Int32Array(this.data.buffer, this.data.byteOffset + 4 * e$3, 1), s$1, this);
					if (this.data instanceof Uint32Array) return new Be(new Uint32Array(this.data.buffer, this.data.byteOffset + 4 * e$3, 1), s$1, this);
				}
				const a$1 = [];
				for (const e$3 of n$2) "x" === e$3 || "r" === e$3 ? a$1.push(this.data[0]) : "y" === e$3 || "g" === e$3 ? a$1.push(this.data[1]) : "z" === e$3 || "b" === e$3 ? a$1.push(this.data[2]) : "w" === e$3 || "a" === e$3 ? a$1.push(this.data[3]) : console.error(`GetDataValue: Unknown member ${e$3}`);
				r$1 = Fe(e$2, a$1, s$1.name);
			}
			t$1 = t$1.postfix;
		}
		return r$1;
	}
	toString() {
		let e$2 = `${this.data[0]}`;
		for (let t$1 = 1; t$1 < this.data.length; ++t$1) e$2 += `, ${this.data[t$1]}`;
		return e$2;
	}
};
var Ue = class Ue extends Ne {
	constructor(e$2, t$1, n$1 = null) {
		super(t$1, n$1), e$2 instanceof Float32Array ? this.data = e$2 : this.data = new Float32Array(e$2);
	}
	clone() {
		return new Ue(new Float32Array(this.data), this.typeInfo, null);
	}
	setDataValue(e$2, t$1, n$1, s$1) {
		n$1 instanceof pe ? console.error("TODO: Set matrix postfix") : t$1 instanceof Ue ? this.data = t$1.data : console.error("SetDataValue: Invalid value", t$1);
	}
	getSubData(e$2, t$1, n$1) {
		if (null === t$1) return this;
		const s$1 = this.typeInfo.name;
		if (e$2.getTypeInfo("f32"), this.typeInfo instanceof a) this.typeInfo.format;
		else if (s$1.endsWith("f")) e$2.getTypeInfo("f32");
		else if (s$1.endsWith("i")) e$2.getTypeInfo("i32");
		else if (s$1.endsWith("u")) e$2.getTypeInfo("u32");
		else {
			if (!s$1.endsWith("h")) return console.error(`GetDataValue: Unknown type ${s$1}`), null;
			e$2.getTypeInfo("f16");
		}
		if (t$1 instanceof ve) {
			const r$1 = t$1.index;
			let a$1 = -1;
			if (r$1 instanceof xe) {
				if (!(r$1.value instanceof Be)) return console.error(`GetDataValue: Invalid array index ${r$1.value}`), null;
				a$1 = r$1.value.value;
			} else {
				const t$2 = e$2.evalExpression(r$1, n$1);
				if (!(t$2 instanceof Be)) return console.error("GetDataValue: Unknown index type", r$1), null;
				a$1 = t$2.value;
			}
			if (a$1 < 0 || a$1 >= this.data.length) return console.error("GetDataValue: Index out of range", a$1), null;
			const i$1 = s$1.endsWith("h") ? "h" : "f";
			let o$1;
			if ("mat2x2" === s$1 || "mat2x2f" === s$1 || "mat2x2h" === s$1 || "mat3x2" === s$1 || "mat3x2f" === s$1 || "mat3x2h" === s$1 || "mat4x2" === s$1 || "mat4x2f" === s$1 || "mat4x2h" === s$1) o$1 = new Me(new Float32Array(this.data.buffer, this.data.byteOffset + 2 * a$1 * 4, 2), e$2.getTypeInfo(`vec2${i$1}`));
			else if ("mat2x3" === s$1 || "mat2x3f" === s$1 || "mat2x3h" === s$1 || "mat3x3" === s$1 || "mat3x3f" === s$1 || "mat3x3h" === s$1 || "mat4x3" === s$1 || "mat4x3f" === s$1 || "mat4x3h" === s$1) o$1 = new Me(new Float32Array(this.data.buffer, this.data.byteOffset + 3 * a$1 * 4, 3), e$2.getTypeInfo(`vec3${i$1}`));
			else {
				if ("mat2x4" !== s$1 && "mat2x4f" !== s$1 && "mat2x4h" !== s$1 && "mat3x4" !== s$1 && "mat3x4f" !== s$1 && "mat3x4h" !== s$1 && "mat4x4" !== s$1 && "mat4x4f" !== s$1 && "mat4x4h" !== s$1) return console.error(`GetDataValue: Unknown type ${s$1}`), null;
				o$1 = new Me(new Float32Array(this.data.buffer, this.data.byteOffset + 4 * a$1 * 4, 4), e$2.getTypeInfo(`vec4${i$1}`));
			}
			return t$1.postfix ? o$1.getSubData(e$2, t$1.postfix, n$1) : o$1;
		}
		return console.error("GetDataValue: Invalid postfix", t$1), null;
	}
	toString() {
		let e$2 = `${this.data[0]}`;
		for (let t$1 = 1; t$1 < this.data.length; ++t$1) e$2 += `, ${this.data[t$1]}`;
		return e$2;
	}
};
var Pe = class Pe extends Ne {
	constructor(e$2, t$1, n$1 = 0, s$1 = null) {
		super(t$1, s$1), this.buffer = e$2 instanceof ArrayBuffer ? e$2 : e$2.buffer, this.offset = n$1;
	}
	clone() {
		return new Pe(new Uint8Array(new Uint8Array(this.buffer, this.offset, this.typeInfo.size)).buffer, this.typeInfo, 0, null);
	}
	setDataValue(t$1, r$1, a$1, i$1) {
		if (null === r$1) return void console.log("setDataValue: NULL data.");
		let o$1 = this.offset, c$1 = this.typeInfo;
		for (; a$1;) {
			if (a$1 instanceof ve) if (c$1 instanceof s) {
				const e$2 = a$1.index;
				if (e$2 instanceof xe) {
					if (!(e$2.value instanceof Be)) return void console.error(`SetDataValue: Invalid index type ${e$2.value}`);
					o$1 += e$2.value.value * c$1.stride;
				} else {
					const n$1 = t$1.evalExpression(e$2, i$1);
					if (!(n$1 instanceof Be)) return void console.error("SetDataValue: Unknown index type", e$2);
					o$1 += n$1.value * c$1.stride;
				}
				c$1 = c$1.format;
			} else console.error(`SetDataValue: Type ${c$1.getTypeName()} is not an array`);
			else {
				if (!(a$1 instanceof pe)) return void console.error("SetDataValue: Unknown postfix type", a$1);
				{
					const t$2 = a$1.value;
					if (c$1 instanceof n) {
						let e$2 = !1;
						for (const n$1 of c$1.members) if (n$1.name === t$2) {
							o$1 += n$1.offset, c$1 = n$1.type, e$2 = !0;
							break;
						}
						if (!e$2) return void console.error(`SetDataValue: Member ${t$2} not found`);
					} else if (c$1 instanceof e$1) {
						const e$2 = c$1.getTypeName();
						let n$1 = 0;
						if ("x" === t$2 || "r" === t$2) n$1 = 0;
						else if ("y" === t$2 || "g" === t$2) n$1 = 1;
						else if ("z" === t$2 || "b" === t$2) n$1 = 2;
						else {
							if ("w" !== t$2 && "a" !== t$2) return void console.error(`SetDataValue: Unknown member ${t$2}`);
							n$1 = 3;
						}
						if (!(r$1 instanceof Be)) return void console.error("SetDataValue: Invalid value", r$1);
						const s$1 = r$1.value;
						"vec2f" === e$2 ? new Float32Array(this.buffer, o$1, 2)[n$1] = s$1 : "vec3f" === e$2 ? new Float32Array(this.buffer, o$1, 3)[n$1] = s$1 : "vec4f" === e$2 ? new Float32Array(this.buffer, o$1, 4)[n$1] = s$1 : "vec2i" === e$2 ? new Int32Array(this.buffer, o$1, 2)[n$1] = s$1 : "vec3i" === e$2 ? new Int32Array(this.buffer, o$1, 3)[n$1] = s$1 : "vec4i" === e$2 ? new Int32Array(this.buffer, o$1, 4)[n$1] = s$1 : "vec2u" === e$2 ? new Uint32Array(this.buffer, o$1, 2)[n$1] = s$1 : "vec3u" === e$2 ? new Uint32Array(this.buffer, o$1, 3)[n$1] = s$1 : "vec4u" === e$2 ? new Uint32Array(this.buffer, o$1, 4)[n$1] = s$1 : console.error(`SetDataValue: Type ${e$2} is not a struct`);
						return;
					}
				}
			}
			a$1 = a$1.postfix;
		}
		this.setData(t$1, r$1, c$1, o$1, i$1);
	}
	setData(e$2, t$1, n$1, s$1, r$1) {
		const a$1 = n$1.getTypeName();
		if ("f32" !== a$1 && "f16" !== a$1) if ("i32" !== a$1 && "atomic<i32>" !== a$1 && "x32" !== a$1) if ("u32" !== a$1 && "atomic<u32>" !== a$1) if ("bool" !== a$1) {
			if ("vec2f" === a$1 || "vec2h" === a$1) {
				const e$3 = new Float32Array(this.buffer, s$1, 2);
				t$1 instanceof Me ? (e$3[0] = t$1.data[0], e$3[1] = t$1.data[1]) : (e$3[0] = t$1[0], e$3[1] = t$1[1]);
				return;
			}
			if ("vec3f" === a$1 || "vec3h" === a$1) {
				const e$3 = new Float32Array(this.buffer, s$1, 3);
				t$1 instanceof Me ? (e$3[0] = t$1.data[0], e$3[1] = t$1.data[1], e$3[2] = t$1.data[2]) : (e$3[0] = t$1[0], e$3[1] = t$1[1], e$3[2] = t$1[2]);
				return;
			}
			if ("vec4f" === a$1 || "vec4h" === a$1) {
				const e$3 = new Float32Array(this.buffer, s$1, 4);
				t$1 instanceof Me ? (e$3[0] = t$1.data[0], e$3[1] = t$1.data[1], e$3[2] = t$1.data[2], e$3[3] = t$1.data[3]) : (e$3[0] = t$1[0], e$3[1] = t$1[1], e$3[2] = t$1[2], e$3[3] = t$1[3]);
				return;
			}
			if ("vec2i" === a$1) {
				const e$3 = new Int32Array(this.buffer, s$1, 2);
				t$1 instanceof Me ? (e$3[0] = t$1.data[0], e$3[1] = t$1.data[1]) : (e$3[0] = t$1[0], e$3[1] = t$1[1]);
				return;
			}
			if ("vec3i" === a$1) {
				const e$3 = new Int32Array(this.buffer, s$1, 3);
				t$1 instanceof Me ? (e$3[0] = t$1.data[0], e$3[1] = t$1.data[1], e$3[2] = t$1.data[2]) : (e$3[0] = t$1[0], e$3[1] = t$1[1], e$3[2] = t$1[2]);
				return;
			}
			if ("vec4i" === a$1) {
				const e$3 = new Int32Array(this.buffer, s$1, 4);
				t$1 instanceof Me ? (e$3[0] = t$1.data[0], e$3[1] = t$1.data[1], e$3[2] = t$1.data[2], e$3[3] = t$1.data[3]) : (e$3[0] = t$1[0], e$3[1] = t$1[1], e$3[2] = t$1[2], e$3[3] = t$1[3]);
				return;
			}
			if ("vec2u" === a$1) {
				const e$3 = new Uint32Array(this.buffer, s$1, 2);
				t$1 instanceof Me ? (e$3[0] = t$1.data[0], e$3[1] = t$1.data[1]) : (e$3[0] = t$1[0], e$3[1] = t$1[1]);
				return;
			}
			if ("vec3u" === a$1) {
				const e$3 = new Uint32Array(this.buffer, s$1, 3);
				t$1 instanceof Me ? (e$3[0] = t$1.data[0], e$3[1] = t$1.data[1], e$3[2] = t$1.data[2]) : (e$3[0] = t$1[0], e$3[1] = t$1[1], e$3[2] = t$1[2]);
				return;
			}
			if ("vec4u" === a$1) {
				const e$3 = new Uint32Array(this.buffer, s$1, 4);
				t$1 instanceof Me ? (e$3[0] = t$1.data[0], e$3[1] = t$1.data[1], e$3[2] = t$1.data[2], e$3[3] = t$1.data[3]) : (e$3[0] = t$1[0], e$3[1] = t$1[1], e$3[2] = t$1[2], e$3[3] = t$1[3]);
				return;
			}
			if ("vec2b" === a$1) {
				const e$3 = new Uint32Array(this.buffer, s$1, 2);
				t$1 instanceof Me ? (e$3[0] = t$1.data[0], e$3[1] = t$1.data[1]) : (e$3[0] = t$1[0], e$3[1] = t$1[1]);
				return;
			}
			if ("vec3b" === a$1) {
				const e$3 = new Uint32Array(this.buffer, s$1, 3);
				t$1 instanceof Me ? (e$3[0] = t$1.data[0], e$3[1] = t$1.data[1], e$3[2] = t$1.data[2]) : (e$3[0] = t$1[0], e$3[1] = t$1[1], e$3[2] = t$1[2]);
				return;
			}
			if ("vec4b" === a$1) {
				const e$3 = new Uint32Array(this.buffer, s$1, 4);
				t$1 instanceof Me ? (e$3[0] = t$1.data[0], e$3[1] = t$1.data[1], e$3[2] = t$1.data[2], e$3[3] = t$1.data[3]) : (e$3[0] = t$1[0], e$3[1] = t$1[1], e$3[2] = t$1[2], e$3[3] = t$1[3]);
				return;
			}
			if ("mat2x2f" === a$1 || "mat2x2h" === a$1) {
				const e$3 = new Float32Array(this.buffer, s$1, 4);
				t$1 instanceof Ue ? (e$3[0] = t$1.data[0], e$3[1] = t$1.data[1], e$3[2] = t$1.data[2], e$3[3] = t$1.data[3]) : (e$3[0] = t$1[0], e$3[1] = t$1[1], e$3[2] = t$1[2], e$3[3] = t$1[3]);
				return;
			}
			if ("mat2x3f" === a$1 || "mat2x3h" === a$1) {
				const e$3 = new Float32Array(this.buffer, s$1, 6);
				t$1 instanceof Ue ? (e$3[0] = t$1.data[0], e$3[1] = t$1.data[1], e$3[2] = t$1.data[2], e$3[3] = t$1.data[3], e$3[4] = t$1.data[4], e$3[5] = t$1.data[5]) : (e$3[0] = t$1[0], e$3[1] = t$1[1], e$3[2] = t$1[2], e$3[3] = t$1[3], e$3[4] = t$1[4], e$3[5] = t$1[5]);
				return;
			}
			if ("mat2x4f" === a$1 || "mat2x4h" === a$1) {
				const e$3 = new Float32Array(this.buffer, s$1, 8);
				t$1 instanceof Ue ? (e$3[0] = t$1.data[0], e$3[1] = t$1.data[1], e$3[2] = t$1.data[2], e$3[3] = t$1.data[3], e$3[4] = t$1.data[4], e$3[5] = t$1.data[5], e$3[6] = t$1.data[6], e$3[7] = t$1.data[7]) : (e$3[0] = t$1[0], e$3[1] = t$1[1], e$3[2] = t$1[2], e$3[3] = t$1[3], e$3[4] = t$1[4], e$3[5] = t$1[5], e$3[6] = t$1[6], e$3[7] = t$1[7]);
				return;
			}
			if ("mat3x2f" === a$1 || "mat3x2h" === a$1) {
				const e$3 = new Float32Array(this.buffer, s$1, 6);
				t$1 instanceof Ue ? (e$3[0] = t$1.data[0], e$3[1] = t$1.data[1], e$3[2] = t$1.data[2], e$3[3] = t$1.data[3], e$3[4] = t$1.data[4], e$3[5] = t$1.data[5]) : (e$3[0] = t$1[0], e$3[1] = t$1[1], e$3[2] = t$1[2], e$3[3] = t$1[3], e$3[4] = t$1[4], e$3[5] = t$1[5]);
				return;
			}
			if ("mat3x3f" === a$1 || "mat3x3h" === a$1) {
				const e$3 = new Float32Array(this.buffer, s$1, 9);
				t$1 instanceof Ue ? (e$3[0] = t$1.data[0], e$3[1] = t$1.data[1], e$3[2] = t$1.data[2], e$3[3] = t$1.data[3], e$3[4] = t$1.data[4], e$3[5] = t$1.data[5], e$3[6] = t$1.data[6], e$3[7] = t$1.data[7], e$3[8] = t$1.data[8]) : (e$3[0] = t$1[0], e$3[1] = t$1[1], e$3[2] = t$1[2], e$3[3] = t$1[3], e$3[4] = t$1[4], e$3[5] = t$1[5], e$3[6] = t$1[6], e$3[7] = t$1[7], e$3[8] = t$1[8]);
				return;
			}
			if ("mat3x4f" === a$1 || "mat3x4h" === a$1) {
				const e$3 = new Float32Array(this.buffer, s$1, 12);
				t$1 instanceof Ue ? (e$3[0] = t$1.data[0], e$3[1] = t$1.data[1], e$3[2] = t$1.data[2], e$3[3] = t$1.data[3], e$3[4] = t$1.data[4], e$3[5] = t$1.data[5], e$3[6] = t$1.data[6], e$3[7] = t$1.data[7], e$3[8] = t$1.data[8], e$3[9] = t$1.data[9], e$3[10] = t$1.data[10], e$3[11] = t$1.data[11]) : (e$3[0] = t$1[0], e$3[1] = t$1[1], e$3[2] = t$1[2], e$3[3] = t$1[3], e$3[4] = t$1[4], e$3[5] = t$1[5], e$3[6] = t$1[6], e$3[7] = t$1[7], e$3[8] = t$1[8], e$3[9] = t$1[9], e$3[10] = t$1[10], e$3[11] = t$1[11]);
				return;
			}
			if ("mat4x2f" === a$1 || "mat4x2h" === a$1) {
				const e$3 = new Float32Array(this.buffer, s$1, 8);
				t$1 instanceof Ue ? (e$3[0] = t$1.data[0], e$3[1] = t$1.data[1], e$3[2] = t$1.data[2], e$3[3] = t$1.data[3], e$3[4] = t$1.data[4], e$3[5] = t$1.data[5], e$3[6] = t$1.data[6], e$3[7] = t$1.data[7]) : (e$3[0] = t$1[0], e$3[1] = t$1[1], e$3[2] = t$1[2], e$3[3] = t$1[3], e$3[4] = t$1[4], e$3[5] = t$1[5], e$3[6] = t$1[6], e$3[7] = t$1[7]);
				return;
			}
			if ("mat4x3f" === a$1 || "mat4x3h" === a$1) {
				const e$3 = new Float32Array(this.buffer, s$1, 12);
				t$1 instanceof Ue ? (e$3[0] = t$1.data[0], e$3[1] = t$1.data[1], e$3[2] = t$1.data[2], e$3[3] = t$1.data[3], e$3[4] = t$1.data[4], e$3[5] = t$1.data[5], e$3[6] = t$1.data[6], e$3[7] = t$1.data[7], e$3[8] = t$1.data[8], e$3[9] = t$1.data[9], e$3[10] = t$1.data[10], e$3[11] = t$1.data[11]) : (e$3[0] = t$1[0], e$3[1] = t$1[1], e$3[2] = t$1[2], e$3[3] = t$1[3], e$3[4] = t$1[4], e$3[5] = t$1[5], e$3[6] = t$1[6], e$3[7] = t$1[7], e$3[8] = t$1[8], e$3[9] = t$1[9], e$3[10] = t$1[10], e$3[11] = t$1[11]);
				return;
			}
			if ("mat4x4f" === a$1 || "mat4x4h" === a$1) {
				const e$3 = new Float32Array(this.buffer, s$1, 16);
				t$1 instanceof Ue ? (e$3[0] = t$1.data[0], e$3[1] = t$1.data[1], e$3[2] = t$1.data[2], e$3[3] = t$1.data[3], e$3[4] = t$1.data[4], e$3[5] = t$1.data[5], e$3[6] = t$1.data[6], e$3[7] = t$1.data[7], e$3[8] = t$1.data[8], e$3[9] = t$1.data[9], e$3[10] = t$1.data[10], e$3[11] = t$1.data[11], e$3[12] = t$1.data[12], e$3[13] = t$1.data[13], e$3[14] = t$1.data[14], e$3[15] = t$1.data[15]) : (e$3[0] = t$1[0], e$3[1] = t$1[1], e$3[2] = t$1[2], e$3[3] = t$1[3], e$3[4] = t$1[4], e$3[5] = t$1[5], e$3[6] = t$1[6], e$3[7] = t$1[7], e$3[8] = t$1[8], e$3[9] = t$1[9], e$3[10] = t$1[10], e$3[11] = t$1[11], e$3[12] = t$1[12], e$3[13] = t$1[13], e$3[14] = t$1[14], e$3[15] = t$1[15]);
				return;
			}
			if (t$1 instanceof Pe) {
				if (n$1 === t$1.typeInfo) {
					new Uint8Array(this.buffer, s$1, t$1.buffer.byteLength).set(new Uint8Array(t$1.buffer));
					return;
				}
				console.error("SetDataValue: Type mismatch", a$1, t$1.typeInfo.getTypeName());
			} else console.error(`SetData: Unknown type ${a$1}`);
		} else t$1 instanceof Be && (new Int32Array(this.buffer, s$1, 1)[0] = t$1.value);
		else t$1 instanceof Be && (new Uint32Array(this.buffer, s$1, 1)[0] = t$1.value);
		else t$1 instanceof Be && (new Int32Array(this.buffer, s$1, 1)[0] = t$1.value);
		else t$1 instanceof Be && (new Float32Array(this.buffer, s$1, 1)[0] = t$1.value);
	}
	getSubData(t$1, r$1, i$1) {
		var o$1, c$1, l$1;
		if (null === r$1) return this;
		let u$1 = this.offset, h$1 = this.typeInfo;
		for (; r$1;) {
			if (r$1 instanceof ve) {
				const e$2 = r$1.index, n$1 = e$2 instanceof fe ? t$1.evalExpression(e$2, i$1) : e$2;
				let a$1 = 0;
				if (n$1 instanceof Be ? a$1 = n$1.value : "number" == typeof n$1 ? a$1 = n$1 : console.error("GetDataValue: Invalid index type", e$2), h$1 instanceof s) u$1 += a$1 * h$1.stride, h$1 = h$1.format;
				else {
					const e$3 = h$1.getTypeName();
					"mat4x4" === e$3 || "mat4x4f" === e$3 || "mat4x4h" === e$3 ? (u$1 += 16 * a$1, h$1 = t$1.getTypeInfo("vec4f")) : console.error(`getDataValue: Type ${h$1.getTypeName()} is not an array`);
				}
			} else {
				if (!(r$1 instanceof pe)) return console.error("GetDataValue: Unknown postfix type", r$1), null;
				{
					const s$1 = r$1.value;
					if (h$1 instanceof n) {
						let e$2 = !1;
						for (const t$2 of h$1.members) if (t$2.name === s$1) {
							u$1 += t$2.offset, h$1 = t$2.type, e$2 = !0;
							break;
						}
						if (!e$2) return console.error(`GetDataValue: Member ${s$1} not found`), null;
					} else if (h$1 instanceof e$1) {
						const e$2 = h$1.getTypeName();
						if ("vec2f" === e$2 || "vec3f" === e$2 || "vec4f" === e$2 || "vec2i" === e$2 || "vec3i" === e$2 || "vec4i" === e$2 || "vec2u" === e$2 || "vec3u" === e$2 || "vec4u" === e$2 || "vec2b" === e$2 || "vec3b" === e$2 || "vec4b" === e$2 || "vec2h" === e$2 || "vec3h" === e$2 || "vec4h" === e$2 || "vec2" === e$2 || "vec3" === e$2 || "vec4" === e$2) {
							if (s$1.length > 0 && s$1.length < 5) {
								let n$1 = "f";
								const r$2 = [];
								for (let a$1 = 0; a$1 < s$1.length; ++a$1) {
									const i$2 = s$1[a$1].toLowerCase();
									let o$2 = 0;
									if ("x" === i$2 || "r" === i$2) o$2 = 0;
									else if ("y" === i$2 || "g" === i$2) o$2 = 1;
									else if ("z" === i$2 || "b" === i$2) o$2 = 2;
									else {
										if ("w" !== i$2 && "a" !== i$2) return console.error(`Unknown member ${s$1}`), null;
										o$2 = 3;
									}
									if (1 === s$1.length) {
										if (e$2.endsWith("f")) return this.buffer.byteLength < u$1 + 4 * o$2 + 4 ? (console.log("Insufficient buffer data"), null) : new Be(new Float32Array(this.buffer, u$1 + 4 * o$2, 1), t$1.getTypeInfo("f32"), this);
										if (e$2.endsWith("h")) return new Be(new Float32Array(this.buffer, u$1 + 4 * o$2, 1), t$1.getTypeInfo("f16"), this);
										if (e$2.endsWith("i")) return new Be(new Int32Array(this.buffer, u$1 + 4 * o$2, 1), t$1.getTypeInfo("i32"), this);
										if (e$2.endsWith("b")) return new Be(new Int32Array(this.buffer, u$1 + 4 * o$2, 1), t$1.getTypeInfo("bool"), this);
										if (e$2.endsWith("u")) return new Be(new Uint32Array(this.buffer, u$1 + 4 * o$2, 1), t$1.getTypeInfo("i32"), this);
									}
									if ("vec2f" === e$2) r$2.push(new Float32Array(this.buffer, u$1, 2)[o$2]);
									else if ("vec3f" === e$2) {
										if (u$1 + 12 >= this.buffer.byteLength) return console.log("Insufficient buffer data"), null;
										const e$3 = new Float32Array(this.buffer, u$1, 3);
										r$2.push(e$3[o$2]);
									} else if ("vec4f" === e$2) r$2.push(new Float32Array(this.buffer, u$1, 4)[o$2]);
									else if ("vec2i" === e$2) n$1 = "i", r$2.push(new Int32Array(this.buffer, u$1, 2)[o$2]);
									else if ("vec3i" === e$2) n$1 = "i", r$2.push(new Int32Array(this.buffer, u$1, 3)[o$2]);
									else if ("vec4i" === e$2) n$1 = "i", r$2.push(new Int32Array(this.buffer, u$1, 4)[o$2]);
									else if ("vec2u" === e$2) {
										n$1 = "u";
										const e$3 = new Uint32Array(this.buffer, u$1, 2);
										r$2.push(e$3[o$2]);
									} else "vec3u" === e$2 ? (n$1 = "u", r$2.push(new Uint32Array(this.buffer, u$1, 3)[o$2])) : "vec4u" === e$2 && (n$1 = "u", r$2.push(new Uint32Array(this.buffer, u$1, 4)[o$2]));
								}
								return 2 === r$2.length ? h$1 = t$1.getTypeInfo(`vec2${n$1}`) : 3 === r$2.length ? h$1 = t$1.getTypeInfo(`vec3${n$1}`) : 4 === r$2.length ? h$1 = t$1.getTypeInfo(`vec4${n$1}`) : console.error(`GetDataValue: Invalid vector length ${r$2.length}`), new Me(r$2, h$1, null);
							}
							return console.error(`GetDataValue: Unknown member ${s$1}`), null;
						}
						return console.error(`GetDataValue: Type ${e$2} is not a struct`), null;
					}
				}
			}
			r$1 = r$1.postfix;
		}
		const f$1 = h$1.getTypeName();
		return "f32" === f$1 ? new Be(new Float32Array(this.buffer, u$1, 1), h$1, this) : "i32" === f$1 ? new Be(new Int32Array(this.buffer, u$1, 1), h$1, this) : "u32" === f$1 ? new Be(new Uint32Array(this.buffer, u$1, 1), h$1, this) : "vec2f" === f$1 ? new Me(new Float32Array(this.buffer, u$1, 2), h$1, this) : "vec3f" === f$1 ? new Me(new Float32Array(this.buffer, u$1, 3), h$1, this) : "vec4f" === f$1 ? new Me(new Float32Array(this.buffer, u$1, 4), h$1, this) : "vec2i" === f$1 ? new Me(new Int32Array(this.buffer, u$1, 2), h$1, this) : "vec3i" === f$1 ? new Me(new Int32Array(this.buffer, u$1, 3), h$1, this) : "vec4i" === f$1 ? new Me(new Int32Array(this.buffer, u$1, 4), h$1, this) : "vec2u" === f$1 ? new Me(new Uint32Array(this.buffer, u$1, 2), h$1, this) : "vec3u" === f$1 ? new Me(new Uint32Array(this.buffer, u$1, 3), h$1, this) : "vec4u" === f$1 ? new Me(new Uint32Array(this.buffer, u$1, 4), h$1, this) : h$1 instanceof a && "atomic" === h$1.name ? "u32" === (null === (o$1 = h$1.format) || void 0 === o$1 ? void 0 : o$1.name) ? new Be(new Uint32Array(this.buffer, u$1, 1)[0], h$1.format, this) : "i32" === (null === (c$1 = h$1.format) || void 0 === c$1 ? void 0 : c$1.name) ? new Be(new Int32Array(this.buffer, u$1, 1)[0], h$1.format, this) : (console.error(`GetDataValue: Invalid atomic format ${null === (l$1 = h$1.format) || void 0 === l$1 ? void 0 : l$1.name}`), null) : new Pe(this.buffer, h$1, u$1, this);
	}
	toString() {
		let e$2 = "";
		if (this.typeInfo instanceof s) if ("f32" === this.typeInfo.format.name) {
			const t$1 = new Float32Array(this.buffer, this.offset);
			e$2 = `[${t$1[0]}`;
			for (let n$1 = 1; n$1 < t$1.length; ++n$1) e$2 += `, ${t$1[n$1]}`;
		} else if ("i32" === this.typeInfo.format.name) {
			const t$1 = new Int32Array(this.buffer, this.offset);
			e$2 = `[${t$1[0]}`;
			for (let n$1 = 1; n$1 < t$1.length; ++n$1) e$2 += `, ${t$1[n$1]}`;
		} else if ("u32" === this.typeInfo.format.name) {
			const t$1 = new Uint32Array(this.buffer, this.offset);
			e$2 = `[${t$1[0]}`;
			for (let n$1 = 1; n$1 < t$1.length; ++n$1) e$2 += `, ${t$1[n$1]}`;
		} else if ("vec2f" === this.typeInfo.format.name) {
			const t$1 = new Float32Array(this.buffer, this.offset);
			e$2 = `[${t$1[0]}, ${t$1[1]}]`;
			for (let n$1 = 1; n$1 < t$1.length / 2; ++n$1) e$2 += `, [${t$1[2 * n$1]}, ${t$1[2 * n$1 + 1]}]`;
		} else if ("vec3f" === this.typeInfo.format.name) {
			const t$1 = new Float32Array(this.buffer, this.offset);
			e$2 = `[${t$1[0]}, ${t$1[1]}, ${t$1[2]}]`;
			for (let n$1 = 4; n$1 < t$1.length; n$1 += 4) e$2 += `, [${t$1[n$1]}, ${t$1[n$1 + 1]}, ${t$1[n$1 + 2]}]`;
		} else if ("vec4f" === this.typeInfo.format.name) {
			const t$1 = new Float32Array(this.buffer, this.offset);
			e$2 = `[${t$1[0]}, ${t$1[1]}, ${t$1[2]}, ${t$1[3]}]`;
			for (let n$1 = 4; n$1 < t$1.length; n$1 += 4) e$2 += `, [${t$1[n$1]}, ${t$1[n$1 + 1]}, ${t$1[n$1 + 2]}, ${t$1[n$1 + 3]}]`;
		} else e$2 = "[...]";
		else this.typeInfo instanceof n ? e$2 += "{...}" : e$2 = "[...]";
		return e$2;
	}
};
var We = class We extends Ne {
	constructor(e$2, t$1, n$1, s$1) {
		super(t$1, null), this.data = e$2, this.descriptor = n$1, this.view = s$1;
	}
	clone() {
		return new We(this.data, this.typeInfo, this.descriptor, this.view);
	}
	get width() {
		var e$2, t$1;
		const n$1 = this.descriptor.size;
		return n$1 instanceof Array && n$1.length > 0 ? null !== (e$2 = n$1[0]) && void 0 !== e$2 ? e$2 : 0 : n$1 instanceof Object && null !== (t$1 = n$1.width) && void 0 !== t$1 ? t$1 : 0;
	}
	get height() {
		var e$2, t$1;
		const n$1 = this.descriptor.size;
		return n$1 instanceof Array && n$1.length > 1 ? null !== (e$2 = n$1[1]) && void 0 !== e$2 ? e$2 : 0 : n$1 instanceof Object && null !== (t$1 = n$1.height) && void 0 !== t$1 ? t$1 : 0;
	}
	get depthOrArrayLayers() {
		var e$2, t$1;
		const n$1 = this.descriptor.size;
		return n$1 instanceof Array && n$1.length > 2 ? null !== (e$2 = n$1[2]) && void 0 !== e$2 ? e$2 : 0 : n$1 instanceof Object && null !== (t$1 = n$1.depthOrArrayLayers) && void 0 !== t$1 ? t$1 : 0;
	}
	get format() {
		var e$2;
		return this.descriptor && null !== (e$2 = this.descriptor.format) && void 0 !== e$2 ? e$2 : "rgba8unorm";
	}
	get sampleCount() {
		var e$2;
		return this.descriptor && null !== (e$2 = this.descriptor.sampleCount) && void 0 !== e$2 ? e$2 : 1;
	}
	get mipLevelCount() {
		var e$2;
		return this.descriptor && null !== (e$2 = this.descriptor.mipLevelCount) && void 0 !== e$2 ? e$2 : 1;
	}
	get dimension() {
		var e$2;
		return this.descriptor && null !== (e$2 = this.descriptor.dimension) && void 0 !== e$2 ? e$2 : "2d";
	}
	getMipLevelSize(e$2) {
		if (e$2 >= this.mipLevelCount) return [
			0,
			0,
			0
		];
		const t$1 = [
			this.width,
			this.height,
			this.depthOrArrayLayers
		];
		for (let n$1 = 0; n$1 < t$1.length; ++n$1) t$1[n$1] = Math.max(1, t$1[n$1] >> e$2);
		return t$1;
	}
	get texelByteSize() {
		const t$1 = S[this.format];
		return t$1 ? t$1.isDepthStencil ? 4 : t$1.bytesPerBlock : 0;
	}
	get bytesPerRow() {
		return this.width * this.texelByteSize;
	}
	get isDepthStencil() {
		const t$1 = S[this.format];
		return !!t$1 && t$1.isDepthStencil;
	}
	getGpuSize() {
		const e$2 = this.format, t$1 = S[e$2], n$1 = this.width;
		if (!e$2 || n$1 <= 0 || !t$1) return -1;
		const s$1 = this.height, r$1 = this.depthOrArrayLayers, a$1 = this.dimension;
		return n$1 / t$1.blockWidth * ("1d" === a$1 ? 1 : s$1 / t$1.blockHeight) * t$1.bytesPerBlock * r$1;
	}
	getPixel(e$2, t$1, n$1 = 0, s$1 = 0) {
		const r$1 = this.texelByteSize, a$1 = this.bytesPerRow, i$1 = this.height, o$1 = this.data[s$1];
		return k(new Uint8Array(o$1), e$2, t$1, n$1, s$1, i$1, a$1, r$1, this.format);
	}
	setPixel(e$2, t$1, n$1, s$1, r$1) {
		const a$1 = this.texelByteSize, i$1 = this.bytesPerRow, o$1 = this.height, c$1 = this.data[s$1];
		(function(e$3, t$2, n$2, s$2, r$2, a$2, i$2, o$2, c$2, l$1) {
			const u$1 = s$2 * (i$2 >>= r$2) * (a$2 >>= r$2) + n$2 * i$2 + t$2 * o$2;
			switch (c$2) {
				case "r8unorm":
					T(e$3, u$1, "8unorm", 1, l$1);
					return;
				case "r8snorm":
					T(e$3, u$1, "8snorm", 1, l$1);
					return;
				case "r8uint":
					T(e$3, u$1, "8uint", 1, l$1);
					return;
				case "r8sint":
					T(e$3, u$1, "8sint", 1, l$1);
					return;
				case "rg8unorm":
					T(e$3, u$1, "8unorm", 2, l$1);
					return;
				case "rg8snorm":
					T(e$3, u$1, "8snorm", 2, l$1);
					return;
				case "rg8uint":
					T(e$3, u$1, "8uint", 2, l$1);
					return;
				case "rg8sint":
					T(e$3, u$1, "8sint", 2, l$1);
					return;
				case "rgba8unorm-srgb":
				case "rgba8unorm":
				case "bgra8unorm-srgb":
				case "bgra8unorm":
					T(e$3, u$1, "8unorm", 4, l$1);
					return;
				case "rgba8snorm":
					T(e$3, u$1, "8snorm", 4, l$1);
					return;
				case "rgba8uint":
					T(e$3, u$1, "8uint", 4, l$1);
					return;
				case "rgba8sint":
					T(e$3, u$1, "8sint", 4, l$1);
					return;
				case "r16uint":
					T(e$3, u$1, "16uint", 1, l$1);
					return;
				case "r16sint":
					T(e$3, u$1, "16sint", 1, l$1);
					return;
				case "r16float":
					T(e$3, u$1, "16float", 1, l$1);
					return;
				case "rg16uint":
					T(e$3, u$1, "16uint", 2, l$1);
					return;
				case "rg16sint":
					T(e$3, u$1, "16sint", 2, l$1);
					return;
				case "rg16float":
					T(e$3, u$1, "16float", 2, l$1);
					return;
				case "rgba16uint":
					T(e$3, u$1, "16uint", 4, l$1);
					return;
				case "rgba16sint":
					T(e$3, u$1, "16sint", 4, l$1);
					return;
				case "rgba16float":
					T(e$3, u$1, "16float", 4, l$1);
					return;
				case "r32uint":
					T(e$3, u$1, "32uint", 1, l$1);
					return;
				case "r32sint":
					T(e$3, u$1, "32sint", 1, l$1);
					return;
				case "depth16unorm":
				case "depth24plus":
				case "depth24plus-stencil8":
				case "depth32float":
				case "depth32float-stencil8":
				case "r32float":
					T(e$3, u$1, "32float", 1, l$1);
					return;
				case "rg32uint":
					T(e$3, u$1, "32uint", 2, l$1);
					return;
				case "rg32sint":
					T(e$3, u$1, "32sint", 2, l$1);
					return;
				case "rg32float":
					T(e$3, u$1, "32float", 2, l$1);
					return;
				case "rgba32uint":
					T(e$3, u$1, "32uint", 4, l$1);
					return;
				case "rgba32sint":
					T(e$3, u$1, "32sint", 4, l$1);
					return;
				case "rgba32float":
					T(e$3, u$1, "32float", 4, l$1);
					return;
				case "rg11b10ufloat": console.error("TODO: rg11b10ufloat not supported for writing");
			}
		})(new Uint8Array(c$1), e$2, t$1, n$1, s$1, o$1, i$1, a$1, this.format, r$1);
	}
};
((e$2) => {
	e$2[e$2.token = 0] = "token", e$2[e$2.keyword = 1] = "keyword", e$2[e$2.reserved = 2] = "reserved";
})(z || (z = {}));
var qe = class {
	constructor(e$2, t$1, n$1) {
		this.name = e$2, this.type = t$1, this.rule = n$1;
	}
	toString() {
		return this.name;
	}
};
var He = class {};
H = He, He.none = new qe("", z.reserved, ""), He.eof = new qe("EOF", z.token, ""), He.reserved = {
	asm: new qe("asm", z.reserved, "asm"),
	bf16: new qe("bf16", z.reserved, "bf16"),
	do: new qe("do", z.reserved, "do"),
	enum: new qe("enum", z.reserved, "enum"),
	f16: new qe("f16", z.reserved, "f16"),
	f64: new qe("f64", z.reserved, "f64"),
	handle: new qe("handle", z.reserved, "handle"),
	i8: new qe("i8", z.reserved, "i8"),
	i16: new qe("i16", z.reserved, "i16"),
	i64: new qe("i64", z.reserved, "i64"),
	mat: new qe("mat", z.reserved, "mat"),
	premerge: new qe("premerge", z.reserved, "premerge"),
	regardless: new qe("regardless", z.reserved, "regardless"),
	typedef: new qe("typedef", z.reserved, "typedef"),
	u8: new qe("u8", z.reserved, "u8"),
	u16: new qe("u16", z.reserved, "u16"),
	u64: new qe("u64", z.reserved, "u64"),
	unless: new qe("unless", z.reserved, "unless"),
	using: new qe("using", z.reserved, "using"),
	vec: new qe("vec", z.reserved, "vec"),
	void: new qe("void", z.reserved, "void")
}, He.keywords = {
	array: new qe("array", z.keyword, "array"),
	atomic: new qe("atomic", z.keyword, "atomic"),
	bool: new qe("bool", z.keyword, "bool"),
	f32: new qe("f32", z.keyword, "f32"),
	i32: new qe("i32", z.keyword, "i32"),
	mat2x2: new qe("mat2x2", z.keyword, "mat2x2"),
	mat2x3: new qe("mat2x3", z.keyword, "mat2x3"),
	mat2x4: new qe("mat2x4", z.keyword, "mat2x4"),
	mat3x2: new qe("mat3x2", z.keyword, "mat3x2"),
	mat3x3: new qe("mat3x3", z.keyword, "mat3x3"),
	mat3x4: new qe("mat3x4", z.keyword, "mat3x4"),
	mat4x2: new qe("mat4x2", z.keyword, "mat4x2"),
	mat4x3: new qe("mat4x3", z.keyword, "mat4x3"),
	mat4x4: new qe("mat4x4", z.keyword, "mat4x4"),
	ptr: new qe("ptr", z.keyword, "ptr"),
	sampler: new qe("sampler", z.keyword, "sampler"),
	sampler_comparison: new qe("sampler_comparison", z.keyword, "sampler_comparison"),
	struct: new qe("struct", z.keyword, "struct"),
	texture_1d: new qe("texture_1d", z.keyword, "texture_1d"),
	texture_2d: new qe("texture_2d", z.keyword, "texture_2d"),
	texture_2d_array: new qe("texture_2d_array", z.keyword, "texture_2d_array"),
	texture_3d: new qe("texture_3d", z.keyword, "texture_3d"),
	texture_cube: new qe("texture_cube", z.keyword, "texture_cube"),
	texture_cube_array: new qe("texture_cube_array", z.keyword, "texture_cube_array"),
	texture_multisampled_2d: new qe("texture_multisampled_2d", z.keyword, "texture_multisampled_2d"),
	texture_storage_1d: new qe("texture_storage_1d", z.keyword, "texture_storage_1d"),
	texture_storage_2d: new qe("texture_storage_2d", z.keyword, "texture_storage_2d"),
	texture_storage_2d_array: new qe("texture_storage_2d_array", z.keyword, "texture_storage_2d_array"),
	texture_storage_3d: new qe("texture_storage_3d", z.keyword, "texture_storage_3d"),
	texture_depth_2d: new qe("texture_depth_2d", z.keyword, "texture_depth_2d"),
	texture_depth_2d_array: new qe("texture_depth_2d_array", z.keyword, "texture_depth_2d_array"),
	texture_depth_cube: new qe("texture_depth_cube", z.keyword, "texture_depth_cube"),
	texture_depth_cube_array: new qe("texture_depth_cube_array", z.keyword, "texture_depth_cube_array"),
	texture_depth_multisampled_2d: new qe("texture_depth_multisampled_2d", z.keyword, "texture_depth_multisampled_2d"),
	texture_external: new qe("texture_external", z.keyword, "texture_external"),
	u32: new qe("u32", z.keyword, "u32"),
	vec2: new qe("vec2", z.keyword, "vec2"),
	vec3: new qe("vec3", z.keyword, "vec3"),
	vec4: new qe("vec4", z.keyword, "vec4"),
	bitcast: new qe("bitcast", z.keyword, "bitcast"),
	block: new qe("block", z.keyword, "block"),
	break: new qe("break", z.keyword, "break"),
	case: new qe("case", z.keyword, "case"),
	continue: new qe("continue", z.keyword, "continue"),
	continuing: new qe("continuing", z.keyword, "continuing"),
	default: new qe("default", z.keyword, "default"),
	diagnostic: new qe("diagnostic", z.keyword, "diagnostic"),
	discard: new qe("discard", z.keyword, "discard"),
	else: new qe("else", z.keyword, "else"),
	enable: new qe("enable", z.keyword, "enable"),
	fallthrough: new qe("fallthrough", z.keyword, "fallthrough"),
	false: new qe("false", z.keyword, "false"),
	fn: new qe("fn", z.keyword, "fn"),
	for: new qe("for", z.keyword, "for"),
	function: new qe("function", z.keyword, "function"),
	if: new qe("if", z.keyword, "if"),
	let: new qe("let", z.keyword, "let"),
	const: new qe("const", z.keyword, "const"),
	loop: new qe("loop", z.keyword, "loop"),
	while: new qe("while", z.keyword, "while"),
	private: new qe("private", z.keyword, "private"),
	read: new qe("read", z.keyword, "read"),
	read_write: new qe("read_write", z.keyword, "read_write"),
	return: new qe("return", z.keyword, "return"),
	requires: new qe("requires", z.keyword, "requires"),
	storage: new qe("storage", z.keyword, "storage"),
	switch: new qe("switch", z.keyword, "switch"),
	true: new qe("true", z.keyword, "true"),
	alias: new qe("alias", z.keyword, "alias"),
	type: new qe("type", z.keyword, "type"),
	uniform: new qe("uniform", z.keyword, "uniform"),
	var: new qe("var", z.keyword, "var"),
	override: new qe("override", z.keyword, "override"),
	workgroup: new qe("workgroup", z.keyword, "workgroup"),
	write: new qe("write", z.keyword, "write"),
	r8unorm: new qe("r8unorm", z.keyword, "r8unorm"),
	r8snorm: new qe("r8snorm", z.keyword, "r8snorm"),
	r8uint: new qe("r8uint", z.keyword, "r8uint"),
	r8sint: new qe("r8sint", z.keyword, "r8sint"),
	r16uint: new qe("r16uint", z.keyword, "r16uint"),
	r16sint: new qe("r16sint", z.keyword, "r16sint"),
	r16float: new qe("r16float", z.keyword, "r16float"),
	rg8unorm: new qe("rg8unorm", z.keyword, "rg8unorm"),
	rg8snorm: new qe("rg8snorm", z.keyword, "rg8snorm"),
	rg8uint: new qe("rg8uint", z.keyword, "rg8uint"),
	rg8sint: new qe("rg8sint", z.keyword, "rg8sint"),
	r32uint: new qe("r32uint", z.keyword, "r32uint"),
	r32sint: new qe("r32sint", z.keyword, "r32sint"),
	r32float: new qe("r32float", z.keyword, "r32float"),
	rg16uint: new qe("rg16uint", z.keyword, "rg16uint"),
	rg16sint: new qe("rg16sint", z.keyword, "rg16sint"),
	rg16float: new qe("rg16float", z.keyword, "rg16float"),
	rgba8unorm: new qe("rgba8unorm", z.keyword, "rgba8unorm"),
	rgba8unorm_srgb: new qe("rgba8unorm_srgb", z.keyword, "rgba8unorm_srgb"),
	rgba8snorm: new qe("rgba8snorm", z.keyword, "rgba8snorm"),
	rgba8uint: new qe("rgba8uint", z.keyword, "rgba8uint"),
	rgba8sint: new qe("rgba8sint", z.keyword, "rgba8sint"),
	bgra8unorm: new qe("bgra8unorm", z.keyword, "bgra8unorm"),
	bgra8unorm_srgb: new qe("bgra8unorm_srgb", z.keyword, "bgra8unorm_srgb"),
	rgb10a2unorm: new qe("rgb10a2unorm", z.keyword, "rgb10a2unorm"),
	rg11b10float: new qe("rg11b10float", z.keyword, "rg11b10float"),
	rg32uint: new qe("rg32uint", z.keyword, "rg32uint"),
	rg32sint: new qe("rg32sint", z.keyword, "rg32sint"),
	rg32float: new qe("rg32float", z.keyword, "rg32float"),
	rgba16uint: new qe("rgba16uint", z.keyword, "rgba16uint"),
	rgba16sint: new qe("rgba16sint", z.keyword, "rgba16sint"),
	rgba16float: new qe("rgba16float", z.keyword, "rgba16float"),
	rgba32uint: new qe("rgba32uint", z.keyword, "rgba32uint"),
	rgba32sint: new qe("rgba32sint", z.keyword, "rgba32sint"),
	rgba32float: new qe("rgba32float", z.keyword, "rgba32float"),
	static_assert: new qe("static_assert", z.keyword, "static_assert")
}, He.tokens = {
	decimal_float_literal: new qe("decimal_float_literal", z.token, /((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?[fh]?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+[fh]?)|(-?[0-9]+[fh])/),
	hex_float_literal: new qe("hex_float_literal", z.token, /-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+[fh]?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+[fh]?))/),
	int_literal: new qe("int_literal", z.token, /-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),
	uint_literal: new qe("uint_literal", z.token, /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),
	name: new qe("name", z.token, /([_\p{XID_Start}][\p{XID_Continue}]+)|([\p{XID_Start}])/u),
	ident: new qe("ident", z.token, /[_a-zA-Z][0-9a-zA-Z_]*/),
	and: new qe("and", z.token, "&"),
	and_and: new qe("and_and", z.token, "&&"),
	arrow: new qe("arrow ", z.token, "->"),
	attr: new qe("attr", z.token, "@"),
	forward_slash: new qe("forward_slash", z.token, "/"),
	bang: new qe("bang", z.token, "!"),
	bracket_left: new qe("bracket_left", z.token, "["),
	bracket_right: new qe("bracket_right", z.token, "]"),
	brace_left: new qe("brace_left", z.token, "{"),
	brace_right: new qe("brace_right", z.token, "}"),
	colon: new qe("colon", z.token, ":"),
	comma: new qe("comma", z.token, ","),
	equal: new qe("equal", z.token, "="),
	equal_equal: new qe("equal_equal", z.token, "=="),
	not_equal: new qe("not_equal", z.token, "!="),
	greater_than: new qe("greater_than", z.token, ">"),
	greater_than_equal: new qe("greater_than_equal", z.token, ">="),
	shift_right: new qe("shift_right", z.token, ">>"),
	less_than: new qe("less_than", z.token, "<"),
	less_than_equal: new qe("less_than_equal", z.token, "<="),
	shift_left: new qe("shift_left", z.token, "<<"),
	modulo: new qe("modulo", z.token, "%"),
	minus: new qe("minus", z.token, "-"),
	minus_minus: new qe("minus_minus", z.token, "--"),
	period: new qe("period", z.token, "."),
	plus: new qe("plus", z.token, "+"),
	plus_plus: new qe("plus_plus", z.token, "++"),
	or: new qe("or", z.token, "|"),
	or_or: new qe("or_or", z.token, "||"),
	paren_left: new qe("paren_left", z.token, "("),
	paren_right: new qe("paren_right", z.token, ")"),
	semicolon: new qe("semicolon", z.token, ";"),
	star: new qe("star", z.token, "*"),
	tilde: new qe("tilde", z.token, "~"),
	underscore: new qe("underscore", z.token, "_"),
	xor: new qe("xor", z.token, "^"),
	plus_equal: new qe("plus_equal", z.token, "+="),
	minus_equal: new qe("minus_equal", z.token, "-="),
	times_equal: new qe("times_equal", z.token, "*="),
	division_equal: new qe("division_equal", z.token, "/="),
	modulo_equal: new qe("modulo_equal", z.token, "%="),
	and_equal: new qe("and_equal", z.token, "&="),
	or_equal: new qe("or_equal", z.token, "|="),
	xor_equal: new qe("xor_equal", z.token, "^="),
	shift_right_equal: new qe("shift_right_equal", z.token, ">>="),
	shift_left_equal: new qe("shift_left_equal", z.token, "<<=")
}, He.simpleTokens = {
	"@": H.tokens.attr,
	"{": H.tokens.brace_left,
	"}": H.tokens.brace_right,
	":": H.tokens.colon,
	",": H.tokens.comma,
	"(": H.tokens.paren_left,
	")": H.tokens.paren_right,
	";": H.tokens.semicolon
}, He.literalTokens = {
	"&": H.tokens.and,
	"&&": H.tokens.and_and,
	"->": H.tokens.arrow,
	"/": H.tokens.forward_slash,
	"!": H.tokens.bang,
	"[": H.tokens.bracket_left,
	"]": H.tokens.bracket_right,
	"=": H.tokens.equal,
	"==": H.tokens.equal_equal,
	"!=": H.tokens.not_equal,
	">": H.tokens.greater_than,
	">=": H.tokens.greater_than_equal,
	">>": H.tokens.shift_right,
	"<": H.tokens.less_than,
	"<=": H.tokens.less_than_equal,
	"<<": H.tokens.shift_left,
	"%": H.tokens.modulo,
	"-": H.tokens.minus,
	"--": H.tokens.minus_minus,
	".": H.tokens.period,
	"+": H.tokens.plus,
	"++": H.tokens.plus_plus,
	"|": H.tokens.or,
	"||": H.tokens.or_or,
	"*": H.tokens.star,
	"~": H.tokens.tilde,
	_: H.tokens.underscore,
	"^": H.tokens.xor,
	"+=": H.tokens.plus_equal,
	"-=": H.tokens.minus_equal,
	"*=": H.tokens.times_equal,
	"/=": H.tokens.division_equal,
	"%=": H.tokens.modulo_equal,
	"&=": H.tokens.and_equal,
	"|=": H.tokens.or_equal,
	"^=": H.tokens.xor_equal,
	">>=": H.tokens.shift_right_equal,
	"<<=": H.tokens.shift_left_equal
}, He.regexTokens = {
	decimal_float_literal: H.tokens.decimal_float_literal,
	hex_float_literal: H.tokens.hex_float_literal,
	int_literal: H.tokens.int_literal,
	uint_literal: H.tokens.uint_literal,
	ident: H.tokens.ident
}, He.storage_class = [
	H.keywords.function,
	H.keywords.private,
	H.keywords.workgroup,
	H.keywords.uniform,
	H.keywords.storage
], He.access_mode = [
	H.keywords.read,
	H.keywords.write,
	H.keywords.read_write
], He.sampler_type = [H.keywords.sampler, H.keywords.sampler_comparison], He.sampled_texture_type = [
	H.keywords.texture_1d,
	H.keywords.texture_2d,
	H.keywords.texture_2d_array,
	H.keywords.texture_3d,
	H.keywords.texture_cube,
	H.keywords.texture_cube_array
], He.multisampled_texture_type = [H.keywords.texture_multisampled_2d], He.storage_texture_type = [
	H.keywords.texture_storage_1d,
	H.keywords.texture_storage_2d,
	H.keywords.texture_storage_2d_array,
	H.keywords.texture_storage_3d
], He.depth_texture_type = [
	H.keywords.texture_depth_2d,
	H.keywords.texture_depth_2d_array,
	H.keywords.texture_depth_cube,
	H.keywords.texture_depth_cube_array,
	H.keywords.texture_depth_multisampled_2d
], He.texture_external_type = [H.keywords.texture_external], He.any_texture_type = [
	...H.sampled_texture_type,
	...H.multisampled_texture_type,
	...H.storage_texture_type,
	...H.depth_texture_type,
	...H.texture_external_type
], He.texel_format = [
	H.keywords.r8unorm,
	H.keywords.r8snorm,
	H.keywords.r8uint,
	H.keywords.r8sint,
	H.keywords.r16uint,
	H.keywords.r16sint,
	H.keywords.r16float,
	H.keywords.rg8unorm,
	H.keywords.rg8snorm,
	H.keywords.rg8uint,
	H.keywords.rg8sint,
	H.keywords.r32uint,
	H.keywords.r32sint,
	H.keywords.r32float,
	H.keywords.rg16uint,
	H.keywords.rg16sint,
	H.keywords.rg16float,
	H.keywords.rgba8unorm,
	H.keywords.rgba8unorm_srgb,
	H.keywords.rgba8snorm,
	H.keywords.rgba8uint,
	H.keywords.rgba8sint,
	H.keywords.bgra8unorm,
	H.keywords.bgra8unorm_srgb,
	H.keywords.rgb10a2unorm,
	H.keywords.rg11b10float,
	H.keywords.rg32uint,
	H.keywords.rg32sint,
	H.keywords.rg32float,
	H.keywords.rgba16uint,
	H.keywords.rgba16sint,
	H.keywords.rgba16float,
	H.keywords.rgba32uint,
	H.keywords.rgba32sint,
	H.keywords.rgba32float
], He.const_literal = [
	H.tokens.int_literal,
	H.tokens.uint_literal,
	H.tokens.decimal_float_literal,
	H.tokens.hex_float_literal,
	H.keywords.true,
	H.keywords.false
], He.literal_or_ident = [
	H.tokens.ident,
	H.tokens.int_literal,
	H.tokens.uint_literal,
	H.tokens.decimal_float_literal,
	H.tokens.hex_float_literal,
	H.tokens.name
], He.element_count_expression = [
	H.tokens.int_literal,
	H.tokens.uint_literal,
	H.tokens.ident
], He.template_types = [
	H.keywords.vec2,
	H.keywords.vec3,
	H.keywords.vec4,
	H.keywords.mat2x2,
	H.keywords.mat2x3,
	H.keywords.mat2x4,
	H.keywords.mat3x2,
	H.keywords.mat3x3,
	H.keywords.mat3x4,
	H.keywords.mat4x2,
	H.keywords.mat4x3,
	H.keywords.mat4x4,
	H.keywords.atomic,
	H.keywords.bitcast,
	...H.any_texture_type
], He.attribute_name = [
	H.tokens.ident,
	H.keywords.block,
	H.keywords.diagnostic
], He.assignment_operators = [
	H.tokens.equal,
	H.tokens.plus_equal,
	H.tokens.minus_equal,
	H.tokens.times_equal,
	H.tokens.division_equal,
	H.tokens.modulo_equal,
	H.tokens.and_equal,
	H.tokens.or_equal,
	H.tokens.xor_equal,
	H.tokens.shift_right_equal,
	H.tokens.shift_left_equal
], He.increment_operators = [H.tokens.plus_plus, H.tokens.minus_minus];
var ze = class {
	constructor(e$2, t$1, n$1, s$1, r$1) {
		this.type = e$2, this.lexeme = t$1, this.line = n$1, this.start = s$1, this.end = r$1;
	}
	toString() {
		return this.lexeme;
	}
	isTemplateType() {
		return -1 != He.template_types.indexOf(this.type);
	}
	isArrayType() {
		return this.type == He.keywords.array;
	}
	isArrayOrTemplateType() {
		return this.isArrayType() || this.isTemplateType();
	}
};
var Re = class {
	constructor(e$2) {
		this._tokens = [], this._start = 0, this._current = 0, this._line = 1, this._source = null != e$2 ? e$2 : "";
	}
	scanTokens() {
		for (; !this._isAtEnd();) if (this._start = this._current, !this.scanToken()) throw `Invalid syntax at line ${this._line}`;
		return this._tokens.push(new ze(He.eof, "", this._line, this._current, this._current)), this._tokens;
	}
	scanToken() {
		let e$2 = this._advance();
		if ("\n" == e$2) return this._line++, !0;
		if (this._isWhitespace(e$2)) return !0;
		if ("/" == e$2) {
			if ("/" == this._peekAhead()) {
				for (; "\n" != e$2;) {
					if (this._isAtEnd()) return !0;
					e$2 = this._advance();
				}
				return this._line++, !0;
			}
			if ("*" == this._peekAhead()) {
				this._advance();
				let t$2 = 1;
				for (; t$2 > 0;) {
					if (this._isAtEnd()) return !0;
					if (e$2 = this._advance(), "\n" == e$2) this._line++;
					else if ("*" == e$2) {
						if ("/" == this._peekAhead() && (this._advance(), t$2--, 0 == t$2)) return !0;
					} else "/" == e$2 && "*" == this._peekAhead() && (this._advance(), t$2++);
				}
				return !0;
			}
		}
		const t$1 = He.simpleTokens[e$2];
		if (t$1) return this._addToken(t$1), !0;
		let n$1 = He.none;
		const s$1 = this._isAlpha(e$2), r$1 = "_" === e$2;
		if (this._isAlphaNumeric(e$2)) {
			let t$2 = this._peekAhead();
			for (; this._isAlphaNumeric(t$2);) e$2 += this._advance(), t$2 = this._peekAhead();
		}
		if (s$1) {
			const t$2 = He.keywords[e$2];
			if (t$2) return this._addToken(t$2), !0;
		}
		if (s$1 || r$1) return this._addToken(He.tokens.ident), !0;
		for (;;) {
			let t$2 = this._findType(e$2);
			const s$2 = this._peekAhead();
			if ("-" == e$2 && this._tokens.length > 0) {
				if ("=" == s$2) return this._current++, e$2 += s$2, this._addToken(He.tokens.minus_equal), !0;
				if ("-" == s$2) return this._current++, e$2 += s$2, this._addToken(He.tokens.minus_minus), !0;
				const n$2 = this._tokens.length - 1;
				if ((-1 != He.literal_or_ident.indexOf(this._tokens[n$2].type) || this._tokens[n$2].type == He.tokens.paren_right) && ">" != s$2) return this._addToken(t$2), !0;
			}
			if (">" == e$2 && (">" == s$2 || "=" == s$2)) {
				let e$3 = !1, n$2 = this._tokens.length - 1;
				for (let t$3 = 0; t$3 < 5 && n$2 >= 0 && -1 === He.assignment_operators.indexOf(this._tokens[n$2].type); ++t$3, --n$2) if (this._tokens[n$2].type === He.tokens.less_than) {
					n$2 > 0 && this._tokens[n$2 - 1].isArrayOrTemplateType() && (e$3 = !0);
					break;
				}
				if (e$3) return this._addToken(t$2), !0;
			}
			if (t$2 === He.none) {
				let s$3 = e$2, r$2 = 0;
				const a$1 = 2;
				for (let e$3 = 0; e$3 < a$1; ++e$3) if (s$3 += this._peekAhead(e$3), t$2 = this._findType(s$3), t$2 !== He.none) {
					r$2 = e$3;
					break;
				}
				if (t$2 === He.none) return n$1 !== He.none && (this._current--, this._addToken(n$1), !0);
				e$2 = s$3, this._current += r$2 + 1;
			}
			if (n$1 = t$2, this._isAtEnd()) break;
			e$2 += this._advance();
		}
		return n$1 !== He.none && (this._addToken(n$1), !0);
	}
	_findType(e$2) {
		for (const t$1 in He.regexTokens) {
			const n$1 = He.regexTokens[t$1];
			if (this._match(e$2, n$1.rule)) return n$1;
		}
		return He.literalTokens[e$2] || He.none;
	}
	_match(e$2, t$1) {
		const n$1 = t$1.exec(e$2);
		return n$1 && 0 == n$1.index && n$1[0] == e$2;
	}
	_isAtEnd() {
		return this._current >= this._source.length;
	}
	_isAlpha(e$2) {
		return !this._isNumeric(e$2) && !this._isWhitespace(e$2) && "_" !== e$2 && "." !== e$2 && "(" !== e$2 && ")" !== e$2 && "[" !== e$2 && "]" !== e$2 && "{" !== e$2 && "}" !== e$2 && "," !== e$2 && ";" !== e$2 && ":" !== e$2 && "=" !== e$2 && "!" !== e$2 && "<" !== e$2 && ">" !== e$2 && "+" !== e$2 && "-" !== e$2 && "*" !== e$2 && "/" !== e$2 && "%" !== e$2 && "&" !== e$2 && "|" !== e$2 && "^" !== e$2 && "~" !== e$2 && "@" !== e$2 && "#" !== e$2 && "?" !== e$2 && "'" !== e$2 && "`" !== e$2 && "\"" !== e$2 && "\\" !== e$2 && "\n" !== e$2 && "\r" !== e$2 && "	" !== e$2 && "\0" !== e$2;
	}
	_isNumeric(e$2) {
		return e$2 >= "0" && e$2 <= "9";
	}
	_isAlphaNumeric(e$2) {
		return this._isAlpha(e$2) || this._isNumeric(e$2) || "_" === e$2;
	}
	_isWhitespace(e$2) {
		return " " == e$2 || "	" == e$2 || "\r" == e$2;
	}
	_advance(e$2 = 0) {
		let t$1 = this._source[this._current];
		return e$2 = e$2 || 0, e$2++, this._current += e$2, t$1;
	}
	_peekAhead(e$2 = 0) {
		return e$2 = e$2 || 0, this._current + e$2 >= this._source.length ? "\0" : this._source[this._current + e$2];
	}
	_addToken(e$2) {
		const t$1 = this._source.substring(this._start, this._current);
		this._tokens.push(new ze(e$2, t$1, this._line, this._start, this._current));
	}
};
function Ge(e$2) {
	return Array.isArray(e$2) || (null == e$2 ? void 0 : e$2.buffer) instanceof ArrayBuffer;
}
var Xe = new Float32Array(1), je = new Uint32Array(Xe.buffer), Ze = new Uint32Array(Xe.buffer), Qe = new Int32Array(1), Ye = new Float32Array(Qe.buffer), Ke = new Uint32Array(Qe.buffer), Je = new Uint32Array(1), et = new Float32Array(Je.buffer), tt = new Int32Array(Je.buffer);
function nt(e$2, t$1, n$1) {
	if (t$1 === n$1) return e$2;
	if ("f32" === t$1) {
		if ("i32" === n$1 || "x32" === n$1) return Xe[0] = e$2, je[0];
		if ("u32" === n$1) return Xe[0] = e$2, Ze[0];
	} else if ("i32" === t$1 || "x32" === t$1) {
		if ("f32" === n$1) return Qe[0] = e$2, Ye[0];
		if ("u32" === n$1) return Qe[0] = e$2, Ke[0];
	} else if ("u32" === t$1) {
		if ("f32" === n$1) return Je[0] = e$2, et[0];
		if ("i32" === n$1 || "x32" === n$1) return Je[0] = e$2, tt[0];
	}
	return console.error(`Unsupported cast from ${t$1} to ${n$1}`), e$2;
}
var st = class {
	constructor(e$2) {
		this.resources = null, this.inUse = !1, this.info = null, this.node = e$2;
	}
};
var rt = class {
	constructor(e$2, t$1) {
		this.align = e$2, this.size = t$1;
	}
};
var at = class at {
	constructor() {
		this.uniforms = [], this.storage = [], this.textures = [], this.samplers = [], this.aliases = [], this.overrides = [], this.structs = [], this.entry = new d(), this.functions = [], this._types = /* @__PURE__ */ new Map(), this._functions = /* @__PURE__ */ new Map();
	}
	_isStorageTexture(e$2) {
		return "texture_storage_1d" == e$2.name || "texture_storage_2d" == e$2.name || "texture_storage_2d_array" == e$2.name || "texture_storage_3d" == e$2.name;
	}
	updateAST(e$2) {
		for (const t$1 of e$2) t$1 instanceof D && this._functions.set(t$1.name, new st(t$1));
		for (const t$1 of e$2) if (t$1 instanceof oe) {
			const e$3 = this.getTypeInfo(t$1, null);
			e$3 instanceof n && this.structs.push(e$3);
		}
		for (const t$1 of e$2) if (t$1 instanceof te) this.aliases.push(this._getAliasInfo(t$1));
		else {
			if (t$1 instanceof M) {
				const e$3 = t$1, n$1 = this._getAttributeNum(e$3.attributes, "id", 0), s$1 = null != e$3.type ? this.getTypeInfo(e$3.type, e$3.attributes) : null;
				this.overrides.push(new h(e$3.name, s$1, e$3.attributes, n$1));
				continue;
			}
			if (this._isUniformVar(t$1)) {
				const e$3 = t$1, n$1 = this._getAttributeNum(e$3.attributes, "group", 0), s$1 = this._getAttributeNum(e$3.attributes, "binding", 0), r$1 = this.getTypeInfo(e$3.type, e$3.attributes), a$1 = new o(e$3.name, r$1, n$1, s$1, e$3.attributes, i.Uniform, e$3.access);
				a$1.access || (a$1.access = "read"), this.uniforms.push(a$1);
				continue;
			}
			if (this._isStorageVar(t$1)) {
				const e$3 = t$1, n$1 = this._getAttributeNum(e$3.attributes, "group", 0), s$1 = this._getAttributeNum(e$3.attributes, "binding", 0), r$1 = this.getTypeInfo(e$3.type, e$3.attributes), a$1 = this._isStorageTexture(r$1), c$1 = new o(e$3.name, r$1, n$1, s$1, e$3.attributes, a$1 ? i.StorageTexture : i.Storage, e$3.access);
				c$1.access || (c$1.access = "read"), this.storage.push(c$1);
				continue;
			}
			if (this._isTextureVar(t$1)) {
				const e$3 = t$1, n$1 = this._getAttributeNum(e$3.attributes, "group", 0), s$1 = this._getAttributeNum(e$3.attributes, "binding", 0), r$1 = this.getTypeInfo(e$3.type, e$3.attributes), a$1 = this._isStorageTexture(r$1), c$1 = new o(e$3.name, r$1, n$1, s$1, e$3.attributes, a$1 ? i.StorageTexture : i.Texture, e$3.access);
				c$1.access || (c$1.access = "read"), a$1 ? this.storage.push(c$1) : this.textures.push(c$1);
				continue;
			}
			if (this._isSamplerVar(t$1)) {
				const e$3 = t$1, n$1 = this._getAttributeNum(e$3.attributes, "group", 0), s$1 = this._getAttributeNum(e$3.attributes, "binding", 0), r$1 = this.getTypeInfo(e$3.type, e$3.attributes), a$1 = new o(e$3.name, r$1, n$1, s$1, e$3.attributes, i.Sampler, e$3.access);
				this.samplers.push(a$1);
				continue;
			}
		}
		for (const t$1 of e$2) if (t$1 instanceof D) {
			const e$3 = this._getAttribute(t$1, "vertex"), n$1 = this._getAttribute(t$1, "fragment"), s$1 = this._getAttribute(t$1, "compute"), r$1 = e$3 || n$1 || s$1, a$1 = new p(t$1.name, null == r$1 ? void 0 : r$1.name, t$1.attributes);
			a$1.attributes = t$1.attributes, a$1.startLine = t$1.startLine, a$1.endLine = t$1.endLine, this.functions.push(a$1), this._functions.get(t$1.name).info = a$1, r$1 && (this._functions.get(t$1.name).inUse = !0, a$1.inUse = !0, a$1.resources = this._findResources(t$1, !!r$1), a$1.inputs = this._getInputs(t$1.args), a$1.outputs = this._getOutputs(t$1.returnType), this.entry[r$1.name].push(a$1)), a$1.arguments = t$1.args.map((e$4) => new f(e$4.name, this.getTypeInfo(e$4.type, e$4.attributes), e$4.attributes)), a$1.returnType = t$1.returnType ? this.getTypeInfo(t$1.returnType, t$1.attributes) : null;
			continue;
		}
		for (const e$3 of this._functions.values()) e$3.info && (e$3.info.inUse = e$3.inUse, this._addCalls(e$3.node, e$3.info.calls));
		for (const e$3 of this._functions.values()) e$3.node.search((t$1) => {
			var n$1, s$1, r$1;
			if (t$1 instanceof De) {
				if (t$1.value) if (Ge(t$1.value)) for (const s$2 of t$1.value) for (const t$2 of this.overrides) s$2 === t$2.name && (null === (n$1 = e$3.info) || void 0 === n$1 || n$1.overrides.push(t$2));
				else for (const n$2 of this.overrides) t$1.value === n$2.name && (null === (s$1 = e$3.info) || void 0 === s$1 || s$1.overrides.push(n$2));
			} else if (t$1 instanceof ge) for (const n$2 of this.overrides) t$1.name === n$2.name && (null === (r$1 = e$3.info) || void 0 === r$1 || r$1.overrides.push(n$2));
		});
		for (const e$3 of this.uniforms) this._markStructsInUse(e$3.type);
		for (const e$3 of this.storage) this._markStructsInUse(e$3.type);
	}
	getFunctionInfo(e$2) {
		for (const t$1 of this.functions) if (t$1.name == e$2) return t$1;
		return null;
	}
	getStructInfo(e$2) {
		for (const t$1 of this.structs) if (t$1.name == e$2) return t$1;
		return null;
	}
	getOverrideInfo(e$2) {
		for (const t$1 of this.overrides) if (t$1.name == e$2) return t$1;
		return null;
	}
	_markStructsInUse(e$2) {
		if (e$2) if (e$2.isStruct) {
			if (e$2.inUse = !0, e$2.members) for (const t$1 of e$2.members) this._markStructsInUse(t$1.type);
		} else if (e$2.isArray) this._markStructsInUse(e$2.format);
		else if (e$2.isTemplate) e$2.format && this._markStructsInUse(e$2.format);
		else {
			const t$1 = this._getAlias(e$2.name);
			t$1 && this._markStructsInUse(t$1);
		}
	}
	_addCalls(e$2, t$1) {
		var n$1;
		for (const s$1 of e$2.calls) {
			const e$3 = null === (n$1 = this._functions.get(s$1.name)) || void 0 === n$1 ? void 0 : n$1.info;
			e$3 && t$1.add(e$3);
		}
	}
	findResource(e$2, t$1, n$1) {
		if (n$1) {
			for (const s$1 of this.entry.compute) if (s$1.name === n$1) {
				for (const n$2 of s$1.resources) if (n$2.group == e$2 && n$2.binding == t$1) return n$2;
			}
			for (const s$1 of this.entry.vertex) if (s$1.name === n$1) {
				for (const n$2 of s$1.resources) if (n$2.group == e$2 && n$2.binding == t$1) return n$2;
			}
			for (const s$1 of this.entry.fragment) if (s$1.name === n$1) {
				for (const n$2 of s$1.resources) if (n$2.group == e$2 && n$2.binding == t$1) return n$2;
			}
		}
		for (const n$2 of this.uniforms) if (n$2.group == e$2 && n$2.binding == t$1) return n$2;
		for (const n$2 of this.storage) if (n$2.group == e$2 && n$2.binding == t$1) return n$2;
		for (const n$2 of this.textures) if (n$2.group == e$2 && n$2.binding == t$1) return n$2;
		for (const n$2 of this.samplers) if (n$2.group == e$2 && n$2.binding == t$1) return n$2;
		return null;
	}
	_findResource(e$2) {
		for (const t$1 of this.uniforms) if (t$1.name == e$2) return t$1;
		for (const t$1 of this.storage) if (t$1.name == e$2) return t$1;
		for (const t$1 of this.textures) if (t$1.name == e$2) return t$1;
		for (const t$1 of this.samplers) if (t$1.name == e$2) return t$1;
		return null;
	}
	_markStructsFromAST(e$2) {
		const t$1 = this.getTypeInfo(e$2, null);
		this._markStructsInUse(t$1);
	}
	_findResources(e$2, t$1) {
		const n$1 = [], s$1 = this, r$1 = [];
		return e$2.search((a$1) => {
			if (a$1 instanceof E) r$1.push({});
			else if (a$1 instanceof $) r$1.pop();
			else if (a$1 instanceof F) {
				const e$3 = a$1;
				t$1 && null !== e$3.type && this._markStructsFromAST(e$3.type), r$1.length > 0 && (r$1[r$1.length - 1][e$3.name] = e$3);
			} else if (a$1 instanceof de) {
				const e$3 = a$1;
				t$1 && null !== e$3.type && this._markStructsFromAST(e$3.type);
			} else if (a$1 instanceof U) {
				const e$3 = a$1;
				t$1 && null !== e$3.type && this._markStructsFromAST(e$3.type), r$1.length > 0 && (r$1[r$1.length - 1][e$3.name] = e$3);
			} else if (a$1 instanceof ge) {
				const e$3 = a$1;
				if (r$1.length > 0) {
					if (r$1[r$1.length - 1][e$3.name]) return;
				}
				const t$2 = s$1._findResource(e$3.name);
				t$2 && n$1.push(t$2);
			} else if (a$1 instanceof me) {
				const r$2 = a$1, i$1 = s$1._functions.get(r$2.name);
				i$1 && (t$1 && (i$1.inUse = !0), e$2.calls.add(i$1.node), null === i$1.resources && (i$1.resources = s$1._findResources(i$1.node, t$1)), n$1.push(...i$1.resources));
			} else if (a$1 instanceof X) {
				const r$2 = a$1, i$1 = s$1._functions.get(r$2.name);
				i$1 && (t$1 && (i$1.inUse = !0), e$2.calls.add(i$1.node), null === i$1.resources && (i$1.resources = s$1._findResources(i$1.node, t$1)), n$1.push(...i$1.resources));
			}
		}), [...new Map(n$1.map((e$3) => [e$3.name, e$3])).values()];
	}
	getBindGroups() {
		const e$2 = [];
		function t$1(t$2, n$1) {
			t$2 >= e$2.length && (e$2.length = t$2 + 1), void 0 === e$2[t$2] && (e$2[t$2] = []), n$1 >= e$2[t$2].length && (e$2[t$2].length = n$1 + 1);
		}
		for (const n$1 of this.uniforms) {
			t$1(n$1.group, n$1.binding);
			e$2[n$1.group][n$1.binding] = n$1;
		}
		for (const n$1 of this.storage) {
			t$1(n$1.group, n$1.binding);
			e$2[n$1.group][n$1.binding] = n$1;
		}
		for (const n$1 of this.textures) {
			t$1(n$1.group, n$1.binding);
			e$2[n$1.group][n$1.binding] = n$1;
		}
		for (const n$1 of this.samplers) {
			t$1(n$1.group, n$1.binding);
			e$2[n$1.group][n$1.binding] = n$1;
		}
		return e$2;
	}
	_getOutputs(e$2, t$1 = void 0) {
		if (void 0 === t$1 && (t$1 = []), e$2 instanceof oe) this._getStructOutputs(e$2, t$1);
		else {
			const n$1 = this._getOutputInfo(e$2);
			null !== n$1 && t$1.push(n$1);
		}
		return t$1;
	}
	_getStructOutputs(e$2, t$1) {
		for (const n$1 of e$2.members) if (n$1.type instanceof oe) this._getStructOutputs(n$1.type, t$1);
		else {
			const e$3 = this._getAttribute(n$1, "location") || this._getAttribute(n$1, "builtin");
			if (null !== e$3) {
				const s$1 = this.getTypeInfo(n$1.type, n$1.type.attributes), r$1 = this._parseInt(e$3.value), a$1 = new u(n$1.name, s$1, e$3.name, r$1);
				t$1.push(a$1);
			}
		}
	}
	_getOutputInfo(e$2) {
		const t$1 = this._getAttribute(e$2, "location") || this._getAttribute(e$2, "builtin");
		if (null !== t$1) {
			const n$1 = this.getTypeInfo(e$2, e$2.attributes), s$1 = this._parseInt(t$1.value);
			return new u("", n$1, t$1.name, s$1);
		}
		return null;
	}
	_getInputs(e$2, t$1 = void 0) {
		void 0 === t$1 && (t$1 = []);
		for (const n$1 of e$2) if (n$1.type instanceof oe) this._getStructInputs(n$1.type, t$1);
		else {
			const e$3 = this._getInputInfo(n$1);
			null !== e$3 && t$1.push(e$3);
		}
		return t$1;
	}
	_getStructInputs(e$2, t$1) {
		for (const n$1 of e$2.members) if (n$1.type instanceof oe) this._getStructInputs(n$1.type, t$1);
		else {
			const e$3 = this._getInputInfo(n$1);
			null !== e$3 && t$1.push(e$3);
		}
	}
	_getInputInfo(e$2) {
		const t$1 = this._getAttribute(e$2, "location") || this._getAttribute(e$2, "builtin");
		if (null !== t$1) {
			const n$1 = this._getAttribute(e$2, "interpolation"), s$1 = this.getTypeInfo(e$2.type, e$2.attributes), r$1 = this._parseInt(t$1.value), a$1 = new l(e$2.name, s$1, t$1.name, r$1);
			return null !== n$1 && (a$1.interpolation = this._parseString(n$1.value)), a$1;
		}
		return null;
	}
	_parseString(e$2) {
		return e$2 instanceof Array && (e$2 = e$2[0]), e$2;
	}
	_parseInt(e$2) {
		e$2 instanceof Array && (e$2 = e$2[0]);
		const t$1 = parseInt(e$2);
		return isNaN(t$1) ? e$2 : t$1;
	}
	_getAlias(e$2) {
		for (const t$1 of this.aliases) if (t$1.name == e$2) return t$1.type;
		return null;
	}
	_getAliasInfo(e$2) {
		return new c(e$2.name, this.getTypeInfo(e$2.type, null));
	}
	getTypeInfoByName(e$2) {
		for (const t$1 of this.structs) if (t$1.name == e$2) return t$1;
		for (const t$1 of this.aliases) if (t$1.name == e$2) return t$1.type;
		return null;
	}
	getTypeInfo(i$1, o$1 = null) {
		if (this._types.has(i$1)) return this._types.get(i$1);
		if (i$1 instanceof le) {
			const e$2 = i$1.type ? this.getTypeInfo(i$1.type, i$1.attributes) : null, t$1 = new r(i$1.name, e$2, o$1);
			return this._types.set(i$1, t$1), this._updateTypeInfo(t$1), t$1;
		}
		if (i$1 instanceof ue) {
			const e$2 = i$1, t$1 = e$2.format ? this.getTypeInfo(e$2.format, e$2.attributes) : null, n$1 = new s(e$2.name, o$1);
			return n$1.format = t$1, n$1.count = e$2.count, this._types.set(i$1, n$1), this._updateTypeInfo(n$1), n$1;
		}
		if (i$1 instanceof oe) {
			const e$2 = i$1, s$1 = new n(e$2.name, o$1);
			s$1.startLine = e$2.startLine, s$1.endLine = e$2.endLine;
			for (const n$1 of e$2.members) {
				const e$3 = this.getTypeInfo(n$1.type, n$1.attributes);
				s$1.members.push(new t(n$1.name, e$3, n$1.attributes));
			}
			return this._types.set(i$1, s$1), this._updateTypeInfo(s$1), s$1;
		}
		if (i$1 instanceof he) {
			const t$1 = i$1, n$1 = t$1.format instanceof ae, s$1 = t$1.format ? n$1 ? this.getTypeInfo(t$1.format, null) : new e$1(t$1.format, null) : null, r$1 = new a(t$1.name, s$1, o$1, t$1.access);
			return this._types.set(i$1, r$1), this._updateTypeInfo(r$1), r$1;
		}
		if (i$1 instanceof ce) {
			const e$2 = i$1, t$1 = e$2.format ? this.getTypeInfo(e$2.format, null) : null, n$1 = new a(e$2.name, t$1, o$1, e$2.access);
			return this._types.set(i$1, n$1), this._updateTypeInfo(n$1), n$1;
		}
		const c$1 = new e$1(i$1.name, o$1);
		return this._types.set(i$1, c$1), this._updateTypeInfo(c$1), c$1;
	}
	_updateTypeInfo(e$2) {
		var t$1, a$1, i$1;
		const o$1 = this._getTypeSize(e$2);
		if (e$2.size = null !== (t$1 = null == o$1 ? void 0 : o$1.size) && void 0 !== t$1 ? t$1 : 0, e$2 instanceof s && e$2.format) {
			const t$2 = this._getTypeSize(e$2.format);
			e$2.stride = Math.max(null !== (a$1 = null == t$2 ? void 0 : t$2.size) && void 0 !== a$1 ? a$1 : 0, null !== (i$1 = null == t$2 ? void 0 : t$2.align) && void 0 !== i$1 ? i$1 : 0), this._updateTypeInfo(e$2.format);
		}
		e$2 instanceof r && this._updateTypeInfo(e$2.format), e$2 instanceof n && this._updateStructInfo(e$2);
	}
	_updateStructInfo(e$2) {
		var t$1;
		let n$1 = 0, s$1 = 0, r$1 = 0, a$1 = 0;
		for (let i$1 = 0, o$1 = e$2.members.length; i$1 < o$1; ++i$1) {
			const o$2 = e$2.members[i$1], c$1 = this._getTypeSize(o$2);
			if (!c$1) continue;
			null !== (t$1 = this._getAlias(o$2.type.name)) && void 0 !== t$1 || o$2.type;
			const l$1 = c$1.align, u$1 = c$1.size;
			n$1 = this._roundUp(l$1, n$1 + s$1), s$1 = u$1, r$1 = n$1, a$1 = Math.max(a$1, l$1), o$2.offset = n$1, o$2.size = u$1, this._updateTypeInfo(o$2.type);
		}
		e$2.size = this._roundUp(a$1, r$1 + s$1), e$2.align = a$1;
	}
	_getTypeSize(r$1) {
		var a$1, i$1;
		if (null == r$1) return null;
		const o$1 = this._getAttributeNum(r$1.attributes, "size", 0), c$1 = this._getAttributeNum(r$1.attributes, "align", 0);
		if (r$1 instanceof t && (r$1 = r$1.type), r$1 instanceof e$1) {
			const e$2 = this._getAlias(r$1.name);
			null !== e$2 && (r$1 = e$2);
		}
		{
			const e$2 = at._typeInfo[r$1.name];
			if (void 0 !== e$2) {
				const t$1 = "f16" === (null === (a$1 = r$1.format) || void 0 === a$1 ? void 0 : a$1.name) ? 2 : 1;
				return new rt(Math.max(c$1, e$2.align / t$1), Math.max(o$1, e$2.size / t$1));
			}
		}
		{
			const e$2 = at._typeInfo[r$1.name.substring(0, r$1.name.length - 1)];
			if (e$2) {
				const t$1 = "h" === r$1.name[r$1.name.length - 1] ? 2 : 1;
				return new rt(Math.max(c$1, e$2.align / t$1), Math.max(o$1, e$2.size / t$1));
			}
		}
		if (r$1 instanceof s) {
			let e$2 = r$1, t$1 = 8, n$1 = 8;
			const s$1 = this._getTypeSize(e$2.format);
			null !== s$1 && (n$1 = s$1.size, t$1 = s$1.align);
			return n$1 = e$2.count * this._getAttributeNum(null !== (i$1 = null == r$1 ? void 0 : r$1.attributes) && void 0 !== i$1 ? i$1 : null, "stride", this._roundUp(t$1, n$1)), o$1 && (n$1 = o$1), new rt(Math.max(c$1, t$1), Math.max(o$1, n$1));
		}
		if (r$1 instanceof n) {
			let e$2 = 0, t$1 = 0, n$1 = 0, s$1 = 0, a$2 = 0;
			for (const t$2 of r$1.members) {
				const r$2 = this._getTypeSize(t$2.type);
				null !== r$2 && (e$2 = Math.max(r$2.align, e$2), n$1 = this._roundUp(r$2.align, n$1 + s$1), s$1 = r$2.size, a$2 = n$1);
			}
			return t$1 = this._roundUp(e$2, a$2 + s$1), new rt(Math.max(c$1, e$2), Math.max(o$1, t$1));
		}
		return null;
	}
	_isUniformVar(e$2) {
		return e$2 instanceof F && "uniform" == e$2.storage;
	}
	_isStorageVar(e$2) {
		return e$2 instanceof F && "storage" == e$2.storage;
	}
	_isTextureVar(e$2) {
		return e$2 instanceof F && null !== e$2.type && -1 != at._textureTypes.indexOf(e$2.type.name);
	}
	_isSamplerVar(e$2) {
		return e$2 instanceof F && null !== e$2.type && -1 != at._samplerTypes.indexOf(e$2.type.name);
	}
	_getAttribute(e$2, t$1) {
		const n$1 = e$2;
		if (!n$1 || !n$1.attributes) return null;
		const s$1 = n$1.attributes;
		for (let e$3 of s$1) if (e$3.name == t$1) return e$3;
		return null;
	}
	_getAttributeNum(e$2, t$1, n$1) {
		if (null === e$2) return n$1;
		for (let s$1 of e$2) if (s$1.name == t$1) {
			let e$3 = null !== s$1 && null !== s$1.value ? s$1.value : n$1;
			return e$3 instanceof Array && (e$3 = e$3[0]), "number" == typeof e$3 ? e$3 : "string" == typeof e$3 ? parseInt(e$3) : n$1;
		}
		return n$1;
	}
	_roundUp(e$2, t$1) {
		return Math.ceil(t$1 / e$2) * e$2;
	}
};
at._typeInfo = {
	f16: {
		align: 2,
		size: 2
	},
	i32: {
		align: 4,
		size: 4
	},
	u32: {
		align: 4,
		size: 4
	},
	f32: {
		align: 4,
		size: 4
	},
	atomic: {
		align: 4,
		size: 4
	},
	vec2: {
		align: 8,
		size: 8
	},
	vec3: {
		align: 16,
		size: 12
	},
	vec4: {
		align: 16,
		size: 16
	},
	mat2x2: {
		align: 8,
		size: 16
	},
	mat3x2: {
		align: 8,
		size: 24
	},
	mat4x2: {
		align: 8,
		size: 32
	},
	mat2x3: {
		align: 16,
		size: 32
	},
	mat3x3: {
		align: 16,
		size: 48
	},
	mat4x3: {
		align: 16,
		size: 64
	},
	mat2x4: {
		align: 16,
		size: 32
	},
	mat3x4: {
		align: 16,
		size: 48
	},
	mat4x4: {
		align: 16,
		size: 64
	}
}, at._textureTypes = He.any_texture_type.map((e$2) => e$2.name), at._samplerTypes = He.sampler_type.map((e$2) => e$2.name);
var it = 0;
var ot = class ot {
	constructor(e$2, t$1, n$1) {
		this.id = it++, this.name = e$2, this.value = t$1, this.node = n$1;
	}
	clone() {
		return new ot(this.name, this.value, this.node);
	}
};
var ct = class ct {
	constructor(e$2) {
		this.id = it++, this.name = e$2.name, this.node = e$2;
	}
	clone() {
		return new ct(this.node);
	}
};
var lt = class lt {
	constructor(e$2) {
		this.parent = null, this.variables = /* @__PURE__ */ new Map(), this.functions = /* @__PURE__ */ new Map(), this.currentFunctionName = "", this.id = it++, e$2 && (this.parent = e$2, this.currentFunctionName = e$2.currentFunctionName);
	}
	getVariable(e$2) {
		var t$1;
		return this.variables.has(e$2) ? null !== (t$1 = this.variables.get(e$2)) && void 0 !== t$1 ? t$1 : null : this.parent ? this.parent.getVariable(e$2) : null;
	}
	getFunction(e$2) {
		var t$1;
		return this.functions.has(e$2) ? null !== (t$1 = this.functions.get(e$2)) && void 0 !== t$1 ? t$1 : null : this.parent ? this.parent.getFunction(e$2) : null;
	}
	createVariable(e$2, t$1, n$1) {
		this.variables.set(e$2, new ot(e$2, t$1, null != n$1 ? n$1 : null));
	}
	setVariable(e$2, t$1, n$1) {
		const s$1 = this.getVariable(e$2);
		null !== s$1 ? s$1.value = t$1 : this.createVariable(e$2, t$1, n$1);
	}
	getVariableValue(e$2) {
		var t$1;
		const n$1 = this.getVariable(e$2);
		return null !== (t$1 = null == n$1 ? void 0 : n$1.value) && void 0 !== t$1 ? t$1 : null;
	}
	clone() {
		return new lt(this);
	}
};
var ut = class {
	evalExpression(e$2, t$1) {
		return null;
	}
	getTypeInfo(e$2) {
		return null;
	}
	getVariableName(e$2, t$1) {
		return "";
	}
};
var ht = class {
	constructor(e$2) {
		this.exec = e$2;
	}
	getTypeInfo(e$2) {
		return this.exec.getTypeInfo(e$2);
	}
	All(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		let s$1 = !0;
		if (n$1 instanceof Me) return n$1.data.forEach((e$3) => {
			e$3 || (s$1 = !1);
		}), new Be(s$1 ? 1 : 0, this.getTypeInfo("bool"));
		throw new Error(`All() expects a vector argument. Line ${e$2.line}`);
	}
	Any(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Be(n$1.data.some((e$3) => e$3) ? 1 : 0, this.getTypeInfo("bool"));
		throw new Error(`Any() expects a vector argument. Line ${e$2.line}`);
	}
	Select(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[2], t$1);
		if (!(n$1 instanceof Be)) throw new Error(`Select() expects a bool condition. Line ${e$2.line}`);
		return n$1.value ? this.exec.evalExpression(e$2.args[1], t$1) : this.exec.evalExpression(e$2.args[0], t$1);
	}
	ArrayLength(e$2, t$1) {
		let n$1 = e$2.args[0];
		n$1 instanceof ke && (n$1 = n$1.right);
		const s$1 = this.exec.evalExpression(n$1, t$1);
		if (s$1 instanceof Pe && 0 === s$1.typeInfo.size) {
			const e$3 = s$1.typeInfo;
			return new Be(s$1.buffer.byteLength / e$3.stride, this.getTypeInfo("u32"));
		}
		return new Be(s$1.typeInfo.size, this.getTypeInfo("u32"));
	}
	Abs(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => Math.abs(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.abs(s$1.value), s$1.typeInfo);
	}
	Acos(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => Math.acos(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.acos(s$1.value), n$1.typeInfo);
	}
	Acosh(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => Math.acosh(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.acosh(s$1.value), n$1.typeInfo);
	}
	Asin(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => Math.asin(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.asin(s$1.value), n$1.typeInfo);
	}
	Asinh(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => Math.asinh(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.asinh(s$1.value), n$1.typeInfo);
	}
	Atan(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => Math.atan(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.atan(s$1.value), n$1.typeInfo);
	}
	Atanh(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => Math.atanh(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.atanh(s$1.value), n$1.typeInfo);
	}
	Atan2(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1), s$1 = this.exec.evalExpression(e$2.args[1], t$1);
		if (n$1 instanceof Me && s$1 instanceof Me) return new Me(n$1.data.map((e$3, t$2) => Math.atan2(e$3, s$1.data[t$2])), n$1.typeInfo);
		const r$1 = n$1, a$1 = s$1;
		return new Be(Math.atan2(r$1.value, a$1.value), n$1.typeInfo);
	}
	Ceil(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => Math.ceil(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.ceil(s$1.value), n$1.typeInfo);
	}
	_clamp(e$2, t$1, n$1) {
		return Math.min(Math.max(e$2, t$1), n$1);
	}
	Clamp(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1), s$1 = this.exec.evalExpression(e$2.args[1], t$1), r$1 = this.exec.evalExpression(e$2.args[2], t$1);
		if (n$1 instanceof Me && s$1 instanceof Me && r$1 instanceof Me) return new Me(n$1.data.map((e$3, t$2) => this._clamp(e$3, s$1.data[t$2], r$1.data[t$2])), n$1.typeInfo);
		const a$1 = n$1, i$1 = s$1, o$1 = r$1;
		return new Be(this._clamp(a$1.value, i$1.value, o$1.value), n$1.typeInfo);
	}
	Cos(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => Math.cos(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.cos(s$1.value), n$1.typeInfo);
	}
	Cosh(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => Math.cosh(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.cos(s$1.value), n$1.typeInfo);
	}
	CountLeadingZeros(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => Math.clz32(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.clz32(s$1.value), n$1.typeInfo);
	}
	_countOneBits(e$2) {
		let t$1 = 0;
		for (; 0 !== e$2;) 1 & e$2 && t$1++, e$2 >>= 1;
		return t$1;
	}
	CountOneBits(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => this._countOneBits(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(this._countOneBits(s$1.value), n$1.typeInfo);
	}
	_countTrailingZeros(e$2) {
		if (0 === e$2) return 32;
		let t$1 = 0;
		for (; !(1 & e$2);) e$2 >>= 1, t$1++;
		return t$1;
	}
	CountTrailingZeros(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => this._countTrailingZeros(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(this._countTrailingZeros(s$1.value), n$1.typeInfo);
	}
	Cross(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1), s$1 = this.exec.evalExpression(e$2.args[1], t$1);
		if (n$1 instanceof Me && s$1 instanceof Me) {
			if (3 !== n$1.data.length || 3 !== s$1.data.length) return console.error(`Cross() expects 3D vectors. Line ${e$2.line}`), null;
			const t$2 = n$1.data, r$1 = s$1.data;
			return new Me([
				t$2[1] * r$1[2] - r$1[1] * t$2[2],
				t$2[2] * r$1[0] - r$1[2] * t$2[0],
				t$2[0] * r$1[1] - r$1[0] * t$2[1]
			], n$1.typeInfo);
		}
		return console.error(`Cross() expects vector arguments. Line ${e$2.line}`), null;
	}
	Degrees(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1), s$1 = 180 / Math.PI;
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => e$3 * s$1), n$1.typeInfo);
		return new Be(n$1.value * s$1, this.getTypeInfo("f32"));
	}
	Determinant(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Ue) {
			const e$3 = n$1.data, t$2 = n$1.typeInfo.getTypeName(), s$1 = t$2.endsWith("h") ? this.getTypeInfo("f16") : this.getTypeInfo("f32");
			if ("mat2x2" === t$2 || "mat2x2f" === t$2 || "mat2x2h" === t$2) return new Be(e$3[0] * e$3[3] - e$3[1] * e$3[2], s$1);
			if ("mat2x3" === t$2 || "mat2x3f" === t$2 || "mat2x3h" === t$2) return new Be(e$3[0] * (e$3[4] * e$3[8] - e$3[5] * e$3[7]) - e$3[1] * (e$3[3] * e$3[8] - e$3[5] * e$3[6]) + e$3[2] * (e$3[3] * e$3[7] - e$3[4] * e$3[6]), s$1);
			if ("mat2x4" === t$2 || "mat2x4f" === t$2 || "mat2x4h" === t$2) console.error(`TODO: Determinant for ${t$2}`);
			else if ("mat3x2" === t$2 || "mat3x2f" === t$2 || "mat3x2h" === t$2) console.error(`TODO: Determinant for ${t$2}`);
			else {
				if ("mat3x3" === t$2 || "mat3x3f" === t$2 || "mat3x3h" === t$2) return new Be(e$3[0] * (e$3[4] * e$3[8] - e$3[5] * e$3[7]) - e$3[1] * (e$3[3] * e$3[8] - e$3[5] * e$3[6]) + e$3[2] * (e$3[3] * e$3[7] - e$3[4] * e$3[6]), s$1);
				"mat3x4" === t$2 || "mat3x4f" === t$2 || "mat3x4h" === t$2 || "mat4x2" === t$2 || "mat4x2f" === t$2 || "mat4x2h" === t$2 || "mat4x3" === t$2 || "mat4x3f" === t$2 || "mat4x3h" === t$2 ? console.error(`TODO: Determinant for ${t$2}`) : "mat4x4" !== t$2 && "mat4x4f" !== t$2 && "mat4x4h" !== t$2 || console.error(`TODO: Determinant for ${t$2}`);
			}
		}
		return console.error(`Determinant expects a matrix argument. Line ${e$2.line}`), null;
	}
	Distance(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1), s$1 = this.exec.evalExpression(e$2.args[1], t$1);
		if (n$1 instanceof Me && s$1 instanceof Me) {
			let e$3 = 0;
			for (let t$2 = 0; t$2 < n$1.data.length; ++t$2) e$3 += (n$1.data[t$2] - s$1.data[t$2]) * (n$1.data[t$2] - s$1.data[t$2]);
			return new Be(Math.sqrt(e$3), this.getTypeInfo("f32"));
		}
		const r$1 = n$1, a$1 = s$1;
		return new Be(Math.abs(r$1.value - a$1.value), n$1.typeInfo);
	}
	_dot(e$2, t$1) {
		let n$1 = 0;
		for (let s$1 = 0; s$1 < e$2.length; ++s$1) n$1 += t$1[s$1] * e$2[s$1];
		return n$1;
	}
	Dot(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1), s$1 = this.exec.evalExpression(e$2.args[1], t$1);
		return n$1 instanceof Me && s$1 instanceof Me ? new Be(this._dot(n$1.data, s$1.data), this.getTypeInfo("f32")) : (console.error(`Dot() expects vector arguments. Line ${e$2.line}`), null);
	}
	Dot4U8Packed(e$2, t$1) {
		return console.error(`TODO: dot4U8Packed. Line ${e$2.line}`), null;
	}
	Dot4I8Packed(e$2, t$1) {
		return console.error(`TODO: dot4I8Packed. Line ${e$2.line}`), null;
	}
	Exp(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => Math.exp(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.exp(s$1.value), n$1.typeInfo);
	}
	Exp2(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => Math.pow(2, e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.pow(2, s$1.value), n$1.typeInfo);
	}
	ExtractBits(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1), s$1 = this.exec.evalExpression(e$2.args[1], t$1), r$1 = this.exec.evalExpression(e$2.args[2], t$1);
		if ("u32" !== s$1.typeInfo.name && "x32" !== s$1.typeInfo.name) return console.error(`ExtractBits() expects an i32 offset argument. Line ${e$2.line}`), null;
		if ("u32" !== r$1.typeInfo.name && "x32" !== r$1.typeInfo.name) return console.error(`ExtractBits() expects an i32 count argument. Line ${e$2.line}`), null;
		const a$1 = s$1.value, i$1 = r$1.value;
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => e$3 >> a$1 & (1 << i$1) - 1), n$1.typeInfo);
		if ("i32" !== n$1.typeInfo.name && "x32" !== n$1.typeInfo.name) return console.error(`ExtractBits() expects an i32 argument. Line ${e$2.line}`), null;
		const o$1 = n$1.value;
		return new Be(o$1 >> a$1 & (1 << i$1) - 1, this.getTypeInfo("i32"));
	}
	FaceForward(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1), s$1 = this.exec.evalExpression(e$2.args[1], t$1), r$1 = this.exec.evalExpression(e$2.args[2], t$1);
		if (n$1 instanceof Me && s$1 instanceof Me && r$1 instanceof Me) return new Me(this._dot(s$1.data, r$1.data) < 0 ? Array.from(n$1.data) : n$1.data.map((e$3) => -e$3), n$1.typeInfo);
		return console.error(`FaceForward() expects vector arguments. Line ${e$2.line}`), null;
	}
	_firstLeadingBit(e$2) {
		return 0 === e$2 ? -1 : 31 - Math.clz32(e$2);
	}
	FirstLeadingBit(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => this._firstLeadingBit(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(this._firstLeadingBit(s$1.value), n$1.typeInfo);
	}
	_firstTrailingBit(e$2) {
		return 0 === e$2 ? -1 : Math.log2(e$2 & -e$2);
	}
	FirstTrailingBit(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => this._firstTrailingBit(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(this._firstTrailingBit(s$1.value), n$1.typeInfo);
	}
	Floor(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => Math.floor(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.floor(s$1.value), n$1.typeInfo);
	}
	Fma(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1), s$1 = this.exec.evalExpression(e$2.args[1], t$1), r$1 = this.exec.evalExpression(e$2.args[2], t$1);
		if (n$1 instanceof Me && s$1 instanceof Me && r$1 instanceof Me) return n$1.data.length !== s$1.data.length || n$1.data.length !== r$1.data.length ? (console.error(`Fma() expects vectors of the same length. Line ${e$2.line}`), null) : new Me(n$1.data.map((e$3, t$2) => e$3 * s$1.data[t$2] + r$1.data[t$2]), n$1.typeInfo);
		const a$1 = n$1, i$1 = s$1, o$1 = r$1;
		return new Be(a$1.value * i$1.value + o$1.value, a$1.typeInfo);
	}
	Fract(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => e$3 - Math.floor(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(s$1.value - Math.floor(s$1.value), n$1.typeInfo);
	}
	Frexp(e$2, t$1) {
		return console.error(`TODO: frexp. Line ${e$2.line}`), null;
	}
	InsertBits(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1), s$1 = this.exec.evalExpression(e$2.args[1], t$1), r$1 = this.exec.evalExpression(e$2.args[2], t$1), a$1 = this.exec.evalExpression(e$2.args[3], t$1);
		if ("u32" !== r$1.typeInfo.name && "x32" !== r$1.typeInfo.name) return console.error(`InsertBits() expects an i32 offset argument. Line ${e$2.line}`), null;
		const i$1 = r$1.value, o$1 = (1 << a$1.value) - 1 << i$1, c$1 = ~o$1;
		if (n$1 instanceof Me && s$1 instanceof Me) return new Me(n$1.data.map((e$3, t$2) => e$3 & c$1 | s$1.data[t$2] << i$1 & o$1), n$1.typeInfo);
		const l$1 = n$1.value, u$1 = s$1.value;
		return new Be(l$1 & c$1 | u$1 << i$1 & o$1, n$1.typeInfo);
	}
	InverseSqrt(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => 1 / Math.sqrt(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(1 / Math.sqrt(s$1.value), n$1.typeInfo);
	}
	Ldexp(e$2, t$1) {
		return console.error(`TODO: ldexp. Line ${e$2.line}`), null;
	}
	Length(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) {
			let e$3 = 0;
			return n$1.data.forEach((t$2) => {
				e$3 += t$2 * t$2;
			}), new Be(Math.sqrt(e$3), this.getTypeInfo("f32"));
		}
		const s$1 = n$1;
		return new Be(Math.abs(s$1.value), n$1.typeInfo);
	}
	Log(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => Math.log(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.log(s$1.value), n$1.typeInfo);
	}
	Log2(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => Math.log2(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.log2(s$1.value), n$1.typeInfo);
	}
	Max(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1), s$1 = this.exec.evalExpression(e$2.args[1], t$1);
		if (n$1 instanceof Me && s$1 instanceof Me) return new Me(n$1.data.map((e$3, t$2) => Math.max(e$3, s$1.data[t$2])), n$1.typeInfo);
		const r$1 = n$1, a$1 = s$1;
		return new Be(Math.max(r$1.value, a$1.value), n$1.typeInfo);
	}
	Min(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1), s$1 = this.exec.evalExpression(e$2.args[1], t$1);
		if (n$1 instanceof Me && s$1 instanceof Me) return new Me(n$1.data.map((e$3, t$2) => Math.min(e$3, s$1.data[t$2])), n$1.typeInfo);
		const r$1 = n$1, a$1 = s$1;
		return new Be(Math.min(r$1.value, a$1.value), n$1.typeInfo);
	}
	Mix(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1), s$1 = this.exec.evalExpression(e$2.args[1], t$1), r$1 = this.exec.evalExpression(e$2.args[2], t$1);
		if (n$1 instanceof Me && s$1 instanceof Me && r$1 instanceof Me) return new Me(n$1.data.map((e$3, t$2) => n$1.data[t$2] * (1 - r$1.data[t$2]) + s$1.data[t$2] * r$1.data[t$2]), n$1.typeInfo);
		const a$1 = s$1, i$1 = r$1;
		return new Be(n$1.value * (1 - i$1.value) + a$1.value * i$1.value, n$1.typeInfo);
	}
	Modf(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1), s$1 = this.exec.evalExpression(e$2.args[1], t$1);
		if (n$1 instanceof Me && s$1 instanceof Me) return new Me(n$1.data.map((e$3, t$2) => e$3 % s$1.data[t$2]), n$1.typeInfo);
		const r$1 = s$1;
		return new Be(n$1.value % r$1.value, n$1.typeInfo);
	}
	Normalize(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) {
			const s$1 = this.Length(e$2, t$1).value;
			return new Me(n$1.data.map((e$3) => e$3 / s$1), n$1.typeInfo);
		}
		return console.error(`Normalize() expects a vector argument. Line ${e$2.line}`), null;
	}
	Pow(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1), s$1 = this.exec.evalExpression(e$2.args[1], t$1);
		if (n$1 instanceof Me && s$1 instanceof Me) return new Me(n$1.data.map((e$3, t$2) => Math.pow(e$3, s$1.data[t$2])), n$1.typeInfo);
		const r$1 = n$1, a$1 = s$1;
		return new Be(Math.pow(r$1.value, a$1.value), n$1.typeInfo);
	}
	QuantizeToF16(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => e$3), n$1.typeInfo);
		return new Be(n$1.value, n$1.typeInfo);
	}
	Radians(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => e$3 * Math.PI / 180), n$1.typeInfo);
		return new Be(n$1.value * Math.PI / 180, this.getTypeInfo("f32"));
	}
	Reflect(e$2, t$1) {
		let n$1 = this.exec.evalExpression(e$2.args[0], t$1), s$1 = this.exec.evalExpression(e$2.args[1], t$1);
		if (n$1 instanceof Me && s$1 instanceof Me) {
			const e$3 = this._dot(n$1.data, s$1.data);
			return new Me(n$1.data.map((t$2, n$2) => t$2 - 2 * e$3 * s$1.data[n$2]), n$1.typeInfo);
		}
		return console.error(`Reflect() expects vector arguments. Line ${e$2.line}`), null;
	}
	Refract(e$2, t$1) {
		let n$1 = this.exec.evalExpression(e$2.args[0], t$1), s$1 = this.exec.evalExpression(e$2.args[1], t$1), r$1 = this.exec.evalExpression(e$2.args[2], t$1);
		if (n$1 instanceof Me && s$1 instanceof Me && r$1 instanceof Be) {
			const e$3 = this._dot(s$1.data, n$1.data);
			return new Me(n$1.data.map((t$2, n$2) => {
				const a$1 = 1 - r$1.value * r$1.value * (1 - e$3 * e$3);
				if (a$1 < 0) return 0;
				const i$1 = Math.sqrt(a$1);
				return r$1.value * t$2 - (r$1.value * e$3 + i$1) * s$1.data[n$2];
			}), n$1.typeInfo);
		}
		return console.error(`Refract() expects vector arguments and a scalar argument. Line ${e$2.line}`), null;
	}
	ReverseBits(e$2, t$1) {
		return console.error(`TODO: reverseBits. Line ${e$2.line}`), null;
	}
	Round(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => Math.round(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.round(s$1.value), n$1.typeInfo);
	}
	Saturate(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => Math.min(Math.max(e$3, 0), 1)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.min(Math.max(s$1.value, 0), 1), n$1.typeInfo);
	}
	Sign(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => Math.sign(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.sign(s$1.value), n$1.typeInfo);
	}
	Sin(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => Math.sin(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.sin(s$1.value), n$1.typeInfo);
	}
	Sinh(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => Math.sinh(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.sinh(s$1.value), n$1.typeInfo);
	}
	_smoothstep(e$2, t$1, n$1) {
		const s$1 = Math.min(Math.max((n$1 - e$2) / (t$1 - e$2), 0), 1);
		return s$1 * s$1 * (3 - 2 * s$1);
	}
	SmoothStep(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1), s$1 = this.exec.evalExpression(e$2.args[1], t$1), r$1 = this.exec.evalExpression(e$2.args[2], t$1);
		if (r$1 instanceof Me && n$1 instanceof Me && s$1 instanceof Me) return new Me(r$1.data.map((e$3, t$2) => this._smoothstep(n$1.data[t$2], s$1.data[t$2], e$3)), r$1.typeInfo);
		const a$1 = n$1, i$1 = s$1, o$1 = r$1;
		return new Be(this._smoothstep(a$1.value, i$1.value, o$1.value), r$1.typeInfo);
	}
	Sqrt(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => Math.sqrt(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.sqrt(s$1.value), n$1.typeInfo);
	}
	Step(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1), s$1 = this.exec.evalExpression(e$2.args[1], t$1);
		if (s$1 instanceof Me && n$1 instanceof Me) return new Me(s$1.data.map((e$3, t$2) => e$3 < n$1.data[t$2] ? 0 : 1), s$1.typeInfo);
		const r$1 = n$1;
		return new Be(s$1.value < r$1.value ? 0 : 1, r$1.typeInfo);
	}
	Tan(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => Math.tan(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.tan(s$1.value), n$1.typeInfo);
	}
	Tanh(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => Math.tanh(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.tanh(s$1.value), n$1.typeInfo);
	}
	_getTransposeType(e$2) {
		const t$1 = e$2.getTypeName();
		return "mat2x2f" === t$1 || "mat2x2h" === t$1 ? e$2 : "mat2x3f" === t$1 ? this.getTypeInfo("mat3x2f") : "mat2x3h" === t$1 ? this.getTypeInfo("mat3x2h") : "mat2x4f" === t$1 ? this.getTypeInfo("mat4x2f") : "mat2x4h" === t$1 ? this.getTypeInfo("mat4x2h") : "mat3x2f" === t$1 ? this.getTypeInfo("mat2x3f") : "mat3x2h" === t$1 ? this.getTypeInfo("mat2x3h") : "mat3x3f" === t$1 || "mat3x3h" === t$1 ? e$2 : "mat3x4f" === t$1 ? this.getTypeInfo("mat4x3f") : "mat3x4h" === t$1 ? this.getTypeInfo("mat4x3h") : "mat4x2f" === t$1 ? this.getTypeInfo("mat2x4f") : "mat4x2h" === t$1 ? this.getTypeInfo("mat2x4h") : "mat4x3f" === t$1 ? this.getTypeInfo("mat3x4f") : "mat4x3h" === t$1 ? this.getTypeInfo("mat3x4h") : ("mat4x4f" === t$1 || "mat4x4h" === t$1 || console.error(`Invalid matrix type ${t$1}`), e$2);
	}
	Transpose(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (!(n$1 instanceof Ue)) return console.error(`Transpose() expects a matrix argument. Line ${e$2.line}`), null;
		const s$1 = this._getTransposeType(n$1.typeInfo);
		if ("mat2x2" === n$1.typeInfo.name || "mat2x2f" === n$1.typeInfo.name || "mat2x2h" === n$1.typeInfo.name) {
			const e$3 = n$1.data;
			return new Ue([
				e$3[0],
				e$3[2],
				e$3[1],
				e$3[3]
			], s$1);
		}
		if ("mat2x3" === n$1.typeInfo.name || "mat2x3f" === n$1.typeInfo.name || "mat2x3h" === n$1.typeInfo.name) {
			const e$3 = n$1.data;
			return new Ue([
				e$3[0],
				e$3[3],
				e$3[6],
				e$3[1],
				e$3[4],
				e$3[7]
			], s$1);
		}
		if ("mat2x4" === n$1.typeInfo.name || "mat2x4f" === n$1.typeInfo.name || "mat2x4h" === n$1.typeInfo.name) {
			const e$3 = n$1.data;
			return new Ue([
				e$3[0],
				e$3[4],
				e$3[8],
				e$3[12],
				e$3[1],
				e$3[5],
				e$3[9],
				e$3[13]
			], s$1);
		}
		if ("mat3x2" === n$1.typeInfo.name || "mat3x2f" === n$1.typeInfo.name || "mat3x2h" === n$1.typeInfo.name) {
			const e$3 = n$1.data;
			return new Ue([
				e$3[0],
				e$3[3],
				e$3[1],
				e$3[4],
				e$3[2],
				e$3[5]
			], s$1);
		}
		if ("mat3x3" === n$1.typeInfo.name || "mat3x3f" === n$1.typeInfo.name || "mat3x3h" === n$1.typeInfo.name) {
			const e$3 = n$1.data;
			return new Ue([
				e$3[0],
				e$3[3],
				e$3[6],
				e$3[1],
				e$3[4],
				e$3[7],
				e$3[2],
				e$3[5],
				e$3[8]
			], s$1);
		}
		if ("mat3x4" === n$1.typeInfo.name || "mat3x4f" === n$1.typeInfo.name || "mat3x4h" === n$1.typeInfo.name) {
			const e$3 = n$1.data;
			return new Ue([
				e$3[0],
				e$3[4],
				e$3[8],
				e$3[12],
				e$3[1],
				e$3[5],
				e$3[9],
				e$3[13],
				e$3[2],
				e$3[6],
				e$3[10],
				e$3[14]
			], s$1);
		}
		if ("mat4x2" === n$1.typeInfo.name || "mat4x2f" === n$1.typeInfo.name || "mat4x2h" === n$1.typeInfo.name) {
			const e$3 = n$1.data;
			return new Ue([
				e$3[0],
				e$3[4],
				e$3[1],
				e$3[5],
				e$3[2],
				e$3[6]
			], s$1);
		}
		if ("mat4x3" === n$1.typeInfo.name || "mat4x3f" === n$1.typeInfo.name || "mat4x3h" === n$1.typeInfo.name) {
			const e$3 = n$1.data;
			return new Ue([
				e$3[0],
				e$3[4],
				e$3[8],
				e$3[1],
				e$3[5],
				e$3[9],
				e$3[2],
				e$3[6],
				e$3[10]
			], s$1);
		}
		if ("mat4x4" === n$1.typeInfo.name || "mat4x4f" === n$1.typeInfo.name || "mat4x4h" === n$1.typeInfo.name) {
			const e$3 = n$1.data;
			return new Ue([
				e$3[0],
				e$3[4],
				e$3[8],
				e$3[12],
				e$3[1],
				e$3[5],
				e$3[9],
				e$3[13],
				e$3[2],
				e$3[6],
				e$3[10],
				e$3[14],
				e$3[3],
				e$3[7],
				e$3[11],
				e$3[15]
			], s$1);
		}
		return console.error(`Invalid matrix type ${n$1.typeInfo.name}`), null;
	}
	Trunc(e$2, t$1) {
		const n$1 = this.exec.evalExpression(e$2.args[0], t$1);
		if (n$1 instanceof Me) return new Me(n$1.data.map((e$3) => Math.trunc(e$3)), n$1.typeInfo);
		const s$1 = n$1;
		return new Be(Math.trunc(s$1.value), n$1.typeInfo);
	}
	Dpdx(e$2, t$1) {
		return console.error(`TODO: dpdx. Line ${e$2.line}`), null;
	}
	DpdxCoarse(e$2, t$1) {
		return console.error(`TODO: dpdxCoarse. Line ${e$2.line}`), null;
	}
	DpdxFine(e$2, t$1) {
		return console.error("TODO: dpdxFine"), null;
	}
	Dpdy(e$2, t$1) {
		return console.error("TODO: dpdy"), null;
	}
	DpdyCoarse(e$2, t$1) {
		return console.error("TODO: dpdyCoarse"), null;
	}
	DpdyFine(e$2, t$1) {
		return console.error("TODO: dpdyFine"), null;
	}
	Fwidth(e$2, t$1) {
		return console.error("TODO: fwidth"), null;
	}
	FwidthCoarse(e$2, t$1) {
		return console.error("TODO: fwidthCoarse"), null;
	}
	FwidthFine(e$2, t$1) {
		return console.error("TODO: fwidthFine"), null;
	}
	TextureDimensions(e$2, t$1) {
		const n$1 = e$2.args[0], s$1 = e$2.args.length > 1 ? this.exec.evalExpression(e$2.args[1], t$1).value : 0;
		if (n$1 instanceof ge) {
			const r$1 = n$1.name, a$1 = t$1.getVariableValue(r$1);
			if (a$1 instanceof We) {
				if (s$1 < 0 || s$1 >= a$1.mipLevelCount) return console.error(`Invalid mip level for textureDimensions. Line ${e$2.line}`), null;
				const t$2 = a$1.getMipLevelSize(s$1), n$2 = a$1.dimension;
				return "1d" === n$2 ? new Be(t$2[0], this.getTypeInfo("u32")) : "3d" === n$2 ? new Me(t$2, this.getTypeInfo("vec3u")) : "2d" === n$2 ? new Me(t$2.slice(0, 2), this.getTypeInfo("vec2u")) : (console.error(`Invalid texture dimension ${n$2} not found. Line ${e$2.line}`), null);
			}
			return console.error(`Texture ${r$1} not found. Line ${e$2.line}`), null;
		}
		return console.error(`Invalid texture argument for textureDimensions. Line ${e$2.line}`), null;
	}
	TextureGather(e$2, t$1) {
		return console.error("TODO: textureGather"), null;
	}
	TextureGatherCompare(e$2, t$1) {
		return console.error("TODO: textureGatherCompare"), null;
	}
	TextureLoad(e$2, t$1) {
		const n$1 = e$2.args[0], s$1 = this.exec.evalExpression(e$2.args[1], t$1), r$1 = e$2.args.length > 2 ? this.exec.evalExpression(e$2.args[2], t$1).value : 0;
		if (!(s$1 instanceof Me) || 2 !== s$1.data.length) return console.error(`Invalid UV argument for textureLoad. Line ${e$2.line}`), null;
		if (n$1 instanceof ge) {
			const a$1 = n$1.name, i$1 = t$1.getVariableValue(a$1);
			if (i$1 instanceof We) {
				const t$2 = Math.floor(s$1.data[0]), n$2 = Math.floor(s$1.data[1]);
				if (t$2 < 0 || t$2 >= i$1.width || n$2 < 0 || n$2 >= i$1.height) return console.error(`Texture ${a$1} out of bounds. Line ${e$2.line}`), null;
				const o$1 = i$1.getPixel(t$2, n$2, 0, r$1);
				return null === o$1 ? (console.error(`Invalid texture format for textureLoad. Line ${e$2.line}`), null) : new Me(o$1, this.getTypeInfo("vec4f"));
			}
			return console.error(`Texture ${a$1} not found. Line ${e$2.line}`), null;
		}
		return console.error(`Invalid texture argument for textureLoad. Line ${e$2.line}`), null;
	}
	TextureNumLayers(e$2, t$1) {
		const n$1 = e$2.args[0];
		if (n$1 instanceof ge) {
			const s$1 = n$1.name, r$1 = t$1.getVariableValue(s$1);
			return r$1 instanceof We ? new Be(r$1.depthOrArrayLayers, this.getTypeInfo("u32")) : (console.error(`Texture ${s$1} not found. Line ${e$2.line}`), null);
		}
		return console.error(`Invalid texture argument for textureNumLayers. Line ${e$2.line}`), null;
	}
	TextureNumLevels(e$2, t$1) {
		const n$1 = e$2.args[0];
		if (n$1 instanceof ge) {
			const s$1 = n$1.name, r$1 = t$1.getVariableValue(s$1);
			return r$1 instanceof We ? new Be(r$1.mipLevelCount, this.getTypeInfo("u32")) : (console.error(`Texture ${s$1} not found. Line ${e$2.line}`), null);
		}
		return console.error(`Invalid texture argument for textureNumLevels. Line ${e$2.line}`), null;
	}
	TextureNumSamples(e$2, t$1) {
		const n$1 = e$2.args[0];
		if (n$1 instanceof ge) {
			const s$1 = n$1.name, r$1 = t$1.getVariableValue(s$1);
			return r$1 instanceof We ? new Be(r$1.sampleCount, this.getTypeInfo("u32")) : (console.error(`Texture ${s$1} not found. Line ${e$2.line}`), null);
		}
		return console.error(`Invalid texture argument for textureNumSamples. Line ${e$2.line}`), null;
	}
	TextureSample(e$2, t$1) {
		return console.error("TODO: textureSample"), null;
	}
	TextureSampleBias(e$2, t$1) {
		return console.error("TODO: textureSampleBias"), null;
	}
	TextureSampleCompare(e$2, t$1) {
		return console.error("TODO: textureSampleCompare"), null;
	}
	TextureSampleCompareLevel(e$2, t$1) {
		return console.error("TODO: textureSampleCompareLevel"), null;
	}
	TextureSampleGrad(e$2, t$1) {
		return console.error("TODO: textureSampleGrad"), null;
	}
	TextureSampleLevel(e$2, t$1) {
		return console.error("TODO: textureSampleLevel"), null;
	}
	TextureSampleBaseClampToEdge(e$2, t$1) {
		return console.error("TODO: textureSampleBaseClampToEdge"), null;
	}
	TextureStore(e$2, t$1) {
		const n$1 = e$2.args[0], s$1 = this.exec.evalExpression(e$2.args[1], t$1), r$1 = 4 === e$2.args.length ? this.exec.evalExpression(e$2.args[2], t$1).value : 0, a$1 = 4 === e$2.args.length ? this.exec.evalExpression(e$2.args[3], t$1).data : this.exec.evalExpression(e$2.args[2], t$1).data;
		if (4 !== a$1.length) return console.error(`Invalid value argument for textureStore. Line ${e$2.line}`), null;
		if (!(s$1 instanceof Me) || 2 !== s$1.data.length) return console.error(`Invalid UV argument for textureStore. Line ${e$2.line}`), null;
		if (n$1 instanceof ge) {
			const i$1 = n$1.name, o$1 = t$1.getVariableValue(i$1);
			if (o$1 instanceof We) {
				const t$2 = o$1.getMipLevelSize(0), n$2 = Math.floor(s$1.data[0]), c$1 = Math.floor(s$1.data[1]);
				return n$2 < 0 || n$2 >= t$2[0] || c$1 < 0 || c$1 >= t$2[1] ? (console.error(`Texture ${i$1} out of bounds. Line ${e$2.line}`), null) : (o$1.setPixel(n$2, c$1, 0, r$1, Array.from(a$1)), null);
			}
			return console.error(`Texture ${i$1} not found. Line ${e$2.line}`), null;
		}
		return console.error(`Invalid texture argument for textureStore. Line ${e$2.line}`), null;
	}
	AtomicLoad(e$2, t$1) {
		let n$1 = e$2.args[0];
		n$1 instanceof ke && (n$1 = n$1.right);
		const s$1 = this.exec.getVariableName(n$1, t$1);
		return t$1.getVariable(s$1).value.getSubData(this.exec, n$1.postfix, t$1);
	}
	AtomicStore(e$2, t$1) {
		let n$1 = e$2.args[0];
		n$1 instanceof ke && (n$1 = n$1.right);
		const s$1 = this.exec.getVariableName(n$1, t$1), r$1 = t$1.getVariable(s$1);
		let a$1 = e$2.args[1];
		const i$1 = this.exec.evalExpression(a$1, t$1), o$1 = r$1.value.getSubData(this.exec, n$1.postfix, t$1);
		return o$1 instanceof Be && i$1 instanceof Be && (o$1.value = i$1.value), r$1.value instanceof Pe && r$1.value.setDataValue(this.exec, o$1, n$1.postfix, t$1), null;
	}
	AtomicAdd(e$2, t$1) {
		let n$1 = e$2.args[0];
		n$1 instanceof ke && (n$1 = n$1.right);
		const s$1 = this.exec.getVariableName(n$1, t$1), r$1 = t$1.getVariable(s$1);
		let a$1 = e$2.args[1];
		const i$1 = this.exec.evalExpression(a$1, t$1), o$1 = r$1.value.getSubData(this.exec, n$1.postfix, t$1), c$1 = new Be(o$1.value, o$1.typeInfo);
		return o$1 instanceof Be && i$1 instanceof Be && (o$1.value += i$1.value), r$1.value instanceof Pe && r$1.value.setDataValue(this.exec, o$1, n$1.postfix, t$1), c$1;
	}
	AtomicSub(e$2, t$1) {
		let n$1 = e$2.args[0];
		n$1 instanceof ke && (n$1 = n$1.right);
		const s$1 = this.exec.getVariableName(n$1, t$1), r$1 = t$1.getVariable(s$1);
		let a$1 = e$2.args[1];
		const i$1 = this.exec.evalExpression(a$1, t$1), o$1 = r$1.value.getSubData(this.exec, n$1.postfix, t$1), c$1 = new Be(o$1.value, o$1.typeInfo);
		return o$1 instanceof Be && i$1 instanceof Be && (o$1.value -= i$1.value), r$1.value instanceof Pe && r$1.value.setDataValue(this.exec, o$1, n$1.postfix, t$1), c$1;
	}
	AtomicMax(e$2, t$1) {
		let n$1 = e$2.args[0];
		n$1 instanceof ke && (n$1 = n$1.right);
		const s$1 = this.exec.getVariableName(n$1, t$1), r$1 = t$1.getVariable(s$1);
		let a$1 = e$2.args[1];
		const i$1 = this.exec.evalExpression(a$1, t$1), o$1 = r$1.value.getSubData(this.exec, n$1.postfix, t$1), c$1 = new Be(o$1.value, o$1.typeInfo);
		return o$1 instanceof Be && i$1 instanceof Be && (o$1.value = Math.max(o$1.value, i$1.value)), r$1.value instanceof Pe && r$1.value.setDataValue(this.exec, o$1, n$1.postfix, t$1), c$1;
	}
	AtomicMin(e$2, t$1) {
		let n$1 = e$2.args[0];
		n$1 instanceof ke && (n$1 = n$1.right);
		const s$1 = this.exec.getVariableName(n$1, t$1), r$1 = t$1.getVariable(s$1);
		let a$1 = e$2.args[1];
		const i$1 = this.exec.evalExpression(a$1, t$1), o$1 = r$1.value.getSubData(this.exec, n$1.postfix, t$1), c$1 = new Be(o$1.value, o$1.typeInfo);
		return o$1 instanceof Be && i$1 instanceof Be && (o$1.value = Math.min(o$1.value, i$1.value)), r$1.value instanceof Pe && r$1.value.setDataValue(this.exec, o$1, n$1.postfix, t$1), c$1;
	}
	AtomicAnd(e$2, t$1) {
		let n$1 = e$2.args[0];
		n$1 instanceof ke && (n$1 = n$1.right);
		const s$1 = this.exec.getVariableName(n$1, t$1), r$1 = t$1.getVariable(s$1);
		let a$1 = e$2.args[1];
		const i$1 = this.exec.evalExpression(a$1, t$1), o$1 = r$1.value.getSubData(this.exec, n$1.postfix, t$1), c$1 = new Be(o$1.value, o$1.typeInfo);
		return o$1 instanceof Be && i$1 instanceof Be && (o$1.value = o$1.value & i$1.value), r$1.value instanceof Pe && r$1.value.setDataValue(this.exec, o$1, n$1.postfix, t$1), c$1;
	}
	AtomicOr(e$2, t$1) {
		let n$1 = e$2.args[0];
		n$1 instanceof ke && (n$1 = n$1.right);
		const s$1 = this.exec.getVariableName(n$1, t$1), r$1 = t$1.getVariable(s$1);
		let a$1 = e$2.args[1];
		const i$1 = this.exec.evalExpression(a$1, t$1), o$1 = r$1.value.getSubData(this.exec, n$1.postfix, t$1), c$1 = new Be(o$1.value, o$1.typeInfo);
		return o$1 instanceof Be && i$1 instanceof Be && (o$1.value = o$1.value | i$1.value), r$1.value instanceof Pe && r$1.value.setDataValue(this.exec, o$1, n$1.postfix, t$1), c$1;
	}
	AtomicXor(e$2, t$1) {
		let n$1 = e$2.args[0];
		n$1 instanceof ke && (n$1 = n$1.right);
		const s$1 = this.exec.getVariableName(n$1, t$1), r$1 = t$1.getVariable(s$1);
		let a$1 = e$2.args[1];
		const i$1 = this.exec.evalExpression(a$1, t$1), o$1 = r$1.value.getSubData(this.exec, n$1.postfix, t$1), c$1 = new Be(o$1.value, o$1.typeInfo);
		return o$1 instanceof Be && i$1 instanceof Be && (o$1.value = o$1.value ^ i$1.value), r$1.value instanceof Pe && r$1.value.setDataValue(this.exec, o$1, n$1.postfix, t$1), c$1;
	}
	AtomicExchange(e$2, t$1) {
		let n$1 = e$2.args[0];
		n$1 instanceof ke && (n$1 = n$1.right);
		const s$1 = this.exec.getVariableName(n$1, t$1), r$1 = t$1.getVariable(s$1);
		let a$1 = e$2.args[1];
		const i$1 = this.exec.evalExpression(a$1, t$1), o$1 = r$1.value.getSubData(this.exec, n$1.postfix, t$1), c$1 = new Be(o$1.value, o$1.typeInfo);
		return o$1 instanceof Be && i$1 instanceof Be && (o$1.value = i$1.value), r$1.value instanceof Pe && r$1.value.setDataValue(this.exec, o$1, n$1.postfix, t$1), c$1;
	}
	AtomicCompareExchangeWeak(e$2, t$1) {
		return console.error("TODO: atomicCompareExchangeWeak"), null;
	}
	Pack4x8snorm(e$2, t$1) {
		return console.error("TODO: pack4x8snorm"), null;
	}
	Pack4x8unorm(e$2, t$1) {
		return console.error("TODO: pack4x8unorm"), null;
	}
	Pack4xI8(e$2, t$1) {
		return console.error("TODO: pack4xI8"), null;
	}
	Pack4xU8(e$2, t$1) {
		return console.error("TODO: pack4xU8"), null;
	}
	Pack4x8Clamp(e$2, t$1) {
		return console.error("TODO: pack4x8Clamp"), null;
	}
	Pack4xU8Clamp(e$2, t$1) {
		return console.error("TODO: pack4xU8Clamp"), null;
	}
	Pack2x16snorm(e$2, t$1) {
		return console.error("TODO: pack2x16snorm"), null;
	}
	Pack2x16unorm(e$2, t$1) {
		return console.error("TODO: pack2x16unorm"), null;
	}
	Pack2x16float(e$2, t$1) {
		return console.error("TODO: pack2x16float"), null;
	}
	Unpack4x8snorm(e$2, t$1) {
		return console.error("TODO: unpack4x8snorm"), null;
	}
	Unpack4x8unorm(e$2, t$1) {
		return console.error("TODO: unpack4x8unorm"), null;
	}
	Unpack4xI8(e$2, t$1) {
		return console.error("TODO: unpack4xI8"), null;
	}
	Unpack4xU8(e$2, t$1) {
		return console.error("TODO: unpack4xU8"), null;
	}
	Unpack2x16snorm(e$2, t$1) {
		return console.error("TODO: unpack2x16snorm"), null;
	}
	Unpack2x16unorm(e$2, t$1) {
		return console.error("TODO: unpack2x16unorm"), null;
	}
	Unpack2x16float(e$2, t$1) {
		return console.error("TODO: unpack2x16float"), null;
	}
	StorageBarrier(e$2, t$1) {
		return null;
	}
	TextureBarrier(e$2, t$1) {
		return null;
	}
	WorkgroupBarrier(e$2, t$1) {
		return null;
	}
	WorkgroupUniformLoad(e$2, t$1) {
		return null;
	}
	SubgroupAdd(e$2, t$1) {
		return console.error("TODO: subgroupAdd"), null;
	}
	SubgroupExclusiveAdd(e$2, t$1) {
		return console.error("TODO: subgroupExclusiveAdd"), null;
	}
	SubgroupInclusiveAdd(e$2, t$1) {
		return console.error("TODO: subgroupInclusiveAdd"), null;
	}
	SubgroupAll(e$2, t$1) {
		return console.error("TODO: subgroupAll"), null;
	}
	SubgroupAnd(e$2, t$1) {
		return console.error("TODO: subgroupAnd"), null;
	}
	SubgroupAny(e$2, t$1) {
		return console.error("TODO: subgroupAny"), null;
	}
	SubgroupBallot(e$2, t$1) {
		return console.error("TODO: subgroupBallot"), null;
	}
	SubgroupBroadcast(e$2, t$1) {
		return console.error("TODO: subgroupBroadcast"), null;
	}
	SubgroupBroadcastFirst(e$2, t$1) {
		return console.error("TODO: subgroupBroadcastFirst"), null;
	}
	SubgroupElect(e$2, t$1) {
		return console.error("TODO: subgroupElect"), null;
	}
	SubgroupMax(e$2, t$1) {
		return console.error("TODO: subgroupMax"), null;
	}
	SubgroupMin(e$2, t$1) {
		return console.error("TODO: subgroupMin"), null;
	}
	SubgroupMul(e$2, t$1) {
		return console.error("TODO: subgroupMul"), null;
	}
	SubgroupExclusiveMul(e$2, t$1) {
		return console.error("TODO: subgroupExclusiveMul"), null;
	}
	SubgroupInclusiveMul(e$2, t$1) {
		return console.error("TODO: subgroupInclusiveMul"), null;
	}
	SubgroupOr(e$2, t$1) {
		return console.error("TODO: subgroupOr"), null;
	}
	SubgroupShuffle(e$2, t$1) {
		return console.error("TODO: subgroupShuffle"), null;
	}
	SubgroupShuffleDown(e$2, t$1) {
		return console.error("TODO: subgroupShuffleDown"), null;
	}
	SubgroupShuffleUp(e$2, t$1) {
		return console.error("TODO: subgroupShuffleUp"), null;
	}
	SubgroupShuffleXor(e$2, t$1) {
		return console.error("TODO: subgroupShuffleXor"), null;
	}
	SubgroupXor(e$2, t$1) {
		return console.error("TODO: subgroupXor"), null;
	}
	QuadBroadcast(e$2, t$1) {
		return console.error("TODO: quadBroadcast"), null;
	}
	QuadSwapDiagonal(e$2, t$1) {
		return console.error("TODO: quadSwapDiagonal"), null;
	}
	QuadSwapX(e$2, t$1) {
		return console.error("TODO: quadSwapX"), null;
	}
	QuadSwapY(e$2, t$1) {
		return console.error("TODO: quadSwapY"), null;
	}
};
var ft = {
	vec2: 2,
	vec2f: 2,
	vec2i: 2,
	vec2u: 2,
	vec2b: 2,
	vec2h: 2,
	vec3: 3,
	vec3f: 3,
	vec3i: 3,
	vec3u: 3,
	vec3b: 3,
	vec3h: 3,
	vec4: 4,
	vec4f: 4,
	vec4i: 4,
	vec4u: 4,
	vec4b: 4,
	vec4h: 4
}, pt = {
	mat2x2: [
		2,
		2,
		4
	],
	mat2x2f: [
		2,
		2,
		4
	],
	mat2x2h: [
		2,
		2,
		4
	],
	mat2x3: [
		2,
		3,
		6
	],
	mat2x3f: [
		2,
		3,
		6
	],
	mat2x3h: [
		2,
		3,
		6
	],
	mat2x4: [
		2,
		4,
		8
	],
	mat2x4f: [
		2,
		4,
		8
	],
	mat2x4h: [
		2,
		4,
		8
	],
	mat3x2: [
		3,
		2,
		6
	],
	mat3x2f: [
		3,
		2,
		6
	],
	mat3x2h: [
		3,
		2,
		6
	],
	mat3x3: [
		3,
		3,
		9
	],
	mat3x3f: [
		3,
		3,
		9
	],
	mat3x3h: [
		3,
		3,
		9
	],
	mat3x4: [
		3,
		4,
		12
	],
	mat3x4f: [
		3,
		4,
		12
	],
	mat3x4h: [
		3,
		4,
		12
	],
	mat4x2: [
		4,
		2,
		8
	],
	mat4x2f: [
		4,
		2,
		8
	],
	mat4x2h: [
		4,
		2,
		8
	],
	mat4x3: [
		4,
		3,
		12
	],
	mat4x3f: [
		4,
		3,
		12
	],
	mat4x3h: [
		4,
		3,
		12
	],
	mat4x4: [
		4,
		4,
		16
	],
	mat4x4f: [
		4,
		4,
		16
	],
	mat4x4h: [
		4,
		4,
		16
	]
};
var dt = class dt extends ut {
	constructor(e$2, t$1) {
		var n$1;
		super(), this.ast = null != e$2 ? e$2 : [], this.reflection = new at(), this.reflection.updateAST(this.ast), this.context = null !== (n$1 = null == t$1 ? void 0 : t$1.clone()) && void 0 !== n$1 ? n$1 : new lt(), this.builtins = new ht(this), this.typeInfo = {
			bool: this.getTypeInfo(ae.bool),
			i32: this.getTypeInfo(ae.i32),
			u32: this.getTypeInfo(ae.u32),
			f32: this.getTypeInfo(ae.f32),
			f16: this.getTypeInfo(ae.f16),
			vec2f: this.getTypeInfo(ce.vec2f),
			vec2u: this.getTypeInfo(ce.vec2u),
			vec2i: this.getTypeInfo(ce.vec2i),
			vec2h: this.getTypeInfo(ce.vec2h),
			vec3f: this.getTypeInfo(ce.vec3f),
			vec3u: this.getTypeInfo(ce.vec3u),
			vec3i: this.getTypeInfo(ce.vec3i),
			vec3h: this.getTypeInfo(ce.vec3h),
			vec4f: this.getTypeInfo(ce.vec4f),
			vec4u: this.getTypeInfo(ce.vec4u),
			vec4i: this.getTypeInfo(ce.vec4i),
			vec4h: this.getTypeInfo(ce.vec4h),
			mat2x2f: this.getTypeInfo(ce.mat2x2f),
			mat2x3f: this.getTypeInfo(ce.mat2x3f),
			mat2x4f: this.getTypeInfo(ce.mat2x4f),
			mat3x2f: this.getTypeInfo(ce.mat3x2f),
			mat3x3f: this.getTypeInfo(ce.mat3x3f),
			mat3x4f: this.getTypeInfo(ce.mat3x4f),
			mat4x2f: this.getTypeInfo(ce.mat4x2f),
			mat4x3f: this.getTypeInfo(ce.mat4x3f),
			mat4x4f: this.getTypeInfo(ce.mat4x4f)
		};
	}
	getVariableValue(e$2) {
		var t$1, n$1;
		const r$1 = null !== (n$1 = null === (t$1 = this.context.getVariable(e$2)) || void 0 === t$1 ? void 0 : t$1.value) && void 0 !== n$1 ? n$1 : null;
		if (null === r$1) return null;
		if (r$1 instanceof Be) return r$1.value;
		if (r$1 instanceof Me) return Array.from(r$1.data);
		if (r$1 instanceof Ue) return Array.from(r$1.data);
		if (r$1 instanceof Pe && r$1.typeInfo instanceof s) {
			if ("u32" === r$1.typeInfo.format.name) return Array.from(new Uint32Array(r$1.buffer, r$1.offset, r$1.typeInfo.count));
			if ("i32" === r$1.typeInfo.format.name) return Array.from(new Int32Array(r$1.buffer, r$1.offset, r$1.typeInfo.count));
			if ("f32" === r$1.typeInfo.format.name) return Array.from(new Float32Array(r$1.buffer, r$1.offset, r$1.typeInfo.count));
		}
		return console.error(`Unsupported return variable type ${r$1.typeInfo.name}`), null;
	}
	execute(e$2) {
		(e$2 = null != e$2 ? e$2 : {}).constants && this._setOverrides(e$2.constants, this.context), this._execStatements(this.ast, this.context);
	}
	dispatchWorkgroups(e$2, t$1, n$1, s$1) {
		const r$1 = this.context.clone();
		(s$1 = null != s$1 ? s$1 : {}).constants && this._setOverrides(s$1.constants, r$1), this._execStatements(this.ast, r$1);
		const a$1 = r$1.getFunction(e$2);
		if (!a$1) return void console.error(`Function ${e$2} not found`);
		if ("number" == typeof t$1) t$1 = [
			t$1,
			1,
			1
		];
		else {
			if (0 === t$1.length) return void console.error("Invalid dispatch count");
			1 === t$1.length ? t$1 = [
				t$1[0],
				1,
				1
			] : 2 === t$1.length ? t$1 = [
				t$1[0],
				t$1[1],
				1
			] : t$1.length > 3 && (t$1 = [
				t$1[0],
				t$1[1],
				t$1[2]
			]);
		}
		const i$1 = t$1[0], o$1 = t$1[1], c$1 = t$1[2], l$1 = this.getTypeInfo("vec3u");
		r$1.setVariable("@num_workgroups", new Me(t$1, l$1));
		const u$1 = this.reflection.getFunctionInfo(e$2);
		null === u$1 && console.error(`Function ${e$2} not found in reflection data`);
		for (const e$3 in n$1) for (const t$2 in n$1[e$3]) {
			const s$2 = n$1[e$3][t$2];
			r$1.variables.forEach((n$2) => {
				var r$2;
				const a$2 = n$2.node;
				if (null == a$2 ? void 0 : a$2.attributes) {
					let i$2 = null, o$2 = null;
					for (const e$4 of a$2.attributes) "binding" === e$4.name ? i$2 = e$4.value : "group" === e$4.name && (o$2 = e$4.value);
					if (t$2 == i$2 && e$3 == o$2) {
						let i$3 = !1;
						for (const s$3 of u$1.resources) if (s$3.name === n$2.name && s$3.group === parseInt(e$3) && s$3.binding === parseInt(t$2)) {
							i$3 = !0;
							break;
						}
						if (i$3) if (void 0 !== s$2.texture && void 0 !== s$2.descriptor) n$2.value = new We(s$2.texture, this.getTypeInfo(a$2.type), s$2.descriptor, null !== (r$2 = s$2.texture.view) && void 0 !== r$2 ? r$2 : null);
						else void 0 !== s$2.uniform ? n$2.value = new Pe(s$2.uniform, this.getTypeInfo(a$2.type)) : n$2.value = new Pe(s$2, this.getTypeInfo(a$2.type));
					}
				}
			});
		}
		for (let e$3 = 0; e$3 < c$1; ++e$3) for (let t$2 = 0; t$2 < o$1; ++t$2) for (let n$2 = 0; n$2 < i$1; ++n$2) r$1.setVariable("@workgroup_id", new Me([
			n$2,
			t$2,
			e$3
		], this.getTypeInfo("vec3u"))), this._dispatchWorkgroup(a$1, [
			n$2,
			t$2,
			e$3
		], r$1);
	}
	execStatement(e$2, t$1) {
		if (e$2 instanceof Y) return this.evalExpression(e$2.value, t$1);
		if (e$2 instanceof se) {
			if (e$2.condition) {
				const n$1 = this.evalExpression(e$2.condition, t$1);
				if (!(n$1 instanceof Be)) throw new Error("Invalid break-if condition");
				if (!n$1.value) return null;
			}
			return dt._breakObj;
		}
		if (e$2 instanceof re) return dt._continueObj;
		if (e$2 instanceof U) this._let(e$2, t$1);
		else if (e$2 instanceof F) this._var(e$2, t$1);
		else if (e$2 instanceof P) this._const(e$2, t$1);
		else if (e$2 instanceof D) this._function(e$2, t$1);
		else {
			if (e$2 instanceof Q) return this._if(e$2, t$1);
			if (e$2 instanceof Z) return this._switch(e$2, t$1);
			if (e$2 instanceof B) return this._for(e$2, t$1);
			if (e$2 instanceof V) return this._while(e$2, t$1);
			if (e$2 instanceof j) return this._loop(e$2, t$1);
			if (e$2 instanceof O) {
				const n$1 = t$1.clone();
				return n$1.currentFunctionName = t$1.currentFunctionName, this._execStatements(e$2.body, n$1);
			}
			if (e$2 instanceof G) this._assign(e$2, t$1);
			else if (e$2 instanceof R) this._increment(e$2, t$1);
			else {
				if (e$2 instanceof oe) return null;
				if (e$2 instanceof M) {
					const n$1 = e$2.name;
					null === t$1.getVariable(n$1) && t$1.setVariable(n$1, new Be(0, this.getTypeInfo("u32")));
				} else if (e$2 instanceof X) this._call(e$2, t$1);
				else {
					if (e$2 instanceof ee) return null;
					if (e$2 instanceof te) return null;
					console.error("Invalid statement type.", e$2, `Line ${e$2.line}`);
				}
			}
		}
		return null;
	}
	evalExpression(e$2, t$1) {
		return e$2 instanceof Ie ? this._evalBinaryOp(e$2, t$1) : e$2 instanceof xe ? this._evalLiteral(e$2, t$1) : e$2 instanceof ge ? this._evalVariable(e$2, t$1) : e$2 instanceof me ? this._evalCall(e$2, t$1) : e$2 instanceof de ? this._evalCreate(e$2, t$1) : e$2 instanceof _e ? this._evalConst(e$2, t$1) : e$2 instanceof ye ? this._evalBitcast(e$2, t$1) : e$2 instanceof ke ? this._evalUnaryOp(e$2, t$1) : (console.error("Invalid expression type", e$2, `Line ${e$2.line}`), null);
	}
	getTypeInfo(e$2) {
		var t$1;
		if (e$2 instanceof ae) {
			const t$2 = this.reflection.getTypeInfo(e$2);
			if (null !== t$2) return t$2;
		}
		let n$1 = null !== (t$1 = this.typeInfo[e$2]) && void 0 !== t$1 ? t$1 : null;
		return null !== n$1 || (n$1 = this.reflection.getTypeInfoByName(e$2)), n$1;
	}
	_setOverrides(e$2, t$1) {
		for (const n$1 in e$2) {
			const s$1 = e$2[n$1], r$1 = this.reflection.getOverrideInfo(n$1);
			null !== r$1 ? (null === r$1.type && (r$1.type = this.getTypeInfo("u32")), "u32" === r$1.type.name || "i32" === r$1.type.name || "f32" === r$1.type.name || "f16" === r$1.type.name ? t$1.setVariable(n$1, new Be(s$1, r$1.type)) : "bool" === r$1.type.name ? t$1.setVariable(n$1, new Be(s$1 ? 1 : 0, r$1.type)) : "vec2" === r$1.type.name || "vec3" === r$1.type.name || "vec4" === r$1.type.name || "vec2f" === r$1.type.name || "vec3f" === r$1.type.name || "vec4f" === r$1.type.name || "vec2i" === r$1.type.name || "vec3i" === r$1.type.name || "vec4i" === r$1.type.name || "vec2u" === r$1.type.name || "vec3u" === r$1.type.name || "vec4u" === r$1.type.name || "vec2h" === r$1.type.name || "vec3h" === r$1.type.name || "vec4h" === r$1.type.name ? t$1.setVariable(n$1, new Me(s$1, r$1.type)) : console.error(`Invalid constant type for ${n$1}`)) : console.error(`Override ${n$1} does not exist in the shader.`);
		}
	}
	_dispatchWorkgroup(e$2, t$1, n$1) {
		const s$1 = [
			1,
			1,
			1
		];
		for (const t$2 of e$2.node.attributes) if ("workgroup_size" === t$2.name) {
			if (t$2.value.length > 0) {
				const e$3 = n$1.getVariableValue(t$2.value[0]);
				s$1[0] = e$3 instanceof Be ? e$3.value : parseInt(t$2.value[0]);
			}
			if (t$2.value.length > 1) {
				const e$3 = n$1.getVariableValue(t$2.value[1]);
				s$1[1] = e$3 instanceof Be ? e$3.value : parseInt(t$2.value[1]);
			}
			if (t$2.value.length > 2) {
				const e$3 = n$1.getVariableValue(t$2.value[2]);
				s$1[2] = e$3 instanceof Be ? e$3.value : parseInt(t$2.value[2]);
			}
		}
		const r$1 = this.getTypeInfo("vec3u"), a$1 = this.getTypeInfo("u32");
		n$1.setVariable("@workgroup_size", new Me(s$1, r$1));
		const i$1 = s$1[0], o$1 = s$1[1], c$1 = s$1[2];
		for (let l$1 = 0, u$1 = 0; l$1 < c$1; ++l$1) for (let c$2 = 0; c$2 < o$1; ++c$2) for (let o$2 = 0; o$2 < i$1; ++o$2, ++u$1) {
			const i$2 = [
				o$2,
				c$2,
				l$1
			], h$1 = [
				o$2 + t$1[0] * s$1[0],
				c$2 + t$1[1] * s$1[1],
				l$1 + t$1[2] * s$1[2]
			];
			n$1.setVariable("@local_invocation_id", new Me(i$2, r$1)), n$1.setVariable("@global_invocation_id", new Me(h$1, r$1)), n$1.setVariable("@local_invocation_index", new Be(u$1, a$1)), this._dispatchExec(e$2, n$1);
		}
	}
	_dispatchExec(e$2, t$1) {
		for (const n$1 of e$2.node.args) for (const e$3 of n$1.attributes) if ("builtin" === e$3.name) {
			const s$1 = `@${e$3.value}`, r$1 = t$1.getVariable(s$1);
			void 0 !== r$1 && t$1.variables.set(n$1.name, r$1);
		}
		this._execStatements(e$2.node.body, t$1);
	}
	getVariableName(e$2, t$1) {
		for (; e$2 instanceof ke;) e$2 = e$2.right;
		return e$2 instanceof ge ? e$2.name : (console.error("Unknown variable type", e$2, "Line", e$2.line), null);
	}
	_execStatements(e$2, t$1) {
		for (const n$1 of e$2) {
			if (n$1 instanceof Array) {
				const e$4 = t$1.clone(), s$1 = this._execStatements(n$1, e$4);
				if (s$1) return s$1;
				continue;
			}
			const e$3 = this.execStatement(n$1, t$1);
			if (e$3) return e$3;
		}
		return null;
	}
	_call(e$2, t$1) {
		const n$1 = t$1.clone();
		n$1.currentFunctionName = e$2.name;
		const s$1 = t$1.getFunction(e$2.name);
		if (s$1) {
			for (let t$2 = 0; t$2 < s$1.node.args.length; ++t$2) {
				const r$1 = s$1.node.args[t$2], a$1 = this.evalExpression(e$2.args[t$2], n$1);
				n$1.setVariable(r$1.name, a$1, r$1);
			}
			this._execStatements(s$1.node.body, n$1);
		} else if (e$2.isBuiltin) this._callBuiltinFunction(e$2, n$1);
		else this.getTypeInfo(e$2.name) && this._evalCreate(e$2, t$1);
	}
	_increment(e$2, t$1) {
		const n$1 = this.getVariableName(e$2.variable, t$1), s$1 = t$1.getVariable(n$1);
		s$1 ? "++" === e$2.operator ? s$1.value instanceof Be ? s$1.value.value++ : console.error(`Variable ${n$1} is not a scalar. Line ${e$2.line}`) : "--" === e$2.operator ? s$1.value instanceof Be ? s$1.value.value-- : console.error(`Variable ${n$1} is not a scalar. Line ${e$2.line}`) : console.error(`Unknown increment operator ${e$2.operator}. Line ${e$2.line}`) : console.error(`Variable ${n$1} not found. Line ${e$2.line}`);
	}
	_getVariableData(e$2, t$1) {
		if (e$2 instanceof ge) {
			const n$1 = this.getVariableName(e$2, t$1), s$1 = t$1.getVariable(n$1);
			return null === s$1 ? (console.error(`Variable ${n$1} not found. Line ${e$2.line}`), null) : s$1.value.getSubData(this, e$2.postfix, t$1);
		}
		if (e$2 instanceof ke) {
			if ("*" === e$2.operator) {
				const n$1 = this._getVariableData(e$2.right, t$1);
				return n$1 instanceof Oe ? n$1.reference.getSubData(this, e$2.postfix, t$1) : (console.error(`Variable ${e$2.right} is not a pointer. Line ${e$2.line}`), null);
			}
			if ("&" === e$2.operator) return new Oe(this._getVariableData(e$2.right, t$1));
		}
		return null;
	}
	_assign(e$2, t$1) {
		let n$1 = null, s$1 = "<var>", r$1 = null;
		if (e$2.variable instanceof ke) {
			const n$2 = this._getVariableData(e$2.variable, t$1), s$2 = this.evalExpression(e$2.value, t$1), r$2 = e$2.operator;
			if ("=" === r$2) {
				if (n$2 instanceof Be || n$2 instanceof Me || n$2 instanceof Ue) {
					if (s$2 instanceof Be || s$2 instanceof Me || s$2 instanceof Ue && n$2.data.length === s$2.data.length) return void n$2.data.set(s$2.data);
					console.error(`Invalid assignment. Line ${e$2.line}`);
				} else if (n$2 instanceof Pe && s$2 instanceof Pe && n$2.buffer.byteLength - n$2.offset >= s$2.buffer.byteLength - s$2.offset) return void (n$2.buffer.byteLength % 4 == 0 ? new Uint32Array(n$2.buffer, n$2.offset, n$2.typeInfo.size / 4).set(new Uint32Array(s$2.buffer, s$2.offset, s$2.typeInfo.size / 4)) : new Uint8Array(n$2.buffer, n$2.offset, n$2.typeInfo.size).set(new Uint8Array(s$2.buffer, s$2.offset, s$2.typeInfo.size)));
				return console.error(`Invalid assignment. Line ${e$2.line}`), null;
			}
			if ("+=" === r$2) return n$2 instanceof Be || n$2 instanceof Me || n$2 instanceof Ue ? s$2 instanceof Be || s$2 instanceof Me || s$2 instanceof Ue ? void n$2.data.set(s$2.data.map((e$3, t$2) => n$2.data[t$2] + e$3)) : void console.error(`Invalid assignment . Line ${e$2.line}`) : void console.error(`Invalid assignment. Line ${e$2.line}`);
			if ("-=" === r$2) return (n$2 instanceof Be || n$2 instanceof Me || n$2 instanceof Ue) && (s$2 instanceof Be || s$2 instanceof Me || s$2 instanceof Ue) ? void n$2.data.set(s$2.data.map((e$3, t$2) => n$2.data[t$2] - e$3)) : void console.error(`Invalid assignment. Line ${e$2.line}`);
		}
		if (e$2.variable instanceof ke) {
			if ("*" === e$2.variable.operator) {
				s$1 = this.getVariableName(e$2.variable.right, t$1);
				const r$2 = t$1.getVariable(s$1);
				if (!(r$2 && r$2.value instanceof Oe)) return void console.error(`Variable ${s$1} is not a pointer. Line ${e$2.line}`);
				n$1 = r$2.value.reference;
				let a$2 = e$2.variable.postfix;
				if (!a$2) {
					let t$2 = e$2.variable.right;
					for (; t$2 instanceof ke;) {
						if (t$2.postfix) {
							a$2 = t$2.postfix;
							break;
						}
						t$2 = t$2.right;
					}
				}
				a$2 && (n$1 = n$1.getSubData(this, a$2, t$1));
			}
		} else {
			r$1 = e$2.variable.postfix, s$1 = this.getVariableName(e$2.variable, t$1);
			const a$2 = t$1.getVariable(s$1);
			if (null === a$2) return void console.error(`Variable ${s$1} not found. Line ${e$2.line}`);
			n$1 = a$2.value;
		}
		if (n$1 instanceof Oe && (n$1 = n$1.reference), null === n$1) return void console.error(`Variable ${s$1} not found. Line ${e$2.line}`);
		const a$1 = this.evalExpression(e$2.value, t$1), i$1 = e$2.operator;
		if ("=" !== i$1) {
			const s$2 = n$1.getSubData(this, r$1, t$1);
			if (s$2 instanceof Me && a$1 instanceof Be) {
				const t$2 = s$2.data, n$2 = a$1.value;
				if ("+=" === i$1) for (let e$3 = 0; e$3 < t$2.length; ++e$3) t$2[e$3] += n$2;
				else if ("-=" === i$1) for (let e$3 = 0; e$3 < t$2.length; ++e$3) t$2[e$3] -= n$2;
				else if ("*=" === i$1) for (let e$3 = 0; e$3 < t$2.length; ++e$3) t$2[e$3] *= n$2;
				else if ("/=" === i$1) for (let e$3 = 0; e$3 < t$2.length; ++e$3) t$2[e$3] /= n$2;
				else if ("%=" === i$1) for (let e$3 = 0; e$3 < t$2.length; ++e$3) t$2[e$3] %= n$2;
				else if ("&=" === i$1) for (let e$3 = 0; e$3 < t$2.length; ++e$3) t$2[e$3] &= n$2;
				else if ("|=" === i$1) for (let e$3 = 0; e$3 < t$2.length; ++e$3) t$2[e$3] |= n$2;
				else if ("^=" === i$1) for (let e$3 = 0; e$3 < t$2.length; ++e$3) t$2[e$3] ^= n$2;
				else if ("<<=" === i$1) for (let e$3 = 0; e$3 < t$2.length; ++e$3) t$2[e$3] <<= n$2;
				else if (">>=" === i$1) for (let e$3 = 0; e$3 < t$2.length; ++e$3) t$2[e$3] >>= n$2;
				else console.error(`Invalid operator ${i$1}. Line ${e$2.line}`);
			} else if (s$2 instanceof Me && a$1 instanceof Me) {
				const t$2 = s$2.data, n$2 = a$1.data;
				if (t$2.length !== n$2.length) return void console.error(`Vector length mismatch. Line ${e$2.line}`);
				if ("+=" === i$1) for (let e$3 = 0; e$3 < t$2.length; ++e$3) t$2[e$3] += n$2[e$3];
				else if ("-=" === i$1) for (let e$3 = 0; e$3 < t$2.length; ++e$3) t$2[e$3] -= n$2[e$3];
				else if ("*=" === i$1) for (let e$3 = 0; e$3 < t$2.length; ++e$3) t$2[e$3] *= n$2[e$3];
				else if ("/=" === i$1) for (let e$3 = 0; e$3 < t$2.length; ++e$3) t$2[e$3] /= n$2[e$3];
				else if ("%=" === i$1) for (let e$3 = 0; e$3 < t$2.length; ++e$3) t$2[e$3] %= n$2[e$3];
				else if ("&=" === i$1) for (let e$3 = 0; e$3 < t$2.length; ++e$3) t$2[e$3] &= n$2[e$3];
				else if ("|=" === i$1) for (let e$3 = 0; e$3 < t$2.length; ++e$3) t$2[e$3] |= n$2[e$3];
				else if ("^=" === i$1) for (let e$3 = 0; e$3 < t$2.length; ++e$3) t$2[e$3] ^= n$2[e$3];
				else if ("<<=" === i$1) for (let e$3 = 0; e$3 < t$2.length; ++e$3) t$2[e$3] <<= n$2[e$3];
				else if (">>=" === i$1) for (let e$3 = 0; e$3 < t$2.length; ++e$3) t$2[e$3] >>= n$2[e$3];
				else console.error(`Invalid operator ${i$1}. Line ${e$2.line}`);
			} else {
				if (!(s$2 instanceof Be && a$1 instanceof Be)) return void console.error(`Invalid type for ${e$2.operator} operator. Line ${e$2.line}`);
				"+=" === i$1 ? s$2.value += a$1.value : "-=" === i$1 ? s$2.value -= a$1.value : "*=" === i$1 ? s$2.value *= a$1.value : "/=" === i$1 ? s$2.value /= a$1.value : "%=" === i$1 ? s$2.value %= a$1.value : "&=" === i$1 ? s$2.value &= a$1.value : "|=" === i$1 ? s$2.value |= a$1.value : "^=" === i$1 ? s$2.value ^= a$1.value : "<<=" === i$1 ? s$2.value <<= a$1.value : ">>=" === i$1 ? s$2.value >>= a$1.value : console.error(`Invalid operator ${i$1}. Line ${e$2.line}`);
			}
			n$1 instanceof Pe && n$1.setDataValue(this, s$2, r$1, t$1);
			return;
		}
		if (n$1 instanceof Pe) n$1.setDataValue(this, a$1, r$1, t$1);
		else if (r$1) {
			if (!(n$1 instanceof Me || n$1 instanceof Ue)) return void console.error(`Variable ${s$1} is not a vector or matrix. Line ${e$2.line}`);
			if (r$1 instanceof ve) {
				const i$2 = this.evalExpression(r$1.index, t$1).value;
				if (n$1 instanceof Me) {
					if (!(a$1 instanceof Be)) return void console.error(`Invalid assignment to ${s$1}. Line ${e$2.line}`);
					n$1.data[i$2] = a$1.value;
				} else {
					if (!(n$1 instanceof Ue)) return void console.error(`Invalid assignment to ${s$1}. Line ${e$2.line}`);
					{
						const i$3 = this.evalExpression(r$1.index, t$1).value;
						if (i$3 < 0) return void console.error(`Invalid assignment to ${s$1}. Line ${e$2.line}`);
						if (!(a$1 instanceof Me)) return void console.error(`Invalid assignment to ${s$1}. Line ${e$2.line}`);
						{
							const t$2 = n$1.typeInfo.getTypeName();
							if ("mat2x2" === t$2 || "mat2x2f" === t$2 || "mat2x2h" === t$2) {
								if (!(i$3 < 2 && 2 === a$1.data.length)) return void console.error(`Invalid assignment to ${s$1}. Line ${e$2.line}`);
								n$1.data[2 * i$3] = a$1.data[0], n$1.data[2 * i$3 + 1] = a$1.data[1];
							} else if ("mat2x3" === t$2 || "mat2x3f" === t$2 || "mat2x3h" === t$2) {
								if (!(i$3 < 2 && 3 === a$1.data.length)) return void console.error(`Invalid assignment to ${s$1}. Line ${e$2.line}`);
								n$1.data[3 * i$3] = a$1.data[0], n$1.data[3 * i$3 + 1] = a$1.data[1], n$1.data[3 * i$3 + 2] = a$1.data[2];
							} else if ("mat2x4" === t$2 || "mat2x4f" === t$2 || "mat2x4h" === t$2) {
								if (!(i$3 < 2 && 4 === a$1.data.length)) return void console.error(`Invalid assignment to ${s$1}. Line ${e$2.line}`);
								n$1.data[4 * i$3] = a$1.data[0], n$1.data[4 * i$3 + 1] = a$1.data[1], n$1.data[4 * i$3 + 2] = a$1.data[2], n$1.data[4 * i$3 + 3] = a$1.data[3];
							} else if ("mat3x2" === t$2 || "mat3x2f" === t$2 || "mat3x2h" === t$2) {
								if (!(i$3 < 3 && 2 === a$1.data.length)) return void console.error(`Invalid assignment to ${s$1}. Line ${e$2.line}`);
								n$1.data[2 * i$3] = a$1.data[0], n$1.data[2 * i$3 + 1] = a$1.data[1];
							} else if ("mat3x3" === t$2 || "mat3x3f" === t$2 || "mat3x3h" === t$2) {
								if (!(i$3 < 3 && 3 === a$1.data.length)) return void console.error(`Invalid assignment to ${s$1}. Line ${e$2.line}`);
								n$1.data[3 * i$3] = a$1.data[0], n$1.data[3 * i$3 + 1] = a$1.data[1], n$1.data[3 * i$3 + 2] = a$1.data[2];
							} else if ("mat3x4" === t$2 || "mat3x4f" === t$2 || "mat3x4h" === t$2) {
								if (!(i$3 < 3 && 4 === a$1.data.length)) return void console.error(`Invalid assignment to ${s$1}. Line ${e$2.line}`);
								n$1.data[4 * i$3] = a$1.data[0], n$1.data[4 * i$3 + 1] = a$1.data[1], n$1.data[4 * i$3 + 2] = a$1.data[2], n$1.data[4 * i$3 + 3] = a$1.data[3];
							} else if ("mat4x2" === t$2 || "mat4x2f" === t$2 || "mat4x2h" === t$2) {
								if (!(i$3 < 4 && 2 === a$1.data.length)) return void console.error(`Invalid assignment to ${s$1}. Line ${e$2.line}`);
								n$1.data[2 * i$3] = a$1.data[0], n$1.data[2 * i$3 + 1] = a$1.data[1];
							} else if ("mat4x3" === t$2 || "mat4x3f" === t$2 || "mat4x3h" === t$2) {
								if (!(i$3 < 4 && 3 === a$1.data.length)) return void console.error(`Invalid assignment to ${s$1}. Line ${e$2.line}`);
								n$1.data[3 * i$3] = a$1.data[0], n$1.data[3 * i$3 + 1] = a$1.data[1], n$1.data[3 * i$3 + 2] = a$1.data[2];
							} else {
								if ("mat4x4" !== t$2 && "mat4x4f" !== t$2 && "mat4x4h" !== t$2) return void console.error(`Invalid assignment to ${s$1}. Line ${e$2.line}`);
								if (!(i$3 < 4 && 4 === a$1.data.length)) return void console.error(`Invalid assignment to ${s$1}. Line ${e$2.line}`);
								n$1.data[4 * i$3] = a$1.data[0], n$1.data[4 * i$3 + 1] = a$1.data[1], n$1.data[4 * i$3 + 2] = a$1.data[2], n$1.data[4 * i$3 + 3] = a$1.data[3];
							}
						}
					}
				}
			} else if (r$1 instanceof pe) {
				const t$2 = r$1.value;
				if (!(n$1 instanceof Me)) return void console.error(`Invalid assignment to ${t$2}. Variable ${s$1} is not a vector. Line ${e$2.line}`);
				if (a$1 instanceof Be) {
					if (t$2.length > 1) return void console.error(`Invalid assignment to ${t$2} for variable ${s$1}. Line ${e$2.line}`);
					if ("x" === t$2) n$1.data[0] = a$1.value;
					else if ("y" === t$2) {
						if (n$1.data.length < 2) return void console.error(`Invalid assignment to ${t$2} for variable ${s$1}. Line ${e$2.line}`);
						n$1.data[1] = a$1.value;
					} else if ("z" === t$2) {
						if (n$1.data.length < 3) return void console.error(`Invalid assignment to ${t$2} for variable ${s$1}. Line ${e$2.line}`);
						n$1.data[2] = a$1.value;
					} else if ("w" === t$2) {
						if (n$1.data.length < 4) return void console.error(`Invalid assignment to ${t$2} for variable ${s$1}. Line ${e$2.line}`);
						n$1.data[3] = a$1.value;
					}
				} else {
					if (!(a$1 instanceof Me)) return void console.error(`Invalid assignment to ${s$1}. Line ${e$2.line}`);
					if (t$2.length !== a$1.data.length) return void console.error(`Invalid assignment to ${t$2} for variable ${s$1}. Line ${e$2.line}`);
					for (let r$2 = 0; r$2 < t$2.length; ++r$2) {
						const i$2 = t$2[r$2];
						if ("x" === i$2 || "r" === i$2) n$1.data[0] = a$1.data[r$2];
						else if ("y" === i$2 || "g" === i$2) {
							if (a$1.data.length < 2) return void console.error(`Invalid assignment to ${i$2} for variable ${s$1}. Line ${e$2.line}`);
							n$1.data[1] = a$1.data[r$2];
						} else if ("z" === i$2 || "b" === i$2) {
							if (a$1.data.length < 3) return void console.error(`Invalid assignment to ${i$2} for variable ${s$1}. Line ${e$2.line}`);
							n$1.data[2] = a$1.data[r$2];
						} else {
							if ("w" !== i$2 && "a" !== i$2) return void console.error(`Invalid assignment to ${i$2} for variable ${s$1}. Line ${e$2.line}`);
							if (a$1.data.length < 4) return void console.error(`Invalid assignment to ${i$2} for variable ${s$1}. Line ${e$2.line}`);
							n$1.data[3] = a$1.data[r$2];
						}
					}
				}
			}
		} else n$1 instanceof Be && a$1 instanceof Be ? n$1.value = a$1.value : n$1 instanceof Me && a$1 instanceof Me || n$1 instanceof Ue && a$1 instanceof Ue ? n$1.data.set(a$1.data) : console.error(`Invalid assignment to ${s$1}. Line ${e$2.line}`);
	}
	_function(e$2, t$1) {
		const n$1 = new ct(e$2);
		t$1.functions.set(e$2.name, n$1);
	}
	_const(e$2, t$1) {
		let n$1 = null;
		null !== e$2.value && (n$1 = this.evalExpression(e$2.value, t$1)), t$1.createVariable(e$2.name, n$1, e$2);
	}
	_let(e$2, t$1) {
		let n$1 = null;
		if (null !== e$2.value) {
			if (n$1 = this.evalExpression(e$2.value, t$1), null === n$1) return void console.error(`Invalid value for variable ${e$2.name}. Line ${e$2.line}`);
			e$2.value instanceof ke || (n$1 = n$1.clone());
		} else {
			const s$1 = e$2.type.name;
			if ("f32" === s$1 || "i32" === s$1 || "u32" === s$1 || "bool" === s$1 || "f16" === s$1 || "vec2" === s$1 || "vec3" === s$1 || "vec4" === s$1 || "vec2f" === s$1 || "vec3f" === s$1 || "vec4f" === s$1 || "vec2i" === s$1 || "vec3i" === s$1 || "vec4i" === s$1 || "vec2u" === s$1 || "vec3u" === s$1 || "vec4u" === s$1 || "vec2h" === s$1 || "vec3h" === s$1 || "vec4h" === s$1 || "vec2b" === s$1 || "vec3b" === s$1 || "vec4b" === s$1 || "mat2x2" === s$1 || "mat2x3" === s$1 || "mat2x4" === s$1 || "mat3x2" === s$1 || "mat3x3" === s$1 || "mat3x4" === s$1 || "mat4x2" === s$1 || "mat4x3" === s$1 || "mat4x4" === s$1 || "mat2x2f" === s$1 || "mat2x3f" === s$1 || "mat2x4f" === s$1 || "mat3x2f" === s$1 || "mat3x3f" === s$1 || "mat3x4f" === s$1 || "mat4x2f" === s$1 || "mat4x3f" === s$1 || "mat4x4f" === s$1 || "mat2x2h" === s$1 || "mat2x3h" === s$1 || "mat2x4h" === s$1 || "mat3x2h" === s$1 || "mat3x3h" === s$1 || "mat3x4h" === s$1 || "mat4x2h" === s$1 || "mat4x3h" === s$1 || "mat4x4h" === s$1 || "array" === s$1) {
				const s$2 = new de(e$2.type, []);
				n$1 = this._evalCreate(s$2, t$1);
			}
		}
		t$1.createVariable(e$2.name, n$1, e$2);
	}
	_var(e$2, t$1) {
		let n$1 = null;
		if (null !== e$2.value) {
			if (n$1 = this.evalExpression(e$2.value, t$1), null === n$1) return void console.error(`Invalid value for variable ${e$2.name}. Line ${e$2.line}`);
			e$2.value instanceof ke || (n$1 = n$1.clone());
		} else {
			if (null === e$2.type) return void console.error(`Variable ${e$2.name} has no type. Line ${e$2.line}`);
			const s$1 = e$2.type.name;
			if ("f32" === s$1 || "i32" === s$1 || "u32" === s$1 || "bool" === s$1 || "f16" === s$1 || "vec2" === s$1 || "vec3" === s$1 || "vec4" === s$1 || "vec2f" === s$1 || "vec3f" === s$1 || "vec4f" === s$1 || "vec2i" === s$1 || "vec3i" === s$1 || "vec4i" === s$1 || "vec2u" === s$1 || "vec3u" === s$1 || "vec4u" === s$1 || "vec2h" === s$1 || "vec3h" === s$1 || "vec4h" === s$1 || "vec2b" === s$1 || "vec3b" === s$1 || "vec4b" === s$1 || "mat2x2" === s$1 || "mat2x3" === s$1 || "mat2x4" === s$1 || "mat3x2" === s$1 || "mat3x3" === s$1 || "mat3x4" === s$1 || "mat4x2" === s$1 || "mat4x3" === s$1 || "mat4x4" === s$1 || "mat2x2f" === s$1 || "mat2x3f" === s$1 || "mat2x4f" === s$1 || "mat3x2f" === s$1 || "mat3x3f" === s$1 || "mat3x4f" === s$1 || "mat4x2f" === s$1 || "mat4x3f" === s$1 || "mat4x4f" === s$1 || "mat2x2h" === s$1 || "mat2x3h" === s$1 || "mat2x4h" === s$1 || "mat3x2h" === s$1 || "mat3x3h" === s$1 || "mat3x4h" === s$1 || "mat4x2h" === s$1 || "mat4x3h" === s$1 || "mat4x4h" === s$1 || e$2.type instanceof ue || e$2.type instanceof oe || e$2.type instanceof ce) {
				const s$2 = new de(e$2.type, []);
				n$1 = this._evalCreate(s$2, t$1);
			}
		}
		t$1.createVariable(e$2.name, n$1, e$2);
	}
	_switch(e$2, t$1) {
		t$1 = t$1.clone();
		const n$1 = this.evalExpression(e$2.condition, t$1);
		if (!(n$1 instanceof Be)) return console.error(`Invalid if condition. Line ${e$2.line}`), null;
		let s$1 = null;
		for (const r$1 of e$2.cases) if (r$1 instanceof Ae) for (const a$1 of r$1.selectors) {
			if (a$1 instanceof Se) {
				s$1 = r$1;
				continue;
			}
			const i$1 = this.evalExpression(a$1, t$1);
			if (!(i$1 instanceof Be)) return console.error(`Invalid case selector. Line ${e$2.line}`), null;
			if (i$1.value === n$1.value) return this._execStatements(r$1.body, t$1);
		}
		else r$1 instanceof Ee && (s$1 = r$1);
		return s$1 ? this._execStatements(s$1.body, t$1) : null;
	}
	_if(e$2, t$1) {
		t$1 = t$1.clone();
		const n$1 = this.evalExpression(e$2.condition, t$1);
		if (!(n$1 instanceof Be)) return console.error(`Invalid if condition. Line ${e$2.line}`), null;
		if (n$1.value) return this._execStatements(e$2.body, t$1);
		for (const n$2 of e$2.elseif) {
			const s$1 = this.evalExpression(n$2.condition, t$1);
			if (!(s$1 instanceof Be)) return console.error(`Invalid if condition. Line ${e$2.line}`), null;
			if (s$1.value) return this._execStatements(n$2.body, t$1);
		}
		return e$2.else ? this._execStatements(e$2.else, t$1) : null;
	}
	_getScalarValue(e$2) {
		return e$2 instanceof Be ? e$2.value : (console.error("Expected scalar value.", e$2), 0);
	}
	_for(e$2, t$1) {
		for (t$1 = t$1.clone(), this.execStatement(e$2.init, t$1); this._getScalarValue(this.evalExpression(e$2.condition, t$1));) {
			const n$1 = this._execStatements(e$2.body, t$1);
			if (n$1 === dt._breakObj) break;
			if (null !== n$1 && n$1 !== dt._continueObj) return n$1;
			this.execStatement(e$2.increment, t$1);
		}
		return null;
	}
	_loop(e$2, t$1) {
		for (t$1 = t$1.clone();;) {
			const n$1 = this._execStatements(e$2.body, t$1);
			if (n$1 === dt._breakObj) break;
			if (n$1 === dt._continueObj) {
				if (e$2.continuing) {
					if (this._execStatements(e$2.continuing.body, t$1) === dt._breakObj) break;
				}
			} else if (null !== n$1) return n$1;
		}
		return null;
	}
	_while(e$2, t$1) {
		for (t$1 = t$1.clone(); this._getScalarValue(this.evalExpression(e$2.condition, t$1));) {
			const n$1 = this._execStatements(e$2.body, t$1);
			if (n$1 === dt._breakObj) break;
			if (n$1 !== dt._continueObj && null !== n$1) return n$1;
		}
		return null;
	}
	_evalBitcast(e$2, t$1) {
		const n$1 = this.evalExpression(e$2.value, t$1), s$1 = e$2.type;
		if (n$1 instanceof Be) return new Be(nt(n$1.value, n$1.typeInfo.name, s$1.name), this.getTypeInfo(s$1));
		if (n$1 instanceof Me) {
			const t$2 = n$1.typeInfo.getTypeName();
			let r$1 = "";
			if (t$2.endsWith("f")) r$1 = "f32";
			else if (t$2.endsWith("i")) r$1 = "i32";
			else if (t$2.endsWith("u")) r$1 = "u32";
			else if (t$2.endsWith("b")) r$1 = "bool";
			else {
				if (!t$2.endsWith("h")) return console.error(`Unknown vector type ${t$2}. Line ${e$2.line}`), null;
				r$1 = "f16";
			}
			const a$1 = s$1.getTypeName();
			let i$1 = "";
			if (a$1.endsWith("f")) i$1 = "f32";
			else if (a$1.endsWith("i")) i$1 = "i32";
			else if (a$1.endsWith("u")) i$1 = "u32";
			else if (a$1.endsWith("b")) i$1 = "bool";
			else {
				if (!a$1.endsWith("h")) return console.error(`Unknown vector type ${i$1}. Line ${e$2.line}`), null;
				i$1 = "f16";
			}
			return new Me(function(e$3, t$3, n$2) {
				if (t$3 === n$2) return e$3;
				const s$2 = new Array(e$3.length);
				for (let r$2 = 0; r$2 < e$3.length; r$2++) s$2[r$2] = nt(e$3[r$2], t$3, n$2);
				return s$2;
			}(Array.from(n$1.data), r$1, i$1), this.getTypeInfo(s$1));
		}
		return console.error(`TODO: bitcast for ${n$1.typeInfo.name}. Line ${e$2.line}`), null;
	}
	_evalConst(e$2, t$1) {
		return t$1.getVariableValue(e$2.name).clone().getSubData(this, e$2.postfix, t$1);
	}
	_evalCreate(e$2, t$1) {
		var r$1;
		if (e$2 instanceof de) {
			if (null === e$2.type) return Ve.void;
			switch (e$2.type.getTypeName()) {
				case "bool":
				case "i32":
				case "u32":
				case "f32":
				case "f16": return this._callConstructorValue(e$2, t$1);
				case "vec2":
				case "vec3":
				case "vec4":
				case "vec2f":
				case "vec3f":
				case "vec4f":
				case "vec2h":
				case "vec3h":
				case "vec4h":
				case "vec2i":
				case "vec3i":
				case "vec4i":
				case "vec2u":
				case "vec3u":
				case "vec4u":
				case "vec2b":
				case "vec3b":
				case "vec4b": return this._callConstructorVec(e$2, t$1);
				case "mat2x2":
				case "mat2x2f":
				case "mat2x2h":
				case "mat2x3":
				case "mat2x3f":
				case "mat2x3h":
				case "mat2x4":
				case "mat2x4f":
				case "mat2x4h":
				case "mat3x2":
				case "mat3x2f":
				case "mat3x2h":
				case "mat3x3":
				case "mat3x3f":
				case "mat3x3h":
				case "mat3x4":
				case "mat3x4f":
				case "mat3x4h":
				case "mat4x2":
				case "mat4x2f":
				case "mat4x2h":
				case "mat4x3":
				case "mat4x3f":
				case "mat4x3h":
				case "mat4x4":
				case "mat4x4f":
				case "mat4x4h": return this._callConstructorMatrix(e$2, t$1);
			}
		}
		const a$1 = e$2 instanceof de ? e$2.type.name : e$2.name, i$1 = e$2 instanceof de ? this.getTypeInfo(e$2.type) : this.getTypeInfo(e$2.name);
		if (null === i$1) return console.error(`Unknown type ${a$1}. Line ${e$2.line}`), null;
		if (0 === i$1.size) return null;
		const o$1 = new Pe(new ArrayBuffer(i$1.size), i$1, 0);
		if (i$1 instanceof n) {
			if (e$2.args) for (let n$1 = 0; n$1 < e$2.args.length; ++n$1) {
				const s$1 = i$1.members[n$1], r$2 = e$2.args[n$1], a$2 = this.evalExpression(r$2, t$1);
				o$1.setData(this, a$2, s$1.type, s$1.offset, t$1);
			}
		} else if (i$1 instanceof s) {
			let n$1 = 0;
			if (e$2.args) for (let s$1 = 0; s$1 < e$2.args.length; ++s$1) {
				const a$2 = e$2.args[s$1], c$1 = this.evalExpression(a$2, t$1);
				null === i$1.format && ("x32" === (null === (r$1 = c$1.typeInfo) || void 0 === r$1 ? void 0 : r$1.name) ? i$1.format = this.getTypeInfo("i32") : i$1.format = c$1.typeInfo), o$1.setData(this, c$1, i$1.format, n$1, t$1), n$1 += i$1.stride;
			}
		} else console.error(`Unknown type "${a$1}". Line ${e$2.line}`);
		return e$2 instanceof de ? o$1.getSubData(this, e$2.postfix, t$1) : o$1;
	}
	_evalLiteral(e$2, t$1) {
		const n$1 = this.getTypeInfo(e$2.type), s$1 = n$1.name;
		if ("x32" === s$1 || "u32" === s$1 || "f32" === s$1 || "f16" === s$1 || "i32" === s$1 || "bool" === s$1) return new Be(e$2.scalarValue, n$1);
		return "vec2" === s$1 || "vec3" === s$1 || "vec4" === s$1 || "vec2f" === s$1 || "vec3f" === s$1 || "vec4f" === s$1 || "vec2h" === s$1 || "vec3h" === s$1 || "vec4h" === s$1 || "vec2i" === s$1 || "vec3i" === s$1 || "vec4i" === s$1 || "vec2u" === s$1 || "vec3u" === s$1 || "vec4u" === s$1 ? this._callConstructorVec(e$2, t$1) : "mat2x2" === s$1 || "mat2x3" === s$1 || "mat2x4" === s$1 || "mat3x2" === s$1 || "mat3x3" === s$1 || "mat3x4" === s$1 || "mat4x2" === s$1 || "mat4x3" === s$1 || "mat4x4" === s$1 || "mat2x2f" === s$1 || "mat2x3f" === s$1 || "mat2x4f" === s$1 || "mat3x2f" === s$1 || "mat3x3f" === s$1 || "mat3x4f" === s$1 || "mat4x2f" === s$1 || "mat4x3f" === s$1 || "mat4x4f" === s$1 || "mat2x2h" === s$1 || "mat2x3h" === s$1 || "mat2x4h" === s$1 || "mat3x2h" === s$1 || "mat3x3h" === s$1 || "mat3x4h" === s$1 || "mat4x2h" === s$1 || "mat4x3h" === s$1 || "mat4x4h" === s$1 ? this._callConstructorMatrix(e$2, t$1) : e$2.value;
	}
	_evalVariable(e$2, t$1) {
		const n$1 = t$1.getVariableValue(e$2.name);
		return null === n$1 ? n$1 : n$1.getSubData(this, e$2.postfix, t$1);
	}
	_maxFormatTypeInfo(e$2) {
		let t$1 = e$2[0];
		if ("f32" === t$1.name) return t$1;
		for (let n$1 = 1; n$1 < e$2.length; ++n$1) {
			const s$1 = dt._priority.get(t$1.name);
			dt._priority.get(e$2[n$1].name) < s$1 && (t$1 = e$2[n$1]);
		}
		return "x32" === t$1.name ? this.getTypeInfo("i32") : t$1;
	}
	_evalUnaryOp(e$2, t$1) {
		const n$1 = this.evalExpression(e$2.right, t$1);
		if ("&" === e$2.operator) return new Oe(n$1);
		if ("*" === e$2.operator) return n$1 instanceof Oe ? n$1.reference.getSubData(this, e$2.postfix, t$1) : (console.error(`Invalid dereference. Line ${e$2.line}`), null);
		const s$1 = n$1 instanceof Be ? n$1.value : n$1 instanceof Me ? Array.from(n$1.data) : null;
		switch (e$2.operator) {
			case "+": {
				if (Ge(s$1)) return new Me(s$1.map((e$4, t$3) => +e$4), n$1.typeInfo);
				const e$3 = s$1, t$2 = this._maxFormatTypeInfo([n$1.typeInfo, n$1.typeInfo]);
				return new Be(+e$3, t$2);
			}
			case "-": {
				if (Ge(s$1)) return new Me(s$1.map((e$4, t$3) => -e$4), n$1.typeInfo);
				const e$3 = s$1, t$2 = this._maxFormatTypeInfo([n$1.typeInfo, n$1.typeInfo]);
				return new Be(-e$3, t$2);
			}
			case "!": {
				if (Ge(s$1)) return new Me(s$1.map((e$4, t$3) => e$4 ? 0 : 1), n$1.typeInfo);
				const e$3 = s$1, t$2 = this._maxFormatTypeInfo([n$1.typeInfo, n$1.typeInfo]);
				return new Be(e$3 ? 0 : 1, t$2);
			}
			case "~": {
				if (Ge(s$1)) return new Me(s$1.map((e$4, t$3) => ~e$4), n$1.typeInfo);
				const e$3 = s$1, t$2 = this._maxFormatTypeInfo([n$1.typeInfo, n$1.typeInfo]);
				return new Be(~e$3, t$2);
			}
		}
		return console.error(`Invalid unary operator ${e$2.operator}. Line ${e$2.line}`), null;
	}
	_evalBinaryOp(e$2, t$1) {
		const n$1 = this.evalExpression(e$2.left, t$1), s$1 = this.evalExpression(e$2.right, t$1), r$1 = n$1 instanceof Be ? n$1.value : n$1 instanceof Me || n$1 instanceof Ue ? Array.from(n$1.data) : null, a$1 = s$1 instanceof Be ? s$1.value : s$1 instanceof Me || s$1 instanceof Ue ? Array.from(s$1.data) : null;
		switch (e$2.operator) {
			case "+": {
				if (Ge(r$1) && Ge(a$1)) {
					const t$3 = r$1, s$2 = a$1;
					if (t$3.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$2.line}.`), null;
					return new Me(t$3.map((e$3, t$4) => e$3 + s$2[t$4]), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$3 = a$1;
					return new Me(r$1.map((t$3, n$2) => t$3 + e$3), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$3 = r$1;
					return new Me(a$1.map((t$3, n$2) => e$3 + t$3), s$1.typeInfo);
				}
				const t$2 = r$1, i$1 = a$1, o$1 = this._maxFormatTypeInfo([n$1.typeInfo, s$1.typeInfo]);
				return new Be(t$2 + i$1, o$1);
			}
			case "-": {
				if (Ge(r$1) && Ge(a$1)) {
					const t$3 = r$1, s$2 = a$1;
					if (t$3.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$2.line}.`), null;
					return new Me(t$3.map((e$3, t$4) => e$3 - s$2[t$4]), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$3 = a$1;
					return new Me(r$1.map((t$3, n$2) => t$3 - e$3), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$3 = r$1;
					return new Me(a$1.map((t$3, n$2) => e$3 - t$3), s$1.typeInfo);
				}
				const t$2 = r$1, i$1 = a$1, o$1 = this._maxFormatTypeInfo([n$1.typeInfo, s$1.typeInfo]);
				return new Be(t$2 - i$1, o$1);
			}
			case "*": {
				if (Ge(r$1) && Ge(a$1)) {
					const t$3 = r$1, i$2 = a$1;
					if (n$1 instanceof Ue && s$1 instanceof Ue) {
						const r$2 = function(e$3, t$4, n$2, s$2) {
							if (void 0 === pt[t$4.name] || void 0 === pt[s$2.name]) return null;
							const r$3 = pt[t$4.name][0], a$3 = pt[t$4.name][1], i$3 = pt[s$2.name][0];
							if (r$3 !== pt[s$2.name][1]) return null;
							const o$3 = new Array(i$3 * a$3);
							for (let t$5 = 0; t$5 < a$3; t$5++) for (let s$3 = 0; s$3 < i$3; s$3++) {
								let c$1 = 0;
								for (let i$4 = 0; i$4 < r$3; i$4++) c$1 += e$3[i$4 * a$3 + t$5] * n$2[s$3 * r$3 + i$4];
								o$3[t$5 * i$3 + s$3] = c$1;
							}
							return o$3;
						}(t$3, n$1.typeInfo, i$2, s$1.typeInfo);
						if (null === r$2) return console.error(`Matrix multiplication failed. Line ${e$2.line}.`), null;
						const a$2 = pt[s$1.typeInfo.name][0], o$2 = pt[n$1.typeInfo.name][1];
						return new Ue(r$2, this.getTypeInfo(`mat${a$2}x${o$2}f`));
					}
					if (n$1 instanceof Ue && s$1 instanceof Me) {
						const r$2 = function(e$3, t$4, n$2, s$2) {
							if (void 0 === pt[t$4.name] || void 0 === ft[s$2.name]) return null;
							const r$3 = pt[t$4.name][0], a$2 = pt[t$4.name][1];
							if (r$3 !== n$2.length) return null;
							const i$3 = new Array(a$2);
							for (let t$5 = 0; t$5 < a$2; t$5++) {
								let s$3 = 0;
								for (let i$4 = 0; i$4 < r$3; i$4++) s$3 += e$3[i$4 * a$2 + t$5] * n$2[i$4];
								i$3[t$5] = s$3;
							}
							return i$3;
						}(t$3, n$1.typeInfo, i$2, s$1.typeInfo);
						return null === r$2 ? (console.error(`Matrix vector multiplication failed. Line ${e$2.line}.`), null) : new Me(r$2, s$1.typeInfo);
					}
					if (n$1 instanceof Me && s$1 instanceof Ue) {
						const r$2 = function(e$3, t$4, n$2, s$2) {
							if (void 0 === ft[t$4.name] || void 0 === pt[s$2.name]) return null;
							const r$3 = pt[s$2.name][0], a$2 = pt[s$2.name][1];
							if (a$2 !== e$3.length) return null;
							const i$3 = [];
							for (let t$5 = 0; t$5 < r$3; t$5++) {
								let s$3 = 0;
								for (let i$4 = 0; i$4 < a$2; i$4++) s$3 += e$3[i$4] * n$2[i$4 * r$3 + t$5];
								i$3[t$5] = s$3;
							}
							return i$3;
						}(t$3, n$1.typeInfo, i$2, s$1.typeInfo);
						return null === r$2 ? (console.error(`Matrix vector multiplication failed. Line ${e$2.line}.`), null) : new Me(r$2, n$1.typeInfo);
					}
					if (t$3.length !== i$2.length) return console.error(`Vector length mismatch. Line ${e$2.line}.`), null;
					return new Me(t$3.map((e$3, t$4) => e$3 * i$2[t$4]), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$3 = a$1, t$3 = r$1.map((t$4, n$2) => t$4 * e$3);
					return n$1 instanceof Ue ? new Ue(t$3, n$1.typeInfo) : new Me(t$3, n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$3 = r$1, t$3 = a$1.map((t$4, n$2) => e$3 * t$4);
					return s$1 instanceof Ue ? new Ue(t$3, s$1.typeInfo) : new Me(t$3, s$1.typeInfo);
				}
				const t$2 = r$1, i$1 = a$1, o$1 = this._maxFormatTypeInfo([n$1.typeInfo, s$1.typeInfo]);
				return new Be(t$2 * i$1, o$1);
			}
			case "%": {
				if (Ge(r$1) && Ge(a$1)) {
					const t$3 = r$1, s$2 = a$1;
					if (t$3.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$2.line}.`), null;
					return new Me(t$3.map((e$3, t$4) => e$3 % s$2[t$4]), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$3 = a$1;
					return new Me(r$1.map((t$3, n$2) => t$3 % e$3), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$3 = r$1;
					return new Me(a$1.map((t$3, n$2) => e$3 % t$3), s$1.typeInfo);
				}
				const t$2 = r$1, i$1 = a$1, o$1 = this._maxFormatTypeInfo([n$1.typeInfo, s$1.typeInfo]);
				return new Be(t$2 % i$1, o$1);
			}
			case "/": {
				if (Ge(r$1) && Ge(a$1)) {
					const t$3 = r$1, s$2 = a$1;
					if (t$3.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$2.line}.`), null;
					return new Me(t$3.map((e$3, t$4) => e$3 / s$2[t$4]), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$3 = a$1;
					return new Me(r$1.map((t$3, n$2) => t$3 / e$3), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$3 = r$1;
					return new Me(a$1.map((t$3, n$2) => e$3 / t$3), s$1.typeInfo);
				}
				const t$2 = r$1, i$1 = a$1, o$1 = this._maxFormatTypeInfo([n$1.typeInfo, s$1.typeInfo]);
				return new Be(t$2 / i$1, o$1);
			}
			case "&": {
				if (Ge(r$1) && Ge(a$1)) {
					const t$3 = r$1, s$2 = a$1;
					if (t$3.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$2.line}.`), null;
					return new Me(t$3.map((e$3, t$4) => e$3 & s$2[t$4]), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$3 = a$1;
					return new Me(r$1.map((t$3, n$2) => t$3 & e$3), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$3 = r$1;
					return new Me(a$1.map((t$3, n$2) => e$3 & t$3), s$1.typeInfo);
				}
				const t$2 = r$1, i$1 = a$1, o$1 = this._maxFormatTypeInfo([n$1.typeInfo, s$1.typeInfo]);
				return new Be(t$2 & i$1, o$1);
			}
			case "|": {
				if (Ge(r$1) && Ge(a$1)) {
					const t$3 = r$1, s$2 = a$1;
					if (t$3.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$2.line}.`), null;
					return new Me(t$3.map((e$3, t$4) => e$3 | s$2[t$4]), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$3 = a$1;
					return new Me(r$1.map((t$3, n$2) => t$3 | e$3), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$3 = r$1;
					return new Me(a$1.map((t$3, n$2) => e$3 | t$3), s$1.typeInfo);
				}
				const t$2 = r$1, i$1 = a$1, o$1 = this._maxFormatTypeInfo([n$1.typeInfo, s$1.typeInfo]);
				return new Be(t$2 | i$1, o$1);
			}
			case "^": {
				if (Ge(r$1) && Ge(a$1)) {
					const t$3 = r$1, s$2 = a$1;
					if (t$3.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$2.line}.`), null;
					return new Me(t$3.map((e$3, t$4) => e$3 ^ s$2[t$4]), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$3 = a$1;
					return new Me(r$1.map((t$3, n$2) => t$3 ^ e$3), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$3 = r$1;
					return new Me(a$1.map((t$3, n$2) => e$3 ^ t$3), s$1.typeInfo);
				}
				const t$2 = r$1, i$1 = a$1, o$1 = this._maxFormatTypeInfo([n$1.typeInfo, s$1.typeInfo]);
				return new Be(t$2 ^ i$1, o$1);
			}
			case "<<": {
				if (Ge(r$1) && Ge(a$1)) {
					const t$3 = r$1, s$2 = a$1;
					if (t$3.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$2.line}.`), null;
					return new Me(t$3.map((e$3, t$4) => e$3 << s$2[t$4]), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$3 = a$1;
					return new Me(r$1.map((t$3, n$2) => t$3 << e$3), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$3 = r$1;
					return new Me(a$1.map((t$3, n$2) => e$3 << t$3), s$1.typeInfo);
				}
				const t$2 = r$1, i$1 = a$1, o$1 = this._maxFormatTypeInfo([n$1.typeInfo, s$1.typeInfo]);
				return new Be(t$2 << i$1, o$1);
			}
			case ">>": {
				if (Ge(r$1) && Ge(a$1)) {
					const t$3 = r$1, s$2 = a$1;
					if (t$3.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$2.line}.`), null;
					return new Me(t$3.map((e$3, t$4) => e$3 >> s$2[t$4]), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$3 = a$1;
					return new Me(r$1.map((t$3, n$2) => t$3 >> e$3), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$3 = r$1;
					return new Me(a$1.map((t$3, n$2) => e$3 >> t$3), s$1.typeInfo);
				}
				const t$2 = r$1, i$1 = a$1, o$1 = this._maxFormatTypeInfo([n$1.typeInfo, s$1.typeInfo]);
				return new Be(t$2 >> i$1, o$1);
			}
			case ">":
				if (Ge(r$1) && Ge(a$1)) {
					const t$2 = r$1, s$2 = a$1;
					if (t$2.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$2.line}.`), null;
					return new Me(t$2.map((e$3, t$3) => e$3 > s$2[t$3] ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$3 = a$1;
					return new Me(r$1.map((t$2, n$2) => t$2 > e$3 ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$3 = r$1;
					return new Me(a$1.map((t$2, n$2) => e$3 > t$2 ? 1 : 0), s$1.typeInfo);
				}
				return new Be(r$1 > a$1 ? 1 : 0, this.getTypeInfo("bool"));
			case "<":
				if (Ge(r$1) && Ge(a$1)) {
					const t$2 = r$1, s$2 = a$1;
					if (t$2.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$2.line}.`), null;
					return new Me(t$2.map((e$3, t$3) => e$3 < s$2[t$3] ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$3 = a$1;
					return new Me(r$1.map((t$2, n$2) => t$2 < e$3 ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$3 = r$1;
					return new Me(a$1.map((t$2, n$2) => e$3 < t$2 ? 1 : 0), s$1.typeInfo);
				}
				return new Be(r$1 < a$1 ? 1 : 0, this.getTypeInfo("bool"));
			case "==":
				if (Ge(r$1) && Ge(a$1)) {
					const t$2 = r$1, s$2 = a$1;
					if (t$2.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$2.line}.`), null;
					return new Me(t$2.map((e$3, t$3) => e$3 === s$2[t$3] ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$3 = a$1;
					return new Me(r$1.map((t$2, n$2) => t$2 == e$3 ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$3 = r$1;
					return new Me(a$1.map((t$2, n$2) => e$3 == t$2 ? 1 : 0), s$1.typeInfo);
				}
				return new Be(r$1 === a$1 ? 1 : 0, this.getTypeInfo("bool"));
			case "!=":
				if (Ge(r$1) && Ge(a$1)) {
					const t$2 = r$1, s$2 = a$1;
					if (t$2.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$2.line}.`), null;
					return new Me(t$2.map((e$3, t$3) => e$3 !== s$2[t$3] ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$3 = a$1;
					return new Me(r$1.map((t$2, n$2) => t$2 !== e$3 ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$3 = r$1;
					return new Me(a$1.map((t$2, n$2) => e$3 !== t$2 ? 1 : 0), s$1.typeInfo);
				}
				return new Be(r$1 !== a$1 ? 1 : 0, this.getTypeInfo("bool"));
			case ">=":
				if (Ge(r$1) && Ge(a$1)) {
					const t$2 = r$1, s$2 = a$1;
					if (t$2.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$2.line}.`), null;
					return new Me(t$2.map((e$3, t$3) => e$3 >= s$2[t$3] ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$3 = a$1;
					return new Me(r$1.map((t$2, n$2) => t$2 >= e$3 ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$3 = r$1;
					return new Me(a$1.map((t$2, n$2) => e$3 >= t$2 ? 1 : 0), s$1.typeInfo);
				}
				return new Be(r$1 >= a$1 ? 1 : 0, this.getTypeInfo("bool"));
			case "<=":
				if (Ge(r$1) && Ge(a$1)) {
					const t$2 = r$1, s$2 = a$1;
					if (t$2.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$2.line}.`), null;
					return new Me(t$2.map((e$3, t$3) => e$3 <= s$2[t$3] ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$3 = a$1;
					return new Me(r$1.map((t$2, n$2) => t$2 <= e$3 ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$3 = r$1;
					return new Me(a$1.map((t$2, n$2) => e$3 <= t$2 ? 1 : 0), s$1.typeInfo);
				}
				return new Be(r$1 <= a$1 ? 1 : 0, this.getTypeInfo("bool"));
			case "&&":
				if (Ge(r$1) && Ge(a$1)) {
					const t$2 = r$1, s$2 = a$1;
					if (t$2.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$2.line}.`), null;
					return new Me(t$2.map((e$3, t$3) => e$3 && s$2[t$3] ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$3 = a$1;
					return new Me(r$1.map((t$2, n$2) => t$2 && e$3 ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$3 = r$1;
					return new Me(a$1.map((t$2, n$2) => e$3 && t$2 ? 1 : 0), s$1.typeInfo);
				}
				return new Be(r$1 && a$1 ? 1 : 0, this.getTypeInfo("bool"));
			case "||":
				if (Ge(r$1) && Ge(a$1)) {
					const t$2 = r$1, s$2 = a$1;
					if (t$2.length !== s$2.length) return console.error(`Vector length mismatch. Line ${e$2.line}.`), null;
					return new Me(t$2.map((e$3, t$3) => e$3 || s$2[t$3] ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(r$1)) {
					const e$3 = a$1;
					return new Me(r$1.map((t$2, n$2) => t$2 || e$3 ? 1 : 0), n$1.typeInfo);
				}
				if (Ge(a$1)) {
					const e$3 = r$1;
					return new Me(a$1.map((t$2, n$2) => e$3 || t$2 ? 1 : 0), s$1.typeInfo);
				}
				return new Be(r$1 || a$1 ? 1 : 0, this.getTypeInfo("bool"));
		}
		return console.error(`Unknown operator ${e$2.operator}. Line ${e$2.line}`), null;
	}
	_evalCall(e$2, t$1) {
		if (null !== e$2.cachedReturnValue) return e$2.cachedReturnValue;
		const n$1 = t$1.clone();
		n$1.currentFunctionName = e$2.name;
		const s$1 = t$1.getFunction(e$2.name);
		if (!s$1) {
			if (e$2.isBuiltin) return this._callBuiltinFunction(e$2, n$1);
			return this.getTypeInfo(e$2.name) ? this._evalCreate(e$2, t$1) : (console.error(`Unknown function "${e$2.name}". Line ${e$2.line}`), null);
		}
		for (let t$2 = 0; t$2 < s$1.node.args.length; ++t$2) {
			const r$1 = s$1.node.args[t$2], a$1 = this.evalExpression(e$2.args[t$2], n$1);
			n$1.createVariable(r$1.name, a$1, r$1);
		}
		return this._execStatements(s$1.node.body, n$1);
	}
	_callBuiltinFunction(e$2, t$1) {
		switch (e$2.name) {
			case "all": return this.builtins.All(e$2, t$1);
			case "any": return this.builtins.Any(e$2, t$1);
			case "select": return this.builtins.Select(e$2, t$1);
			case "arrayLength": return this.builtins.ArrayLength(e$2, t$1);
			case "abs": return this.builtins.Abs(e$2, t$1);
			case "acos": return this.builtins.Acos(e$2, t$1);
			case "acosh": return this.builtins.Acosh(e$2, t$1);
			case "asin": return this.builtins.Asin(e$2, t$1);
			case "asinh": return this.builtins.Asinh(e$2, t$1);
			case "atan": return this.builtins.Atan(e$2, t$1);
			case "atanh": return this.builtins.Atanh(e$2, t$1);
			case "atan2": return this.builtins.Atan2(e$2, t$1);
			case "ceil": return this.builtins.Ceil(e$2, t$1);
			case "clamp": return this.builtins.Clamp(e$2, t$1);
			case "cos": return this.builtins.Cos(e$2, t$1);
			case "cosh": return this.builtins.Cosh(e$2, t$1);
			case "countLeadingZeros": return this.builtins.CountLeadingZeros(e$2, t$1);
			case "countOneBits": return this.builtins.CountOneBits(e$2, t$1);
			case "countTrailingZeros": return this.builtins.CountTrailingZeros(e$2, t$1);
			case "cross": return this.builtins.Cross(e$2, t$1);
			case "degrees": return this.builtins.Degrees(e$2, t$1);
			case "determinant": return this.builtins.Determinant(e$2, t$1);
			case "distance": return this.builtins.Distance(e$2, t$1);
			case "dot": return this.builtins.Dot(e$2, t$1);
			case "dot4U8Packed": return this.builtins.Dot4U8Packed(e$2, t$1);
			case "dot4I8Packed": return this.builtins.Dot4I8Packed(e$2, t$1);
			case "exp": return this.builtins.Exp(e$2, t$1);
			case "exp2": return this.builtins.Exp2(e$2, t$1);
			case "extractBits": return this.builtins.ExtractBits(e$2, t$1);
			case "faceForward": return this.builtins.FaceForward(e$2, t$1);
			case "firstLeadingBit": return this.builtins.FirstLeadingBit(e$2, t$1);
			case "firstTrailingBit": return this.builtins.FirstTrailingBit(e$2, t$1);
			case "floor": return this.builtins.Floor(e$2, t$1);
			case "fma": return this.builtins.Fma(e$2, t$1);
			case "fract": return this.builtins.Fract(e$2, t$1);
			case "frexp": return this.builtins.Frexp(e$2, t$1);
			case "insertBits": return this.builtins.InsertBits(e$2, t$1);
			case "inverseSqrt": return this.builtins.InverseSqrt(e$2, t$1);
			case "ldexp": return this.builtins.Ldexp(e$2, t$1);
			case "length": return this.builtins.Length(e$2, t$1);
			case "log": return this.builtins.Log(e$2, t$1);
			case "log2": return this.builtins.Log2(e$2, t$1);
			case "max": return this.builtins.Max(e$2, t$1);
			case "min": return this.builtins.Min(e$2, t$1);
			case "mix": return this.builtins.Mix(e$2, t$1);
			case "modf": return this.builtins.Modf(e$2, t$1);
			case "normalize": return this.builtins.Normalize(e$2, t$1);
			case "pow": return this.builtins.Pow(e$2, t$1);
			case "quantizeToF16": return this.builtins.QuantizeToF16(e$2, t$1);
			case "radians": return this.builtins.Radians(e$2, t$1);
			case "reflect": return this.builtins.Reflect(e$2, t$1);
			case "refract": return this.builtins.Refract(e$2, t$1);
			case "reverseBits": return this.builtins.ReverseBits(e$2, t$1);
			case "round": return this.builtins.Round(e$2, t$1);
			case "saturate": return this.builtins.Saturate(e$2, t$1);
			case "sign": return this.builtins.Sign(e$2, t$1);
			case "sin": return this.builtins.Sin(e$2, t$1);
			case "sinh": return this.builtins.Sinh(e$2, t$1);
			case "smoothstep": return this.builtins.SmoothStep(e$2, t$1);
			case "sqrt": return this.builtins.Sqrt(e$2, t$1);
			case "step": return this.builtins.Step(e$2, t$1);
			case "tan": return this.builtins.Tan(e$2, t$1);
			case "tanh": return this.builtins.Tanh(e$2, t$1);
			case "transpose": return this.builtins.Transpose(e$2, t$1);
			case "trunc": return this.builtins.Trunc(e$2, t$1);
			case "dpdx": return this.builtins.Dpdx(e$2, t$1);
			case "dpdxCoarse": return this.builtins.DpdxCoarse(e$2, t$1);
			case "dpdxFine": return this.builtins.DpdxFine(e$2, t$1);
			case "dpdy": return this.builtins.Dpdy(e$2, t$1);
			case "dpdyCoarse": return this.builtins.DpdyCoarse(e$2, t$1);
			case "dpdyFine": return this.builtins.DpdyFine(e$2, t$1);
			case "fwidth": return this.builtins.Fwidth(e$2, t$1);
			case "fwidthCoarse": return this.builtins.FwidthCoarse(e$2, t$1);
			case "fwidthFine": return this.builtins.FwidthFine(e$2, t$1);
			case "textureDimensions": return this.builtins.TextureDimensions(e$2, t$1);
			case "textureGather": return this.builtins.TextureGather(e$2, t$1);
			case "textureGatherCompare": return this.builtins.TextureGatherCompare(e$2, t$1);
			case "textureLoad": return this.builtins.TextureLoad(e$2, t$1);
			case "textureNumLayers": return this.builtins.TextureNumLayers(e$2, t$1);
			case "textureNumLevels": return this.builtins.TextureNumLevels(e$2, t$1);
			case "textureNumSamples": return this.builtins.TextureNumSamples(e$2, t$1);
			case "textureSample": return this.builtins.TextureSample(e$2, t$1);
			case "textureSampleBias": return this.builtins.TextureSampleBias(e$2, t$1);
			case "textureSampleCompare": return this.builtins.TextureSampleCompare(e$2, t$1);
			case "textureSampleCompareLevel": return this.builtins.TextureSampleCompareLevel(e$2, t$1);
			case "textureSampleGrad": return this.builtins.TextureSampleGrad(e$2, t$1);
			case "textureSampleLevel": return this.builtins.TextureSampleLevel(e$2, t$1);
			case "textureSampleBaseClampToEdge": return this.builtins.TextureSampleBaseClampToEdge(e$2, t$1);
			case "textureStore": return this.builtins.TextureStore(e$2, t$1);
			case "atomicLoad": return this.builtins.AtomicLoad(e$2, t$1);
			case "atomicStore": return this.builtins.AtomicStore(e$2, t$1);
			case "atomicAdd": return this.builtins.AtomicAdd(e$2, t$1);
			case "atomicSub": return this.builtins.AtomicSub(e$2, t$1);
			case "atomicMax": return this.builtins.AtomicMax(e$2, t$1);
			case "atomicMin": return this.builtins.AtomicMin(e$2, t$1);
			case "atomicAnd": return this.builtins.AtomicAnd(e$2, t$1);
			case "atomicOr": return this.builtins.AtomicOr(e$2, t$1);
			case "atomicXor": return this.builtins.AtomicXor(e$2, t$1);
			case "atomicExchange": return this.builtins.AtomicExchange(e$2, t$1);
			case "atomicCompareExchangeWeak": return this.builtins.AtomicCompareExchangeWeak(e$2, t$1);
			case "pack4x8snorm": return this.builtins.Pack4x8snorm(e$2, t$1);
			case "pack4x8unorm": return this.builtins.Pack4x8unorm(e$2, t$1);
			case "pack4xI8": return this.builtins.Pack4xI8(e$2, t$1);
			case "pack4xU8": return this.builtins.Pack4xU8(e$2, t$1);
			case "pack4x8Clamp": return this.builtins.Pack4x8Clamp(e$2, t$1);
			case "pack4xU8Clamp": return this.builtins.Pack4xU8Clamp(e$2, t$1);
			case "pack2x16snorm": return this.builtins.Pack2x16snorm(e$2, t$1);
			case "pack2x16unorm": return this.builtins.Pack2x16unorm(e$2, t$1);
			case "pack2x16float": return this.builtins.Pack2x16float(e$2, t$1);
			case "unpack4x8snorm": return this.builtins.Unpack4x8snorm(e$2, t$1);
			case "unpack4x8unorm": return this.builtins.Unpack4x8unorm(e$2, t$1);
			case "unpack4xI8": return this.builtins.Unpack4xI8(e$2, t$1);
			case "unpack4xU8": return this.builtins.Unpack4xU8(e$2, t$1);
			case "unpack2x16snorm": return this.builtins.Unpack2x16snorm(e$2, t$1);
			case "unpack2x16unorm": return this.builtins.Unpack2x16unorm(e$2, t$1);
			case "unpack2x16float": return this.builtins.Unpack2x16float(e$2, t$1);
			case "storageBarrier": return this.builtins.StorageBarrier(e$2, t$1);
			case "textureBarrier": return this.builtins.TextureBarrier(e$2, t$1);
			case "workgroupBarrier": return this.builtins.WorkgroupBarrier(e$2, t$1);
			case "workgroupUniformLoad": return this.builtins.WorkgroupUniformLoad(e$2, t$1);
			case "subgroupAdd": return this.builtins.SubgroupAdd(e$2, t$1);
			case "subgroupExclusiveAdd": return this.builtins.SubgroupExclusiveAdd(e$2, t$1);
			case "subgroupInclusiveAdd": return this.builtins.SubgroupInclusiveAdd(e$2, t$1);
			case "subgroupAll": return this.builtins.SubgroupAll(e$2, t$1);
			case "subgroupAnd": return this.builtins.SubgroupAnd(e$2, t$1);
			case "subgroupAny": return this.builtins.SubgroupAny(e$2, t$1);
			case "subgroupBallot": return this.builtins.SubgroupBallot(e$2, t$1);
			case "subgroupBroadcast": return this.builtins.SubgroupBroadcast(e$2, t$1);
			case "subgroupBroadcastFirst": return this.builtins.SubgroupBroadcastFirst(e$2, t$1);
			case "subgroupElect": return this.builtins.SubgroupElect(e$2, t$1);
			case "subgroupMax": return this.builtins.SubgroupMax(e$2, t$1);
			case "subgroupMin": return this.builtins.SubgroupMin(e$2, t$1);
			case "subgroupMul": return this.builtins.SubgroupMul(e$2, t$1);
			case "subgroupExclusiveMul": return this.builtins.SubgroupExclusiveMul(e$2, t$1);
			case "subgroupInclusiveMul": return this.builtins.SubgroupInclusiveMul(e$2, t$1);
			case "subgroupOr": return this.builtins.SubgroupOr(e$2, t$1);
			case "subgroupShuffle": return this.builtins.SubgroupShuffle(e$2, t$1);
			case "subgroupShuffleDown": return this.builtins.SubgroupShuffleDown(e$2, t$1);
			case "subgroupShuffleUp": return this.builtins.SubgroupShuffleUp(e$2, t$1);
			case "subgroupShuffleXor": return this.builtins.SubgroupShuffleXor(e$2, t$1);
			case "subgroupXor": return this.builtins.SubgroupXor(e$2, t$1);
			case "quadBroadcast": return this.builtins.QuadBroadcast(e$2, t$1);
			case "quadSwapDiagonal": return this.builtins.QuadSwapDiagonal(e$2, t$1);
			case "quadSwapX": return this.builtins.QuadSwapX(e$2, t$1);
			case "quadSwapY": return this.builtins.QuadSwapY(e$2, t$1);
		}
		const n$1 = t$1.getFunction(e$2.name);
		if (n$1) {
			const s$1 = t$1.clone();
			for (let t$2 = 0; t$2 < n$1.node.args.length; ++t$2) {
				const r$1 = n$1.node.args[t$2], a$1 = this.evalExpression(e$2.args[t$2], s$1);
				s$1.setVariable(r$1.name, a$1, r$1);
			}
			return this._execStatements(n$1.node.body, s$1);
		}
		return null;
	}
	_callConstructorValue(e$2, t$1) {
		if (!e$2.args || 0 === e$2.args.length) return new Be(0, this.getTypeInfo(e$2.type));
		const n$1 = this.evalExpression(e$2.args[0], t$1);
		return n$1.typeInfo = this.getTypeInfo(e$2.type), n$1.getSubData(this, e$2.postfix, t$1).clone();
	}
	_callConstructorVec(e$2, t$1) {
		const n$1 = this.getTypeInfo(e$2.type), s$1 = e$2.type.getTypeName(), r$1 = ft[s$1];
		if (void 0 === r$1) return console.error(`Invalid vec constructor ${s$1}. Line ${e$2.line}`), null;
		const a$1 = [];
		if (e$2 instanceof xe) if (e$2.isVector) {
			const t$2 = e$2.vectorValue;
			for (const e$3 of t$2) a$1.push(e$3);
		} else a$1.push(e$2.scalarValue);
		else if (e$2.args) for (const n$2 of e$2.args) {
			const e$3 = this.evalExpression(n$2, t$1);
			if (e$3 instanceof Me) {
				const t$2 = e$3.data;
				for (let e$4 = 0; e$4 < t$2.length; ++e$4) {
					let n$3 = t$2[e$4];
					a$1.push(n$3);
				}
			} else if (e$3 instanceof Be) {
				let t$2 = e$3.value;
				a$1.push(t$2);
			}
		}
		if (e$2.type instanceof ce && null === e$2.type.format && (e$2.type.format = ce.f32), 0 === a$1.length) return new Me(new Array(r$1).fill(0), n$1).getSubData(this, e$2.postfix, t$1);
		if (1 === a$1.length) for (; a$1.length < r$1;) a$1.push(a$1[0]);
		if (a$1.length < r$1) return console.error(`Invalid vec constructor. Line ${e$2.line}`), null;
		return new Me(a$1.length > r$1 ? a$1.slice(0, r$1) : a$1, n$1).getSubData(this, e$2.postfix, t$1);
	}
	_callConstructorMatrix(e$2, t$1) {
		const n$1 = this.getTypeInfo(e$2.type), s$1 = e$2.type.getTypeName(), r$1 = pt[s$1];
		if (void 0 === r$1) return console.error(`Invalid matrix constructor ${s$1}. Line ${e$2.line}`), null;
		const i$1 = [];
		if (e$2 instanceof xe) if (e$2.isVector) {
			const t$2 = e$2.vectorValue;
			for (const e$3 of t$2) i$1.push(e$3);
		} else i$1.push(e$2.scalarValue);
		else if (e$2.args) for (const n$2 of e$2.args) {
			const e$3 = this.evalExpression(n$2, t$1);
			e$3 instanceof Me ? i$1.push(...e$3.data) : e$3 instanceof Be ? i$1.push(e$3.value) : e$3 instanceof Ue && i$1.push(...e$3.data);
		}
		if (n$1 instanceof a && null === n$1.format && (n$1.format = this.getTypeInfo("f32")), 0 === i$1.length) return new Ue(new Array(r$1[2]).fill(0), n$1).getSubData(this, e$2.postfix, t$1);
		return i$1.length !== r$1[2] ? (console.error(`Invalid matrix constructor. Line ${e$2.line}`), null) : new Ue(i$1, n$1).getSubData(this, e$2.postfix, t$1);
	}
};
dt._breakObj = new Ne(new e$1("BREAK", null), null), dt._continueObj = new Ne(new e$1("CONTINUE", null), null), dt._priority = new Map([
	["f32", 0],
	["f16", 1],
	["u32", 2],
	["i32", 3],
	["x32", 3]
]);
var mt = class {
	constructor() {
		this.constants = /* @__PURE__ */ new Map(), this.aliases = /* @__PURE__ */ new Map(), this.structs = /* @__PURE__ */ new Map();
	}
};
var gt = class {
	constructor() {
		this._tokens = [], this._current = 0, this._currentLine = 1, this._deferArrayCountEval = [], this._currentLoop = [], this._context = new mt(), this._exec = new dt(), this._forwardTypeCount = 0;
	}
	parse(e$2) {
		this._initialize(e$2), this._deferArrayCountEval.length = 0;
		const t$1 = [];
		for (; !this._isAtEnd();) {
			const e$3 = this._global_decl_or_directive();
			if (!e$3) break;
			t$1.push(e$3);
		}
		if (this._deferArrayCountEval.length > 0) {
			for (const e$3 of this._deferArrayCountEval) {
				const t$2 = e$3.arrayType, n$1 = e$3.countNode;
				if (n$1 instanceof ge) {
					const e$4 = n$1.name, s$1 = this._context.constants.get(e$4);
					if (s$1) try {
						t$2.count = s$1.constEvaluate(this._exec);
					} catch (e$5) {}
				}
			}
			this._deferArrayCountEval.length = 0;
		}
		if (this._forwardTypeCount > 0) for (const e$3 of t$1) e$3.search((e$4) => {
			e$4 instanceof Ce || e$4 instanceof le ? e$4.type = this._forwardType(e$4.type) : e$4 instanceof ue ? e$4.format = this._forwardType(e$4.format) : e$4 instanceof F || e$4 instanceof U || e$4 instanceof P ? e$4.type = this._forwardType(e$4.type) : e$4 instanceof D ? e$4.returnType = this._forwardType(e$4.returnType) : e$4 instanceof $e && (e$4.type = this._forwardType(e$4.type));
		});
		return t$1;
	}
	_forwardType(e$2) {
		if (e$2 instanceof ie) {
			const t$1 = this._getType(e$2.name);
			if (t$1) return t$1;
		} else e$2 instanceof le ? e$2.type = this._forwardType(e$2.type) : e$2 instanceof ue && (e$2.format = this._forwardType(e$2.format));
		return e$2;
	}
	_initialize(e$2) {
		if (e$2) if ("string" == typeof e$2) this._tokens = new Re(e$2).scanTokens();
		else this._tokens = e$2;
		else this._tokens = [];
		this._current = 0;
	}
	_updateNode(e$2, t$1) {
		return e$2.line = null != t$1 ? t$1 : this._currentLine, e$2;
	}
	_error(e$2, t$1) {
		return {
			token: e$2,
			message: t$1,
			toString: () => `${t$1}`
		};
	}
	_isAtEnd() {
		return this._current >= this._tokens.length || this._peek().type == He.eof;
	}
	_match(e$2) {
		if (e$2 instanceof qe) return !!this._check(e$2) && (this._advance(), !0);
		for (let t$1 = 0, n$1 = e$2.length; t$1 < n$1; ++t$1) {
			const n$2 = e$2[t$1];
			if (this._check(n$2)) return this._advance(), !0;
		}
		return !1;
	}
	_consume(e$2, t$1) {
		if (this._check(e$2)) return this._advance();
		throw this._error(this._peek(), `${t$1}. Line:${this._currentLine}`);
	}
	_check(e$2) {
		if (this._isAtEnd()) return !1;
		const t$1 = this._peek();
		if (e$2 instanceof Array) {
			const n$1 = t$1.type;
			let s$1 = !1;
			for (const t$2 of e$2) {
				if (n$1 === t$2) return !0;
				t$2 === He.tokens.name && (s$1 = !0);
			}
			if (s$1) {
				const e$3 = He.tokens.name.rule.exec(t$1.lexeme);
				if (e$3 && 0 == e$3.index && e$3[0] == t$1.lexeme) return !0;
			}
			return !1;
		}
		if (t$1.type === e$2) return !0;
		if (e$2 === He.tokens.name) {
			const e$3 = He.tokens.name.rule.exec(t$1.lexeme);
			return e$3 && 0 == e$3.index && e$3[0] == t$1.lexeme;
		}
		return !1;
	}
	_advance() {
		var e$2, t$1;
		return this._currentLine = null !== (t$1 = null === (e$2 = this._peek()) || void 0 === e$2 ? void 0 : e$2.line) && void 0 !== t$1 ? t$1 : -1, this._isAtEnd() || this._current++, this._previous();
	}
	_peek() {
		return this._tokens[this._current];
	}
	_previous() {
		return this._tokens[this._current - 1];
	}
	_global_decl_or_directive() {
		for (; this._match(He.tokens.semicolon) && !this._isAtEnd(););
		if (this._match(He.keywords.alias)) {
			const e$3 = this._type_alias();
			return this._consume(He.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([e$3]), e$3;
		}
		if (this._match(He.keywords.diagnostic)) {
			const e$3 = this._diagnostic();
			return this._consume(He.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([e$3]), e$3;
		}
		if (this._match(He.keywords.requires)) {
			const e$3 = this._requires_directive();
			return this._consume(He.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([e$3]), e$3;
		}
		if (this._match(He.keywords.enable)) {
			const e$3 = this._enable_directive();
			return this._consume(He.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([e$3]), e$3;
		}
		const e$2 = this._attribute();
		if (this._check(He.keywords.var)) {
			const t$1 = this._global_variable_decl();
			return null != t$1 && (t$1.attributes = e$2), this._consume(He.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t$1]), t$1;
		}
		if (this._check(He.keywords.override)) {
			const t$1 = this._override_variable_decl();
			return null != t$1 && (t$1.attributes = e$2), this._consume(He.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t$1]), t$1;
		}
		if (this._check(He.keywords.let)) {
			const t$1 = this._global_let_decl();
			return null != t$1 && (t$1.attributes = e$2), this._consume(He.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t$1]), t$1;
		}
		if (this._check(He.keywords.const)) {
			const t$1 = this._global_const_decl();
			return null != t$1 && (t$1.attributes = e$2), this._consume(He.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t$1]), t$1;
		}
		if (this._check(He.keywords.struct)) {
			const t$1 = this._struct_decl();
			return null != t$1 && (t$1.attributes = e$2), this._exec.reflection.updateAST([t$1]), t$1;
		}
		if (this._check(He.keywords.fn)) {
			const t$1 = this._function_decl();
			return null != t$1 && (t$1.attributes = e$2), this._exec.reflection.updateAST([t$1]), t$1;
		}
		return null;
	}
	_function_decl() {
		if (!this._match(He.keywords.fn)) return null;
		const e$2 = this._currentLine, t$1 = this._consume(He.tokens.ident, "Expected function name.").toString();
		this._consume(He.tokens.paren_left, "Expected '(' for function arguments.");
		const n$1 = [];
		if (!this._check(He.tokens.paren_right)) do {
			if (this._check(He.tokens.paren_right)) break;
			const e$3 = this._attribute(), t$2 = this._consume(He.tokens.name, "Expected argument name.").toString();
			this._consume(He.tokens.colon, "Expected ':' for argument type.");
			const s$2 = this._attribute(), r$2 = this._type_decl();
			null != r$2 && (r$2.attributes = s$2, n$1.push(this._updateNode(new $e(t$2, r$2, e$3))));
		} while (this._match(He.tokens.comma));
		this._consume(He.tokens.paren_right, "Expected ')' after function arguments.");
		let s$1 = null;
		if (this._match(He.tokens.arrow)) {
			const e$3 = this._attribute();
			s$1 = this._type_decl(), null != s$1 && (s$1.attributes = e$3);
		}
		const r$1 = this._compound_statement(), a$1 = this._currentLine;
		return this._updateNode(new D(t$1, n$1, s$1, r$1, e$2, a$1), e$2);
	}
	_compound_statement() {
		const e$2 = [];
		for (this._consume(He.tokens.brace_left, "Expected '{' for block."); !this._check(He.tokens.brace_right);) {
			const t$1 = this._statement();
			null !== t$1 && e$2.push(t$1);
		}
		return this._consume(He.tokens.brace_right, "Expected '}' for block."), e$2;
	}
	_statement() {
		for (; this._match(He.tokens.semicolon) && !this._isAtEnd(););
		if (this._check(He.tokens.attr) && this._attribute(), this._check(He.keywords.if)) return this._if_statement();
		if (this._check(He.keywords.switch)) return this._switch_statement();
		if (this._check(He.keywords.loop)) return this._loop_statement();
		if (this._check(He.keywords.for)) return this._for_statement();
		if (this._check(He.keywords.while)) return this._while_statement();
		if (this._check(He.keywords.continuing)) return this._continuing_statement();
		if (this._check(He.keywords.static_assert)) return this._static_assert_statement();
		if (this._check(He.tokens.brace_left)) return this._compound_statement();
		let e$2 = null;
		if (this._check(He.keywords.return)) e$2 = this._return_statement();
		else if (this._check([
			He.keywords.var,
			He.keywords.let,
			He.keywords.const
		])) e$2 = this._variable_statement();
		else if (this._match(He.keywords.discard)) e$2 = this._updateNode(new ne());
		else if (this._match(He.keywords.break)) {
			const t$1 = this._updateNode(new se());
			if (this._currentLoop.length > 0) t$1.loopId = this._currentLoop[this._currentLoop.length - 1].id;
			e$2 = t$1, this._check(He.keywords.if) && (this._advance(), t$1.condition = this._optional_paren_expression());
		} else if (this._match(He.keywords.continue)) {
			const t$1 = this._updateNode(new re());
			if (!(this._currentLoop.length > 0)) throw this._error(this._peek(), `Continue statement must be inside a loop. Line: ${t$1.line}`);
			t$1.loopId = this._currentLoop[this._currentLoop.length - 1].id;
			e$2 = t$1;
		} else e$2 = this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement();
		return null != e$2 && this._consume(He.tokens.semicolon, "Expected ';' after statement."), e$2;
	}
	_static_assert_statement() {
		if (!this._match(He.keywords.static_assert)) return null;
		const e$2 = this._currentLine, t$1 = this._optional_paren_expression();
		return this._updateNode(new N(t$1), e$2);
	}
	_while_statement() {
		if (!this._match(He.keywords.while)) return null;
		const e$2 = this._updateNode(new V(null, null));
		return this._currentLoop.push(e$2), e$2.condition = this._optional_paren_expression(), this._check(He.tokens.attr) && this._attribute(), e$2.body = this._compound_statement(), this._currentLoop.pop(), e$2;
	}
	_continuing_statement() {
		const e$2 = this._currentLoop.length > 0 ? this._currentLoop[this._currentLoop.length - 1].id : -1;
		if (!this._match(He.keywords.continuing)) return null;
		const t$1 = this._currentLine, n$1 = this._compound_statement();
		return this._updateNode(new O(n$1, e$2), t$1);
	}
	_for_statement() {
		if (!this._match(He.keywords.for)) return null;
		this._consume(He.tokens.paren_left, "Expected '('.");
		const e$2 = this._updateNode(new B(null, null, null, null));
		return this._currentLoop.push(e$2), e$2.init = this._check(He.tokens.semicolon) ? null : this._for_init(), this._consume(He.tokens.semicolon, "Expected ';'."), e$2.condition = this._check(He.tokens.semicolon) ? null : this._short_circuit_or_expression(), this._consume(He.tokens.semicolon, "Expected ';'."), e$2.increment = this._check(He.tokens.paren_right) ? null : this._for_increment(), this._consume(He.tokens.paren_right, "Expected ')'."), this._check(He.tokens.attr) && this._attribute(), e$2.body = this._compound_statement(), this._currentLoop.pop(), e$2;
	}
	_for_init() {
		return this._variable_statement() || this._func_call_statement() || this._assignment_statement();
	}
	_for_increment() {
		return this._func_call_statement() || this._increment_decrement_statement() || this._assignment_statement();
	}
	_variable_statement() {
		if (this._check(He.keywords.var)) {
			const e$2 = this._variable_decl();
			if (null === e$2) throw this._error(this._peek(), "Variable declaration expected.");
			let t$1 = null;
			return this._match(He.tokens.equal) && (t$1 = this._short_circuit_or_expression()), this._updateNode(new F(e$2.name, e$2.type, e$2.storage, e$2.access, t$1), e$2.line);
		}
		if (this._match(He.keywords.let)) {
			const e$2 = this._currentLine, t$1 = this._consume(He.tokens.name, "Expected name for let.").toString();
			let n$1 = null;
			if (this._match(He.tokens.colon)) {
				const e$3 = this._attribute();
				n$1 = this._type_decl(), null != n$1 && (n$1.attributes = e$3);
			}
			this._consume(He.tokens.equal, "Expected '=' for let.");
			const s$1 = this._short_circuit_or_expression();
			return this._updateNode(new U(t$1, n$1, null, null, s$1), e$2);
		}
		if (this._match(He.keywords.const)) {
			const e$2 = this._currentLine, t$1 = this._consume(He.tokens.name, "Expected name for const.").toString();
			let n$1 = null;
			if (this._match(He.tokens.colon)) {
				const e$3 = this._attribute();
				n$1 = this._type_decl(), null != n$1 && (n$1.attributes = e$3);
			}
			this._consume(He.tokens.equal, "Expected '=' for const.");
			const s$1 = this._short_circuit_or_expression();
			return null === n$1 && s$1 instanceof xe && (n$1 = s$1.type), this._updateNode(new P(t$1, n$1, null, null, s$1), e$2);
		}
		return null;
	}
	_increment_decrement_statement() {
		const e$2 = this._current, t$1 = this._unary_expression();
		if (null == t$1) return null;
		if (!this._check(He.increment_operators)) return this._current = e$2, null;
		const n$1 = this._consume(He.increment_operators, "Expected increment operator");
		return this._updateNode(new R(n$1.type === He.tokens.plus_plus ? W.increment : W.decrement, t$1));
	}
	_assignment_statement() {
		let e$2 = null;
		const t$1 = this._currentLine;
		if (this._check(He.tokens.brace_right)) return null;
		let n$1 = this._match(He.tokens.underscore);
		if (n$1 || (e$2 = this._unary_expression()), !n$1 && null == e$2) return null;
		const s$1 = this._consume(He.assignment_operators, "Expected assignment operator."), r$1 = this._short_circuit_or_expression();
		return this._updateNode(new G(q.parse(s$1.lexeme), e$2, r$1), t$1);
	}
	_func_call_statement() {
		if (!this._check(He.tokens.ident)) return null;
		const e$2 = this._currentLine, t$1 = this._current, n$1 = this._consume(He.tokens.ident, "Expected function name."), s$1 = this._argument_expression_list();
		return null === s$1 ? (this._current = t$1, null) : this._updateNode(new X(n$1.lexeme, s$1), e$2);
	}
	_loop_statement() {
		if (!this._match(He.keywords.loop)) return null;
		this._check(He.tokens.attr) && this._attribute(), this._consume(He.tokens.brace_left, "Expected '{' for loop.");
		const e$2 = this._updateNode(new j([], null));
		this._currentLoop.push(e$2);
		let t$1 = this._statement();
		for (; null !== t$1;) {
			if (Array.isArray(t$1)) for (let n$1 of t$1) e$2.body.push(n$1);
			else e$2.body.push(t$1);
			if (t$1 instanceof O) {
				e$2.continuing = t$1;
				break;
			}
			t$1 = this._statement();
		}
		return this._currentLoop.pop(), this._consume(He.tokens.brace_right, "Expected '}' for loop."), e$2;
	}
	_switch_statement() {
		if (!this._match(He.keywords.switch)) return null;
		const e$2 = this._updateNode(new Z(null, []));
		if (this._currentLoop.push(e$2), e$2.condition = this._optional_paren_expression(), this._check(He.tokens.attr) && this._attribute(), this._consume(He.tokens.brace_left, "Expected '{' for switch."), e$2.cases = this._switch_body(), null == e$2.cases || 0 == e$2.cases.length) throw this._error(this._previous(), "Expected 'case' or 'default'.");
		return this._consume(He.tokens.brace_right, "Expected '}' for switch."), this._currentLoop.pop(), e$2;
	}
	_switch_body() {
		const e$2 = [];
		let t$1 = !1;
		for (; this._check([He.keywords.default, He.keywords.case]);) {
			if (this._match(He.keywords.case)) {
				const n$1 = this._case_selectors();
				for (const e$3 of n$1) if (e$3 instanceof Se) {
					if (t$1) throw this._error(this._previous(), "Multiple default cases in switch statement.");
					t$1 = !0;
					break;
				}
				this._match(He.tokens.colon), this._check(He.tokens.attr) && this._attribute(), this._consume(He.tokens.brace_left, "Exected '{' for switch case.");
				const s$1 = this._case_body();
				this._consume(He.tokens.brace_right, "Exected '}' for switch case."), e$2.push(this._updateNode(new Ae(n$1, s$1)));
			}
			if (this._match(He.keywords.default)) {
				if (t$1) throw this._error(this._previous(), "Multiple default cases in switch statement.");
				this._match(He.tokens.colon), this._check(He.tokens.attr) && this._attribute(), this._consume(He.tokens.brace_left, "Exected '{' for switch default.");
				const n$1 = this._case_body();
				this._consume(He.tokens.brace_right, "Exected '}' for switch default."), e$2.push(this._updateNode(new Ee(n$1)));
			}
		}
		return e$2;
	}
	_case_selectors() {
		const e$2 = [];
		for (this._match(He.keywords.default) ? e$2.push(this._updateNode(new Se())) : e$2.push(this._shift_expression()); this._match(He.tokens.comma);) this._match(He.keywords.default) ? e$2.push(this._updateNode(new Se())) : e$2.push(this._shift_expression());
		return e$2;
	}
	_case_body() {
		if (this._match(He.keywords.fallthrough)) return this._consume(He.tokens.semicolon, "Expected ';'"), [];
		let e$2 = this._statement();
		if (null == e$2) return [];
		e$2 instanceof Array || (e$2 = [e$2]);
		const t$1 = this._case_body();
		return 0 == t$1.length ? e$2 : [...e$2, t$1[0]];
	}
	_if_statement() {
		if (!this._match(He.keywords.if)) return null;
		const e$2 = this._currentLine, t$1 = this._optional_paren_expression();
		this._check(He.tokens.attr) && this._attribute();
		const n$1 = this._compound_statement();
		let s$1 = [];
		this._match_elseif() && (this._check(He.tokens.attr) && this._attribute(), s$1 = this._elseif_statement(s$1));
		let r$1 = null;
		return this._match(He.keywords.else) && (this._check(He.tokens.attr) && this._attribute(), r$1 = this._compound_statement()), this._updateNode(new Q(t$1, n$1, s$1, r$1), e$2);
	}
	_match_elseif() {
		return this._tokens[this._current].type === He.keywords.else && this._tokens[this._current + 1].type === He.keywords.if && (this._advance(), this._advance(), !0);
	}
	_elseif_statement(e$2 = []) {
		const t$1 = this._optional_paren_expression(), n$1 = this._compound_statement();
		return e$2.push(this._updateNode(new Le(t$1, n$1))), this._match_elseif() && (this._check(He.tokens.attr) && this._attribute(), this._elseif_statement(e$2)), e$2;
	}
	_return_statement() {
		if (!this._match(He.keywords.return)) return null;
		const e$2 = this._short_circuit_or_expression();
		return this._updateNode(new Y(e$2));
	}
	_short_circuit_or_expression() {
		let e$2 = this._short_circuit_and_expr();
		for (; this._match(He.tokens.or_or);) e$2 = this._updateNode(new Ie(this._previous().toString(), e$2, this._short_circuit_and_expr()));
		return e$2;
	}
	_short_circuit_and_expr() {
		let e$2 = this._inclusive_or_expression();
		for (; this._match(He.tokens.and_and);) e$2 = this._updateNode(new Ie(this._previous().toString(), e$2, this._inclusive_or_expression()));
		return e$2;
	}
	_inclusive_or_expression() {
		let e$2 = this._exclusive_or_expression();
		for (; this._match(He.tokens.or);) e$2 = this._updateNode(new Ie(this._previous().toString(), e$2, this._exclusive_or_expression()));
		return e$2;
	}
	_exclusive_or_expression() {
		let e$2 = this._and_expression();
		for (; this._match(He.tokens.xor);) e$2 = this._updateNode(new Ie(this._previous().toString(), e$2, this._and_expression()));
		return e$2;
	}
	_and_expression() {
		let e$2 = this._equality_expression();
		for (; this._match(He.tokens.and);) e$2 = this._updateNode(new Ie(this._previous().toString(), e$2, this._equality_expression()));
		return e$2;
	}
	_equality_expression() {
		const e$2 = this._relational_expression();
		return this._match([He.tokens.equal_equal, He.tokens.not_equal]) ? this._updateNode(new Ie(this._previous().toString(), e$2, this._relational_expression())) : e$2;
	}
	_relational_expression() {
		let e$2 = this._shift_expression();
		for (; this._match([
			He.tokens.less_than,
			He.tokens.greater_than,
			He.tokens.less_than_equal,
			He.tokens.greater_than_equal
		]);) e$2 = this._updateNode(new Ie(this._previous().toString(), e$2, this._shift_expression()));
		return e$2;
	}
	_shift_expression() {
		let e$2 = this._additive_expression();
		for (; this._match([He.tokens.shift_left, He.tokens.shift_right]);) e$2 = this._updateNode(new Ie(this._previous().toString(), e$2, this._additive_expression()));
		return e$2;
	}
	_additive_expression() {
		let e$2 = this._multiplicative_expression();
		for (; this._match([He.tokens.plus, He.tokens.minus]);) e$2 = this._updateNode(new Ie(this._previous().toString(), e$2, this._multiplicative_expression()));
		return e$2;
	}
	_multiplicative_expression() {
		let e$2 = this._unary_expression();
		for (; this._match([
			He.tokens.star,
			He.tokens.forward_slash,
			He.tokens.modulo
		]);) e$2 = this._updateNode(new Ie(this._previous().toString(), e$2, this._unary_expression()));
		return e$2;
	}
	_unary_expression() {
		return this._match([
			He.tokens.minus,
			He.tokens.bang,
			He.tokens.tilde,
			He.tokens.star,
			He.tokens.and
		]) ? this._updateNode(new ke(this._previous().toString(), this._unary_expression())) : this._singular_expression();
	}
	_singular_expression() {
		const e$2 = this._primary_expression(), t$1 = this._postfix_expression();
		return t$1 && (e$2.postfix = t$1), e$2;
	}
	_postfix_expression() {
		if (this._match(He.tokens.bracket_left)) {
			const e$2 = this._short_circuit_or_expression();
			this._consume(He.tokens.bracket_right, "Expected ']'.");
			const t$1 = this._updateNode(new ve(e$2)), n$1 = this._postfix_expression();
			return n$1 && (t$1.postfix = n$1), t$1;
		}
		if (this._match(He.tokens.period)) {
			const e$2 = this._consume(He.tokens.name, "Expected member name."), t$1 = this._postfix_expression(), n$1 = this._updateNode(new pe(e$2.lexeme));
			return t$1 && (n$1.postfix = t$1), n$1;
		}
		return null;
	}
	_getStruct(e$2) {
		if (this._context.aliases.has(e$2)) return this._context.aliases.get(e$2).type;
		if (this._context.structs.has(e$2)) return this._context.structs.get(e$2);
		return null;
	}
	_getType(e$2) {
		const t$1 = this._getStruct(e$2);
		if (null !== t$1) return t$1;
		switch (e$2) {
			case "void": return ae.void;
			case "bool": return ae.bool;
			case "i32": return ae.i32;
			case "u32": return ae.u32;
			case "f32": return ae.f32;
			case "f16": return ae.f16;
			case "vec2f": return ce.vec2f;
			case "vec3f": return ce.vec3f;
			case "vec4f": return ce.vec4f;
			case "vec2i": return ce.vec2i;
			case "vec3i": return ce.vec3i;
			case "vec4i": return ce.vec4i;
			case "vec2u": return ce.vec2u;
			case "vec3u": return ce.vec3u;
			case "vec4u": return ce.vec4u;
			case "vec2h": return ce.vec2h;
			case "vec3h": return ce.vec3h;
			case "vec4h": return ce.vec4h;
			case "mat2x2f": return ce.mat2x2f;
			case "mat2x3f": return ce.mat2x3f;
			case "mat2x4f": return ce.mat2x4f;
			case "mat3x2f": return ce.mat3x2f;
			case "mat3x3f": return ce.mat3x3f;
			case "mat3x4f": return ce.mat3x4f;
			case "mat4x2f": return ce.mat4x2f;
			case "mat4x3f": return ce.mat4x3f;
			case "mat4x4f": return ce.mat4x4f;
			case "mat2x2h": return ce.mat2x2h;
			case "mat2x3h": return ce.mat2x3h;
			case "mat2x4h": return ce.mat2x4h;
			case "mat3x2h": return ce.mat3x2h;
			case "mat3x3h": return ce.mat3x3h;
			case "mat3x4h": return ce.mat3x4h;
			case "mat4x2h": return ce.mat4x2h;
			case "mat4x3h": return ce.mat4x3h;
			case "mat4x4h": return ce.mat4x4h;
			case "mat2x2i": return ce.mat2x2i;
			case "mat2x3i": return ce.mat2x3i;
			case "mat2x4i": return ce.mat2x4i;
			case "mat3x2i": return ce.mat3x2i;
			case "mat3x3i": return ce.mat3x3i;
			case "mat3x4i": return ce.mat3x4i;
			case "mat4x2i": return ce.mat4x2i;
			case "mat4x3i": return ce.mat4x3i;
			case "mat4x4i": return ce.mat4x4i;
			case "mat2x2u": return ce.mat2x2u;
			case "mat2x3u": return ce.mat2x3u;
			case "mat2x4u": return ce.mat2x4u;
			case "mat3x2u": return ce.mat3x2u;
			case "mat3x3u": return ce.mat3x3u;
			case "mat3x4u": return ce.mat3x4u;
			case "mat4x2u": return ce.mat4x2u;
			case "mat4x3u": return ce.mat4x3u;
			case "mat4x4u": return ce.mat4x4u;
		}
		return null;
	}
	_validateTypeRange(e$2, t$1) {
		if ("i32" === t$1.name) {
			if (e$2 < -2147483648 || e$2 > 2147483647) throw this._error(this._previous(), `Value out of range for i32: ${e$2}. Line: ${this._currentLine}.`);
		} else if ("u32" === t$1.name && (e$2 < 0 || e$2 > 4294967295)) throw this._error(this._previous(), `Value out of range for u32: ${e$2}. Line: ${this._currentLine}.`);
	}
	_primary_expression() {
		if (this._match(He.tokens.ident)) {
			const e$3 = this._previous().toString();
			if (this._check(He.tokens.paren_left)) {
				const t$2 = this._argument_expression_list(), n$1 = this._getType(e$3);
				return null !== n$1 ? this._updateNode(new de(n$1, t$2)) : this._updateNode(new me(e$3, t$2));
			}
			if (this._context.constants.has(e$3)) {
				const t$2 = this._context.constants.get(e$3);
				return this._updateNode(new _e(e$3, t$2.value));
			}
			return this._updateNode(new ge(e$3));
		}
		if (this._match(He.tokens.int_literal)) {
			const e$3 = this._previous().toString();
			let t$2 = e$3.endsWith("i") || e$3.endsWith("i") ? ae.i32 : e$3.endsWith("u") || e$3.endsWith("U") ? ae.u32 : ae.x32;
			const n$1 = parseInt(e$3);
			return this._validateTypeRange(n$1, t$2), this._updateNode(new xe(new Be(n$1, this._exec.getTypeInfo(t$2)), t$2));
		}
		if (this._match(He.tokens.uint_literal)) {
			const e$3 = parseInt(this._previous().toString());
			return this._validateTypeRange(e$3, ae.u32), this._updateNode(new xe(new Be(e$3, this._exec.getTypeInfo(ae.u32)), ae.u32));
		}
		if (this._match([He.tokens.decimal_float_literal, He.tokens.hex_float_literal])) {
			let e$3 = this._previous().toString(), t$2 = e$3.endsWith("h");
			t$2 && (e$3 = e$3.substring(0, e$3.length - 1));
			const n$1 = parseFloat(e$3);
			this._validateTypeRange(n$1, t$2 ? ae.f16 : ae.f32);
			const s$1 = t$2 ? ae.f16 : ae.f32;
			return this._updateNode(new xe(new Be(n$1, this._exec.getTypeInfo(s$1)), s$1));
		}
		if (this._match([He.keywords.true, He.keywords.false])) {
			let e$3 = this._previous().toString() === He.keywords.true.rule;
			return this._updateNode(new xe(new Be(e$3 ? 1 : 0, this._exec.getTypeInfo(ae.bool)), ae.bool));
		}
		if (this._check(He.tokens.paren_left)) return this._paren_expression();
		if (this._match(He.keywords.bitcast)) {
			this._consume(He.tokens.less_than, "Expected '<'.");
			const e$3 = this._type_decl();
			this._consume(He.tokens.greater_than, "Expected '>'.");
			const t$2 = this._paren_expression();
			return this._updateNode(new ye(e$3, t$2));
		}
		const e$2 = this._type_decl(), t$1 = this._argument_expression_list();
		return this._updateNode(new de(e$2, t$1));
	}
	_argument_expression_list() {
		if (!this._match(He.tokens.paren_left)) return null;
		const e$2 = [];
		do {
			if (this._check(He.tokens.paren_right)) break;
			const t$1 = this._short_circuit_or_expression();
			e$2.push(t$1);
		} while (this._match(He.tokens.comma));
		return this._consume(He.tokens.paren_right, "Expected ')' for agument list"), e$2;
	}
	_optional_paren_expression() {
		this._match(He.tokens.paren_left);
		const e$2 = this._short_circuit_or_expression();
		return this._match(He.tokens.paren_right), e$2;
	}
	_paren_expression() {
		this._consume(He.tokens.paren_left, "Expected '('.");
		const e$2 = this._short_circuit_or_expression();
		return this._consume(He.tokens.paren_right, "Expected ')'."), e$2;
	}
	_struct_decl() {
		if (!this._match(He.keywords.struct)) return null;
		const e$2 = this._currentLine, t$1 = this._consume(He.tokens.ident, "Expected name for struct.").toString();
		this._consume(He.tokens.brace_left, "Expected '{' for struct body.");
		const n$1 = [];
		for (; !this._check(He.tokens.brace_right);) {
			const e$3 = this._attribute(), t$2 = this._consume(He.tokens.name, "Expected variable name.").toString();
			this._consume(He.tokens.colon, "Expected ':' for struct member type.");
			const s$2 = this._attribute(), r$2 = this._type_decl();
			null != r$2 && (r$2.attributes = s$2), this._check(He.tokens.brace_right) ? this._match(He.tokens.comma) : this._consume(He.tokens.comma, "Expected ',' for struct member."), n$1.push(this._updateNode(new Ce(t$2, r$2, e$3)));
		}
		this._consume(He.tokens.brace_right, "Expected '}' after struct body.");
		const s$1 = this._currentLine, r$1 = this._updateNode(new oe(t$1, n$1, e$2, s$1), e$2);
		return this._context.structs.set(t$1, r$1), r$1;
	}
	_global_variable_decl() {
		const e$2 = this._variable_decl();
		if (!e$2) return null;
		if (this._match(He.tokens.equal)) e$2.value = this._const_expression();
		if (null !== e$2.type && e$2.value instanceof xe) {
			if ("x32" !== e$2.value.type.name) {
				if (e$2.type.getTypeName() !== e$2.value.type.getTypeName()) throw this._error(this._peek(), `Invalid cast from ${e$2.value.type.name} to ${e$2.type.name}. Line:${this._currentLine}`);
			}
			e$2.value.isScalar && this._validateTypeRange(e$2.value.scalarValue, e$2.type), e$2.value.type = e$2.type;
		} else null === e$2.type && e$2.value instanceof xe && (e$2.type = "x32" === e$2.value.type.name ? ae.i32 : e$2.value.type, e$2.value.isScalar && this._validateTypeRange(e$2.value.scalarValue, e$2.type));
		return e$2;
	}
	_override_variable_decl() {
		const e$2 = this._override_decl();
		return e$2 && this._match(He.tokens.equal) && (e$2.value = this._const_expression()), e$2;
	}
	_global_const_decl() {
		var e$2;
		if (!this._match(He.keywords.const)) return null;
		const t$1 = this._consume(He.tokens.name, "Expected variable name"), n$1 = this._currentLine;
		let s$1 = null;
		if (this._match(He.tokens.colon)) {
			const e$3 = this._attribute();
			s$1 = this._type_decl(), null != s$1 && (s$1.attributes = e$3);
		}
		let r$1 = null;
		this._consume(He.tokens.equal, "const declarations require an assignment");
		const i$1 = this._short_circuit_or_expression();
		try {
			let e$3 = [ae.f32], n$2 = i$1.constEvaluate(this._exec, e$3);
			n$2 instanceof Be && this._validateTypeRange(n$2.value, e$3[0]), e$3[0] instanceof ce && null === e$3[0].format && n$2.typeInfo instanceof a && null !== n$2.typeInfo.format && ("f16" === n$2.typeInfo.format.name ? e$3[0].format = ae.f16 : "f32" === n$2.typeInfo.format.name ? e$3[0].format = ae.f32 : "i32" === n$2.typeInfo.format.name ? e$3[0].format = ae.i32 : "u32" === n$2.typeInfo.format.name ? e$3[0].format = ae.u32 : "bool" === n$2.typeInfo.format.name ? e$3[0].format = ae.bool : console.error(`TODO: impelement template format type ${n$2.typeInfo.format.name}`)), r$1 = this._updateNode(new xe(n$2, e$3[0])), this._exec.context.setVariable(t$1.toString(), n$2);
		} catch (e$3) {
			r$1 = i$1;
		}
		if (null !== s$1 && r$1 instanceof xe) {
			if ("x32" !== r$1.type.name) {
				if (s$1.getTypeName() !== r$1.type.getTypeName()) throw this._error(this._peek(), `Invalid cast from ${r$1.type.name} to ${s$1.name}. Line:${this._currentLine}`);
			}
			r$1.type = s$1, r$1.isScalar && this._validateTypeRange(r$1.scalarValue, r$1.type);
		} else null === s$1 && r$1 instanceof xe && (s$1 = null !== (e$2 = null == r$1 ? void 0 : r$1.type) && void 0 !== e$2 ? e$2 : ae.f32, s$1 === ae.x32 && (s$1 = ae.i32));
		const o$1 = this._updateNode(new P(t$1.toString(), s$1, "", "", r$1), n$1);
		return this._context.constants.set(o$1.name, o$1), o$1;
	}
	_global_let_decl() {
		if (!this._match(He.keywords.let)) return null;
		const e$2 = this._currentLine, t$1 = this._consume(He.tokens.name, "Expected variable name");
		let n$1 = null;
		if (this._match(He.tokens.colon)) {
			const e$3 = this._attribute();
			n$1 = this._type_decl(), null != n$1 && (n$1.attributes = e$3);
		}
		let s$1 = null;
		if (this._match(He.tokens.equal) && (s$1 = this._const_expression()), null !== n$1 && s$1 instanceof xe) {
			if ("x32" !== s$1.type.name) {
				if (n$1.getTypeName() !== s$1.type.getTypeName()) throw this._error(this._peek(), `Invalid cast from ${s$1.type.name} to ${n$1.name}. Line:${this._currentLine}`);
			}
			s$1.type = n$1;
		} else null === n$1 && s$1 instanceof xe && (n$1 = "x32" === s$1.type.name ? ae.i32 : s$1.type);
		return s$1 instanceof xe && s$1.isScalar && this._validateTypeRange(s$1.scalarValue, n$1), this._updateNode(new U(t$1.toString(), n$1, "", "", s$1), e$2);
	}
	_const_expression() {
		return this._short_circuit_or_expression();
	}
	_variable_decl() {
		if (!this._match(He.keywords.var)) return null;
		const e$2 = this._currentLine;
		let t$1 = "", n$1 = "";
		this._match(He.tokens.less_than) && (t$1 = this._consume(He.storage_class, "Expected storage_class.").toString(), this._match(He.tokens.comma) && (n$1 = this._consume(He.access_mode, "Expected access_mode.").toString()), this._consume(He.tokens.greater_than, "Expected '>'."));
		const s$1 = this._consume(He.tokens.name, "Expected variable name");
		let r$1 = null;
		if (this._match(He.tokens.colon)) {
			const e$3 = this._attribute();
			r$1 = this._type_decl(), null != r$1 && (r$1.attributes = e$3);
		}
		return this._updateNode(new F(s$1.toString(), r$1, t$1, n$1, null), e$2);
	}
	_override_decl() {
		if (!this._match(He.keywords.override)) return null;
		const e$2 = this._consume(He.tokens.name, "Expected variable name");
		let t$1 = null;
		if (this._match(He.tokens.colon)) {
			const e$3 = this._attribute();
			t$1 = this._type_decl(), null != t$1 && (t$1.attributes = e$3);
		}
		return this._updateNode(new M(e$2.toString(), t$1, null));
	}
	_diagnostic() {
		this._consume(He.tokens.paren_left, "Expected '('");
		const e$2 = this._consume(He.tokens.ident, "Expected severity control name.");
		this._consume(He.tokens.comma, "Expected ','");
		let t$1 = this._consume(He.tokens.ident, "Expected diagnostic rule name.").toString();
		if (this._match(He.tokens.period)) t$1 += `.${this._consume(He.tokens.ident, "Expected diagnostic message.").toString()}`;
		return this._consume(He.tokens.paren_right, "Expected ')'"), this._updateNode(new ee(e$2.toString(), t$1));
	}
	_enable_directive() {
		const e$2 = this._consume(He.tokens.ident, "identity expected.");
		return this._updateNode(new K(e$2.toString()));
	}
	_requires_directive() {
		const e$2 = [this._consume(He.tokens.ident, "identity expected.").toString()];
		for (; this._match(He.tokens.comma);) {
			const t$1 = this._consume(He.tokens.ident, "identity expected.");
			e$2.push(t$1.toString());
		}
		return this._updateNode(new J(e$2));
	}
	_type_alias() {
		const e$2 = this._consume(He.tokens.ident, "identity expected.");
		this._consume(He.tokens.equal, "Expected '=' for type alias.");
		let t$1 = this._type_decl();
		if (null === t$1) throw this._error(this._peek(), "Expected Type for Alias.");
		this._context.aliases.has(t$1.name) && (t$1 = this._context.aliases.get(t$1.name).type);
		const n$1 = this._updateNode(new te(e$2.toString(), t$1));
		return this._context.aliases.set(n$1.name, n$1), n$1;
	}
	_type_decl() {
		if (this._check([
			He.tokens.ident,
			...He.texel_format,
			He.keywords.bool,
			He.keywords.f32,
			He.keywords.i32,
			He.keywords.u32
		])) {
			const e$3 = this._advance().toString();
			if (this._context.structs.has(e$3)) return this._context.structs.get(e$3);
			if (this._context.aliases.has(e$3)) return this._context.aliases.get(e$3).type;
			if (!this._getType(e$3)) {
				const t$2 = this._updateNode(new ie(e$3));
				return this._forwardTypeCount++, t$2;
			}
			return this._updateNode(new ae(e$3));
		}
		let e$2 = this._texture_sampler_types();
		if (e$2) return e$2;
		if (this._check(He.template_types)) {
			let e$3 = this._advance().toString(), t$2 = null, n$1 = null;
			this._match(He.tokens.less_than) && (t$2 = this._type_decl(), n$1 = null, this._match(He.tokens.comma) && (n$1 = this._consume(He.access_mode, "Expected access_mode for pointer").toString()), this._consume(He.tokens.greater_than, "Expected '>' for type."));
			return this._updateNode(new ce(e$3, t$2, n$1));
		}
		if (this._match(He.keywords.ptr)) {
			let e$3 = this._previous().toString();
			this._consume(He.tokens.less_than, "Expected '<' for pointer.");
			const t$2 = this._consume(He.storage_class, "Expected storage_class for pointer");
			this._consume(He.tokens.comma, "Expected ',' for pointer.");
			const n$1 = this._type_decl();
			let s$1 = null;
			this._match(He.tokens.comma) && (s$1 = this._consume(He.access_mode, "Expected access_mode for pointer").toString()), this._consume(He.tokens.greater_than, "Expected '>' for pointer.");
			return this._updateNode(new le(e$3, t$2.toString(), n$1, s$1));
		}
		const t$1 = this._attribute();
		if (this._match(He.keywords.array)) {
			let e$3 = null, n$1 = -1;
			const s$1 = this._previous();
			let r$1 = null;
			if (this._match(He.tokens.less_than)) {
				e$3 = this._type_decl(), this._context.aliases.has(e$3.name) && (e$3 = this._context.aliases.get(e$3.name).type);
				let t$2 = "";
				if (this._match(He.tokens.comma)) {
					r$1 = this._shift_expression();
					try {
						t$2 = r$1.constEvaluate(this._exec).toString(), r$1 = null;
					} catch (e$4) {
						t$2 = "1";
					}
				}
				this._consume(He.tokens.greater_than, "Expected '>' for array."), n$1 = t$2 ? parseInt(t$2) : 0;
			}
			const a$1 = this._updateNode(new ue(s$1.toString(), t$1, e$3, n$1));
			return r$1 && this._deferArrayCountEval.push({
				arrayType: a$1,
				countNode: r$1
			}), a$1;
		}
		return null;
	}
	_texture_sampler_types() {
		if (this._match(He.sampler_type)) return this._updateNode(new he(this._previous().toString(), null, null));
		if (this._match(He.depth_texture_type)) return this._updateNode(new he(this._previous().toString(), null, null));
		if (this._match(He.sampled_texture_type) || this._match(He.multisampled_texture_type)) {
			const e$2 = this._previous();
			this._consume(He.tokens.less_than, "Expected '<' for sampler type.");
			const t$1 = this._type_decl();
			return this._consume(He.tokens.greater_than, "Expected '>' for sampler type."), this._updateNode(new he(e$2.toString(), t$1, null));
		}
		if (this._match(He.storage_texture_type)) {
			const e$2 = this._previous();
			this._consume(He.tokens.less_than, "Expected '<' for sampler type.");
			const t$1 = this._consume(He.texel_format, "Invalid texel format.").toString();
			this._consume(He.tokens.comma, "Expected ',' after texel format.");
			const n$1 = this._consume(He.access_mode, "Expected access mode for storage texture type.").toString();
			return this._consume(He.tokens.greater_than, "Expected '>' for sampler type."), this._updateNode(new he(e$2.toString(), t$1, n$1));
		}
		return null;
	}
	_attribute() {
		let e$2 = [];
		for (; this._match(He.tokens.attr);) {
			const t$1 = this._consume(He.attribute_name, "Expected attribute name"), n$1 = this._updateNode(new De(t$1.toString(), null));
			if (this._match(He.tokens.paren_left)) {
				if (n$1.value = this._consume(He.literal_or_ident, "Expected attribute value").toString(), this._check(He.tokens.comma)) {
					this._advance();
					do {
						const e$3 = this._consume(He.literal_or_ident, "Expected attribute value").toString();
						n$1.value instanceof Array || (n$1.value = [n$1.value]), n$1.value.push(e$3);
					} while (this._match(He.tokens.comma));
				}
				this._consume(He.tokens.paren_right, "Expected ')'");
			}
			e$2.push(n$1);
		}
		return 0 == e$2.length ? null : e$2;
	}
};
var _t = class extends at {
	constructor(e$2) {
		super(), e$2 && this.update(e$2);
	}
	update(e$2) {
		const t$1 = new gt().parse(e$2);
		this.updateAST(t$1);
	}
};

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/lib/wgsl/get-shader-layout-wgsl.js
/**
* Parse a ShaderLayout from WGSL shader source code.
* @param source WGSL source code (can contain both @vertex and @fragment entry points)
* @returns
*/
function getShaderLayoutFromWGSL(source$2) {
	const shaderLayout = {
		attributes: [],
		bindings: []
	};
	let parsedWGSL;
	try {
		parsedWGSL = parseWGSL(source$2);
	} catch (error) {
		log.error(error.message)();
		return shaderLayout;
	}
	for (const uniform of parsedWGSL.uniforms) {
		const members = [];
		for (const attribute of uniform.type?.members || []) members.push({
			name: attribute.name,
			type: getType(attribute.type)
		});
		shaderLayout.bindings.push({
			type: "uniform",
			name: uniform.name,
			group: uniform.group,
			location: uniform.binding,
			members
		});
	}
	for (const texture of parsedWGSL.textures) shaderLayout.bindings.push({
		type: "texture",
		name: texture.name,
		group: texture.group,
		location: texture.binding
	});
	for (const sampler of parsedWGSL.samplers) shaderLayout.bindings.push({
		type: "sampler",
		name: sampler.name,
		group: sampler.group,
		location: sampler.binding
	});
	const vertex = parsedWGSL.entry.vertex[0];
	const attributeCount = vertex?.inputs.length || 0;
	for (let i$1 = 0; i$1 < attributeCount; i$1++) {
		const wgslAttribute = vertex.inputs[i$1];
		if (wgslAttribute.locationType === "location") {
			const type = getType(wgslAttribute.type);
			shaderLayout.attributes.push({
				name: wgslAttribute.name,
				location: Number(wgslAttribute.location),
				type
			});
		}
	}
	return shaderLayout;
}
/** Get a valid shader attribute type string from a wgsl-reflect type */
function getType(type) {
	return type?.format ? `${type.name}<${type.format.name}>` : type.name;
}
function parseWGSL(source$2) {
	try {
		return new _t(source$2);
	} catch (error) {
		if (error instanceof Error) throw error;
		let message = "WGSL parse error";
		if (typeof error === "object" && error?.message) message += `: ${error.message} `;
		if (typeof error === "object" && error?.token) message += error.token.line || "";
		throw new Error(message, { cause: error });
	}
}

//#endregion
//#region node_modules/@math.gl/core/dist/lib/common.js
var RADIANS_TO_DEGREES$2 = 1 / Math.PI * 180;
var DEGREES_TO_RADIANS$6 = 1 / 180 * Math.PI;
var DEFAULT_CONFIG = {
	EPSILON: 1e-12,
	debug: false,
	precision: 4,
	printTypes: false,
	printDegrees: false,
	printRowMajor: true,
	_cartographicRadians: false
};
globalThis.mathgl = globalThis.mathgl || { config: { ...DEFAULT_CONFIG } };
const config = globalThis.mathgl.config;
/**
* Formats a value into a string
* @param value
* @param param1
* @returns
*/
function formatValue(value, { precision = config.precision } = {}) {
	value = round(value);
	return `${parseFloat(value.toPrecision(precision))}`;
}
/**
* Check if value is an "array"
* Returns `true` if value is either an array or a typed array
* Note: returns `false` for `ArrayBuffer` and `DataView` instances
* @note isTypedArray and isNumericArray are often more useful in TypeScript
*/
function isArray$1(value) {
	return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
}
function radians(degrees$1, result) {
	return map(degrees$1, (degrees$2) => degrees$2 * DEGREES_TO_RADIANS$6, result);
}
function degrees(radians$1, result) {
	return map(radians$1, (radians$2) => radians$2 * RADIANS_TO_DEGREES$2, result);
}
function clamp(value, min, max) {
	return map(value, (value$1) => Math.max(min, Math.min(max, value$1)));
}
function lerp(a$1, b$1, t$1) {
	if (isArray$1(a$1)) return a$1.map((ai, i$1) => lerp(ai, b$1[i$1], t$1));
	return t$1 * b$1 + (1 - t$1) * a$1;
}
/**
* Compares any two math objects, using `equals` method if available.
* @param a
* @param b
* @param epsilon
* @returns
*/
function equals(a$1, b$1, epsilon) {
	const oldEpsilon = config.EPSILON;
	if (epsilon) config.EPSILON = epsilon;
	try {
		if (a$1 === b$1) return true;
		if (isArray$1(a$1) && isArray$1(b$1)) {
			if (a$1.length !== b$1.length) return false;
			for (let i$1 = 0; i$1 < a$1.length; ++i$1) if (!equals(a$1[i$1], b$1[i$1])) return false;
			return true;
		}
		if (a$1 && a$1.equals) return a$1.equals(b$1);
		if (b$1 && b$1.equals) return b$1.equals(a$1);
		if (typeof a$1 === "number" && typeof b$1 === "number") return Math.abs(a$1 - b$1) <= config.EPSILON * Math.max(1, Math.abs(a$1), Math.abs(b$1));
		return false;
	} finally {
		config.EPSILON = oldEpsilon;
	}
}
function round(value) {
	return Math.round(value / config.EPSILON) * config.EPSILON;
}
function duplicateArray(array) {
	return array.clone ? array.clone() : new Array(array.length);
}
function map(value, func, result) {
	if (isArray$1(value)) {
		const array = value;
		result = result || duplicateArray(array);
		for (let i$1 = 0; i$1 < result.length && i$1 < array.length; ++i$1) result[i$1] = func(typeof value === "number" ? value : value[i$1], i$1, result);
		return result;
	}
	return func(value);
}

//#endregion
//#region node_modules/@math.gl/core/dist/classes/base/math-array.js
/** Base class for vectors and matrices */
var MathArray = class extends Array {
	/**
	* Clone the current object
	* @returns a new copy of this object
	*/
	clone() {
		return new this.constructor().copy(this);
	}
	fromArray(array, offset = 0) {
		for (let i$1 = 0; i$1 < this.ELEMENTS; ++i$1) this[i$1] = array[i$1 + offset];
		return this.check();
	}
	toArray(targetArray = [], offset = 0) {
		for (let i$1 = 0; i$1 < this.ELEMENTS; ++i$1) targetArray[offset + i$1] = this[i$1];
		return targetArray;
	}
	toObject(targetObject) {
		return targetObject;
	}
	from(arrayOrObject) {
		return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : this.fromObject(arrayOrObject);
	}
	to(arrayOrObject) {
		if (arrayOrObject === this) return this;
		return isArray$1(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
	}
	toTarget(target) {
		return target ? this.to(target) : this;
	}
	/** @deprecated */
	toFloat32Array() {
		return new Float32Array(this);
	}
	toString() {
		return this.formatString(config);
	}
	/** Formats string according to options */
	formatString(opts) {
		let string = "";
		for (let i$1 = 0; i$1 < this.ELEMENTS; ++i$1) string += (i$1 > 0 ? ", " : "") + formatValue(this[i$1], opts);
		return `${opts.printTypes ? this.constructor.name : ""}[${string}]`;
	}
	equals(array) {
		if (!array || this.length !== array.length) return false;
		for (let i$1 = 0; i$1 < this.ELEMENTS; ++i$1) if (!equals(this[i$1], array[i$1])) return false;
		return true;
	}
	exactEquals(array) {
		if (!array || this.length !== array.length) return false;
		for (let i$1 = 0; i$1 < this.ELEMENTS; ++i$1) if (this[i$1] !== array[i$1]) return false;
		return true;
	}
	/** Negates all values in this object */
	negate() {
		for (let i$1 = 0; i$1 < this.ELEMENTS; ++i$1) this[i$1] = -this[i$1];
		return this.check();
	}
	lerp(a$1, b$1, t$1) {
		if (t$1 === void 0) return this.lerp(this, a$1, b$1);
		for (let i$1 = 0; i$1 < this.ELEMENTS; ++i$1) {
			const ai = a$1[i$1];
			this[i$1] = ai + t$1 * ((typeof b$1 === "number" ? b$1 : b$1[i$1]) - ai);
		}
		return this.check();
	}
	/** Minimal */
	min(vector) {
		for (let i$1 = 0; i$1 < this.ELEMENTS; ++i$1) this[i$1] = Math.min(vector[i$1], this[i$1]);
		return this.check();
	}
	/** Maximal */
	max(vector) {
		for (let i$1 = 0; i$1 < this.ELEMENTS; ++i$1) this[i$1] = Math.max(vector[i$1], this[i$1]);
		return this.check();
	}
	clamp(minVector, maxVector) {
		for (let i$1 = 0; i$1 < this.ELEMENTS; ++i$1) this[i$1] = Math.min(Math.max(this[i$1], minVector[i$1]), maxVector[i$1]);
		return this.check();
	}
	add(...vectors) {
		for (const vector of vectors) for (let i$1 = 0; i$1 < this.ELEMENTS; ++i$1) this[i$1] += vector[i$1];
		return this.check();
	}
	subtract(...vectors) {
		for (const vector of vectors) for (let i$1 = 0; i$1 < this.ELEMENTS; ++i$1) this[i$1] -= vector[i$1];
		return this.check();
	}
	scale(scale$3) {
		if (typeof scale$3 === "number") for (let i$1 = 0; i$1 < this.ELEMENTS; ++i$1) this[i$1] *= scale$3;
		else for (let i$1 = 0; i$1 < this.ELEMENTS && i$1 < scale$3.length; ++i$1) this[i$1] *= scale$3[i$1];
		return this.check();
	}
	/**
	* Multiplies all elements by `scale`
	* Note: `Matrix4.multiplyByScalar` only scales its 3x3 "minor"
	*/
	multiplyByScalar(scalar) {
		for (let i$1 = 0; i$1 < this.ELEMENTS; ++i$1) this[i$1] *= scalar;
		return this.check();
	}
	/** Throws an error if array length is incorrect or contains illegal values */
	check() {
		if (config.debug && !this.validate()) throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
		return this;
	}
	/** Returns false if the array length is incorrect or contains illegal values */
	validate() {
		let valid = this.length === this.ELEMENTS;
		for (let i$1 = 0; i$1 < this.ELEMENTS; ++i$1) valid = valid && Number.isFinite(this[i$1]);
		return valid;
	}
	/** @deprecated */
	sub(a$1) {
		return this.subtract(a$1);
	}
	/** @deprecated */
	setScalar(a$1) {
		for (let i$1 = 0; i$1 < this.ELEMENTS; ++i$1) this[i$1] = a$1;
		return this.check();
	}
	/** @deprecated */
	addScalar(a$1) {
		for (let i$1 = 0; i$1 < this.ELEMENTS; ++i$1) this[i$1] += a$1;
		return this.check();
	}
	/** @deprecated */
	subScalar(a$1) {
		return this.addScalar(-a$1);
	}
	/** @deprecated */
	multiplyScalar(scalar) {
		for (let i$1 = 0; i$1 < this.ELEMENTS; ++i$1) this[i$1] *= scalar;
		return this.check();
	}
	/** @deprecated */
	divideScalar(a$1) {
		return this.multiplyByScalar(1 / a$1);
	}
	/** @deprecated */
	clampScalar(min, max) {
		for (let i$1 = 0; i$1 < this.ELEMENTS; ++i$1) this[i$1] = Math.min(Math.max(this[i$1], min), max);
		return this.check();
	}
	/** @deprecated */
	get elements() {
		return this;
	}
};

//#endregion
//#region node_modules/@math.gl/core/dist/lib/validators.js
function validateVector(v$1, length$2) {
	if (v$1.length !== length$2) return false;
	for (let i$1 = 0; i$1 < v$1.length; ++i$1) if (!Number.isFinite(v$1[i$1])) return false;
	return true;
}
function checkNumber(value) {
	if (!Number.isFinite(value)) throw new Error(`Invalid number ${JSON.stringify(value)}`);
	return value;
}
function checkVector(v$1, length$2, callerName = "") {
	if (config.debug && !validateVector(v$1, length$2)) throw new Error(`math.gl: ${callerName} some fields set to invalid numbers'`);
	return v$1;
}

//#endregion
//#region node_modules/@math.gl/core/dist/lib/assert.js
function assert$2(condition, message) {
	if (!condition) throw new Error(`math.gl assertion ${message}`);
}

//#endregion
//#region node_modules/@math.gl/core/dist/classes/base/vector.js
/** Base class for vectors with at least 2 elements */
var Vector = class extends MathArray {
	get x() {
		return this[0];
	}
	set x(value) {
		this[0] = checkNumber(value);
	}
	get y() {
		return this[1];
	}
	set y(value) {
		this[1] = checkNumber(value);
	}
	/**
	* Returns the length of the vector from the origin to the point described by this vector
	*
	* @note `length` is a reserved word for Arrays, so `v.length()` will return number of elements
	* Instead we provide `len` and `magnitude`
	*/
	len() {
		return Math.sqrt(this.lengthSquared());
	}
	/**
	* Returns the length of the vector from the origin to the point described by this vector
	*/
	magnitude() {
		return this.len();
	}
	/**
	* Returns the squared length of the vector from the origin to the point described by this vector
	*/
	lengthSquared() {
		let length$2 = 0;
		for (let i$1 = 0; i$1 < this.ELEMENTS; ++i$1) length$2 += this[i$1] * this[i$1];
		return length$2;
	}
	/**
	* Returns the squared length of the vector from the origin to the point described by this vector
	*/
	magnitudeSquared() {
		return this.lengthSquared();
	}
	distance(mathArray) {
		return Math.sqrt(this.distanceSquared(mathArray));
	}
	distanceSquared(mathArray) {
		let length$2 = 0;
		for (let i$1 = 0; i$1 < this.ELEMENTS; ++i$1) {
			const dist = this[i$1] - mathArray[i$1];
			length$2 += dist * dist;
		}
		return checkNumber(length$2);
	}
	dot(mathArray) {
		let product = 0;
		for (let i$1 = 0; i$1 < this.ELEMENTS; ++i$1) product += this[i$1] * mathArray[i$1];
		return checkNumber(product);
	}
	normalize() {
		const length$2 = this.magnitude();
		if (length$2 !== 0) for (let i$1 = 0; i$1 < this.ELEMENTS; ++i$1) this[i$1] /= length$2;
		return this.check();
	}
	multiply(...vectors) {
		for (const vector of vectors) for (let i$1 = 0; i$1 < this.ELEMENTS; ++i$1) this[i$1] *= vector[i$1];
		return this.check();
	}
	divide(...vectors) {
		for (const vector of vectors) for (let i$1 = 0; i$1 < this.ELEMENTS; ++i$1) this[i$1] /= vector[i$1];
		return this.check();
	}
	lengthSq() {
		return this.lengthSquared();
	}
	distanceTo(vector) {
		return this.distance(vector);
	}
	distanceToSquared(vector) {
		return this.distanceSquared(vector);
	}
	getComponent(i$1) {
		assert$2(i$1 >= 0 && i$1 < this.ELEMENTS, "index is out of range");
		return checkNumber(this[i$1]);
	}
	setComponent(i$1, value) {
		assert$2(i$1 >= 0 && i$1 < this.ELEMENTS, "index is out of range");
		this[i$1] = value;
		return this.check();
	}
	addVectors(a$1, b$1) {
		return this.copy(a$1).add(b$1);
	}
	subVectors(a$1, b$1) {
		return this.copy(a$1).subtract(b$1);
	}
	multiplyVectors(a$1, b$1) {
		return this.copy(a$1).multiply(b$1);
	}
	addScaledVector(a$1, b$1) {
		return this.add(new this.constructor(a$1).multiplyScalar(b$1));
	}
};

//#endregion
//#region node_modules/@math.gl/core/dist/gl-matrix/common.js
/**
* Common utilities
* @module glMatrix
*/
const EPSILON$3 = 1e-6;
let ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var degree = Math.PI / 180;

//#endregion
//#region node_modules/@math.gl/core/dist/gl-matrix/vec2.js
/**
* 2 Dimensional Vector
* @module vec2
*/
/**
* Creates a new, empty vec2
*
* @returns a new 2D vector
*/
function create$2() {
	const out = new ARRAY_TYPE(2);
	if (ARRAY_TYPE != Float32Array) {
		out[0] = 0;
		out[1] = 0;
	}
	return out;
}
/**
* Adds two vec2's
*
* @param {NumericArray} out the receiving vector
* @param {Readonly<NumericArray>} a the first operand
* @param {Readonly<NumericArray>} b the second operand
* @returns {NumericArray} out
*/
function add$1(out, a$1, b$1) {
	out[0] = a$1[0] + b$1[0];
	out[1] = a$1[1] + b$1[1];
	return out;
}
/**
* Subtracts vector b from vector a
*
* @param {NumericArray} out the receiving vector
* @param {Readonly<NumericArray>} a the first operand
* @param {Readonly<NumericArray>} b the second operand
* @returns {NumericArray} out
*/
function subtract$1(out, a$1, b$1) {
	out[0] = a$1[0] - b$1[0];
	out[1] = a$1[1] - b$1[1];
	return out;
}
/**
* Scales a vec2 by a scalar number
*
* @param {NumericArray} out the receiving vector
* @param {Readonly<NumericArray>} a the vector to scale
* @param {Number} b amount to scale the vector by
* @returns {NumericArray} out
*/
function scale$2(out, a$1, b$1) {
	out[0] = a$1[0] * b$1;
	out[1] = a$1[1] * b$1;
	return out;
}
/**
* Calculates the length of a vec2
*
* @param {Readonly<NumericArray>} a vector to calculate length of
* @returns {Number} length of a
*/
function length$1(a$1) {
	const x$1 = a$1[0];
	const y$1 = a$1[1];
	return Math.sqrt(x$1 * x$1 + y$1 * y$1);
}
/**
* Negates the components of a vec2
*
* @param {NumericArray} out the receiving vector
* @param {Readonly<NumericArray>} a vector to negate
* @returns {NumericArray} out
*/
function negate$1(out, a$1) {
	out[0] = -a$1[0];
	out[1] = -a$1[1];
	return out;
}
/**
* Performs a linear interpolation between two vec2's
*
* @param {NumericArray} out the receiving vector
* @param {Readonly<NumericArray>} a the first operand
* @param {Readonly<NumericArray>} b the second operand
* @param {Number} t interpolation amount, in the range [0-1], between the two inputs
* @returns {NumericArray} out
*/
function lerp$3(out, a$1, b$1, t$1) {
	const ax = a$1[0];
	const ay = a$1[1];
	out[0] = ax + t$1 * (b$1[0] - ax);
	out[1] = ay + t$1 * (b$1[1] - ay);
	return out;
}
/**
* Transforms the vec2 with a mat4
* 3rd vector component is implicitly '0'
* 4th vector component is implicitly '1'
*
* @param {NumericArray} out the receiving vector
* @param {Readonly<NumericArray>} a the vector to transform
* @param {ReadonlyMat4} m matrix to transform with
* @returns {NumericArray} out
*/
function transformMat4(out, a$1, m$1) {
	const x$1 = a$1[0];
	const y$1 = a$1[1];
	out[0] = m$1[0] * x$1 + m$1[4] * y$1 + m$1[12];
	out[1] = m$1[1] * x$1 + m$1[5] * y$1 + m$1[13];
	return out;
}
/**
* Alias for {@link vec2.subtract}
* @function
*/
const sub$1 = subtract$1;
/**
* Perform some operation over an array of vec2s.
*
* @param {Array} a the array of vectors to iterate over
* @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
* @param {Number} offset Number of elements to skip at the beginning of the array
* @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
* @param {Function} fn Function to call for each vector in the array
* @param {Object} [arg] additional argument to pass to fn
* @returns {Array} a
* @function
*/
const forEach$2 = (function() {
	const vec = create$2();
	return function(a$1, stride, offset, count$1, fn, arg) {
		let i$1;
		let l$1;
		if (!stride) stride = 2;
		if (!offset) offset = 0;
		if (count$1) l$1 = Math.min(count$1 * stride + offset, a$1.length);
		else l$1 = a$1.length;
		for (i$1 = offset; i$1 < l$1; i$1 += stride) {
			vec[0] = a$1[i$1];
			vec[1] = a$1[i$1 + 1];
			fn(vec, vec, arg);
			a$1[i$1] = vec[0];
			a$1[i$1 + 1] = vec[1];
		}
		return a$1;
	};
})();

//#endregion
//#region node_modules/@math.gl/core/dist/lib/gl-matrix-extras.js
function vec2_transformMat4AsVector(out, a$1, m$1) {
	const x$1 = a$1[0];
	const y$1 = a$1[1];
	const w$1 = m$1[3] * x$1 + m$1[7] * y$1 || 1;
	out[0] = (m$1[0] * x$1 + m$1[4] * y$1) / w$1;
	out[1] = (m$1[1] * x$1 + m$1[5] * y$1) / w$1;
	return out;
}
function vec3_transformMat4AsVector(out, a$1, m$1) {
	const x$1 = a$1[0];
	const y$1 = a$1[1];
	const z$1 = a$1[2];
	const w$1 = m$1[3] * x$1 + m$1[7] * y$1 + m$1[11] * z$1 || 1;
	out[0] = (m$1[0] * x$1 + m$1[4] * y$1 + m$1[8] * z$1) / w$1;
	out[1] = (m$1[1] * x$1 + m$1[5] * y$1 + m$1[9] * z$1) / w$1;
	out[2] = (m$1[2] * x$1 + m$1[6] * y$1 + m$1[10] * z$1) / w$1;
	return out;
}
function vec3_transformMat2(out, a$1, m$1) {
	const x$1 = a$1[0];
	const y$1 = a$1[1];
	out[0] = m$1[0] * x$1 + m$1[2] * y$1;
	out[1] = m$1[1] * x$1 + m$1[3] * y$1;
	out[2] = a$1[2];
	return out;
}

//#endregion
//#region node_modules/@math.gl/core/dist/gl-matrix/vec3.js
/**
* 3 Dimensional Vector
* @module vec3
*/
/**
* Creates a new, empty vec3
*
* @returns {vec3} a new 3D vector
*/
function create$1() {
	const out = new ARRAY_TYPE(3);
	if (ARRAY_TYPE != Float32Array) {
		out[0] = 0;
		out[1] = 0;
		out[2] = 0;
	}
	return out;
}
/**
* Calculates the length of a vec3
*
* @param {ReadonlyVec3} a vector to calculate length of
* @returns {Number} length of a
*/
function length(a$1) {
	const x$1 = a$1[0];
	const y$1 = a$1[1];
	const z$1 = a$1[2];
	return Math.sqrt(x$1 * x$1 + y$1 * y$1 + z$1 * z$1);
}
/**
* Subtracts vector b from vector a
*
* @param {vec3} out the receiving vector
* @param {ReadonlyVec3} a the first operand
* @param {ReadonlyVec3} b the second operand
* @returns {vec3} out
*/
function subtract(out, a$1, b$1) {
	out[0] = a$1[0] - b$1[0];
	out[1] = a$1[1] - b$1[1];
	out[2] = a$1[2] - b$1[2];
	return out;
}
/**
* Calculates the squared length of a vec3
*
* @param {ReadonlyVec3} a vector to calculate squared length of
* @returns {Number} squared length of a
*/
function squaredLength(a$1) {
	const x$1 = a$1[0];
	const y$1 = a$1[1];
	const z$1 = a$1[2];
	return x$1 * x$1 + y$1 * y$1 + z$1 * z$1;
}
/**
* Negates the components of a vec3
*
* @param {vec3} out the receiving vector
* @param {ReadonlyVec3} a vector to negate
* @returns {vec3} out
*/
function negate(out, a$1) {
	out[0] = -a$1[0];
	out[1] = -a$1[1];
	out[2] = -a$1[2];
	return out;
}
/**
* Calculates the dot product of two vec3's
*
* @param {ReadonlyVec3} a the first operand
* @param {ReadonlyVec3} b the second operand
* @returns {Number} dot product of a and b
*/
function dot(a$1, b$1) {
	return a$1[0] * b$1[0] + a$1[1] * b$1[1] + a$1[2] * b$1[2];
}
/**
* Computes the cross product of two vec3's
*
* @param {vec3} out the receiving vector
* @param {ReadonlyVec3} a the first operand
* @param {ReadonlyVec3} b the second operand
* @returns {vec3} out
*/
function cross(out, a$1, b$1) {
	const ax = a$1[0];
	const ay = a$1[1];
	const az = a$1[2];
	const bx = b$1[0];
	const by = b$1[1];
	const bz = b$1[2];
	out[0] = ay * bz - az * by;
	out[1] = az * bx - ax * bz;
	out[2] = ax * by - ay * bx;
	return out;
}
/**
* Performs a linear interpolation between two vec3's
*
* @param {vec3} out the receiving vector
* @param {ReadonlyVec3} a the first operand
* @param {ReadonlyVec3} b the second operand
* @param {Number} t interpolation amount, in the range [0-1], between the two inputs
* @returns {vec3} out
*/
function lerp$2(out, a$1, b$1, t$1) {
	const ax = a$1[0];
	const ay = a$1[1];
	const az = a$1[2];
	out[0] = ax + t$1 * (b$1[0] - ax);
	out[1] = ay + t$1 * (b$1[1] - ay);
	out[2] = az + t$1 * (b$1[2] - az);
	return out;
}
/**
* Transforms the vec3 with a mat4.
* 4th vector component is implicitly '1'
*
* @param {vec3} out the receiving vector
* @param {ReadonlyVec3} a the vector to transform
* @param {ReadonlyMat4} m matrix to transform with
* @returns {vec3} out
*/
function transformMat4$1(out, a$1, m$1) {
	const x$1 = a$1[0];
	const y$1 = a$1[1];
	const z$1 = a$1[2];
	let w$1 = m$1[3] * x$1 + m$1[7] * y$1 + m$1[11] * z$1 + m$1[15];
	w$1 = w$1 || 1;
	out[0] = (m$1[0] * x$1 + m$1[4] * y$1 + m$1[8] * z$1 + m$1[12]) / w$1;
	out[1] = (m$1[1] * x$1 + m$1[5] * y$1 + m$1[9] * z$1 + m$1[13]) / w$1;
	out[2] = (m$1[2] * x$1 + m$1[6] * y$1 + m$1[10] * z$1 + m$1[14]) / w$1;
	return out;
}
/**
* Transforms the vec3 with a mat3.
*
* @param {vec3} out the receiving vector
* @param {ReadonlyVec3} a the vector to transform
* @param {ReadonlyMat3} m the 3x3 matrix to transform with
* @returns {vec3} out
*/
function transformMat3(out, a$1, m$1) {
	const x$1 = a$1[0];
	const y$1 = a$1[1];
	const z$1 = a$1[2];
	out[0] = x$1 * m$1[0] + y$1 * m$1[3] + z$1 * m$1[6];
	out[1] = x$1 * m$1[1] + y$1 * m$1[4] + z$1 * m$1[7];
	out[2] = x$1 * m$1[2] + y$1 * m$1[5] + z$1 * m$1[8];
	return out;
}
/**
* Transforms the vec3 with a quat
* Can also be used for dual quaternions. (Multiply it with the real part)
*
* @param {vec3} out the receiving vector
* @param {ReadonlyVec3} a the vector to transform
* @param {ReadonlyQuat} q quaternion to transform with
* @returns {vec3} out
*/
function transformQuat(out, a$1, q$1) {
	const qx = q$1[0];
	const qy = q$1[1];
	const qz = q$1[2];
	const qw = q$1[3];
	const x$1 = a$1[0];
	const y$1 = a$1[1];
	const z$1 = a$1[2];
	let uvx = qy * z$1 - qz * y$1;
	let uvy = qz * x$1 - qx * z$1;
	let uvz = qx * y$1 - qy * x$1;
	let uuvx = qy * uvz - qz * uvy;
	let uuvy = qz * uvx - qx * uvz;
	let uuvz = qx * uvy - qy * uvx;
	const w2 = qw * 2;
	uvx *= w2;
	uvy *= w2;
	uvz *= w2;
	uuvx *= 2;
	uuvy *= 2;
	uuvz *= 2;
	out[0] = x$1 + uvx + uuvx;
	out[1] = y$1 + uvy + uuvy;
	out[2] = z$1 + uvz + uuvz;
	return out;
}
/**
* Rotate a 3D vector around the x-axis
* @param {vec3} out The receiving vec3
* @param {ReadonlyVec3} a The vec3 point to rotate
* @param {ReadonlyVec3} b The origin of the rotation
* @param {Number} rad The angle of rotation in radians
* @returns {vec3} out
*/
function rotateX$1(out, a$1, b$1, rad) {
	const p$1 = [];
	const r$1 = [];
	p$1[0] = a$1[0] - b$1[0];
	p$1[1] = a$1[1] - b$1[1];
	p$1[2] = a$1[2] - b$1[2];
	r$1[0] = p$1[0];
	r$1[1] = p$1[1] * Math.cos(rad) - p$1[2] * Math.sin(rad);
	r$1[2] = p$1[1] * Math.sin(rad) + p$1[2] * Math.cos(rad);
	out[0] = r$1[0] + b$1[0];
	out[1] = r$1[1] + b$1[1];
	out[2] = r$1[2] + b$1[2];
	return out;
}
/**
* Rotate a 3D vector around the y-axis
* @param {vec3} out The receiving vec3
* @param {ReadonlyVec3} a The vec3 point to rotate
* @param {ReadonlyVec3} b The origin of the rotation
* @param {Number} rad The angle of rotation in radians
* @returns {vec3} out
*/
function rotateY$1(out, a$1, b$1, rad) {
	const p$1 = [];
	const r$1 = [];
	p$1[0] = a$1[0] - b$1[0];
	p$1[1] = a$1[1] - b$1[1];
	p$1[2] = a$1[2] - b$1[2];
	r$1[0] = p$1[2] * Math.sin(rad) + p$1[0] * Math.cos(rad);
	r$1[1] = p$1[1];
	r$1[2] = p$1[2] * Math.cos(rad) - p$1[0] * Math.sin(rad);
	out[0] = r$1[0] + b$1[0];
	out[1] = r$1[1] + b$1[1];
	out[2] = r$1[2] + b$1[2];
	return out;
}
/**
* Rotate a 3D vector around the z-axis
* @param {vec3} out The receiving vec3
* @param {ReadonlyVec3} a The vec3 point to rotate
* @param {ReadonlyVec3} b The origin of the rotation
* @param {Number} rad The angle of rotation in radians
* @returns {vec3} out
*/
function rotateZ$1(out, a$1, b$1, rad) {
	const p$1 = [];
	const r$1 = [];
	p$1[0] = a$1[0] - b$1[0];
	p$1[1] = a$1[1] - b$1[1];
	p$1[2] = a$1[2] - b$1[2];
	r$1[0] = p$1[0] * Math.cos(rad) - p$1[1] * Math.sin(rad);
	r$1[1] = p$1[0] * Math.sin(rad) + p$1[1] * Math.cos(rad);
	r$1[2] = p$1[2];
	out[0] = r$1[0] + b$1[0];
	out[1] = r$1[1] + b$1[1];
	out[2] = r$1[2] + b$1[2];
	return out;
}
/**
* Get the angle between two 3D vectors
* @param {ReadonlyVec3} a The first operand
* @param {ReadonlyVec3} b The second operand
* @returns {Number} The angle in radians
*/
function angle(a$1, b$1) {
	const ax = a$1[0];
	const ay = a$1[1];
	const az = a$1[2];
	const bx = b$1[0];
	const by = b$1[1];
	const bz = b$1[2];
	const mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz));
	const cosine = mag && dot(a$1, b$1) / mag;
	return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
* Alias for {@link vec3.subtract}
* @function
*/
const sub = subtract;
/**
* Alias for {@link vec3.length}
* @function
*/
const len = length;
/**
* Alias for {@link vec3.squaredLength}
* @function
*/
const sqrLen = squaredLength;
/**
* Perform some operation over an array of vec3s.
*
* @param {Array} a the array of vectors to iterate over
* @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
* @param {Number} offset Number of elements to skip at the beginning of the array
* @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
* @param {Function} fn Function to call for each vector in the array
* @param {Object} [arg] additional argument to pass to fn
* @returns {Array} a
* @function
*/
const forEach$1 = (function() {
	const vec = create$1();
	return function(a$1, stride, offset, count$1, fn, arg) {
		let i$1;
		let l$1;
		if (!stride) stride = 3;
		if (!offset) offset = 0;
		if (count$1) l$1 = Math.min(count$1 * stride + offset, a$1.length);
		else l$1 = a$1.length;
		for (i$1 = offset; i$1 < l$1; i$1 += stride) {
			vec[0] = a$1[i$1];
			vec[1] = a$1[i$1 + 1];
			vec[2] = a$1[i$1 + 2];
			fn(vec, vec, arg);
			a$1[i$1] = vec[0];
			a$1[i$1 + 1] = vec[1];
			a$1[i$1 + 2] = vec[2];
		}
		return a$1;
	};
})();

//#endregion
//#region node_modules/@math.gl/core/dist/classes/vector3.js
var ORIGIN = [
	0,
	0,
	0
];
var ZERO$1;
/**
* Three-element vector class with common linear algebra operations.
* Subclass of Array<number> meaning that it is highly compatible with other libraries
*/
var Vector3 = class Vector3 extends Vector {
	static get ZERO() {
		if (!ZERO$1) {
			ZERO$1 = new Vector3(0, 0, 0);
			Object.freeze(ZERO$1);
		}
		return ZERO$1;
	}
	/**
	* @class
	* @param x
	* @param y
	* @param z
	*/
	constructor(x$1 = 0, y$1 = 0, z$1 = 0) {
		super(-0, -0, -0);
		if (arguments.length === 1 && isArray$1(x$1)) this.copy(x$1);
		else {
			if (config.debug) {
				checkNumber(x$1);
				checkNumber(y$1);
				checkNumber(z$1);
			}
			this[0] = x$1;
			this[1] = y$1;
			this[2] = z$1;
		}
	}
	set(x$1, y$1, z$1) {
		this[0] = x$1;
		this[1] = y$1;
		this[2] = z$1;
		return this.check();
	}
	copy(array) {
		this[0] = array[0];
		this[1] = array[1];
		this[2] = array[2];
		return this.check();
	}
	fromObject(object) {
		if (config.debug) {
			checkNumber(object.x);
			checkNumber(object.y);
			checkNumber(object.z);
		}
		this[0] = object.x;
		this[1] = object.y;
		this[2] = object.z;
		return this.check();
	}
	toObject(object) {
		object.x = this[0];
		object.y = this[1];
		object.z = this[2];
		return object;
	}
	get ELEMENTS() {
		return 3;
	}
	get z() {
		return this[2];
	}
	set z(value) {
		this[2] = checkNumber(value);
	}
	angle(vector) {
		return angle(this, vector);
	}
	cross(vector) {
		cross(this, this, vector);
		return this.check();
	}
	rotateX({ radians: radians$1, origin = ORIGIN }) {
		rotateX$1(this, this, origin, radians$1);
		return this.check();
	}
	rotateY({ radians: radians$1, origin = ORIGIN }) {
		rotateY$1(this, this, origin, radians$1);
		return this.check();
	}
	rotateZ({ radians: radians$1, origin = ORIGIN }) {
		rotateZ$1(this, this, origin, radians$1);
		return this.check();
	}
	transform(matrix4) {
		return this.transformAsPoint(matrix4);
	}
	transformAsPoint(matrix4) {
		transformMat4$1(this, this, matrix4);
		return this.check();
	}
	transformAsVector(matrix4) {
		vec3_transformMat4AsVector(this, this, matrix4);
		return this.check();
	}
	transformByMatrix3(matrix3) {
		transformMat3(this, this, matrix3);
		return this.check();
	}
	transformByMatrix2(matrix2) {
		vec3_transformMat2(this, this, matrix2);
		return this.check();
	}
	transformByQuaternion(quaternion) {
		transformQuat(this, this, quaternion);
		return this.check();
	}
};

//#endregion
//#region node_modules/@math.gl/core/dist/classes/base/matrix.js
/** Base class for matrices */
var Matrix = class extends MathArray {
	toString() {
		let string = "[";
		if (config.printRowMajor) {
			string += "row-major:";
			for (let row = 0; row < this.RANK; ++row) for (let col = 0; col < this.RANK; ++col) string += ` ${this[col * this.RANK + row]}`;
		} else {
			string += "column-major:";
			for (let i$1 = 0; i$1 < this.ELEMENTS; ++i$1) string += ` ${this[i$1]}`;
		}
		string += "]";
		return string;
	}
	getElementIndex(row, col) {
		return col * this.RANK + row;
	}
	getElement(row, col) {
		return this[col * this.RANK + row];
	}
	setElement(row, col, value) {
		this[col * this.RANK + row] = checkNumber(value);
		return this;
	}
	getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
		const firstIndex = columnIndex * this.RANK;
		for (let i$1 = 0; i$1 < this.RANK; ++i$1) result[i$1] = this[firstIndex + i$1];
		return result;
	}
	setColumn(columnIndex, columnVector) {
		const firstIndex = columnIndex * this.RANK;
		for (let i$1 = 0; i$1 < this.RANK; ++i$1) this[firstIndex + i$1] = columnVector[i$1];
		return this;
	}
};

//#endregion
//#region node_modules/@math.gl/core/dist/gl-matrix/mat4.js
/**
* Set a mat4 to the identity matrix
*
* @param {mat4} out the receiving matrix
* @returns {mat4} out
*/
function identity(out) {
	out[0] = 1;
	out[1] = 0;
	out[2] = 0;
	out[3] = 0;
	out[4] = 0;
	out[5] = 1;
	out[6] = 0;
	out[7] = 0;
	out[8] = 0;
	out[9] = 0;
	out[10] = 1;
	out[11] = 0;
	out[12] = 0;
	out[13] = 0;
	out[14] = 0;
	out[15] = 1;
	return out;
}
/**
* Transpose the values of a mat4
*
* @param {mat4} out the receiving matrix
* @param {ReadonlyMat4} a the source matrix
* @returns {mat4} out
*/
function transpose(out, a$1) {
	if (out === a$1) {
		const a01 = a$1[1];
		const a02 = a$1[2];
		const a03 = a$1[3];
		const a12 = a$1[6];
		const a13 = a$1[7];
		const a23 = a$1[11];
		out[1] = a$1[4];
		out[2] = a$1[8];
		out[3] = a$1[12];
		out[4] = a01;
		out[6] = a$1[9];
		out[7] = a$1[13];
		out[8] = a02;
		out[9] = a12;
		out[11] = a$1[14];
		out[12] = a03;
		out[13] = a13;
		out[14] = a23;
	} else {
		out[0] = a$1[0];
		out[1] = a$1[4];
		out[2] = a$1[8];
		out[3] = a$1[12];
		out[4] = a$1[1];
		out[5] = a$1[5];
		out[6] = a$1[9];
		out[7] = a$1[13];
		out[8] = a$1[2];
		out[9] = a$1[6];
		out[10] = a$1[10];
		out[11] = a$1[14];
		out[12] = a$1[3];
		out[13] = a$1[7];
		out[14] = a$1[11];
		out[15] = a$1[15];
	}
	return out;
}
/**
* Inverts a mat4
*
* @param {mat4} out the receiving matrix
* @param {ReadonlyMat4} a the source matrix
* @returns {mat4} out
*/
function invert(out, a$1) {
	const a00 = a$1[0];
	const a01 = a$1[1];
	const a02 = a$1[2];
	const a03 = a$1[3];
	const a10 = a$1[4];
	const a11 = a$1[5];
	const a12 = a$1[6];
	const a13 = a$1[7];
	const a20 = a$1[8];
	const a21 = a$1[9];
	const a22 = a$1[10];
	const a23 = a$1[11];
	const a30 = a$1[12];
	const a31 = a$1[13];
	const a32 = a$1[14];
	const a33 = a$1[15];
	const b00 = a00 * a11 - a01 * a10;
	const b01 = a00 * a12 - a02 * a10;
	const b02 = a00 * a13 - a03 * a10;
	const b03 = a01 * a12 - a02 * a11;
	const b04 = a01 * a13 - a03 * a11;
	const b05 = a02 * a13 - a03 * a12;
	const b06 = a20 * a31 - a21 * a30;
	const b07 = a20 * a32 - a22 * a30;
	const b08 = a20 * a33 - a23 * a30;
	const b09 = a21 * a32 - a22 * a31;
	const b10 = a21 * a33 - a23 * a31;
	const b11 = a22 * a33 - a23 * a32;
	let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
	if (!det) return null;
	det = 1 / det;
	out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
	out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
	out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
	out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
	out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
	out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
	out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
	out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
	out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
	out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
	out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
	out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
	out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
	out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
	out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
	out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
	return out;
}
/**
* Calculates the determinant of a mat4
*
* @param {ReadonlyMat4} a the source matrix
* @returns {Number} determinant of a
*/
function determinant(a$1) {
	const a00 = a$1[0];
	const a01 = a$1[1];
	const a02 = a$1[2];
	const a03 = a$1[3];
	const a10 = a$1[4];
	const a11 = a$1[5];
	const a12 = a$1[6];
	const a13 = a$1[7];
	const a20 = a$1[8];
	const a21 = a$1[9];
	const a22 = a$1[10];
	const a23 = a$1[11];
	const a30 = a$1[12];
	const a31 = a$1[13];
	const a32 = a$1[14];
	const a33 = a$1[15];
	const b0 = a00 * a11 - a01 * a10;
	const b1 = a00 * a12 - a02 * a10;
	const b2 = a01 * a12 - a02 * a11;
	const b3 = a20 * a31 - a21 * a30;
	const b4 = a20 * a32 - a22 * a30;
	const b5 = a21 * a32 - a22 * a31;
	const b6 = a00 * b5 - a01 * b4 + a02 * b3;
	const b7 = a10 * b5 - a11 * b4 + a12 * b3;
	const b8 = a20 * b2 - a21 * b1 + a22 * b0;
	const b9 = a30 * b2 - a31 * b1 + a32 * b0;
	return a13 * b6 - a03 * b7 + a33 * b8 - a23 * b9;
}
/**
* Multiplies two mat4s
*
* @param {mat4} out the receiving matrix
* @param {ReadonlyMat4} a the first operand
* @param {ReadonlyMat4} b the second operand
* @returns {mat4} out
*/
function multiply(out, a$1, b$1) {
	const a00 = a$1[0];
	const a01 = a$1[1];
	const a02 = a$1[2];
	const a03 = a$1[3];
	const a10 = a$1[4];
	const a11 = a$1[5];
	const a12 = a$1[6];
	const a13 = a$1[7];
	const a20 = a$1[8];
	const a21 = a$1[9];
	const a22 = a$1[10];
	const a23 = a$1[11];
	const a30 = a$1[12];
	const a31 = a$1[13];
	const a32 = a$1[14];
	const a33 = a$1[15];
	let b0 = b$1[0];
	let b1 = b$1[1];
	let b2 = b$1[2];
	let b3 = b$1[3];
	out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	b0 = b$1[4];
	b1 = b$1[5];
	b2 = b$1[6];
	b3 = b$1[7];
	out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	b0 = b$1[8];
	b1 = b$1[9];
	b2 = b$1[10];
	b3 = b$1[11];
	out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	b0 = b$1[12];
	b1 = b$1[13];
	b2 = b$1[14];
	b3 = b$1[15];
	out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	return out;
}
/**
* Translate a mat4 by the given vector
*
* @param {mat4} out the receiving matrix
* @param {ReadonlyMat4} a the matrix to translate
* @param {ReadonlyVec3} v vector to translate by
* @returns {mat4} out
*/
function translate(out, a$1, v$1) {
	const x$1 = v$1[0];
	const y$1 = v$1[1];
	const z$1 = v$1[2];
	let a00;
	let a01;
	let a02;
	let a03;
	let a10;
	let a11;
	let a12;
	let a13;
	let a20;
	let a21;
	let a22;
	let a23;
	if (a$1 === out) {
		out[12] = a$1[0] * x$1 + a$1[4] * y$1 + a$1[8] * z$1 + a$1[12];
		out[13] = a$1[1] * x$1 + a$1[5] * y$1 + a$1[9] * z$1 + a$1[13];
		out[14] = a$1[2] * x$1 + a$1[6] * y$1 + a$1[10] * z$1 + a$1[14];
		out[15] = a$1[3] * x$1 + a$1[7] * y$1 + a$1[11] * z$1 + a$1[15];
	} else {
		a00 = a$1[0];
		a01 = a$1[1];
		a02 = a$1[2];
		a03 = a$1[3];
		a10 = a$1[4];
		a11 = a$1[5];
		a12 = a$1[6];
		a13 = a$1[7];
		a20 = a$1[8];
		a21 = a$1[9];
		a22 = a$1[10];
		a23 = a$1[11];
		out[0] = a00;
		out[1] = a01;
		out[2] = a02;
		out[3] = a03;
		out[4] = a10;
		out[5] = a11;
		out[6] = a12;
		out[7] = a13;
		out[8] = a20;
		out[9] = a21;
		out[10] = a22;
		out[11] = a23;
		out[12] = a00 * x$1 + a10 * y$1 + a20 * z$1 + a$1[12];
		out[13] = a01 * x$1 + a11 * y$1 + a21 * z$1 + a$1[13];
		out[14] = a02 * x$1 + a12 * y$1 + a22 * z$1 + a$1[14];
		out[15] = a03 * x$1 + a13 * y$1 + a23 * z$1 + a$1[15];
	}
	return out;
}
/**
* Scales the mat4 by the dimensions in the given vec3 not using vectorization
*
* @param {mat4} out the receiving matrix
* @param {ReadonlyMat4} a the matrix to scale
* @param {ReadonlyVec3} v the vec3 to scale the matrix by
* @returns {mat4} out
**/
function scale(out, a$1, v$1) {
	const x$1 = v$1[0];
	const y$1 = v$1[1];
	const z$1 = v$1[2];
	out[0] = a$1[0] * x$1;
	out[1] = a$1[1] * x$1;
	out[2] = a$1[2] * x$1;
	out[3] = a$1[3] * x$1;
	out[4] = a$1[4] * y$1;
	out[5] = a$1[5] * y$1;
	out[6] = a$1[6] * y$1;
	out[7] = a$1[7] * y$1;
	out[8] = a$1[8] * z$1;
	out[9] = a$1[9] * z$1;
	out[10] = a$1[10] * z$1;
	out[11] = a$1[11] * z$1;
	out[12] = a$1[12];
	out[13] = a$1[13];
	out[14] = a$1[14];
	out[15] = a$1[15];
	return out;
}
/**
* Rotates a mat4 by the given angle around the given axis
*
* @param {mat4} out the receiving matrix
* @param {ReadonlyMat4} a the matrix to rotate
* @param {Number} rad the angle to rotate the matrix by
* @param {ReadonlyVec3} axis the axis to rotate around
* @returns {mat4} out
*/
function rotate(out, a$1, rad, axis) {
	let x$1 = axis[0];
	let y$1 = axis[1];
	let z$1 = axis[2];
	let len$1 = Math.sqrt(x$1 * x$1 + y$1 * y$1 + z$1 * z$1);
	let c$1;
	let s$1;
	let t$1;
	let a00;
	let a01;
	let a02;
	let a03;
	let a10;
	let a11;
	let a12;
	let a13;
	let a20;
	let a21;
	let a22;
	let a23;
	let b00;
	let b01;
	let b02;
	let b10;
	let b11;
	let b12;
	let b20;
	let b21;
	let b22;
	if (len$1 < EPSILON$3) return null;
	len$1 = 1 / len$1;
	x$1 *= len$1;
	y$1 *= len$1;
	z$1 *= len$1;
	s$1 = Math.sin(rad);
	c$1 = Math.cos(rad);
	t$1 = 1 - c$1;
	a00 = a$1[0];
	a01 = a$1[1];
	a02 = a$1[2];
	a03 = a$1[3];
	a10 = a$1[4];
	a11 = a$1[5];
	a12 = a$1[6];
	a13 = a$1[7];
	a20 = a$1[8];
	a21 = a$1[9];
	a22 = a$1[10];
	a23 = a$1[11];
	b00 = x$1 * x$1 * t$1 + c$1;
	b01 = y$1 * x$1 * t$1 + z$1 * s$1;
	b02 = z$1 * x$1 * t$1 - y$1 * s$1;
	b10 = x$1 * y$1 * t$1 - z$1 * s$1;
	b11 = y$1 * y$1 * t$1 + c$1;
	b12 = z$1 * y$1 * t$1 + x$1 * s$1;
	b20 = x$1 * z$1 * t$1 + y$1 * s$1;
	b21 = y$1 * z$1 * t$1 - x$1 * s$1;
	b22 = z$1 * z$1 * t$1 + c$1;
	out[0] = a00 * b00 + a10 * b01 + a20 * b02;
	out[1] = a01 * b00 + a11 * b01 + a21 * b02;
	out[2] = a02 * b00 + a12 * b01 + a22 * b02;
	out[3] = a03 * b00 + a13 * b01 + a23 * b02;
	out[4] = a00 * b10 + a10 * b11 + a20 * b12;
	out[5] = a01 * b10 + a11 * b11 + a21 * b12;
	out[6] = a02 * b10 + a12 * b11 + a22 * b12;
	out[7] = a03 * b10 + a13 * b11 + a23 * b12;
	out[8] = a00 * b20 + a10 * b21 + a20 * b22;
	out[9] = a01 * b20 + a11 * b21 + a21 * b22;
	out[10] = a02 * b20 + a12 * b21 + a22 * b22;
	out[11] = a03 * b20 + a13 * b21 + a23 * b22;
	if (a$1 !== out) {
		out[12] = a$1[12];
		out[13] = a$1[13];
		out[14] = a$1[14];
		out[15] = a$1[15];
	}
	return out;
}
/**
* Rotates a matrix by the given angle around the X axis
*
* @param {mat4} out the receiving matrix
* @param {ReadonlyMat4} a the matrix to rotate
* @param {Number} rad the angle to rotate the matrix by
* @returns {mat4} out
*/
function rotateX(out, a$1, rad) {
	const s$1 = Math.sin(rad);
	const c$1 = Math.cos(rad);
	const a10 = a$1[4];
	const a11 = a$1[5];
	const a12 = a$1[6];
	const a13 = a$1[7];
	const a20 = a$1[8];
	const a21 = a$1[9];
	const a22 = a$1[10];
	const a23 = a$1[11];
	if (a$1 !== out) {
		out[0] = a$1[0];
		out[1] = a$1[1];
		out[2] = a$1[2];
		out[3] = a$1[3];
		out[12] = a$1[12];
		out[13] = a$1[13];
		out[14] = a$1[14];
		out[15] = a$1[15];
	}
	out[4] = a10 * c$1 + a20 * s$1;
	out[5] = a11 * c$1 + a21 * s$1;
	out[6] = a12 * c$1 + a22 * s$1;
	out[7] = a13 * c$1 + a23 * s$1;
	out[8] = a20 * c$1 - a10 * s$1;
	out[9] = a21 * c$1 - a11 * s$1;
	out[10] = a22 * c$1 - a12 * s$1;
	out[11] = a23 * c$1 - a13 * s$1;
	return out;
}
/**
* Rotates a matrix by the given angle around the Y axis
*
* @param {mat4} out the receiving matrix
* @param {ReadonlyMat4} a the matrix to rotate
* @param {Number} rad the angle to rotate the matrix by
* @returns {mat4} out
*/
function rotateY(out, a$1, rad) {
	const s$1 = Math.sin(rad);
	const c$1 = Math.cos(rad);
	const a00 = a$1[0];
	const a01 = a$1[1];
	const a02 = a$1[2];
	const a03 = a$1[3];
	const a20 = a$1[8];
	const a21 = a$1[9];
	const a22 = a$1[10];
	const a23 = a$1[11];
	if (a$1 !== out) {
		out[4] = a$1[4];
		out[5] = a$1[5];
		out[6] = a$1[6];
		out[7] = a$1[7];
		out[12] = a$1[12];
		out[13] = a$1[13];
		out[14] = a$1[14];
		out[15] = a$1[15];
	}
	out[0] = a00 * c$1 - a20 * s$1;
	out[1] = a01 * c$1 - a21 * s$1;
	out[2] = a02 * c$1 - a22 * s$1;
	out[3] = a03 * c$1 - a23 * s$1;
	out[8] = a00 * s$1 + a20 * c$1;
	out[9] = a01 * s$1 + a21 * c$1;
	out[10] = a02 * s$1 + a22 * c$1;
	out[11] = a03 * s$1 + a23 * c$1;
	return out;
}
/**
* Rotates a matrix by the given angle around the Z axis
*
* @param {mat4} out the receiving matrix
* @param {ReadonlyMat4} a the matrix to rotate
* @param {Number} rad the angle to rotate the matrix by
* @returns {mat4} out
*/
function rotateZ(out, a$1, rad) {
	const s$1 = Math.sin(rad);
	const c$1 = Math.cos(rad);
	const a00 = a$1[0];
	const a01 = a$1[1];
	const a02 = a$1[2];
	const a03 = a$1[3];
	const a10 = a$1[4];
	const a11 = a$1[5];
	const a12 = a$1[6];
	const a13 = a$1[7];
	if (a$1 !== out) {
		out[8] = a$1[8];
		out[9] = a$1[9];
		out[10] = a$1[10];
		out[11] = a$1[11];
		out[12] = a$1[12];
		out[13] = a$1[13];
		out[14] = a$1[14];
		out[15] = a$1[15];
	}
	out[0] = a00 * c$1 + a10 * s$1;
	out[1] = a01 * c$1 + a11 * s$1;
	out[2] = a02 * c$1 + a12 * s$1;
	out[3] = a03 * c$1 + a13 * s$1;
	out[4] = a10 * c$1 - a00 * s$1;
	out[5] = a11 * c$1 - a01 * s$1;
	out[6] = a12 * c$1 - a02 * s$1;
	out[7] = a13 * c$1 - a03 * s$1;
	return out;
}
/**
* Calculates a 4x4 matrix from the given quaternion
*
* @param {mat4} out mat4 receiving operation result
* @param {ReadonlyQuat} q Quaternion to create matrix from
*
* @returns {mat4} out
*/
function fromQuat(out, q$1) {
	const x$1 = q$1[0];
	const y$1 = q$1[1];
	const z$1 = q$1[2];
	const w$1 = q$1[3];
	const x2 = x$1 + x$1;
	const y2 = y$1 + y$1;
	const z2 = z$1 + z$1;
	const xx = x$1 * x2;
	const yx = y$1 * x2;
	const yy = y$1 * y2;
	const zx = z$1 * x2;
	const zy = z$1 * y2;
	const zz = z$1 * z2;
	const wx = w$1 * x2;
	const wy = w$1 * y2;
	const wz = w$1 * z2;
	out[0] = 1 - yy - zz;
	out[1] = yx + wz;
	out[2] = zx - wy;
	out[3] = 0;
	out[4] = yx - wz;
	out[5] = 1 - xx - zz;
	out[6] = zy + wx;
	out[7] = 0;
	out[8] = zx + wy;
	out[9] = zy - wx;
	out[10] = 1 - xx - yy;
	out[11] = 0;
	out[12] = 0;
	out[13] = 0;
	out[14] = 0;
	out[15] = 1;
	return out;
}
/**
* Generates a frustum matrix with the given bounds
*
* @param {mat4} out mat4 frustum matrix will be written into
* @param {Number} left Left bound of the frustum
* @param {Number} right Right bound of the frustum
* @param {Number} bottom Bottom bound of the frustum
* @param {Number} top Top bound of the frustum
* @param {Number} near Near bound of the frustum
* @param {Number} far Far bound of the frustum
* @returns {mat4} out
*/
function frustum(out, left, right, bottom, top, near, far) {
	const rl = 1 / (right - left);
	const tb = 1 / (top - bottom);
	const nf = 1 / (near - far);
	out[0] = near * 2 * rl;
	out[1] = 0;
	out[2] = 0;
	out[3] = 0;
	out[4] = 0;
	out[5] = near * 2 * tb;
	out[6] = 0;
	out[7] = 0;
	out[8] = (right + left) * rl;
	out[9] = (top + bottom) * tb;
	out[10] = (far + near) * nf;
	out[11] = -1;
	out[12] = 0;
	out[13] = 0;
	out[14] = far * near * 2 * nf;
	out[15] = 0;
	return out;
}
/**
* Generates a perspective projection matrix with the given bounds.
* The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
* which matches WebGL/OpenGL's clip volume.
* Passing null/undefined/no value for far will generate infinite projection matrix.
*
* @param {mat4} out mat4 frustum matrix will be written into
* @param {number} fovy Vertical field of view in radians
* @param {number} aspect Aspect ratio. typically viewport width/height
* @param {number} near Near bound of the frustum
* @param {number} far Far bound of the frustum, can be null or Infinity
* @returns {mat4} out
*/
function perspectiveNO(out, fovy, aspect, near, far) {
	const f$1 = 1 / Math.tan(fovy / 2);
	out[0] = f$1 / aspect;
	out[1] = 0;
	out[2] = 0;
	out[3] = 0;
	out[4] = 0;
	out[5] = f$1;
	out[6] = 0;
	out[7] = 0;
	out[8] = 0;
	out[9] = 0;
	out[11] = -1;
	out[12] = 0;
	out[13] = 0;
	out[15] = 0;
	if (far != null && far !== Infinity) {
		const nf = 1 / (near - far);
		out[10] = (far + near) * nf;
		out[14] = 2 * far * near * nf;
	} else {
		out[10] = -1;
		out[14] = -2 * near;
	}
	return out;
}
/**
* Alias for {@link mat4.perspectiveNO}
* @function
*/
const perspective = perspectiveNO;
/**
* Generates a orthogonal projection matrix with the given bounds.
* The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
* which matches WebGL/OpenGL's clip volume.
*
* @param {mat4} out mat4 frustum matrix will be written into
* @param {number} left Left bound of the frustum
* @param {number} right Right bound of the frustum
* @param {number} bottom Bottom bound of the frustum
* @param {number} top Top bound of the frustum
* @param {number} near Near bound of the frustum
* @param {number} far Far bound of the frustum
* @returns {mat4} out
*/
function orthoNO(out, left, right, bottom, top, near, far) {
	const lr = 1 / (left - right);
	const bt = 1 / (bottom - top);
	const nf = 1 / (near - far);
	out[0] = -2 * lr;
	out[1] = 0;
	out[2] = 0;
	out[3] = 0;
	out[4] = 0;
	out[5] = -2 * bt;
	out[6] = 0;
	out[7] = 0;
	out[8] = 0;
	out[9] = 0;
	out[10] = 2 * nf;
	out[11] = 0;
	out[12] = (left + right) * lr;
	out[13] = (top + bottom) * bt;
	out[14] = (far + near) * nf;
	out[15] = 1;
	return out;
}
/**
* Alias for {@link mat4.orthoNO}
* @function
*/
const ortho = orthoNO;
/**
* Generates a look-at matrix with the given eye position, focal point, and up axis.
* If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
*
* @param {mat4} out mat4 frustum matrix will be written into
* @param {ReadonlyVec3} eye Position of the viewer
* @param {ReadonlyVec3} center Point the viewer is looking at
* @param {ReadonlyVec3} up vec3 pointing up
* @returns {mat4} out
*/
function lookAt(out, eye, center, up) {
	let len$1;
	let x0;
	let x1;
	let x2;
	let y0;
	let y1;
	let y2;
	let z0;
	let z1;
	let z2;
	const eyex = eye[0];
	const eyey = eye[1];
	const eyez = eye[2];
	const upx = up[0];
	const upy = up[1];
	const upz = up[2];
	const centerx = center[0];
	const centery = center[1];
	const centerz = center[2];
	if (Math.abs(eyex - centerx) < EPSILON$3 && Math.abs(eyey - centery) < EPSILON$3 && Math.abs(eyez - centerz) < EPSILON$3) return identity(out);
	z0 = eyex - centerx;
	z1 = eyey - centery;
	z2 = eyez - centerz;
	len$1 = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
	z0 *= len$1;
	z1 *= len$1;
	z2 *= len$1;
	x0 = upy * z2 - upz * z1;
	x1 = upz * z0 - upx * z2;
	x2 = upx * z1 - upy * z0;
	len$1 = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
	if (!len$1) {
		x0 = 0;
		x1 = 0;
		x2 = 0;
	} else {
		len$1 = 1 / len$1;
		x0 *= len$1;
		x1 *= len$1;
		x2 *= len$1;
	}
	y0 = z1 * x2 - z2 * x1;
	y1 = z2 * x0 - z0 * x2;
	y2 = z0 * x1 - z1 * x0;
	len$1 = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
	if (!len$1) {
		y0 = 0;
		y1 = 0;
		y2 = 0;
	} else {
		len$1 = 1 / len$1;
		y0 *= len$1;
		y1 *= len$1;
		y2 *= len$1;
	}
	out[0] = x0;
	out[1] = y0;
	out[2] = z0;
	out[3] = 0;
	out[4] = x1;
	out[5] = y1;
	out[6] = z1;
	out[7] = 0;
	out[8] = x2;
	out[9] = y2;
	out[10] = z2;
	out[11] = 0;
	out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
	out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
	out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
	out[15] = 1;
	return out;
}

//#endregion
//#region node_modules/@math.gl/core/dist/gl-matrix/vec4.js
/**
* 4 Dimensional Vector
* @module vec4
*/
/**
* Creates a new, empty vec4
*
* @returns {vec4} a new 4D vector
*/
function create() {
	const out = new ARRAY_TYPE(4);
	if (ARRAY_TYPE != Float32Array) {
		out[0] = 0;
		out[1] = 0;
		out[2] = 0;
		out[3] = 0;
	}
	return out;
}
/**
* Scales a vec4 by a scalar number
*
* @param {vec4} out the receiving vector
* @param {ReadonlyVec4} a the vector to scale
* @param {Number} b amount to scale the vector by
* @returns {vec4} out
*/
function scale$1(out, a$1, b$1) {
	out[0] = a$1[0] * b$1;
	out[1] = a$1[1] * b$1;
	out[2] = a$1[2] * b$1;
	out[3] = a$1[3] * b$1;
	return out;
}
/**
* Transforms the vec4 with a mat4.
*
* @param {vec4} out the receiving vector
* @param {ReadonlyVec4} a the vector to transform
* @param {ReadonlyMat4} m matrix to transform with
* @returns {vec4} out
*/
function transformMat4$2(out, a$1, m$1) {
	const x$1 = a$1[0];
	const y$1 = a$1[1];
	const z$1 = a$1[2];
	const w$1 = a$1[3];
	out[0] = m$1[0] * x$1 + m$1[4] * y$1 + m$1[8] * z$1 + m$1[12] * w$1;
	out[1] = m$1[1] * x$1 + m$1[5] * y$1 + m$1[9] * z$1 + m$1[13] * w$1;
	out[2] = m$1[2] * x$1 + m$1[6] * y$1 + m$1[10] * z$1 + m$1[14] * w$1;
	out[3] = m$1[3] * x$1 + m$1[7] * y$1 + m$1[11] * z$1 + m$1[15] * w$1;
	return out;
}
/**
* Perform some operation over an array of vec4s.
*
* @param {Array} a the array of vectors to iterate over
* @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
* @param {Number} offset Number of elements to skip at the beginning of the array
* @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
* @param {Function} fn Function to call for each vector in the array
* @param {Object} [arg] additional argument to pass to fn
* @returns {Array} a
* @function
*/
const forEach = (function() {
	const vec = create();
	return function(a$1, stride, offset, count$1, fn, arg) {
		let i$1;
		let l$1;
		if (!stride) stride = 4;
		if (!offset) offset = 0;
		if (count$1) l$1 = Math.min(count$1 * stride + offset, a$1.length);
		else l$1 = a$1.length;
		for (i$1 = offset; i$1 < l$1; i$1 += stride) {
			vec[0] = a$1[i$1];
			vec[1] = a$1[i$1 + 1];
			vec[2] = a$1[i$1 + 2];
			vec[3] = a$1[i$1 + 3];
			fn(vec, vec, arg);
			a$1[i$1] = vec[0];
			a$1[i$1 + 1] = vec[1];
			a$1[i$1 + 2] = vec[2];
			a$1[i$1 + 3] = vec[3];
		}
		return a$1;
	};
})();

//#endregion
//#region node_modules/@math.gl/core/dist/classes/matrix4.js
var INDICES;
(function(INDICES$1) {
	INDICES$1[INDICES$1["COL0ROW0"] = 0] = "COL0ROW0";
	INDICES$1[INDICES$1["COL0ROW1"] = 1] = "COL0ROW1";
	INDICES$1[INDICES$1["COL0ROW2"] = 2] = "COL0ROW2";
	INDICES$1[INDICES$1["COL0ROW3"] = 3] = "COL0ROW3";
	INDICES$1[INDICES$1["COL1ROW0"] = 4] = "COL1ROW0";
	INDICES$1[INDICES$1["COL1ROW1"] = 5] = "COL1ROW1";
	INDICES$1[INDICES$1["COL1ROW2"] = 6] = "COL1ROW2";
	INDICES$1[INDICES$1["COL1ROW3"] = 7] = "COL1ROW3";
	INDICES$1[INDICES$1["COL2ROW0"] = 8] = "COL2ROW0";
	INDICES$1[INDICES$1["COL2ROW1"] = 9] = "COL2ROW1";
	INDICES$1[INDICES$1["COL2ROW2"] = 10] = "COL2ROW2";
	INDICES$1[INDICES$1["COL2ROW3"] = 11] = "COL2ROW3";
	INDICES$1[INDICES$1["COL3ROW0"] = 12] = "COL3ROW0";
	INDICES$1[INDICES$1["COL3ROW1"] = 13] = "COL3ROW1";
	INDICES$1[INDICES$1["COL3ROW2"] = 14] = "COL3ROW2";
	INDICES$1[INDICES$1["COL3ROW3"] = 15] = "COL3ROW3";
})(INDICES || (INDICES = {}));
var DEFAULT_FOVY = 45 * Math.PI / 180;
var DEFAULT_ASPECT = 1;
var DEFAULT_NEAR = .1;
var DEFAULT_FAR = 500;
var IDENTITY_MATRIX$1 = Object.freeze([
	1,
	0,
	0,
	0,
	0,
	1,
	0,
	0,
	0,
	0,
	1,
	0,
	0,
	0,
	0,
	1
]);
/**
* A 4x4 matrix with common linear algebra operations
* Subclass of Array<number> meaning that it is highly compatible with other libraries
*/
var Matrix4 = class extends Matrix {
	static get IDENTITY() {
		return getIdentityMatrix();
	}
	static get ZERO() {
		return getZeroMatrix();
	}
	get ELEMENTS() {
		return 16;
	}
	get RANK() {
		return 4;
	}
	get INDICES() {
		return INDICES;
	}
	constructor(array) {
		super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);
		if (arguments.length === 1 && Array.isArray(array)) this.copy(array);
		else this.identity();
	}
	copy(array) {
		this[0] = array[0];
		this[1] = array[1];
		this[2] = array[2];
		this[3] = array[3];
		this[4] = array[4];
		this[5] = array[5];
		this[6] = array[6];
		this[7] = array[7];
		this[8] = array[8];
		this[9] = array[9];
		this[10] = array[10];
		this[11] = array[11];
		this[12] = array[12];
		this[13] = array[13];
		this[14] = array[14];
		this[15] = array[15];
		return this.check();
	}
	set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
		this[0] = m00;
		this[1] = m10;
		this[2] = m20;
		this[3] = m30;
		this[4] = m01;
		this[5] = m11;
		this[6] = m21;
		this[7] = m31;
		this[8] = m02;
		this[9] = m12;
		this[10] = m22;
		this[11] = m32;
		this[12] = m03;
		this[13] = m13;
		this[14] = m23;
		this[15] = m33;
		return this.check();
	}
	setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
		this[0] = m00;
		this[1] = m10;
		this[2] = m20;
		this[3] = m30;
		this[4] = m01;
		this[5] = m11;
		this[6] = m21;
		this[7] = m31;
		this[8] = m02;
		this[9] = m12;
		this[10] = m22;
		this[11] = m32;
		this[12] = m03;
		this[13] = m13;
		this[14] = m23;
		this[15] = m33;
		return this.check();
	}
	toRowMajor(result) {
		result[0] = this[0];
		result[1] = this[4];
		result[2] = this[8];
		result[3] = this[12];
		result[4] = this[1];
		result[5] = this[5];
		result[6] = this[9];
		result[7] = this[13];
		result[8] = this[2];
		result[9] = this[6];
		result[10] = this[10];
		result[11] = this[14];
		result[12] = this[3];
		result[13] = this[7];
		result[14] = this[11];
		result[15] = this[15];
		return result;
	}
	/** Set to identity matrix */
	identity() {
		return this.copy(IDENTITY_MATRIX$1);
	}
	/**
	*
	* @param object
	* @returns self
	*/
	fromObject(object) {
		return this.check();
	}
	/**
	* Calculates a 4x4 matrix from the given quaternion
	* @param quaternion Quaternion to create matrix from
	* @returns self
	*/
	fromQuaternion(quaternion) {
		fromQuat(this, quaternion);
		return this.check();
	}
	/**
	* Generates a frustum matrix with the given bounds
	* @param view.left - Left bound of the frustum
	* @param view.right - Right bound of the frustum
	* @param view.bottom - Bottom bound of the frustum
	* @param view.top - Top bound of the frustum
	* @param view.near - Near bound of the frustum
	* @param view.far - Far bound of the frustum. Can be set to Infinity.
	* @returns self
	*/
	frustum(view) {
		const { left, right, bottom, top, near = DEFAULT_NEAR, far = DEFAULT_FAR } = view;
		if (far === Infinity) computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);
		else frustum(this, left, right, bottom, top, near, far);
		return this.check();
	}
	/**
	* Generates a look-at matrix with the given eye position, focal point,
	* and up axis
	* @param view.eye - (vector) Position of the viewer
	* @param view.center - (vector) Point the viewer is looking at
	* @param view.up - (vector) Up axis
	* @returns self
	*/
	lookAt(view) {
		const { eye, center = [
			0,
			0,
			0
		], up = [
			0,
			1,
			0
		] } = view;
		lookAt(this, eye, center, up);
		return this.check();
	}
	/**
	* Generates a orthogonal projection matrix with the given bounds
	* from "traditional" view space parameters
	* @param view.left - Left bound of the frustum
	* @param view.right number  Right bound of the frustum
	* @param view.bottom - Bottom bound of the frustum
	* @param view.top number  Top bound of the frustum
	* @param view.near - Near bound of the frustum
	* @param view.far number  Far bound of the frustum
	* @returns self
	*/
	ortho(view) {
		const { left, right, bottom, top, near = DEFAULT_NEAR, far = DEFAULT_FAR } = view;
		ortho(this, left, right, bottom, top, near, far);
		return this.check();
	}
	/**
	* Generates an orthogonal projection matrix with the same parameters
	* as a perspective matrix (plus focalDistance)
	* @param view.fovy Vertical field of view in radians
	* @param view.aspect Aspect ratio. Typically viewport width / viewport height
	* @param view.focalDistance Distance in the view frustum used for extent calculations
	* @param view.near Near bound of the frustum
	* @param view.far Far bound of the frustum
	* @returns self
	*/
	orthographic(view) {
		const { fovy = DEFAULT_FOVY, aspect = DEFAULT_ASPECT, focalDistance = 1, near = DEFAULT_NEAR, far = DEFAULT_FAR } = view;
		checkRadians(fovy);
		const halfY = fovy / 2;
		const top = focalDistance * Math.tan(halfY);
		const right = top * aspect;
		return this.ortho({
			left: -right,
			right,
			bottom: -top,
			top,
			near,
			far
		});
	}
	/**
	* Generates a perspective projection matrix with the given bounds
	* @param view.fovy Vertical field of view in radians
	* @param view.aspect Aspect ratio. typically viewport width/height
	* @param view.near Near bound of the frustum
	* @param view.far Far bound of the frustum
	* @returns self
	*/
	perspective(view) {
		const { fovy = 45 * Math.PI / 180, aspect = 1, near = .1, far = 500 } = view;
		checkRadians(fovy);
		perspective(this, fovy, aspect, near, far);
		return this.check();
	}
	determinant() {
		return determinant(this);
	}
	/**
	* Extracts the non-uniform scale assuming the matrix is an affine transformation.
	* The scales are the "lengths" of the column vectors in the upper-left 3x3 matrix.
	* @param result
	* @returns self
	*/
	getScale(result = [
		-0,
		-0,
		-0
	]) {
		result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
		result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
		result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
		return result;
	}
	/**
	* Gets the translation portion, assuming the matrix is a affine transformation matrix.
	* @param result
	* @returns self
	*/
	getTranslation(result = [
		-0,
		-0,
		-0
	]) {
		result[0] = this[12];
		result[1] = this[13];
		result[2] = this[14];
		return result;
	}
	/**
	* Gets upper left 3x3 pure rotation matrix (non-scaling), assume affine transformation matrix
	* @param result
	* @param scaleResult
	* @returns self
	*/
	getRotation(result, scaleResult) {
		result = result || [
			-0,
			-0,
			-0,
			-0,
			-0,
			-0,
			-0,
			-0,
			-0,
			-0,
			-0,
			-0,
			-0,
			-0,
			-0,
			-0
		];
		scaleResult = scaleResult || [
			-0,
			-0,
			-0
		];
		const scale$3 = this.getScale(scaleResult);
		const inverseScale0 = 1 / scale$3[0];
		const inverseScale1 = 1 / scale$3[1];
		const inverseScale2 = 1 / scale$3[2];
		result[0] = this[0] * inverseScale0;
		result[1] = this[1] * inverseScale1;
		result[2] = this[2] * inverseScale2;
		result[3] = 0;
		result[4] = this[4] * inverseScale0;
		result[5] = this[5] * inverseScale1;
		result[6] = this[6] * inverseScale2;
		result[7] = 0;
		result[8] = this[8] * inverseScale0;
		result[9] = this[9] * inverseScale1;
		result[10] = this[10] * inverseScale2;
		result[11] = 0;
		result[12] = 0;
		result[13] = 0;
		result[14] = 0;
		result[15] = 1;
		return result;
	}
	/**
	*
	* @param result
	* @param scaleResult
	* @returns self
	*/
	getRotationMatrix3(result, scaleResult) {
		result = result || [
			-0,
			-0,
			-0,
			-0,
			-0,
			-0,
			-0,
			-0,
			-0
		];
		scaleResult = scaleResult || [
			-0,
			-0,
			-0
		];
		const scale$3 = this.getScale(scaleResult);
		const inverseScale0 = 1 / scale$3[0];
		const inverseScale1 = 1 / scale$3[1];
		const inverseScale2 = 1 / scale$3[2];
		result[0] = this[0] * inverseScale0;
		result[1] = this[1] * inverseScale1;
		result[2] = this[2] * inverseScale2;
		result[3] = this[4] * inverseScale0;
		result[4] = this[5] * inverseScale1;
		result[5] = this[6] * inverseScale2;
		result[6] = this[8] * inverseScale0;
		result[7] = this[9] * inverseScale1;
		result[8] = this[10] * inverseScale2;
		return result;
	}
	transpose() {
		transpose(this, this);
		return this.check();
	}
	invert() {
		invert(this, this);
		return this.check();
	}
	multiplyLeft(a$1) {
		multiply(this, a$1, this);
		return this.check();
	}
	multiplyRight(a$1) {
		multiply(this, this, a$1);
		return this.check();
	}
	rotateX(radians$1) {
		rotateX(this, this, radians$1);
		return this.check();
	}
	rotateY(radians$1) {
		rotateY(this, this, radians$1);
		return this.check();
	}
	/**
	* Rotates a matrix by the given angle around the Z axis.
	* @param radians
	* @returns self
	*/
	rotateZ(radians$1) {
		rotateZ(this, this, radians$1);
		return this.check();
	}
	/**
	*
	* @param param0
	* @returns self
	*/
	rotateXYZ(angleXYZ) {
		return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);
	}
	/**
	*
	* @param radians
	* @param axis
	* @returns self
	*/
	rotateAxis(radians$1, axis) {
		rotate(this, this, radians$1, axis);
		return this.check();
	}
	/**
	*
	* @param factor
	* @returns self
	*/
	scale(factor) {
		scale(this, this, Array.isArray(factor) ? factor : [
			factor,
			factor,
			factor
		]);
		return this.check();
	}
	/**
	*
	* @param vec
	* @returns self
	*/
	translate(vector) {
		translate(this, this, vector);
		return this.check();
	}
	/**
	* Transforms any 2, 3 or 4 element vector. 2 and 3 elements are treated as points
	* @param vector
	* @param result
	* @returns self
	*/
	transform(vector, result) {
		if (vector.length === 4) {
			result = transformMat4$2(result || [
				-0,
				-0,
				-0,
				-0
			], vector, this);
			checkVector(result, 4);
			return result;
		}
		return this.transformAsPoint(vector, result);
	}
	/**
	* Transforms any 2 or 3 element array as point (w implicitly 1)
	* @param vector
	* @param result
	* @returns self
	*/
	transformAsPoint(vector, result) {
		const { length: length$2 } = vector;
		let out;
		switch (length$2) {
			case 2:
				out = transformMat4(result || [-0, -0], vector, this);
				break;
			case 3:
				out = transformMat4$1(result || [
					-0,
					-0,
					-0
				], vector, this);
				break;
			default: throw new Error("Illegal vector");
		}
		checkVector(out, vector.length);
		return out;
	}
	/**
	* Transforms any 2 or 3 element array as vector (w implicitly 0)
	* @param vector
	* @param result
	* @returns self
	*/
	transformAsVector(vector, result) {
		let out;
		switch (vector.length) {
			case 2:
				out = vec2_transformMat4AsVector(result || [-0, -0], vector, this);
				break;
			case 3:
				out = vec3_transformMat4AsVector(result || [
					-0,
					-0,
					-0
				], vector, this);
				break;
			default: throw new Error("Illegal vector");
		}
		checkVector(out, vector.length);
		return out;
	}
	/** @deprecated */
	transformPoint(vector, result) {
		return this.transformAsPoint(vector, result);
	}
	/** @deprecated */
	transformVector(vector, result) {
		return this.transformAsPoint(vector, result);
	}
	/** @deprecated */
	transformDirection(vector, result) {
		return this.transformAsVector(vector, result);
	}
	makeRotationX(radians$1) {
		return this.identity().rotateX(radians$1);
	}
	makeTranslation(x$1, y$1, z$1) {
		return this.identity().translate([
			x$1,
			y$1,
			z$1
		]);
	}
};
var ZERO;
var IDENTITY$1;
function getZeroMatrix() {
	if (!ZERO) {
		ZERO = new Matrix4([
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0
		]);
		Object.freeze(ZERO);
	}
	return ZERO;
}
function getIdentityMatrix() {
	if (!IDENTITY$1) {
		IDENTITY$1 = new Matrix4();
		Object.freeze(IDENTITY$1);
	}
	return IDENTITY$1;
}
function checkRadians(possiblyDegrees) {
	if (possiblyDegrees > Math.PI * 2) throw Error("expected radians");
}
function computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {
	const column0Row0 = 2 * near / (right - left);
	const column1Row1 = 2 * near / (top - bottom);
	const column2Row0 = (right + left) / (right - left);
	const column2Row1 = (top + bottom) / (top - bottom);
	const column2Row2 = -1;
	const column2Row3 = -1;
	const column3Row2 = -2 * near;
	result[0] = column0Row0;
	result[1] = 0;
	result[2] = 0;
	result[3] = 0;
	result[4] = 0;
	result[5] = column1Row1;
	result[6] = 0;
	result[7] = 0;
	result[8] = column2Row0;
	result[9] = column2Row1;
	result[10] = column2Row2;
	result[11] = column2Row3;
	result[12] = 0;
	result[13] = 0;
	result[14] = column3Row2;
	result[15] = 0;
	return result;
}

//#endregion
//#region node_modules/@math.gl/core/dist/classes/spherical-coordinates.js
var EPSILON$2 = 1e-6;
var EARTH_RADIUS_METERS = 6371e3;
/**
* The poles (phi) are at the positive and negative y axis.
* The equator starts at positive z.
* @link https://en.wikipedia.org/wiki/Spherical_coordinate_system
*/
var SphericalCoordinates = class SphericalCoordinates {
	/**
	* Creates a new SphericalCoordinates object
	* @param options
	* @param [options.phi] =0 - rotation around X (latitude)
	* @param [options.theta] =0 - rotation around Y (longitude)
	* @param [options.radius] =1 - Distance from center
	* @param [options.bearing]
	* @param [options.pitch]
	* @param [options.altitude]
	* @param [options.radiusScale] =1
	*/
	constructor({ phi = 0, theta = 0, radius = 1, bearing, pitch, altitude, radiusScale = EARTH_RADIUS_METERS } = {}) {
		this.phi = phi;
		this.theta = theta;
		this.radius = radius || altitude || 1;
		this.radiusScale = radiusScale || 1;
		if (bearing !== void 0) this.bearing = bearing;
		if (pitch !== void 0) this.pitch = pitch;
		this.check();
	}
	toString() {
		return this.formatString(config);
	}
	formatString({ printTypes = false }) {
		const f$1 = formatValue;
		return `${printTypes ? "Spherical" : ""}\
[rho:${f$1(this.radius)},theta:${f$1(this.theta)},phi:${f$1(this.phi)}]`;
	}
	equals(other) {
		return equals(this.radius, other.radius) && equals(this.theta, other.theta) && equals(this.phi, other.phi);
	}
	exactEquals(other) {
		return this.radius === other.radius && this.theta === other.theta && this.phi === other.phi;
	}
	get bearing() {
		return 180 - degrees(this.phi);
	}
	set bearing(v$1) {
		this.phi = Math.PI - radians(v$1);
	}
	get pitch() {
		return degrees(this.theta);
	}
	set pitch(v$1) {
		this.theta = radians(v$1);
	}
	get longitude() {
		return degrees(this.phi);
	}
	get latitude() {
		return degrees(this.theta);
	}
	get lng() {
		return degrees(this.phi);
	}
	get lat() {
		return degrees(this.theta);
	}
	get z() {
		return (this.radius - 1) * this.radiusScale;
	}
	set(radius, phi, theta) {
		this.radius = radius;
		this.phi = phi;
		this.theta = theta;
		return this.check();
	}
	clone() {
		return new SphericalCoordinates().copy(this);
	}
	copy(other) {
		this.radius = other.radius;
		this.phi = other.phi;
		this.theta = other.theta;
		return this.check();
	}
	fromLngLatZ([lng, lat, z$1]) {
		this.radius = 1 + z$1 / this.radiusScale;
		this.phi = radians(lat);
		this.theta = radians(lng);
		return this.check();
	}
	fromVector3(v$1) {
		this.radius = length(v$1);
		if (this.radius > 0) {
			this.theta = Math.atan2(v$1[0], v$1[1]);
			this.phi = Math.acos(clamp(v$1[2] / this.radius, -1, 1));
		}
		return this.check();
	}
	toVector3() {
		return new Vector3(0, 0, this.radius).rotateX({ radians: this.theta }).rotateZ({ radians: this.phi });
	}
	makeSafe() {
		this.phi = Math.max(EPSILON$2, Math.min(Math.PI - EPSILON$2, this.phi));
		return this;
	}
	check() {
		if (!Number.isFinite(this.phi) || !Number.isFinite(this.theta) || !(this.radius > 0)) throw new Error("SphericalCoordinates: some fields set to invalid numbers");
		return this;
	}
};

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64-utils.js
/**
* Calculate WebGL 64 bit float
* @param a  - the input float number
* @param out - the output array. If not supplied, a new array is created.
* @param startIndex - the index in the output array to fill from. Default 0.
* @returns - the fp64 representation of the input number
*/
function fp64ify(a$1, out = [], startIndex = 0) {
	const hiPart = Math.fround(a$1);
	const loPart = a$1 - hiPart;
	out[startIndex] = hiPart;
	out[startIndex + 1] = loPart;
	return out;
}
/**
* Calculate the low part of a WebGL 64 bit float
* @param a the input float number
* @returns the lower 32 bit of the number
*/
function fp64LowPart$1(a$1) {
	return a$1 - Math.fround(a$1);
}
/**
* Calculate WebGL 64 bit matrix (transposed "Float64Array")
* @param matrix  the input matrix
* @returns the fp64 representation of the input matrix
*/
function fp64ifyMatrix4(matrix) {
	const matrixFP64 = new Float32Array(32);
	for (let i$1 = 0; i$1 < 4; ++i$1) for (let j$1 = 0; j$1 < 4; ++j$1) {
		const index = i$1 * 4 + j$1;
		fp64ify(matrix[j$1 * 4 + i$1], matrixFP64, index * 2);
	}
	return matrixFP64;
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/modules/math/fp32/fp32.js
var fp32shader = `\
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND

// All these functions are for substituting tan() function from Intel GPU only
const float TWO_PI = 6.2831854820251465;
const float PI_2 = 1.5707963705062866;
const float PI_16 = 0.1963495463132858;

const float SIN_TABLE_0 = 0.19509032368659973;
const float SIN_TABLE_1 = 0.3826834261417389;
const float SIN_TABLE_2 = 0.5555702447891235;
const float SIN_TABLE_3 = 0.7071067690849304;

const float COS_TABLE_0 = 0.9807852506637573;
const float COS_TABLE_1 = 0.9238795042037964;
const float COS_TABLE_2 = 0.8314695954322815;
const float COS_TABLE_3 = 0.7071067690849304;

const float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!
const float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!
const float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!
const float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!

float sin_taylor_fp32(float a) {
  float r, s, t, x;

  if (a == 0.0) {
    return 0.0;
  }

  x = -a * a;
  s = a;
  r = a;

  r = r * x;
  t = r * INVERSE_FACTORIAL_3;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_5;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_7;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_9;
  s = s + t;

  return s;
}

void sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {
  if (a == 0.0) {
    sin_t = 0.0;
    cos_t = 1.0;
  }
  sin_t = sin_taylor_fp32(a);
  cos_t = sqrt(1.0 - sin_t * sin_t);
}

float tan_taylor_fp32(float a) {
    float sin_a;
    float cos_a;

    if (a == 0.0) {
        return 0.0;
    }

    // 2pi range reduction
    float z = floor(a / TWO_PI);
    float r = a - TWO_PI * z;

    float t;
    float q = floor(r / PI_2 + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return 1.0 / 0.0;
    }

    t = r - PI_2 * q;

    q = floor(t / PI_16 + 0.5);
    int k = int(q);
    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return 1.0 / 0.0;
    } else {
        t = t - PI_16 * q;
    }

    float u = 0.0;
    float v = 0.0;

    float sin_t, cos_t;
    float s, c;
    sincos_taylor_fp32(t, sin_t, cos_t);

    if (k == 0) {
        s = sin_t;
        c = cos_t;
    } else {
        if (abs(float(abs_k) - 1.0) < 0.5) {
            u = COS_TABLE_0;
            v = SIN_TABLE_0;
        } else if (abs(float(abs_k) - 2.0) < 0.5) {
            u = COS_TABLE_1;
            v = SIN_TABLE_1;
        } else if (abs(float(abs_k) - 3.0) < 0.5) {
            u = COS_TABLE_2;
            v = SIN_TABLE_2;
        } else if (abs(float(abs_k) - 4.0) < 0.5) {
            u = COS_TABLE_3;
            v = SIN_TABLE_3;
        }
        if (k > 0) {
            s = u * sin_t + v * cos_t;
            c = u * cos_t - v * sin_t;
        } else {
            s = u * sin_t - v * cos_t;
            c = u * cos_t + v * sin_t;
        }
    }

    if (j == 0) {
        sin_a = s;
        cos_a = c;
    } else if (j == 1) {
        sin_a = c;
        cos_a = -s;
    } else if (j == -1) {
        sin_a = -c;
        cos_a = s;
    } else {
        sin_a = -s;
        cos_a = -c;
    }
    return sin_a / cos_a;
}
#endif

float tan_fp32(float a) {
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
  return tan_taylor_fp32(a);
#else
  return tan(a);
#endif
}
`;
/**
* 32 bit math library (fixups for GPUs)
*/
const fp32 = {
	name: "fp32",
	vs: fp32shader
};

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64-arithmetic-glsl.js
const fp64arithmeticShader = `\

uniform fp64arithmeticUniforms {
  uniform float ONE;
} fp64;

/*
About LUMA_FP64_CODE_ELIMINATION_WORKAROUND

The purpose of this workaround is to prevent shader compilers from
optimizing away necessary arithmetic operations by swapping their sequences
or transform the equation to some 'equivalent' form.

The method is to multiply an artifical variable, ONE, which will be known to
the compiler to be 1 only at runtime. The whole expression is then represented
as a polynomial with respective to ONE. In the coefficients of all terms, only one a
and one b should appear

err = (a + b) * ONE^6 - a * ONE^5 - (a + b) * ONE^4 + a * ONE^3 - b - (a + b) * ONE^2 + a * ONE
*/

// Divide float number to high and low floats to extend fraction bits
vec2 split(float a) {
  const float SPLIT = 4097.0;
  float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float a_hi = t * fp64.ONE - (t - a);
  float a_lo = a * fp64.ONE - a_hi;
#else
  float a_hi = t - (t - a);
  float a_lo = a - a_hi;
#endif
  return vec2(a_hi, a_lo);
}

// Divide float number again when high float uses too many fraction bits
vec2 split2(vec2 a) {
  vec2 b = split(a.x);
  b.y += a.y;
  return b;
}

// Special sum operation when a > b
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float sum = (a + b) * fp64.ONE;
  float err = b - (sum - a) * fp64.ONE;
#else
  float sum = a + b;
  float err = b - (sum - a);
#endif
  return vec2(sum, err);
}

// General sum operation
vec2 twoSum(float a, float b) {
  float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE + (b - v);
#else
  float v = s - a;
  float err = (a - (s - v)) + (b - v);
#endif
  return vec2(s, err);
}

vec2 twoSub(float a, float b) {
  float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE - (b + v);
#else
  float v = s - a;
  float err = (a - (s - v)) - (b + v);
#endif
  return vec2(s, err);
}

vec2 twoSqr(float a) {
  float prod = a * a;
  vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float err = ((a_fp64.x * a_fp64.x - prod) * fp64.ONE + 2.0 * a_fp64.x *
    a_fp64.y * fp64.ONE * fp64.ONE) + a_fp64.y * a_fp64.y * fp64.ONE * fp64.ONE * fp64.ONE;
#else
  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
  return vec2(prod, err);
}

vec2 twoProd(float a, float b) {
  float prod = a * b;
  vec2 a_fp64 = split(a);
  vec2 b_fp64 = split(b);
  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
  return vec2(prod, err);
}

vec2 sum_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSum(a.x, b.x);
  t = twoSum(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 sub_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSub(a.x, b.x);
  t = twoSub(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 mul_fp64(vec2 a, vec2 b) {
  vec2 prod = twoProd(a.x, b.x);
  // y component is for the error
  prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  return prod;
}

vec2 div_fp64(vec2 a, vec2 b) {
  float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
  vec2 yn = a * xn;
#endif
  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
  vec2 prod = twoProd(xn, diff);
  return sum_fp64(yn, prod);
}

vec2 sqrt_fp64(vec2 a) {
  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);

  float x = 1.0 / sqrt(a.x);
  float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  vec2 yn_sqr = twoSqr(yn) * fp64.ONE;
#else
  vec2 yn_sqr = twoSqr(yn);
#endif
  float diff = sub_fp64(a, yn_sqr).x;
  vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  return sum_fp64(split(yn), prod);
#else
  return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`;

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64.js
var defaultUniforms = { ONE: 1 };
/**
* 64bit arithmetic: add, sub, mul, div (small subset of fp64 module)
*/
const fp64arithmetic = {
	name: "fp64arithmetic",
	vs: fp64arithmeticShader,
	defaultUniforms,
	uniformTypes: { ONE: "f32" },
	fp64ify,
	fp64LowPart: fp64LowPart$1,
	fp64ifyMatrix4
};

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/modules/engine/picking/picking.js
var DEFAULT_HIGHLIGHT_COLOR = [
	0,
	1,
	1,
	1
];
var vs$5 = `\
uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

out vec4 picking_vRGBcolor_Avalid;

// Normalize unsigned byte color to 0-1 range
vec3 picking_normalizeColor(vec3 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

// Normalize unsigned byte color to 0-1 range
vec4 picking_normalizeColor(vec4 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

bool picking_isColorZero(vec3 color) {
  return dot(color, vec3(1.0)) < 0.00001;
}

bool picking_isColorValid(vec3 color) {
  return dot(color, vec3(1.0)) > 0.00001;
}

// Check if this vertex is highlighted 
bool isVertexHighlighted(vec3 vertexColor) {
  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);
  return
    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));
}

// Set the current picking color
void picking_setPickingColor(vec3 pickingColor) {
  pickingColor = picking_normalizeColor(pickingColor);

  if (bool(picking.isActive)) {
    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable
    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));

    if (!bool(picking.isAttribute)) {
      // Stores the picking color so that the fragment shader can render it during picking
      picking_vRGBcolor_Avalid.rgb = pickingColor;
    }
  } else {
    // Do the comparison with selected item color in vertex shader as it should mean fewer compares
    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));
  }
}

void picking_setPickingAttribute(float value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.r = value;
  }
}

void picking_setPickingAttribute(vec2 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rg = value;
  }
}

void picking_setPickingAttribute(vec3 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rgb = value;
  }
}
`;
var fs$3 = `\
uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

in vec4 picking_vRGBcolor_Avalid;

/*
 * Returns highlight color if this item is selected.
 */
vec4 picking_filterHighlightColor(vec4 color) {
  // If we are still picking, we don't highlight
  if (picking.isActive > 0.5) {
    return color;
  }

  bool selected = bool(picking_vRGBcolor_Avalid.a);

  if (selected) {
    // Blend in highlight color based on its alpha value
    float highLightAlpha = picking.highlightColor.a;
    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
    float highLightRatio = highLightAlpha / blendedAlpha;

    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);
    return vec4(blendedRGB, blendedAlpha);
  } else {
    return color;
  }
}

/*
 * Returns picking color if picking enabled else unmodified argument.
 */
vec4 picking_filterPickingColor(vec4 color) {
  if (bool(picking.isActive)) {
    if (picking_vRGBcolor_Avalid.a == 0.0) {
      discard;
    }
    return picking_vRGBcolor_Avalid;
  }
  return color;
}

/*
 * Returns picking color if picking is enabled if not
 * highlight color if this item is selected, otherwise unmodified argument.
 */
vec4 picking_filterColor(vec4 color) {
  vec4 highlightColor = picking_filterHighlightColor(color);
  return picking_filterPickingColor(highlightColor);
}
`;
/**
* Provides support for color-coding-based picking and highlighting.
* In particular, supports picking a specific instance in an instanced
* draw call and highlighting an instance based on its picking color,
* and correspondingly, supports picking and highlighting groups of
* primitives with the same picking color in non-instanced draw-calls
*/
const picking = {
	props: {},
	uniforms: {},
	name: "picking",
	uniformTypes: {
		isActive: "f32",
		isAttribute: "f32",
		isHighlightActive: "f32",
		useFloatColors: "f32",
		highlightedObjectColor: "vec3<f32>",
		highlightColor: "vec4<f32>"
	},
	defaultUniforms: {
		isActive: false,
		isAttribute: false,
		isHighlightActive: false,
		useFloatColors: true,
		highlightedObjectColor: [
			0,
			0,
			0
		],
		highlightColor: DEFAULT_HIGHLIGHT_COLOR
	},
	vs: vs$5,
	fs: fs$3,
	getUniforms: getUniforms$2
};
function getUniforms$2(opts = {}, prevUniforms) {
	const uniforms = {};
	if (opts.highlightedObjectColor === void 0) {} else if (opts.highlightedObjectColor === null) uniforms.isHighlightActive = false;
	else {
		uniforms.isHighlightActive = true;
		uniforms.highlightedObjectColor = opts.highlightedObjectColor.slice(0, 3);
	}
	if (opts.highlightColor) {
		const color = Array.from(opts.highlightColor, (x$1) => x$1 / 255);
		if (!Number.isFinite(color[3])) color[3] = 1;
		uniforms.highlightColor = color;
	}
	if (opts.isActive !== void 0) {
		uniforms.isActive = Boolean(opts.isActive);
		uniforms.isAttribute = Boolean(opts.isAttribute);
	}
	if (opts.useFloatColors !== void 0) uniforms.useFloatColors = Boolean(opts.useFloatColors);
	return uniforms;
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting-glsl.js
const lightingUniformsGLSL = `\
precision highp int;

// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  vec3 color;
};

struct PointLight {
  vec3 color;
  vec3 position;
  vec3 attenuation; // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  vec3 color;
  vec3 direction;
};

uniform lightingUniforms {
  int enabled;
  int lightType;

  int directionalLightCount;
  int pointLightCount;

  vec3 ambientColor;

  vec3 lightColor0;
  vec3 lightPosition0;
  vec3 lightDirection0;
  vec3 lightAttenuation0;

  vec3 lightColor1;
  vec3 lightPosition1;
  vec3 lightDirection1;
  vec3 lightAttenuation1;

  vec3 lightColor2;
  vec3 lightPosition2;
  vec3 lightDirection2;
  vec3 lightAttenuation2;
} lighting;

PointLight lighting_getPointLight(int index) {
  switch (index) {
    case 0:
      return PointLight(lighting.lightColor0, lighting.lightPosition0, lighting.lightAttenuation0);
    case 1:
      return PointLight(lighting.lightColor1, lighting.lightPosition1, lighting.lightAttenuation1);
    case 2:
    default:  
      return PointLight(lighting.lightColor2, lighting.lightPosition2, lighting.lightAttenuation2);
  }
}

DirectionalLight lighting_getDirectionalLight(int index) {
  switch (index) {
    case 0:
      return DirectionalLight(lighting.lightColor0, lighting.lightDirection0);
    case 1:
      return DirectionalLight(lighting.lightColor1, lighting.lightDirection1);
    case 2:
    default:   
      return DirectionalLight(lighting.lightColor2, lighting.lightDirection2);
  }
} 

float getPointLightAttenuation(PointLight pointLight, float distance) {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}

// #endif
`;

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting-wgsl.js
const lightingUniformsWGSL = `\
// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  color: vec3<f32>,
};

struct PointLight {
  color: vec3<f32>,
  position: vec3<f32>,
  attenuation: vec3<f32>, // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  color: vec3<f32>,
  direction: vec3<f32>,
};

struct lightingUniforms {
  enabled: i32,
  pointLightCount: i32,
  directionalLightCount: i32,

  ambientColor: vec3<f32>,

  // TODO - support multiple lights by uncommenting arrays below
  lightType: i32,
  lightColor: vec3<f32>,
  lightDirection: vec3<f32>,
  lightPosition: vec3<f32>,
  lightAttenuation: vec3<f32>,

  // AmbientLight ambientLight;
  // PointLight pointLight[MAX_LIGHTS];
  // DirectionalLight directionalLight[MAX_LIGHTS];
};

// Binding 0:1 is reserved for lighting (Note: could go into separate bind group as it is stable across draw calls)
@binding(1) @group(0) var<uniform> lighting : lightingUniforms;

fn lighting_getPointLight(index: i32) -> PointLight {
  return PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);
}

fn lighting_getDirectionalLight(index: i32) -> DirectionalLight {
  return DirectionalLight(lighting.lightColor, lighting.lightDirection);
} 

fn getPointLightAttenuation(pointLight: PointLight, distance: f32) -> f32 {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}
`;

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting.js
/** Max number of supported lights (in addition to ambient light */
var MAX_LIGHTS = 5;
/** Whether to divide */
var COLOR_FACTOR = 255;
/** Shader type field for lights */
var LIGHT_TYPE;
(function(LIGHT_TYPE$1) {
	LIGHT_TYPE$1[LIGHT_TYPE$1["POINT"] = 0] = "POINT";
	LIGHT_TYPE$1[LIGHT_TYPE$1["DIRECTIONAL"] = 1] = "DIRECTIONAL";
})(LIGHT_TYPE || (LIGHT_TYPE = {}));
/** UBO ready lighting module */
const lighting = {
	props: {},
	uniforms: {},
	name: "lighting",
	defines: {},
	uniformTypes: {
		enabled: "i32",
		lightType: "i32",
		directionalLightCount: "i32",
		pointLightCount: "i32",
		ambientColor: "vec3<f32>",
		lightColor0: "vec3<f32>",
		lightPosition0: "vec3<f32>",
		lightDirection0: "vec3<f32>",
		lightAttenuation0: "vec3<f32>",
		lightColor1: "vec3<f32>",
		lightPosition1: "vec3<f32>",
		lightDirection1: "vec3<f32>",
		lightAttenuation1: "vec3<f32>",
		lightColor2: "vec3<f32>",
		lightPosition2: "vec3<f32>",
		lightDirection2: "vec3<f32>",
		lightAttenuation2: "vec3<f32>"
	},
	defaultUniforms: {
		enabled: 1,
		lightType: LIGHT_TYPE.POINT,
		directionalLightCount: 0,
		pointLightCount: 0,
		ambientColor: [
			.1,
			.1,
			.1
		],
		lightColor0: [
			1,
			1,
			1
		],
		lightPosition0: [
			1,
			1,
			2
		],
		lightDirection0: [
			1,
			1,
			1
		],
		lightAttenuation0: [
			1,
			0,
			0
		],
		lightColor1: [
			1,
			1,
			1
		],
		lightPosition1: [
			1,
			1,
			2
		],
		lightDirection1: [
			1,
			1,
			1
		],
		lightAttenuation1: [
			1,
			0,
			0
		],
		lightColor2: [
			1,
			1,
			1
		],
		lightPosition2: [
			1,
			1,
			2
		],
		lightDirection2: [
			1,
			1,
			1
		],
		lightAttenuation2: [
			1,
			0,
			0
		]
	},
	source: lightingUniformsWGSL,
	vs: lightingUniformsGLSL,
	fs: lightingUniformsGLSL,
	getUniforms: getUniforms$1
};
function getUniforms$1(props, prevUniforms = {}) {
	props = props ? { ...props } : props;
	if (!props) return { ...lighting.defaultUniforms };
	if (props.lights) props = {
		...props,
		...extractLightTypes(props.lights),
		lights: void 0
	};
	const { ambientLight, pointLights, directionalLights } = props || {};
	if (!(ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0)) return {
		...lighting.defaultUniforms,
		enabled: 0
	};
	const uniforms = {
		...lighting.defaultUniforms,
		...prevUniforms,
		...getLightSourceUniforms({
			ambientLight,
			pointLights,
			directionalLights
		})
	};
	if (props.enabled !== void 0) uniforms.enabled = props.enabled ? 1 : 0;
	return uniforms;
}
function getLightSourceUniforms({ ambientLight, pointLights = [], directionalLights = [] }) {
	const lightSourceUniforms = {};
	lightSourceUniforms.ambientColor = convertColor(ambientLight);
	let currentLight = 0;
	for (const pointLight of pointLights) {
		lightSourceUniforms.lightType = LIGHT_TYPE.POINT;
		const i$1 = currentLight;
		lightSourceUniforms[`lightColor${i$1}`] = convertColor(pointLight);
		lightSourceUniforms[`lightPosition${i$1}`] = pointLight.position;
		lightSourceUniforms[`lightAttenuation${i$1}`] = pointLight.attenuation || [
			1,
			0,
			0
		];
		currentLight++;
	}
	for (const directionalLight of directionalLights) {
		lightSourceUniforms.lightType = LIGHT_TYPE.DIRECTIONAL;
		const i$1 = currentLight;
		lightSourceUniforms[`lightColor${i$1}`] = convertColor(directionalLight);
		lightSourceUniforms[`lightDirection${i$1}`] = directionalLight.direction;
		currentLight++;
	}
	if (currentLight > MAX_LIGHTS) log.warn("MAX_LIGHTS exceeded")();
	lightSourceUniforms.directionalLightCount = directionalLights.length;
	lightSourceUniforms.pointLightCount = pointLights.length;
	return lightSourceUniforms;
}
function extractLightTypes(lights) {
	const lightSources = {
		pointLights: [],
		directionalLights: []
	};
	for (const light of lights || []) switch (light.type) {
		case "ambient":
			lightSources.ambientLight = light;
			break;
		case "directional":
			lightSources.directionalLights?.push(light);
			break;
		case "point":
			lightSources.pointLights?.push(light);
			break;
		default:
	}
	return lightSources;
}
/** Take color 0-255 and intensity as input and output 0.0-1.0 range */
function convertColor(colorDef = {}) {
	const { color = [
		0,
		0,
		0
	], intensity = 1 } = colorDef;
	return color.map((component) => component * intensity / COLOR_FACTOR);
}

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/modules/lighting/phong-material/phong-shaders-glsl.js
const PHONG_VS = `\
uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;
`;
const PHONG_FS = `\
#define MAX_LIGHTS 3

uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
  vec3 halfway_direction = normalize(light_direction + view_direction);
  float lambertian = dot(light_direction, normal_worldspace);
  float specular = 0.0;
  if (lambertian > 0.0) {
    float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, material.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;
}

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  vec3 view_direction = normalize(cameraPosition - position_worldspace);
  lightColor = material.ambient * surfaceColor * lighting.ambientColor;

  for (int i = 0; i < lighting.pointLightCount; i++) {
    PointLight pointLight = lighting_getPointLight(i);
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    float light_attenuation = getPointLightAttenuation(pointLight, distance(light_position_worldspace, position_worldspace));
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color / light_attenuation);
  }

  int totalLights = min(MAX_LIGHTS, lighting.pointLightCount + lighting.directionalLightCount);
  for (int i = lighting.pointLightCount; i < totalLights; i++) {
    DirectionalLight directionalLight = lighting_getDirectionalLight(i);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
}
`;

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/modules/lighting/phong-material/phong-shaders-wgsl.js
const PHONG_WGSL = `\
struct phongMaterialUniforms {
  ambient: f32,
  diffuse: f32,
  shininess: f32,
  specularColor: vec3<f32>,
};

@binding(2) @group(0) var<uniform> phongMaterial : phongMaterialUniforms;

fn lighting_getLightColor(surfaceColor: vec3<f32>, light_direction: vec3<f32>, view_direction: vec3<f32>, normal_worldspace: vec3<f32>, color: vec3<f32>) -> vec3<f32> {
  let halfway_direction: vec3<f32> = normalize(light_direction + view_direction);
  var lambertian: f32 = dot(light_direction, normal_worldspace);
  var specular: f32 = 0.0;
  if (lambertian > 0.0) {
    let specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, phongMaterial.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * phongMaterial.diffuse * surfaceColor + specular * phongMaterial.specularColor) * color;
}

fn lighting_getLightColor2(surfaceColor: vec3<f32>, cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32> {
  var lightColor: vec3<f32> = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  let view_direction: vec3<f32> = normalize(cameraPosition - position_worldspace);
  lightColor = phongMaterial.ambient * surfaceColor * lighting.ambientColor;

  if (lighting.lightType == 0) {
    let pointLight: PointLight  = lighting_getPointLight(0);
    let light_position_worldspace: vec3<f32> = pointLight.position;
    let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  } else if (lighting.lightType == 1) {
    var directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
  /*
  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.pointLightCount) {
      break;
    }
    PointLight pointLight = lighting.pointLight[i];
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  }

  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.directionalLightCount) {
      break;
    }
    DirectionalLight directionalLight = lighting.directionalLight[i];
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  */
}

fn lighting_getSpecularLightColor(cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32>{
  var lightColor = vec3<f32>(0, 0, 0);
  let surfaceColor = vec3<f32>(0, 0, 0);

  if (lighting.enabled == 0) {
    let view_direction = normalize(cameraPosition - position_worldspace);

    switch (lighting.lightType) {
      case 0, default: {
        let pointLight: PointLight = lighting_getPointLight(0);
        let light_position_worldspace: vec3<f32> = pointLight.position;
        let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
        lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
      }
      case 1: {
        let directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
        lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
      }
    }
  }
  return lightColor;
}
`;
/**
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting.pointLightCount) {
break;
}
PointLight pointLight = lighting_getPointLight(i);
vec3 light_position_worldspace = pointLight.position;
vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
}

for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting.directionalLightCount) {
break;
}
PointLight pointLight = lighting_getDirectionalLight(i);
lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
}
}
/**
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting.pointLightCount) {
break;
}
PointLight pointLight = lighting_getPointLight(i);
vec3 light_position_worldspace = pointLight.position;
vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
}

for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting.directionalLightCount) {
break;
}
PointLight pointLight = lighting_getDirectionalLight(i);
lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
}
}
*/

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/modules/lighting/gouraud-material/gouraud-material.js
/** In Gouraud shading, color is calculated for each triangle vertex normal, and then color is interpolated colors across the triangle */
const gouraudMaterial = {
	props: {},
	name: "gouraudMaterial",
	vs: PHONG_FS.replace("phongMaterial", "gouraudMaterial"),
	fs: PHONG_VS.replace("phongMaterial", "gouraudMaterial"),
	source: PHONG_WGSL.replaceAll("phongMaterial", "gouraudMaterial"),
	defines: { LIGHTING_VERTEX: true },
	dependencies: [lighting],
	uniformTypes: {
		ambient: "f32",
		diffuse: "f32",
		shininess: "f32",
		specularColor: "vec3<f32>"
	},
	defaultUniforms: {
		ambient: .35,
		diffuse: .6,
		shininess: 32,
		specularColor: [
			.15,
			.15,
			.15
		]
	},
	getUniforms(props) {
		const uniforms = { ...props };
		if (uniforms.specularColor) uniforms.specularColor = uniforms.specularColor.map((x$1) => x$1 / 255);
		return {
			...gouraudMaterial.defaultUniforms,
			...uniforms
		};
	}
};

//#endregion
//#region node_modules/@luma.gl/shadertools/dist/modules/lighting/phong-material/phong-material.js
/** In Phong shading, the normal vector is linearly interpolated across the surface of the polygon from the polygon's vertex normals. */
const phongMaterial = {
	name: "phongMaterial",
	dependencies: [lighting],
	source: PHONG_WGSL,
	vs: PHONG_VS,
	fs: PHONG_FS,
	defines: { LIGHTING_FRAGMENT: true },
	uniformTypes: {
		ambient: "f32",
		diffuse: "f32",
		shininess: "f32",
		specularColor: "vec3<f32>"
	},
	defaultUniforms: {
		ambient: .35,
		diffuse: .6,
		shininess: 32,
		specularColor: [
			.15,
			.15,
			.15
		]
	},
	getUniforms(props) {
		const uniforms = { ...props };
		if (uniforms.specularColor) uniforms.specularColor = uniforms.specularColor.map((x$1) => x$1 / 255);
		return {
			...phongMaterial.defaultUniforms,
			...uniforms
		};
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/shaderlib/misc/layer-uniforms.js
var uniformBlock$2 = `\
uniform layerUniforms {
  uniform float opacity;
} layer;
`;
const layerUniforms = {
	name: "layer",
	vs: uniformBlock$2,
	fs: uniformBlock$2,
	getUniforms: (props) => {
		return { opacity: Math.pow(props.opacity, 1 / 2.2) };
	},
	uniformTypes: { opacity: "f32" }
};

//#endregion
//#region node_modules/@deck.gl/core/dist/shaderlib/color/color.js
var colorWGSL = `

struct ColorUniforms {
  opacity: f32,
};

var<private> color: ColorUniforms = ColorUniforms(1.0);
// TODO (kaapp) avoiding binding index collisions to handle layer opacity 
// requires some thought.
// @group(0) @binding(0) var<uniform> color: ColorUniforms;

@must_use
fn deckgl_premultiplied_alpha(fragColor: vec4<f32>) -> vec4<f32> {
    return vec4(fragColor.rgb * fragColor.a, fragColor.a); 
};
`;
var color_default = {
	name: "color",
	dependencies: [],
	source: colorWGSL,
	getUniforms: (_props) => {
		return {};
	},
	uniformTypes: { opacity: "f32" }
};

//#endregion
//#region node_modules/@deck.gl/core/dist/shaderlib/misc/geometry.js
var source$1 = `\
const SMOOTH_EDGE_RADIUS: f32 = 0.5;

struct VertexGeometry {
  position: vec4<f32>,
  worldPosition: vec3<f32>,
  worldPositionAlt: vec3<f32>,
  normal: vec3<f32>,
  uv: vec2<f32>,
  pickingColor: vec3<f32>,
};

var<private> geometry_: VertexGeometry = VertexGeometry(
  vec4<f32>(0.0, 0.0, 1.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec2<f32>(0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0)
);

struct FragmentGeometry {
  uv: vec2<f32>,
};

var<private> fragmentGeometry: FragmentGeometry;

fn smoothedge(edge: f32, x: f32) -> f32 {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`;
var defines = "#define SMOOTH_EDGE_RADIUS 0.5";
var vs$4 = `\
${defines}

struct VertexGeometry {
  vec4 position;
  vec3 worldPosition;
  vec3 worldPositionAlt;
  vec3 normal;
  vec2 uv;
  vec3 pickingColor;
} geometry = VertexGeometry(
  vec4(0.0, 0.0, 1.0, 0.0),
  vec3(0.0),
  vec3(0.0),
  vec3(0.0),
  vec2(0.0),
  vec3(0.0)
);
`;
var fs$2 = `\
${defines}

struct FragmentGeometry {
  vec2 uv;
} geometry;

float smoothedge(float edge, float x) {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`;
var geometry_default = {
	name: "geometry",
	source: source$1,
	vs: vs$4,
	fs: fs$2
};

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/input-consts.js
const COMPUTE_INTERVAL = 25;
var InputEvent;
(function(InputEvent$1) {
	InputEvent$1[InputEvent$1["Start"] = 1] = "Start";
	InputEvent$1[InputEvent$1["Move"] = 2] = "Move";
	InputEvent$1[InputEvent$1["End"] = 4] = "End";
	InputEvent$1[InputEvent$1["Cancel"] = 8] = "Cancel";
})(InputEvent || (InputEvent = {}));
var InputDirection;
(function(InputDirection$1) {
	InputDirection$1[InputDirection$1["None"] = 0] = "None";
	InputDirection$1[InputDirection$1["Left"] = 1] = "Left";
	InputDirection$1[InputDirection$1["Right"] = 2] = "Right";
	InputDirection$1[InputDirection$1["Up"] = 4] = "Up";
	InputDirection$1[InputDirection$1["Down"] = 8] = "Down";
	InputDirection$1[InputDirection$1["Horizontal"] = 3] = "Horizontal";
	InputDirection$1[InputDirection$1["Vertical"] = 12] = "Vertical";
	InputDirection$1[InputDirection$1["All"] = 15] = "All";
})(InputDirection || (InputDirection = {}));

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/recognizer/recognizer-state.js
var RecognizerState;
(function(RecognizerState$1) {
	RecognizerState$1[RecognizerState$1["Possible"] = 1] = "Possible";
	RecognizerState$1[RecognizerState$1["Began"] = 2] = "Began";
	RecognizerState$1[RecognizerState$1["Changed"] = 4] = "Changed";
	RecognizerState$1[RecognizerState$1["Ended"] = 8] = "Ended";
	RecognizerState$1[RecognizerState$1["Recognized"] = 8] = "Recognized";
	RecognizerState$1[RecognizerState$1["Cancelled"] = 16] = "Cancelled";
	RecognizerState$1[RecognizerState$1["Failed"] = 32] = "Failed";
})(RecognizerState || (RecognizerState = {}));

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/touchaction/touchaction-Consts.js
const TOUCH_ACTION_COMPUTE = "compute";
const TOUCH_ACTION_AUTO = "auto";
const TOUCH_ACTION_MANIPULATION = "manipulation";
const TOUCH_ACTION_NONE = "none";
const TOUCH_ACTION_PAN_X = "pan-x";
const TOUCH_ACTION_PAN_Y = "pan-y";

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/touchaction/clean-touch-actions.js
/**
* when the touchActions are collected they are not a valid value, so we need to clean things up. *
* @returns valid touchAction
*/
function cleanTouchActions(actions) {
	if (actions.includes(TOUCH_ACTION_NONE)) return TOUCH_ACTION_NONE;
	const hasPanX = actions.includes(TOUCH_ACTION_PAN_X);
	const hasPanY = actions.includes(TOUCH_ACTION_PAN_Y);
	if (hasPanX && hasPanY) return TOUCH_ACTION_NONE;
	if (hasPanX || hasPanY) return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
	if (actions.includes(TOUCH_ACTION_MANIPULATION)) return TOUCH_ACTION_MANIPULATION;
	return TOUCH_ACTION_AUTO;
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/touchaction/touchaction.js
/**
* Touch Action
* sets the touchAction property or uses the js alternative
*/
var TouchAction = class {
	constructor(manager, value) {
		this.actions = "";
		this.manager = manager;
		this.set(value);
	}
	/**
	* set the touchAction value on the element or enable the polyfill
	*/
	set(value) {
		if (value === TOUCH_ACTION_COMPUTE) value = this.compute();
		if (this.manager.element) {
			this.manager.element.style.touchAction = value;
			this.actions = value;
		}
	}
	/**
	* just re-set the touchAction value
	*/
	update() {
		this.set(this.manager.options.touchAction);
	}
	/**
	* compute the value for the touchAction property based on the recognizer's settings
	*/
	compute() {
		let actions = [];
		for (const recognizer of this.manager.recognizers) if (recognizer.options.enable) actions = actions.concat(recognizer.getTouchAction());
		return cleanTouchActions(actions.join(" "));
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/utils/split-str.js
/**
* split string on whitespace
* @returns {Array} words
*/
function splitStr(str) {
	return str.trim().split(/\s+/g);
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/utils/event-listeners.js
/**
* addEventListener with multiple events at once
*/
function addEventListeners(target, types, handler) {
	if (!target) return;
	for (const type of splitStr(types)) target.addEventListener(type, handler, false);
}
/**
* removeEventListener with multiple events at once
*/
function removeEventListeners(target, types, handler) {
	if (!target) return;
	for (const type of splitStr(types)) target.removeEventListener(type, handler, false);
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/utils/get-window-for-element.js
/**
* get the window object of an element
*/
function getWindowForElement(element) {
	return (element.ownerDocument || element).defaultView;
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/utils/has-parent.js
/**
* find if a node is in the given parent
*/
function hasParent(node, parent) {
	let ancestor = node;
	while (ancestor) {
		if (ancestor === parent) return true;
		ancestor = ancestor.parentNode;
	}
	return false;
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/get-center.js
/**
* get the center of all the pointers
*/
function getCenter(pointers) {
	const pointersLength = pointers.length;
	if (pointersLength === 1) return {
		x: Math.round(pointers[0].clientX),
		y: Math.round(pointers[0].clientY)
	};
	let x$1 = 0;
	let y$1 = 0;
	let i$1 = 0;
	while (i$1 < pointersLength) {
		x$1 += pointers[i$1].clientX;
		y$1 += pointers[i$1].clientY;
		i$1++;
	}
	return {
		x: Math.round(x$1 / pointersLength),
		y: Math.round(y$1 / pointersLength)
	};
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/simple-clone-input-data.js
/**
* create a simple clone from the input used for storage of firstInput and firstMultiple
*/
function simpleCloneInputData(input) {
	const pointers = [];
	let i$1 = 0;
	while (i$1 < input.pointers.length) {
		pointers[i$1] = {
			clientX: Math.round(input.pointers[i$1].clientX),
			clientY: Math.round(input.pointers[i$1].clientY)
		};
		i$1++;
	}
	return {
		timeStamp: Date.now(),
		pointers,
		center: getCenter(pointers),
		deltaX: input.deltaX,
		deltaY: input.deltaY
	};
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/get-distance.js
/**
* calculate the absolute distance between two points
* @returns distance
*/
function getPointDistance(p1, p2) {
	const x$1 = p2.x - p1.x;
	const y$1 = p2.y - p1.y;
	return Math.sqrt(x$1 * x$1 + y$1 * y$1);
}
/**
* calculate the absolute distance between two pointer events
* @returns distance
*/
function getEventDistance(p1, p2) {
	const x$1 = p2.clientX - p1.clientX;
	const y$1 = p2.clientY - p1.clientY;
	return Math.sqrt(x$1 * x$1 + y$1 * y$1);
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/get-angle.js
/**
* calculate the angle between two coordinates
* @returns angle in degrees
*/
function getPointAngle(p1, p2) {
	const x$1 = p2.x - p1.x;
	const y$1 = p2.y - p1.y;
	return Math.atan2(y$1, x$1) * 180 / Math.PI;
}
/**
* calculate the angle between two pointer events
* @returns angle in degrees
*/
function getEventAngle(p1, p2) {
	const x$1 = p2.clientX - p1.clientX;
	const y$1 = p2.clientY - p1.clientY;
	return Math.atan2(y$1, x$1) * 180 / Math.PI;
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/get-direction.js
/**
* get the direction between two points
* @returns direction
*/
function getDirection(dx, dy) {
	if (dx === dy) return InputDirection.None;
	if (Math.abs(dx) >= Math.abs(dy)) return dx < 0 ? InputDirection.Left : InputDirection.Right;
	return dy < 0 ? InputDirection.Up : InputDirection.Down;
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/get-delta-xy.js
/** Populates input.deltaX, input.deltaY */
function computeDeltaXY(session, input) {
	const center = input.center;
	let offset = session.offsetDelta;
	let prevDelta = session.prevDelta;
	const prevInput = session.prevInput;
	if (input.eventType === InputEvent.Start || prevInput?.eventType === InputEvent.End) {
		prevDelta = session.prevDelta = {
			x: prevInput?.deltaX || 0,
			y: prevInput?.deltaY || 0
		};
		offset = session.offsetDelta = {
			x: center.x,
			y: center.y
		};
	}
	return {
		deltaX: prevDelta.x + (center.x - offset.x),
		deltaY: prevDelta.y + (center.y - offset.y)
	};
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/get-velocity.js
/**
* calculate the velocity between two points. unit is in px per ms.
*/
function getVelocity(deltaTime, x$1, y$1) {
	return {
		x: x$1 / deltaTime || 0,
		y: y$1 / deltaTime || 0
	};
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/get-scale.js
/**
* calculate the scale factor between two pointersets
* no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
*/
function getScale(start, end) {
	return getEventDistance(end[0], end[1]) / getEventDistance(start[0], start[1]);
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/get-rotation.js
/**
* calculate the rotation degrees between two pointer sets
* @returns rotation in degrees
*/
function getRotation(start, end) {
	return getEventAngle(end[1], end[0]) - getEventAngle(start[1], start[0]);
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/compute-interval-input-data.js
/**
* velocity is calculated every x ms
*/
function computeIntervalInputData(session, input) {
	const last = session.lastInterval || input;
	const deltaTime = input.timeStamp - last.timeStamp;
	let velocity;
	let velocityX;
	let velocityY;
	let direction;
	if (input.eventType !== InputEvent.Cancel && (deltaTime > COMPUTE_INTERVAL || last.velocity === void 0)) {
		const deltaX = input.deltaX - last.deltaX;
		const deltaY = input.deltaY - last.deltaY;
		const v$1 = getVelocity(deltaTime, deltaX, deltaY);
		velocityX = v$1.x;
		velocityY = v$1.y;
		velocity = Math.abs(v$1.x) > Math.abs(v$1.y) ? v$1.x : v$1.y;
		direction = getDirection(deltaX, deltaY);
		session.lastInterval = input;
	} else {
		velocity = last.velocity;
		velocityX = last.velocityX;
		velocityY = last.velocityY;
		direction = last.direction;
	}
	input.velocity = velocity;
	input.velocityX = velocityX;
	input.velocityY = velocityY;
	input.direction = direction;
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/compute-input-data.js
/**
* extend the data with some usable properties like scale, rotate, velocity etc
*/
function computeInputData(manager, input) {
	const { session } = manager;
	const { pointers } = input;
	const { length: pointersLength } = pointers;
	if (!session.firstInput) session.firstInput = simpleCloneInputData(input);
	if (pointersLength > 1 && !session.firstMultiple) session.firstMultiple = simpleCloneInputData(input);
	else if (pointersLength === 1) session.firstMultiple = false;
	const { firstInput, firstMultiple } = session;
	const offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
	const center = input.center = getCenter(pointers);
	input.timeStamp = Date.now();
	input.deltaTime = input.timeStamp - firstInput.timeStamp;
	input.angle = getPointAngle(offsetCenter, center);
	input.distance = getPointDistance(offsetCenter, center);
	const { deltaX, deltaY } = computeDeltaXY(session, input);
	input.deltaX = deltaX;
	input.deltaY = deltaY;
	input.offsetDirection = getDirection(input.deltaX, input.deltaY);
	const overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
	input.overallVelocityX = overallVelocity.x;
	input.overallVelocityY = overallVelocity.y;
	input.overallVelocity = Math.abs(overallVelocity.x) > Math.abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
	input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
	input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
	input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
	let target = manager.element;
	if (hasParent(input.srcEvent.target, target)) target = input.srcEvent.target;
	input.target = target;
	computeIntervalInputData(session, input);
	return input;
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/input-handler.js
/**
* handle input events
*/
function inputHandler(manager, eventType, input) {
	const pointersLen = input.pointers.length;
	const changedPointersLen = input.changedPointers.length;
	const isFirst = eventType & InputEvent.Start && pointersLen - changedPointersLen === 0;
	const isFinal = eventType & (InputEvent.End | InputEvent.Cancel) && pointersLen - changedPointersLen === 0;
	input.isFirst = Boolean(isFirst);
	input.isFinal = Boolean(isFinal);
	if (isFirst) manager.session = {};
	input.eventType = eventType;
	const processedInput = computeInputData(manager, input);
	manager.emit("hammer.input", processedInput);
	manager.recognize(processedInput);
	manager.session.prevInput = processedInput;
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/input/input.js
/**
* create new input type manager
*/
var Input$1 = class {
	constructor(manager) {
		this.evEl = "";
		this.evWin = "";
		this.evTarget = "";
		/** smaller wrapper around the handler, for the scope and the enabled state of the manager,
		* so when disabled the input events are completely bypassed.
		*/
		this.domHandler = (ev) => {
			if (this.manager.options.enable) this.handler(ev);
		};
		this.manager = manager;
		this.element = manager.element;
		this.target = manager.options.inputTarget || manager.element;
	}
	callback(eventType, input) {
		inputHandler(this.manager, eventType, input);
	}
	/**
	* bind the events
	*/
	init() {
		addEventListeners(this.element, this.evEl, this.domHandler);
		addEventListeners(this.target, this.evTarget, this.domHandler);
		addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
	}
	/**
	* unbind the events
	*/
	destroy() {
		removeEventListeners(this.element, this.evEl, this.domHandler);
		removeEventListeners(this.target, this.evTarget, this.domHandler);
		removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/inputs/pointerevent.js
var POINTER_INPUT_MAP = {
	pointerdown: InputEvent.Start,
	pointermove: InputEvent.Move,
	pointerup: InputEvent.End,
	pointercancel: InputEvent.Cancel,
	pointerout: InputEvent.Cancel
};
var POINTER_ELEMENT_EVENTS = "pointerdown";
var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
/**
* Pointer events input
*/
var PointerEventInput = class extends Input$1 {
	constructor(manager) {
		super(manager);
		this.evEl = POINTER_ELEMENT_EVENTS;
		this.evWin = POINTER_WINDOW_EVENTS;
		this.store = this.manager.session.pointerEvents = [];
		this.init();
	}
	/**
	* handle mouse events
	*/
	handler(ev) {
		const { store } = this;
		let removePointer = false;
		const eventType = POINTER_INPUT_MAP[ev.type];
		const pointerType = ev.pointerType;
		const isTouch = pointerType === "touch";
		let storeIndex = store.findIndex((e$2) => e$2.pointerId === ev.pointerId);
		if (eventType & InputEvent.Start && (ev.buttons || isTouch)) {
			if (storeIndex < 0) {
				store.push(ev);
				storeIndex = store.length - 1;
			}
		} else if (eventType & (InputEvent.End | InputEvent.Cancel)) removePointer = true;
		if (storeIndex < 0) return;
		store[storeIndex] = ev;
		this.callback(eventType, {
			pointers: store,
			changedPointers: [ev],
			eventType,
			pointerType,
			srcEvent: ev
		});
		if (removePointer) store.splice(storeIndex, 1);
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/utils/prefixed.js
var VENDOR_PREFIXES = [
	"",
	"webkit",
	"Moz",
	"MS",
	"ms",
	"o"
];
/**
* get the prefixed property
* @returns prefixed property name
*/
function prefixed(obj, property) {
	const camelProp = property[0].toUpperCase() + property.slice(1);
	for (const prefix of VENDOR_PREFIXES) {
		const prop = prefix ? prefix + camelProp : property;
		if (prop in obj) return prop;
	}
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/manager.js
var STOP = 1;
var FORCED_STOP = 2;
var defaultOptions = {
	touchAction: "compute",
	enable: true,
	inputTarget: null,
	cssProps: {
		userSelect: "none",
		userDrag: "none",
		touchCallout: "none",
		tapHighlightColor: "rgba(0,0,0,0)"
	}
};
/**
* Manager
*/
var Manager = class {
	constructor(element, options) {
		this.options = {
			...defaultOptions,
			...options,
			cssProps: {
				...defaultOptions.cssProps,
				...options.cssProps
			},
			inputTarget: options.inputTarget || element
		};
		this.handlers = {};
		this.session = {};
		this.recognizers = [];
		this.oldCssProps = {};
		this.element = element;
		this.input = new PointerEventInput(this);
		this.touchAction = new TouchAction(this, this.options.touchAction);
		this.toggleCssProps(true);
	}
	/**
	* set options
	*/
	set(options) {
		Object.assign(this.options, options);
		if (options.touchAction) this.touchAction.update();
		if (options.inputTarget) {
			this.input.destroy();
			this.input.target = options.inputTarget;
			this.input.init();
		}
		return this;
	}
	/**
	* stop recognizing for this session.
	* This session will be discarded, when a new [input]start event is fired.
	* When forced, the recognizer cycle is stopped immediately.
	*/
	stop(force) {
		this.session.stopped = force ? FORCED_STOP : STOP;
	}
	/**
	* run the recognizers!
	* called by the inputHandler function on every movement of the pointers (touches)
	* it walks through all the recognizers and tries to detect the gesture that is being made
	*/
	recognize(inputData) {
		const { session } = this;
		if (session.stopped) return;
		if (this.session.prevented) inputData.srcEvent.preventDefault();
		let recognizer;
		const { recognizers } = this;
		let { curRecognizer } = session;
		if (!curRecognizer || curRecognizer && curRecognizer.state & RecognizerState.Recognized) curRecognizer = session.curRecognizer = null;
		let i$1 = 0;
		while (i$1 < recognizers.length) {
			recognizer = recognizers[i$1];
			if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer === curRecognizer || recognizer.canRecognizeWith(curRecognizer))) recognizer.recognize(inputData);
			else recognizer.reset();
			if (!curRecognizer && recognizer.state & (RecognizerState.Began | RecognizerState.Changed | RecognizerState.Ended)) curRecognizer = session.curRecognizer = recognizer;
			i$1++;
		}
	}
	/**
	* get a recognizer by its event name.
	*/
	get(recognizerName) {
		const { recognizers } = this;
		for (let i$1 = 0; i$1 < recognizers.length; i$1++) if (recognizers[i$1].options.event === recognizerName) return recognizers[i$1];
		return null;
	}
	/**
	* add a recognizer to the manager
	* existing recognizers with the same event name will be removed
	*/
	add(recognizer) {
		if (Array.isArray(recognizer)) {
			for (const item of recognizer) this.add(item);
			return this;
		}
		const existing = this.get(recognizer.options.event);
		if (existing) this.remove(existing);
		this.recognizers.push(recognizer);
		recognizer.manager = this;
		this.touchAction.update();
		return recognizer;
	}
	/**
	* remove a recognizer by name or instance
	*/
	remove(recognizerOrName) {
		if (Array.isArray(recognizerOrName)) {
			for (const item of recognizerOrName) this.remove(item);
			return this;
		}
		const recognizer = typeof recognizerOrName === "string" ? this.get(recognizerOrName) : recognizerOrName;
		if (recognizer) {
			const { recognizers } = this;
			const index = recognizers.indexOf(recognizer);
			if (index !== -1) {
				recognizers.splice(index, 1);
				this.touchAction.update();
			}
		}
		return this;
	}
	/**
	* bind event
	*/
	on(events, handler) {
		if (!events || !handler) return;
		const { handlers } = this;
		for (const event of splitStr(events)) {
			handlers[event] = handlers[event] || [];
			handlers[event].push(handler);
		}
	}
	/**
	* unbind event, leave hander blank to remove all handlers
	*/
	off(events, handler) {
		if (!events) return;
		const { handlers } = this;
		for (const event of splitStr(events)) if (!handler) delete handlers[event];
		else if (handlers[event]) handlers[event].splice(handlers[event].indexOf(handler), 1);
	}
	/**
	* emit event to the listeners
	*/
	emit(event, data) {
		const handlers = this.handlers[event] && this.handlers[event].slice();
		if (!handlers || !handlers.length) return;
		const evt = data;
		evt.type = event;
		evt.preventDefault = function() {
			data.srcEvent.preventDefault();
		};
		let i$1 = 0;
		while (i$1 < handlers.length) {
			handlers[i$1](evt);
			i$1++;
		}
	}
	/**
	* destroy the manager and unbinds all events
	* it doesn't unbind dom events, that is the user own responsibility
	*/
	destroy() {
		this.toggleCssProps(false);
		this.handlers = {};
		this.session = {};
		this.input.destroy();
		this.element = null;
	}
	/**
	* add/remove the css properties as defined in manager.options.cssProps
	*/
	toggleCssProps(add$2) {
		const { element } = this;
		if (!element) return;
		for (const [name, value] of Object.entries(this.options.cssProps)) {
			const prop = prefixed(element.style, name);
			if (add$2) {
				this.oldCssProps[prop] = element.style[prop];
				element.style[prop] = value;
			} else element.style[prop] = this.oldCssProps[prop] || "";
		}
		if (!add$2) this.oldCssProps = {};
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/utils/unique-id.js
/**
* get a unique id
*/
var _uniqueId = 1;
function uniqueId() {
	return _uniqueId++;
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/recognizer/state-str.js
/**
* get a usable string, used as event postfix
*/
function stateStr(state) {
	if (state & RecognizerState.Cancelled) return "cancel";
	else if (state & RecognizerState.Ended) return "end";
	else if (state & RecognizerState.Changed) return "move";
	else if (state & RecognizerState.Began) return "start";
	return "";
}

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/recognizer/recognizer.js
/**
* Recognizer flow explained; *
* All recognizers have the initial state of POSSIBLE when a input session starts.
* The definition of a input session is from the first input until the last input, with all it's movement in it. *
* Example session for mouse-input: mousedown -> mousemove -> mouseup
*
* On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
* which determines with state it should be.
*
* If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
* POSSIBLE to give it another change on the next cycle.
*
*               Possible
*                  |
*            +-----+---------------+
*            |                     |
*      +-----+-----+               |
*      |           |               |
*   Failed      Cancelled          |
*                          +-------+------+
*                          |              |
*                      Recognized       Began
*                                         |
*                                      Changed
*                                         |
*                                  Ended/Recognized
*/
/**
* Recognizer
* Every recognizer needs to extend from this class.
*/
var Recognizer = class {
	constructor(options) {
		this.options = options;
		this.id = uniqueId();
		this.state = RecognizerState.Possible;
		this.simultaneous = {};
		this.requireFail = [];
	}
	/**
	* set options
	*/
	set(options) {
		Object.assign(this.options, options);
		this.manager.touchAction.update();
		return this;
	}
	/**
	* recognize simultaneous with an other recognizer.
	*/
	recognizeWith(recognizerOrName) {
		if (Array.isArray(recognizerOrName)) {
			for (const item of recognizerOrName) this.recognizeWith(item);
			return this;
		}
		let otherRecognizer;
		if (typeof recognizerOrName === "string") {
			otherRecognizer = this.manager.get(recognizerOrName);
			if (!otherRecognizer) throw new Error(`Cannot find recognizer ${recognizerOrName}`);
		} else otherRecognizer = recognizerOrName;
		const { simultaneous } = this;
		if (!simultaneous[otherRecognizer.id]) {
			simultaneous[otherRecognizer.id] = otherRecognizer;
			otherRecognizer.recognizeWith(this);
		}
		return this;
	}
	/**
	* drop the simultaneous link. it doesnt remove the link on the other recognizer.
	*/
	dropRecognizeWith(recognizerOrName) {
		if (Array.isArray(recognizerOrName)) {
			for (const item of recognizerOrName) this.dropRecognizeWith(item);
			return this;
		}
		let otherRecognizer;
		if (typeof recognizerOrName === "string") otherRecognizer = this.manager.get(recognizerOrName);
		else otherRecognizer = recognizerOrName;
		if (otherRecognizer) delete this.simultaneous[otherRecognizer.id];
		return this;
	}
	/**
	* recognizer can only run when an other is failing
	*/
	requireFailure(recognizerOrName) {
		if (Array.isArray(recognizerOrName)) {
			for (const item of recognizerOrName) this.requireFailure(item);
			return this;
		}
		let otherRecognizer;
		if (typeof recognizerOrName === "string") {
			otherRecognizer = this.manager.get(recognizerOrName);
			if (!otherRecognizer) throw new Error(`Cannot find recognizer ${recognizerOrName}`);
		} else otherRecognizer = recognizerOrName;
		const { requireFail } = this;
		if (requireFail.indexOf(otherRecognizer) === -1) {
			requireFail.push(otherRecognizer);
			otherRecognizer.requireFailure(this);
		}
		return this;
	}
	/**
	* drop the requireFailure link. it does not remove the link on the other recognizer.
	*/
	dropRequireFailure(recognizerOrName) {
		if (Array.isArray(recognizerOrName)) {
			for (const item of recognizerOrName) this.dropRequireFailure(item);
			return this;
		}
		let otherRecognizer;
		if (typeof recognizerOrName === "string") otherRecognizer = this.manager.get(recognizerOrName);
		else otherRecognizer = recognizerOrName;
		if (otherRecognizer) {
			const index = this.requireFail.indexOf(otherRecognizer);
			if (index > -1) this.requireFail.splice(index, 1);
		}
		return this;
	}
	/**
	* has require failures boolean
	*/
	hasRequireFailures() {
		return Boolean(this.requireFail.find((recognier) => recognier.options.enable));
	}
	/**
	* if the recognizer can recognize simultaneous with an other recognizer
	*/
	canRecognizeWith(otherRecognizer) {
		return Boolean(this.simultaneous[otherRecognizer.id]);
	}
	/**
	* You should use `tryEmit` instead of `emit` directly to check
	* that all the needed recognizers has failed before emitting.
	*/
	emit(input) {
		if (!input) return;
		const { state } = this;
		if (state < RecognizerState.Ended) this.manager.emit(this.options.event + stateStr(state), input);
		this.manager.emit(this.options.event, input);
		if (input.additionalEvent) this.manager.emit(input.additionalEvent, input);
		if (state >= RecognizerState.Ended) this.manager.emit(this.options.event + stateStr(state), input);
	}
	/**
	* Check that all the require failure recognizers has failed,
	* if true, it emits a gesture event,
	* otherwise, setup the state to FAILED.
	*/
	tryEmit(input) {
		if (this.canEmit()) this.emit(input);
		else this.state = RecognizerState.Failed;
	}
	/**
	* can we emit?
	*/
	canEmit() {
		let i$1 = 0;
		while (i$1 < this.requireFail.length) {
			if (!(this.requireFail[i$1].state & (RecognizerState.Failed | RecognizerState.Possible))) return false;
			i$1++;
		}
		return true;
	}
	/**
	* update the recognizer
	*/
	recognize(inputData) {
		const inputDataClone = { ...inputData };
		if (!this.options.enable) {
			this.reset();
			this.state = RecognizerState.Failed;
			return;
		}
		if (this.state & (RecognizerState.Recognized | RecognizerState.Cancelled | RecognizerState.Failed)) this.state = RecognizerState.Possible;
		this.state = this.process(inputDataClone);
		if (this.state & (RecognizerState.Began | RecognizerState.Changed | RecognizerState.Ended | RecognizerState.Cancelled)) this.tryEmit(inputDataClone);
	}
	/**
	* return the event names that are emitted by this recognizer
	*/
	getEventNames() {
		return [this.options.event];
	}
	/**
	* called when the gesture isn't allowed to recognize
	* like when another is being recognized or it is disabled
	*/
	reset() {}
};

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/recognizers/attribute.js
/**
* This recognizer is just used as a base for the simple attribute recognizers.
*/
var AttrRecognizer = class extends Recognizer {
	/**
	* Used to check if it the recognizer receives valid input, like input.distance > 10.
	*/
	attrTest(input) {
		const optionPointers = this.options.pointers;
		return optionPointers === 0 || input.pointers.length === optionPointers;
	}
	/**
	* Process the input and return the state for the recognizer
	*/
	process(input) {
		const { state } = this;
		const { eventType } = input;
		const isRecognized = state & (RecognizerState.Began | RecognizerState.Changed);
		const isValid = this.attrTest(input);
		if (isRecognized && (eventType & InputEvent.Cancel || !isValid)) return state | RecognizerState.Cancelled;
		else if (isRecognized || isValid) {
			if (eventType & InputEvent.End) return state | RecognizerState.Ended;
			else if (!(state & RecognizerState.Began)) return RecognizerState.Began;
			return state | RecognizerState.Changed;
		}
		return RecognizerState.Failed;
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/recognizers/tap.js
/**
* A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
* between the given interval and position. The delay option can be used to recognize multi-taps without firing
* a single tap.
*
* The eventData from the emitted event contains the property `tapCount`, which contains the amount of
* multi-taps being recognized.
*/
var TapRecognizer = class extends Recognizer {
	constructor(options = {}) {
		super({
			enable: true,
			event: "tap",
			pointers: 1,
			taps: 1,
			interval: 300,
			time: 250,
			threshold: 9,
			posThreshold: 10,
			...options
		});
		/** previous time for tap counting */
		this.pTime = null;
		/** previous center for tap counting */
		this.pCenter = null;
		this._timer = null;
		this._input = null;
		this.count = 0;
	}
	getTouchAction() {
		return [TOUCH_ACTION_MANIPULATION];
	}
	process(input) {
		const { options } = this;
		const validPointers = input.pointers.length === options.pointers;
		const validMovement = input.distance < options.threshold;
		const validTouchTime = input.deltaTime < options.time;
		this.reset();
		if (input.eventType & InputEvent.Start && this.count === 0) return this.failTimeout();
		if (validMovement && validTouchTime && validPointers) {
			if (input.eventType !== InputEvent.End) return this.failTimeout();
			const validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
			const validMultiTap = !this.pCenter || getPointDistance(this.pCenter, input.center) < options.posThreshold;
			this.pTime = input.timeStamp;
			this.pCenter = input.center;
			if (!validMultiTap || !validInterval) this.count = 1;
			else this.count += 1;
			this._input = input;
			if (this.count % options.taps === 0) {
				if (!this.hasRequireFailures()) return RecognizerState.Recognized;
				this._timer = setTimeout(() => {
					this.state = RecognizerState.Recognized;
					this.tryEmit(this._input);
				}, options.interval);
				return RecognizerState.Began;
			}
		}
		return RecognizerState.Failed;
	}
	failTimeout() {
		this._timer = setTimeout(() => {
			this.state = RecognizerState.Failed;
		}, this.options.interval);
		return RecognizerState.Failed;
	}
	reset() {
		clearTimeout(this._timer);
	}
	emit(input) {
		if (this.state === RecognizerState.Recognized) {
			input.tapCount = this.count;
			this.manager.emit(this.options.event, input);
		}
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/recognizers/pan.js
var EVENT_NAMES$1 = [
	"",
	"start",
	"move",
	"end",
	"cancel",
	"up",
	"down",
	"left",
	"right"
];
/**
* Pan
* Recognized when the pointer is down and moved in the allowed direction.
*/
var PanRecognizer = class extends AttrRecognizer {
	constructor(options = {}) {
		super({
			enable: true,
			pointers: 1,
			event: "pan",
			threshold: 10,
			direction: InputDirection.All,
			...options
		});
		this.pX = null;
		this.pY = null;
	}
	getTouchAction() {
		const { options: { direction } } = this;
		const actions = [];
		if (direction & InputDirection.Horizontal) actions.push(TOUCH_ACTION_PAN_Y);
		if (direction & InputDirection.Vertical) actions.push(TOUCH_ACTION_PAN_X);
		return actions;
	}
	getEventNames() {
		return EVENT_NAMES$1.map((suffix) => this.options.event + suffix);
	}
	directionTest(input) {
		const { options } = this;
		let hasMoved = true;
		let { distance: distance$1 } = input;
		let { direction } = input;
		const x$1 = input.deltaX;
		const y$1 = input.deltaY;
		if (!(direction & options.direction)) if (options.direction & InputDirection.Horizontal) {
			direction = x$1 === 0 ? InputDirection.None : x$1 < 0 ? InputDirection.Left : InputDirection.Right;
			hasMoved = x$1 !== this.pX;
			distance$1 = Math.abs(input.deltaX);
		} else {
			direction = y$1 === 0 ? InputDirection.None : y$1 < 0 ? InputDirection.Up : InputDirection.Down;
			hasMoved = y$1 !== this.pY;
			distance$1 = Math.abs(input.deltaY);
		}
		input.direction = direction;
		return hasMoved && distance$1 > options.threshold && Boolean(direction & options.direction);
	}
	attrTest(input) {
		return super.attrTest(input) && (Boolean(this.state & RecognizerState.Began) || !(this.state & RecognizerState.Began) && this.directionTest(input));
	}
	emit(input) {
		this.pX = input.deltaX;
		this.pY = input.deltaY;
		const direction = InputDirection[input.direction].toLowerCase();
		if (direction) input.additionalEvent = this.options.event + direction;
		super.emit(input);
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/hammerjs/recognizers/pinch.js
var EVENT_NAMES = [
	"",
	"start",
	"move",
	"end",
	"cancel",
	"in",
	"out"
];
/**
* Pinch
* Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
*/
var PinchRecognizer = class extends AttrRecognizer {
	constructor(options = {}) {
		super({
			enable: true,
			event: "pinch",
			threshold: 0,
			pointers: 2,
			...options
		});
	}
	getTouchAction() {
		return [TOUCH_ACTION_NONE];
	}
	getEventNames() {
		return EVENT_NAMES.map((suffix) => this.options.event + suffix);
	}
	attrTest(input) {
		return super.attrTest(input) && (Math.abs(input.scale - 1) > this.options.threshold || Boolean(this.state & RecognizerState.Began));
	}
	emit(input) {
		if (input.scale !== 1) {
			const inOut = input.scale < 1 ? "in" : "out";
			input.additionalEvent = this.options.event + inOut;
		}
		super.emit(input);
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/inputs/input.js
var Input = class {
	constructor(element, callback, options) {
		this.element = element;
		this.callback = callback;
		this.options = options;
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/utils/globals.js
const userAgent = typeof navigator !== "undefined" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "";
var window_ = typeof window !== "undefined" ? window : global;

//#endregion
//#region node_modules/mjolnir.js/dist/inputs/wheel-input.js
var firefox = userAgent.indexOf("firefox") !== -1;
var WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
var WHEEL_DELTA_PER_LINE = 40;
var SHIFT_MULTIPLIER = .25;
var WheelInput = class extends Input {
	constructor(element, callback, options) {
		super(element, callback, {
			enable: true,
			...options
		});
		this.handleEvent = (event) => {
			if (!this.options.enable) return;
			let value = event.deltaY;
			if (globalThis.WheelEvent) {
				if (firefox && event.deltaMode === globalThis.WheelEvent.DOM_DELTA_PIXEL) value /= globalThis.devicePixelRatio;
				if (event.deltaMode === globalThis.WheelEvent.DOM_DELTA_LINE) value *= WHEEL_DELTA_PER_LINE;
			}
			if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);
			if (event.shiftKey && value) value = value * SHIFT_MULTIPLIER;
			this.callback({
				type: "wheel",
				center: {
					x: event.clientX,
					y: event.clientY
				},
				delta: -value,
				srcEvent: event,
				pointerType: "mouse",
				target: event.target
			});
		};
		element.addEventListener("wheel", this.handleEvent, { passive: false });
	}
	destroy() {
		this.element.removeEventListener("wheel", this.handleEvent);
	}
	/**
	* Enable this input (begin processing events)
	* if the specified event type is among those handled by this input.
	*/
	enableEventType(eventType, enabled) {
		if (eventType === "wheel") this.options.enable = enabled;
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/inputs/move-input.js
var MOUSE_EVENTS$1 = [
	"mousedown",
	"mousemove",
	"mouseup",
	"mouseover",
	"mouseout",
	"mouseleave"
];
/**
* Hammer.js swallows 'move' events (for pointer/touch/mouse)
* when the pointer is not down. This class sets up a handler
* specifically for these events to work around this limitation.
* Note that this could be extended to more intelligently handle
* move events across input types, e.g. storing multiple simultaneous
* pointer/touch events, calculating speed/direction, etc.
*/
var MoveInput = class extends Input {
	constructor(element, callback, options) {
		super(element, callback, {
			enable: true,
			...options
		});
		this.handleEvent = (event) => {
			this.handleOverEvent(event);
			this.handleOutEvent(event);
			this.handleEnterEvent(event);
			this.handleLeaveEvent(event);
			this.handleMoveEvent(event);
		};
		this.pressed = false;
		const { enable } = this.options;
		this.enableMoveEvent = enable;
		this.enableLeaveEvent = enable;
		this.enableEnterEvent = enable;
		this.enableOutEvent = enable;
		this.enableOverEvent = enable;
		MOUSE_EVENTS$1.forEach((event) => element.addEventListener(event, this.handleEvent));
	}
	destroy() {
		MOUSE_EVENTS$1.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
	}
	/**
	* Enable this input (begin processing events)
	* if the specified event type is among those handled by this input.
	*/
	enableEventType(eventType, enabled) {
		switch (eventType) {
			case "pointermove":
				this.enableMoveEvent = enabled;
				break;
			case "pointerover":
				this.enableOverEvent = enabled;
				break;
			case "pointerout":
				this.enableOutEvent = enabled;
				break;
			case "pointerenter":
				this.enableEnterEvent = enabled;
				break;
			case "pointerleave":
				this.enableLeaveEvent = enabled;
				break;
			default:
		}
	}
	handleOverEvent(event) {
		if (this.enableOverEvent && event.type === "mouseover") this._emit("pointerover", event);
	}
	handleOutEvent(event) {
		if (this.enableOutEvent && event.type === "mouseout") this._emit("pointerout", event);
	}
	handleEnterEvent(event) {
		if (this.enableEnterEvent && event.type === "mouseenter") this._emit("pointerenter", event);
	}
	handleLeaveEvent(event) {
		if (this.enableLeaveEvent && event.type === "mouseleave") this._emit("pointerleave", event);
	}
	handleMoveEvent(event) {
		if (this.enableMoveEvent) switch (event.type) {
			case "mousedown":
				if (event.button >= 0) this.pressed = true;
				break;
			case "mousemove":
				if (event.buttons === 0) this.pressed = false;
				if (!this.pressed) this._emit("pointermove", event);
				break;
			case "mouseup":
				this.pressed = false;
				break;
			default:
		}
	}
	_emit(type, event) {
		this.callback({
			type,
			center: {
				x: event.clientX,
				y: event.clientY
			},
			srcEvent: event,
			pointerType: "mouse",
			target: event.target
		});
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/inputs/key-input.js
var KEY_EVENTS = ["keydown", "keyup"];
var KeyInput = class extends Input {
	constructor(element, callback, options) {
		super(element, callback, {
			enable: true,
			tabIndex: 0,
			...options
		});
		this.handleEvent = (event) => {
			const targetElement = event.target || event.srcElement;
			if (targetElement.tagName === "INPUT" && targetElement.type === "text" || targetElement.tagName === "TEXTAREA") return;
			if (this.enableDownEvent && event.type === "keydown") this.callback({
				type: "keydown",
				srcEvent: event,
				key: event.key,
				target: event.target
			});
			if (this.enableUpEvent && event.type === "keyup") this.callback({
				type: "keyup",
				srcEvent: event,
				key: event.key,
				target: event.target
			});
		};
		this.enableDownEvent = this.options.enable;
		this.enableUpEvent = this.options.enable;
		element.tabIndex = this.options.tabIndex;
		element.style.outline = "none";
		KEY_EVENTS.forEach((event) => element.addEventListener(event, this.handleEvent));
	}
	destroy() {
		KEY_EVENTS.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
	}
	/**
	* Enable this input (begin processing events)
	* if the specified event type is among those handled by this input.
	*/
	enableEventType(eventType, enabled) {
		if (eventType === "keydown") this.enableDownEvent = enabled;
		if (eventType === "keyup") this.enableUpEvent = enabled;
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/inputs/contextmenu-input.js
var ContextmenuInput = class extends Input {
	constructor(element, callback, options) {
		super(element, callback, options);
		this.handleEvent = (event) => {
			if (!this.options.enable) return;
			this.callback({
				type: "contextmenu",
				center: {
					x: event.clientX,
					y: event.clientY
				},
				srcEvent: event,
				pointerType: "mouse",
				target: event.target
			});
		};
		element.addEventListener("contextmenu", this.handleEvent);
	}
	destroy() {
		this.element.removeEventListener("contextmenu", this.handleEvent);
	}
	/**
	* Enable this input (begin processing events)
	* if the specified event type is among those handled by this input.
	*/
	enableEventType(eventType, enabled) {
		if (eventType === "contextmenu") this.options.enable = enabled;
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/utils/event-utils.js
var DOWN_EVENT = 1;
var MOVE_EVENT = 2;
var UP_EVENT = 4;
var MOUSE_EVENTS = {
	pointerdown: DOWN_EVENT,
	pointermove: MOVE_EVENT,
	pointerup: UP_EVENT,
	mousedown: DOWN_EVENT,
	mousemove: MOVE_EVENT,
	mouseup: UP_EVENT
};
var MOUSE_EVENT_BUTTON_LEFT = 0;
var MOUSE_EVENT_BUTTON_MIDDLE = 1;
var MOUSE_EVENT_BUTTON_RIGHT = 2;
var MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;
var MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;
var MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;
/**
* Extract the involved mouse button
*/
function whichButtons(event) {
	const eventType = MOUSE_EVENTS[event.srcEvent.type];
	if (!eventType) return null;
	const { buttons, button } = event.srcEvent;
	let leftButton = false;
	let middleButton = false;
	let rightButton = false;
	if (eventType === MOVE_EVENT) {
		leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);
		middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);
		rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);
	} else {
		leftButton = button === MOUSE_EVENT_BUTTON_LEFT;
		middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;
		rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;
	}
	return {
		leftButton,
		middleButton,
		rightButton
	};
}
/**
* Calculate event position relative to the root element
*/
function getOffsetPosition(event, rootElement) {
	const center = event.center;
	if (!center) return null;
	const rect = rootElement.getBoundingClientRect();
	const scaleX = rect.width / rootElement.offsetWidth || 1;
	const scaleY = rect.height / rootElement.offsetHeight || 1;
	return {
		center,
		offsetCenter: {
			x: (center.x - rect.left - rootElement.clientLeft) / scaleX,
			y: (center.y - rect.top - rootElement.clientTop) / scaleY
		}
	};
}

//#endregion
//#region node_modules/mjolnir.js/dist/utils/event-registrar.js
var DEFAULT_OPTIONS = {
	srcElement: "root",
	priority: 0
};
var EventRegistrar = class {
	constructor(eventManager, recognizerName) {
		/**
		* Handles hammerjs event
		*/
		this.handleEvent = (event) => {
			if (this.isEmpty()) return;
			const mjolnirEvent = this._normalizeEvent(event);
			let target = event.srcEvent.target;
			while (target && target !== mjolnirEvent.rootElement) {
				this._emit(mjolnirEvent, target);
				if (mjolnirEvent.handled) return;
				target = target.parentNode;
			}
			this._emit(mjolnirEvent, "root");
		};
		this.eventManager = eventManager;
		this.recognizerName = recognizerName;
		this.handlers = [];
		this.handlersByElement = /* @__PURE__ */ new Map();
		this._active = false;
	}
	isEmpty() {
		return !this._active;
	}
	add(type, handler, options, once = false, passive = false) {
		const { handlers, handlersByElement } = this;
		const opts = {
			...DEFAULT_OPTIONS,
			...options
		};
		let entries = handlersByElement.get(opts.srcElement);
		if (!entries) {
			entries = [];
			handlersByElement.set(opts.srcElement, entries);
		}
		const entry = {
			type,
			handler,
			srcElement: opts.srcElement,
			priority: opts.priority
		};
		if (once) entry.once = true;
		if (passive) entry.passive = true;
		handlers.push(entry);
		this._active = this._active || !entry.passive;
		let insertPosition = entries.length - 1;
		while (insertPosition >= 0) {
			if (entries[insertPosition].priority >= entry.priority) break;
			insertPosition--;
		}
		entries.splice(insertPosition + 1, 0, entry);
	}
	remove(type, handler) {
		const { handlers, handlersByElement } = this;
		for (let i$1 = handlers.length - 1; i$1 >= 0; i$1--) {
			const entry = handlers[i$1];
			if (entry.type === type && entry.handler === handler) {
				handlers.splice(i$1, 1);
				const entries = handlersByElement.get(entry.srcElement);
				entries.splice(entries.indexOf(entry), 1);
				if (entries.length === 0) handlersByElement.delete(entry.srcElement);
			}
		}
		this._active = handlers.some((entry) => !entry.passive);
	}
	/**
	* Invoke handlers on a particular element
	*/
	_emit(event, srcElement) {
		const entries = this.handlersByElement.get(srcElement);
		if (entries) {
			let immediatePropagationStopped = false;
			const stopPropagation = () => {
				event.handled = true;
			};
			const stopImmediatePropagation = () => {
				event.handled = true;
				immediatePropagationStopped = true;
			};
			const entriesToRemove = [];
			for (let i$1 = 0; i$1 < entries.length; i$1++) {
				const { type, handler, once } = entries[i$1];
				handler({
					...event,
					type,
					stopPropagation,
					stopImmediatePropagation
				});
				if (once) entriesToRemove.push(entries[i$1]);
				if (immediatePropagationStopped) break;
			}
			for (let i$1 = 0; i$1 < entriesToRemove.length; i$1++) {
				const { type, handler } = entriesToRemove[i$1];
				this.remove(type, handler);
			}
		}
	}
	/**
	* Normalizes hammerjs and custom events to have predictable fields.
	*/
	_normalizeEvent(event) {
		const rootElement = this.eventManager.getElement();
		return {
			...event,
			...whichButtons(event),
			...getOffsetPosition(event, rootElement),
			preventDefault: () => {
				event.srcEvent.preventDefault();
			},
			stopImmediatePropagation: null,
			stopPropagation: null,
			handled: false,
			rootElement
		};
	}
};

//#endregion
//#region node_modules/mjolnir.js/dist/event-manager.js
function normalizeRecognizer(item) {
	if ("recognizer" in item) return item;
	let recognizer;
	const itemArray = Array.isArray(item) ? [...item] : [item];
	if (typeof itemArray[0] === "function") recognizer = new (itemArray.shift())(itemArray.shift() || {});
	else recognizer = itemArray.shift();
	return {
		recognizer,
		recognizeWith: typeof itemArray[0] === "string" ? [itemArray[0]] : itemArray[0],
		requireFailure: typeof itemArray[1] === "string" ? [itemArray[1]] : itemArray[1]
	};
}
var EventManager = class {
	constructor(element = null, options = {}) {
		/**
		* Handle basic events using the 'hammer.input' Hammer.js API:
		* Before running Recognizers, Hammer emits a 'hammer.input' event
		* with the basic event info. This function emits all basic events
		* aliased to the "class" of event received.
		* See constants.BASIC_EVENT_CLASSES basic event class definitions.
		*/
		this._onBasicInput = (event) => {
			this.manager.emit(event.srcEvent.type, event);
		};
		/**
		* Handle events not supported by Hammer.js,
		* and pipe back out through same (Hammer) channel used by other events.
		*/
		this._onOtherEvent = (event) => {
			this.manager.emit(event.type, event);
		};
		this.options = {
			recognizers: [],
			events: {},
			touchAction: "compute",
			tabIndex: 0,
			cssProps: {},
			...options
		};
		this.events = /* @__PURE__ */ new Map();
		this.element = element;
		if (!element) return;
		this.manager = new Manager(element, this.options);
		for (const item of this.options.recognizers) {
			const { recognizer, recognizeWith, requireFailure } = normalizeRecognizer(item);
			this.manager.add(recognizer);
			if (recognizeWith) recognizer.recognizeWith(recognizeWith);
			if (requireFailure) recognizer.requireFailure(requireFailure);
		}
		this.manager.on("hammer.input", this._onBasicInput);
		this.wheelInput = new WheelInput(element, this._onOtherEvent, { enable: false });
		this.moveInput = new MoveInput(element, this._onOtherEvent, { enable: false });
		this.keyInput = new KeyInput(element, this._onOtherEvent, {
			enable: false,
			tabIndex: options.tabIndex
		});
		this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, { enable: false });
		this.on(this.options.events);
	}
	getElement() {
		return this.element;
	}
	destroy() {
		if (!this.element) return;
		this.wheelInput.destroy();
		this.moveInput.destroy();
		this.keyInput.destroy();
		this.contextmenuInput.destroy();
		this.manager.destroy();
	}
	/** Register an event handler function to be called on `event` */
	on(event, handler, opts) {
		this._addEventHandler(event, handler, opts, false);
	}
	once(event, handler, opts) {
		this._addEventHandler(event, handler, opts, true);
	}
	watch(event, handler, opts) {
		this._addEventHandler(event, handler, opts, false, true);
	}
	off(event, handler) {
		this._removeEventHandler(event, handler);
	}
	_toggleRecognizer(name, enabled) {
		const { manager } = this;
		if (!manager) return;
		const recognizer = manager.get(name);
		if (recognizer) {
			recognizer.set({ enable: enabled });
			manager.touchAction.update();
		}
		this.wheelInput?.enableEventType(name, enabled);
		this.moveInput?.enableEventType(name, enabled);
		this.keyInput?.enableEventType(name, enabled);
		this.contextmenuInput?.enableEventType(name, enabled);
	}
	/**
	* Process the event registration for a single event + handler.
	*/
	_addEventHandler(event, handler, opts, once, passive) {
		if (typeof event !== "string") {
			opts = handler;
			for (const [eventName, eventHandler] of Object.entries(event)) this._addEventHandler(eventName, eventHandler, opts, once, passive);
			return;
		}
		const { manager, events } = this;
		if (!manager) return;
		let eventRegistrar = events.get(event);
		if (!eventRegistrar) {
			const recognizerName = this._getRecognizerName(event) || event;
			eventRegistrar = new EventRegistrar(this, recognizerName);
			events.set(event, eventRegistrar);
			if (manager) manager.on(event, eventRegistrar.handleEvent);
		}
		eventRegistrar.add(event, handler, opts, once, passive);
		if (!eventRegistrar.isEmpty()) this._toggleRecognizer(eventRegistrar.recognizerName, true);
	}
	/**
	* Process the event deregistration for a single event + handler.
	*/
	_removeEventHandler(event, handler) {
		if (typeof event !== "string") {
			for (const [eventName, eventHandler] of Object.entries(event)) this._removeEventHandler(eventName, eventHandler);
			return;
		}
		const { events } = this;
		const eventRegistrar = events.get(event);
		if (!eventRegistrar) return;
		eventRegistrar.remove(event, handler);
		if (eventRegistrar.isEmpty()) {
			const { recognizerName } = eventRegistrar;
			let isRecognizerUsed = false;
			for (const eh of events.values()) if (eh.recognizerName === recognizerName && !eh.isEmpty()) {
				isRecognizerUsed = true;
				break;
			}
			if (!isRecognizerUsed) this._toggleRecognizer(recognizerName, false);
		}
	}
	_getRecognizerName(event) {
		return this.manager.recognizers.find((recognizer) => {
			return recognizer.getEventNames().includes(event);
		})?.options.event;
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/constants.js
/**
* The coordinate system that positions/dimensions are defined in.
*/
const COORDINATE_SYSTEM = {
	DEFAULT: -1,
	LNGLAT: 1,
	METER_OFFSETS: 2,
	LNGLAT_OFFSETS: 3,
	CARTESIAN: 0
};
Object.defineProperty(COORDINATE_SYSTEM, "IDENTITY", { get: () => {
	log_default.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")();
	return 0;
} });
/**
* How coordinates are transformed from the world space into the common space.
*/
const PROJECTION_MODE = {
	WEB_MERCATOR: 1,
	GLOBE: 2,
	WEB_MERCATOR_AUTO_OFFSET: 4,
	IDENTITY: 0
};
const UNIT = {
	common: 0,
	meters: 1,
	pixels: 2
};
const EVENT_HANDLERS = {
	click: "onClick",
	dblclick: "onClick",
	panstart: "onDragStart",
	panmove: "onDrag",
	panend: "onDragEnd"
};
const RECOGNIZERS = {
	multipan: [PanRecognizer, {
		threshold: 10,
		direction: InputDirection.Vertical,
		pointers: 2
	}],
	pinch: [
		PinchRecognizer,
		{},
		null,
		["multipan"]
	],
	pan: [
		PanRecognizer,
		{ threshold: 1 },
		["pinch"],
		["multipan"]
	],
	dblclick: [TapRecognizer, {
		event: "dblclick",
		taps: 2
	}],
	click: [
		TapRecognizer,
		{ event: "click" },
		null,
		["dblclick"]
	]
};
/**
* @deprecated Use string constants directly
*/
const OPERATION = {
	DRAW: "draw",
	MASK: "mask",
	TERRAIN: "terrain"
};

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/memoize.js
function isEqual(a$1, b$1) {
	if (a$1 === b$1) return true;
	if (Array.isArray(a$1)) {
		const len$1 = a$1.length;
		if (!b$1 || b$1.length !== len$1) return false;
		for (let i$1 = 0; i$1 < len$1; i$1++) if (a$1[i$1] !== b$1[i$1]) return false;
		return true;
	}
	return false;
}
/**
* Speed up consecutive function calls by caching the result of calls with identical input
* https://en.wikipedia.org/wiki/Memoization
* @param {function} compute - the function to be memoized
*/
function memoize(compute) {
	let cachedArgs = {};
	let cachedResult;
	return (args) => {
		for (const key in args) if (!isEqual(args[key], cachedArgs[key])) {
			cachedResult = compute(args);
			cachedArgs = args;
			break;
		}
		return cachedResult;
	};
}

//#endregion
//#region node_modules/@deck.gl/core/dist/shaderlib/project/viewport-uniforms.js
var ZERO_VECTOR$1 = [
	0,
	0,
	0,
	0
];
var VECTOR_TO_POINT_MATRIX$1 = [
	1,
	0,
	0,
	0,
	0,
	1,
	0,
	0,
	0,
	0,
	1,
	0,
	0,
	0,
	0,
	0
];
var IDENTITY_MATRIX = [
	1,
	0,
	0,
	0,
	0,
	1,
	0,
	0,
	0,
	0,
	1,
	0,
	0,
	0,
	0,
	1
];
var DEFAULT_PIXELS_PER_UNIT2 = [
	0,
	0,
	0
];
var DEFAULT_COORDINATE_ORIGIN$1 = [
	0,
	0,
	0
];
var getMemoizedViewportUniforms = memoize(calculateViewportUniforms);
function getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin = DEFAULT_COORDINATE_ORIGIN$1) {
	if (coordinateOrigin.length < 3) coordinateOrigin = [
		coordinateOrigin[0],
		coordinateOrigin[1],
		0
	];
	let shaderCoordinateOrigin = coordinateOrigin;
	let geospatialOrigin;
	let offsetMode = true;
	if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) geospatialOrigin = coordinateOrigin;
	else geospatialOrigin = viewport.isGeospatial ? [
		Math.fround(viewport.longitude),
		Math.fround(viewport.latitude),
		0
	] : null;
	switch (viewport.projectionMode) {
		case PROJECTION_MODE.WEB_MERCATOR:
			if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
				geospatialOrigin = [
					0,
					0,
					0
				];
				offsetMode = false;
			}
			break;
		case PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET:
			if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) shaderCoordinateOrigin = geospatialOrigin;
			else if (coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
				shaderCoordinateOrigin = [
					Math.fround(viewport.center[0]),
					Math.fround(viewport.center[1]),
					0
				];
				geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);
				shaderCoordinateOrigin[0] -= coordinateOrigin[0];
				shaderCoordinateOrigin[1] -= coordinateOrigin[1];
				shaderCoordinateOrigin[2] -= coordinateOrigin[2];
			}
			break;
		case PROJECTION_MODE.IDENTITY:
			shaderCoordinateOrigin = viewport.position.map(Math.fround);
			shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;
			break;
		case PROJECTION_MODE.GLOBE:
			offsetMode = false;
			geospatialOrigin = null;
			break;
		default: offsetMode = false;
	}
	return {
		geospatialOrigin,
		shaderCoordinateOrigin,
		offsetMode
	};
}
function calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin) {
	const { viewMatrixUncentered, projectionMatrix } = viewport;
	let { viewMatrix: viewMatrix$1, viewProjectionMatrix } = viewport;
	let projectionCenter = ZERO_VECTOR$1;
	let originCommon = ZERO_VECTOR$1;
	let cameraPosCommon = viewport.cameraPosition;
	const { geospatialOrigin, shaderCoordinateOrigin, offsetMode } = getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin);
	if (offsetMode) {
		originCommon = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
		cameraPosCommon = [
			cameraPosCommon[0] - originCommon[0],
			cameraPosCommon[1] - originCommon[1],
			cameraPosCommon[2] - originCommon[2]
		];
		originCommon[3] = 1;
		projectionCenter = transformMat4$2([], originCommon, viewProjectionMatrix);
		viewMatrix$1 = viewMatrixUncentered || viewMatrix$1;
		viewProjectionMatrix = multiply([], projectionMatrix, viewMatrix$1);
		viewProjectionMatrix = multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX$1);
	}
	return {
		viewMatrix: viewMatrix$1,
		viewProjectionMatrix,
		projectionCenter,
		originCommon,
		cameraPosCommon,
		shaderCoordinateOrigin,
		geospatialOrigin
	};
}
/**
* Returns uniforms for shaders based on current projection
* includes: projection matrix suitable for shaders
*
* TODO - Ensure this works with any viewport, not just WebMercatorViewports
*
* @param {WebMercatorViewport} viewport -
* @return {Float32Array} - 4x4 projection matrix that can be used in shaders
*/
function getUniformsFromViewport({ viewport, devicePixelRatio = 1, modelMatrix = null, coordinateSystem = COORDINATE_SYSTEM.DEFAULT, coordinateOrigin = DEFAULT_COORDINATE_ORIGIN$1, autoWrapLongitude = false }) {
	if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
	const uniforms = getMemoizedViewportUniforms({
		viewport,
		devicePixelRatio,
		coordinateSystem,
		coordinateOrigin
	});
	uniforms.wrapLongitude = autoWrapLongitude;
	uniforms.modelMatrix = modelMatrix || IDENTITY_MATRIX;
	return uniforms;
}
function calculateViewportUniforms({ viewport, devicePixelRatio, coordinateSystem, coordinateOrigin }) {
	const { projectionCenter, viewProjectionMatrix, originCommon, cameraPosCommon, shaderCoordinateOrigin, geospatialOrigin } = calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin);
	const distanceScales = viewport.getDistanceScales();
	const viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];
	const focalDistance = transformMat4$2([], [
		0,
		0,
		-viewport.focalDistance,
		1
	], viewport.projectionMatrix)[3] || 1;
	const uniforms = {
		coordinateSystem,
		projectionMode: viewport.projectionMode,
		coordinateOrigin: shaderCoordinateOrigin,
		commonOrigin: originCommon.slice(0, 3),
		center: projectionCenter,
		pseudoMeters: Boolean(viewport._pseudoMeters),
		viewportSize,
		devicePixelRatio,
		focalDistance,
		commonUnitsPerMeter: distanceScales.unitsPerMeter,
		commonUnitsPerWorldUnit: distanceScales.unitsPerMeter,
		commonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,
		scale: viewport.scale,
		wrapLongitude: false,
		viewProjectionMatrix,
		modelMatrix: IDENTITY_MATRIX,
		cameraPosition: cameraPosCommon
	};
	if (geospatialOrigin) {
		const distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin);
		switch (coordinateSystem) {
			case COORDINATE_SYSTEM.METER_OFFSETS:
				uniforms.commonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;
				uniforms.commonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;
				break;
			case COORDINATE_SYSTEM.LNGLAT:
			case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
				if (!viewport._pseudoMeters) uniforms.commonUnitsPerMeter = distanceScalesAtOrigin.unitsPerMeter;
				uniforms.commonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;
				uniforms.commonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;
				break;
			case COORDINATE_SYSTEM.CARTESIAN:
				uniforms.commonUnitsPerWorldUnit = [
					1,
					1,
					distanceScalesAtOrigin.unitsPerMeter[2]
				];
				uniforms.commonUnitsPerWorldUnit2 = [
					0,
					0,
					distanceScalesAtOrigin.unitsPerMeter2[2]
				];
				break;
			default: break;
		}
	}
	return uniforms;
}

//#endregion
//#region node_modules/@deck.gl/core/dist/shaderlib/project/project.wgsl.js
var COORDINATE_SYSTEM_WGSL_CONSTANTS = Object.keys(COORDINATE_SYSTEM).map((key) => `const COORDINATE_SYSTEM_${key}: i32 = ${COORDINATE_SYSTEM[key]};`).join("");
var PROJECTION_MODE_WGSL_CONSTANTS = Object.keys(PROJECTION_MODE).map((key) => `const PROJECTION_MODE_${key}: i32 = ${PROJECTION_MODE[key]};`).join("");
var UNIT_WGSL_CONSTANTS = Object.keys(UNIT).map((key) => `const UNIT_${key.toUpperCase()}: i32 = ${UNIT[key]};`).join("");
const projectWGSLHeader = `\
${COORDINATE_SYSTEM_WGSL_CONSTANTS}
${PROJECTION_MODE_WGSL_CONSTANTS}
${UNIT_WGSL_CONSTANTS}

const TILE_SIZE: f32 = 512.0;
const PI: f32 = 3.1415926536;
const WORLD_SCALE: f32 = TILE_SIZE / (PI * 2.0);
const ZERO_64_LOW: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
const EARTH_RADIUS: f32 = 6370972.0; // meters
const GLOBE_RADIUS: f32 = 256.0;

// -----------------------------------------------------------------------------
// Uniform block (converted from GLSL uniform block)
// -----------------------------------------------------------------------------
struct ProjectUniforms {
  wrapLongitude: i32,
  coordinateSystem: i32,
  commonUnitsPerMeter: vec3<f32>,
  projectionMode: i32,
  scale: f32,
  commonUnitsPerWorldUnit: vec3<f32>,
  commonUnitsPerWorldUnit2: vec3<f32>,
  center: vec4<f32>,
  modelMatrix: mat4x4<f32>,
  viewProjectionMatrix: mat4x4<f32>,
  viewportSize: vec2<f32>,
  devicePixelRatio: f32,
  focalDistance: f32,
  cameraPosition: vec3<f32>,
  coordinateOrigin: vec3<f32>,
  commonOrigin: vec3<f32>,
  pseudoMeters: i32,
};

@group(0) @binding(0)
var<uniform> project: ProjectUniforms;

// -----------------------------------------------------------------------------
// Geometry data
// (In your GLSL code, "geometry" was assumed to be available globally. In WGSL,
// you might supply this via vertex attributes or a uniform. Here we define a
// uniform struct for demonstration.)
// -----------------------------------------------------------------------------

// Structure to carry additional geometry data used by deck.gl filters.
struct Geometry {
  worldPosition: vec3<f32>,
  worldPositionAlt: vec3<f32>,
  position: vec4<f32>,
  normal: vec3<f32>,
  uv: vec2<f32>,
  pickingColor: vec3<f32>,
};

// @group(0) @binding(1)
var<private> geometry: Geometry;
`;
const projectWGSL = `\
${projectWGSLHeader}

// -----------------------------------------------------------------------------
// Functions
// -----------------------------------------------------------------------------

// Returns an adjustment factor for commonUnitsPerMeter
fn _project_size_at_latitude(lat: f32) -> f32 {
  let y = clamp(lat, -89.9, 89.9);
  return 1.0 / cos(radians(y));
}

// Overloaded version: scales a value in meters at a given latitude.
fn _project_size_at_latitude_m(meters: f32, lat: f32) -> f32 {
  return meters * project.commonUnitsPerMeter.z * _project_size_at_latitude(lat);
}

// Computes a non-linear scale factor based on geometry.
// (Note: This function relies on "geometry" being provided.)
fn project_size() -> f32 {
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR &&
      project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
      project.pseudoMeters == 0) {
    if (geometry.position.w == 0.0) {
      return _project_size_at_latitude(geometry.worldPosition.y);
    }
    let y: f32 = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
    let y2 = y * y;
    let y4 = y2 * y2;
    let y6 = y4 * y2;
    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
  }
  return 1.0;
}

// Overloads to scale offsets (meters to world units)
fn project_size_float(meters: f32) -> f32 {
  return meters * project.commonUnitsPerMeter.z * project_size();
}

fn project_size_vec2(meters: vec2<f32>) -> vec2<f32> {
  return meters * project.commonUnitsPerMeter.xy * project_size();
}

fn project_size_vec3(meters: vec3<f32>) -> vec3<f32> {
  return meters * project.commonUnitsPerMeter * project_size();
}

fn project_size_vec4(meters: vec4<f32>) -> vec4<f32> {
  return vec4<f32>(meters.xyz * project.commonUnitsPerMeter, meters.w);
}

// Returns a rotation matrix aligning the zaxis with the given up vector.
fn project_get_orientation_matrix(up: vec3<f32>) -> mat3x3<f32> {
  let uz = normalize(up);
  let ux = select(
    vec3<f32>(1.0, 0.0, 0.0),
    normalize(vec3<f32>(uz.y, -uz.x, 0.0)),
    abs(uz.z) == 1.0
  );
  let uy = cross(uz, ux);
  return mat3x3<f32>(ux, uy, uz);
}

// Since WGSL does not support "out" parameters, we return a struct.
struct RotationResult {
  needsRotation: bool,
  transform: mat3x3<f32>,
};

fn project_needs_rotation(commonPosition: vec3<f32>) -> RotationResult {
  if (project.projectionMode == PROJECTION_MODE_GLOBE) {
    return RotationResult(true, project_get_orientation_matrix(commonPosition));
  } else {
    return RotationResult(false, mat3x3<f32>());  // identity alternative if needed
  };
}

// Projects a normal vector from the current coordinate system to world space.
fn project_normal(vector: vec3<f32>) -> vec3<f32> {
  let normal_modelspace = project.modelMatrix * vec4<f32>(vector, 0.0);
  var n = normalize(normal_modelspace.xyz * project.commonUnitsPerMeter);
  let rotResult = project_needs_rotation(geometry.position.xyz);
  if (rotResult.needsRotation) {
    n = rotResult.transform * n;
  }
  return n;
}

// Applies a scale offset based on y-offset (dy)
fn project_offset_(offset: vec4<f32>) -> vec4<f32> {
  let dy: f32 = offset.y;
  let commonUnitsPerWorldUnit = project.commonUnitsPerWorldUnit + project.commonUnitsPerWorldUnit2 * dy;
  return vec4<f32>(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}

// Projects lng/lat coordinates to a unit tile [0,1]
fn project_mercator_(lnglat: vec2<f32>) -> vec2<f32> {
  var x = lnglat.x;
  if (project.wrapLongitude != 0) {
    x = ((x + 180.0) % 360.0) - 180.0;
  }
  let y = clamp(lnglat.y, -89.9, 89.9);
  return vec2<f32>(
    radians(x) + PI,
    PI + log(tan(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

// Projects lng/lat/z coordinates for a globe projection.
fn project_globe_(lnglatz: vec3<f32>) -> vec3<f32> {
  let lambda = radians(lnglatz.x);
  let phi = radians(lnglatz.y);
  let cosPhi = cos(phi);
  let D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;
  return vec3<f32>(
    sin(lambda) * cosPhi,
    -cos(lambda) * cosPhi,
    sin(phi)
  ) * D;
}

// Projects positions (with an optional 64-bit low part) from the input
// coordinate system to the common space.
fn project_position_vec4_f64(position: vec4<f32>, position64Low: vec3<f32>) -> vec4<f32> {
  var position_world = project.modelMatrix * position;

  // Work around for a Mac+NVIDIA bug:
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4<f32>(
        project_mercator_(position_world.xy),
        _project_size_at_latitude_m(position_world.z, position_world.y),
        position_world.w
      );
    }
    if (project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
      position_world = vec4f(position_world.xyz + project.coordinateOrigin, position_world.w);
    }
  }
  if (project.projectionMode == PROJECTION_MODE_GLOBE) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4<f32>(
        project_globe_(position_world.xyz),
        position_world.w
      );
    }
  }
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      if (abs(position_world.y - project.coordinateOrigin.y) > 0.25) {
        return vec4<f32>(
          project_mercator_(position_world.xy) - project.commonOrigin.xy,
          project_size_float(position_world.z),
          position_world.w
        );
      }
    }
  }
  if (project.projectionMode == PROJECTION_MODE_IDENTITY ||
      (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
       (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
        project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
    position_world = vec4f(position_world.xyz - project.coordinateOrigin, position_world.w);
  }

  return project_offset_(position_world) +
         project_offset_(project.modelMatrix * vec4<f32>(position64Low, 0.0));
}

// Overloaded versions for different input types.
fn project_position_vec4_f32(position: vec4<f32>) -> vec4<f32> {
  return project_position_vec4_f64(position, ZERO_64_LOW);
}

fn project_position_vec3_f64(position: vec3<f32>, position64Low: vec3<f32>) -> vec3<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 1.0), position64Low);
  return projected_position.xyz;
}

fn project_position_vec3_f32(position: vec3<f32>) -> vec3<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 1.0), ZERO_64_LOW);
  return projected_position.xyz;
}

fn project_position_vec2_f32(position: vec2<f32>) -> vec2<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 0.0, 1.0), ZERO_64_LOW);
  return projected_position.xy;
}

// Transforms a common space position to clip space.
fn project_common_position_to_clipspace_with_projection(position: vec4<f32>, viewProjectionMatrix: mat4x4<f32>, center: vec4<f32>) -> vec4<f32> {
  return viewProjectionMatrix * position + center;
}

// Uses the project viewProjectionMatrix and center.
fn project_common_position_to_clipspace(position: vec4<f32>) -> vec4<f32> {
  return project_common_position_to_clipspace_with_projection(position, project.viewProjectionMatrix, project.center);
}

// Returns a clip space offset corresponding to a given number of screen pixels.
fn project_pixel_size_to_clipspace(pixels: vec2<f32>) -> vec2<f32> {
  let offset = pixels / project.viewportSize * project.devicePixelRatio * 2.0;
  return offset * project.focalDistance;
}

fn project_meter_size_to_pixel(meters: f32) -> f32 {
  return project_size_float(meters) * project.scale;
}

fn project_unit_size_to_pixel(size: f32, unit: i32) -> f32 {
  if (unit == UNIT_METERS) {
    return project_meter_size_to_pixel(size);
  } else if (unit == UNIT_COMMON) {
    return size * project.scale;
  }
  // UNIT_PIXELS: no scaling applied.
  return size;
}

fn project_pixel_size_float(pixels: f32) -> f32 {
  return pixels / project.scale;
}

fn project_pixel_size_vec2(pixels: vec2<f32>) -> vec2<f32> {
  return pixels / project.scale;
}
`;

//#endregion
//#region node_modules/@deck.gl/core/dist/shaderlib/project/project.glsl.js
var COORDINATE_SYSTEM_GLSL_CONSTANTS = Object.keys(COORDINATE_SYSTEM).map((key) => `const int COORDINATE_SYSTEM_${key} = ${COORDINATE_SYSTEM[key]};`).join("");
var PROJECTION_MODE_GLSL_CONSTANTS = Object.keys(PROJECTION_MODE).map((key) => `const int PROJECTION_MODE_${key} = ${PROJECTION_MODE[key]};`).join("");
var UNIT_GLSL_CONSTANTS = Object.keys(UNIT).map((key) => `const int UNIT_${key.toUpperCase()} = ${UNIT[key]};`).join("");
const projectGLSL = `\
${COORDINATE_SYSTEM_GLSL_CONSTANTS}
${PROJECTION_MODE_GLSL_CONSTANTS}
${UNIT_GLSL_CONSTANTS}
uniform projectUniforms {
bool wrapLongitude;
int coordinateSystem;
vec3 commonUnitsPerMeter;
int projectionMode;
float scale;
vec3 commonUnitsPerWorldUnit;
vec3 commonUnitsPerWorldUnit2;
vec4 center;
mat4 modelMatrix;
mat4 viewProjectionMatrix;
vec2 viewportSize;
float devicePixelRatio;
float focalDistance;
vec3 cameraPosition;
vec3 coordinateOrigin;
vec3 commonOrigin;
bool pseudoMeters;
} project;
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / (PI * 2.0);
const vec3 ZERO_64_LOW = vec3(0.0);
const float EARTH_RADIUS = 6370972.0;
const float GLOBE_RADIUS = 256.0;
float project_size_at_latitude(float lat) {
float y = clamp(lat, -89.9, 89.9);
return 1.0 / cos(radians(y));
}
float project_size() {
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR &&
project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
project.pseudoMeters == false) {
if (geometry.position.w == 0.0) {
return project_size_at_latitude(geometry.worldPosition.y);
}
float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
float y2 = y * y;
float y4 = y2 * y2;
float y6 = y4 * y2;
return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
}
return 1.0;
}
float project_size_at_latitude(float meters, float lat) {
return meters * project.commonUnitsPerMeter.z * project_size_at_latitude(lat);
}
float project_size(float meters) {
return meters * project.commonUnitsPerMeter.z * project_size();
}
vec2 project_size(vec2 meters) {
return meters * project.commonUnitsPerMeter.xy * project_size();
}
vec3 project_size(vec3 meters) {
return meters * project.commonUnitsPerMeter * project_size();
}
vec4 project_size(vec4 meters) {
return vec4(meters.xyz * project.commonUnitsPerMeter, meters.w);
}
mat3 project_get_orientation_matrix(vec3 up) {
vec3 uz = normalize(up);
vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));
vec3 uy = cross(uz, ux);
return mat3(ux, uy, uz);
}
bool project_needs_rotation(vec3 commonPosition, out mat3 transform) {
if (project.projectionMode == PROJECTION_MODE_GLOBE) {
transform = project_get_orientation_matrix(commonPosition);
return true;
}
return false;
}
vec3 project_normal(vec3 vector) {
vec4 normal_modelspace = project.modelMatrix * vec4(vector, 0.0);
vec3 n = normalize(normal_modelspace.xyz * project.commonUnitsPerMeter);
mat3 rotation;
if (project_needs_rotation(geometry.position.xyz, rotation)) {
n = rotation * n;
}
return n;
}
vec4 project_offset_(vec4 offset) {
float dy = offset.y;
vec3 commonUnitsPerWorldUnit = project.commonUnitsPerWorldUnit + project.commonUnitsPerWorldUnit2 * dy;
return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}
vec2 project_mercator_(vec2 lnglat) {
float x = lnglat.x;
if (project.wrapLongitude) {
x = mod(x + 180., 360.0) - 180.;
}
float y = clamp(lnglat.y, -89.9, 89.9);
return vec2(
radians(x) + PI,
PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))
) * WORLD_SCALE;
}
vec3 project_globe_(vec3 lnglatz) {
float lambda = radians(lnglatz.x);
float phi = radians(lnglatz.y);
float cosPhi = cos(phi);
float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;
return vec3(
sin(lambda) * cosPhi,
-cos(lambda) * cosPhi,
sin(phi)
) * D;
}
vec4 project_position(vec4 position, vec3 position64Low) {
vec4 position_world = project.modelMatrix * position;
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_mercator_(position_world.xy),
project_size_at_latitude(position_world.z, position_world.y),
position_world.w
);
}
if (project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
position_world.xyz += project.coordinateOrigin;
}
}
if (project.projectionMode == PROJECTION_MODE_GLOBE) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_globe_(position_world.xyz),
position_world.w
);
}
}
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
if (abs(position_world.y - project.coordinateOrigin.y) > 0.25) {
return vec4(
project_mercator_(position_world.xy) - project.commonOrigin.xy,
project_size(position_world.z),
position_world.w
);
}
}
}
if (project.projectionMode == PROJECTION_MODE_IDENTITY ||
(project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
(project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
position_world.xyz -= project.coordinateOrigin;
}
return project_offset_(position_world) + project_offset_(project.modelMatrix * vec4(position64Low, 0.0));
}
vec4 project_position(vec4 position) {
return project_position(position, ZERO_64_LOW);
}
vec3 project_position(vec3 position, vec3 position64Low) {
vec4 projected_position = project_position(vec4(position, 1.0), position64Low);
return projected_position.xyz;
}
vec3 project_position(vec3 position) {
vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);
return projected_position.xyz;
}
vec2 project_position(vec2 position) {
vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);
return projected_position.xy;
}
vec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {
return viewProjectionMatrix * position + center;
}
vec4 project_common_position_to_clipspace(vec4 position) {
return project_common_position_to_clipspace(position, project.viewProjectionMatrix, project.center);
}
vec2 project_pixel_size_to_clipspace(vec2 pixels) {
vec2 offset = pixels / project.viewportSize * project.devicePixelRatio * 2.0;
return offset * project.focalDistance;
}
float project_size_to_pixel(float meters) {
return project_size(meters) * project.scale;
}
float project_size_to_pixel(float size, int unit) {
if (unit == UNIT_METERS) return project_size_to_pixel(size);
if (unit == UNIT_COMMON) return size * project.scale;
return size;
}
float project_pixel_size(float pixels) {
return pixels / project.scale;
}
vec2 project_pixel_size(vec2 pixels) {
return pixels / project.scale;
}
`;

//#endregion
//#region node_modules/@deck.gl/core/dist/shaderlib/project/project.js
var INITIAL_MODULE_OPTIONS = {};
function getUniforms(opts = INITIAL_MODULE_OPTIONS) {
	if ("viewport" in opts) return getUniformsFromViewport(opts);
	return {};
}
var project_default = {
	name: "project",
	dependencies: [fp32, geometry_default],
	source: projectWGSL,
	vs: projectGLSL,
	getUniforms,
	uniformTypes: {
		wrapLongitude: "f32",
		coordinateSystem: "i32",
		commonUnitsPerMeter: "vec3<f32>",
		projectionMode: "i32",
		scale: "f32",
		commonUnitsPerWorldUnit: "vec3<f32>",
		commonUnitsPerWorldUnit2: "vec3<f32>",
		center: "vec4<f32>",
		modelMatrix: "mat4x4<f32>",
		viewProjectionMatrix: "mat4x4<f32>",
		viewportSize: "vec2<f32>",
		devicePixelRatio: "f32",
		focalDistance: "f32",
		cameraPosition: "vec3<f32>",
		coordinateOrigin: "vec3<f32>",
		commonOrigin: "vec3<f32>",
		pseudoMeters: "f32"
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/shaderlib/project32/project32.js
var source = `\
// Define a structure to hold both the clip-space position and the common position.
struct ProjectResult {
  clipPosition: vec4<f32>,
  commonPosition: vec4<f32>,
};

// This function mimics the GLSL version with the 'out' parameter by returning both values.
fn project_position_to_clipspace_and_commonspace(
    position: vec3<f32>,
    position64Low: vec3<f32>,
    offset: vec3<f32>
) -> ProjectResult {
  // Compute the projected position.
  let projectedPosition: vec3<f32> = project_position_vec3_f64(position, position64Low);

  // Start with the provided offset.
  var finalOffset: vec3<f32> = offset;

  // Get whether a rotation is needed and the rotation matrix.
  let rotationResult = project_needs_rotation(projectedPosition);

  // If rotation is needed, update the offset.
  if (rotationResult.needsRotation) {
    finalOffset = rotationResult.transform * offset;
  }

  // Compute the common position.
  let commonPosition: vec4<f32> = vec4<f32>(projectedPosition + finalOffset, 1.0);

  // Convert to clip-space.
  let clipPosition: vec4<f32> = project_common_position_to_clipspace(commonPosition);

  return ProjectResult(clipPosition, commonPosition);
}

// A convenience overload that returns only the clip-space position.
fn project_position_to_clipspace(
    position: vec3<f32>,
    position64Low: vec3<f32>,
    offset: vec3<f32>
) -> vec4<f32> {
  return project_position_to_clipspace_and_commonspace(position, position64Low, offset).clipPosition;
}
`;
var vs$3 = `\
vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition
) {
  vec3 projectedPosition = project_position(position, position64Low);
  mat3 rotation;
  if (project_needs_rotation(projectedPosition, rotation)) {
    // offset is specified as ENU
    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe
    offset = rotation * offset;
  }
  commonPosition = vec4(projectedPosition + offset, 1.0);
  return project_common_position_to_clipspace(commonPosition);
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset
) {
  vec4 commonPosition;
  return project_position_to_clipspace(position, position64Low, offset, commonPosition);
}
`;
var project32_default = {
	name: "project32",
	dependencies: [project_default],
	source,
	vs: vs$3
};

//#endregion
//#region node_modules/@math.gl/web-mercator/dist/math-utils.js
function createMat4$1() {
	return [
		1,
		0,
		0,
		0,
		0,
		1,
		0,
		0,
		0,
		0,
		1,
		0,
		0,
		0,
		0,
		1
	];
}
function transformVector$1(matrix, vector) {
	const result = transformMat4$2([], vector, matrix);
	scale$1(result, result, 1 / result[3]);
	return result;
}
function mod$1(value, divisor) {
	const modulus = value % divisor;
	return modulus < 0 ? divisor + modulus : modulus;
}
function lerp$1(start, end, step) {
	return step * end + (1 - step) * start;
}
function clamp$1(x$1, min, max) {
	return x$1 < min ? min : x$1 > max ? max : x$1;
}
function ieLog2(x$1) {
	return Math.log(x$1) * Math.LOG2E;
}
const log2 = Math.log2 || ieLog2;

//#endregion
//#region node_modules/@math.gl/web-mercator/dist/assert.js
function assert$1(condition, message) {
	if (!condition) throw new Error(message || "@math.gl/web-mercator: assertion failed.");
}

//#endregion
//#region node_modules/@math.gl/web-mercator/dist/web-mercator-utils.js
var PI = Math.PI;
var PI_4 = PI / 4;
var DEGREES_TO_RADIANS$5 = PI / 180;
var RADIANS_TO_DEGREES$1 = 180 / PI;
var TILE_SIZE$1 = 512;
var EARTH_CIRCUMFERENCE = 4003e4;
const MAX_LATITUDE = 85.051129;
const DEFAULT_ALTITUDE = 1.5;
/** Logarithimic zoom to linear scale **/
function zoomToScale(zoom) {
	return Math.pow(2, zoom);
}
/** Linear scale to logarithimic zoom **/
function scaleToZoom(scale$3) {
	return log2(scale$3);
}
/**
* Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
* Performs the nonlinear part of the web mercator projection.
* Remaining projection is done with 4x4 matrices which also handles
* perspective.
*
* @param lngLat - [lng, lat] coordinates
*   Specifies a point on the sphere to project onto the map.
* @return [x,y] coordinates.
*/
function lngLatToWorld(lngLat) {
	const [lng, lat] = lngLat;
	assert$1(Number.isFinite(lng));
	assert$1(Number.isFinite(lat) && lat >= -90 && lat <= 90, "invalid latitude");
	const lambda2 = lng * DEGREES_TO_RADIANS$5;
	const phi2 = lat * DEGREES_TO_RADIANS$5;
	return [TILE_SIZE$1 * (lambda2 + PI) / (2 * PI), TILE_SIZE$1 * (PI + Math.log(Math.tan(PI_4 + phi2 * .5))) / (2 * PI)];
}
/**
* Unproject world point [x,y] on map onto {lat, lon} on sphere
*
* @param xy - array with [x,y] members
*  representing point on projected map plane
* @return - array with [x,y] of point on sphere.
*   Has toArray method if you need a GeoJSON Array.
*   Per cartographic tradition, lat and lon are specified as degrees.
*/
function worldToLngLat(xy) {
	const [x$1, y$1] = xy;
	const lambda2 = x$1 / TILE_SIZE$1 * (2 * PI) - PI;
	const phi2 = 2 * (Math.atan(Math.exp(y$1 / TILE_SIZE$1 * (2 * PI) - PI)) - PI_4);
	return [lambda2 * RADIANS_TO_DEGREES$1, phi2 * RADIANS_TO_DEGREES$1];
}
/**
* Returns the zoom level that gives a 1 meter pixel at a certain latitude
* 1 = C*cos(y)/2^z/TILE_SIZE = C*cos(y)/2^(z+9)
*/
function getMeterZoom(options) {
	const { latitude } = options;
	assert$1(Number.isFinite(latitude));
	return scaleToZoom(EARTH_CIRCUMFERENCE * Math.cos(latitude * DEGREES_TO_RADIANS$5)) - 9;
}
/**
* Calculate the conversion from meter to common units at a given latitude
* This is a cheaper version of `getDistanceScales`
* @param latitude center latitude in degrees
* @returns common units per meter
*/
function unitsPerMeter(latitude) {
	const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS$5);
	return TILE_SIZE$1 / EARTH_CIRCUMFERENCE / latCosine;
}
/**
* Calculate distance scales in meters around current lat/lon, both for
* degrees and pixels.
* In mercator projection mode, the distance scales vary significantly
* with latitude.
*/
function getDistanceScales$1(options) {
	const { latitude, longitude, highPrecision = false } = options;
	assert$1(Number.isFinite(latitude) && Number.isFinite(longitude));
	const worldSize = TILE_SIZE$1;
	const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS$5);
	/**
	* Number of pixels occupied by one degree longitude around current lat/lon:
	unitsPerDegreeX = d(lngLatToWorld([lng, lat])[0])/d(lng)
	= scale * TILE_SIZE * DEGREES_TO_RADIANS / (2 * PI)
	unitsPerDegreeY = d(lngLatToWorld([lng, lat])[1])/d(lat)
	= -scale * TILE_SIZE * DEGREES_TO_RADIANS / cos(lat * DEGREES_TO_RADIANS)  / (2 * PI)
	*/
	const unitsPerDegreeX = worldSize / 360;
	const unitsPerDegreeY = unitsPerDegreeX / latCosine;
	/**
	* Number of pixels occupied by one meter around current lat/lon:
	*/
	const altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;
	/**
	* LngLat: longitude -> east and latitude -> north (bottom left)
	* UTM meter offset: x -> east and y -> north (bottom left)
	* World space: x -> east and y -> south (top left)
	*
	* Y needs to be flipped when converting delta degree/meter to delta pixels
	*/
	const result = {
		unitsPerMeter: [
			altUnitsPerMeter,
			altUnitsPerMeter,
			altUnitsPerMeter
		],
		metersPerUnit: [
			1 / altUnitsPerMeter,
			1 / altUnitsPerMeter,
			1 / altUnitsPerMeter
		],
		unitsPerDegree: [
			unitsPerDegreeX,
			unitsPerDegreeY,
			altUnitsPerMeter
		],
		degreesPerUnit: [
			1 / unitsPerDegreeX,
			1 / unitsPerDegreeY,
			1 / altUnitsPerMeter
		]
	};
	/**
	* Taylor series 2nd order for 1/latCosine
	f'(a) * (x - a)
	= d(1/cos(lat * DEGREES_TO_RADIANS))/d(lat) * dLat
	= DEGREES_TO_RADIANS * tan(lat * DEGREES_TO_RADIANS) / cos(lat * DEGREES_TO_RADIANS) * dLat
	*/
	if (highPrecision) {
		const latCosine2 = DEGREES_TO_RADIANS$5 * Math.tan(latitude * DEGREES_TO_RADIANS$5) / latCosine;
		const unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;
		const altUnitsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
		const altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;
		result.unitsPerDegree2 = [
			0,
			unitsPerDegreeY2,
			altUnitsPerDegree2
		];
		result.unitsPerMeter2 = [
			altUnitsPerMeter2,
			0,
			altUnitsPerMeter2
		];
	}
	return result;
}
/**
* Offset a lng/lat position by meterOffset (northing, easting)
*/
function addMetersToLngLat(lngLatZ, xyz) {
	const [longitude, latitude, z0] = lngLatZ;
	const [x$1, y$1, z$1] = xyz;
	const { unitsPerMeter: unitsPerMeter$1, unitsPerMeter2 } = getDistanceScales$1({
		longitude,
		latitude,
		highPrecision: true
	});
	const worldspace = lngLatToWorld(lngLatZ);
	worldspace[0] += x$1 * (unitsPerMeter$1[0] + unitsPerMeter2[0] * y$1);
	worldspace[1] += y$1 * (unitsPerMeter$1[1] + unitsPerMeter2[1] * y$1);
	const newLngLat = worldToLngLat(worldspace);
	const newZ = (z0 || 0) + (z$1 || 0);
	return Number.isFinite(z0) || Number.isFinite(z$1) ? [
		newLngLat[0],
		newLngLat[1],
		newZ
	] : newLngLat;
}
/**
*
* view and projection matrix creation is intentionally kept compatible with
* mapbox-gl's implementation to ensure that seamless interoperation
* with mapbox and react-map-gl. See: https://github.com/mapbox/mapbox-gl-js
*/
function getViewMatrix$1(options) {
	const { height, pitch, bearing, altitude, scale: scale$3, center } = options;
	const vm = createMat4$1();
	translate(vm, vm, [
		0,
		0,
		-altitude
	]);
	rotateX(vm, vm, -pitch * DEGREES_TO_RADIANS$5);
	rotateZ(vm, vm, bearing * DEGREES_TO_RADIANS$5);
	const relativeScale = scale$3 / height;
	scale(vm, vm, [
		relativeScale,
		relativeScale,
		relativeScale
	]);
	if (center) translate(vm, vm, negate([], center));
	return vm;
}
/**
* Calculates mapbox compatible projection matrix from parameters
*
* @param options.width Width of "viewport" or window
* @param options.height Height of "viewport" or window
* @param options.scale Scale at the current zoom
* @param options.center Offset of the target, vec3 in world space
* @param options.offset Offset of the focal point, vec2 in screen space
* @param options.pitch Camera angle in degrees (0 is straight down)
* @param options.fovy field of view in degrees
* @param options.altitude if provided, field of view is calculated using `altitudeToFovy()`
* @param options.nearZMultiplier control z buffer
* @param options.farZMultiplier control z buffer
* @returns project parameters object
*/
function getProjectionParameters(options) {
	const { width, height, altitude, pitch = 0, offset, center, scale: scale$3, nearZMultiplier = 1, farZMultiplier = 1 } = options;
	let { fovy = altitudeToFovy(DEFAULT_ALTITUDE) } = options;
	if (altitude !== void 0) fovy = altitudeToFovy(altitude);
	const fovRadians = fovy * DEGREES_TO_RADIANS$5;
	const pitchRadians = pitch * DEGREES_TO_RADIANS$5;
	const focalDistance = fovyToAltitude(fovy);
	let cameraToSeaLevelDistance = focalDistance;
	if (center) cameraToSeaLevelDistance += center[2] * scale$3 / Math.cos(pitchRadians) / height;
	const fovAboveCenter = fovRadians * (.5 + (offset ? offset[1] : 0) / height);
	const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * cameraToSeaLevelDistance / Math.sin(clamp$1(Math.PI / 2 - pitchRadians - fovAboveCenter, .01, Math.PI - .01));
	const furthestDistance = Math.sin(pitchRadians) * topHalfSurfaceDistance + cameraToSeaLevelDistance;
	const horizonDistance = cameraToSeaLevelDistance * 10;
	const farZ = Math.min(furthestDistance * farZMultiplier, horizonDistance);
	return {
		fov: fovRadians,
		aspect: width / height,
		focalDistance,
		near: nearZMultiplier,
		far: farZ
	};
}
/**
*
* Convert an altitude to field of view such that the
* focal distance is equal to the altitude
*
* @param altitude - altitude of camera in screen units
* @return fovy field of view in degrees
*/
function altitudeToFovy(altitude) {
	return 2 * Math.atan(.5 / altitude) * RADIANS_TO_DEGREES$1;
}
/**
*
* Convert an field of view such that the
* focal distance is equal to the altitude
*
* @param fovy - field of view in degrees
* @return altitude altitude of camera in screen units
*/
function fovyToAltitude(fovy) {
	return .5 / Math.tan(.5 * fovy * DEGREES_TO_RADIANS$5);
}
function worldToPixels(xyz, pixelProjectionMatrix) {
	const [x$1, y$1, z$1 = 0] = xyz;
	assert$1(Number.isFinite(x$1) && Number.isFinite(y$1) && Number.isFinite(z$1));
	return transformVector$1(pixelProjectionMatrix, [
		x$1,
		y$1,
		z$1,
		1
	]);
}
/**
* Unproject pixels on screen to flat coordinates.
*
* @param xyz - pixel coordinate on screen.
* @param pixelUnprojectionMatrix - unprojection matrix 4x4
* @param targetZ - if pixel coordinate does not have a 3rd component (depth),
*    targetZ is used as the elevation plane to unproject onto
* @return [x, y, Z] flat coordinates on 512*512 Mercator Zoom 0 tile.
*/
function pixelsToWorld(xyz, pixelUnprojectionMatrix, targetZ = 0) {
	const [x$1, y$1, z$1] = xyz;
	assert$1(Number.isFinite(x$1) && Number.isFinite(y$1), "invalid pixel coordinate");
	if (Number.isFinite(z$1)) return transformVector$1(pixelUnprojectionMatrix, [
		x$1,
		y$1,
		z$1,
		1
	]);
	const coord0 = transformVector$1(pixelUnprojectionMatrix, [
		x$1,
		y$1,
		0,
		1
	]);
	const coord1 = transformVector$1(pixelUnprojectionMatrix, [
		x$1,
		y$1,
		1,
		1
	]);
	const z0 = coord0[2];
	const z1 = coord1[2];
	const t$1 = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
	return lerp$3([], coord0, coord1, t$1);
}

//#endregion
//#region node_modules/@math.gl/web-mercator/dist/fit-bounds.js
/**
* Returns map settings {latitude, longitude, zoom}
* that will contain the provided corners within the provided width.
*
* > _Note: Only supports non-perspective mode._
*
* @param options fit bounds parameters
* @returns - latitude, longitude and zoom
*/
function fitBounds(options) {
	const { width, height, bounds, minExtent = 0, maxZoom = 24, offset = [0, 0] } = options;
	const [[west, south], [east, north]] = bounds;
	const padding = getPaddingObject(options.padding);
	const nw = lngLatToWorld([west, clamp$1(north, -MAX_LATITUDE, MAX_LATITUDE)]);
	const se$1 = lngLatToWorld([east, clamp$1(south, -MAX_LATITUDE, MAX_LATITUDE)]);
	const size = [Math.max(Math.abs(se$1[0] - nw[0]), minExtent), Math.max(Math.abs(se$1[1] - nw[1]), minExtent)];
	const targetSize = [width - padding.left - padding.right - Math.abs(offset[0]) * 2, height - padding.top - padding.bottom - Math.abs(offset[1]) * 2];
	assert$1(targetSize[0] > 0 && targetSize[1] > 0);
	const scaleX = targetSize[0] / size[0];
	const scaleY = targetSize[1] / size[1];
	const offsetX = (padding.right - padding.left) / 2 / scaleX;
	const offsetY = (padding.top - padding.bottom) / 2 / scaleY;
	const centerLngLat = worldToLngLat([(se$1[0] + nw[0]) / 2 + offsetX, (se$1[1] + nw[1]) / 2 + offsetY]);
	const zoom = Math.min(maxZoom, log2(Math.abs(Math.min(scaleX, scaleY))));
	assert$1(Number.isFinite(zoom));
	return {
		longitude: centerLngLat[0],
		latitude: centerLngLat[1],
		zoom
	};
}
function getPaddingObject(padding = 0) {
	if (typeof padding === "number") return {
		top: padding,
		bottom: padding,
		left: padding,
		right: padding
	};
	assert$1(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));
	return padding;
}

//#endregion
//#region node_modules/@math.gl/web-mercator/dist/get-bounds.js
var DEGREES_TO_RADIANS$4 = Math.PI / 180;
function getBounds(viewport, z$1 = 0) {
	const { width, height, unproject } = viewport;
	const unprojectOps = { targetZ: z$1 };
	const bottomLeft = unproject([0, height], unprojectOps);
	const bottomRight = unproject([width, height], unprojectOps);
	let topLeft;
	let topRight;
	if ((viewport.fovy ? .5 * viewport.fovy * DEGREES_TO_RADIANS$4 : Math.atan(.5 / viewport.altitude)) > (90 - viewport.pitch) * DEGREES_TO_RADIANS$4 - .01) {
		topLeft = unprojectOnFarPlane(viewport, 0, z$1);
		topRight = unprojectOnFarPlane(viewport, width, z$1);
	} else {
		topLeft = unproject([0, 0], unprojectOps);
		topRight = unproject([width, 0], unprojectOps);
	}
	return [
		bottomLeft,
		bottomRight,
		topRight,
		topLeft
	];
}
function unprojectOnFarPlane(viewport, x$1, targetZ) {
	const { pixelUnprojectionMatrix } = viewport;
	const coord0 = transformVector$1(pixelUnprojectionMatrix, [
		x$1,
		0,
		1,
		1
	]);
	const coord1 = transformVector$1(pixelUnprojectionMatrix, [
		x$1,
		viewport.height,
		1,
		1
	]);
	const t$1 = (targetZ * viewport.distanceScales.unitsPerMeter[2] - coord0[2]) / (coord1[2] - coord0[2]);
	const result = worldToLngLat(lerp$3([], coord0, coord1, t$1));
	result.push(targetZ);
	return result;
}

//#endregion
//#region node_modules/@math.gl/web-mercator/dist/normalize-viewport-props.js
var TILE_SIZE = 512;
/**
* Apply mathematical constraints to viewport props
* @param props
*/
function normalizeViewportProps(props) {
	const { width, height, pitch = 0 } = props;
	let { longitude, latitude, zoom, bearing = 0 } = props;
	if (longitude < -180 || longitude > 180) longitude = mod$1(longitude + 180, 360) - 180;
	if (bearing < -180 || bearing > 180) bearing = mod$1(bearing + 180, 360) - 180;
	const minZoom = log2(height / TILE_SIZE);
	if (zoom <= minZoom) {
		zoom = minZoom;
		latitude = 0;
	} else {
		const halfHeightPixels = height / 2 / Math.pow(2, zoom);
		const minLatitude = worldToLngLat([0, halfHeightPixels])[1];
		if (latitude < minLatitude) latitude = minLatitude;
		else {
			const maxLatitude = worldToLngLat([0, TILE_SIZE - halfHeightPixels])[1];
			if (latitude > maxLatitude) latitude = maxLatitude;
		}
	}
	return {
		width,
		height,
		longitude,
		latitude,
		zoom,
		pitch,
		bearing
	};
}

//#endregion
//#region node_modules/@math.gl/web-mercator/dist/fly-to-viewport.js
var EPSILON$1 = .01;
var VIEWPORT_TRANSITION_PROPS = [
	"longitude",
	"latitude",
	"zoom"
];
var DEFAULT_OPTS$1 = {
	curve: 1.414,
	speed: 1.2
};
/**
* mapbox-gl-js flyTo : https://www.mapbox.com/mapbox-gl-js/api/#map#flyto.
* It implements Smooth and efficient zooming and panning. algorithm by
* "Jarke J. van Wijk and Wim A.A. Nuij"
*/
function flyToViewport(startProps, endProps, t$1, options) {
	const { startZoom, startCenterXY, uDelta, w0, u1, S: S$1, rho, rho2, r0 } = getFlyToTransitionParams(startProps, endProps, options);
	if (u1 < EPSILON$1) {
		const viewport = {};
		for (const key of VIEWPORT_TRANSITION_PROPS) {
			const startValue = startProps[key];
			const endValue = endProps[key];
			viewport[key] = lerp$1(startValue, endValue, t$1);
		}
		return viewport;
	}
	const s$1 = t$1 * S$1;
	const w$1 = Math.cosh(r0) / Math.cosh(r0 + rho * s$1);
	const u$1 = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s$1) - Math.sinh(r0)) / rho2) / u1;
	const newZoom = startZoom + scaleToZoom(1 / w$1);
	const newCenterWorld = scale$2([], uDelta, u$1);
	add$1(newCenterWorld, newCenterWorld, startCenterXY);
	const newCenter = worldToLngLat(newCenterWorld);
	return {
		longitude: newCenter[0],
		latitude: newCenter[1],
		zoom: newZoom
	};
}
function getFlyToDuration(startProps, endProps, options) {
	const opts = {
		...DEFAULT_OPTS$1,
		...options
	};
	const { screenSpeed, speed, maxDuration } = opts;
	const { S: S$1, rho } = getFlyToTransitionParams(startProps, endProps, opts);
	const length$2 = 1e3 * S$1;
	let duration;
	if (Number.isFinite(screenSpeed)) duration = length$2 / (screenSpeed / rho);
	else duration = length$2 / speed;
	return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;
}
function getFlyToTransitionParams(startProps, endProps, opts) {
	opts = Object.assign({}, DEFAULT_OPTS$1, opts);
	const rho = opts.curve;
	const startZoom = startProps.zoom;
	const startCenter = [startProps.longitude, startProps.latitude];
	const startScale = zoomToScale(startZoom);
	const endZoom = endProps.zoom;
	const endCenter = [endProps.longitude, endProps.latitude];
	const scale$3 = zoomToScale(endZoom - startZoom);
	const startCenterXY = lngLatToWorld(startCenter);
	const endCenterXY = lngLatToWorld(endCenter);
	const uDelta = sub$1([], endCenterXY, startCenterXY);
	const w0 = Math.max(startProps.width, startProps.height);
	const w1 = w0 / scale$3;
	const u1 = length$1(uDelta) * startScale;
	const _u1 = Math.max(u1, EPSILON$1);
	const rho2 = rho * rho;
	const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);
	const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);
	const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);
	const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
	return {
		startZoom,
		startCenterXY,
		uDelta,
		w0,
		u1,
		S: (r1 - r0) / rho,
		rho,
		rho2,
		r0,
		r1
	};
}

//#endregion
//#region node_modules/@deck.gl/core/dist/shaderlib/shadow/shadow.js
var uniformBlock$1 = `
uniform shadowUniforms {
  bool drawShadowMap;
  bool useShadowMap;
  vec4 color;
  highp int lightId;
  float lightCount;
  mat4 viewProjectionMatrix0;
  mat4 viewProjectionMatrix1;
  vec4 projectCenter0;
  vec4 projectCenter1;
} shadow;
`;
var vs$2 = `
${uniformBlock$1}

const int max_lights = 2;

out vec3 shadow_vPosition[max_lights];

vec4 shadow_setVertexPosition(vec4 position_commonspace) {
  mat4 viewProjectionMatrices[max_lights];
  viewProjectionMatrices[0] = shadow.viewProjectionMatrix0;
  viewProjectionMatrices[1] = shadow.viewProjectionMatrix1;
  vec4 projectCenters[max_lights];
  projectCenters[0] = shadow.projectCenter0;
  projectCenters[1] = shadow.projectCenter1;

  if (shadow.drawShadowMap) {
    return project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[shadow.lightId], projectCenters[shadow.lightId]);
  }
  if (shadow.useShadowMap) {
    for (int i = 0; i < max_lights; i++) {
      if(i < int(shadow.lightCount)) {
        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[i], projectCenters[i]);
        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;
      }
    }
  }
  return gl_Position;
}

`;
var fs$1 = `
${uniformBlock$1}

const int max_lights = 2;
uniform sampler2D shadow_uShadowMap0;
uniform sampler2D shadow_uShadowMap1;

in vec3 shadow_vPosition[max_lights];

const vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);
const vec4 bitUnpackShift = 1.0 / bitPackShift;
const vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);

float shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {
  vec4 rgbaDepth = texture(shadowMap, position.xy);

  float z = dot(rgbaDepth, bitUnpackShift);
  return smoothstep(0.001, 0.01, position.z - z);
}

vec4 shadow_filterShadowColor(vec4 color) {
  if (shadow.drawShadowMap) {
    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);
    rgbaDepth -= rgbaDepth.gbaa * bitMask;
    return rgbaDepth;
  }
  if (shadow.useShadowMap) {
    float shadowAlpha = 0.0;
    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);
    if(shadow.lightCount > 1.0) {
      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);
    }
    shadowAlpha *= shadow.color.a / shadow.lightCount;
    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);

    return vec4(
      mix(color.rgb, shadow.color.rgb, shadowAlpha / blendedAlpha),
      blendedAlpha
    );
  }
  return color;
}

`;
var getMemoizedViewportCenterPosition = memoize(getViewportCenterPosition);
var getMemoizedViewProjectionMatrices = memoize(getViewProjectionMatrices);
var DEFAULT_SHADOW_COLOR$1 = [
	0,
	0,
	0,
	1
];
var VECTOR_TO_POINT_MATRIX = [
	1,
	0,
	0,
	0,
	0,
	1,
	0,
	0,
	0,
	0,
	1,
	0,
	0,
	0,
	0,
	0
];
function screenToCommonSpace(xyz, pixelUnprojectionMatrix) {
	const [x$1, y$1, z$1] = xyz;
	const coord = pixelsToWorld([
		x$1,
		y$1,
		z$1
	], pixelUnprojectionMatrix);
	if (Number.isFinite(z$1)) return coord;
	return [
		coord[0],
		coord[1],
		0
	];
}
function getViewportCenterPosition({ viewport, center }) {
	return new Matrix4(viewport.viewProjectionMatrix).invert().transform(center);
}
function getViewProjectionMatrices({ viewport, shadowMatrices }) {
	const projectionMatrices = [];
	const pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;
	const farZ = viewport.isGeospatial ? void 0 : 1;
	const corners = [
		[
			0,
			0,
			farZ
		],
		[
			viewport.width,
			0,
			farZ
		],
		[
			0,
			viewport.height,
			farZ
		],
		[
			viewport.width,
			viewport.height,
			farZ
		],
		[
			0,
			0,
			-1
		],
		[
			viewport.width,
			0,
			-1
		],
		[
			0,
			viewport.height,
			-1
		],
		[
			viewport.width,
			viewport.height,
			-1
		]
	].map((pixel) => screenToCommonSpace(pixel, pixelUnprojectionMatrix));
	for (const shadowMatrix of shadowMatrices) {
		const viewMatrix$1 = shadowMatrix.clone().translate(new Vector3(viewport.center).negate());
		const positions = corners.map((corner) => viewMatrix$1.transform(corner));
		const projectionMatrix = new Matrix4().ortho({
			left: Math.min(...positions.map((position) => position[0])),
			right: Math.max(...positions.map((position) => position[0])),
			bottom: Math.min(...positions.map((position) => position[1])),
			top: Math.max(...positions.map((position) => position[1])),
			near: Math.min(...positions.map((position) => -position[2])),
			far: Math.max(...positions.map((position) => -position[2]))
		});
		projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));
	}
	return projectionMatrices;
}
function createShadowUniforms(opts) {
	const { shadowEnabled = true, project: projectProps } = opts;
	if (!shadowEnabled || !projectProps || !opts.shadowMatrices || !opts.shadowMatrices.length) return {
		drawShadowMap: false,
		useShadowMap: false,
		shadow_uShadowMap0: opts.dummyShadowMap,
		shadow_uShadowMap1: opts.dummyShadowMap
	};
	const projectUniforms = project_default.getUniforms(projectProps);
	const center = getMemoizedViewportCenterPosition({
		viewport: projectProps.viewport,
		center: projectUniforms.center
	});
	const projectCenters = [];
	const viewProjectionMatrices = getMemoizedViewProjectionMatrices({
		shadowMatrices: opts.shadowMatrices,
		viewport: projectProps.viewport
	}).slice();
	for (let i$1 = 0; i$1 < opts.shadowMatrices.length; i$1++) {
		const viewProjectionMatrix = viewProjectionMatrices[i$1];
		const viewProjectionMatrixCentered = viewProjectionMatrix.clone().translate(new Vector3(projectProps.viewport.center).negate());
		if (projectUniforms.coordinateSystem === COORDINATE_SYSTEM.LNGLAT && projectUniforms.projectionMode === PROJECTION_MODE.WEB_MERCATOR) {
			viewProjectionMatrices[i$1] = viewProjectionMatrixCentered;
			projectCenters[i$1] = center;
		} else {
			viewProjectionMatrices[i$1] = viewProjectionMatrix.clone().multiplyRight(VECTOR_TO_POINT_MATRIX);
			projectCenters[i$1] = viewProjectionMatrixCentered.transform(center);
		}
	}
	const uniforms = {
		drawShadowMap: Boolean(opts.drawToShadowMap),
		useShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,
		color: opts.shadowColor || DEFAULT_SHADOW_COLOR$1,
		lightId: opts.shadowLightId || 0,
		lightCount: opts.shadowMatrices.length,
		shadow_uShadowMap0: opts.dummyShadowMap,
		shadow_uShadowMap1: opts.dummyShadowMap
	};
	for (let i$1 = 0; i$1 < viewProjectionMatrices.length; i$1++) {
		uniforms[`viewProjectionMatrix${i$1}`] = viewProjectionMatrices[i$1];
		uniforms[`projectCenter${i$1}`] = projectCenters[i$1];
	}
	for (let i$1 = 0; i$1 < 2; i$1++) uniforms[`shadow_uShadowMap${i$1}`] = opts.shadowMaps && opts.shadowMaps[i$1] || opts.dummyShadowMap;
	return uniforms;
}
var shadow_default = {
	name: "shadow",
	dependencies: [project_default],
	vs: vs$2,
	fs: fs$1,
	inject: {
		"vs:DECKGL_FILTER_GL_POSITION": `
    position = shadow_setVertexPosition(geometry.position);
    `,
		"fs:DECKGL_FILTER_COLOR": `
    color = shadow_filterShadowColor(color);
    `
	},
	getUniforms: createShadowUniforms,
	uniformTypes: {
		drawShadowMap: "f32",
		useShadowMap: "f32",
		color: "vec4<f32>",
		lightId: "i32",
		lightCount: "f32",
		viewProjectionMatrix0: "mat4x4<f32>",
		viewProjectionMatrix1: "mat4x4<f32>",
		projectCenter0: "vec4<f32>",
		projectCenter1: "vec4<f32>"
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/shaderlib/picking/picking.js
var picking_default = {
	...picking,
	defaultUniforms: {
		...picking.defaultUniforms,
		useFloatColors: false
	},
	inject: {
		"vs:DECKGL_FILTER_GL_POSITION": `
    // for picking depth values
    picking_setPickingAttribute(position.z / position.w);
  `,
		"vs:DECKGL_FILTER_COLOR": `
  picking_setPickingColor(geometry.pickingColor);
  `,
		"fs:DECKGL_FILTER_COLOR": {
			order: 99,
			injection: `
  // use highlight color if this fragment belongs to the selected object.
  color = picking_filterHighlightColor(color);

  // use picking color if rendering to picking FBO.
  color = picking_filterPickingColor(color);
    `
		}
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/shaderlib/index.js
var DEFAULT_MODULES = [geometry_default];
var SHADER_HOOKS_GLSL = [
	"vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)",
	"vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)",
	"vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)",
	"fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"
];
var SHADER_HOOKS_WGSL = [];
function getShaderAssembler(language) {
	const shaderAssembler = ShaderAssembler.getDefaultShaderAssembler();
	for (const shaderModule of DEFAULT_MODULES) shaderAssembler.addDefaultModule(shaderModule);
	shaderAssembler._hookFunctions.length = 0;
	const shaderHooks = language === "glsl" ? SHADER_HOOKS_GLSL : SHADER_HOOKS_WGSL;
	for (const shaderHook of shaderHooks) shaderAssembler.addShaderHook(shaderHook);
	return shaderAssembler;
}

//#endregion
//#region node_modules/@deck.gl/core/dist/effects/lighting/ambient-light.js
var DEFAULT_LIGHT_COLOR$2 = [
	255,
	255,
	255
];
var DEFAULT_LIGHT_INTENSITY$2 = 1;
var idCount$2 = 0;
var AmbientLight = class {
	constructor(props = {}) {
		this.type = "ambient";
		const { color = DEFAULT_LIGHT_COLOR$2 } = props;
		const { intensity = DEFAULT_LIGHT_INTENSITY$2 } = props;
		this.id = props.id || `ambient-${idCount$2++}`;
		this.color = color;
		this.intensity = intensity;
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/effects/lighting/directional-light.js
var DEFAULT_LIGHT_COLOR$1 = [
	255,
	255,
	255
];
var DEFAULT_LIGHT_INTENSITY$1 = 1;
var DEFAULT_LIGHT_DIRECTION = [
	0,
	0,
	-1
];
var idCount$1 = 0;
var DirectionalLight = class {
	constructor(props = {}) {
		this.type = "directional";
		const { color = DEFAULT_LIGHT_COLOR$1 } = props;
		const { intensity = DEFAULT_LIGHT_INTENSITY$1 } = props;
		const { direction = DEFAULT_LIGHT_DIRECTION } = props;
		const { _shadow = false } = props;
		this.id = props.id || `directional-${idCount$1++}`;
		this.color = color;
		this.intensity = intensity;
		this.type = "directional";
		this.direction = new Vector3(direction).normalize().toArray();
		this.shadow = _shadow;
	}
	getProjectedLight(opts) {
		return this;
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/passes/pass.js
/**
* Base class for passes
* @todo v9 - should the luma.gl RenderPass be owned by this class?
* Currently owned by subclasses
*/
var Pass = class {
	/** Create a new Pass instance */
	constructor(device, props = { id: "pass" }) {
		const { id } = props;
		this.id = id;
		this.device = device;
		this.props = { ...props };
	}
	setProps(props) {
		Object.assign(this.props, props);
	}
	render(params) {}
	cleanup() {}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/passes/layers-pass.js
/** A Pass that renders all layers */
var LayersPass = class extends Pass {
	constructor() {
		super(...arguments);
		this._lastRenderIndex = -1;
	}
	render(options) {
		const [width, height] = this.device.canvasContext.getDrawingBufferSize();
		const clearCanvas = options.clearCanvas ?? true;
		const clearColor = options.clearColor ?? (clearCanvas ? [
			0,
			0,
			0,
			0
		] : false);
		const clearDepth = clearCanvas ? 1 : false;
		const clearStencil = clearCanvas ? 0 : false;
		const colorMask = options.colorMask ?? 15;
		const parameters = { viewport: [
			0,
			0,
			width,
			height
		] };
		if (options.colorMask) parameters.colorMask = colorMask;
		if (options.scissorRect) parameters.scissorRect = options.scissorRect;
		const renderPass = this.device.beginRenderPass({
			framebuffer: options.target,
			parameters,
			clearColor,
			clearDepth,
			clearStencil
		});
		try {
			return this._drawLayers(renderPass, options);
		} finally {
			renderPass.end();
			this.device.submit();
		}
	}
	/** Draw a list of layers in a list of viewports */
	_drawLayers(renderPass, options) {
		const { target, shaderModuleProps, viewports, views, onViewportActive, clearStack = true } = options;
		options.pass = options.pass || "unknown";
		if (clearStack) this._lastRenderIndex = -1;
		const renderStats = [];
		for (const viewport of viewports) {
			const view = views && views[viewport.id];
			onViewportActive?.(viewport);
			const drawLayerParams = this._getDrawLayerParams(viewport, options);
			const subViewports = viewport.subViewports || [viewport];
			for (const subViewport of subViewports) {
				const stats = this._drawLayersInViewport(renderPass, {
					target,
					shaderModuleProps,
					viewport: subViewport,
					view,
					pass: options.pass,
					layers: options.layers
				}, drawLayerParams);
				renderStats.push(stats);
			}
		}
		return renderStats;
	}
	_getDrawLayerParams(viewport, { layers, pass, isPicking = false, layerFilter, cullRect, effects, shaderModuleProps }, evaluateShouldDrawOnly = false) {
		const drawLayerParams = [];
		const indexResolver = layerIndexResolver(this._lastRenderIndex + 1);
		const drawContext = {
			layer: layers[0],
			viewport,
			isPicking,
			renderPass: pass,
			cullRect
		};
		const layerFilterCache = {};
		for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
			const layer = layers[layerIndex];
			const shouldDrawLayer = this._shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache);
			const layerParam = { shouldDrawLayer };
			if (shouldDrawLayer && !evaluateShouldDrawOnly) {
				layerParam.shouldDrawLayer = true;
				layerParam.layerRenderIndex = indexResolver(layer, shouldDrawLayer);
				layerParam.shaderModuleProps = this._getShaderModuleProps(layer, effects, pass, shaderModuleProps);
				layerParam.layerParameters = {
					...layer.context.deck?.props.parameters,
					...this.getLayerParameters(layer, layerIndex, viewport)
				};
			}
			drawLayerParams[layerIndex] = layerParam;
		}
		return drawLayerParams;
	}
	_drawLayersInViewport(renderPass, { layers, shaderModuleProps: globalModuleParameters, pass, target, viewport, view }, drawLayerParams) {
		const glViewport = getGLViewport(this.device, {
			shaderModuleProps: globalModuleParameters,
			target,
			viewport
		});
		if (view) {
			const { clear, clearColor, clearDepth, clearStencil } = view.props;
			if (clear) {
				let colorToUse = [
					0,
					0,
					0,
					0
				];
				let depthToUse = 1;
				let stencilToUse = 0;
				if (Array.isArray(clearColor)) colorToUse = [...clearColor.slice(0, 3), clearColor[3] || 255].map((c$1) => c$1 / 255);
				else if (clearColor === false) colorToUse = false;
				if (clearDepth !== void 0) depthToUse = clearDepth;
				if (clearStencil !== void 0) stencilToUse = clearStencil;
				this.device.beginRenderPass({
					framebuffer: target,
					parameters: {
						viewport: glViewport,
						scissorRect: glViewport
					},
					clearColor: colorToUse,
					clearDepth: depthToUse,
					clearStencil: stencilToUse
				}).end();
			}
		}
		const renderStatus = {
			totalCount: layers.length,
			visibleCount: 0,
			compositeCount: 0,
			pickableCount: 0
		};
		renderPass.setParameters({ viewport: glViewport });
		for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
			const layer = layers[layerIndex];
			const drawLayerParameters = drawLayerParams[layerIndex];
			const { shouldDrawLayer } = drawLayerParameters;
			if (shouldDrawLayer && layer.props.pickable) renderStatus.pickableCount++;
			if (layer.isComposite) renderStatus.compositeCount++;
			if (layer.isDrawable && drawLayerParameters.shouldDrawLayer) {
				const { layerRenderIndex, shaderModuleProps, layerParameters } = drawLayerParameters;
				renderStatus.visibleCount++;
				this._lastRenderIndex = Math.max(this._lastRenderIndex, layerRenderIndex);
				if (shaderModuleProps.project) shaderModuleProps.project.viewport = viewport;
				layer.context.renderPass = renderPass;
				try {
					layer._drawLayer({
						renderPass,
						shaderModuleProps,
						uniforms: { layerIndex: layerRenderIndex },
						parameters: layerParameters
					});
				} catch (err) {
					layer.raiseError(err, `drawing ${layer} to ${pass}`);
				}
			}
		}
		return renderStatus;
	}
	shouldDrawLayer(layer) {
		return true;
	}
	getShaderModuleProps(layer, effects, otherShaderModuleProps) {
		return null;
	}
	getLayerParameters(layer, layerIndex, viewport) {
		return layer.props.parameters;
	}
	_shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache) {
		if (!(layer.props.visible && this.shouldDrawLayer(layer))) return false;
		drawContext.layer = layer;
		let parent = layer.parent;
		while (parent) {
			if (!parent.props.visible || !parent.filterSubLayer(drawContext)) return false;
			drawContext.layer = parent;
			parent = parent.parent;
		}
		if (layerFilter) {
			const rootLayerId = drawContext.layer.id;
			if (!(rootLayerId in layerFilterCache)) layerFilterCache[rootLayerId] = layerFilter(drawContext);
			if (!layerFilterCache[rootLayerId]) return false;
		}
		layer.activateViewport(drawContext.viewport);
		return true;
	}
	_getShaderModuleProps(layer, effects, pass, overrides) {
		const devicePixelRatio = this.device.canvasContext.cssToDeviceRatio();
		const layerProps = layer.internalState?.propsInTransition || layer.props;
		const shaderModuleProps = {
			layer: layerProps,
			picking: { isActive: false },
			project: {
				viewport: layer.context.viewport,
				devicePixelRatio,
				modelMatrix: layerProps.modelMatrix,
				coordinateSystem: layerProps.coordinateSystem,
				coordinateOrigin: layerProps.coordinateOrigin,
				autoWrapLongitude: layer.wrapLongitude
			}
		};
		if (effects) for (const effect of effects) mergeModuleParameters(shaderModuleProps, effect.getShaderModuleProps?.(layer, shaderModuleProps));
		return mergeModuleParameters(shaderModuleProps, this.getShaderModuleProps(layer, effects, shaderModuleProps), overrides);
	}
};
function layerIndexResolver(startIndex = 0, layerIndices = {}) {
	const resolvers = {};
	const resolveLayerIndex = (layer, isDrawn) => {
		const indexOverride = layer.props._offset;
		const layerId = layer.id;
		const parentId = layer.parent && layer.parent.id;
		let index;
		if (parentId && !(parentId in layerIndices)) resolveLayerIndex(layer.parent, false);
		if (parentId in resolvers) {
			const resolver = resolvers[parentId] = resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices);
			index = resolver(layer, isDrawn);
			resolvers[layerId] = resolver;
		} else if (Number.isFinite(indexOverride)) {
			index = indexOverride + (layerIndices[parentId] || 0);
			resolvers[layerId] = null;
		} else index = startIndex;
		if (isDrawn && index >= startIndex) startIndex = index + 1;
		layerIndices[layerId] = index;
		return index;
	};
	return resolveLayerIndex;
}
function getGLViewport(device, { shaderModuleProps, target, viewport }) {
	const pixelRatio = shaderModuleProps?.project?.devicePixelRatio ?? device.canvasContext.cssToDeviceRatio();
	const [, drawingBufferHeight] = device.canvasContext.getDrawingBufferSize();
	const height = target ? target.height : drawingBufferHeight;
	const dimensions = viewport;
	return [
		dimensions.x * pixelRatio,
		height - (dimensions.y + dimensions.height) * pixelRatio,
		dimensions.width * pixelRatio,
		dimensions.height * pixelRatio
	];
}
function mergeModuleParameters(target, ...sources) {
	for (const source$2 of sources) if (source$2) for (const key in source$2) if (target[key]) Object.assign(target[key], source$2[key]);
	else target[key] = source$2[key];
	return target;
}

//#endregion
//#region node_modules/@deck.gl/core/dist/passes/shadow-pass.js
var ShadowPass = class extends LayersPass {
	constructor(device, props) {
		super(device, props);
		const shadowMap = device.createTexture({
			format: "rgba8unorm",
			width: 1,
			height: 1,
			sampler: {
				minFilter: "linear",
				magFilter: "linear",
				addressModeU: "clamp-to-edge",
				addressModeV: "clamp-to-edge"
			}
		});
		const depthBuffer = device.createTexture({
			format: "depth16unorm",
			width: 1,
			height: 1
		});
		this.fbo = device.createFramebuffer({
			id: "shadowmap",
			width: 1,
			height: 1,
			colorAttachments: [shadowMap],
			depthStencilAttachment: depthBuffer
		});
	}
	delete() {
		if (this.fbo) {
			this.fbo.destroy();
			this.fbo = null;
		}
	}
	getShadowMap() {
		return this.fbo.colorAttachments[0].texture;
	}
	render(params) {
		const target = this.fbo;
		const pixelRatio = this.device.canvasContext.cssToDeviceRatio();
		const viewport = params.viewports[0];
		const width = viewport.width * pixelRatio;
		const height = viewport.height * pixelRatio;
		const clearColor = [
			1,
			1,
			1,
			1
		];
		if (width !== target.width || height !== target.height) target.resize({
			width,
			height
		});
		super.render({
			...params,
			clearColor,
			target,
			pass: "shadow"
		});
	}
	getLayerParameters(layer, layerIndex, viewport) {
		return {
			...layer.props.parameters,
			blend: false,
			depthWriteEnabled: true,
			depthCompare: "less-equal"
		};
	}
	shouldDrawLayer(layer) {
		return layer.props.shadowEnabled !== false;
	}
	getShaderModuleProps(layer, effects, otherShaderModuleProps) {
		return { shadow: {
			project: otherShaderModuleProps.project,
			drawToShadowMap: true
		} };
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/effects/lighting/lighting-effect.js
var DEFAULT_AMBIENT_LIGHT_PROPS = {
	color: [
		255,
		255,
		255
	],
	intensity: 1
};
var DEFAULT_DIRECTIONAL_LIGHT_PROPS = [{
	color: [
		255,
		255,
		255
	],
	intensity: 1,
	direction: [
		-1,
		3,
		-1
	]
}, {
	color: [
		255,
		255,
		255
	],
	intensity: .9,
	direction: [
		1,
		-8,
		-2.5
	]
}];
var DEFAULT_SHADOW_COLOR = [
	0,
	0,
	0,
	200 / 255
];
var LightingEffect = class {
	constructor(props = {}) {
		this.id = "lighting-effect";
		this.shadowColor = DEFAULT_SHADOW_COLOR;
		this.shadow = false;
		this.directionalLights = [];
		this.pointLights = [];
		this.shadowPasses = [];
		this.dummyShadowMap = null;
		this.setProps(props);
	}
	setup(context) {
		this.context = context;
		const { device, deck } = context;
		if (this.shadow && !this.dummyShadowMap) {
			this._createShadowPasses(device);
			deck._addDefaultShaderModule(shadow_default);
			this.dummyShadowMap = device.createTexture({
				width: 1,
				height: 1
			});
		}
	}
	setProps(props) {
		this.ambientLight = void 0;
		this.directionalLights = [];
		this.pointLights = [];
		for (const key in props) {
			const lightSource = props[key];
			switch (lightSource.type) {
				case "ambient":
					this.ambientLight = lightSource;
					break;
				case "directional":
					this.directionalLights.push(lightSource);
					break;
				case "point":
					this.pointLights.push(lightSource);
					break;
				default:
			}
		}
		this._applyDefaultLights();
		this.shadow = this.directionalLights.some((light) => light.shadow);
		if (this.context) this.setup(this.context);
		this.props = props;
	}
	preRender({ layers, layerFilter, viewports, onViewportActive, views }) {
		if (!this.shadow) return;
		this.shadowMatrices = this._calculateMatrices();
		for (let i$1 = 0; i$1 < this.shadowPasses.length; i$1++) this.shadowPasses[i$1].render({
			layers,
			layerFilter,
			viewports,
			onViewportActive,
			views,
			shaderModuleProps: { shadow: {
				shadowLightId: i$1,
				dummyShadowMap: this.dummyShadowMap,
				shadowMatrices: this.shadowMatrices
			} }
		});
	}
	getShaderModuleProps(layer, otherShaderModuleProps) {
		const shadowProps = this.shadow ? {
			project: otherShaderModuleProps.project,
			shadowMaps: this.shadowPasses.map((shadowPass) => shadowPass.getShadowMap()),
			dummyShadowMap: this.dummyShadowMap,
			shadowColor: this.shadowColor,
			shadowMatrices: this.shadowMatrices
		} : {};
		const lightingProps = {
			enabled: true,
			ambientLight: this.ambientLight,
			directionalLights: this.directionalLights.map((directionalLight) => directionalLight.getProjectedLight({ layer })),
			pointLights: this.pointLights.map((pointLight) => pointLight.getProjectedLight({ layer }))
		};
		const materialProps = layer.props.material;
		return {
			shadow: shadowProps,
			lighting: lightingProps,
			phongMaterial: materialProps,
			gouraudMaterial: materialProps
		};
	}
	cleanup(context) {
		for (const shadowPass of this.shadowPasses) shadowPass.delete();
		this.shadowPasses.length = 0;
		if (this.dummyShadowMap) {
			this.dummyShadowMap.destroy();
			this.dummyShadowMap = null;
			context.deck._removeDefaultShaderModule(shadow_default);
		}
	}
	_calculateMatrices() {
		const lightMatrices = [];
		for (const light of this.directionalLights) {
			const viewMatrix$1 = new Matrix4().lookAt({ eye: new Vector3(light.direction).negate() });
			lightMatrices.push(viewMatrix$1);
		}
		return lightMatrices;
	}
	_createShadowPasses(device) {
		for (let i$1 = 0; i$1 < this.directionalLights.length; i$1++) {
			const shadowPass = new ShadowPass(device);
			this.shadowPasses[i$1] = shadowPass;
		}
	}
	_applyDefaultLights() {
		const { ambientLight, pointLights, directionalLights } = this;
		if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {
			this.ambientLight = new AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);
			this.directionalLights.push(new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]), new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1]));
		}
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/typed-array-manager.js
var TypedArrayManager = class {
	constructor(options = {}) {
		this._pool = [];
		this.opts = {
			overAlloc: 2,
			poolSize: 100
		};
		this.setOptions(options);
	}
	setOptions(options) {
		Object.assign(this.opts, options);
	}
	allocate(typedArray, count$1, { size = 1, type, padding = 0, copy = false, initialize = false, maxCount }) {
		const Type = type || typedArray && typedArray.constructor || Float32Array;
		const newSize = count$1 * size + padding;
		if (ArrayBuffer.isView(typedArray)) {
			if (newSize <= typedArray.length) return typedArray;
			if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) return new Type(typedArray.buffer, 0, newSize);
		}
		let maxSize = Infinity;
		if (maxCount) maxSize = maxCount * size + padding;
		const newArray = this._allocate(Type, newSize, initialize, maxSize);
		if (typedArray && copy) newArray.set(typedArray);
		else if (!initialize) newArray.fill(0, 0, 4);
		this._release(typedArray);
		return newArray;
	}
	release(typedArray) {
		this._release(typedArray);
	}
	_allocate(Type, size, initialize, maxSize) {
		let sizeToAllocate = Math.max(Math.ceil(size * this.opts.overAlloc), 1);
		if (sizeToAllocate > maxSize) sizeToAllocate = maxSize;
		const pool = this._pool;
		const byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;
		const i$1 = pool.findIndex((b$1) => b$1.byteLength >= byteLength);
		if (i$1 >= 0) {
			const array = new Type(pool.splice(i$1, 1)[0], 0, sizeToAllocate);
			if (initialize) array.fill(0);
			return array;
		}
		return new Type(sizeToAllocate);
	}
	_release(typedArray) {
		if (!ArrayBuffer.isView(typedArray)) return;
		const pool = this._pool;
		const { buffer } = typedArray;
		const { byteLength } = buffer;
		const i$1 = pool.findIndex((b$1) => b$1.byteLength >= byteLength);
		if (i$1 < 0) pool.push(buffer);
		else if (i$1 > 0 || pool.length < this.opts.poolSize) pool.splice(i$1, 0, buffer);
		if (pool.length > this.opts.poolSize) pool.shift();
	}
};
var typed_array_manager_default = new TypedArrayManager();

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/math-utils.js
function createMat4() {
	return [
		1,
		0,
		0,
		0,
		0,
		1,
		0,
		0,
		0,
		0,
		1,
		0,
		0,
		0,
		0,
		1
	];
}
function mod(value, divisor) {
	const modulus = value % divisor;
	return modulus < 0 ? divisor + modulus : modulus;
}
function getCameraPosition(viewMatrixInverse) {
	return [
		viewMatrixInverse[12],
		viewMatrixInverse[13],
		viewMatrixInverse[14]
	];
}
function getFrustumPlanes(viewProjectionMatrix) {
	return {
		left: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[0], viewProjectionMatrix[7] + viewProjectionMatrix[4], viewProjectionMatrix[11] + viewProjectionMatrix[8], viewProjectionMatrix[15] + viewProjectionMatrix[12]),
		right: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[0], viewProjectionMatrix[7] - viewProjectionMatrix[4], viewProjectionMatrix[11] - viewProjectionMatrix[8], viewProjectionMatrix[15] - viewProjectionMatrix[12]),
		bottom: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[1], viewProjectionMatrix[7] + viewProjectionMatrix[5], viewProjectionMatrix[11] + viewProjectionMatrix[9], viewProjectionMatrix[15] + viewProjectionMatrix[13]),
		top: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[1], viewProjectionMatrix[7] - viewProjectionMatrix[5], viewProjectionMatrix[11] - viewProjectionMatrix[9], viewProjectionMatrix[15] - viewProjectionMatrix[13]),
		near: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[2], viewProjectionMatrix[7] + viewProjectionMatrix[6], viewProjectionMatrix[11] + viewProjectionMatrix[10], viewProjectionMatrix[15] + viewProjectionMatrix[14]),
		far: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[2], viewProjectionMatrix[7] - viewProjectionMatrix[6], viewProjectionMatrix[11] - viewProjectionMatrix[10], viewProjectionMatrix[15] - viewProjectionMatrix[14])
	};
}
var scratchVector = new Vector3();
function getFrustumPlane(a$1, b$1, c$1, d$1) {
	scratchVector.set(a$1, b$1, c$1);
	const L$1 = scratchVector.len();
	return {
		distance: d$1 / L$1,
		normal: new Vector3(-a$1 / L$1, -b$1 / L$1, -c$1 / L$1)
	};
}
/**
* Calculate the low part of a WebGL 64 bit float
* @param x {number} - the input float number
* @returns {number} - the lower 32 bit of the number
*/
function fp64LowPart(x$1) {
	return x$1 - Math.fround(x$1);
}
var scratchArray;
/**
* Split a Float64Array into a double-length Float32Array
* @param typedArray
* @param options
* @param options.size  - per attribute size
* @param options.startIndex - start index in the source array
* @param options.endIndex  - end index in the source array
* @returns {} - high part, low part for each attribute:
[1xHi, 1yHi, 1zHi, 1xLow, 1yLow, 1zLow, 2xHi, ...]
*/
function toDoublePrecisionArray(typedArray, options) {
	const { size = 1, startIndex = 0 } = options;
	const endIndex = options.endIndex !== void 0 ? options.endIndex : typedArray.length;
	const count$1 = (endIndex - startIndex) / size;
	scratchArray = typed_array_manager_default.allocate(scratchArray, count$1, {
		type: Float32Array,
		size: size * 2
	});
	let sourceIndex = startIndex;
	let targetIndex = 0;
	while (sourceIndex < endIndex) {
		for (let j$1 = 0; j$1 < size; j$1++) {
			const value = typedArray[sourceIndex++];
			scratchArray[targetIndex + j$1] = value;
			scratchArray[targetIndex + j$1 + size] = fp64LowPart(value);
		}
		targetIndex += size * 2;
	}
	return scratchArray.subarray(0, count$1 * size * 2);
}
function mergeBounds(boundsList) {
	let mergedBounds = null;
	let isMerged = false;
	for (const bounds of boundsList) {
		if (!bounds) continue;
		if (!mergedBounds) mergedBounds = bounds;
		else {
			if (!isMerged) {
				mergedBounds = [[mergedBounds[0][0], mergedBounds[0][1]], [mergedBounds[1][0], mergedBounds[1][1]]];
				isMerged = true;
			}
			mergedBounds[0][0] = Math.min(mergedBounds[0][0], bounds[0][0]);
			mergedBounds[0][1] = Math.min(mergedBounds[0][1], bounds[0][1]);
			mergedBounds[1][0] = Math.max(mergedBounds[1][0], bounds[1][0]);
			mergedBounds[1][1] = Math.max(mergedBounds[1][1], bounds[1][1]);
		}
	}
	return mergedBounds;
}

//#endregion
//#region node_modules/@deck.gl/core/dist/viewports/viewport.js
var DEGREES_TO_RADIANS$3 = Math.PI / 180;
var IDENTITY = createMat4();
var ZERO_VECTOR = [
	0,
	0,
	0
];
var DEFAULT_DISTANCE_SCALES = {
	unitsPerMeter: [
		1,
		1,
		1
	],
	metersPerUnit: [
		1,
		1,
		1
	]
};
function createProjectionMatrix({ width, height, orthographic, fovyRadians, focalDistance, padding, near, far }) {
	const aspect = width / height;
	const matrix = orthographic ? new Matrix4().orthographic({
		fovy: fovyRadians,
		aspect,
		focalDistance,
		near,
		far
	}) : new Matrix4().perspective({
		fovy: fovyRadians,
		aspect,
		near,
		far
	});
	if (padding) {
		const { left = 0, right = 0, top = 0, bottom = 0 } = padding;
		const offsetX = clamp((left + width - right) / 2, 0, width) - width / 2;
		const offsetY = clamp((top + height - bottom) / 2, 0, height) - height / 2;
		matrix[8] -= offsetX * 2 / width;
		matrix[9] += offsetY * 2 / height;
	}
	return matrix;
}
/**
* Manages coordinate system transformations.
*
* Note: The Viewport is immutable in the sense that it only has accessors.
* A new viewport instance should be created if any parameters have changed.
*/
var Viewport = class Viewport {
	constructor(opts = {}) {
		this._frustumPlanes = {};
		this.id = opts.id || this.constructor.displayName || "viewport";
		this.x = opts.x || 0;
		this.y = opts.y || 0;
		this.width = opts.width || 1;
		this.height = opts.height || 1;
		this.zoom = opts.zoom || 0;
		this.padding = opts.padding;
		this.distanceScales = opts.distanceScales || DEFAULT_DISTANCE_SCALES;
		this.focalDistance = opts.focalDistance || 1;
		this.position = opts.position || ZERO_VECTOR;
		this.modelMatrix = opts.modelMatrix || null;
		const { longitude, latitude } = opts;
		this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);
		this._initProps(opts);
		this._initMatrices(opts);
		this.equals = this.equals.bind(this);
		this.project = this.project.bind(this);
		this.unproject = this.unproject.bind(this);
		this.projectPosition = this.projectPosition.bind(this);
		this.unprojectPosition = this.unprojectPosition.bind(this);
		this.projectFlat = this.projectFlat.bind(this);
		this.unprojectFlat = this.unprojectFlat.bind(this);
	}
	get subViewports() {
		return null;
	}
	get metersPerPixel() {
		return this.distanceScales.metersPerUnit[2] / this.scale;
	}
	get projectionMode() {
		if (this.isGeospatial) return this.zoom < 12 ? PROJECTION_MODE.WEB_MERCATOR : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;
		return PROJECTION_MODE.IDENTITY;
	}
	equals(viewport) {
		if (!(viewport instanceof Viewport)) return false;
		if (this === viewport) return true;
		return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && equals(viewport.projectionMatrix, this.projectionMatrix) && equals(viewport.viewMatrix, this.viewMatrix);
	}
	/**
	* Projects xyz (possibly latitude and longitude) to pixel coordinates in window
	* using viewport projection parameters
	* - [longitude, latitude] to [x, y]
	* - [longitude, latitude, Z] => [x, y, z]
	* Note: By default, returns top-left coordinates for canvas/SVG type render
	*
	* @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
	* @param {Object} opts - options
	* @param {Object} opts.topLeft=true - Whether projected coords are top left
	* @return {Array} - [x, y] or [x, y, z] in top left coords
	*/
	project(xyz, { topLeft = true } = {}) {
		const coord = worldToPixels(this.projectPosition(xyz), this.pixelProjectionMatrix);
		const [x$1, y$1] = coord;
		const y2 = topLeft ? y$1 : this.height - y$1;
		return xyz.length === 2 ? [x$1, y2] : [
			x$1,
			y2,
			coord[2]
		];
	}
	/**
	* Unproject pixel coordinates on screen onto world coordinates,
	* (possibly [lon, lat]) on map.
	* - [x, y] => [lng, lat]
	* - [x, y, z] => [lng, lat, Z]
	* @param {Array} xyz -
	* @param {Object} opts - options
	* @param {Object} opts.topLeft=true - Whether origin is top left
	* @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
	*/
	unproject(xyz, { topLeft = true, targetZ } = {}) {
		const [x$1, y$1, z$1] = xyz;
		const y2 = topLeft ? y$1 : this.height - y$1;
		const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
		const coord = pixelsToWorld([
			x$1,
			y2,
			z$1
		], this.pixelUnprojectionMatrix, targetZWorld);
		const [X$1, Y$1, Z$1] = this.unprojectPosition(coord);
		if (Number.isFinite(z$1)) return [
			X$1,
			Y$1,
			Z$1
		];
		return Number.isFinite(targetZ) ? [
			X$1,
			Y$1,
			targetZ
		] : [X$1, Y$1];
	}
	projectPosition(xyz) {
		const [X$1, Y$1] = this.projectFlat(xyz);
		return [
			X$1,
			Y$1,
			(xyz[2] || 0) * this.distanceScales.unitsPerMeter[2]
		];
	}
	unprojectPosition(xyz) {
		const [X$1, Y$1] = this.unprojectFlat(xyz);
		return [
			X$1,
			Y$1,
			(xyz[2] || 0) * this.distanceScales.metersPerUnit[2]
		];
	}
	/**
	* Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
	* Performs the nonlinear part of the web mercator projection.
	* Remaining projection is done with 4x4 matrices which also handles
	* perspective.
	* @param {Array} lngLat - [lng, lat] coordinates
	*   Specifies a point on the sphere to project onto the map.
	* @return {Array} [x,y] coordinates.
	*/
	projectFlat(xyz) {
		if (this.isGeospatial) {
			const result = lngLatToWorld(xyz);
			result[1] = clamp(result[1], -318, 830);
			return result;
		}
		return xyz;
	}
	/**
	* Unproject world point [x,y] on map onto {lat, lon} on sphere
	* @param {object|Vector} xy - object with {x,y} members
	*  representing point on projected map plane
	* @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
	*   Has toArray method if you need a GeoJSON Array.
	*   Per cartographic tradition, lat and lon are specified as degrees.
	*/
	unprojectFlat(xyz) {
		if (this.isGeospatial) return worldToLngLat(xyz);
		return xyz;
	}
	/**
	* Get bounds of the current viewport
	* @return {Array} - [minX, minY, maxX, maxY]
	*/
	getBounds(options = {}) {
		const unprojectOption = { targetZ: options.z || 0 };
		const topLeft = this.unproject([0, 0], unprojectOption);
		const topRight = this.unproject([this.width, 0], unprojectOption);
		const bottomLeft = this.unproject([0, this.height], unprojectOption);
		const bottomRight = this.unproject([this.width, this.height], unprojectOption);
		return [
			Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
			Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]),
			Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
			Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])
		];
	}
	getDistanceScales(coordinateOrigin) {
		if (coordinateOrigin && this.isGeospatial) return getDistanceScales$1({
			longitude: coordinateOrigin[0],
			latitude: coordinateOrigin[1],
			highPrecision: true
		});
		return this.distanceScales;
	}
	containsPixel({ x: x$1, y: y$1, width = 1, height = 1 }) {
		return x$1 < this.x + this.width && this.x < x$1 + width && y$1 < this.y + this.height && this.y < y$1 + height;
	}
	getFrustumPlanes() {
		if (this._frustumPlanes.near) return this._frustumPlanes;
		Object.assign(this._frustumPlanes, getFrustumPlanes(this.viewProjectionMatrix));
		return this._frustumPlanes;
	}
	/**
	* Needed by panning and linear transition
	* Pan the viewport to place a given world coordinate at screen point [x, y]
	*
	* @param {Array} coords - world coordinates
	* @param {Array} pixel - [x,y] coordinates on screen
	* @param {Array} startPixel - [x,y] screen position where pan started (optional, for delta-based panning)
	* @return {Object} props of the new viewport
	*/
	panByPosition(coords, pixel, startPixel) {
		return null;
	}
	_initProps(opts) {
		const longitude = opts.longitude;
		const latitude = opts.latitude;
		if (this.isGeospatial) {
			if (!Number.isFinite(opts.zoom)) this.zoom = getMeterZoom({ latitude }) + Math.log2(this.focalDistance);
			this.distanceScales = opts.distanceScales || getDistanceScales$1({
				latitude,
				longitude
			});
		}
		this.scale = Math.pow(2, this.zoom);
		const { position, modelMatrix } = opts;
		let meterOffset = ZERO_VECTOR;
		if (position) meterOffset = modelMatrix ? new Matrix4(modelMatrix).transformAsVector(position, []) : position;
		if (this.isGeospatial) {
			const center = this.projectPosition([
				longitude,
				latitude,
				0
			]);
			this.center = new Vector3(meterOffset).scale(this.distanceScales.unitsPerMeter).add(center);
		} else this.center = this.projectPosition(meterOffset);
	}
	_initMatrices(opts) {
		const { viewMatrix: viewMatrix$1 = IDENTITY, projectionMatrix = null, orthographic = false, fovyRadians, fovy = 75, near = .1, far = 1e3, padding = null, focalDistance = 1 } = opts;
		this.viewMatrixUncentered = viewMatrix$1;
		this.viewMatrix = new Matrix4().multiplyRight(viewMatrix$1).translate(new Vector3(this.center).negate());
		this.projectionMatrix = projectionMatrix || createProjectionMatrix({
			width: this.width,
			height: this.height,
			orthographic,
			fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS$3,
			focalDistance,
			padding,
			near,
			far
		});
		const vpm = createMat4();
		multiply(vpm, vpm, this.projectionMatrix);
		multiply(vpm, vpm, this.viewMatrix);
		this.viewProjectionMatrix = vpm;
		this.viewMatrixInverse = invert([], this.viewMatrix) || this.viewMatrix;
		this.cameraPosition = getCameraPosition(this.viewMatrixInverse);
		const viewportMatrix = createMat4();
		const pixelProjectionMatrix = createMat4();
		scale(viewportMatrix, viewportMatrix, [
			this.width / 2,
			-this.height / 2,
			1
		]);
		translate(viewportMatrix, viewportMatrix, [
			1,
			-1,
			0
		]);
		multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);
		this.pixelProjectionMatrix = pixelProjectionMatrix;
		this.pixelUnprojectionMatrix = invert(createMat4(), this.pixelProjectionMatrix);
		if (!this.pixelUnprojectionMatrix) log_default.warn("Pixel project matrix not invertible")();
	}
};
Viewport.displayName = "Viewport";
var viewport_default = Viewport;

//#endregion
//#region node_modules/@deck.gl/core/dist/viewports/web-mercator-viewport.js
/**
* Manages transformations to/from WGS84 coordinates using the Web Mercator Projection.
*/
var WebMercatorViewport = class WebMercatorViewport extends viewport_default {
	constructor(opts = {}) {
		const { latitude = 0, longitude = 0, zoom = 0, pitch = 0, bearing = 0, nearZMultiplier = .1, farZMultiplier = 1.01, nearZ, farZ, orthographic = false, projectionMatrix, repeat = false, worldOffset = 0, position, padding, legacyMeterSizes = false } = opts;
		let { width, height, altitude = 1.5 } = opts;
		const scale$3 = Math.pow(2, zoom);
		width = width || 1;
		height = height || 1;
		let fovy;
		let projectionParameters = null;
		if (projectionMatrix) {
			altitude = projectionMatrix[5] / 2;
			fovy = altitudeToFovy(altitude);
		} else {
			if (opts.fovy) {
				fovy = opts.fovy;
				altitude = fovyToAltitude(fovy);
			} else fovy = altitudeToFovy(altitude);
			let offset;
			if (padding) {
				const { top = 0, bottom = 0 } = padding;
				offset = [0, clamp((top + height - bottom) / 2, 0, height) - height / 2];
			}
			projectionParameters = getProjectionParameters({
				width,
				height,
				scale: scale$3,
				center: position && [
					0,
					0,
					position[2] * unitsPerMeter(latitude)
				],
				offset,
				pitch,
				fovy,
				nearZMultiplier,
				farZMultiplier
			});
			if (Number.isFinite(nearZ)) projectionParameters.near = nearZ;
			if (Number.isFinite(farZ)) projectionParameters.far = farZ;
		}
		let viewMatrixUncentered = getViewMatrix$1({
			height,
			pitch,
			bearing,
			scale: scale$3,
			altitude
		});
		if (worldOffset) viewMatrixUncentered = new Matrix4().translate([
			512 * worldOffset,
			0,
			0
		]).multiplyLeft(viewMatrixUncentered);
		super({
			...opts,
			width,
			height,
			viewMatrix: viewMatrixUncentered,
			longitude,
			latitude,
			zoom,
			...projectionParameters,
			fovy,
			focalDistance: altitude
		});
		this.latitude = latitude;
		this.longitude = longitude;
		this.zoom = zoom;
		this.pitch = pitch;
		this.bearing = bearing;
		this.altitude = altitude;
		this.fovy = fovy;
		this.orthographic = orthographic;
		this._subViewports = repeat ? [] : null;
		this._pseudoMeters = legacyMeterSizes;
		Object.freeze(this);
	}
	get subViewports() {
		if (this._subViewports && !this._subViewports.length) {
			const bounds = this.getBounds();
			const minOffset = Math.floor((bounds[0] + 180) / 360);
			const maxOffset = Math.ceil((bounds[2] - 180) / 360);
			for (let x$1 = minOffset; x$1 <= maxOffset; x$1++) {
				const offsetViewport = x$1 ? new WebMercatorViewport({
					...this,
					worldOffset: x$1
				}) : this;
				this._subViewports.push(offsetViewport);
			}
		}
		return this._subViewports;
	}
	projectPosition(xyz) {
		if (this._pseudoMeters) return super.projectPosition(xyz);
		const [X$1, Y$1] = this.projectFlat(xyz);
		return [
			X$1,
			Y$1,
			(xyz[2] || 0) * unitsPerMeter(xyz[1])
		];
	}
	unprojectPosition(xyz) {
		if (this._pseudoMeters) return super.unprojectPosition(xyz);
		const [X$1, Y$1] = this.unprojectFlat(xyz);
		return [
			X$1,
			Y$1,
			(xyz[2] || 0) / unitsPerMeter(Y$1)
		];
	}
	/**
	* Add a meter delta to a base lnglat coordinate, returning a new lnglat array
	*
	* Note: Uses simple linear approximation around the viewport center
	* Error increases with size of offset (roughly 1% per 100km)
	*
	* @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate
	* @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
	* @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas
	*/
	addMetersToLngLat(lngLatZ, xyz) {
		return addMetersToLngLat(lngLatZ, xyz);
	}
	panByPosition(coords, pixel, startPixel) {
		const fromLocation = pixelsToWorld(pixel, this.pixelUnprojectionMatrix);
		const toLocation = this.projectFlat(coords);
		const translate$1 = add$1([], toLocation, negate$1([], fromLocation));
		const newCenter = add$1([], this.center, translate$1);
		const [longitude, latitude] = this.unprojectFlat(newCenter);
		return {
			longitude,
			latitude
		};
	}
	getBounds(options = {}) {
		const corners = getBounds(this, options.z || 0);
		return [
			Math.min(corners[0][0], corners[1][0], corners[2][0], corners[3][0]),
			Math.min(corners[0][1], corners[1][1], corners[2][1], corners[3][1]),
			Math.max(corners[0][0], corners[1][0], corners[2][0], corners[3][0]),
			Math.max(corners[0][1], corners[1][1], corners[2][1], corners[3][1])
		];
	}
	/**
	* Returns a new viewport that fit around the given rectangle.
	* Only supports non-perspective mode.
	*/
	fitBounds(bounds, options = {}) {
		const { width, height } = this;
		const { longitude, latitude, zoom } = fitBounds({
			width,
			height,
			bounds,
			...options
		});
		return new WebMercatorViewport({
			width,
			height,
			longitude,
			latitude,
			zoom
		});
	}
};
WebMercatorViewport.displayName = "WebMercatorViewport";
var web_mercator_viewport_default = WebMercatorViewport;

//#endregion
//#region node_modules/@deck.gl/core/dist/shaderlib/project/project-functions.js
/**
* Projection utils
* TODO: move to Viewport class?
*/
var DEFAULT_COORDINATE_ORIGIN = [
	0,
	0,
	0
];
function lngLatZToWorldPosition(lngLatZ, viewport, offsetMode = false) {
	const p$1 = viewport.projectPosition(lngLatZ);
	if (offsetMode && viewport instanceof web_mercator_viewport_default) {
		const [longitude, latitude, z$1 = 0] = lngLatZ;
		p$1[2] = z$1 * viewport.getDistanceScales([longitude, latitude]).unitsPerMeter[2];
	}
	return p$1;
}
function normalizeParameters(opts) {
	const { viewport, modelMatrix, coordinateOrigin } = opts;
	let { coordinateSystem, fromCoordinateSystem, fromCoordinateOrigin } = opts;
	if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
	if (fromCoordinateSystem === void 0) fromCoordinateSystem = coordinateSystem;
	if (fromCoordinateOrigin === void 0) fromCoordinateOrigin = coordinateOrigin;
	return {
		viewport,
		coordinateSystem,
		coordinateOrigin,
		modelMatrix,
		fromCoordinateSystem,
		fromCoordinateOrigin
	};
}
/** Get the common space position from world coordinates in the given coordinate system */
function getWorldPosition(position, { viewport, modelMatrix, coordinateSystem, coordinateOrigin, offsetMode }) {
	let [x$1, y$1, z$1 = 0] = position;
	if (modelMatrix) [x$1, y$1, z$1] = transformMat4$2([], [
		x$1,
		y$1,
		z$1,
		1
	], modelMatrix);
	switch (coordinateSystem) {
		case COORDINATE_SYSTEM.LNGLAT: return lngLatZToWorldPosition([
			x$1,
			y$1,
			z$1
		], viewport, offsetMode);
		case COORDINATE_SYSTEM.LNGLAT_OFFSETS: return lngLatZToWorldPosition([
			x$1 + coordinateOrigin[0],
			y$1 + coordinateOrigin[1],
			z$1 + (coordinateOrigin[2] || 0)
		], viewport, offsetMode);
		case COORDINATE_SYSTEM.METER_OFFSETS: return lngLatZToWorldPosition(addMetersToLngLat(coordinateOrigin, [
			x$1,
			y$1,
			z$1
		]), viewport, offsetMode);
		case COORDINATE_SYSTEM.CARTESIAN:
		default: return viewport.isGeospatial ? [
			x$1 + coordinateOrigin[0],
			y$1 + coordinateOrigin[1],
			z$1 + coordinateOrigin[2]
		] : viewport.projectPosition([
			x$1,
			y$1,
			z$1
		]);
	}
}
/**
* Equivalent to project_position in project.glsl
* projects a user supplied position to world position directly with or without
* a reference coordinate system
*/
function projectPosition(position, params) {
	const { viewport, coordinateSystem, coordinateOrigin, modelMatrix, fromCoordinateSystem, fromCoordinateOrigin } = normalizeParameters(params);
	const { autoOffset = true } = params;
	const { geospatialOrigin = DEFAULT_COORDINATE_ORIGIN, shaderCoordinateOrigin = DEFAULT_COORDINATE_ORIGIN, offsetMode = false } = autoOffset ? getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin) : {};
	const worldPosition = getWorldPosition(position, {
		viewport,
		modelMatrix,
		coordinateSystem: fromCoordinateSystem,
		coordinateOrigin: fromCoordinateOrigin,
		offsetMode
	});
	if (offsetMode) {
		const positionCommonSpace = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
		sub(worldPosition, worldPosition, positionCommonSpace);
	}
	return worldPosition;
}

//#endregion
//#region node_modules/@deck.gl/core/dist/effects/lighting/point-light.js
var DEFAULT_LIGHT_COLOR = [
	255,
	255,
	255
];
var DEFAULT_LIGHT_INTENSITY = 1;
var DEFAULT_ATTENUATION = [
	1,
	0,
	0
];
var DEFAULT_LIGHT_POSITION = [
	0,
	0,
	1
];
var idCount = 0;
var PointLight = class {
	constructor(props = {}) {
		this.type = "point";
		const { color = DEFAULT_LIGHT_COLOR } = props;
		const { intensity = DEFAULT_LIGHT_INTENSITY } = props;
		const { position = DEFAULT_LIGHT_POSITION } = props;
		this.id = props.id || `point-${idCount++}`;
		this.color = color;
		this.intensity = intensity;
		this.type = "point";
		this.position = position;
		this.attenuation = getAttenuation(props);
		this.projectedLight = { ...this };
	}
	getProjectedLight({ layer }) {
		const { projectedLight } = this;
		const viewport = layer.context.viewport;
		const { coordinateSystem, coordinateOrigin } = layer.props;
		const position = projectPosition(this.position, {
			viewport,
			coordinateSystem,
			coordinateOrigin,
			fromCoordinateSystem: viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN,
			fromCoordinateOrigin: [
				0,
				0,
				0
			]
		});
		projectedLight.color = this.color;
		projectedLight.intensity = this.intensity;
		projectedLight.position = position;
		return projectedLight;
	}
};
function getAttenuation(props) {
	if (props.attenuation) return props.attenuation;
	return DEFAULT_ATTENUATION;
}

//#endregion
//#region node_modules/@deck.gl/core/dist/effects/lighting/camera-light.js
var CameraLight = class extends PointLight {
	getProjectedLight({ layer }) {
		const { projectedLight } = this;
		const viewport = layer.context.viewport;
		const { coordinateSystem, coordinateOrigin, modelMatrix } = layer.props;
		const { cameraPosition } = getUniformsFromViewport({
			viewport,
			modelMatrix,
			coordinateSystem,
			coordinateOrigin
		});
		projectedLight.color = this.color;
		projectedLight.intensity = this.intensity;
		projectedLight.position = cameraPosition;
		return projectedLight;
	}
};

//#endregion
//#region node_modules/@math.gl/sun/dist/suncalc.js
var DEGREES_TO_RADIANS$2 = Math.PI / 180;
var DAY_IN_MS = 1e3 * 60 * 60 * 24;
var JD1970 = 2440588;
var JD2000 = 2451545;
var e = DEGREES_TO_RADIANS$2 * 23.4397;
var M0 = 357.5291;
var M1 = .98560028;
var THETA0 = 280.147;
var THETA1 = 360.9856235;
/**
* Calculate sun position
* based on https://www.aa.quae.nl/en/reken/zonpositie.html
* inspired by https://github.com/mourner/suncalc/blob/master/suncalc.js
*/
function getSunPosition(timestamp, latitude, longitude) {
	const longitudeWestInRadians = DEGREES_TO_RADIANS$2 * -longitude;
	const phi = DEGREES_TO_RADIANS$2 * latitude;
	const d$1 = toDays(timestamp);
	const c$1 = getSunCoords(d$1);
	const H$1 = getSiderealTime(d$1, longitudeWestInRadians) - c$1.rightAscension;
	return {
		azimuth: getAzimuth(H$1, phi, c$1.declination),
		altitude: getAltitude(H$1, phi, c$1.declination)
	};
}
function getSunDirection(timestamp, latitude, longitude) {
	const { azimuth, altitude } = getSunPosition(timestamp, latitude, longitude);
	return [
		Math.sin(azimuth) * Math.cos(altitude),
		Math.cos(azimuth) * Math.cos(altitude),
		-Math.sin(altitude)
	];
}
function toJulianDay(timestamp) {
	return (typeof timestamp === "number" ? timestamp : timestamp.getTime()) / DAY_IN_MS - .5 + JD1970;
}
function toDays(timestamp) {
	return toJulianDay(timestamp) - JD2000;
}
function getRightAscension(eclipticLongitude, b$1) {
	const lambda = eclipticLongitude;
	return Math.atan2(Math.sin(lambda) * Math.cos(e) - Math.tan(b$1) * Math.sin(e), Math.cos(lambda));
}
function getDeclination(eclipticLongitude, b$1) {
	const lambda = eclipticLongitude;
	return Math.asin(Math.sin(b$1) * Math.cos(e) + Math.cos(b$1) * Math.sin(e) * Math.sin(lambda));
}
function getAzimuth(hourAngle, latitudeInRadians, declination) {
	const H$1 = hourAngle;
	const phi = latitudeInRadians;
	const delta = declination;
	return Math.atan2(Math.sin(H$1), Math.cos(H$1) * Math.sin(phi) - Math.tan(delta) * Math.cos(phi));
}
function getAltitude(hourAngle, latitudeInRadians, declination) {
	const H$1 = hourAngle;
	const phi = latitudeInRadians;
	const delta = declination;
	return Math.asin(Math.sin(phi) * Math.sin(delta) + Math.cos(phi) * Math.cos(delta) * Math.cos(H$1));
}
function getSiderealTime(dates, longitudeWestInRadians) {
	return DEGREES_TO_RADIANS$2 * (THETA0 + THETA1 * dates) - longitudeWestInRadians;
}
function getSolarMeanAnomaly(days) {
	return DEGREES_TO_RADIANS$2 * (M0 + M1 * days);
}
function getEclipticLongitude(meanAnomaly) {
	const M$1 = meanAnomaly;
	const C$1 = DEGREES_TO_RADIANS$2 * (1.9148 * Math.sin(M$1) + .02 * Math.sin(2 * M$1) + 3e-4 * Math.sin(3 * M$1));
	const P$1 = DEGREES_TO_RADIANS$2 * 102.9372;
	return M$1 + C$1 + P$1 + Math.PI;
}
function getSunCoords(dates) {
	const L$1 = getEclipticLongitude(getSolarMeanAnomaly(dates));
	return {
		declination: getDeclination(L$1, 0),
		rightAscension: getRightAscension(L$1, 0)
	};
}

//#endregion
//#region node_modules/@deck.gl/core/dist/effects/lighting/sun-light.js
var SunLight = class extends DirectionalLight {
	constructor(opts) {
		super(opts);
		this.timestamp = opts.timestamp;
	}
	getProjectedLight({ layer }) {
		const { viewport } = layer.context;
		if (viewport.resolution && viewport.resolution > 0) {
			const [x$1, y$1, z$1] = getSunDirection(this.timestamp, 0, 0);
			this.direction = [
				x$1,
				-z$1,
				y$1
			];
		} else {
			const { latitude, longitude } = viewport;
			this.direction = getSunDirection(this.timestamp, latitude, longitude);
		}
		return this;
	}
};

//#endregion
//#region node_modules/@luma.gl/engine/dist/animation/timeline.js
var channelHandles = 1;
var animationHandles = 1;
var Timeline = class {
	time = 0;
	channels = /* @__PURE__ */ new Map();
	animations = /* @__PURE__ */ new Map();
	playing = false;
	lastEngineTime = -1;
	constructor() {}
	addChannel(props) {
		const { delay = 0, duration = Number.POSITIVE_INFINITY, rate = 1, repeat = 1 } = props;
		const channelId = channelHandles++;
		const channel = {
			time: 0,
			delay,
			duration,
			rate,
			repeat
		};
		this._setChannelTime(channel, this.time);
		this.channels.set(channelId, channel);
		return channelId;
	}
	removeChannel(channelId) {
		this.channels.delete(channelId);
		for (const [animationHandle, animation] of this.animations) if (animation.channel === channelId) this.detachAnimation(animationHandle);
	}
	isFinished(channelId) {
		const channel = this.channels.get(channelId);
		if (channel === void 0) return false;
		return this.time >= channel.delay + channel.duration * channel.repeat;
	}
	getTime(channelId) {
		if (channelId === void 0) return this.time;
		const channel = this.channels.get(channelId);
		if (channel === void 0) return -1;
		return channel.time;
	}
	setTime(time) {
		this.time = Math.max(0, time);
		const channels = this.channels.values();
		for (const channel of channels) this._setChannelTime(channel, this.time);
		const animations = this.animations.values();
		for (const animationData of animations) {
			const { animation, channel } = animationData;
			animation.setTime(this.getTime(channel));
		}
	}
	play() {
		this.playing = true;
	}
	pause() {
		this.playing = false;
		this.lastEngineTime = -1;
	}
	reset() {
		this.setTime(0);
	}
	attachAnimation(animation, channelHandle) {
		const animationHandle = animationHandles++;
		this.animations.set(animationHandle, {
			animation,
			channel: channelHandle
		});
		animation.setTime(this.getTime(channelHandle));
		return animationHandle;
	}
	detachAnimation(channelId) {
		this.animations.delete(channelId);
	}
	update(engineTime) {
		if (this.playing) {
			if (this.lastEngineTime === -1) this.lastEngineTime = engineTime;
			this.setTime(this.time + (engineTime - this.lastEngineTime));
			this.lastEngineTime = engineTime;
		}
	}
	_setChannelTime(channel, time) {
		const offsetTime = time - channel.delay;
		if (offsetTime >= channel.duration * channel.repeat) channel.time = channel.duration * channel.rate;
		else {
			channel.time = Math.max(0, offsetTime) % channel.duration;
			channel.time *= channel.rate;
		}
	}
};

//#endregion
//#region node_modules/@luma.gl/engine/dist/animation-loop/request-animation-frame.js
/** Node.js polyfill for requestAnimationFrame */
function requestAnimationFramePolyfill(callback) {
	return typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1e3 / 60);
}
/** Node.js polyfill for cancelAnimationFrame */
function cancelAnimationFramePolyfill(timerId) {
	return typeof window !== "undefined" && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
}

//#endregion
//#region node_modules/@luma.gl/engine/dist/animation-loop/animation-loop.js
var statIdCounter = 0;
/** Convenient animation loop */
var AnimationLoop = class AnimationLoop {
	static defaultAnimationLoopProps = {
		device: null,
		onAddHTML: () => "",
		onInitialize: async () => null,
		onRender: () => {},
		onFinalize: () => {},
		onError: (error) => console.error(error),
		stats: luma.stats.get(`animation-loop-${statIdCounter++}`),
		autoResizeViewport: false
	};
	device = null;
	canvas = null;
	props;
	animationProps = null;
	timeline = null;
	stats;
	cpuTime;
	gpuTime;
	frameRate;
	display;
	needsRedraw = "initialized";
	_initialized = false;
	_running = false;
	_animationFrameId = null;
	_nextFramePromise = null;
	_resolveNextFrame = null;
	_cpuStartTime = 0;
	_error = null;
	constructor(props) {
		this.props = {
			...AnimationLoop.defaultAnimationLoopProps,
			...props
		};
		props = this.props;
		if (!props.device) throw new Error("No device provided");
		this.stats = props.stats || new Stats({ id: "animation-loop-stats" });
		this.cpuTime = this.stats.get("CPU Time");
		this.gpuTime = this.stats.get("GPU Time");
		this.frameRate = this.stats.get("Frame Rate");
		this.setProps({ autoResizeViewport: props.autoResizeViewport });
		this.start = this.start.bind(this);
		this.stop = this.stop.bind(this);
		this._onMousemove = this._onMousemove.bind(this);
		this._onMouseleave = this._onMouseleave.bind(this);
	}
	destroy() {
		this.stop();
		this._setDisplay(null);
	}
	/** @deprecated Use .destroy() */
	delete() {
		this.destroy();
	}
	reportError(error) {
		this.props.onError(error);
		this._error = error;
	}
	/** Flags this animation loop as needing redraw */
	setNeedsRedraw(reason) {
		this.needsRedraw = this.needsRedraw || reason;
		return this;
	}
	setProps(props) {
		if ("autoResizeViewport" in props) this.props.autoResizeViewport = props.autoResizeViewport || false;
		return this;
	}
	/** Starts a render loop if not already running */
	async start() {
		if (this._running) return this;
		this._running = true;
		try {
			let appContext;
			if (!this._initialized) {
				this._initialized = true;
				await this._initDevice();
				this._initialize();
				await this.props.onInitialize(this._getAnimationProps());
			}
			if (!this._running) return null;
			if (appContext !== false) {
				this._cancelAnimationFrame();
				this._requestAnimationFrame();
			}
			return this;
		} catch (err) {
			const error = err instanceof Error ? err : /* @__PURE__ */ new Error("Unknown error");
			this.props.onError(error);
			throw error;
		}
	}
	/** Stops a render loop if already running, finalizing */
	stop() {
		if (this._running) {
			if (this.animationProps && !this._error) this.props.onFinalize(this.animationProps);
			this._cancelAnimationFrame();
			this._nextFramePromise = null;
			this._resolveNextFrame = null;
			this._running = false;
		}
		return this;
	}
	/** Explicitly draw a frame */
	redraw() {
		if (this.device?.isLost || this._error) return this;
		this._beginFrameTimers();
		this._setupFrame();
		this._updateAnimationProps();
		this._renderFrame(this._getAnimationProps());
		this._clearNeedsRedraw();
		if (this._resolveNextFrame) {
			this._resolveNextFrame(this);
			this._nextFramePromise = null;
			this._resolveNextFrame = null;
		}
		this._endFrameTimers();
		return this;
	}
	/** Add a timeline, it will be automatically updated by the animation loop. */
	attachTimeline(timeline) {
		this.timeline = timeline;
		return this.timeline;
	}
	/** Remove a timeline */
	detachTimeline() {
		this.timeline = null;
	}
	/** Wait until a render completes */
	waitForRender() {
		this.setNeedsRedraw("waitForRender");
		if (!this._nextFramePromise) this._nextFramePromise = new Promise((resolve) => {
			this._resolveNextFrame = resolve;
		});
		return this._nextFramePromise;
	}
	/** TODO - should use device.deviceContext */
	async toDataURL() {
		this.setNeedsRedraw("toDataURL");
		await this.waitForRender();
		if (this.canvas instanceof HTMLCanvasElement) return this.canvas.toDataURL();
		throw new Error("OffscreenCanvas");
	}
	_initialize() {
		this._startEventHandling();
		this._initializeAnimationProps();
		this._updateAnimationProps();
		this._resizeViewport();
	}
	_setDisplay(display) {
		if (this.display) {
			this.display.destroy();
			this.display.animationLoop = null;
		}
		if (display) display.animationLoop = this;
		this.display = display;
	}
	_requestAnimationFrame() {
		if (!this._running) return;
		this._animationFrameId = requestAnimationFramePolyfill(this._animationFrame.bind(this));
	}
	_cancelAnimationFrame() {
		if (this._animationFrameId === null) return;
		cancelAnimationFramePolyfill(this._animationFrameId);
		this._animationFrameId = null;
	}
	_animationFrame() {
		if (!this._running) return;
		this.redraw();
		this._requestAnimationFrame();
	}
	_renderFrame(animationProps) {
		if (this.display) {
			this.display._renderFrame(animationProps);
			return;
		}
		this.props.onRender(this._getAnimationProps());
		this.device?.submit();
	}
	_clearNeedsRedraw() {
		this.needsRedraw = false;
	}
	_setupFrame() {
		this._resizeViewport();
	}
	_initializeAnimationProps() {
		const canvasContext = this.device?.getDefaultCanvasContext();
		if (!this.device || !canvasContext) throw new Error("loop");
		const canvas$1 = canvasContext?.canvas;
		const useDevicePixels = canvasContext.props.useDevicePixels;
		this.animationProps = {
			animationLoop: this,
			device: this.device,
			canvasContext,
			canvas: canvas$1,
			useDevicePixels,
			timeline: this.timeline,
			needsRedraw: false,
			width: 1,
			height: 1,
			aspect: 1,
			time: 0,
			startTime: Date.now(),
			engineTime: 0,
			tick: 0,
			tock: 0,
			_mousePosition: null
		};
	}
	_getAnimationProps() {
		if (!this.animationProps) throw new Error("animationProps");
		return this.animationProps;
	}
	_updateAnimationProps() {
		if (!this.animationProps) return;
		const { width, height, aspect } = this._getSizeAndAspect();
		if (width !== this.animationProps.width || height !== this.animationProps.height) this.setNeedsRedraw("drawing buffer resized");
		if (aspect !== this.animationProps.aspect) this.setNeedsRedraw("drawing buffer aspect changed");
		this.animationProps.width = width;
		this.animationProps.height = height;
		this.animationProps.aspect = aspect;
		this.animationProps.needsRedraw = this.needsRedraw;
		this.animationProps.engineTime = Date.now() - this.animationProps.startTime;
		if (this.timeline) this.timeline.update(this.animationProps.engineTime);
		this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60);
		this.animationProps.tock++;
		this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
	}
	/** Wait for supplied device */
	async _initDevice() {
		this.device = await this.props.device;
		if (!this.device) throw new Error("No device provided");
		this.canvas = this.device.getDefaultCanvasContext().canvas || null;
	}
	_createInfoDiv() {
		if (this.canvas && this.props.onAddHTML) {
			const wrapperDiv = document.createElement("div");
			document.body.appendChild(wrapperDiv);
			wrapperDiv.style.position = "relative";
			const div = document.createElement("div");
			div.style.position = "absolute";
			div.style.left = "10px";
			div.style.bottom = "10px";
			div.style.width = "300px";
			div.style.background = "white";
			if (this.canvas instanceof HTMLCanvasElement) wrapperDiv.appendChild(this.canvas);
			wrapperDiv.appendChild(div);
			const html = this.props.onAddHTML(div);
			if (html) div.innerHTML = html;
		}
	}
	_getSizeAndAspect() {
		if (!this.device) return {
			width: 1,
			height: 1,
			aspect: 1
		};
		const [width, height] = this.device?.getDefaultCanvasContext().getDevicePixelSize() || [1, 1];
		let aspect = 1;
		const canvas$1 = this.device?.getDefaultCanvasContext().canvas;
		if (canvas$1 && canvas$1.clientHeight) aspect = canvas$1.clientWidth / canvas$1.clientHeight;
		else if (width > 0 && height > 0) aspect = width / height;
		return {
			width,
			height,
			aspect
		};
	}
	/** @deprecated Default viewport setup */
	_resizeViewport() {
		if (this.props.autoResizeViewport && this.device.gl) this.device.gl.viewport(0, 0, this.device.gl.drawingBufferWidth, this.device.gl.drawingBufferHeight);
	}
	_beginFrameTimers() {
		this.frameRate.timeEnd();
		this.frameRate.timeStart();
		this.cpuTime.timeStart();
	}
	_endFrameTimers() {
		this.cpuTime.timeEnd();
	}
	_startEventHandling() {
		if (this.canvas) {
			this.canvas.addEventListener("mousemove", this._onMousemove.bind(this));
			this.canvas.addEventListener("mouseleave", this._onMouseleave.bind(this));
		}
	}
	_onMousemove(event) {
		if (event instanceof MouseEvent) this._getAnimationProps()._mousePosition = [event.offsetX, event.offsetY];
	}
	_onMouseleave(event) {
		this._getAnimationProps()._mousePosition = null;
	}
};

//#endregion
//#region node_modules/@luma.gl/engine/dist/utils/uid.js
var uidCounters = {};
/**
* Returns a UID.
* @param id= - Identifier base name
* @return uid
**/
function uid(id = "id") {
	uidCounters[id] = uidCounters[id] || 1;
	return `${id}-${uidCounters[id]++}`;
}

//#endregion
//#region node_modules/@luma.gl/engine/dist/geometry/gpu-geometry.js
var GPUGeometry = class {
	id;
	userData = {};
	/** Determines how vertices are read from the 'vertex' attributes */
	topology;
	bufferLayout = [];
	vertexCount;
	indices;
	attributes;
	constructor(props) {
		this.id = props.id || uid("geometry");
		this.topology = props.topology;
		this.indices = props.indices || null;
		this.attributes = props.attributes;
		this.vertexCount = props.vertexCount;
		this.bufferLayout = props.bufferLayout || [];
		if (this.indices) {
			if (!(this.indices.usage & Buffer.INDEX)) throw new Error("Index buffer must have INDEX usage");
		}
	}
	destroy() {
		this.indices?.destroy();
		for (const attribute of Object.values(this.attributes)) attribute.destroy();
	}
	getVertexCount() {
		return this.vertexCount;
	}
	getAttributes() {
		return this.attributes;
	}
	getIndexes() {
		return this.indices || null;
	}
	_calculateVertexCount(positions) {
		return positions.byteLength / 12;
	}
};
function makeGPUGeometry(device, geometry) {
	if (geometry instanceof GPUGeometry) return geometry;
	const indices = getIndexBufferFromGeometry(device, geometry);
	const { attributes, bufferLayout } = getAttributeBuffersFromGeometry(device, geometry);
	return new GPUGeometry({
		topology: geometry.topology || "triangle-list",
		bufferLayout,
		vertexCount: geometry.vertexCount,
		indices,
		attributes
	});
}
function getIndexBufferFromGeometry(device, geometry) {
	if (!geometry.indices) return;
	const data = geometry.indices.value;
	return device.createBuffer({
		usage: Buffer.INDEX,
		data
	});
}
function getAttributeBuffersFromGeometry(device, geometry) {
	const bufferLayout = [];
	const attributes = {};
	for (const [attributeName, attribute] of Object.entries(geometry.attributes)) {
		let name = attributeName;
		switch (attributeName) {
			case "POSITION":
				name = "positions";
				break;
			case "NORMAL":
				name = "normals";
				break;
			case "TEXCOORD_0":
				name = "texCoords";
				break;
			case "COLOR_0":
				name = "colors";
				break;
		}
		if (attribute) {
			attributes[name] = device.createBuffer({
				data: attribute.value,
				id: `${attributeName}-buffer`
			});
			const { value, size, normalized } = attribute;
			bufferLayout.push({
				name,
				format: getVertexFormatFromAttribute(value, size, normalized)
			});
		}
	}
	return {
		attributes,
		bufferLayout,
		vertexCount: geometry._calculateVertexCount(geometry.attributes, geometry.indices)
	};
}

//#endregion
//#region node_modules/@luma.gl/engine/dist/factories/pipeline-factory.js
/**
* Efficiently creates / caches pipelines
*/
var PipelineFactory = class PipelineFactory {
	static defaultProps = { ...RenderPipeline.defaultProps };
	/** Get the singleton default pipeline factory for the specified device */
	static getDefaultPipelineFactory(device) {
		device._lumaData["defaultPipelineFactory"] = device._lumaData["defaultPipelineFactory"] || new PipelineFactory(device);
		return device._lumaData["defaultPipelineFactory"];
	}
	device;
	cachingEnabled;
	destroyPolicy;
	debug;
	_hashCounter = 0;
	_hashes = {};
	_renderPipelineCache = {};
	_computePipelineCache = {};
	get [Symbol.toStringTag]() {
		return "PipelineFactory";
	}
	toString() {
		return `PipelineFactory(${this.device.id})`;
	}
	constructor(device) {
		this.device = device;
		this.cachingEnabled = device.props._cachePipelines;
		this.destroyPolicy = device.props._cacheDestroyPolicy;
		this.debug = device.props.debugFactories;
	}
	/** Return a RenderPipeline matching supplied props. Reuses an equivalent pipeline if already created. */
	createRenderPipeline(props) {
		if (!this.cachingEnabled) return this.device.createRenderPipeline(props);
		const allProps = {
			...RenderPipeline.defaultProps,
			...props
		};
		const cache = this._renderPipelineCache;
		const hash = this._hashRenderPipeline(allProps);
		let pipeline = cache[hash]?.pipeline;
		if (!pipeline) {
			pipeline = this.device.createRenderPipeline({
				...allProps,
				id: allProps.id ? `${allProps.id}-cached` : uid("unnamed-cached")
			});
			pipeline.hash = hash;
			cache[hash] = {
				pipeline,
				useCount: 1
			};
			if (this.debug) log.log(3, `${this}: ${pipeline} created, count=${cache[hash].useCount}`)();
		} else {
			cache[hash].useCount++;
			if (this.debug) log.log(3, `${this}: ${cache[hash].pipeline} reused, count=${cache[hash].useCount}, (id=${props.id})`)();
		}
		return pipeline;
	}
	/** Return a ComputePipeline matching supplied props. Reuses an equivalent pipeline if already created. */
	createComputePipeline(props) {
		if (!this.cachingEnabled) return this.device.createComputePipeline(props);
		const allProps = {
			...ComputePipeline.defaultProps,
			...props
		};
		const cache = this._computePipelineCache;
		const hash = this._hashComputePipeline(allProps);
		let pipeline = cache[hash]?.pipeline;
		if (!pipeline) {
			pipeline = this.device.createComputePipeline({
				...allProps,
				id: allProps.id ? `${allProps.id}-cached` : void 0
			});
			pipeline.hash = hash;
			cache[hash] = {
				pipeline,
				useCount: 1
			};
			if (this.debug) log.log(3, `${this}: ${pipeline} created, count=${cache[hash].useCount}`)();
		} else {
			cache[hash].useCount++;
			if (this.debug) log.log(3, `${this}: ${cache[hash].pipeline} reused, count=${cache[hash].useCount}, (id=${props.id})`)();
		}
		return pipeline;
	}
	release(pipeline) {
		if (!this.cachingEnabled) {
			pipeline.destroy();
			return;
		}
		const cache = this._getCache(pipeline);
		const hash = pipeline.hash;
		cache[hash].useCount--;
		if (cache[hash].useCount === 0) {
			this._destroyPipeline(pipeline);
			if (this.debug) log.log(3, `${this}: ${pipeline} released and destroyed`)();
		} else if (cache[hash].useCount < 0) {
			log.error(`${this}: ${pipeline} released, useCount < 0, resetting`)();
			cache[hash].useCount = 0;
		} else if (this.debug) log.log(3, `${this}: ${pipeline} released, count=${cache[hash].useCount}`)();
	}
	/** Destroy a cached pipeline, removing it from the cache (depending on destroy policy) */
	_destroyPipeline(pipeline) {
		const cache = this._getCache(pipeline);
		switch (this.destroyPolicy) {
			case "never": return false;
			case "unused":
				delete cache[pipeline.hash];
				pipeline.destroy();
				return true;
		}
	}
	/** Get the appropriate cache for the type of pipeline */
	_getCache(pipeline) {
		let cache;
		if (pipeline instanceof ComputePipeline) cache = this._computePipelineCache;
		if (pipeline instanceof RenderPipeline) cache = this._renderPipelineCache;
		if (!cache) throw new Error(`${this}`);
		if (!cache[pipeline.hash]) throw new Error(`${this}: ${pipeline} matched incorrect entry`);
		return cache;
	}
	/** Calculate a hash based on all the inputs for a compute pipeline */
	_hashComputePipeline(props) {
		const { type } = this.device;
		return `${type}/C/${this._getHash(props.shader.source)}`;
	}
	/** Calculate a hash based on all the inputs for a render pipeline */
	_hashRenderPipeline(props) {
		const vsHash = props.vs ? this._getHash(props.vs.source) : 0;
		const fsHash = props.fs ? this._getHash(props.fs.source) : 0;
		const varyingHash = "-";
		const bufferLayoutHash = this._getHash(JSON.stringify(props.bufferLayout));
		const { type } = this.device;
		switch (type) {
			case "webgl": return `${type}/R/${vsHash}/${fsHash}V${varyingHash}BL${bufferLayoutHash}`;
			case "webgpu":
			default:
				const parameterHash = this._getHash(JSON.stringify(props.parameters));
				return `${type}/R/${vsHash}/${fsHash}V${varyingHash}T${props.topology}P${parameterHash}BL${bufferLayoutHash}`;
		}
	}
	_getHash(key) {
		if (this._hashes[key] === void 0) this._hashes[key] = this._hashCounter++;
		return this._hashes[key];
	}
};

//#endregion
//#region node_modules/@luma.gl/engine/dist/factories/shader-factory.js
/** Manages a cached pool of Shaders for reuse. */
var ShaderFactory = class ShaderFactory {
	static defaultProps = { ...Shader.defaultProps };
	/** Returns the default ShaderFactory for the given {@link Device}, creating one if necessary. */
	static getDefaultShaderFactory(device) {
		device._lumaData["defaultShaderFactory"] ||= new ShaderFactory(device);
		return device._lumaData["defaultShaderFactory"];
	}
	device;
	cachingEnabled;
	destroyPolicy;
	debug;
	_cache = {};
	get [Symbol.toStringTag]() {
		return "ShaderFactory";
	}
	toString() {
		return `${this[Symbol.toStringTag]}(${this.device.id})`;
	}
	/** @internal */
	constructor(device) {
		this.device = device;
		this.cachingEnabled = device.props._cacheShaders;
		this.destroyPolicy = device.props._cacheDestroyPolicy;
		this.debug = true;
	}
	/** Requests a {@link Shader} from the cache, creating a new Shader only if necessary. */
	createShader(props) {
		if (!this.cachingEnabled) return this.device.createShader(props);
		const key = this._hashShader(props);
		let cacheEntry = this._cache[key];
		if (!cacheEntry) {
			const shader = this.device.createShader({
				...props,
				id: props.id ? `${props.id}-cached` : void 0
			});
			this._cache[key] = cacheEntry = {
				shader,
				useCount: 1
			};
			if (this.debug) log.log(3, `${this}: Created new shader ${shader.id}`)();
		} else {
			cacheEntry.useCount++;
			if (this.debug) log.log(3, `${this}: Reusing shader ${cacheEntry.shader.id} count=${cacheEntry.useCount}`)();
		}
		return cacheEntry.shader;
	}
	/** Releases a previously-requested {@link Shader}, destroying it if no users remain. */
	release(shader) {
		if (!this.cachingEnabled) {
			shader.destroy();
			return;
		}
		const key = this._hashShader(shader);
		const cacheEntry = this._cache[key];
		if (cacheEntry) {
			cacheEntry.useCount--;
			if (cacheEntry.useCount === 0) {
				if (this.destroyPolicy === "unused") {
					delete this._cache[key];
					cacheEntry.shader.destroy();
					if (this.debug) log.log(3, `${this}: Releasing shader ${shader.id}, destroyed`)();
				}
			} else if (cacheEntry.useCount < 0) throw new Error(`ShaderFactory: Shader ${shader.id} released too many times`);
			else if (this.debug) log.log(3, `${this}: Releasing shader ${shader.id} count=${cacheEntry.useCount}`)();
		}
	}
	_hashShader(value) {
		return `${value.stage}:${value.source}`;
	}
};

//#endregion
//#region node_modules/@luma.gl/engine/dist/debug/debug-shader-layout.js
/**
* Extracts a table suitable for `console.table()` from a shader layout to assist in debugging.
* @param layout shader layout
* @param name app should provide the most meaningful name, usually the model or pipeline name / id.
* @returns
*/
function getDebugTableForShaderLayout(layout, name) {
	const table = {};
	const header = "Values";
	if (layout.attributes.length === 0 && !layout.varyings?.length) return { "No attributes or varyings": { [header]: "N/A" } };
	for (const attributeDeclaration of layout.attributes) if (attributeDeclaration) {
		const glslDeclaration = `${attributeDeclaration.location} ${attributeDeclaration.name}: ${attributeDeclaration.type}`;
		table[`in ${glslDeclaration}`] = { [header]: attributeDeclaration.stepMode || "vertex" };
	}
	for (const varyingDeclaration of layout.varyings || []) {
		const glslDeclaration = `${varyingDeclaration.location} ${varyingDeclaration.name}`;
		table[`out ${glslDeclaration}`] = { [header]: JSON.stringify(varyingDeclaration) };
	}
	return table;
}

//#endregion
//#region node_modules/@luma.gl/engine/dist/debug/debug-framebuffer.js
/** Only works with 1st device? */
var canvas = null;
var ctx = null;
/** Debug utility to draw FBO contents onto screen */
function debugFramebuffer(fbo, { id, minimap, opaque, top = "0", left = "0", rgbaScale = 1 }) {
	if (!canvas) {
		canvas = document.createElement("canvas");
		canvas.id = id;
		canvas.title = id;
		canvas.style.zIndex = "100";
		canvas.style.position = "absolute";
		canvas.style.top = top;
		canvas.style.left = left;
		canvas.style.border = "blue 5px solid";
		canvas.style.transform = "scaleY(-1)";
		document.body.appendChild(canvas);
		ctx = canvas.getContext("2d");
	}
	if (canvas.width !== fbo.width || canvas.height !== fbo.height) {
		canvas.width = fbo.width / 2;
		canvas.height = fbo.height / 2;
		canvas.style.width = "400px";
		canvas.style.height = "400px";
	}
	const color = fbo.device.readPixelsToArrayWebGL(fbo);
	const imageData = ctx?.createImageData(fbo.width, fbo.height);
	if (imageData) {
		const offset = 0;
		for (let i$1 = 0; i$1 < color.length; i$1 += 4) {
			imageData.data[offset + i$1 + 0] = color[i$1 + 0] * rgbaScale;
			imageData.data[offset + i$1 + 1] = color[i$1 + 1] * rgbaScale;
			imageData.data[offset + i$1 + 2] = color[i$1 + 2] * rgbaScale;
			imageData.data[offset + i$1 + 3] = opaque ? 255 : color[i$1 + 3] * rgbaScale;
		}
		ctx?.putImageData(imageData, 0, 0);
	}
}

//#endregion
//#region node_modules/@luma.gl/engine/dist/utils/deep-equal.js
/**
* Fast partial deep equal for prop.
*
* @param a Prop
* @param b Prop to compare against `a`
* @param depth Depth to which to recurse in nested Objects/Arrays. Use 0 (default) for shallow comparison, -1 for infinite depth
*/
function deepEqual$1(a$1, b$1, depth) {
	if (a$1 === b$1) return true;
	if (!depth || !a$1 || !b$1) return false;
	if (Array.isArray(a$1)) {
		if (!Array.isArray(b$1) || a$1.length !== b$1.length) return false;
		for (let i$1 = 0; i$1 < a$1.length; i$1++) if (!deepEqual$1(a$1[i$1], b$1[i$1], depth - 1)) return false;
		return true;
	}
	if (Array.isArray(b$1)) return false;
	if (typeof a$1 === "object" && typeof b$1 === "object") {
		const aKeys = Object.keys(a$1);
		const bKeys = Object.keys(b$1);
		if (aKeys.length !== bKeys.length) return false;
		for (const key of aKeys) {
			if (!b$1.hasOwnProperty(key)) return false;
			if (!deepEqual$1(a$1[key], b$1[key], depth - 1)) return false;
		}
		return true;
	}
	return false;
}

//#endregion
//#region node_modules/@luma.gl/engine/dist/utils/buffer-layout-helper.js
/** BufferLayoutHelper is a helper class that should not be used directly by applications */
var BufferLayoutHelper = class {
	bufferLayouts;
	constructor(bufferLayouts) {
		this.bufferLayouts = bufferLayouts;
	}
	getBufferLayout(name) {
		return this.bufferLayouts.find((layout) => layout.name === name) || null;
	}
	/** Get attribute names from a BufferLayout */
	getAttributeNamesForBuffer(bufferLayout) {
		return bufferLayout.attributes ? bufferLayout.attributes?.map((layout) => layout.attribute) : [bufferLayout.name];
	}
	mergeBufferLayouts(bufferLayouts1, bufferLayouts2) {
		const mergedLayouts = [...bufferLayouts1];
		for (const attribute of bufferLayouts2) {
			const index = mergedLayouts.findIndex((attribute2) => attribute2.name === attribute.name);
			if (index < 0) mergedLayouts.push(attribute);
			else mergedLayouts[index] = attribute;
		}
		return mergedLayouts;
	}
	getBufferIndex(bufferName) {
		const bufferIndex = this.bufferLayouts.findIndex((layout) => layout.name === bufferName);
		if (bufferIndex === -1) log.warn(`BufferLayout: Missing buffer for "${bufferName}".`)();
		return bufferIndex;
	}
};

//#endregion
//#region node_modules/@luma.gl/engine/dist/utils/buffer-layout-order.js
function sortedBufferLayoutByShaderSourceLocations(shaderLayout, bufferLayout) {
	const shaderLayoutMap = Object.fromEntries(shaderLayout.attributes.map((attr) => [attr.name, attr.location]));
	const sortedLayout = bufferLayout.slice();
	sortedLayout.sort((a$1, b$1) => {
		const attributeNamesA = a$1.attributes ? a$1.attributes.map((attr) => attr.attribute) : [a$1.name];
		const attributeNamesB = b$1.attributes ? b$1.attributes.map((attr) => attr.attribute) : [b$1.name];
		return Math.min(...attributeNamesA.map((name) => shaderLayoutMap[name])) - Math.min(...attributeNamesB.map((name) => shaderLayoutMap[name]));
	});
	return sortedLayout;
}

//#endregion
//#region node_modules/@math.gl/types/dist/is-array.js
/**
* Check is an array is a typed array
* @param value value to be tested
* @returns input with type narrowed to TypedArray, or null
*/
function isTypedArray(value) {
	return ArrayBuffer.isView(value) && !(value instanceof DataView);
}
/**
* Check is an array is an array of numbers)
* @param value value to be tested
* @returns input with type narrowed to NumberArray, or null
*/
function isNumberArray(value) {
	if (Array.isArray(value)) return value.length === 0 || typeof value[0] === "number";
	return false;
}
/**
* Check is an array is a numeric array (typed array or array of numbers)
* @param value value to be tested
* @returns input with type narrowed to NumericArray, or null
*/
function isNumericArray(value) {
	return isTypedArray(value) || isNumberArray(value);
}

//#endregion
//#region node_modules/@luma.gl/engine/dist/model/split-uniforms-and-bindings.js
function isUniformValue(value) {
	return isNumericArray(value) || typeof value === "number" || typeof value === "boolean";
}
function splitUniformsAndBindings(uniforms) {
	const result = {
		bindings: {},
		uniforms: {}
	};
	Object.keys(uniforms).forEach((name) => {
		const uniform = uniforms[name];
		if (isUniformValue(uniform)) result.uniforms[name] = uniform;
		else result.bindings[name] = uniform;
	});
	return result;
}

//#endregion
//#region node_modules/@luma.gl/engine/dist/shader-inputs.js
/**
* ShaderInputs holds uniform and binding values for one or more shader modules,
* - It can generate binary data for any uniform buffer
* - It can manage a uniform buffer for each block
* - It can update managed uniform buffers with a single call
* - It performs some book keeping on what has changed to minimize unnecessary writes to uniform buffers.
*/
var ShaderInputs = class {
	options = { disableWarnings: false };
	/**
	* The map of modules
	* @todo should should this include the resolved dependencies?
	*/
	modules;
	/** Stores the uniform values for each module */
	moduleUniforms;
	/** Stores the uniform bindings for each module  */
	moduleBindings;
	/** Tracks if uniforms have changed */
	/**
	* Create a new UniformStore instance
	* @param modules
	*/
	constructor(modules, options) {
		Object.assign(this.options, options);
		const resolvedModules = getShaderModuleDependencies(Object.values(modules).filter((module) => module.dependencies));
		for (const resolvedModule of resolvedModules) modules[resolvedModule.name] = resolvedModule;
		log.log(1, "Creating ShaderInputs with modules", Object.keys(modules))();
		this.modules = modules;
		this.moduleUniforms = {};
		this.moduleBindings = {};
		for (const [name, module] of Object.entries(modules)) {
			this._addModule(module);
			if (module.name && name !== module.name && !this.options.disableWarnings) log.warn(`Module name: ${name} vs ${module.name}`)();
		}
	}
	/** Destroy */
	destroy() {}
	/**
	* Set module props
	*/
	setProps(props) {
		for (const name of Object.keys(props)) {
			const moduleName = name;
			const moduleProps = props[moduleName] || {};
			const module = this.modules[moduleName];
			if (!module) {
				if (!this.options.disableWarnings) log.warn(`Module ${name} not found`)();
				continue;
			}
			const oldUniforms = this.moduleUniforms[moduleName];
			const oldBindings = this.moduleBindings[moduleName];
			const { uniforms, bindings } = splitUniformsAndBindings(module.getUniforms?.(moduleProps, oldUniforms) || moduleProps);
			this.moduleUniforms[moduleName] = {
				...oldUniforms,
				...uniforms
			};
			this.moduleBindings[moduleName] = {
				...oldBindings,
				...bindings
			};
		}
	}
	/**
	* Return the map of modules
	* @todo should should this include the resolved dependencies?
	*/
	getModules() {
		return Object.values(this.modules);
	}
	/** Get all uniform values for all modules */
	getUniformValues() {
		return this.moduleUniforms;
	}
	/** Merges all bindings for the shader (from the various modules) */
	getBindingValues() {
		const bindings = {};
		for (const moduleBindings of Object.values(this.moduleBindings)) Object.assign(bindings, moduleBindings);
		return bindings;
	}
	/** Return a debug table that can be used for console.table() or log.table() */
	getDebugTable() {
		const table = {};
		for (const [moduleName, module] of Object.entries(this.moduleUniforms)) for (const [key, value] of Object.entries(module)) table[`${moduleName}.${key}`] = {
			type: this.modules[moduleName].uniformTypes?.[key],
			value: String(value)
		};
		return table;
	}
	_addModule(module) {
		const moduleName = module.name;
		this.moduleUniforms[moduleName] = module.defaultUniforms || {};
		this.moduleBindings[moduleName] = {};
	}
};

//#endregion
//#region node_modules/@luma.gl/engine/dist/application-utils/load-file.js
var pathPrefix = "";
/**
* Loads ImageBitmap asynchronously. Respects setPathPrefix.
* image.crossOrigin can be set via opts.crossOrigin, default to 'anonymous'
* @returns a promise tracking the load
*/
async function loadImageBitmap(url, opts) {
	const image = new Image();
	image.crossOrigin = opts?.crossOrigin || "anonymous";
	image.src = url.startsWith("http") ? url : pathPrefix + url;
	await image.decode();
	return opts ? await createImageBitmap(image, opts) : await createImageBitmap(image);
}

//#endregion
//#region node_modules/@luma.gl/engine/dist/async-texture/async-texture.js
const TextureCubeFaces = [
	"+X",
	"-X",
	"+Y",
	"-Y",
	"+Z",
	"-Z"
];
const CubeFaces = [
	"+X",
	"-X",
	"+Y",
	"-Y",
	"+Z",
	"-Z"
];
/**
* It is very convenient to be able to initialize textures with promises
* This can add considerable complexity to the Texture class, and doesn't
* fit with the immutable nature of WebGPU resources.
* Instead, luma.gl offers async textures as a separate class.
*/
var AsyncTexture = class AsyncTexture {
	device;
	id;
	props;
	texture;
	sampler;
	view;
	ready;
	isReady = false;
	destroyed = false;
	resolveReady = () => {};
	rejectReady = () => {};
	get [Symbol.toStringTag]() {
		return "AsyncTexture";
	}
	toString() {
		return `AsyncTexture:"${this.id}"(${this.isReady ? "ready" : "loading"})`;
	}
	constructor(device, props) {
		this.device = device;
		const id = uid("async-texture");
		this.props = {
			...AsyncTexture.defaultProps,
			id,
			...props
		};
		this.id = this.props.id;
		props = { ...props };
		if (typeof props?.data === "string" && props.dimension === "2d") props.data = loadImageBitmap(props.data);
		if (props.mipmaps) props.mipLevels = "auto";
		this.ready = new Promise((resolve, reject) => {
			this.resolveReady = () => {
				this.isReady = true;
				resolve();
			};
			this.rejectReady = reject;
		});
		this.initAsync(props);
	}
	async initAsync(props) {
		const asyncData = props.data;
		const data = await awaitAllPromises(asyncData).then(void 0, this.rejectReady);
		if (this.destroyed) return;
		const size = this.props.width && this.props.height ? {
			width: this.props.width,
			height: this.props.height
		} : this.getTextureDataSize(data);
		if (!size) throw new Error("Texture size could not be determined");
		const syncProps = {
			...size,
			...props,
			data: void 0,
			mipLevels: 1
		};
		const maxMips = this.device.getMipLevelCount(syncProps.width, syncProps.height);
		syncProps.mipLevels = this.props.mipLevels === "auto" ? maxMips : Math.min(maxMips, this.props.mipLevels);
		this.texture = this.device.createTexture(syncProps);
		this.sampler = this.texture.sampler;
		this.view = this.texture.view;
		if (props.data) switch (this.props.dimension) {
			case "1d":
				this._setTexture1DData(this.texture, data);
				break;
			case "2d":
				this._setTexture2DData(data);
				break;
			case "3d":
				this._setTexture3DData(this.texture, data);
				break;
			case "2d-array":
				this._setTextureArrayData(this.texture, data);
				break;
			case "cube":
				this._setTextureCubeData(this.texture, data);
				break;
			case "cube-array":
				this._setTextureCubeArrayData(this.texture, data);
				break;
		}
		if (this.props.mipmaps) this.generateMipmaps();
		log.info(1, `${this} loaded`);
		this.resolveReady();
	}
	destroy() {
		if (this.texture) {
			this.texture.destroy();
			this.texture = null;
		}
		this.destroyed = true;
	}
	generateMipmaps() {
		this.texture.generateMipmapsWebGL();
	}
	/** Set sampler or create and set new Sampler from SamplerProps */
	setSampler(sampler = {}) {
		this.texture.setSampler(sampler instanceof Sampler ? sampler : this.device.createSampler(sampler));
	}
	/**
	* Textures are immutable and cannot be resized after creation,
	* but we can create a similar texture with the same parameters but a new size.
	* @note Does not copy contents of the texture
	* @note Mipmaps may need to be regenerated after resizing / setting new data
	* @todo Abort pending promise and create a texture with the new size?
	*/
	resize(size) {
		if (!this.isReady) throw new Error("Cannot resize texture before it is ready");
		if (size.width === this.texture.width && size.height === this.texture.height) return false;
		if (this.texture) {
			const texture = this.texture;
			this.texture = texture.clone(size);
			texture.destroy();
		}
		return true;
	}
	/** Check if texture data is a typed array */
	isTextureLevelData(data) {
		const typedArray = data?.data;
		return ArrayBuffer.isView(typedArray);
	}
	/** Get the size of the texture described by the provided TextureData */
	getTextureDataSize(data) {
		if (!data) return null;
		if (ArrayBuffer.isView(data)) return null;
		if (Array.isArray(data)) return this.getTextureDataSize(data[0]);
		if (this.device.isExternalImage(data)) return this.device.getExternalImageSize(data);
		if (data && typeof data === "object" && data.constructor === Object) {
			const untypedData = Object.values(data)[0];
			return {
				width: untypedData.width,
				height: untypedData.height
			};
		}
		throw new Error("texture size deduction failed");
	}
	/** Convert luma.gl cubemap face constants to depth index */
	getCubeFaceDepth(face) {
		switch (face) {
			case "+X": return 0;
			case "-X": return 1;
			case "+Y": return 2;
			case "-Y": return 3;
			case "+Z": return 4;
			case "-Z": return 5;
			default: throw new Error(face);
		}
	}
	setTextureData(data) {}
	/** Experimental: Set multiple mip levels */
	_setTexture1DData(texture, data) {
		throw new Error("setTexture1DData not supported in WebGL.");
	}
	/** Experimental: Set multiple mip levels */
	_setTexture2DData(lodData, depth = 0) {
		if (!this.texture) throw new Error("Texture not initialized");
		const lodArray = this._normalizeTextureData(lodData);
		if (lodArray.length > 1 && this.props.mipmaps !== false) log.warn(`Texture ${this.id} mipmap and multiple LODs.`)();
		for (let mipLevel = 0; mipLevel < lodArray.length; mipLevel++) {
			const imageData = lodArray[mipLevel];
			if (this.device.isExternalImage(imageData)) this.texture.copyExternalImage({
				image: imageData,
				depth,
				mipLevel,
				flipY: true
			});
			else this.texture.copyImageData({
				data: imageData.data,
				mipLevel
			});
		}
	}
	/**
	* Experimental: Sets 3D texture data: multiple depth slices, multiple mip levels
	* @param data
	*/
	_setTexture3DData(texture, data) {
		if (this.texture?.props.dimension !== "3d") throw new Error(this.id);
		for (let depth = 0; depth < data.length; depth++) this._setTexture2DData(data[depth], depth);
	}
	/**
	* Experimental: Set Cube texture data, multiple faces, multiple mip levels
	* @todo - could support TextureCubeArray with depth
	* @param data
	* @param index
	*/
	_setTextureCubeData(texture, data) {
		if (this.texture?.props.dimension !== "cube") throw new Error(this.id);
		for (const [face, faceData] of Object.entries(data)) {
			const faceDepth = CubeFaces.indexOf(face);
			this._setTexture2DData(faceData, faceDepth);
		}
	}
	/**
	* Experimental: Sets texture array data, multiple levels, multiple depth slices
	* @param data
	*/
	_setTextureArrayData(texture, data) {
		if (this.texture?.props.dimension !== "2d-array") throw new Error(this.id);
		for (let depth = 0; depth < data.length; depth++) this._setTexture2DData(data[depth], depth);
	}
	/**
	* Experimental: Sets texture cube array, multiple faces, multiple levels, multiple mip levels
	* @param data
	*/
	_setTextureCubeArrayData(texture, data) {
		throw new Error("setTextureCubeArrayData not supported in WebGL2.");
	}
	/** Experimental */
	_setTextureCubeFaceData(texture, lodData, face, depth = 0) {
		if (Array.isArray(lodData) && lodData.length > 1 && this.props.mipmaps !== false) log.warn(`${this.id} has mipmap and multiple LODs.`)();
		const faceDepth = TextureCubeFaces.indexOf(face);
		this._setTexture2DData(lodData, faceDepth);
	}
	/**
	* Normalize TextureData to an array of TextureImageData / ExternalImages
	* @param data
	* @param options
	* @returns array of TextureImageData / ExternalImages
	*/
	_normalizeTextureData(data) {
		const options = this.texture;
		let mipLevelArray;
		if (ArrayBuffer.isView(data)) mipLevelArray = [{
			data,
			width: options.width,
			height: options.height
		}];
		else if (!Array.isArray(data)) mipLevelArray = [data];
		else mipLevelArray = data;
		return mipLevelArray;
	}
	static defaultProps = {
		...Texture.defaultProps,
		data: null,
		mipmaps: false
	};
};
/** Resolve all promises in a nested data structure */
async function awaitAllPromises(x$1) {
	x$1 = await x$1;
	if (Array.isArray(x$1)) return await Promise.all(x$1.map(awaitAllPromises));
	if (x$1 && typeof x$1 === "object" && x$1.constructor === Object) {
		const object = x$1;
		const values = await Promise.all(Object.values(object));
		const keys = Object.keys(object);
		const resolvedObject = {};
		for (let i$1 = 0; i$1 < keys.length; i$1++) resolvedObject[keys[i$1]] = values[i$1];
		return resolvedObject;
	}
	return x$1;
}

//#endregion
//#region node_modules/@luma.gl/engine/dist/model/model.js
var LOG_DRAW_PRIORITY = 2;
var LOG_DRAW_TIMEOUT = 1e4;
/**
* v9 Model API
* A model
* - automatically reuses pipelines (programs) when possible
* - automatically rebuilds pipelines if necessary to accommodate changed settings
* shadertools integration
* - accepts modules and performs shader transpilation
*/
var Model = class Model {
	static defaultProps = {
		...RenderPipeline.defaultProps,
		source: void 0,
		vs: null,
		fs: null,
		id: "unnamed",
		handle: void 0,
		userData: {},
		defines: {},
		modules: [],
		geometry: null,
		indexBuffer: null,
		attributes: {},
		constantAttributes: {},
		varyings: [],
		isInstanced: void 0,
		instanceCount: 0,
		vertexCount: 0,
		shaderInputs: void 0,
		pipelineFactory: void 0,
		shaderFactory: void 0,
		transformFeedback: void 0,
		shaderAssembler: ShaderAssembler.getDefaultShaderAssembler(),
		debugShaders: void 0,
		disableWarnings: void 0
	};
	device;
	id;
	source;
	vs;
	fs;
	pipelineFactory;
	shaderFactory;
	userData = {};
	/** The render pipeline GPU parameters, depth testing etc */
	parameters;
	/** The primitive topology */
	topology;
	/** Buffer layout */
	bufferLayout;
	/** Use instanced rendering */
	isInstanced = void 0;
	/** instance count. `undefined` means not instanced */
	instanceCount = 0;
	/** Vertex count */
	vertexCount;
	/** Index buffer */
	indexBuffer = null;
	/** Buffer-valued attributes */
	bufferAttributes = {};
	/** Constant-valued attributes */
	constantAttributes = {};
	/** Bindings (textures, samplers, uniform buffers) */
	bindings = {};
	/**
	* VertexArray
	* @note not implemented: if bufferLayout is updated, vertex array has to be rebuilt!
	* @todo - allow application to define multiple vertex arrays?
	* */
	vertexArray;
	/** TransformFeedback, WebGL 2 only. */
	transformFeedback = null;
	/** The underlying GPU "program". @note May be recreated if parameters change */
	pipeline;
	/** ShaderInputs instance */
	shaderInputs;
	_uniformStore;
	_attributeInfos = {};
	_gpuGeometry = null;
	props;
	_pipelineNeedsUpdate = "newly created";
	_needsRedraw = "initializing";
	_destroyed = false;
	/** "Time" of last draw. Monotonically increasing timestamp */
	_lastDrawTimestamp = -1;
	get [Symbol.toStringTag]() {
		return "Model";
	}
	toString() {
		return `Model(${this.id})`;
	}
	constructor(device, props) {
		this.props = {
			...Model.defaultProps,
			...props
		};
		props = this.props;
		this.id = props.id || uid("model");
		this.device = device;
		Object.assign(this.userData, props.userData);
		const moduleMap = Object.fromEntries(this.props.modules?.map((module) => [module.name, module]) || []);
		const shaderInputs = props.shaderInputs || new ShaderInputs(moduleMap, { disableWarnings: this.props.disableWarnings });
		this.setShaderInputs(shaderInputs);
		const platformInfo = getPlatformInfo(device);
		const modules = (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || [];
		if (this.device.type === "webgpu" && this.props.source) {
			const { source: source$2, getUniforms: getUniforms$3 } = this.props.shaderAssembler.assembleWGSLShader({
				platformInfo,
				...this.props,
				modules
			});
			this.source = source$2;
			this._getModuleUniforms = getUniforms$3;
			this.props.shaderLayout ||= getShaderLayoutFromWGSL(this.source);
		} else {
			const { vs: vs$6, fs: fs$4, getUniforms: getUniforms$3 } = this.props.shaderAssembler.assembleGLSLShaderPair({
				platformInfo,
				...this.props,
				modules
			});
			this.vs = vs$6;
			this.fs = fs$4;
			this._getModuleUniforms = getUniforms$3;
		}
		this.vertexCount = this.props.vertexCount;
		this.instanceCount = this.props.instanceCount;
		this.topology = this.props.topology;
		this.bufferLayout = this.props.bufferLayout;
		this.parameters = this.props.parameters;
		if (props.geometry) this.setGeometry(props.geometry);
		this.pipelineFactory = props.pipelineFactory || PipelineFactory.getDefaultPipelineFactory(this.device);
		this.shaderFactory = props.shaderFactory || ShaderFactory.getDefaultShaderFactory(this.device);
		this.pipeline = this._updatePipeline();
		this.vertexArray = device.createVertexArray({
			shaderLayout: this.pipeline.shaderLayout,
			bufferLayout: this.pipeline.bufferLayout
		});
		if (this._gpuGeometry) this._setGeometryAttributes(this._gpuGeometry);
		if ("isInstanced" in props) this.isInstanced = props.isInstanced;
		if (props.instanceCount) this.setInstanceCount(props.instanceCount);
		if (props.vertexCount) this.setVertexCount(props.vertexCount);
		if (props.indexBuffer) this.setIndexBuffer(props.indexBuffer);
		if (props.attributes) this.setAttributes(props.attributes);
		if (props.constantAttributes) this.setConstantAttributes(props.constantAttributes);
		if (props.bindings) this.setBindings(props.bindings);
		if (props.transformFeedback) this.transformFeedback = props.transformFeedback;
		Object.seal(this);
	}
	destroy() {
		if (!this._destroyed) {
			this.pipelineFactory.release(this.pipeline);
			this.shaderFactory.release(this.pipeline.vs);
			if (this.pipeline.fs) this.shaderFactory.release(this.pipeline.fs);
			this._uniformStore.destroy();
			this._gpuGeometry?.destroy();
			this._destroyed = true;
		}
	}
	/** Query redraw status. Clears the status. */
	needsRedraw() {
		if (this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp) this.setNeedsRedraw("contents of bound textures or buffers updated");
		const needsRedraw = this._needsRedraw;
		this._needsRedraw = false;
		return needsRedraw;
	}
	/** Mark the model as needing a redraw */
	setNeedsRedraw(reason) {
		this._needsRedraw ||= reason;
	}
	predraw() {
		this.updateShaderInputs();
		this.pipeline = this._updatePipeline();
	}
	draw(renderPass) {
		const loadingBinding = this._areBindingsLoading();
		if (loadingBinding) {
			log.info(LOG_DRAW_PRIORITY, `>>> DRAWING ABORTED ${this.id}: ${loadingBinding} not loaded`)();
			return false;
		}
		try {
			renderPass.pushDebugGroup(`${this}.predraw(${renderPass})`);
			this.predraw();
		} finally {
			renderPass.popDebugGroup();
		}
		let drawSuccess;
		try {
			renderPass.pushDebugGroup(`${this}.draw(${renderPass})`);
			this._logDrawCallStart();
			this.pipeline = this._updatePipeline();
			const syncBindings = this._getBindings();
			this.pipeline.setBindings(syncBindings, { disableWarnings: this.props.disableWarnings });
			const { indexBuffer } = this.vertexArray;
			const indexCount = indexBuffer ? indexBuffer.byteLength / (indexBuffer.indexType === "uint32" ? 4 : 2) : void 0;
			drawSuccess = this.pipeline.draw({
				renderPass,
				vertexArray: this.vertexArray,
				isInstanced: this.isInstanced,
				vertexCount: this.vertexCount,
				instanceCount: this.instanceCount,
				indexCount,
				transformFeedback: this.transformFeedback || void 0,
				parameters: this.parameters,
				topology: this.topology
			});
		} finally {
			renderPass.popDebugGroup();
			this._logDrawCallEnd();
		}
		this._logFramebuffer(renderPass);
		if (drawSuccess) {
			this._lastDrawTimestamp = this.device.timestamp;
			this._needsRedraw = false;
		} else this._needsRedraw = "waiting for resource initialization";
		return drawSuccess;
	}
	/**
	* Updates the optional geometry
	* Geometry, set topology and bufferLayout
	* @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
	*/
	setGeometry(geometry) {
		this._gpuGeometry?.destroy();
		const gpuGeometry = geometry && makeGPUGeometry(this.device, geometry);
		if (gpuGeometry) {
			this.setTopology(gpuGeometry.topology || "triangle-list");
			this.bufferLayout = new BufferLayoutHelper(this.bufferLayout).mergeBufferLayouts(gpuGeometry.bufferLayout, this.bufferLayout);
			if (this.vertexArray) this._setGeometryAttributes(gpuGeometry);
		}
		this._gpuGeometry = gpuGeometry;
	}
	/**
	* Updates the primitive topology ('triangle-list', 'triangle-strip' etc).
	* @note Triggers a pipeline rebuild / pipeline cache fetch on WebGPU
	*/
	setTopology(topology) {
		if (topology !== this.topology) {
			this.topology = topology;
			this._setPipelineNeedsUpdate("topology");
		}
	}
	/**
	* Updates the buffer layout.
	* @note Triggers a pipeline rebuild / pipeline cache fetch
	*/
	setBufferLayout(bufferLayout) {
		const bufferLayoutHelper = new BufferLayoutHelper(this.bufferLayout);
		this.bufferLayout = this._gpuGeometry ? bufferLayoutHelper.mergeBufferLayouts(bufferLayout, this._gpuGeometry.bufferLayout) : bufferLayout;
		this._setPipelineNeedsUpdate("bufferLayout");
		this.pipeline = this._updatePipeline();
		this.vertexArray = this.device.createVertexArray({
			shaderLayout: this.pipeline.shaderLayout,
			bufferLayout: this.pipeline.bufferLayout
		});
		if (this._gpuGeometry) this._setGeometryAttributes(this._gpuGeometry);
	}
	/**
	* Set GPU parameters.
	* @note Can trigger a pipeline rebuild / pipeline cache fetch.
	* @param parameters
	*/
	setParameters(parameters) {
		if (!deepEqual$1(parameters, this.parameters, 2)) {
			this.parameters = parameters;
			this._setPipelineNeedsUpdate("parameters");
		}
	}
	/**
	* Updates the instance count (used in draw calls)
	* @note Any attributes with stepMode=instance need to be at least this big
	*/
	setInstanceCount(instanceCount) {
		this.instanceCount = instanceCount;
		if (this.isInstanced === void 0 && instanceCount > 0) this.isInstanced = true;
		this.setNeedsRedraw("instanceCount");
	}
	/**
	* Updates the vertex count (used in draw calls)
	* @note Any attributes with stepMode=vertex need to be at least this big
	*/
	setVertexCount(vertexCount) {
		this.vertexCount = vertexCount;
		this.setNeedsRedraw("vertexCount");
	}
	/** Set the shader inputs */
	setShaderInputs(shaderInputs) {
		this.shaderInputs = shaderInputs;
		this._uniformStore = new UniformStore(this.shaderInputs.modules);
		for (const [moduleName, module] of Object.entries(this.shaderInputs.modules)) if (shaderModuleHasUniforms(module)) {
			const uniformBuffer = this._uniformStore.getManagedUniformBuffer(this.device, moduleName);
			this.bindings[`${moduleName}Uniforms`] = uniformBuffer;
		}
		this.setNeedsRedraw("shaderInputs");
	}
	/** Update uniform buffers from the model's shader inputs */
	updateShaderInputs() {
		this._uniformStore.setUniforms(this.shaderInputs.getUniformValues());
		this.setBindings(this.shaderInputs.getBindingValues());
		this.setNeedsRedraw("shaderInputs");
	}
	/**
	* Sets bindings (textures, samplers, uniform buffers)
	*/
	setBindings(bindings) {
		Object.assign(this.bindings, bindings);
		this.setNeedsRedraw("bindings");
	}
	/**
	* Updates optional transform feedback. WebGL only.
	*/
	setTransformFeedback(transformFeedback) {
		this.transformFeedback = transformFeedback;
		this.setNeedsRedraw("transformFeedback");
	}
	/**
	* Sets the index buffer
	* @todo - how to unset it if we change geometry?
	*/
	setIndexBuffer(indexBuffer) {
		this.vertexArray.setIndexBuffer(indexBuffer);
		this.setNeedsRedraw("indexBuffer");
	}
	/**
	* Sets attributes (buffers)
	* @note Overrides any attributes previously set with the same name
	*/
	setAttributes(buffers, options) {
		const disableWarnings = options?.disableWarnings ?? this.props.disableWarnings;
		if (buffers["indices"]) log.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)();
		this.bufferLayout = sortedBufferLayoutByShaderSourceLocations(this.pipeline.shaderLayout, this.bufferLayout);
		const bufferLayoutHelper = new BufferLayoutHelper(this.bufferLayout);
		for (const [bufferName, buffer] of Object.entries(buffers)) {
			const bufferLayout = bufferLayoutHelper.getBufferLayout(bufferName);
			if (!bufferLayout) {
				if (!disableWarnings) log.warn(`Model(${this.id}): Missing layout for buffer "${bufferName}".`)();
				continue;
			}
			const attributeNames = bufferLayoutHelper.getAttributeNamesForBuffer(bufferLayout);
			let set = false;
			for (const attributeName of attributeNames) {
				const attributeInfo = this._attributeInfos[attributeName];
				if (attributeInfo) {
					const location = this.device.type === "webgpu" ? bufferLayoutHelper.getBufferIndex(attributeInfo.bufferName) : attributeInfo.location;
					this.vertexArray.setBuffer(location, buffer);
					set = true;
				}
			}
			if (!set && !disableWarnings) log.warn(`Model(${this.id}): Ignoring buffer "${buffer.id}" for unknown attribute "${bufferName}"`)();
		}
		this.setNeedsRedraw("attributes");
	}
	/**
	* Sets constant attributes
	* @note Overrides any attributes previously set with the same name
	* Constant attributes are only supported in WebGL, not in WebGPU
	* Any attribute that is disabled in the current vertex array object
	* is read from the context's global constant value for that attribute location.
	* @param constantAttributes
	*/
	setConstantAttributes(attributes, options) {
		for (const [attributeName, value] of Object.entries(attributes)) {
			const attributeInfo = this._attributeInfos[attributeName];
			if (attributeInfo) this.vertexArray.setConstantWebGL(attributeInfo.location, value);
			else if (!(options?.disableWarnings ?? this.props.disableWarnings)) log.warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${attributeName}"`)();
		}
		this.setNeedsRedraw("constants");
	}
	/** Check that bindings are loaded. Returns id of first binding that is still loading. */
	_areBindingsLoading() {
		for (const binding of Object.values(this.bindings)) if (binding instanceof AsyncTexture && !binding.isReady) return binding.id;
		return false;
	}
	/** Extracts texture view from loaded async textures. Returns null if any textures have not yet been loaded. */
	_getBindings() {
		const validBindings = {};
		for (const [name, binding] of Object.entries(this.bindings)) if (binding instanceof AsyncTexture) {
			if (binding.isReady) validBindings[name] = binding.texture;
		} else validBindings[name] = binding;
		return validBindings;
	}
	/** Get the timestamp of the latest updated bound GPU memory resource (buffer/texture). */
	_getBindingsUpdateTimestamp() {
		let timestamp = 0;
		for (const binding of Object.values(this.bindings)) if (binding instanceof TextureView) timestamp = Math.max(timestamp, binding.texture.updateTimestamp);
		else if (binding instanceof Buffer || binding instanceof Texture) timestamp = Math.max(timestamp, binding.updateTimestamp);
		else if (binding instanceof AsyncTexture) timestamp = binding.texture ? Math.max(timestamp, binding.texture.updateTimestamp) : Infinity;
		else if (!(binding instanceof Sampler)) timestamp = Math.max(timestamp, binding.buffer.updateTimestamp);
		return timestamp;
	}
	/**
	* Updates the optional geometry attributes
	* Geometry, sets several attributes, indexBuffer, and also vertex count
	* @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
	*/
	_setGeometryAttributes(gpuGeometry) {
		const attributes = { ...gpuGeometry.attributes };
		for (const [attributeName] of Object.entries(attributes)) if (!this.pipeline.shaderLayout.attributes.find((layout) => layout.name === attributeName) && attributeName !== "positions") delete attributes[attributeName];
		this.vertexCount = gpuGeometry.vertexCount;
		this.setIndexBuffer(gpuGeometry.indices || null);
		this.setAttributes(gpuGeometry.attributes, { disableWarnings: true });
		this.setAttributes(attributes, { disableWarnings: this.props.disableWarnings });
		this.setNeedsRedraw("geometry attributes");
	}
	/** Mark pipeline as needing update */
	_setPipelineNeedsUpdate(reason) {
		this._pipelineNeedsUpdate ||= reason;
		this.setNeedsRedraw(reason);
	}
	/** Update pipeline if needed */
	_updatePipeline() {
		if (this._pipelineNeedsUpdate) {
			let prevShaderVs = null;
			let prevShaderFs = null;
			if (this.pipeline) {
				log.log(1, `Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)();
				prevShaderVs = this.pipeline.vs;
				prevShaderFs = this.pipeline.fs;
			}
			this._pipelineNeedsUpdate = false;
			const vs$6 = this.shaderFactory.createShader({
				id: `${this.id}-vertex`,
				stage: "vertex",
				source: this.source || this.vs,
				debugShaders: this.props.debugShaders
			});
			let fs$4 = null;
			if (this.source) fs$4 = vs$6;
			else if (this.fs) fs$4 = this.shaderFactory.createShader({
				id: `${this.id}-fragment`,
				stage: "fragment",
				source: this.source || this.fs,
				debugShaders: this.props.debugShaders
			});
			this.pipeline = this.pipelineFactory.createRenderPipeline({
				...this.props,
				bufferLayout: this.bufferLayout,
				topology: this.topology,
				parameters: this.parameters,
				bindings: this._getBindings(),
				vs: vs$6,
				fs: fs$4
			});
			this._attributeInfos = getAttributeInfosFromLayouts(this.pipeline.shaderLayout, this.bufferLayout);
			if (prevShaderVs) this.shaderFactory.release(prevShaderVs);
			if (prevShaderFs) this.shaderFactory.release(prevShaderFs);
		}
		return this.pipeline;
	}
	/** Throttle draw call logging */
	_lastLogTime = 0;
	_logOpen = false;
	_logDrawCallStart() {
		const logDrawTimeout = log.level > 3 ? 0 : LOG_DRAW_TIMEOUT;
		if (log.level < 2 || Date.now() - this._lastLogTime < logDrawTimeout) return;
		this._lastLogTime = Date.now();
		this._logOpen = true;
		log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, { collapsed: log.level <= 2 })();
	}
	_logDrawCallEnd() {
		if (this._logOpen) {
			const shaderLayoutTable = getDebugTableForShaderLayout(this.pipeline.shaderLayout, this.id);
			log.table(LOG_DRAW_PRIORITY, shaderLayoutTable)();
			const uniformTable = this.shaderInputs.getDebugTable();
			log.table(LOG_DRAW_PRIORITY, uniformTable)();
			const attributeTable = this._getAttributeDebugTable();
			log.table(LOG_DRAW_PRIORITY, this._attributeInfos)();
			log.table(LOG_DRAW_PRIORITY, attributeTable)();
			log.groupEnd(LOG_DRAW_PRIORITY)();
			this._logOpen = false;
		}
	}
	_drawCount = 0;
	_logFramebuffer(renderPass) {
		const debugFramebuffers = this.device.props.debugFramebuffers;
		this._drawCount++;
		if (!debugFramebuffers) return;
		const framebuffer = renderPass.props.framebuffer;
		if (framebuffer) debugFramebuffer(framebuffer, {
			id: framebuffer.id,
			minimap: true
		});
	}
	_getAttributeDebugTable() {
		const table = {};
		for (const [name, attributeInfo] of Object.entries(this._attributeInfos)) {
			const values = this.vertexArray.attributes[attributeInfo.location];
			table[attributeInfo.location] = {
				name,
				type: attributeInfo.shaderType,
				values: values ? this._getBufferOrConstantValues(values, attributeInfo.bufferDataType) : "null"
			};
		}
		if (this.vertexArray.indexBuffer) {
			const { indexBuffer } = this.vertexArray;
			const values = indexBuffer.indexType === "uint32" ? new Uint32Array(indexBuffer.debugData) : new Uint16Array(indexBuffer.debugData);
			table["indices"] = {
				name: "indices",
				type: indexBuffer.indexType,
				values: values.toString()
			};
		}
		return table;
	}
	_getBufferOrConstantValues(attribute, dataType) {
		const TypedArrayConstructor = getTypedArrayConstructor(dataType);
		return (attribute instanceof Buffer ? new TypedArrayConstructor(attribute.debugData) : attribute).toString();
	}
};
function shaderModuleHasUniforms(module) {
	return Boolean(module.uniformTypes && !isObjectEmpty(module.uniformTypes));
}
/** Create a shadertools platform info from the Device */
function getPlatformInfo(device) {
	return {
		type: device.type,
		shaderLanguage: device.info.shadingLanguage,
		shaderLanguageVersion: device.info.shadingLanguageVersion,
		gpu: device.info.gpu,
		features: device.features
	};
}
/** Returns true if given object is empty, false otherwise. */
function isObjectEmpty(obj) {
	for (const key in obj) return false;
	return true;
}

//#endregion
//#region node_modules/@luma.gl/engine/dist/compute/buffer-transform.js
/**
* Manages a WebGL program (pipeline) for bufferbuffer transforms.
* @note Only works under WebGL2.
*/
var BufferTransform = class BufferTransform {
	device;
	model;
	transformFeedback;
	static defaultProps = {
		...Model.defaultProps,
		outputs: void 0,
		feedbackBuffers: void 0
	};
	static isSupported(device) {
		return device?.info?.type === "webgl";
	}
	constructor(device, props = BufferTransform.defaultProps) {
		if (!BufferTransform.isSupported(device)) throw new Error("BufferTransform not yet implemented on WebGPU");
		this.device = device;
		this.model = new Model(this.device, {
			id: props.id || "buffer-transform-model",
			fs: props.fs || getPassthroughFS(),
			topology: props.topology || "point-list",
			varyings: props.outputs || props.varyings,
			...props
		});
		this.transformFeedback = this.device.createTransformFeedback({
			layout: this.model.pipeline.shaderLayout,
			buffers: props.feedbackBuffers
		});
		this.model.setTransformFeedback(this.transformFeedback);
		Object.seal(this);
	}
	/** Destroy owned resources. */
	destroy() {
		if (this.model) this.model.destroy();
	}
	/** @deprecated Use {@link destroy}. */
	delete() {
		this.destroy();
	}
	/** Run one transform loop. */
	run(options) {
		if (options?.inputBuffers) this.model.setAttributes(options.inputBuffers);
		if (options?.outputBuffers) this.transformFeedback.setBuffers(options.outputBuffers);
		const renderPass = this.device.beginRenderPass(options);
		this.model.draw(renderPass);
		renderPass.end();
	}
	/** @deprecated App knows what buffers it is passing in - Returns the {@link Buffer} or {@link BufferRange} for given varying name. */
	getBuffer(varyingName) {
		return this.transformFeedback.getBuffer(varyingName);
	}
	/** @deprecated App knows what buffers it is passing in - Reads the {@link Buffer} or {@link BufferRange} for given varying name. */
	readAsync(varyingName) {
		const result = this.getBuffer(varyingName);
		if (!result) throw new Error("BufferTransform#getBuffer");
		if (result instanceof Buffer) return result.readAsync();
		const { buffer, byteOffset = 0, byteLength = buffer.byteLength } = result;
		return buffer.readAsync(byteOffset, byteLength);
	}
};

//#endregion
//#region node_modules/@luma.gl/engine/dist/geometry/geometry.js
var Geometry = class {
	id;
	/** Determines how vertices are read from the 'vertex' attributes */
	topology;
	vertexCount;
	indices;
	attributes;
	userData = {};
	constructor(props) {
		const { attributes = {}, indices = null, vertexCount = null } = props;
		this.id = props.id || uid("geometry");
		this.topology = props.topology;
		if (indices) this.indices = ArrayBuffer.isView(indices) ? {
			value: indices,
			size: 1
		} : indices;
		this.attributes = {};
		for (const [attributeName, attributeValue] of Object.entries(attributes)) {
			const attribute = ArrayBuffer.isView(attributeValue) ? { value: attributeValue } : attributeValue;
			if (!ArrayBuffer.isView(attribute.value)) throw new Error(`${this._print(attributeName)}: must be typed array or object with value as typed array`);
			if ((attributeName === "POSITION" || attributeName === "positions") && !attribute.size) attribute.size = 3;
			if (attributeName === "indices") {
				if (this.indices) throw new Error("Multiple indices detected");
				this.indices = attribute;
			} else this.attributes[attributeName] = attribute;
		}
		if (this.indices && this.indices["isIndexed"] !== void 0) {
			this.indices = Object.assign({}, this.indices);
			delete this.indices["isIndexed"];
		}
		this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);
	}
	getVertexCount() {
		return this.vertexCount;
	}
	/**
	* Return an object with all attributes plus indices added as a field.
	* TODO Geometry types are a mess
	*/
	getAttributes() {
		return this.indices ? {
			indices: this.indices,
			...this.attributes
		} : this.attributes;
	}
	_print(attributeName) {
		return `Geometry ${this.id} attribute ${attributeName}`;
	}
	/**
	* GeometryAttribute
	* value: typed array
	* type: indices, vertices, uvs
	* size: elements per vertex
	* target: WebGL buffer type (string or constant)
	*
	* @param attributes
	* @param indices
	* @returns
	*/
	_setAttributes(attributes, indices) {
		return this;
	}
	_calculateVertexCount(attributes, indices) {
		if (indices) return indices.value.length;
		let vertexCount = Infinity;
		for (const attribute of Object.values(attributes)) {
			const { value, size, constant } = attribute;
			if (!constant && value && size !== void 0 && size >= 1) vertexCount = Math.min(vertexCount, value.length / size);
		}
		return vertexCount;
	}
};

//#endregion
//#region node_modules/@luma.gl/engine/dist/models/clip-space.js
var CLIPSPACE_VERTEX_SHADER_WGSL = `\
struct VertexInputs {
  @location(0) clipSpacePosition: vec2<f32>,
  @location(1) texCoord: vec2<f32>,
  @location(2) coordinate: vec2<f32>  
}

struct FragmentInputs {
  @builtin(position) Position : vec4<f32>,
  @location(0) position : vec2<f32>,
  @location(1) coordinate : vec2<f32>,
  @location(2) uv : vec2<f32>
};

@vertex
fn vertexMain(inputs: VertexInputs) -> FragmentInputs {
  var outputs: FragmentInputs;
  outputs.Position = vec4(inputs.clipSpacePosition, 0., 1.);
  outputs.position = inputs.clipSpacePosition;
  outputs.coordinate = inputs.coordinate;
  outputs.uv = inputs.texCoord;
  return outputs;
}
`;
var CLIPSPACE_VERTEX_SHADER = `\
#version 300 es
in vec2 clipSpacePositions;
in vec2 texCoords;
in vec2 coordinates;

out vec2 position;
out vec2 coordinate;
out vec2 uv;

void main(void) {
  gl_Position = vec4(clipSpacePositions, 0., 1.);
  position = clipSpacePositions;
  coordinate = coordinates;
  uv = texCoords;
}
`;
var POSITIONS = [
	-1,
	-1,
	1,
	-1,
	-1,
	1,
	1,
	1
];
/**
* A flat geometry that covers the "visible area" that the GPU renders.
*/
var ClipSpace = class extends Model {
	constructor(device, props) {
		const TEX_COORDS = POSITIONS.map((coord) => coord === -1 ? 0 : coord);
		if (props.source) props = {
			...props,
			source: `${CLIPSPACE_VERTEX_SHADER_WGSL}\n${props.source}`
		};
		super(device, {
			id: props.id || uid("clip-space"),
			...props,
			vs: CLIPSPACE_VERTEX_SHADER,
			vertexCount: 4,
			geometry: new Geometry({
				topology: "triangle-strip",
				vertexCount: 4,
				attributes: {
					clipSpacePositions: {
						size: 2,
						value: new Float32Array(POSITIONS)
					},
					texCoords: {
						size: 2,
						value: new Float32Array(TEX_COORDS)
					},
					coordinates: {
						size: 2,
						value: new Float32Array(TEX_COORDS)
					}
				}
			})
		});
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/passes/screen-pass-uniforms.js
var uniformBlock = `\
uniform screenUniforms {
  vec2 texSize;
} screen;
`;
const screenUniforms = {
	name: "screen",
	fs: uniformBlock,
	uniformTypes: { texSize: "vec2<f32>" }
};

//#endregion
//#region node_modules/@deck.gl/core/dist/passes/screen-pass.js
/** A base render pass. */
var ScreenPass = class extends Pass {
	constructor(device, props) {
		super(device, props);
		const { module, fs: fs$4, id } = props;
		this.model = new ClipSpace(device, {
			id,
			fs: fs$4,
			modules: [module, screenUniforms],
			parameters: {
				depthWriteEnabled: false,
				depthCompare: "always",
				depthBias: 0,
				blend: true,
				blendColorSrcFactor: "one",
				blendColorDstFactor: "one-minus-src-alpha",
				blendAlphaSrcFactor: "one",
				blendAlphaDstFactor: "one-minus-src-alpha",
				blendColorOperation: "add",
				blendAlphaOperation: "add"
			}
		});
	}
	render(params) {
		this._renderPass(this.device, params);
	}
	delete() {
		this.model.destroy();
		this.model = null;
	}
	/**
	* Renders the pass.
	* This is an abstract method that should be overridden.
	* @param inputBuffer - Frame buffer that contains the result of the previous pass
	* @param outputBuffer - Frame buffer that serves as the output render target
	*/
	_renderPass(device, options) {
		const { clearCanvas, inputBuffer, outputBuffer } = options;
		const texSize = [inputBuffer.width, inputBuffer.height];
		const screenProps = {
			texSrc: inputBuffer.colorAttachments[0],
			texSize
		};
		this.model.shaderInputs.setProps({
			screen: screenProps,
			...options.moduleProps
		});
		const renderPass = this.device.beginRenderPass({
			framebuffer: outputBuffer,
			parameters: { viewport: [
				0,
				0,
				...texSize
			] },
			clearColor: clearCanvas ? [
				0,
				0,
				0,
				0
			] : false,
			clearDepth: 1,
			clearStencil: false
		});
		this.model.draw(renderPass);
		renderPass.end();
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/effects/post-process-effect.js
var PostProcessEffect = class {
	constructor(module, props) {
		this.id = `${module.name}-pass`;
		this.props = props;
		initializeShaderModule(module);
		this.module = module;
	}
	setup({ device }) {
		this.passes = createPasses(device, this.module, this.id);
	}
	setProps(props) {
		this.props = props;
	}
	preRender() {}
	postRender(params) {
		const passes = this.passes;
		const { target } = params;
		let inputBuffer = params.inputBuffer;
		let outputBuffer = params.swapBuffer;
		for (let index = 0; index < passes.length; index++) {
			const isLastPass = index === passes.length - 1;
			const renderToTarget = target !== void 0 && isLastPass;
			if (renderToTarget) outputBuffer = target;
			const clearCanvas = !renderToTarget || Boolean(params.clearCanvas);
			const moduleProps = {};
			const uniforms = this.module.passes[index].uniforms;
			moduleProps[this.module.name] = {
				...this.props,
				...uniforms
			};
			passes[index].render({
				clearCanvas,
				inputBuffer,
				outputBuffer,
				moduleProps
			});
			const switchBuffer = outputBuffer;
			outputBuffer = inputBuffer;
			inputBuffer = switchBuffer;
		}
		return inputBuffer;
	}
	cleanup() {
		if (this.passes) {
			for (const pass of this.passes) pass.delete();
			this.passes = void 0;
		}
	}
};
function createPasses(device, module, id) {
	return module.passes.map((pass, index) => {
		const fs$4 = getFragmentShaderForRenderPass(module, pass);
		return new ScreenPass(device, {
			id: `${id}-${index}`,
			module,
			fs: fs$4
		});
	});
}
var FS_TEMPLATE_INPUTS = `\
#version 300 es
uniform sampler2D texSrc;

in vec2 position;
in vec2 coordinate;
in vec2 uv;

out vec4 fragColor;
`;
var FILTER_FS_TEMPLATE = (func) => `\
${FS_TEMPLATE_INPUTS}
void main() {
  fragColor = texture(texSrc, coordinate);
  fragColor = ${func}(fragColor, screen.texSize, coordinate);
}
`;
var SAMPLER_FS_TEMPLATE = (func) => `\
${FS_TEMPLATE_INPUTS}
void main() {
  fragColor = ${func}(texSrc, screen.texSize, coordinate);
}
`;
function getFragmentShaderForRenderPass(module, pass) {
	if (pass.filter) return FILTER_FS_TEMPLATE(typeof pass.filter === "string" ? pass.filter : `${module.name}_filterColor_ext`);
	if (pass.sampler) return SAMPLER_FS_TEMPLATE(typeof pass.sampler === "string" ? pass.sampler : `${module.name}_sampleColor`);
	return "";
}

//#endregion
//#region node_modules/@deck.gl/core/dist/passes/pick-layers-pass.js
var PICKING_BLENDING = {
	blendColorOperation: "add",
	blendColorSrcFactor: "one",
	blendColorDstFactor: "zero",
	blendAlphaOperation: "add",
	blendAlphaSrcFactor: "constant",
	blendAlphaDstFactor: "zero"
};
var PickLayersPass = class extends LayersPass {
	constructor() {
		super(...arguments);
		this._colorEncoderState = null;
	}
	render(props) {
		if ("pickingFBO" in props) return this._drawPickingBuffer(props);
		return super.render(props);
	}
	_drawPickingBuffer({ layers, layerFilter, views, viewports, onViewportActive, pickingFBO, deviceRect: { x: x$1, y: y$1, width, height }, cullRect, effects, pass = "picking", pickZ, shaderModuleProps }) {
		this.pickZ = pickZ;
		const colorEncoderState = this._resetColorEncoder(pickZ);
		const scissorRect = [
			x$1,
			y$1,
			width,
			height
		];
		const renderStatus = super.render({
			target: pickingFBO,
			layers,
			layerFilter,
			views,
			viewports,
			onViewportActive,
			cullRect,
			effects: effects?.filter((e$2) => e$2.useInPicking),
			pass,
			isPicking: true,
			shaderModuleProps,
			clearColor: [
				0,
				0,
				0,
				0
			],
			colorMask: 15,
			scissorRect
		});
		this._colorEncoderState = null;
		return {
			decodePickingColor: colorEncoderState && decodeColor.bind(null, colorEncoderState),
			stats: renderStatus
		};
	}
	shouldDrawLayer(layer) {
		const { pickable, operation } = layer.props;
		return pickable && operation.includes("draw") || operation.includes("terrain") || operation.includes("mask");
	}
	getShaderModuleProps(layer, effects, otherShaderModuleProps) {
		return {
			picking: {
				isActive: 1,
				isAttribute: this.pickZ
			},
			lighting: { enabled: false }
		};
	}
	getLayerParameters(layer, layerIndex, viewport) {
		const pickParameters = { ...layer.props.parameters };
		const { pickable, operation } = layer.props;
		if (!this._colorEncoderState || operation.includes("terrain")) pickParameters.blend = false;
		else if (pickable && operation.includes("draw")) {
			Object.assign(pickParameters, PICKING_BLENDING);
			pickParameters.blend = true;
			pickParameters.blendColor = encodeColor(this._colorEncoderState, layer, viewport);
		}
		return pickParameters;
	}
	_resetColorEncoder(pickZ) {
		this._colorEncoderState = pickZ ? null : {
			byLayer: /* @__PURE__ */ new Map(),
			byAlpha: []
		};
		return this._colorEncoderState;
	}
};
function encodeColor(encoded, layer, viewport) {
	const { byLayer, byAlpha } = encoded;
	let a$1;
	let entry = byLayer.get(layer);
	if (entry) {
		entry.viewports.push(viewport);
		a$1 = entry.a;
	} else {
		a$1 = byLayer.size + 1;
		if (a$1 <= 255) {
			entry = {
				a: a$1,
				layer,
				viewports: [viewport]
			};
			byLayer.set(layer, entry);
			byAlpha[a$1] = entry;
		} else {
			log_default.warn("Too many pickable layers, only picking the first 255")();
			a$1 = 0;
		}
	}
	return [
		0,
		0,
		0,
		a$1 / 255
	];
}
function decodeColor(encoded, pickedColor) {
	const entry = encoded.byAlpha[pickedColor[3]];
	return entry && {
		pickedLayer: entry.layer,
		pickedViewports: entry.viewports,
		pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)
	};
}

//#endregion
//#region node_modules/@deck.gl/core/dist/lifecycle/constants.js
const LIFECYCLE = {
	NO_STATE: "Awaiting state",
	MATCHED: "Matched. State transferred from previous layer",
	INITIALIZED: "Initialized",
	AWAITING_GC: "Discarded. Awaiting garbage collection",
	AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
	FINALIZED: "Finalized! Awaiting garbage collection"
};
const COMPONENT_SYMBOL = Symbol.for("component");
const PROP_TYPES_SYMBOL = Symbol.for("propTypes");
const DEPRECATED_PROPS_SYMBOL = Symbol.for("deprecatedProps");
const ASYNC_DEFAULTS_SYMBOL = Symbol.for("asyncPropDefaults");
const ASYNC_ORIGINAL_SYMBOL = Symbol.for("asyncPropOriginal");
const ASYNC_RESOLVED_SYMBOL = Symbol.for("asyncPropResolved");

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/flatten.js
/**
* Flattens a nested array into a single level array,
* or a single value into an array with one value
* @example flatten([[1, [2]], [3], 4]) => [1, 2, 3, 4]
* @example flatten(1) => [1]
* @param array The array to flatten.
* @param filter= - Optional predicate called on each `value` to
*   determine if it should be included (pushed onto) the resulting array.
* @return Returns the new flattened array (new array or `result` if provided)
*/
function flatten(array, filter = () => true) {
	if (!Array.isArray(array)) return filter(array) ? [array] : [];
	return flattenArray(array, filter, []);
}
/** Deep flattens an array. Helper to `flatten`, see its parameters */
function flattenArray(array, filter, result) {
	let index = -1;
	while (++index < array.length) {
		const value = array[index];
		if (Array.isArray(value)) flattenArray(value, filter, result);
		else if (filter(value)) result.push(value);
	}
	return result;
}
/** Uses copyWithin to significantly speed up typed array value filling */
function fillArray({ target, source: source$2, start = 0, count: count$1 = 1 }) {
	const length$2 = source$2.length;
	const total = count$1 * length$2;
	let copied = 0;
	for (let i$1 = start; copied < length$2; copied++) target[i$1++] = source$2[copied];
	while (copied < total) if (copied < total - copied) {
		target.copyWithin(start + copied, start, start + copied);
		copied *= 2;
	} else {
		target.copyWithin(start + copied, start, start + total - copied);
		copied = total;
	}
	return target;
}

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/resource/resource.js
var Resource = class {
	constructor(id, data, context) {
		this._loadCount = 0;
		this._subscribers = /* @__PURE__ */ new Set();
		this.id = id;
		this.context = context;
		this.setData(data);
	}
	subscribe(consumer) {
		this._subscribers.add(consumer);
	}
	unsubscribe(consumer) {
		this._subscribers.delete(consumer);
	}
	inUse() {
		return this._subscribers.size > 0;
	}
	delete() {}
	getData() {
		return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
	}
	setData(data, forceUpdate) {
		if (data === this._data && !forceUpdate) return;
		this._data = data;
		const loadCount = ++this._loadCount;
		let loader = data;
		if (typeof data === "string") loader = load(data);
		if (loader instanceof Promise) {
			this.isLoaded = false;
			this._loader = loader.then((result) => {
				if (this._loadCount === loadCount) {
					this.isLoaded = true;
					this._error = void 0;
					this._content = result;
				}
			}).catch((error) => {
				if (this._loadCount === loadCount) {
					this.isLoaded = true;
					this._error = error || true;
				}
			});
		} else {
			this.isLoaded = true;
			this._error = void 0;
			this._content = data;
		}
		for (const subscriber of this._subscribers) subscriber.onChange(this.getData());
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/resource/resource-manager.js
var ResourceManager = class {
	constructor(props) {
		this.protocol = props.protocol || "resource://";
		this._context = {
			device: props.device,
			gl: props.device?.gl,
			resourceManager: this
		};
		this._resources = {};
		this._consumers = {};
		this._pruneRequest = null;
	}
	contains(resourceId) {
		if (resourceId.startsWith(this.protocol)) return true;
		return resourceId in this._resources;
	}
	add({ resourceId, data, forceUpdate = false, persistent = true }) {
		let res = this._resources[resourceId];
		if (res) res.setData(data, forceUpdate);
		else {
			res = new Resource(resourceId, data, this._context);
			this._resources[resourceId] = res;
		}
		res.persistent = persistent;
	}
	remove(resourceId) {
		const res = this._resources[resourceId];
		if (res) {
			res.delete();
			delete this._resources[resourceId];
		}
	}
	unsubscribe({ consumerId }) {
		const consumer = this._consumers[consumerId];
		if (consumer) {
			for (const requestId in consumer) {
				const request = consumer[requestId];
				const resource = this._resources[request.resourceId];
				if (resource) resource.unsubscribe(request);
			}
			delete this._consumers[consumerId];
			this.prune();
		}
	}
	subscribe({ resourceId, onChange, consumerId, requestId = "default" }) {
		const { _resources: resources, protocol } = this;
		if (resourceId.startsWith(protocol)) {
			resourceId = resourceId.replace(protocol, "");
			if (!resources[resourceId]) this.add({
				resourceId,
				data: null,
				persistent: false
			});
		}
		const res = resources[resourceId];
		this._track(consumerId, requestId, res, onChange);
		if (res) return res.getData();
	}
	prune() {
		if (!this._pruneRequest) this._pruneRequest = setTimeout(() => this._prune(), 0);
	}
	finalize() {
		for (const key in this._resources) this._resources[key].delete();
	}
	_track(consumerId, requestId, resource, onChange) {
		const consumers = this._consumers;
		const consumer = consumers[consumerId] = consumers[consumerId] || {};
		let request = consumer[requestId];
		const oldResource = request && request.resourceId && this._resources[request.resourceId];
		if (oldResource) {
			oldResource.unsubscribe(request);
			this.prune();
		}
		if (resource) {
			if (request) {
				request.onChange = onChange;
				request.resourceId = resource.id;
			} else request = {
				onChange,
				resourceId: resource.id
			};
			consumer[requestId] = request;
			resource.subscribe(request);
		}
	}
	_prune() {
		this._pruneRequest = null;
		for (const key of Object.keys(this._resources)) {
			const res = this._resources[key];
			if (!res.persistent && !res.inUse()) {
				res.delete();
				delete this._resources[key];
			}
		}
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/layer-manager.js
var TRACE_SET_LAYERS = "layerManager.setLayers";
var TRACE_ACTIVATE_VIEWPORT = "layerManager.activateViewport";
var LayerManager = class {
	/**
	* @param device
	* @param param1
	*/
	constructor(device, props) {
		this._lastRenderedLayers = [];
		this._needsRedraw = false;
		this._needsUpdate = false;
		this._nextLayers = null;
		this._debug = false;
		this._defaultShaderModulesChanged = false;
		/** Make a viewport "current" in layer context, updating viewportChanged flags */
		this.activateViewport = (viewport$1) => {
			debug(TRACE_ACTIVATE_VIEWPORT, this, viewport$1);
			if (viewport$1) this.context.viewport = viewport$1;
		};
		const { deck, stats, viewport, timeline } = props || {};
		this.layers = [];
		this.resourceManager = new ResourceManager({
			device,
			protocol: "deck://"
		});
		this.context = {
			mousePosition: null,
			userData: {},
			layerManager: this,
			device,
			gl: device?.gl,
			deck,
			shaderAssembler: getShaderAssembler(device?.info?.shadingLanguage || "glsl"),
			defaultShaderModules: [layerUniforms],
			renderPass: void 0,
			stats: stats || new Stats({ id: "deck.gl" }),
			viewport: viewport || new viewport_default({ id: "DEFAULT-INITIAL-VIEWPORT" }),
			timeline: timeline || new Timeline(),
			resourceManager: this.resourceManager,
			onError: void 0
		};
		Object.seal(this);
	}
	/** Method to call when the layer manager is not needed anymore. */
	finalize() {
		this.resourceManager.finalize();
		for (const layer of this.layers) this._finalizeLayer(layer);
	}
	/** Check if a redraw is needed */
	needsRedraw(opts = { clearRedrawFlags: false }) {
		let redraw = this._needsRedraw;
		if (opts.clearRedrawFlags) this._needsRedraw = false;
		for (const layer of this.layers) {
			const layerNeedsRedraw = layer.getNeedsRedraw(opts);
			redraw = redraw || layerNeedsRedraw;
		}
		return redraw;
	}
	/** Check if a deep update of all layers is needed */
	needsUpdate() {
		if (this._nextLayers && this._nextLayers !== this._lastRenderedLayers) return "layers changed";
		if (this._defaultShaderModulesChanged) return "shader modules changed";
		return this._needsUpdate;
	}
	/** Layers will be redrawn (in next animation frame) */
	setNeedsRedraw(reason) {
		this._needsRedraw = this._needsRedraw || reason;
	}
	/** Layers will be updated deeply (in next animation frame)
	Potentially regenerating attributes and sub layers */
	setNeedsUpdate(reason) {
		this._needsUpdate = this._needsUpdate || reason;
	}
	/** Gets a list of currently rendered layers. Optionally filter by id. */
	getLayers({ layerIds } = {}) {
		return layerIds ? this.layers.filter((layer) => layerIds.find((layerId) => layer.id.indexOf(layerId) === 0)) : this.layers;
	}
	/** Set props needed for layer rendering and picking. */
	setProps(props) {
		if ("debug" in props) this._debug = props.debug;
		if ("userData" in props) this.context.userData = props.userData;
		if ("layers" in props) this._nextLayers = props.layers;
		if ("onError" in props) this.context.onError = props.onError;
	}
	/** Supply a new layer list, initiating sublayer generation and layer matching */
	setLayers(newLayers, reason) {
		debug(TRACE_SET_LAYERS, this, reason, newLayers);
		this._lastRenderedLayers = newLayers;
		const flatLayers = flatten(newLayers, Boolean);
		for (const layer of flatLayers) layer.context = this.context;
		this._updateLayers(this.layers, flatLayers);
	}
	/** Update layers from last cycle if `setNeedsUpdate()` has been called */
	updateLayers() {
		const reason = this.needsUpdate();
		if (reason) {
			this.setNeedsRedraw(`updating layers: ${reason}`);
			this.setLayers(this._nextLayers || this._lastRenderedLayers, reason);
		}
		this._nextLayers = null;
	}
	/** Register a default shader module */
	addDefaultShaderModule(module) {
		const { defaultShaderModules } = this.context;
		if (!defaultShaderModules.find((m$1) => m$1.name === module.name)) {
			defaultShaderModules.push(module);
			this._defaultShaderModulesChanged = true;
		}
	}
	/** Deregister a default shader module */
	removeDefaultShaderModule(module) {
		const { defaultShaderModules } = this.context;
		const i$1 = defaultShaderModules.findIndex((m$1) => m$1.name === module.name);
		if (i$1 >= 0) {
			defaultShaderModules.splice(i$1, 1);
			this._defaultShaderModulesChanged = true;
		}
	}
	_handleError(stage, error, layer) {
		layer.raiseError(error, `${stage} of ${layer}`);
	}
	/** Match all layers, checking for caught errors
	to avoid having an exception in one layer disrupt other layers */
	_updateLayers(oldLayers, newLayers) {
		const oldLayerMap = {};
		for (const oldLayer of oldLayers) if (oldLayerMap[oldLayer.id]) log_default.warn(`Multiple old layers with same id ${oldLayer.id}`)();
		else oldLayerMap[oldLayer.id] = oldLayer;
		if (this._defaultShaderModulesChanged) {
			for (const layer of oldLayers) {
				layer.setNeedsUpdate();
				layer.setChangeFlags({ extensionsChanged: true });
			}
			this._defaultShaderModulesChanged = false;
		}
		const generatedLayers = [];
		this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);
		this._finalizeOldLayers(oldLayerMap);
		let needsUpdate = false;
		for (const layer of generatedLayers) if (layer.hasUniformTransition()) {
			needsUpdate = `Uniform transition in ${layer}`;
			break;
		}
		this._needsUpdate = needsUpdate;
		this.layers = generatedLayers;
	}
	_updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {
		for (const newLayer of newLayers) {
			newLayer.context = this.context;
			const oldLayer = oldLayerMap[newLayer.id];
			if (oldLayer === null) log_default.warn(`Multiple new layers with same id ${newLayer.id}`)();
			oldLayerMap[newLayer.id] = null;
			let sublayers = null;
			try {
				if (this._debug && oldLayer !== newLayer) newLayer.validateProps();
				if (!oldLayer) this._initializeLayer(newLayer);
				else {
					this._transferLayerState(oldLayer, newLayer);
					this._updateLayer(newLayer);
				}
				generatedLayers.push(newLayer);
				sublayers = newLayer.isComposite ? newLayer.getSubLayers() : null;
			} catch (err) {
				this._handleError("matching", err, newLayer);
			}
			if (sublayers) this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);
		}
	}
	_finalizeOldLayers(oldLayerMap) {
		for (const layerId in oldLayerMap) {
			const layer = oldLayerMap[layerId];
			if (layer) this._finalizeLayer(layer);
		}
	}
	/** Safely initializes a single layer, calling layer methods */
	_initializeLayer(layer) {
		try {
			layer._initialize();
			layer.lifecycle = LIFECYCLE.INITIALIZED;
		} catch (err) {
			this._handleError("initialization", err, layer);
		}
	}
	/** Transfer state from one layer to a newer version */
	_transferLayerState(oldLayer, newLayer) {
		newLayer._transferState(oldLayer);
		newLayer.lifecycle = LIFECYCLE.MATCHED;
		if (newLayer !== oldLayer) oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;
	}
	/** Safely updates a single layer, cleaning all flags */
	_updateLayer(layer) {
		try {
			layer._update();
		} catch (err) {
			this._handleError("update", err, layer);
		}
	}
	/** Safely finalizes a single layer, removing all resources */
	_finalizeLayer(layer) {
		this._needsRedraw = this._needsRedraw || `finalized ${layer}`;
		layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;
		try {
			layer._finalize();
			layer.lifecycle = LIFECYCLE.FINALIZED;
		} catch (err) {
			this._handleError("finalization", err, layer);
		}
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/deep-equal.js
/**
* Fast partial deep equal for prop.
*
* @param a Prop
* @param b Prop to compare against `a`
* @param depth Depth to which to recurse in nested Objects/Arrays. Use 0 (default) for shallow comparison, -1 for infinite depth
*/
function deepEqual(a$1, b$1, depth) {
	if (a$1 === b$1) return true;
	if (!depth || !a$1 || !b$1) return false;
	if (Array.isArray(a$1)) {
		if (!Array.isArray(b$1) || a$1.length !== b$1.length) return false;
		for (let i$1 = 0; i$1 < a$1.length; i$1++) if (!deepEqual(a$1[i$1], b$1[i$1], depth - 1)) return false;
		return true;
	}
	if (Array.isArray(b$1)) return false;
	if (typeof a$1 === "object" && typeof b$1 === "object") {
		const aKeys = Object.keys(a$1);
		const bKeys = Object.keys(b$1);
		if (aKeys.length !== bKeys.length) return false;
		for (const key of aKeys) {
			if (!b$1.hasOwnProperty(key)) return false;
			if (!deepEqual(a$1[key], b$1[key], depth - 1)) return false;
		}
		return true;
	}
	return false;
}

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/view-manager.js
var ViewManager = class {
	constructor(props) {
		this.views = [];
		this.width = 100;
		this.height = 100;
		this.viewState = {};
		this.controllers = {};
		this.timeline = props.timeline;
		this._viewports = [];
		this._viewportMap = {};
		this._isUpdating = false;
		this._needsRedraw = "First render";
		this._needsUpdate = "Initialize";
		this._eventManager = props.eventManager;
		this._eventCallbacks = {
			onViewStateChange: props.onViewStateChange,
			onInteractionStateChange: props.onInteractionStateChange
		};
		Object.seal(this);
		this.setProps(props);
	}
	/** Remove all resources and event listeners */
	finalize() {
		for (const key in this.controllers) {
			const controller = this.controllers[key];
			if (controller) controller.finalize();
		}
		this.controllers = {};
	}
	/** Check if a redraw is needed */
	needsRedraw(opts = { clearRedrawFlags: false }) {
		const redraw = this._needsRedraw;
		if (opts.clearRedrawFlags) this._needsRedraw = false;
		return redraw;
	}
	/** Mark the manager as dirty. Will rebuild all viewports and update controllers. */
	setNeedsUpdate(reason) {
		this._needsUpdate = this._needsUpdate || reason;
		this._needsRedraw = this._needsRedraw || reason;
	}
	/** Checks each viewport for transition updates */
	updateViewStates() {
		for (const viewId in this.controllers) {
			const controller = this.controllers[viewId];
			if (controller) controller.updateTransition();
		}
	}
	/** Get a set of viewports for a given width and height
	* TODO - Intention is for deck.gl to autodeduce width and height and drop the need for props
	* @param rect (object, optional) - filter the viewports
	*   + not provided - return all viewports
	*   + {x, y} - only return viewports that contain this pixel
	*   + {x, y, width, height} - only return viewports that overlap with this rectangle
	*/
	getViewports(rect) {
		if (rect) return this._viewports.filter((viewport) => viewport.containsPixel(rect));
		return this._viewports;
	}
	/** Get a map of all views */
	getViews() {
		const viewMap = {};
		this.views.forEach((view) => {
			viewMap[view.id] = view;
		});
		return viewMap;
	}
	/** Resolves a viewId string to a View */
	getView(viewId) {
		return this.views.find((view) => view.id === viewId);
	}
	/** Returns the viewState for a specific viewId. Matches the viewState by
	1. view.viewStateId
	2. view.id
	3. root viewState
	then applies the view's filter if any */
	getViewState(viewOrViewId) {
		const view = typeof viewOrViewId === "string" ? this.getView(viewOrViewId) : viewOrViewId;
		const viewState = view && this.viewState[view.getViewStateId()] || this.viewState;
		return view ? view.filterViewState(viewState) : viewState;
	}
	getViewport(viewId) {
		return this._viewportMap[viewId];
	}
	/**
	* Unproject pixel coordinates on screen onto world coordinates,
	* (possibly [lon, lat]) on map.
	* - [x, y] => [lng, lat]
	* - [x, y, z] => [lng, lat, Z]
	* @param {Array} xyz -
	* @param {Object} opts - options
	* @param {Object} opts.topLeft=true - Whether origin is top left
	* @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
	*/
	unproject(xyz, opts) {
		const viewports = this.getViewports();
		const pixel = {
			x: xyz[0],
			y: xyz[1]
		};
		for (let i$1 = viewports.length - 1; i$1 >= 0; --i$1) {
			const viewport = viewports[i$1];
			if (viewport.containsPixel(pixel)) {
				const p$1 = xyz.slice();
				p$1[0] -= viewport.x;
				p$1[1] -= viewport.y;
				return viewport.unproject(p$1, opts);
			}
		}
		return null;
	}
	/** Update the manager with new Deck props */
	setProps(props) {
		if (props.views) this._setViews(props.views);
		if (props.viewState) this._setViewState(props.viewState);
		if ("width" in props || "height" in props) this._setSize(props.width, props.height);
		if (!this._isUpdating) this._update();
	}
	_update() {
		this._isUpdating = true;
		if (this._needsUpdate) {
			this._needsUpdate = false;
			this._rebuildViewports();
		}
		if (this._needsUpdate) {
			this._needsUpdate = false;
			this._rebuildViewports();
		}
		this._isUpdating = false;
	}
	_setSize(width, height) {
		if (width !== this.width || height !== this.height) {
			this.width = width;
			this.height = height;
			this.setNeedsUpdate("Size changed");
		}
	}
	_setViews(views) {
		views = flatten(views, Boolean);
		if (this._diffViews(views, this.views)) this.setNeedsUpdate("views changed");
		this.views = views;
	}
	_setViewState(viewState) {
		if (viewState) {
			if (!deepEqual(viewState, this.viewState, 3)) this.setNeedsUpdate("viewState changed");
			this.viewState = viewState;
		} else log_default.warn("missing `viewState` or `initialViewState`")();
	}
	_createController(view, props) {
		const Controller$1 = props.type;
		return new Controller$1({
			timeline: this.timeline,
			eventManager: this._eventManager,
			onViewStateChange: this._eventCallbacks.onViewStateChange,
			onStateChange: this._eventCallbacks.onInteractionStateChange,
			makeViewport: (viewState) => this.getView(view.id)?.makeViewport({
				viewState,
				width: this.width,
				height: this.height
			})
		});
	}
	_updateController(view, viewState, viewport, controller) {
		const controllerProps = view.controller;
		if (controllerProps && viewport) {
			const resolvedProps = {
				...viewState,
				...controllerProps,
				id: view.id,
				x: viewport.x,
				y: viewport.y,
				width: viewport.width,
				height: viewport.height
			};
			if (!controller || controller.constructor !== controllerProps.type) controller = this._createController(view, resolvedProps);
			if (controller) controller.setProps(resolvedProps);
			return controller;
		}
		return null;
	}
	_rebuildViewports() {
		const { views } = this;
		const oldControllers = this.controllers;
		this._viewports = [];
		this.controllers = {};
		let invalidateControllers = false;
		for (let i$1 = views.length; i$1--;) {
			const view = views[i$1];
			const viewState = this.getViewState(view);
			const viewport = view.makeViewport({
				viewState,
				width: this.width,
				height: this.height
			});
			let oldController = oldControllers[view.id];
			const hasController = Boolean(view.controller);
			if (hasController && !oldController) invalidateControllers = true;
			if ((invalidateControllers || !hasController) && oldController) {
				oldController.finalize();
				oldController = null;
			}
			this.controllers[view.id] = this._updateController(view, viewState, viewport, oldController);
			if (viewport) this._viewports.unshift(viewport);
		}
		for (const id in oldControllers) {
			const oldController = oldControllers[id];
			if (oldController && !this.controllers[id]) oldController.finalize();
		}
		this._buildViewportMap();
	}
	_buildViewportMap() {
		this._viewportMap = {};
		this._viewports.forEach((viewport) => {
			if (viewport.id) this._viewportMap[viewport.id] = this._viewportMap[viewport.id] || viewport;
		});
	}
	_diffViews(newViews, oldViews) {
		if (newViews.length !== oldViews.length) return true;
		return newViews.some((_$1, i$1) => !newViews[i$1].equals(oldViews[i$1]));
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/positions.js
var PERCENT_OR_PIXELS_REGEX = /([0-9]+\.?[0-9]*)(%|px)/;
function parsePosition(value) {
	switch (typeof value) {
		case "number": return {
			position: value,
			relative: false
		};
		case "string":
			const match = PERCENT_OR_PIXELS_REGEX.exec(value);
			if (match && match.length >= 3) {
				const relative = match[2] === "%";
				const position = parseFloat(match[1]);
				return {
					position: relative ? position / 100 : position,
					relative
				};
			}
		default: throw new Error(`Could not parse position string ${value}`);
	}
}
function getPosition(position, extent) {
	return position.relative ? Math.round(position.position * extent) : position.position;
}

//#endregion
//#region node_modules/@deck.gl/core/dist/views/view.js
var View = class {
	constructor(props) {
		const { id, x: x$1 = 0, y: y$1 = 0, width = "100%", height = "100%", padding = null } = props;
		this.id = id || this.constructor.displayName || "view";
		this.props = {
			...props,
			id: this.id
		};
		this._x = parsePosition(x$1);
		this._y = parsePosition(y$1);
		this._width = parsePosition(width);
		this._height = parsePosition(height);
		this._padding = padding && {
			left: parsePosition(padding.left || 0),
			right: parsePosition(padding.right || 0),
			top: parsePosition(padding.top || 0),
			bottom: parsePosition(padding.bottom || 0)
		};
		this.equals = this.equals.bind(this);
		Object.seal(this);
	}
	equals(view) {
		if (this === view) return true;
		return this.constructor === view.constructor && deepEqual(this.props, view.props, 2);
	}
	/** Clone this view with modified props */
	clone(newProps) {
		const ViewConstructor = this.constructor;
		return new ViewConstructor({
			...this.props,
			...newProps
		});
	}
	/** Make viewport from canvas dimensions and view state */
	makeViewport({ width, height, viewState }) {
		viewState = this.filterViewState(viewState);
		const viewportDimensions = this.getDimensions({
			width,
			height
		});
		if (!viewportDimensions.height || !viewportDimensions.width) return null;
		return new (this.getViewportType(viewState))({
			...viewState,
			...this.props,
			...viewportDimensions
		});
	}
	getViewStateId() {
		const { viewState } = this.props;
		if (typeof viewState === "string") return viewState;
		return viewState?.id || this.id;
	}
	filterViewState(viewState) {
		if (this.props.viewState && typeof this.props.viewState === "object") {
			if (!this.props.viewState.id) return this.props.viewState;
			const newViewState = { ...viewState };
			for (const key in this.props.viewState) if (key !== "id") newViewState[key] = this.props.viewState[key];
			return newViewState;
		}
		return viewState;
	}
	/** Resolve the dimensions of the view from overall canvas dimensions */
	getDimensions({ width, height }) {
		const dimensions = {
			x: getPosition(this._x, width),
			y: getPosition(this._y, height),
			width: getPosition(this._width, width),
			height: getPosition(this._height, height)
		};
		if (this._padding) dimensions.padding = {
			left: getPosition(this._padding.left, width),
			top: getPosition(this._padding.top, height),
			right: getPosition(this._padding.right, width),
			bottom: getPosition(this._padding.bottom, height)
		};
		return dimensions;
	}
	get controller() {
		const opts = this.props.controller;
		if (!opts) return null;
		if (opts === true) return { type: this.ControllerType };
		if (typeof opts === "function") return { type: opts };
		return {
			type: this.ControllerType,
			...opts
		};
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/transitions/transition.js
var Transition = class {
	/**
	* @params timeline {Timeline}
	*/
	constructor(timeline) {
		this._inProgress = false;
		this._handle = null;
		this.time = 0;
		this.settings = { duration: 0 };
		this._timeline = timeline;
	}
	get inProgress() {
		return this._inProgress;
	}
	/**
	* (re)start this transition.
	* @params props {object} - optional overriding props. see constructor
	*/
	start(settings) {
		this.cancel();
		this.settings = settings;
		this._inProgress = true;
		this.settings.onStart?.(this);
	}
	/**
	* end this transition if it is in progress.
	*/
	end() {
		if (this._inProgress) {
			this._timeline.removeChannel(this._handle);
			this._handle = null;
			this._inProgress = false;
			this.settings.onEnd?.(this);
		}
	}
	/**
	* cancel this transition if it is in progress.
	*/
	cancel() {
		if (this._inProgress) {
			this.settings.onInterrupt?.(this);
			this._timeline.removeChannel(this._handle);
			this._handle = null;
			this._inProgress = false;
		}
	}
	/**
	* update this transition. Returns `true` if updated.
	*/
	update() {
		if (!this._inProgress) return false;
		if (this._handle === null) {
			const { _timeline: timeline, settings } = this;
			this._handle = timeline.addChannel({
				delay: timeline.getTime(),
				duration: settings.duration
			});
		}
		this.time = this._timeline.getTime(this._handle);
		this._onUpdate();
		this.settings.onUpdate?.(this);
		if (this._timeline.isFinished(this._handle)) this.end();
		return true;
	}
	_onUpdate() {}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/controllers/transition-manager.js
var noop$1 = () => {};
const TRANSITION_EVENTS = {
	BREAK: 1,
	SNAP_TO_END: 2,
	IGNORE: 3
};
var DEFAULT_EASING = (t$1) => t$1;
var DEFAULT_INTERRUPTION = TRANSITION_EVENTS.BREAK;
var TransitionManager = class {
	constructor(opts) {
		this._onTransitionUpdate = (transition) => {
			const { time, settings: { interpolator, startProps, endProps, duration, easing } } = transition;
			const t$1 = easing(time / duration);
			const viewport = interpolator.interpolateProps(startProps, endProps, t$1);
			this.propsInTransition = this.getControllerState({
				...this.props,
				...viewport
			}).getViewportProps();
			this.onViewStateChange({
				viewState: this.propsInTransition,
				oldViewState: this.props
			});
		};
		this.getControllerState = opts.getControllerState;
		this.propsInTransition = null;
		this.transition = new Transition(opts.timeline);
		this.onViewStateChange = opts.onViewStateChange || noop$1;
		this.onStateChange = opts.onStateChange || noop$1;
	}
	finalize() {
		this.transition.cancel();
	}
	getViewportInTransition() {
		return this.propsInTransition;
	}
	processViewStateChange(nextProps) {
		let transitionTriggered = false;
		const currentProps = this.props;
		this.props = nextProps;
		if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) return false;
		if (this._isTransitionEnabled(nextProps)) {
			let startProps = currentProps;
			if (this.transition.inProgress) {
				const { interruption, endProps } = this.transition.settings;
				startProps = {
					...currentProps,
					...interruption === TRANSITION_EVENTS.SNAP_TO_END ? endProps : this.propsInTransition || currentProps
				};
			}
			this._triggerTransition(startProps, nextProps);
			transitionTriggered = true;
		} else this.transition.cancel();
		return transitionTriggered;
	}
	updateTransition() {
		this.transition.update();
	}
	_isTransitionEnabled(props) {
		const { transitionDuration, transitionInterpolator } = props;
		return (transitionDuration > 0 || transitionDuration === "auto") && Boolean(transitionInterpolator);
	}
	_isUpdateDueToCurrentTransition(props) {
		if (this.transition.inProgress && this.propsInTransition) return this.transition.settings.interpolator.arePropsEqual(props, this.propsInTransition);
		return false;
	}
	_shouldIgnoreViewportChange(currentProps, nextProps) {
		if (this.transition.inProgress) return this.transition.settings.interruption === TRANSITION_EVENTS.IGNORE || this._isUpdateDueToCurrentTransition(nextProps);
		if (this._isTransitionEnabled(nextProps)) return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);
		return true;
	}
	_triggerTransition(startProps, endProps) {
		const startViewstate = this.getControllerState(startProps);
		const endViewStateProps = this.getControllerState(endProps).shortestPathFrom(startViewstate);
		const transitionInterpolator = endProps.transitionInterpolator;
		const duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;
		if (duration === 0) return;
		const initialProps = transitionInterpolator.initializeProps(startProps, endViewStateProps);
		this.propsInTransition = {};
		const transitionSettings = {
			duration,
			easing: endProps.transitionEasing || DEFAULT_EASING,
			interpolator: transitionInterpolator,
			interruption: endProps.transitionInterruption || DEFAULT_INTERRUPTION,
			startProps: initialProps.start,
			endProps: initialProps.end,
			onStart: endProps.onTransitionStart,
			onUpdate: this._onTransitionUpdate,
			onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),
			onEnd: this._onTransitionEnd(endProps.onTransitionEnd)
		};
		this.transition.start(transitionSettings);
		this.onStateChange({ inTransition: true });
		this.updateTransition();
	}
	_onTransitionEnd(callback) {
		return (transition) => {
			this.propsInTransition = null;
			this.onStateChange({
				inTransition: false,
				isZooming: false,
				isPanning: false,
				isRotating: false
			});
			callback?.(transition);
		};
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/assert.js
function assert(condition, message) {
	if (!condition) throw new Error(message || "deck.gl: assertion failed.");
}

//#endregion
//#region node_modules/@deck.gl/core/dist/transitions/transition-interpolator.js
var TransitionInterpolator = class {
	/**
	* @param opts {array|object}
	* @param opts.compare {array} - prop names used in equality check
	* @param opts.extract {array} - prop names needed for interpolation
	* @param opts.required {array} - prop names that must be supplied
	* alternatively, supply one list of prop names as `opts` if all of the above are the same.
	*/
	constructor(opts) {
		const { compare, extract, required } = opts;
		this._propsToCompare = compare;
		this._propsToExtract = extract || compare;
		this._requiredProps = required;
	}
	/**
	* Checks if two sets of props need transition in between
	* @param currentProps {object} - a list of viewport props
	* @param nextProps {object} - a list of viewport props
	* @returns {bool} - true if two props are equivalent
	*/
	arePropsEqual(currentProps, nextProps) {
		for (const key of this._propsToCompare) if (!(key in currentProps) || !(key in nextProps) || !equals(currentProps[key], nextProps[key])) return false;
		return true;
	}
	/**
	* Called before transition starts to validate/pre-process start and end props
	* @param startProps {object} - a list of starting viewport props
	* @param endProps {object} - a list of target viewport props
	* @returns {Object} {start, end} - start and end props to be passed
	*   to `interpolateProps`
	*/
	initializeProps(startProps, endProps) {
		const startViewStateProps = {};
		const endViewStateProps = {};
		for (const key of this._propsToExtract) if (key in startProps || key in endProps) {
			startViewStateProps[key] = startProps[key];
			endViewStateProps[key] = endProps[key];
		}
		this._checkRequiredProps(startViewStateProps);
		this._checkRequiredProps(endViewStateProps);
		return {
			start: startViewStateProps,
			end: endViewStateProps
		};
	}
	/**
	* Returns transition duration
	* @param startProps {object} - a list of starting viewport props
	* @param endProps {object} - a list of target viewport props
	* @returns {Number} - transition duration in milliseconds
	*/
	getDuration(startProps, endProps) {
		return endProps.transitionDuration;
	}
	_checkRequiredProps(props) {
		if (!this._requiredProps) return;
		this._requiredProps.forEach((propName) => {
			const value = props[propName];
			assert(Number.isFinite(value) || Array.isArray(value), `${propName} is required for transition`);
		});
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/viewports/globe-viewport.js
var DEGREES_TO_RADIANS$1 = Math.PI / 180;
var RADIANS_TO_DEGREES = 180 / Math.PI;
var EARTH_RADIUS = 6370972;
var GLOBE_RADIUS = 256;
function getDistanceScales() {
	const unitsPerMeter$1 = GLOBE_RADIUS / EARTH_RADIUS;
	const unitsPerDegree = Math.PI / 180 * GLOBE_RADIUS;
	return {
		unitsPerMeter: [
			unitsPerMeter$1,
			unitsPerMeter$1,
			unitsPerMeter$1
		],
		unitsPerMeter2: [
			0,
			0,
			0
		],
		metersPerUnit: [
			1 / unitsPerMeter$1,
			1 / unitsPerMeter$1,
			1 / unitsPerMeter$1
		],
		unitsPerDegree: [
			unitsPerDegree,
			unitsPerDegree,
			unitsPerMeter$1
		],
		unitsPerDegree2: [
			0,
			0,
			0
		],
		degreesPerUnit: [
			1 / unitsPerDegree,
			1 / unitsPerDegree,
			1 / unitsPerMeter$1
		]
	};
}
var GlobeViewport = class extends viewport_default {
	constructor(opts = {}) {
		const { longitude = 0, zoom = 0, nearZMultiplier = .5, farZMultiplier = 1, resolution = 10 } = opts;
		let { latitude = 0, height, altitude = 1.5, fovy } = opts;
		latitude = Math.max(Math.min(latitude, MAX_LATITUDE), -MAX_LATITUDE);
		height = height || 1;
		if (fovy) altitude = fovyToAltitude(fovy);
		else fovy = altitudeToFovy(altitude);
		const scale$3 = Math.pow(2, zoom - zoomAdjust(latitude));
		const nearZ = opts.nearZ ?? nearZMultiplier;
		const farZ = opts.farZ ?? (altitude + GLOBE_RADIUS * 2 * scale$3 / height) * farZMultiplier;
		const viewMatrix$1 = new Matrix4().lookAt({
			eye: [
				0,
				-altitude,
				0
			],
			up: [
				0,
				0,
				1
			]
		});
		viewMatrix$1.rotateX(latitude * DEGREES_TO_RADIANS$1);
		viewMatrix$1.rotateZ(-longitude * DEGREES_TO_RADIANS$1);
		viewMatrix$1.scale(scale$3 / height);
		super({
			...opts,
			height,
			viewMatrix: viewMatrix$1,
			longitude,
			latitude,
			zoom,
			distanceScales: getDistanceScales(),
			fovy,
			focalDistance: altitude,
			near: nearZ,
			far: farZ
		});
		this.scale = scale$3;
		this.latitude = latitude;
		this.longitude = longitude;
		this.fovy = fovy;
		this.resolution = resolution;
	}
	get projectionMode() {
		return PROJECTION_MODE.GLOBE;
	}
	getDistanceScales() {
		return this.distanceScales;
	}
	getBounds(options = {}) {
		const unprojectOption = { targetZ: options.z || 0 };
		const left = this.unproject([0, this.height / 2], unprojectOption);
		const top = this.unproject([this.width / 2, 0], unprojectOption);
		const right = this.unproject([this.width, this.height / 2], unprojectOption);
		const bottom = this.unproject([this.width / 2, this.height], unprojectOption);
		if (right[0] < this.longitude) right[0] += 360;
		if (left[0] > this.longitude) left[0] -= 360;
		return [
			Math.min(left[0], right[0], top[0], bottom[0]),
			Math.min(left[1], right[1], top[1], bottom[1]),
			Math.max(left[0], right[0], top[0], bottom[0]),
			Math.max(left[1], right[1], top[1], bottom[1])
		];
	}
	unproject(xyz, { topLeft = true, targetZ } = {}) {
		const [x$1, y$1, z$1] = xyz;
		const y2 = topLeft ? y$1 : this.height - y$1;
		const { pixelUnprojectionMatrix } = this;
		let coord;
		if (Number.isFinite(z$1)) coord = transformVector(pixelUnprojectionMatrix, [
			x$1,
			y2,
			z$1,
			1
		]);
		else {
			const coord0 = transformVector(pixelUnprojectionMatrix, [
				x$1,
				y2,
				-1,
				1
			]);
			const coord1 = transformVector(pixelUnprojectionMatrix, [
				x$1,
				y2,
				1,
				1
			]);
			const lt$1 = ((targetZ || 0) / EARTH_RADIUS + 1) * GLOBE_RADIUS;
			const lSqr = sqrLen(sub([], coord0, coord1));
			const l0Sqr = sqrLen(coord0);
			const l1Sqr = sqrLen(coord1);
			const dSqr = 4 * ((4 * l0Sqr * l1Sqr - (lSqr - l0Sqr - l1Sqr) ** 2) / 16) / lSqr;
			const t$1 = (Math.sqrt(l0Sqr - dSqr) - Math.sqrt(Math.max(0, lt$1 * lt$1 - dSqr))) / Math.sqrt(lSqr);
			coord = lerp$2([], coord0, coord1, t$1);
		}
		const [X$1, Y$1, Z$1] = this.unprojectPosition(coord);
		if (Number.isFinite(z$1)) return [
			X$1,
			Y$1,
			Z$1
		];
		return Number.isFinite(targetZ) ? [
			X$1,
			Y$1,
			targetZ
		] : [X$1, Y$1];
	}
	projectPosition(xyz) {
		const [lng, lat, Z$1 = 0] = xyz;
		const lambda = lng * DEGREES_TO_RADIANS$1;
		const phi = lat * DEGREES_TO_RADIANS$1;
		const cosPhi = Math.cos(phi);
		const D$1 = (Z$1 / EARTH_RADIUS + 1) * GLOBE_RADIUS;
		return [
			Math.sin(lambda) * cosPhi * D$1,
			-Math.cos(lambda) * cosPhi * D$1,
			Math.sin(phi) * D$1
		];
	}
	unprojectPosition(xyz) {
		const [x$1, y$1, z$1] = xyz;
		const D$1 = len(xyz);
		const phi = Math.asin(z$1 / D$1);
		return [
			Math.atan2(x$1, -y$1) * RADIANS_TO_DEGREES,
			phi * RADIANS_TO_DEGREES,
			(D$1 / GLOBE_RADIUS - 1) * EARTH_RADIUS
		];
	}
	projectFlat(xyz) {
		return xyz;
	}
	unprojectFlat(xyz) {
		return xyz;
	}
	/**
	* Pan the globe using delta-based movement
	* @param coords - the geographic coordinates where the pan started
	* @param pixel - the current screen position
	* @param startPixel - the screen position where the pan started
	* @returns updated viewport options with new longitude/latitude
	*/
	panByPosition([startLng, startLat, startZoom], pixel, startPixel) {
		const rotationSpeed = .25 / Math.pow(2, this.zoom - zoomAdjust(this.latitude));
		const longitude = startLng + rotationSpeed * (startPixel[0] - pixel[0]);
		let latitude = startLat - rotationSpeed * (startPixel[1] - pixel[1]);
		latitude = Math.max(Math.min(latitude, MAX_LATITUDE), -MAX_LATITUDE);
		const out = {
			longitude,
			latitude,
			zoom: startZoom - zoomAdjust(startLat)
		};
		out.zoom += zoomAdjust(out.latitude);
		return out;
	}
};
GlobeViewport.displayName = "GlobeViewport";
var globe_viewport_default = GlobeViewport;
function zoomAdjust(latitude) {
	const scaleAdjust = Math.PI * Math.cos(latitude * Math.PI / 180);
	return Math.log2(scaleAdjust);
}
function transformVector(matrix, vector) {
	const result = transformMat4$2([], vector, matrix);
	scale$1(result, result, 1 / result[3]);
	return result;
}

//#endregion
//#region node_modules/@deck.gl/core/dist/transitions/linear-interpolator.js
var DEFAULT_PROPS = [
	"longitude",
	"latitude",
	"zoom",
	"bearing",
	"pitch"
];
var DEFAULT_REQUIRED_PROPS = [
	"longitude",
	"latitude",
	"zoom"
];
/**
* Performs linear interpolation of two view states.
*/
var LinearInterpolator = class extends TransitionInterpolator {
	/**
	* @param {Object} opts
	* @param {Array} opts.transitionProps - list of props to apply linear transition to.
	* @param {Array} opts.around - a screen point to zoom/rotate around.
	* @param {Function} opts.makeViewport - construct a viewport instance with given props.
	*/
	constructor(opts = {}) {
		const transitionProps = Array.isArray(opts) ? opts : opts.transitionProps;
		const normalizedOpts = Array.isArray(opts) ? {} : opts;
		normalizedOpts.transitionProps = Array.isArray(transitionProps) ? {
			compare: transitionProps,
			required: transitionProps
		} : transitionProps || {
			compare: DEFAULT_PROPS,
			required: DEFAULT_REQUIRED_PROPS
		};
		super(normalizedOpts.transitionProps);
		this.opts = normalizedOpts;
	}
	initializeProps(startProps, endProps) {
		const result = super.initializeProps(startProps, endProps);
		const { makeViewport, around } = this.opts;
		if (makeViewport && around) if (makeViewport(startProps) instanceof globe_viewport_default) log_default.warn("around not supported in GlobeView")();
		else {
			const startViewport = makeViewport(startProps);
			const endViewport = makeViewport(endProps);
			const aroundPosition = startViewport.unproject(around);
			result.start.around = around;
			Object.assign(result.end, {
				around: endViewport.project(aroundPosition),
				aroundPosition,
				width: endProps.width,
				height: endProps.height
			});
		}
		return result;
	}
	interpolateProps(startProps, endProps, t$1) {
		const propsInTransition = {};
		for (const key of this._propsToExtract) propsInTransition[key] = lerp(startProps[key] || 0, endProps[key] || 0, t$1);
		if (endProps.aroundPosition && this.opts.makeViewport) {
			const viewport = this.opts.makeViewport({
				...endProps,
				...propsInTransition
			});
			Object.assign(propsInTransition, viewport.panByPosition(endProps.aroundPosition, lerp(startProps.around, endProps.around, t$1)));
		}
		return propsInTransition;
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/controllers/controller.js
var NO_TRANSITION_PROPS = { transitionDuration: 0 };
var DEFAULT_INERTIA = 300;
var INERTIA_EASING = (t$1) => 1 - (1 - t$1) * (1 - t$1);
var EVENT_TYPES = {
	WHEEL: ["wheel"],
	PAN: [
		"panstart",
		"panmove",
		"panend"
	],
	PINCH: [
		"pinchstart",
		"pinchmove",
		"pinchend"
	],
	MULTI_PAN: [
		"multipanstart",
		"multipanmove",
		"multipanend"
	],
	DOUBLE_CLICK: ["dblclick"],
	KEYBOARD: ["keydown"]
};
var pinchEventWorkaround = {};
var Controller = class {
	constructor(opts) {
		this.state = {};
		this._events = {};
		this._interactionState = { isDragging: false };
		this._customEvents = [];
		this._eventStartBlocked = null;
		this._panMove = false;
		this.invertPan = false;
		this.dragMode = "rotate";
		this.inertia = 0;
		this.scrollZoom = true;
		this.dragPan = true;
		this.dragRotate = true;
		this.doubleClickZoom = true;
		this.touchZoom = true;
		this.touchRotate = false;
		this.keyboard = true;
		this.transitionManager = new TransitionManager({
			...opts,
			getControllerState: (props) => new this.ControllerState(props),
			onViewStateChange: this._onTransition.bind(this),
			onStateChange: this._setInteractionState.bind(this)
		});
		this.handleEvent = this.handleEvent.bind(this);
		this.eventManager = opts.eventManager;
		this.onViewStateChange = opts.onViewStateChange || (() => {});
		this.onStateChange = opts.onStateChange || (() => {});
		this.makeViewport = opts.makeViewport;
	}
	set events(customEvents) {
		this.toggleEvents(this._customEvents, false);
		this.toggleEvents(customEvents, true);
		this._customEvents = customEvents;
		if (this.props) this.setProps(this.props);
	}
	finalize() {
		for (const eventName in this._events) if (this._events[eventName]) this.eventManager?.off(eventName, this.handleEvent);
		this.transitionManager.finalize();
	}
	/**
	* Callback for events
	*/
	handleEvent(event) {
		this._controllerState = void 0;
		const eventStartBlocked = this._eventStartBlocked;
		switch (event.type) {
			case "panstart": return eventStartBlocked ? false : this._onPanStart(event);
			case "panmove": return this._onPan(event);
			case "panend": return this._onPanEnd(event);
			case "pinchstart": return eventStartBlocked ? false : this._onPinchStart(event);
			case "pinchmove": return this._onPinch(event);
			case "pinchend": return this._onPinchEnd(event);
			case "multipanstart": return eventStartBlocked ? false : this._onMultiPanStart(event);
			case "multipanmove": return this._onMultiPan(event);
			case "multipanend": return this._onMultiPanEnd(event);
			case "dblclick": return this._onDoubleClick(event);
			case "wheel": return this._onWheel(event);
			case "keydown": return this._onKeyDown(event);
			default: return false;
		}
	}
	get controllerState() {
		this._controllerState = this._controllerState || new this.ControllerState({
			makeViewport: this.makeViewport,
			...this.props,
			...this.state
		});
		return this._controllerState;
	}
	getCenter(event) {
		const { x: x$1, y: y$1 } = this.props;
		const { offsetCenter } = event;
		return [offsetCenter.x - x$1, offsetCenter.y - y$1];
	}
	isPointInBounds(pos, event) {
		const { width, height } = this.props;
		if (event && event.handled) return false;
		const inside = pos[0] >= 0 && pos[0] <= width && pos[1] >= 0 && pos[1] <= height;
		if (inside && event) event.stopPropagation();
		return inside;
	}
	isFunctionKeyPressed(event) {
		const { srcEvent } = event;
		return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
	}
	isDragging() {
		return this._interactionState.isDragging || false;
	}
	blockEvents(timeout) {
		const timer = setTimeout(() => {
			if (this._eventStartBlocked === timer) this._eventStartBlocked = null;
		}, timeout);
		this._eventStartBlocked = timer;
	}
	/**
	* Extract interactivity options
	*/
	setProps(props) {
		if (props.dragMode) this.dragMode = props.dragMode;
		this.props = props;
		if (!("transitionInterpolator" in props)) props.transitionInterpolator = this._getTransitionProps().transitionInterpolator;
		this.transitionManager.processViewStateChange(props);
		const { inertia } = props;
		this.inertia = Number.isFinite(inertia) ? inertia : inertia === true ? DEFAULT_INERTIA : 0;
		const { scrollZoom = true, dragPan = true, dragRotate = true, doubleClickZoom = true, touchZoom = true, touchRotate = false, keyboard = true } = props;
		const isInteractive = Boolean(this.onViewStateChange);
		this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);
		this.toggleEvents(EVENT_TYPES.PAN, isInteractive);
		this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && (touchZoom || touchRotate));
		this.toggleEvents(EVENT_TYPES.MULTI_PAN, isInteractive && touchRotate);
		this.toggleEvents(EVENT_TYPES.DOUBLE_CLICK, isInteractive && doubleClickZoom);
		this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && keyboard);
		this.scrollZoom = scrollZoom;
		this.dragPan = dragPan;
		this.dragRotate = dragRotate;
		this.doubleClickZoom = doubleClickZoom;
		this.touchZoom = touchZoom;
		this.touchRotate = touchRotate;
		this.keyboard = keyboard;
	}
	updateTransition() {
		this.transitionManager.updateTransition();
	}
	toggleEvents(eventNames, enabled) {
		if (this.eventManager) eventNames.forEach((eventName) => {
			if (this._events[eventName] !== enabled) {
				this._events[eventName] = enabled;
				if (enabled) this.eventManager.on(eventName, this.handleEvent);
				else this.eventManager.off(eventName, this.handleEvent);
			}
		});
	}
	updateViewport(newControllerState, extraProps = null, interactionState = {}) {
		const viewState = {
			...newControllerState.getViewportProps(),
			...extraProps
		};
		const changed = this.controllerState !== newControllerState;
		this.state = newControllerState.getState();
		this._setInteractionState(interactionState);
		if (changed) {
			const oldViewState = this.controllerState && this.controllerState.getViewportProps();
			if (this.onViewStateChange) this.onViewStateChange({
				viewState,
				interactionState: this._interactionState,
				oldViewState,
				viewId: this.props.id
			});
		}
	}
	_onTransition(params) {
		this.onViewStateChange({
			...params,
			interactionState: this._interactionState,
			viewId: this.props.id
		});
	}
	_setInteractionState(newStates) {
		Object.assign(this._interactionState, newStates);
		this.onStateChange(this._interactionState);
	}
	_onPanStart(event) {
		const pos = this.getCenter(event);
		if (!this.isPointInBounds(pos, event)) return false;
		let alternateMode = this.isFunctionKeyPressed(event) || event.rightButton || false;
		if (this.invertPan || this.dragMode === "pan") alternateMode = !alternateMode;
		const newControllerState = this.controllerState[alternateMode ? "panStart" : "rotateStart"]({ pos });
		this._panMove = alternateMode;
		this.updateViewport(newControllerState, NO_TRANSITION_PROPS, { isDragging: true });
		return true;
	}
	_onPan(event) {
		if (!this.isDragging()) return false;
		return this._panMove ? this._onPanMove(event) : this._onPanRotate(event);
	}
	_onPanEnd(event) {
		if (!this.isDragging()) return false;
		return this._panMove ? this._onPanMoveEnd(event) : this._onPanRotateEnd(event);
	}
	_onPanMove(event) {
		if (!this.dragPan) return false;
		const pos = this.getCenter(event);
		const newControllerState = this.controllerState.pan({ pos });
		this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
			isDragging: true,
			isPanning: true
		});
		return true;
	}
	_onPanMoveEnd(event) {
		const { inertia } = this;
		if (this.dragPan && inertia && event.velocity) {
			const pos = this.getCenter(event);
			const endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];
			const newControllerState = this.controllerState.pan({ pos: endPos }).panEnd();
			this.updateViewport(newControllerState, {
				...this._getTransitionProps(),
				transitionDuration: inertia,
				transitionEasing: INERTIA_EASING
			}, {
				isDragging: false,
				isPanning: true
			});
		} else {
			const newControllerState = this.controllerState.panEnd();
			this.updateViewport(newControllerState, null, {
				isDragging: false,
				isPanning: false
			});
		}
		return true;
	}
	_onPanRotate(event) {
		if (!this.dragRotate) return false;
		const pos = this.getCenter(event);
		const newControllerState = this.controllerState.rotate({ pos });
		this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
			isDragging: true,
			isRotating: true
		});
		return true;
	}
	_onPanRotateEnd(event) {
		const { inertia } = this;
		if (this.dragRotate && inertia && event.velocity) {
			const pos = this.getCenter(event);
			const endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];
			const newControllerState = this.controllerState.rotate({ pos: endPos }).rotateEnd();
			this.updateViewport(newControllerState, {
				...this._getTransitionProps(),
				transitionDuration: inertia,
				transitionEasing: INERTIA_EASING
			}, {
				isDragging: false,
				isRotating: true
			});
		} else {
			const newControllerState = this.controllerState.rotateEnd();
			this.updateViewport(newControllerState, null, {
				isDragging: false,
				isRotating: false
			});
		}
		return true;
	}
	_onWheel(event) {
		if (!this.scrollZoom) return false;
		const pos = this.getCenter(event);
		if (!this.isPointInBounds(pos, event)) return false;
		event.srcEvent.preventDefault();
		const { speed = .01, smooth = false } = this.scrollZoom === true ? {} : this.scrollZoom;
		const { delta } = event;
		let scale$3 = 2 / (1 + Math.exp(-Math.abs(delta * speed)));
		if (delta < 0 && scale$3 !== 0) scale$3 = 1 / scale$3;
		const transitionProps = smooth ? {
			...this._getTransitionProps({ around: pos }),
			transitionDuration: 250
		} : NO_TRANSITION_PROPS;
		const newControllerState = this.controllerState.zoom({
			pos,
			scale: scale$3
		});
		this.updateViewport(newControllerState, transitionProps, {
			isZooming: true,
			isPanning: true
		});
		if (!smooth) this._setInteractionState({
			isZooming: false,
			isPanning: false
		});
		return true;
	}
	_onMultiPanStart(event) {
		const pos = this.getCenter(event);
		if (!this.isPointInBounds(pos, event)) return false;
		const newControllerState = this.controllerState.rotateStart({ pos });
		this.updateViewport(newControllerState, NO_TRANSITION_PROPS, { isDragging: true });
		return true;
	}
	_onMultiPan(event) {
		if (!this.touchRotate) return false;
		if (!this.isDragging()) return false;
		const pos = this.getCenter(event);
		pos[0] -= event.deltaX;
		const newControllerState = this.controllerState.rotate({ pos });
		this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
			isDragging: true,
			isRotating: true
		});
		return true;
	}
	_onMultiPanEnd(event) {
		if (!this.isDragging()) return false;
		const { inertia } = this;
		if (this.touchRotate && inertia && event.velocityY) {
			const pos = this.getCenter(event);
			const endPos = [pos[0], pos[1] += event.velocityY * inertia / 2];
			const newControllerState = this.controllerState.rotate({ pos: endPos });
			this.updateViewport(newControllerState, {
				...this._getTransitionProps(),
				transitionDuration: inertia,
				transitionEasing: INERTIA_EASING
			}, {
				isDragging: false,
				isRotating: true
			});
			this.blockEvents(inertia);
		} else {
			const newControllerState = this.controllerState.rotateEnd();
			this.updateViewport(newControllerState, null, {
				isDragging: false,
				isRotating: false
			});
		}
		return true;
	}
	_onPinchStart(event) {
		const pos = this.getCenter(event);
		if (!this.isPointInBounds(pos, event)) return false;
		const newControllerState = this.controllerState.zoomStart({ pos }).rotateStart({ pos });
		pinchEventWorkaround._startPinchRotation = event.rotation;
		pinchEventWorkaround._lastPinchEvent = event;
		this.updateViewport(newControllerState, NO_TRANSITION_PROPS, { isDragging: true });
		return true;
	}
	_onPinch(event) {
		if (!this.touchZoom && !this.touchRotate) return false;
		if (!this.isDragging()) return false;
		let newControllerState = this.controllerState;
		if (this.touchZoom) {
			const { scale: scale$3 } = event;
			const pos = this.getCenter(event);
			newControllerState = newControllerState.zoom({
				pos,
				scale: scale$3
			});
		}
		if (this.touchRotate) {
			const { rotation } = event;
			newControllerState = newControllerState.rotate({ deltaAngleX: pinchEventWorkaround._startPinchRotation - rotation });
		}
		this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
			isDragging: true,
			isPanning: this.touchZoom,
			isZooming: this.touchZoom,
			isRotating: this.touchRotate
		});
		pinchEventWorkaround._lastPinchEvent = event;
		return true;
	}
	_onPinchEnd(event) {
		if (!this.isDragging()) return false;
		const { inertia } = this;
		const { _lastPinchEvent } = pinchEventWorkaround;
		if (this.touchZoom && inertia && _lastPinchEvent && event.scale !== _lastPinchEvent.scale) {
			const pos = this.getCenter(event);
			let newControllerState = this.controllerState.rotateEnd();
			const z$1 = Math.log2(event.scale);
			const velocityZ = (z$1 - Math.log2(_lastPinchEvent.scale)) / (event.deltaTime - _lastPinchEvent.deltaTime);
			const endScale = Math.pow(2, z$1 + velocityZ * inertia / 2);
			newControllerState = newControllerState.zoom({
				pos,
				scale: endScale
			}).zoomEnd();
			this.updateViewport(newControllerState, {
				...this._getTransitionProps({ around: pos }),
				transitionDuration: inertia,
				transitionEasing: INERTIA_EASING
			}, {
				isDragging: false,
				isPanning: this.touchZoom,
				isZooming: this.touchZoom,
				isRotating: false
			});
			this.blockEvents(inertia);
		} else {
			const newControllerState = this.controllerState.zoomEnd().rotateEnd();
			this.updateViewport(newControllerState, null, {
				isDragging: false,
				isPanning: false,
				isZooming: false,
				isRotating: false
			});
		}
		pinchEventWorkaround._startPinchRotation = null;
		pinchEventWorkaround._lastPinchEvent = null;
		return true;
	}
	_onDoubleClick(event) {
		if (!this.doubleClickZoom) return false;
		const pos = this.getCenter(event);
		if (!this.isPointInBounds(pos, event)) return false;
		const isZoomOut = this.isFunctionKeyPressed(event);
		const newControllerState = this.controllerState.zoom({
			pos,
			scale: isZoomOut ? .5 : 2
		});
		this.updateViewport(newControllerState, this._getTransitionProps({ around: pos }), {
			isZooming: true,
			isPanning: true
		});
		this.blockEvents(100);
		return true;
	}
	_onKeyDown(event) {
		if (!this.keyboard) return false;
		const funcKey = this.isFunctionKeyPressed(event);
		const { zoomSpeed, moveSpeed, rotateSpeedX, rotateSpeedY } = this.keyboard === true ? {} : this.keyboard;
		const { controllerState } = this;
		let newControllerState;
		const interactionState = {};
		switch (event.srcEvent.code) {
			case "Minus":
				newControllerState = funcKey ? controllerState.zoomOut(zoomSpeed).zoomOut(zoomSpeed) : controllerState.zoomOut(zoomSpeed);
				interactionState.isZooming = true;
				break;
			case "Equal":
				newControllerState = funcKey ? controllerState.zoomIn(zoomSpeed).zoomIn(zoomSpeed) : controllerState.zoomIn(zoomSpeed);
				interactionState.isZooming = true;
				break;
			case "ArrowLeft":
				if (funcKey) {
					newControllerState = controllerState.rotateLeft(rotateSpeedX);
					interactionState.isRotating = true;
				} else {
					newControllerState = controllerState.moveLeft(moveSpeed);
					interactionState.isPanning = true;
				}
				break;
			case "ArrowRight":
				if (funcKey) {
					newControllerState = controllerState.rotateRight(rotateSpeedX);
					interactionState.isRotating = true;
				} else {
					newControllerState = controllerState.moveRight(moveSpeed);
					interactionState.isPanning = true;
				}
				break;
			case "ArrowUp":
				if (funcKey) {
					newControllerState = controllerState.rotateUp(rotateSpeedY);
					interactionState.isRotating = true;
				} else {
					newControllerState = controllerState.moveUp(moveSpeed);
					interactionState.isPanning = true;
				}
				break;
			case "ArrowDown":
				if (funcKey) {
					newControllerState = controllerState.rotateDown(rotateSpeedY);
					interactionState.isRotating = true;
				} else {
					newControllerState = controllerState.moveDown(moveSpeed);
					interactionState.isPanning = true;
				}
				break;
			default: return false;
		}
		this.updateViewport(newControllerState, this._getTransitionProps(), interactionState);
		return true;
	}
	_getTransitionProps(opts) {
		const { transition } = this;
		if (!transition || !transition.transitionInterpolator) return NO_TRANSITION_PROPS;
		return opts ? {
			...transition,
			transitionInterpolator: new LinearInterpolator({
				...opts,
				...transition.transitionInterpolator.opts,
				makeViewport: this.controllerState.makeViewport
			})
		} : transition;
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/controllers/view-state.js
var ViewState = class {
	constructor(props, state) {
		this._viewportProps = this.applyConstraints(props);
		this._state = state;
	}
	getViewportProps() {
		return this._viewportProps;
	}
	getState() {
		return this._state;
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/controllers/map-controller.js
var PITCH_MOUSE_THRESHOLD = 5;
var PITCH_ACCEL = 1.2;
var MapState = class extends ViewState {
	constructor(options) {
		const { width, height, latitude, longitude, zoom, bearing = 0, pitch = 0, altitude = 1.5, position = [
			0,
			0,
			0
		], maxZoom = 20, minZoom = 0, maxPitch = 60, minPitch = 0, startPanLngLat, startZoomLngLat, startRotatePos, startBearing, startPitch, startZoom, normalize = true } = options;
		assert(Number.isFinite(longitude));
		assert(Number.isFinite(latitude));
		assert(Number.isFinite(zoom));
		super({
			width,
			height,
			latitude,
			longitude,
			zoom,
			bearing,
			pitch,
			altitude,
			maxZoom,
			minZoom,
			maxPitch,
			minPitch,
			normalize,
			position
		}, {
			startPanLngLat,
			startZoomLngLat,
			startRotatePos,
			startBearing,
			startPitch,
			startZoom
		});
		this.makeViewport = options.makeViewport;
	}
	/**
	* Start panning
	* @param {[Number, Number]} pos - position on screen where the pointer grabs
	*/
	panStart({ pos }) {
		return this._getUpdatedState({ startPanLngLat: this._unproject(pos) });
	}
	/**
	* Pan
	* @param {[Number, Number]} pos - position on screen where the pointer is
	* @param {[Number, Number], optional} startPos - where the pointer grabbed at
	*   the start of the operation. Must be supplied of `panStart()` was not called
	*/
	pan({ pos, startPos }) {
		const startPanLngLat = this.getState().startPanLngLat || this._unproject(startPos);
		if (!startPanLngLat) return this;
		const newProps = this.makeViewport(this.getViewportProps()).panByPosition(startPanLngLat, pos);
		return this._getUpdatedState(newProps);
	}
	/**
	* End panning
	* Must call if `panStart()` was called
	*/
	panEnd() {
		return this._getUpdatedState({ startPanLngLat: null });
	}
	/**
	* Start rotating
	* @param {[Number, Number]} pos - position on screen where the center is
	*/
	rotateStart({ pos }) {
		return this._getUpdatedState({
			startRotatePos: pos,
			startBearing: this.getViewportProps().bearing,
			startPitch: this.getViewportProps().pitch
		});
	}
	/**
	* Rotate
	* @param {[Number, Number]} pos - position on screen where the center is
	*/
	rotate({ pos, deltaAngleX = 0, deltaAngleY = 0 }) {
		const { startRotatePos, startBearing, startPitch } = this.getState();
		if (!startRotatePos || startBearing === void 0 || startPitch === void 0) return this;
		let newRotation;
		if (pos) newRotation = this._getNewRotation(pos, startRotatePos, startPitch, startBearing);
		else newRotation = {
			bearing: startBearing + deltaAngleX,
			pitch: startPitch + deltaAngleY
		};
		return this._getUpdatedState(newRotation);
	}
	/**
	* End rotating
	* Must call if `rotateStart()` was called
	*/
	rotateEnd() {
		return this._getUpdatedState({
			startBearing: null,
			startPitch: null
		});
	}
	/**
	* Start zooming
	* @param {[Number, Number]} pos - position on screen where the center is
	*/
	zoomStart({ pos }) {
		return this._getUpdatedState({
			startZoomLngLat: this._unproject(pos),
			startZoom: this.getViewportProps().zoom
		});
	}
	/**
	* Zoom
	* @param {[Number, Number]} pos - position on screen where the current center is
	* @param {[Number, Number]} startPos - the center position at
	*   the start of the operation. Must be supplied of `zoomStart()` was not called
	* @param {Number} scale - a number between [0, 1] specifying the accumulated
	*   relative scale.
	*/
	zoom({ pos, startPos, scale: scale$3 }) {
		let { startZoom, startZoomLngLat } = this.getState();
		if (!startZoomLngLat) {
			startZoom = this.getViewportProps().zoom;
			startZoomLngLat = this._unproject(startPos) || this._unproject(pos);
		}
		if (!startZoomLngLat) return this;
		const { maxZoom, minZoom } = this.getViewportProps();
		let zoom = startZoom + Math.log2(scale$3);
		zoom = clamp(zoom, minZoom, maxZoom);
		const zoomedViewport = this.makeViewport({
			...this.getViewportProps(),
			zoom
		});
		return this._getUpdatedState({
			zoom,
			...zoomedViewport.panByPosition(startZoomLngLat, pos)
		});
	}
	/**
	* End zooming
	* Must call if `zoomStart()` was called
	*/
	zoomEnd() {
		return this._getUpdatedState({
			startZoomLngLat: null,
			startZoom: null
		});
	}
	zoomIn(speed = 2) {
		return this._zoomFromCenter(speed);
	}
	zoomOut(speed = 2) {
		return this._zoomFromCenter(1 / speed);
	}
	moveLeft(speed = 100) {
		return this._panFromCenter([speed, 0]);
	}
	moveRight(speed = 100) {
		return this._panFromCenter([-speed, 0]);
	}
	moveUp(speed = 100) {
		return this._panFromCenter([0, speed]);
	}
	moveDown(speed = 100) {
		return this._panFromCenter([0, -speed]);
	}
	rotateLeft(speed = 15) {
		return this._getUpdatedState({ bearing: this.getViewportProps().bearing - speed });
	}
	rotateRight(speed = 15) {
		return this._getUpdatedState({ bearing: this.getViewportProps().bearing + speed });
	}
	rotateUp(speed = 10) {
		return this._getUpdatedState({ pitch: this.getViewportProps().pitch + speed });
	}
	rotateDown(speed = 10) {
		return this._getUpdatedState({ pitch: this.getViewportProps().pitch - speed });
	}
	shortestPathFrom(viewState) {
		const fromProps = viewState.getViewportProps();
		const props = { ...this.getViewportProps() };
		const { bearing, longitude } = props;
		if (Math.abs(bearing - fromProps.bearing) > 180) props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
		if (Math.abs(longitude - fromProps.longitude) > 180) props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
		return props;
	}
	applyConstraints(props) {
		const { maxZoom, minZoom, zoom } = props;
		props.zoom = clamp(zoom, minZoom, maxZoom);
		const { maxPitch, minPitch, pitch } = props;
		props.pitch = clamp(pitch, minPitch, maxPitch);
		const { normalize = true } = props;
		if (normalize) Object.assign(props, normalizeViewportProps(props));
		return props;
	}
	_zoomFromCenter(scale$3) {
		const { width, height } = this.getViewportProps();
		return this.zoom({
			pos: [width / 2, height / 2],
			scale: scale$3
		});
	}
	_panFromCenter(offset) {
		const { width, height } = this.getViewportProps();
		return this.pan({
			startPos: [width / 2, height / 2],
			pos: [width / 2 + offset[0], height / 2 + offset[1]]
		});
	}
	_getUpdatedState(newProps) {
		return new this.constructor({
			makeViewport: this.makeViewport,
			...this.getViewportProps(),
			...this.getState(),
			...newProps
		});
	}
	_unproject(pos) {
		const viewport = this.makeViewport(this.getViewportProps());
		return pos && viewport.unproject(pos);
	}
	_getNewRotation(pos, startPos, startPitch, startBearing) {
		const deltaX = pos[0] - startPos[0];
		const deltaY = pos[1] - startPos[1];
		const centerY = pos[1];
		const startY = startPos[1];
		const { width, height } = this.getViewportProps();
		const deltaScaleX = deltaX / width;
		let deltaScaleY = 0;
		if (deltaY > 0) {
			if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;
		} else if (deltaY < 0) {
			if (startY > PITCH_MOUSE_THRESHOLD) deltaScaleY = 1 - centerY / startY;
		}
		deltaScaleY = clamp(deltaScaleY, -1, 1);
		const { minPitch, maxPitch } = this.getViewportProps();
		const bearing = startBearing + 180 * deltaScaleX;
		let pitch = startPitch;
		if (deltaScaleY > 0) pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
		else if (deltaScaleY < 0) pitch = startPitch - deltaScaleY * (minPitch - startPitch);
		return {
			pitch,
			bearing
		};
	}
};
var MapController = class extends Controller {
	constructor() {
		super(...arguments);
		this.ControllerState = MapState;
		this.transition = {
			transitionDuration: 300,
			transitionInterpolator: new LinearInterpolator({ transitionProps: {
				compare: [
					"longitude",
					"latitude",
					"zoom",
					"bearing",
					"pitch",
					"position"
				],
				required: [
					"longitude",
					"latitude",
					"zoom"
				]
			} })
		};
		this.dragMode = "pan";
	}
	setProps(props) {
		props.position = props.position || [
			0,
			0,
			0
		];
		const oldProps = this.props;
		super.setProps(props);
		if (!oldProps || oldProps.height !== props.height) this.updateViewport(new this.ControllerState({
			makeViewport: this.makeViewport,
			...props,
			...this.state
		}));
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/views/map-view.js
var MapView = class extends View {
	constructor(props = {}) {
		super(props);
	}
	getViewportType() {
		return web_mercator_viewport_default;
	}
	get ControllerType() {
		return MapController;
	}
};
MapView.displayName = "MapView";
var map_view_default = MapView;

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/effect-manager.js
var DEFAULT_LIGHTING_EFFECT = new LightingEffect();
/** Sort two effects. Returns 0 if equal, negative if e1 < e2, positive if e1 > e2 */
function compareEffects(e1, e2) {
	return (e1.order ?? Infinity) - (e2.order ?? Infinity);
}
var EffectManager = class {
	constructor(context) {
		this._resolvedEffects = [];
		/** Effect instances and order preference pairs, sorted by order */
		this._defaultEffects = [];
		this.effects = [];
		this._context = context;
		this._needsRedraw = "Initial render";
		this._setEffects([]);
	}
	/**
	* Register a new default effect, i.e. an effect presents regardless of user supplied props.effects
	*/
	addDefaultEffect(effect) {
		const defaultEffects = this._defaultEffects;
		if (!defaultEffects.find((e$2) => e$2.id === effect.id)) {
			const index = defaultEffects.findIndex((e$2) => compareEffects(e$2, effect) > 0);
			if (index < 0) defaultEffects.push(effect);
			else defaultEffects.splice(index, 0, effect);
			effect.setup(this._context);
			this._setEffects(this.effects);
		}
	}
	setProps(props) {
		if ("effects" in props) {
			if (!deepEqual(props.effects, this.effects, 1)) this._setEffects(props.effects);
		}
	}
	needsRedraw(opts = { clearRedrawFlags: false }) {
		const redraw = this._needsRedraw;
		if (opts.clearRedrawFlags) this._needsRedraw = false;
		return redraw;
	}
	getEffects() {
		return this._resolvedEffects;
	}
	_setEffects(effects) {
		const oldEffectsMap = {};
		for (const effect of this.effects) oldEffectsMap[effect.id] = effect;
		const nextEffects = [];
		for (const effect of effects) {
			const oldEffect = oldEffectsMap[effect.id];
			let effectToAdd = effect;
			if (oldEffect && oldEffect !== effect) if (oldEffect.setProps) {
				oldEffect.setProps(effect.props);
				effectToAdd = oldEffect;
			} else oldEffect.cleanup(this._context);
			else if (!oldEffect) effect.setup(this._context);
			nextEffects.push(effectToAdd);
			delete oldEffectsMap[effect.id];
		}
		for (const removedEffectId in oldEffectsMap) oldEffectsMap[removedEffectId].cleanup(this._context);
		this.effects = nextEffects;
		this._resolvedEffects = nextEffects.concat(this._defaultEffects);
		if (!effects.some((effect) => effect instanceof LightingEffect)) this._resolvedEffects.push(DEFAULT_LIGHTING_EFFECT);
		this._needsRedraw = "effects changed";
	}
	finalize() {
		for (const effect of this._resolvedEffects) effect.cleanup(this._context);
		this.effects.length = 0;
		this._resolvedEffects.length = 0;
		this._defaultEffects.length = 0;
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/passes/draw-layers-pass.js
var DrawLayersPass = class extends LayersPass {
	shouldDrawLayer(layer) {
		const { operation } = layer.props;
		return operation.includes("draw") || operation.includes("terrain");
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/deck-renderer.js
var TRACE_RENDER_LAYERS$1 = "deckRenderer.renderLayers";
var DeckRenderer = class {
	constructor(device) {
		this.device = device;
		this.layerFilter = null;
		this.drawPickingColors = false;
		this.drawLayersPass = new DrawLayersPass(device);
		this.pickLayersPass = new PickLayersPass(device);
		this.renderCount = 0;
		this._needsRedraw = "Initial render";
		this.renderBuffers = [];
		this.lastPostProcessEffect = null;
	}
	setProps(props) {
		if (this.layerFilter !== props.layerFilter) {
			this.layerFilter = props.layerFilter;
			this._needsRedraw = "layerFilter changed";
		}
		if (this.drawPickingColors !== props.drawPickingColors) {
			this.drawPickingColors = props.drawPickingColors;
			this._needsRedraw = "drawPickingColors changed";
		}
	}
	renderLayers(opts) {
		if (!opts.viewports.length) return;
		const layerPass = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;
		const renderOpts = {
			layerFilter: this.layerFilter,
			isPicking: this.drawPickingColors,
			...opts
		};
		if (renderOpts.effects) this._preRender(renderOpts.effects, renderOpts);
		const outputBuffer = this.lastPostProcessEffect ? this.renderBuffers[0] : renderOpts.target;
		if (this.lastPostProcessEffect) {
			renderOpts.clearColor = [
				0,
				0,
				0,
				0
			];
			renderOpts.clearCanvas = true;
		}
		const renderStats = layerPass.render({
			...renderOpts,
			target: outputBuffer
		});
		if (renderOpts.effects) {
			if (this.lastPostProcessEffect) renderOpts.clearCanvas = opts.clearCanvas === void 0 ? true : opts.clearCanvas;
			this._postRender(renderOpts.effects, renderOpts);
		}
		this.renderCount++;
		debug(TRACE_RENDER_LAYERS$1, this, renderStats, opts);
	}
	needsRedraw(opts = { clearRedrawFlags: false }) {
		const redraw = this._needsRedraw;
		if (opts.clearRedrawFlags) this._needsRedraw = false;
		return redraw;
	}
	finalize() {
		const { renderBuffers } = this;
		for (const buffer of renderBuffers) buffer.delete();
		renderBuffers.length = 0;
	}
	_preRender(effects, opts) {
		this.lastPostProcessEffect = null;
		opts.preRenderStats = opts.preRenderStats || {};
		for (const effect of effects) {
			opts.preRenderStats[effect.id] = effect.preRender(opts);
			if (effect.postRender) this.lastPostProcessEffect = effect.id;
		}
		if (this.lastPostProcessEffect) this._resizeRenderBuffers();
	}
	_resizeRenderBuffers() {
		const { renderBuffers } = this;
		const size = this.device.canvasContext.getDrawingBufferSize();
		const [width, height] = size;
		if (renderBuffers.length === 0) [0, 1].map((i$1) => {
			const texture = this.device.createTexture({
				sampler: {
					minFilter: "linear",
					magFilter: "linear"
				},
				width,
				height
			});
			renderBuffers.push(this.device.createFramebuffer({
				id: `deck-renderbuffer-${i$1}`,
				colorAttachments: [texture]
			}));
		});
		for (const buffer of renderBuffers) buffer.resize(size);
	}
	_postRender(effects, opts) {
		const { renderBuffers } = this;
		const params = {
			...opts,
			inputBuffer: renderBuffers[0],
			swapBuffer: renderBuffers[1]
		};
		for (const effect of effects) if (effect.postRender) {
			params.target = effect.id === this.lastPostProcessEffect ? opts.target : void 0;
			const buffer = effect.postRender(params);
			params.inputBuffer = buffer;
			params.swapBuffer = buffer === renderBuffers[0] ? renderBuffers[1] : renderBuffers[0];
		}
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/picking/query-object.js
var NO_PICKED_OBJECT = {
	pickedColor: null,
	pickedObjectIndex: -1
};
/**
* Pick at a specified pixel with a tolerance radius
* Returns the closest object to the pixel in shape `{pickedColor, pickedLayer, pickedObjectIndex}`
*/
function getClosestObject({ pickedColors, decodePickingColor, deviceX, deviceY, deviceRadius, deviceRect }) {
	const { x: x$1, y: y$1, width, height } = deviceRect;
	let minSquareDistanceToCenter = deviceRadius * deviceRadius;
	let closestPixelIndex = -1;
	let i$1 = 0;
	for (let row = 0; row < height; row++) {
		const dy = row + y$1 - deviceY;
		const dy2 = dy * dy;
		if (dy2 > minSquareDistanceToCenter) i$1 += 4 * width;
		else for (let col = 0; col < width; col++) {
			if (pickedColors[i$1 + 3] - 1 >= 0) {
				const dx = col + x$1 - deviceX;
				const d2 = dx * dx + dy2;
				if (d2 <= minSquareDistanceToCenter) {
					minSquareDistanceToCenter = d2;
					closestPixelIndex = i$1;
				}
			}
			i$1 += 4;
		}
	}
	if (closestPixelIndex >= 0) {
		const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);
		const pickedObject = decodePickingColor(pickedColor);
		if (pickedObject) {
			const dy = Math.floor(closestPixelIndex / 4 / width);
			const dx = closestPixelIndex / 4 - dy * width;
			return {
				...pickedObject,
				pickedColor,
				pickedX: x$1 + dx,
				pickedY: y$1 + dy
			};
		}
		log_default.error("Picked non-existent layer. Is picking buffer corrupt?")();
	}
	return NO_PICKED_OBJECT;
}
/**
* Examines a picking buffer for unique colors
* Returns array of unique objects in shape `{x, y, pickedColor, pickedLayer, pickedObjectIndex}`
*/
function getUniqueObjects({ pickedColors, decodePickingColor }) {
	const uniqueColors = /* @__PURE__ */ new Map();
	if (pickedColors) {
		for (let i$1 = 0; i$1 < pickedColors.length; i$1 += 4) if (pickedColors[i$1 + 3] - 1 >= 0) {
			const pickedColor = pickedColors.slice(i$1, i$1 + 4);
			const colorKey = pickedColor.join(",");
			if (!uniqueColors.has(colorKey)) {
				const pickedObject = decodePickingColor(pickedColor);
				if (pickedObject) uniqueColors.set(colorKey, {
					...pickedObject,
					color: pickedColor
				});
				else log_default.error("Picked non-existent layer. Is picking buffer corrupt?")();
			}
		}
	}
	return Array.from(uniqueColors.values());
}

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/picking/pick-info.js
/** Generates some basic information of the picking action: x, y, coordinates etc.
* Regardless if anything is picked
*/
function getEmptyPickingInfo({ pickInfo, viewports, pixelRatio, x: x$1, y: y$1, z: z$1 }) {
	let pickedViewport = viewports[0];
	if (viewports.length > 1) pickedViewport = getViewportFromCoordinates(pickInfo?.pickedViewports || viewports, {
		x: x$1,
		y: y$1
	});
	let coordinate;
	if (pickedViewport) {
		const point = [x$1 - pickedViewport.x, y$1 - pickedViewport.y];
		if (z$1 !== void 0) point[2] = z$1;
		coordinate = pickedViewport.unproject(point);
	}
	return {
		color: null,
		layer: null,
		viewport: pickedViewport,
		index: -1,
		picked: false,
		x: x$1,
		y: y$1,
		pixel: [x$1, y$1],
		coordinate,
		devicePixel: pickInfo && "pickedX" in pickInfo ? [pickInfo.pickedX, pickInfo.pickedY] : void 0,
		pixelRatio
	};
}
/** Generates the picking info of a picking operation */
function processPickInfo(opts) {
	const { pickInfo, lastPickedInfo, mode, layers } = opts;
	const { pickedColor, pickedLayer, pickedObjectIndex } = pickInfo;
	const affectedLayers = pickedLayer ? [pickedLayer] : [];
	if (mode === "hover") {
		const lastPickedPixelIndex = lastPickedInfo.index;
		const lastPickedLayerId = lastPickedInfo.layerId;
		const pickedLayerId = pickedLayer ? pickedLayer.props.id : null;
		if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedPixelIndex) {
			if (pickedLayerId !== lastPickedLayerId) {
				const lastPickedLayer = layers.find((layer) => layer.props.id === lastPickedLayerId);
				if (lastPickedLayer) affectedLayers.unshift(lastPickedLayer);
			}
			lastPickedInfo.layerId = pickedLayerId;
			lastPickedInfo.index = pickedObjectIndex;
			lastPickedInfo.info = null;
		}
	}
	const baseInfo = getEmptyPickingInfo(opts);
	const infos = /* @__PURE__ */ new Map();
	infos.set(null, baseInfo);
	affectedLayers.forEach((layer) => {
		let info = { ...baseInfo };
		if (layer === pickedLayer) {
			info.color = pickedColor;
			info.index = pickedObjectIndex;
			info.picked = true;
		}
		info = getLayerPickingInfo({
			layer,
			info,
			mode
		});
		const rootLayer = info.layer;
		if (layer === pickedLayer && mode === "hover") lastPickedInfo.info = info;
		infos.set(rootLayer.id, info);
		if (mode === "hover") rootLayer.updateAutoHighlight(info);
	});
	return infos;
}
/** Walk up the layer composite chain to populate the info object */
function getLayerPickingInfo({ layer, info, mode }) {
	while (layer && info) {
		const sourceLayer = info.layer || null;
		info.sourceLayer = sourceLayer;
		info.layer = layer;
		info = layer.getPickingInfo({
			info,
			mode,
			sourceLayer
		});
		layer = layer.parent;
	}
	return info;
}
/** Indentifies which viewport, if any corresponds to x and y
If multiple viewports contain the target pixel, last viewport drawn is returend
Returns first viewport if no match */
function getViewportFromCoordinates(viewports, pixel) {
	for (let i$1 = viewports.length - 1; i$1 >= 0; i$1--) {
		const viewport = viewports[i$1];
		if (viewport.containsPixel(pixel)) return viewport;
	}
	return viewports[0];
}

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/deck-picker.js
/** Manages picking in a Deck context */
var DeckPicker = class {
	constructor(device) {
		this._pickable = true;
		this.device = device;
		this.pickLayersPass = new PickLayersPass(device);
		this.lastPickedInfo = {
			index: -1,
			layerId: null,
			info: null
		};
	}
	setProps(props) {
		if ("layerFilter" in props) this.layerFilter = props.layerFilter;
		if ("_pickable" in props) this._pickable = props._pickable;
	}
	finalize() {
		if (this.pickingFBO) this.pickingFBO.destroy();
		if (this.depthFBO) this.depthFBO.destroy();
	}
	/**
	* Pick the closest info at given coordinate
	* @returns Promise that resolves with picking info
	*/
	pickObjectAsync(opts) {
		return this._pickClosestObjectAsync(opts);
	}
	/**
	* Picks a list of unique infos within a bounding box
	* @returns Promise that resolves to all unique infos within a bounding box
	*/
	pickObjectsAsync(opts) {
		return this._pickVisibleObjectsAsync(opts);
	}
	/**
	* Pick the closest info at given coordinate
	* @returns picking info
	* @deprecated WebGL only - use pickObjectAsync instead
	*/
	pickObject(opts) {
		return this._pickClosestObject(opts);
	}
	/**
	* Get all unique infos within a bounding box
	* @returns all unique infos within a bounding box
	* @deprecated WebGL only - use pickObjectAsync instead
	*/
	pickObjects(opts) {
		return this._pickVisibleObjects(opts);
	}
	getLastPickedObject({ x: x$1, y: y$1, layers, viewports }, lastPickedInfo = this.lastPickedInfo.info) {
		const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;
		const lastPickedViewportId = lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;
		const layer = lastPickedLayerId ? layers.find((l$1) => l$1.id === lastPickedLayerId) : null;
		const viewport = lastPickedViewportId && viewports.find((v$1) => v$1.id === lastPickedViewportId) || viewports[0];
		const info = {
			x: x$1,
			y: y$1,
			viewport,
			coordinate: viewport && viewport.unproject([x$1 - viewport.x, y$1 - viewport.y]),
			layer
		};
		return {
			...lastPickedInfo,
			...info
		};
	}
	/** Ensures that picking framebuffer exists and matches the canvas size */
	_resizeBuffer() {
		if (!this.pickingFBO) {
			this.pickingFBO = this.device.createFramebuffer({
				colorAttachments: ["rgba8unorm"],
				depthStencilAttachment: "depth16unorm"
			});
			if (this.device.isTextureFormatRenderable("rgba32float")) this.depthFBO = this.device.createFramebuffer({
				colorAttachments: ["rgba32float"],
				depthStencilAttachment: "depth16unorm"
			});
		}
		const { canvas: canvas$1 } = this.device.getDefaultCanvasContext();
		this.pickingFBO?.resize({
			width: canvas$1.width,
			height: canvas$1.height
		});
		this.depthFBO?.resize({
			width: canvas$1.width,
			height: canvas$1.height
		});
	}
	/** Preliminary filtering of the layers list. Skid picking pass if no layer is pickable. */
	_getPickable(layers) {
		if (this._pickable === false) return null;
		const pickableLayers = layers.filter((layer) => this.pickLayersPass.shouldDrawLayer(layer) && !layer.isComposite);
		return pickableLayers.length ? pickableLayers : null;
	}
	/**
	* Pick the closest object at the given coordinate
	*/
	async _pickClosestObjectAsync({ layers, views, viewports, x: x$1, y: y$1, radius = 0, depth = 1, mode = "query", unproject3D, onViewportActive, effects }) {
		const pixelRatio = this.device.canvasContext.cssToDeviceRatio();
		const pickableLayers = this._getPickable(layers);
		if (!pickableLayers || viewports.length === 0) return {
			result: [],
			emptyInfo: getEmptyPickingInfo({
				viewports,
				x: x$1,
				y: y$1,
				pixelRatio
			})
		};
		this._resizeBuffer();
		const devicePixelRange = this.device.canvasContext.cssToDevicePixels([x$1, y$1], true);
		const devicePixel = [devicePixelRange.x + Math.floor(devicePixelRange.width / 2), devicePixelRange.y + Math.floor(devicePixelRange.height / 2)];
		const deviceRadius = Math.round(radius * pixelRatio);
		const { width, height } = this.pickingFBO;
		const deviceRect = this._getPickingRect({
			deviceX: devicePixel[0],
			deviceY: devicePixel[1],
			deviceRadius,
			deviceWidth: width,
			deviceHeight: height
		});
		const cullRect = {
			x: x$1 - radius,
			y: y$1 - radius,
			width: radius * 2 + 1,
			height: radius * 2 + 1
		};
		let infos;
		const result = [];
		const affectedLayers = /* @__PURE__ */ new Set();
		for (let i$1 = 0; i$1 < depth; i$1++) {
			let pickInfo;
			if (deviceRect) pickInfo = getClosestObject({
				...this._drawAndSample({
					layers: pickableLayers,
					views,
					viewports,
					onViewportActive,
					deviceRect,
					cullRect,
					effects,
					pass: `picking:${mode}`
				}),
				deviceX: devicePixel[0],
				deviceY: devicePixel[1],
				deviceRadius,
				deviceRect
			});
			else pickInfo = {
				pickedColor: null,
				pickedObjectIndex: -1
			};
			let z$1;
			if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {
				const { pickedColors: pickedColors2 } = this._drawAndSample({
					layers: [pickInfo.pickedLayer],
					views,
					viewports,
					onViewportActive,
					deviceRect: {
						x: pickInfo.pickedX,
						y: pickInfo.pickedY,
						width: 1,
						height: 1
					},
					cullRect,
					effects,
					pass: `picking:${mode}:z`
				}, true);
				if (pickedColors2[3]) z$1 = pickedColors2[0];
			}
			if (pickInfo.pickedLayer && i$1 + 1 < depth) {
				affectedLayers.add(pickInfo.pickedLayer);
				pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);
			}
			infos = processPickInfo({
				pickInfo,
				lastPickedInfo: this.lastPickedInfo,
				mode,
				layers: pickableLayers,
				viewports,
				x: x$1,
				y: y$1,
				z: z$1,
				pixelRatio
			});
			for (const info of infos.values()) if (info.layer) result.push(info);
			if (!pickInfo.pickedColor) break;
		}
		for (const layer of affectedLayers) layer.restorePickingColors();
		return {
			result,
			emptyInfo: infos.get(null)
		};
	}
	/**
	* Pick the closest object at the given coordinate
	* @deprecated WebGL only
	*/
	_pickClosestObject({ layers, views, viewports, x: x$1, y: y$1, radius = 0, depth = 1, mode = "query", unproject3D, onViewportActive, effects }) {
		const pixelRatio = this.device.canvasContext.cssToDeviceRatio();
		const pickableLayers = this._getPickable(layers);
		if (!pickableLayers || viewports.length === 0) return {
			result: [],
			emptyInfo: getEmptyPickingInfo({
				viewports,
				x: x$1,
				y: y$1,
				pixelRatio
			})
		};
		this._resizeBuffer();
		const devicePixelRange = this.device.canvasContext.cssToDevicePixels([x$1, y$1], true);
		const devicePixel = [devicePixelRange.x + Math.floor(devicePixelRange.width / 2), devicePixelRange.y + Math.floor(devicePixelRange.height / 2)];
		const deviceRadius = Math.round(radius * pixelRatio);
		const { width, height } = this.pickingFBO;
		const deviceRect = this._getPickingRect({
			deviceX: devicePixel[0],
			deviceY: devicePixel[1],
			deviceRadius,
			deviceWidth: width,
			deviceHeight: height
		});
		const cullRect = {
			x: x$1 - radius,
			y: y$1 - radius,
			width: radius * 2 + 1,
			height: radius * 2 + 1
		};
		let infos;
		const result = [];
		const affectedLayers = /* @__PURE__ */ new Set();
		for (let i$1 = 0; i$1 < depth; i$1++) {
			let pickInfo;
			if (deviceRect) pickInfo = getClosestObject({
				...this._drawAndSample({
					layers: pickableLayers,
					views,
					viewports,
					onViewportActive,
					deviceRect,
					cullRect,
					effects,
					pass: `picking:${mode}`
				}),
				deviceX: devicePixel[0],
				deviceY: devicePixel[1],
				deviceRadius,
				deviceRect
			});
			else pickInfo = {
				pickedColor: null,
				pickedObjectIndex: -1
			};
			let z$1;
			if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {
				const { pickedColors: pickedColors2 } = this._drawAndSample({
					layers: [pickInfo.pickedLayer],
					views,
					viewports,
					onViewportActive,
					deviceRect: {
						x: pickInfo.pickedX,
						y: pickInfo.pickedY,
						width: 1,
						height: 1
					},
					cullRect,
					effects,
					pass: `picking:${mode}:z`
				}, true);
				if (pickedColors2[3]) z$1 = pickedColors2[0];
			}
			if (pickInfo.pickedLayer && i$1 + 1 < depth) {
				affectedLayers.add(pickInfo.pickedLayer);
				pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);
			}
			infos = processPickInfo({
				pickInfo,
				lastPickedInfo: this.lastPickedInfo,
				mode,
				layers: pickableLayers,
				viewports,
				x: x$1,
				y: y$1,
				z: z$1,
				pixelRatio
			});
			for (const info of infos.values()) if (info.layer) result.push(info);
			if (!pickInfo.pickedColor) break;
		}
		for (const layer of affectedLayers) layer.restorePickingColors();
		return {
			result,
			emptyInfo: infos.get(null)
		};
	}
	/**
	* Pick all objects within the given bounding box
	*/
	async _pickVisibleObjectsAsync({ layers, views, viewports, x: x$1, y: y$1, width = 1, height = 1, mode = "query", maxObjects = null, onViewportActive, effects }) {
		const pickableLayers = this._getPickable(layers);
		if (!pickableLayers || viewports.length === 0) return [];
		this._resizeBuffer();
		const pixelRatio = this.device.canvasContext.cssToDeviceRatio();
		const leftTop = this.device.canvasContext.cssToDevicePixels([x$1, y$1], true);
		const deviceLeft = leftTop.x;
		const deviceTop = leftTop.y + leftTop.height;
		const rightBottom = this.device.canvasContext.cssToDevicePixels([x$1 + width, y$1 + height], true);
		const deviceRight = rightBottom.x + rightBottom.width;
		const deviceBottom = rightBottom.y;
		const deviceRect = {
			x: deviceLeft,
			y: deviceBottom,
			width: deviceRight - deviceLeft,
			height: deviceTop - deviceBottom
		};
		const pickInfos = getUniqueObjects(this._drawAndSample({
			layers: pickableLayers,
			views,
			viewports,
			onViewportActive,
			deviceRect,
			cullRect: {
				x: x$1,
				y: y$1,
				width,
				height
			},
			effects,
			pass: `picking:${mode}`
		}));
		const uniquePickedObjects = /* @__PURE__ */ new Map();
		const uniqueInfos = [];
		const limitMaxObjects = Number.isFinite(maxObjects);
		for (let i$1 = 0; i$1 < pickInfos.length; i$1++) {
			if (limitMaxObjects && uniqueInfos.length >= maxObjects) break;
			const pickInfo = pickInfos[i$1];
			let info = {
				color: pickInfo.pickedColor,
				layer: null,
				index: pickInfo.pickedObjectIndex,
				picked: true,
				x: x$1,
				y: y$1,
				pixelRatio
			};
			info = getLayerPickingInfo({
				layer: pickInfo.pickedLayer,
				info,
				mode
			});
			const pickedLayerId = info.layer.id;
			if (!uniquePickedObjects.has(pickedLayerId)) uniquePickedObjects.set(pickedLayerId, /* @__PURE__ */ new Set());
			const uniqueObjectsInLayer = uniquePickedObjects.get(pickedLayerId);
			const pickedObjectKey = info.object ?? info.index;
			if (!uniqueObjectsInLayer.has(pickedObjectKey)) {
				uniqueObjectsInLayer.add(pickedObjectKey);
				uniqueInfos.push(info);
			}
		}
		return uniqueInfos;
	}
	/**
	* Pick all objects within the given bounding box
	* @deprecated WebGL only
	*/
	_pickVisibleObjects({ layers, views, viewports, x: x$1, y: y$1, width = 1, height = 1, mode = "query", maxObjects = null, onViewportActive, effects }) {
		const pickableLayers = this._getPickable(layers);
		if (!pickableLayers || viewports.length === 0) return [];
		this._resizeBuffer();
		const pixelRatio = this.device.canvasContext.cssToDeviceRatio();
		const leftTop = this.device.canvasContext.cssToDevicePixels([x$1, y$1], true);
		const deviceLeft = leftTop.x;
		const deviceTop = leftTop.y + leftTop.height;
		const rightBottom = this.device.canvasContext.cssToDevicePixels([x$1 + width, y$1 + height], true);
		const deviceRight = rightBottom.x + rightBottom.width;
		const deviceBottom = rightBottom.y;
		const deviceRect = {
			x: deviceLeft,
			y: deviceBottom,
			width: deviceRight - deviceLeft,
			height: deviceTop - deviceBottom
		};
		const pickInfos = getUniqueObjects(this._drawAndSample({
			layers: pickableLayers,
			views,
			viewports,
			onViewportActive,
			deviceRect,
			cullRect: {
				x: x$1,
				y: y$1,
				width,
				height
			},
			effects,
			pass: `picking:${mode}`
		}));
		const uniquePickedObjects = /* @__PURE__ */ new Map();
		const uniqueInfos = [];
		const limitMaxObjects = Number.isFinite(maxObjects);
		for (let i$1 = 0; i$1 < pickInfos.length; i$1++) {
			if (limitMaxObjects && uniqueInfos.length >= maxObjects) break;
			const pickInfo = pickInfos[i$1];
			let info = {
				color: pickInfo.pickedColor,
				layer: null,
				index: pickInfo.pickedObjectIndex,
				picked: true,
				x: x$1,
				y: y$1,
				pixelRatio
			};
			info = getLayerPickingInfo({
				layer: pickInfo.pickedLayer,
				info,
				mode
			});
			const pickedLayerId = info.layer.id;
			if (!uniquePickedObjects.has(pickedLayerId)) uniquePickedObjects.set(pickedLayerId, /* @__PURE__ */ new Set());
			const uniqueObjectsInLayer = uniquePickedObjects.get(pickedLayerId);
			const pickedObjectKey = info.object ?? info.index;
			if (!uniqueObjectsInLayer.has(pickedObjectKey)) {
				uniqueObjectsInLayer.add(pickedObjectKey);
				uniqueInfos.push(info);
			}
		}
		return uniqueInfos;
	}
	async _drawAndSampleAsync({ layers, views, viewports, onViewportActive, deviceRect, cullRect, effects, pass }, pickZ = false) {
		const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;
		const opts = {
			layers,
			layerFilter: this.layerFilter,
			views,
			viewports,
			onViewportActive,
			pickingFBO,
			deviceRect,
			cullRect,
			effects,
			pass,
			pickZ,
			preRenderStats: {},
			isPicking: true
		};
		for (const effect of effects) if (effect.useInPicking) opts.preRenderStats[effect.id] = effect.preRender(opts);
		const { decodePickingColor } = this.pickLayersPass.render(opts);
		const { x: x$1, y: y$1, width, height } = deviceRect;
		const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);
		this.device.readPixelsToArrayWebGL(pickingFBO, {
			sourceX: x$1,
			sourceY: y$1,
			sourceWidth: width,
			sourceHeight: height,
			target: pickedColors
		});
		return {
			pickedColors,
			decodePickingColor
		};
	}
	_drawAndSample({ layers, views, viewports, onViewportActive, deviceRect, cullRect, effects, pass }, pickZ = false) {
		const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;
		const opts = {
			layers,
			layerFilter: this.layerFilter,
			views,
			viewports,
			onViewportActive,
			pickingFBO,
			deviceRect,
			cullRect,
			effects,
			pass,
			pickZ,
			preRenderStats: {},
			isPicking: true
		};
		for (const effect of effects) if (effect.useInPicking) opts.preRenderStats[effect.id] = effect.preRender(opts);
		const { decodePickingColor } = this.pickLayersPass.render(opts);
		const { x: x$1, y: y$1, width, height } = deviceRect;
		const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);
		this.device.readPixelsToArrayWebGL(pickingFBO, {
			sourceX: x$1,
			sourceY: y$1,
			sourceWidth: width,
			sourceHeight: height,
			target: pickedColors
		});
		return {
			pickedColors,
			decodePickingColor
		};
	}
	/**
	* Calculate a picking rect centered on deviceX and deviceY and clipped to device
	* @returns null if pixel is outside of device
	*/
	_getPickingRect({ deviceX, deviceY, deviceRadius, deviceWidth, deviceHeight }) {
		const x$1 = Math.max(0, deviceX - deviceRadius);
		const y$1 = Math.max(0, deviceY - deviceRadius);
		const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x$1;
		const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y$1;
		if (width <= 0 || height <= 0) return null;
		return {
			x: x$1,
			y: y$1,
			width,
			height
		};
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/widget-manager.js
var PLACEMENTS = {
	"top-left": {
		top: 0,
		left: 0
	},
	"top-right": {
		top: 0,
		right: 0
	},
	"bottom-left": {
		bottom: 0,
		left: 0
	},
	"bottom-right": {
		bottom: 0,
		right: 0
	},
	fill: {
		top: 0,
		left: 0,
		bottom: 0,
		right: 0
	}
};
var DEFAULT_PLACEMENT = "top-left";
var ROOT_CONTAINER_ID = "root";
var WidgetManager = class {
	constructor({ deck, parentElement }) {
		/** Widgets added via the imperative API */
		this.defaultWidgets = [];
		/** Widgets received from the declarative API */
		this.widgets = [];
		/** Resolved widgets from both imperative and declarative APIs */
		this.resolvedWidgets = [];
		/** Mounted HTML containers */
		this.containers = {};
		/** Viewport provided to widget on redraw */
		this.lastViewports = {};
		this.deck = deck;
		parentElement?.classList.add("deck-widget-container");
		this.parentElement = parentElement;
	}
	getWidgets() {
		return this.resolvedWidgets;
	}
	/** Declarative API to configure widgets */
	setProps(props) {
		if (props.widgets && !deepEqual(props.widgets, this.widgets, 1)) {
			const nextWidgets = props.widgets.filter(Boolean);
			this._setWidgets(nextWidgets);
		}
	}
	finalize() {
		for (const widget of this.getWidgets()) this._removeWidget(widget);
		this.defaultWidgets.length = 0;
		this.resolvedWidgets.length = 0;
		for (const id in this.containers) this.containers[id].remove();
	}
	/** Imperative API. Widgets added this way are not affected by the declarative prop. */
	addDefault(widget) {
		if (!this.defaultWidgets.find((w$1) => w$1.id === widget.id)) {
			this._addWidget(widget);
			this.defaultWidgets.push(widget);
			this._setWidgets(this.widgets);
		}
	}
	onRedraw({ viewports, layers }) {
		const viewportsById = viewports.reduce((acc, v$1) => {
			acc[v$1.id] = v$1;
			return acc;
		}, {});
		for (const widget of this.getWidgets()) {
			const { viewId } = widget;
			if (viewId) {
				const viewport = viewportsById[viewId];
				if (viewport) {
					if (widget.onViewportChange) widget.onViewportChange(viewport);
					widget.onRedraw?.({
						viewports: [viewport],
						layers
					});
				}
			} else {
				if (widget.onViewportChange) for (const viewport of viewports) widget.onViewportChange(viewport);
				widget.onRedraw?.({
					viewports,
					layers
				});
			}
		}
		this.lastViewports = viewportsById;
		this._updateContainers();
	}
	onHover(info, event) {
		for (const widget of this.getWidgets()) {
			const { viewId } = widget;
			if (!viewId || viewId === info.viewport?.id) widget.onHover?.(info, event);
		}
	}
	onEvent(info, event) {
		const eventHandlerProp = EVENT_HANDLERS[event.type];
		if (!eventHandlerProp) return;
		for (const widget of this.getWidgets()) {
			const { viewId } = widget;
			if (!viewId || viewId === info.viewport?.id) widget[eventHandlerProp]?.(info, event);
		}
	}
	/**
	* Resolve widgets from the declarative prop
	* Initialize new widgets and remove old ones
	* Update props of existing widgets
	*/
	_setWidgets(nextWidgets) {
		const oldWidgetMap = {};
		for (const widget of this.resolvedWidgets) oldWidgetMap[widget.id] = widget;
		this.resolvedWidgets.length = 0;
		for (const widget of this.defaultWidgets) {
			oldWidgetMap[widget.id] = null;
			this.resolvedWidgets.push(widget);
		}
		for (let widget of nextWidgets) {
			const oldWidget = oldWidgetMap[widget.id];
			if (!oldWidget) this._addWidget(widget);
			else if (oldWidget.viewId !== widget.viewId || oldWidget.placement !== widget.placement) {
				this._removeWidget(oldWidget);
				this._addWidget(widget);
			} else if (widget !== oldWidget) {
				oldWidget.setProps(widget.props);
				widget = oldWidget;
			}
			oldWidgetMap[widget.id] = null;
			this.resolvedWidgets.push(widget);
		}
		for (const id in oldWidgetMap) {
			const oldWidget = oldWidgetMap[id];
			if (oldWidget) this._removeWidget(oldWidget);
		}
		this.widgets = nextWidgets;
	}
	/** Initialize new widget */
	_addWidget(widget) {
		const { viewId = null, placement = DEFAULT_PLACEMENT } = widget;
		const container = widget.props._container ?? viewId;
		widget.widgetManager = this;
		widget.deck = this.deck;
		widget.rootElement = widget._onAdd({
			deck: this.deck,
			viewId
		});
		if (widget.rootElement) this._getContainer(container, placement).append(widget.rootElement);
		widget.updateHTML();
	}
	/** Destroy an old widget */
	_removeWidget(widget) {
		widget.onRemove?.();
		if (widget.rootElement) widget.rootElement.remove();
		widget.rootElement = void 0;
		widget.deck = void 0;
		widget.widgetManager = void 0;
	}
	/** Get a container element based on view and placement */
	_getContainer(viewIdOrContainer, placement) {
		if (viewIdOrContainer && typeof viewIdOrContainer !== "string") return viewIdOrContainer;
		const containerId = viewIdOrContainer || ROOT_CONTAINER_ID;
		let viewContainer = this.containers[containerId];
		if (!viewContainer) {
			viewContainer = document.createElement("div");
			viewContainer.style.pointerEvents = "none";
			viewContainer.style.position = "absolute";
			viewContainer.style.overflow = "hidden";
			this.parentElement?.append(viewContainer);
			this.containers[containerId] = viewContainer;
		}
		let container = viewContainer.querySelector(`.${placement}`);
		if (!container) {
			container = globalThis.document.createElement("div");
			container.className = placement;
			container.style.position = "absolute";
			container.style.zIndex = "2";
			Object.assign(container.style, PLACEMENTS[placement]);
			viewContainer.append(container);
		}
		return container;
	}
	_updateContainers() {
		const canvasWidth = this.deck.width;
		const canvasHeight = this.deck.height;
		for (const id in this.containers) {
			const viewport = this.lastViewports[id] || null;
			const visible = id === ROOT_CONTAINER_ID || viewport;
			const container = this.containers[id];
			if (visible) {
				container.style.display = "block";
				container.style.left = `${viewport ? viewport.x : 0}px`;
				container.style.top = `${viewport ? viewport.y : 0}px`;
				container.style.width = `${viewport ? viewport.width : canvasWidth}px`;
				container.style.height = `${viewport ? viewport.height : canvasHeight}px`;
			} else container.style.display = "none";
		}
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/apply-styles.js
function applyStyles(element, style) {
	if (style) Object.entries(style).map(([key, value]) => {
		if (key.startsWith("--")) element.style.setProperty(key, value);
		else element.style[key] = value;
	});
}
function removeStyles(element, style) {
	if (style) Object.keys(style).map((key) => {
		if (key.startsWith("--")) element.style.removeProperty(key);
		else element.style[key] = "";
	});
}

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/widget.js
var Widget = class {
	constructor(props) {
		/**
		* The view id that this widget controls. Default `null`.
		* If assigned, this widget will only respond to events occurred inside the specific view that matches this id.
		*/
		this.viewId = null;
		this.props = {
			...this.constructor.defaultProps,
			...props
		};
		this.id = this.props.id;
	}
	/** Called to update widget options */
	setProps(props) {
		const oldProps = this.props;
		const el = this.rootElement;
		if (el && oldProps.className !== props.className) {
			if (oldProps.className) el.classList.remove(oldProps.className);
			if (props.className) el.classList.add(props.className);
		}
		if (el && !deepEqual(oldProps.style, props.style, 1)) {
			removeStyles(el, oldProps.style);
			applyStyles(el, props.style);
		}
		Object.assign(this.props, props);
		this.updateHTML();
	}
	/** Update the HTML to reflect latest props and state */
	updateHTML() {
		if (this.rootElement) this.onRenderHTML(this.rootElement);
	}
	/**
	* Common utility to create the root DOM element for this widget
	* Configures the top-level styles and adds basic class names for theming
	* @returns an UI element that should be appended to the Deck container
	*/
	onCreateRootElement() {
		const CLASS_NAMES = [
			"deck-widget",
			this.className,
			this.props.className
		];
		const element = document.createElement("div");
		CLASS_NAMES.filter((cls) => typeof cls === "string" && cls.length > 0).forEach((className) => element.classList.add(className));
		applyStyles(element, this.props.style);
		return element;
	}
	/** Internal API called by Deck when the widget is first added to a Deck instance */
	_onAdd(params) {
		return this.onAdd(params) ?? this.onCreateRootElement();
	}
	/** Overridable by subclass - called when the widget is first added to a Deck instance
	* @returns an optional UI element that should be appended to the Deck container
	*/
	onAdd(params) {}
	/** Called when the widget is removed */
	onRemove() {}
	/** Called when the containing view is changed */
	onViewportChange(viewport) {}
	/** Called when the containing view is redrawn */
	onRedraw(params) {}
	/** Called when a hover event occurs */
	onHover(info, event) {}
	/** Called when a click event occurs */
	onClick(info, event) {}
	/** Called when a drag event occurs */
	onDrag(info, event) {}
	/** Called when a dragstart event occurs */
	onDragStart(info, event) {}
	/** Called when a dragend event occurs */
	onDragEnd(info, event) {}
};
Widget.defaultProps = {
	id: "widget",
	style: {},
	_container: null,
	className: ""
};

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/tooltip-widget.js
var defaultStyle = {
	zIndex: "1",
	position: "absolute",
	pointerEvents: "none",
	color: "#a0a7b4",
	backgroundColor: "#29323c",
	padding: "10px",
	top: "0",
	left: "0",
	display: "none"
};
var TooltipWidget = class extends Widget {
	constructor(props = {}) {
		super(props);
		this.id = "default-tooltip";
		this.placement = "fill";
		this.className = "deck-tooltip";
		this.isVisible = false;
		this.setProps(props);
	}
	onCreateRootElement() {
		const el = document.createElement("div");
		el.className = this.className;
		Object.assign(el.style, defaultStyle);
		return el;
	}
	onRenderHTML(rootElement) {}
	onViewportChange(viewport) {
		if (this.isVisible && viewport.id === this.lastViewport?.id && !viewport.equals(this.lastViewport)) this.setTooltip(null);
		this.lastViewport = viewport;
	}
	onHover(info) {
		const { deck } = this;
		const getTooltip = deck && deck.props.getTooltip;
		if (!getTooltip) return;
		const displayInfo = getTooltip(info);
		this.setTooltip(displayInfo, info.x, info.y);
	}
	setTooltip(displayInfo, x$1, y$1) {
		const el = this.rootElement;
		if (!el) return;
		if (typeof displayInfo === "string") el.innerText = displayInfo;
		else if (!displayInfo) {
			this.isVisible = false;
			el.style.display = "none";
			return;
		} else {
			if (displayInfo.text) el.innerText = displayInfo.text;
			if (displayInfo.html) el.innerHTML = displayInfo.html;
			if (displayInfo.className) el.className = displayInfo.className;
		}
		this.isVisible = true;
		el.style.display = "block";
		el.style.transform = `translate(${x$1}px, ${y$1}px)`;
		if (displayInfo && typeof displayInfo === "object" && "style" in displayInfo) Object.assign(el.style, displayInfo.style);
	}
};
TooltipWidget.defaultProps = { ...Widget.defaultProps };

//#endregion
//#region node_modules/@luma.gl/webgl/dist/context/polyfills/polyfill-webgl1-extensions.js
var WEBGL1_STATIC_EXTENSIONS = {
	WEBGL_depth_texture: { UNSIGNED_INT_24_8_WEBGL: 34042 },
	OES_element_index_uint: {},
	OES_texture_float: {},
	OES_texture_half_float: { HALF_FLOAT_OES: 5131 },
	EXT_color_buffer_float: {},
	OES_standard_derivatives: { FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 35723 },
	EXT_frag_depth: {},
	EXT_blend_minmax: {
		MIN_EXT: 32775,
		MAX_EXT: 32776
	},
	EXT_shader_texture_lod: {}
};
var getWEBGL_draw_buffers = (gl) => ({
	drawBuffersWEBGL(buffers) {
		return gl.drawBuffers(buffers);
	},
	COLOR_ATTACHMENT0_WEBGL: 36064,
	COLOR_ATTACHMENT1_WEBGL: 36065,
	COLOR_ATTACHMENT2_WEBGL: 36066,
	COLOR_ATTACHMENT3_WEBGL: 36067
});
var getOES_vertex_array_object = (gl) => ({
	VERTEX_ARRAY_BINDING_OES: 34229,
	createVertexArrayOES() {
		return gl.createVertexArray();
	},
	deleteVertexArrayOES(vertexArray) {
		return gl.deleteVertexArray(vertexArray);
	},
	isVertexArrayOES(vertexArray) {
		return gl.isVertexArray(vertexArray);
	},
	bindVertexArrayOES(vertexArray) {
		return gl.bindVertexArray(vertexArray);
	}
});
var getANGLE_instanced_arrays = (gl) => ({
	VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 35070,
	drawArraysInstancedANGLE(...args) {
		return gl.drawArraysInstanced(...args);
	},
	drawElementsInstancedANGLE(...args) {
		return gl.drawElementsInstanced(...args);
	},
	vertexAttribDivisorANGLE(...args) {
		return gl.vertexAttribDivisor(...args);
	}
});
/**
* Make browser return WebGL2 contexts even if WebGL1 contexts are requested
* @param enforce
* @returns
*/
function enforceWebGL2(enforce = true) {
	const prototype = HTMLCanvasElement.prototype;
	if (!enforce && prototype.originalGetContext) {
		prototype.getContext = prototype.originalGetContext;
		prototype.originalGetContext = void 0;
		return;
	}
	prototype.originalGetContext = prototype.getContext;
	prototype.getContext = function(contextId, options) {
		if (contextId === "webgl" || contextId === "experimental-webgl") {
			const context = this.originalGetContext("webgl2", options);
			if (context instanceof HTMLElement) polyfillWebGL1Extensions(context);
			return context;
		}
		return this.originalGetContext(contextId, options);
	};
}
/** Install WebGL1-only extensions on WebGL2 contexts */
function polyfillWebGL1Extensions(gl) {
	gl.getExtension("EXT_color_buffer_float");
	const boundExtensions = {
		...WEBGL1_STATIC_EXTENSIONS,
		WEBGL_disjoint_timer_query: gl.getExtension("EXT_disjoint_timer_query_webgl2"),
		WEBGL_draw_buffers: getWEBGL_draw_buffers(gl),
		OES_vertex_array_object: getOES_vertex_array_object(gl),
		ANGLE_instanced_arrays: getANGLE_instanced_arrays(gl)
	};
	const originalGetExtension = gl.getExtension;
	gl.getExtension = function(extensionName) {
		const ext = originalGetExtension.call(gl, extensionName);
		if (ext) return ext;
		if (extensionName in boundExtensions) return boundExtensions[extensionName];
		return null;
	};
	const originalGetSupportedExtensions = gl.getSupportedExtensions;
	gl.getSupportedExtensions = function() {
		return (originalGetSupportedExtensions.apply(gl) || [])?.concat(Object.keys(boundExtensions));
	};
}

//#endregion
//#region node_modules/@luma.gl/webgl/dist/adapter/webgl-adapter.js
var LOG_LEVEL = 1;
var WebGLAdapter = class extends Adapter {
	/** type of device's created by this adapter */
	type = "webgl";
	constructor() {
		super();
		Device.defaultProps = {
			...Device.defaultProps,
			...DEFAULT_SPECTOR_PROPS
		};
	}
	/** Force any created WebGL contexts to be WebGL2 contexts, polyfilled with WebGL1 extensions */
	enforceWebGL2(enable) {
		enforceWebGL2(enable);
	}
	/** Check if WebGL 2 is available */
	isSupported() {
		return typeof WebGL2RenderingContext !== "undefined";
	}
	isDeviceHandle(handle) {
		if (typeof WebGL2RenderingContext !== "undefined" && handle instanceof WebGL2RenderingContext) return true;
		if (typeof WebGLRenderingContext !== "undefined" && handle instanceof WebGLRenderingContext) log.warn("WebGL1 is not supported", handle)();
		return false;
	}
	/**
	* Get a device instance from a GL context
	* Creates a WebGLCanvasContext against the contexts canvas
	* @note autoResize will be disabled, assuming that whoever created the external context will be handling resizes.
	* @param gl
	* @returns
	*/
	async attach(gl, props = {}) {
		const { WebGLDevice: WebGLDevice$1 } = await import("./webgl-device-Bz2VA4AM.js");
		if (gl instanceof WebGLDevice$1) return gl;
		if (gl?.device instanceof WebGLDevice$1) return gl.device;
		if (!isWebGL(gl)) throw new Error("Invalid WebGL2RenderingContext");
		const createCanvasContext = props.createCanvasContext === true ? {} : props.createCanvasContext;
		return new WebGLDevice$1({
			...props,
			_handle: gl,
			createCanvasContext: {
				canvas: gl.canvas,
				autoResize: false,
				...createCanvasContext
			}
		});
	}
	async create(props = {}) {
		const { WebGLDevice: WebGLDevice$1 } = await import("./webgl-device-Bz2VA4AM.js");
		log.groupCollapsed(LOG_LEVEL, "WebGLDevice created")();
		try {
			const promises = [];
			if (props.debugWebGL || props.debug) promises.push(loadWebGLDeveloperTools());
			if (props.debugSpectorJS) promises.push(loadSpectorJS(props));
			const results = await Promise.allSettled(promises);
			for (const result of results) if (result.status === "rejected") log.error(`Failed to initialize debug libraries ${result.reason}`)();
			const device = new WebGLDevice$1(props);
			const message = `\
${device._reused ? "Reusing" : "Created"} device with WebGL2 ${device.props.debug ? "debug " : ""}context: \
${device.info.vendor}, ${device.info.renderer} for canvas: ${device.canvasContext.id}`;
			log.probe(LOG_LEVEL, message)();
			log.table(LOG_LEVEL, device.info)();
			return device;
		} finally {
			log.groupEnd(LOG_LEVEL)();
		}
	}
};
/** Check if supplied parameter is a WebGL2RenderingContext */
function isWebGL(gl) {
	if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) return true;
	return Boolean(gl && Number.isFinite(gl._version));
}
const webgl2Adapter = new WebGLAdapter();

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/deck.js
function noop() {}
var getCursor = ({ isDragging }) => isDragging ? "grabbing" : "grab";
var defaultProps$1 = {
	id: "",
	width: "100%",
	height: "100%",
	style: null,
	viewState: null,
	initialViewState: null,
	pickingRadius: 0,
	layerFilter: null,
	parameters: {},
	parent: null,
	device: null,
	deviceProps: {},
	gl: null,
	canvas: null,
	layers: [],
	effects: [],
	views: null,
	controller: null,
	useDevicePixels: true,
	touchAction: "none",
	eventRecognizerOptions: {},
	_framebuffer: null,
	_animate: false,
	_pickable: true,
	_typedArrayManagerProps: {},
	_customRender: null,
	widgets: [],
	onDeviceInitialized: noop,
	onWebGLInitialized: noop,
	onResize: noop,
	onViewStateChange: noop,
	onInteractionStateChange: noop,
	onBeforeRender: noop,
	onAfterRender: noop,
	onLoad: noop,
	onError: (error) => log_default.error(error.message, error.cause)(),
	onHover: null,
	onClick: null,
	onDragStart: null,
	onDrag: null,
	onDragEnd: null,
	_onMetrics: null,
	getCursor,
	getTooltip: null,
	debug: false,
	drawPickingColors: false
};
var Deck = class {
	constructor(props) {
		this.width = 0;
		this.height = 0;
		this.userData = {};
		this.device = null;
		this.canvas = null;
		this.viewManager = null;
		this.layerManager = null;
		this.effectManager = null;
		this.deckRenderer = null;
		this.deckPicker = null;
		this.eventManager = null;
		this.widgetManager = null;
		this.tooltip = null;
		this.animationLoop = null;
		this.cursorState = {
			isHovering: false,
			isDragging: false
		};
		this.stats = new Stats({ id: "deck.gl" });
		this.metrics = {
			fps: 0,
			setPropsTime: 0,
			updateAttributesTime: 0,
			framesRedrawn: 0,
			pickTime: 0,
			pickCount: 0,
			gpuTime: 0,
			gpuTimePerFrame: 0,
			cpuTime: 0,
			cpuTimePerFrame: 0,
			bufferMemory: 0,
			textureMemory: 0,
			renderbufferMemory: 0,
			gpuMemory: 0
		};
		this._metricsCounter = 0;
		this._needsRedraw = "Initial render";
		this._pickRequest = {
			mode: "hover",
			x: -1,
			y: -1,
			radius: 0,
			event: null
		};
		/**
		* Pick and store the object under the pointer on `pointerdown`.
		* This object is reused for subsequent `onClick` and `onDrag*` callbacks.
		*/
		this._lastPointerDownInfo = null;
		/** Internal use only: event handler for pointerdown */
		this._onPointerMove = (event) => {
			const { _pickRequest } = this;
			if (event.type === "pointerleave") {
				_pickRequest.x = -1;
				_pickRequest.y = -1;
				_pickRequest.radius = 0;
			} else if (event.leftButton || event.rightButton) return;
			else {
				const pos = event.offsetCenter;
				if (!pos) return;
				_pickRequest.x = pos.x;
				_pickRequest.y = pos.y;
				_pickRequest.radius = this.props.pickingRadius;
			}
			if (this.layerManager) this.layerManager.context.mousePosition = {
				x: _pickRequest.x,
				y: _pickRequest.y
			};
			_pickRequest.event = event;
		};
		/** Internal use only: event handler for click & drag */
		this._onEvent = (event) => {
			const eventHandlerProp = EVENT_HANDLERS[event.type];
			const pos = event.offsetCenter;
			if (!eventHandlerProp || !pos || !this.layerManager) return;
			const layers = this.layerManager.getLayers();
			const info = this.deckPicker.getLastPickedObject({
				x: pos.x,
				y: pos.y,
				layers,
				viewports: this.getViewports(pos)
			}, this._lastPointerDownInfo);
			const { layer } = info;
			const layerHandler = layer && (layer[eventHandlerProp] || layer.props[eventHandlerProp]);
			const rootHandler = this.props[eventHandlerProp];
			let handled = false;
			if (layerHandler) handled = layerHandler.call(layer, info, event);
			if (!handled) {
				rootHandler?.(info, event);
				this.widgetManager.onEvent(info, event);
			}
		};
		/** Internal use only: evnet handler for pointerdown */
		this._onPointerDown = (event) => {
			if (this.device?.type === "webgpu") return;
			const pos = event.offsetCenter;
			const pickedInfo = this._pick("pickObject", "pickObject Time", {
				x: pos.x,
				y: pos.y,
				radius: this.props.pickingRadius
			});
			this._lastPointerDownInfo = pickedInfo.result[0] || pickedInfo.emptyInfo;
		};
		this.props = {
			...defaultProps$1,
			...props
		};
		props = this.props;
		if (props.viewState && props.initialViewState) log_default.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")();
		this.viewState = this.props.initialViewState;
		if (props.device) this.device = props.device;
		let deviceOrPromise = this.device;
		if (!deviceOrPromise && props.gl) {
			if (props.gl instanceof WebGLRenderingContext) log_default.error("WebGL1 context not supported.")();
			const userOnResize = this.props.deviceProps?.onResize;
			deviceOrPromise = webgl2Adapter.attach(props.gl, {
				...this.props.deviceProps,
				onResize: (canvasContext, info) => {
					const { width, height } = canvasContext.canvas;
					canvasContext.drawingBufferWidth = width;
					canvasContext.drawingBufferHeight = height;
					this._needsRedraw = "Canvas resized";
					userOnResize?.(canvasContext, info);
				}
			});
		}
		if (!deviceOrPromise) deviceOrPromise = this._createDevice(props);
		this.animationLoop = this._createAnimationLoop(deviceOrPromise, props);
		this.setProps(props);
		if (props._typedArrayManagerProps) typed_array_manager_default.setOptions(props._typedArrayManagerProps);
		this.animationLoop.start();
	}
	/** Stop rendering and dispose all resources */
	finalize() {
		this.animationLoop?.stop();
		this.animationLoop?.destroy();
		this.animationLoop = null;
		this._lastPointerDownInfo = null;
		this.layerManager?.finalize();
		this.layerManager = null;
		this.viewManager?.finalize();
		this.viewManager = null;
		this.effectManager?.finalize();
		this.effectManager = null;
		this.deckRenderer?.finalize();
		this.deckRenderer = null;
		this.deckPicker?.finalize();
		this.deckPicker = null;
		this.eventManager?.destroy();
		this.eventManager = null;
		this.widgetManager?.finalize();
		this.widgetManager = null;
		if (!this.props.canvas && !this.props.device && !this.props.gl && this.canvas) {
			this.canvas.parentElement?.removeChild(this.canvas);
			this.canvas = null;
		}
	}
	/** Partially update props */
	setProps(props) {
		this.stats.get("setProps Time").timeStart();
		if ("onLayerHover" in props) log_default.removed("onLayerHover", "onHover")();
		if ("onLayerClick" in props) log_default.removed("onLayerClick", "onClick")();
		if (props.initialViewState && !deepEqual(this.props.initialViewState, props.initialViewState, 3)) this.viewState = props.initialViewState;
		Object.assign(this.props, props);
		this._setCanvasSize(this.props);
		const resolvedProps = Object.create(this.props);
		Object.assign(resolvedProps, {
			views: this._getViews(),
			width: this.width,
			height: this.height,
			viewState: this._getViewState()
		});
		if (props.device && props.device.id !== this.device?.id) {
			this.animationLoop?.stop();
			if (this.canvas !== props.device.canvasContext?.canvas) {
				this.canvas?.remove();
				this.eventManager?.destroy();
				this.canvas = null;
			}
			log_default.log(`recreating animation loop for new device! id=${props.device.id}`)();
			this.animationLoop = this._createAnimationLoop(props.device, props);
			this.animationLoop.start();
		}
		this.animationLoop?.setProps(resolvedProps);
		if (props.useDevicePixels !== void 0 && this.device?.canvasContext) this.device.canvasContext.setProps({ useDevicePixels: props.useDevicePixels });
		if (this.layerManager) {
			this.viewManager.setProps(resolvedProps);
			this.layerManager.activateViewport(this.getViewports()[0]);
			this.layerManager.setProps(resolvedProps);
			this.effectManager.setProps(resolvedProps);
			this.deckRenderer.setProps(resolvedProps);
			this.deckPicker.setProps(resolvedProps);
			this.widgetManager.setProps(resolvedProps);
		}
		this.stats.get("setProps Time").timeEnd();
	}
	/**
	* Check if a redraw is needed
	* @returns `false` or a string summarizing the redraw reason
	*/
	needsRedraw(opts = { clearRedrawFlags: false }) {
		if (!this.layerManager) return false;
		if (this.props._animate) return "Deck._animate";
		let redraw = this._needsRedraw;
		if (opts.clearRedrawFlags) this._needsRedraw = false;
		const viewManagerNeedsRedraw = this.viewManager.needsRedraw(opts);
		const layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);
		const effectManagerNeedsRedraw = this.effectManager.needsRedraw(opts);
		const deckRendererNeedsRedraw = this.deckRenderer.needsRedraw(opts);
		redraw = redraw || viewManagerNeedsRedraw || layerManagerNeedsRedraw || effectManagerNeedsRedraw || deckRendererNeedsRedraw;
		return redraw;
	}
	/**
	* Redraw the GL context
	* @param reason If not provided, only redraw if deemed necessary. Otherwise redraw regardless of internal states.
	* @returns
	*/
	redraw(reason) {
		if (!this.layerManager) return;
		let redrawReason = this.needsRedraw({ clearRedrawFlags: true });
		redrawReason = reason || redrawReason;
		if (!redrawReason) return;
		this.stats.get("Redraw Count").incrementCount();
		if (this.props._customRender) this.props._customRender(redrawReason);
		else this._drawLayers(redrawReason);
	}
	/** Flag indicating that the Deck instance has initialized its resources and it's safe to call public methods. */
	get isInitialized() {
		return this.viewManager !== null;
	}
	/** Get a list of views that are currently rendered */
	getViews() {
		assert(this.viewManager);
		return this.viewManager.views;
	}
	/** Get a list of viewports that are currently rendered.
	* @param rect If provided, only returns viewports within the given bounding box.
	*/
	getViewports(rect) {
		assert(this.viewManager);
		return this.viewManager.getViewports(rect);
	}
	/** Get the current canvas element. */
	getCanvas() {
		return this.canvas;
	}
	/** Query the object rendered on top at a given point */
	pickObject(opts) {
		const infos = this._pick("pickObject", "pickObject Time", opts).result;
		return infos.length ? infos[0] : null;
	}
	pickMultipleObjects(opts) {
		opts.depth = opts.depth || 10;
		return this._pick("pickObject", "pickMultipleObjects Time", opts).result;
	}
	pickObjects(opts) {
		return this._pick("pickObjects", "pickObjects Time", opts);
	}
	/** Experimental
	* Add a global resource for sharing among layers
	*/
	_addResources(resources, forceUpdate = false) {
		for (const id in resources) this.layerManager.resourceManager.add({
			resourceId: id,
			data: resources[id],
			forceUpdate
		});
	}
	/** Experimental
	* Remove a global resource
	*/
	_removeResources(resourceIds) {
		for (const id of resourceIds) this.layerManager.resourceManager.remove(id);
	}
	/** Experimental
	* Register a default effect. Effects will be sorted by order, those with a low order will be rendered first
	*/
	_addDefaultEffect(effect) {
		this.effectManager.addDefaultEffect(effect);
	}
	_addDefaultShaderModule(module) {
		this.layerManager.addDefaultShaderModule(module);
	}
	_removeDefaultShaderModule(module) {
		this.layerManager?.removeDefaultShaderModule(module);
	}
	_pick(method, statKey, opts) {
		assert(this.deckPicker);
		const { stats } = this;
		stats.get("Pick Count").incrementCount();
		stats.get(statKey).timeStart();
		const infos = this.deckPicker[method]({
			layers: this.layerManager.getLayers(opts),
			views: this.viewManager.getViews(),
			viewports: this.getViewports(opts),
			onViewportActive: this.layerManager.activateViewport,
			effects: this.effectManager.getEffects(),
			...opts
		});
		stats.get(statKey).timeEnd();
		return infos;
	}
	/** Resolve props.canvas to element */
	_createCanvas(props) {
		let canvas$1 = props.canvas;
		if (typeof canvas$1 === "string") {
			canvas$1 = document.getElementById(canvas$1);
			assert(canvas$1);
		}
		if (!canvas$1) {
			canvas$1 = document.createElement("canvas");
			canvas$1.id = props.id || "deckgl-overlay";
			if (props.width && typeof props.width === "number") canvas$1.width = props.width;
			if (props.height && typeof props.height === "number") canvas$1.height = props.height;
			(props.parent || document.body).appendChild(canvas$1);
		}
		Object.assign(canvas$1.style, props.style);
		return canvas$1;
	}
	/** Updates canvas width and/or height, if provided as props */
	_setCanvasSize(props) {
		if (!this.canvas) return;
		const { width, height } = props;
		if (width || width === 0) {
			const cssWidth = Number.isFinite(width) ? `${width}px` : width;
			this.canvas.style.width = cssWidth;
		}
		if (height || height === 0) {
			const cssHeight = Number.isFinite(height) ? `${height}px` : height;
			this.canvas.style.position = props.style?.position || "absolute";
			this.canvas.style.height = cssHeight;
		}
	}
	/** If canvas size has changed, reads out the new size and update */
	_updateCanvasSize() {
		const { canvas: canvas$1 } = this;
		if (!canvas$1) return;
		const newWidth = canvas$1.clientWidth ?? canvas$1.width;
		const newHeight = canvas$1.clientHeight ?? canvas$1.height;
		if (newWidth !== this.width || newHeight !== this.height) {
			this.width = newWidth;
			this.height = newHeight;
			this.viewManager?.setProps({
				width: newWidth,
				height: newHeight
			});
			this.layerManager?.activateViewport(this.getViewports()[0]);
			this.props.onResize({
				width: newWidth,
				height: newHeight
			});
		}
	}
	_createAnimationLoop(deviceOrPromise, props) {
		const { gl, onError } = props;
		return new AnimationLoop({
			device: deviceOrPromise,
			autoResizeDrawingBuffer: !gl,
			autoResizeViewport: false,
			onInitialize: (context) => this._setDevice(context.device),
			onRender: this._onRenderFrame.bind(this),
			onError
		});
	}
	_createDevice(props) {
		const canvasContextUserProps = this.props.deviceProps?.createCanvasContext;
		const canvasContextProps = typeof canvasContextUserProps === "object" ? canvasContextUserProps : void 0;
		const deviceProps = {
			adapters: [],
			_cacheShaders: true,
			_cachePipelines: true,
			...props.deviceProps
		};
		if (!deviceProps.adapters.includes(webgl2Adapter)) deviceProps.adapters.push(webgl2Adapter);
		const defaultCanvasProps = { alphaMode: this.props.deviceProps?.type === "webgpu" ? "premultiplied" : void 0 };
		const userOnResize = this.props.deviceProps?.onResize;
		return luma.createDevice({
			_reuseDevices: true,
			type: "webgl",
			...deviceProps,
			createCanvasContext: {
				...defaultCanvasProps,
				...canvasContextProps,
				canvas: this._createCanvas(props),
				useDevicePixels: this.props.useDevicePixels,
				autoResize: true
			},
			onResize: (canvasContext, info) => {
				this._needsRedraw = "Canvas resized";
				userOnResize?.(canvasContext, info);
			}
		});
	}
	_getViewState() {
		return this.props.viewState || this.viewState;
	}
	_getViews() {
		const { views } = this.props;
		const normalizedViews = Array.isArray(views) ? views : views ? [views] : [new map_view_default({ id: "default-view" })];
		if (normalizedViews.length && this.props.controller) normalizedViews[0].props.controller = this.props.controller;
		return normalizedViews;
	}
	_onContextLost() {
		const { onError } = this.props;
		if (this.animationLoop && onError) onError(/* @__PURE__ */ new Error("WebGL context is lost"));
	}
	/** Actually run picking */
	_pickAndCallback() {
		if (this.device?.type === "webgpu") return;
		const { _pickRequest } = this;
		if (_pickRequest.event) {
			const { result, emptyInfo } = this._pick("pickObject", "pickObject Time", _pickRequest);
			this.cursorState.isHovering = result.length > 0;
			let pickedInfo = emptyInfo;
			let handled = false;
			for (const info of result) {
				pickedInfo = info;
				handled = info.layer?.onHover(info, _pickRequest.event) || handled;
			}
			if (!handled) {
				this.props.onHover?.(pickedInfo, _pickRequest.event);
				this.widgetManager.onHover(pickedInfo, _pickRequest.event);
			}
			_pickRequest.event = null;
		}
	}
	_updateCursor() {
		const container = this.props.parent || this.canvas;
		if (container) container.style.cursor = this.props.getCursor(this.cursorState);
	}
	_setDevice(device) {
		this.device = device;
		if (!this.animationLoop) return;
		if (!this.canvas) {
			this.canvas = this.device.canvasContext?.canvas;
			if (!this.canvas.isConnected && this.props.parent) this.props.parent.insertBefore(this.canvas, this.props.parent.firstChild);
		}
		if (this.device.type === "webgl") this.device.setParametersWebGL({
			blend: true,
			blendFunc: [
				770,
				771,
				1,
				771
			],
			polygonOffsetFill: true,
			depthTest: true,
			depthFunc: 515
		});
		this.props.onDeviceInitialized(this.device);
		if (this.device.type === "webgl") this.props.onWebGLInitialized(this.device.gl);
		const timeline = new Timeline();
		timeline.play();
		this.animationLoop.attachTimeline(timeline);
		this.eventManager = new EventManager(this.props.parent || this.canvas, {
			touchAction: this.props.touchAction,
			recognizers: Object.keys(RECOGNIZERS).map((eventName) => {
				const [RecognizerConstructor, defaultOptions$1, recognizeWith, requestFailure] = RECOGNIZERS[eventName];
				const optionsOverride = this.props.eventRecognizerOptions?.[eventName];
				return {
					recognizer: new RecognizerConstructor({
						...defaultOptions$1,
						...optionsOverride,
						event: eventName
					}),
					recognizeWith,
					requestFailure
				};
			}),
			events: {
				pointerdown: this._onPointerDown,
				pointermove: this._onPointerMove,
				pointerleave: this._onPointerMove
			}
		});
		for (const eventType in EVENT_HANDLERS) this.eventManager.on(eventType, this._onEvent);
		this.viewManager = new ViewManager({
			timeline,
			eventManager: this.eventManager,
			onViewStateChange: this._onViewStateChange.bind(this),
			onInteractionStateChange: this._onInteractionStateChange.bind(this),
			views: this._getViews(),
			viewState: this._getViewState(),
			width: this.width,
			height: this.height
		});
		const viewport = this.viewManager.getViewports()[0];
		this.layerManager = new LayerManager(this.device, {
			deck: this,
			stats: this.stats,
			viewport,
			timeline
		});
		this.effectManager = new EffectManager({
			deck: this,
			device: this.device
		});
		this.deckRenderer = new DeckRenderer(this.device);
		this.deckPicker = new DeckPicker(this.device);
		this.widgetManager = new WidgetManager({
			deck: this,
			parentElement: this.canvas?.parentElement
		});
		this.widgetManager.addDefault(new TooltipWidget());
		this.setProps(this.props);
		this._updateCanvasSize();
		this.props.onLoad();
	}
	/** Internal only: default render function (redraw all layers and views) */
	_drawLayers(redrawReason, renderOptions) {
		const { device, gl } = this.layerManager.context;
		this.props.onBeforeRender({
			device,
			gl
		});
		const opts = {
			target: this.props._framebuffer,
			layers: this.layerManager.getLayers(),
			viewports: this.viewManager.getViewports(),
			onViewportActive: this.layerManager.activateViewport,
			views: this.viewManager.getViews(),
			pass: "screen",
			effects: this.effectManager.getEffects(),
			...renderOptions
		};
		this.deckRenderer?.renderLayers(opts);
		if (opts.pass === "screen") this.widgetManager.onRedraw({
			viewports: opts.viewports,
			layers: opts.layers
		});
		this.props.onAfterRender({
			device,
			gl
		});
	}
	_onRenderFrame() {
		this._getFrameStats();
		if (this._metricsCounter++ % 60 === 0) {
			this._getMetrics();
			this.stats.reset();
			log_default.table(4, this.metrics)();
			if (this.props._onMetrics) this.props._onMetrics(this.metrics);
		}
		this._updateCanvasSize();
		this._updateCursor();
		this.layerManager.updateLayers();
		if (this.device?.type !== "webgpu") this._pickAndCallback();
		this.redraw();
		if (this.viewManager) this.viewManager.updateViewStates();
	}
	_onViewStateChange(params) {
		const viewState = this.props.onViewStateChange(params) || params.viewState;
		if (this.viewState) {
			this.viewState = {
				...this.viewState,
				[params.viewId]: viewState
			};
			if (!this.props.viewState) {
				if (this.viewManager) this.viewManager.setProps({ viewState: this.viewState });
			}
		}
	}
	_onInteractionStateChange(interactionState) {
		this.cursorState.isDragging = interactionState.isDragging || false;
		this.props.onInteractionStateChange(interactionState);
	}
	_getFrameStats() {
		const { stats } = this;
		stats.get("frameRate").timeEnd();
		stats.get("frameRate").timeStart();
		const animationLoopStats = this.animationLoop.stats;
		stats.get("GPU Time").addTime(animationLoopStats.get("GPU Time").lastTiming);
		stats.get("CPU Time").addTime(animationLoopStats.get("CPU Time").lastTiming);
	}
	_getMetrics() {
		const { metrics, stats } = this;
		metrics.fps = stats.get("frameRate").getHz();
		metrics.setPropsTime = stats.get("setProps Time").time;
		metrics.updateAttributesTime = stats.get("Update Attributes").time;
		metrics.framesRedrawn = stats.get("Redraw Count").count;
		metrics.pickTime = stats.get("pickObject Time").time + stats.get("pickMultipleObjects Time").time + stats.get("pickObjects Time").time;
		metrics.pickCount = stats.get("Pick Count").count;
		metrics.gpuTime = stats.get("GPU Time").time;
		metrics.cpuTime = stats.get("CPU Time").time;
		metrics.gpuTimePerFrame = stats.get("GPU Time").getAverageTime();
		metrics.cpuTimePerFrame = stats.get("CPU Time").getAverageTime();
		const memoryStats = luma.stats.get("Memory Usage");
		metrics.bufferMemory = memoryStats.get("Buffer Memory").count;
		metrics.textureMemory = memoryStats.get("Texture Memory").count;
		metrics.renderbufferMemory = memoryStats.get("Renderbuffer Memory").count;
		metrics.gpuMemory = memoryStats.get("GPU Memory").count;
	}
};
Deck.defaultProps = defaultProps$1;
Deck.VERSION = VERSION;
var deck_default = Deck;

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/attribute/gl-utils.js
function typedArrayFromDataType(type) {
	switch (type) {
		case "float64": return Float64Array;
		case "uint8":
		case "unorm8": return Uint8ClampedArray;
		default: return getTypedArrayConstructor(type);
	}
}
const dataTypeFromTypedArray = getDataType;
function getBufferAttributeLayout(name, accessor, deviceType) {
	const type = deviceType === "webgpu" && accessor.type === "uint8" ? "unorm8" : accessor.type;
	return {
		attribute: name,
		format: accessor.size > 1 ? `${type}x${accessor.size}` : accessor.type,
		byteOffset: accessor.offset || 0
	};
}
function getStride(accessor) {
	return accessor.stride || accessor.size * accessor.bytesPerElement;
}
function bufferLayoutEqual(accessor1, accessor2) {
	return accessor1.type === accessor2.type && accessor1.size === accessor2.size && getStride(accessor1) === getStride(accessor2) && (accessor1.offset || 0) === (accessor2.offset || 0);
}

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/attribute/data-column.js
function resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {
	if (shaderAttributeOptions.offset) log_default.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
	const stride = getStride(baseAccessor);
	const vertexOffset = shaderAttributeOptions.vertexOffset !== void 0 ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;
	const elementOffset = shaderAttributeOptions.elementOffset || 0;
	const offset = vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + (baseAccessor.offset || 0);
	return {
		...shaderAttributeOptions,
		offset,
		stride
	};
}
function resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {
	const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);
	return {
		high: resolvedOptions,
		low: {
			...resolvedOptions,
			offset: resolvedOptions.offset + baseAccessor.size * 4
		}
	};
}
var DataColumn = class {
	constructor(device, opts, state) {
		this._buffer = null;
		this.device = device;
		this.id = opts.id || "";
		this.size = opts.size || 1;
		const logicalType = opts.logicalType || opts.type;
		const doublePrecision = logicalType === "float64";
		let { defaultValue } = opts;
		defaultValue = Number.isFinite(defaultValue) ? [defaultValue] : defaultValue || new Array(this.size).fill(0);
		let bufferType;
		if (doublePrecision) bufferType = "float32";
		else if (!logicalType && opts.isIndexed) bufferType = "uint32";
		else bufferType = logicalType || "float32";
		let defaultType = typedArrayFromDataType(logicalType || bufferType);
		this.doublePrecision = doublePrecision;
		if (doublePrecision && opts.fp64 === false) defaultType = Float32Array;
		this.value = null;
		this.settings = {
			...opts,
			defaultType,
			defaultValue,
			logicalType,
			type: bufferType,
			normalized: bufferType.includes("norm"),
			size: this.size,
			bytesPerElement: defaultType.BYTES_PER_ELEMENT
		};
		this.state = {
			...state,
			externalBuffer: null,
			bufferAccessor: this.settings,
			allocatedValue: null,
			numInstances: 0,
			bounds: null,
			constant: false
		};
	}
	get isConstant() {
		return this.state.constant;
	}
	get buffer() {
		return this._buffer;
	}
	get byteOffset() {
		const accessor = this.getAccessor();
		if (accessor.vertexOffset) return accessor.vertexOffset * getStride(accessor);
		return 0;
	}
	get numInstances() {
		return this.state.numInstances;
	}
	set numInstances(n$1) {
		this.state.numInstances = n$1;
	}
	delete() {
		if (this._buffer) {
			this._buffer.delete();
			this._buffer = null;
		}
		typed_array_manager_default.release(this.state.allocatedValue);
	}
	getBuffer() {
		if (this.state.constant) return null;
		return this.state.externalBuffer || this._buffer;
	}
	getValue(attributeName = this.id, options = null) {
		const result = {};
		if (this.state.constant) {
			const value = this.value;
			if (options) {
				const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);
				const offset = shaderAttributeDef.offset / value.BYTES_PER_ELEMENT;
				const size = shaderAttributeDef.size || this.size;
				result[attributeName] = value.subarray(offset, offset + size);
			} else result[attributeName] = value;
		} else result[attributeName] = this.getBuffer();
		if (this.doublePrecision) if (this.value instanceof Float64Array) result[`${attributeName}64Low`] = result[attributeName];
		else result[`${attributeName}64Low`] = new Float32Array(this.size);
		return result;
	}
	_getBufferLayout(attributeName = this.id, options = null) {
		const accessor = this.getAccessor();
		const attributes = [];
		const result = {
			name: this.id,
			byteStride: getStride(accessor),
			attributes
		};
		if (this.doublePrecision) {
			const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(accessor, options || {});
			attributes.push(getBufferAttributeLayout(attributeName, {
				...accessor,
				...doubleShaderAttributeDefs.high
			}, this.device.type), getBufferAttributeLayout(`${attributeName}64Low`, {
				...accessor,
				...doubleShaderAttributeDefs.low
			}, this.device.type));
		} else if (options) {
			const shaderAttributeDef = resolveShaderAttribute(accessor, options);
			attributes.push(getBufferAttributeLayout(attributeName, {
				...accessor,
				...shaderAttributeDef
			}, this.device.type));
		} else attributes.push(getBufferAttributeLayout(attributeName, accessor, this.device.type));
		return result;
	}
	setAccessor(accessor) {
		this.state.bufferAccessor = accessor;
	}
	getAccessor() {
		return this.state.bufferAccessor;
	}
	getBounds() {
		if (this.state.bounds) return this.state.bounds;
		let result = null;
		if (this.state.constant && this.value) {
			const min = Array.from(this.value);
			result = [min, min];
		} else {
			const { value, numInstances, size } = this;
			const len$1 = numInstances * size;
			if (value && len$1 && value.length >= len$1) {
				const min = new Array(size).fill(Infinity);
				const max = new Array(size).fill(-Infinity);
				for (let i$1 = 0; i$1 < len$1;) for (let j$1 = 0; j$1 < size; j$1++) {
					const v$1 = value[i$1++];
					if (v$1 < min[j$1]) min[j$1] = v$1;
					if (v$1 > max[j$1]) max[j$1] = v$1;
				}
				result = [min, max];
			}
		}
		this.state.bounds = result;
		return result;
	}
	setData(data) {
		const { state } = this;
		let opts;
		if (ArrayBuffer.isView(data)) opts = { value: data };
		else if (data instanceof Buffer) opts = { buffer: data };
		else opts = data;
		const accessor = {
			...this.settings,
			...opts
		};
		if (ArrayBuffer.isView(opts.value)) {
			if (!opts.type) if (this.doublePrecision && opts.value instanceof Float64Array) accessor.type = "float32";
			else {
				const type = dataTypeFromTypedArray(opts.value);
				accessor.type = accessor.normalized ? type.replace("int", "norm") : type;
			}
			accessor.bytesPerElement = opts.value.BYTES_PER_ELEMENT;
			accessor.stride = getStride(accessor);
		}
		state.bounds = null;
		if (opts.constant) {
			let value = opts.value;
			value = this._normalizeValue(value, [], 0);
			if (this.settings.normalized) value = this.normalizeConstant(value);
			if (!(!state.constant || !this._areValuesEqual(value, this.value))) return false;
			state.externalBuffer = null;
			state.constant = true;
			this.value = ArrayBuffer.isView(value) ? value : new Float32Array(value);
		} else if (opts.buffer) {
			state.externalBuffer = opts.buffer;
			state.constant = false;
			this.value = opts.value || null;
		} else if (opts.value) {
			this._checkExternalBuffer(opts);
			let value = opts.value;
			state.externalBuffer = null;
			state.constant = false;
			this.value = value;
			let { buffer } = this;
			const stride = getStride(accessor);
			const byteOffset = (accessor.vertexOffset || 0) * stride;
			if (this.doublePrecision && value instanceof Float64Array) value = toDoublePrecisionArray(value, accessor);
			if (this.settings.isIndexed) {
				const ArrayType = this.settings.defaultType;
				if (value.constructor !== ArrayType) value = new ArrayType(value);
			}
			const requiredBufferSize = value.byteLength + byteOffset + stride * 2;
			if (!buffer || buffer.byteLength < requiredBufferSize) buffer = this._createBuffer(requiredBufferSize);
			buffer.write(value, byteOffset);
		}
		this.setAccessor(accessor);
		return true;
	}
	updateSubBuffer(opts = {}) {
		this.state.bounds = null;
		const value = this.value;
		const { startOffset = 0, endOffset } = opts;
		this.buffer.write(this.doublePrecision && value instanceof Float64Array ? toDoublePrecisionArray(value, {
			size: this.size,
			startIndex: startOffset,
			endIndex: endOffset
		}) : value.subarray(startOffset, endOffset), startOffset * value.BYTES_PER_ELEMENT + this.byteOffset);
	}
	allocate(numInstances, copy = false) {
		const { state } = this;
		const oldValue = state.allocatedValue;
		const value = typed_array_manager_default.allocate(oldValue, numInstances + 1, {
			size: this.size,
			type: this.settings.defaultType,
			copy
		});
		this.value = value;
		const { byteOffset } = this;
		let { buffer } = this;
		if (!buffer || buffer.byteLength < value.byteLength + byteOffset) {
			buffer = this._createBuffer(value.byteLength + byteOffset);
			if (copy && oldValue) buffer.write(oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue, byteOffset);
		}
		state.allocatedValue = value;
		state.constant = false;
		state.externalBuffer = null;
		this.setAccessor(this.settings);
		return true;
	}
	_checkExternalBuffer(opts) {
		const { value } = opts;
		if (!ArrayBuffer.isView(value)) throw new Error(`Attribute ${this.id} value is not TypedArray`);
		const ArrayType = this.settings.defaultType;
		let illegalArrayType = false;
		if (this.doublePrecision) illegalArrayType = value.BYTES_PER_ELEMENT < 4;
		if (illegalArrayType) throw new Error(`Attribute ${this.id} does not support ${value.constructor.name}`);
		if (!(value instanceof ArrayType) && this.settings.normalized && !("normalized" in opts)) log_default.warn(`Attribute ${this.id} is normalized`)();
	}
	normalizeConstant(value) {
		switch (this.settings.type) {
			case "snorm8": return new Float32Array(value).map((x$1) => (x$1 + 128) / 255 * 2 - 1);
			case "snorm16": return new Float32Array(value).map((x$1) => (x$1 + 32768) / 65535 * 2 - 1);
			case "unorm8": return new Float32Array(value).map((x$1) => x$1 / 255);
			case "unorm16": return new Float32Array(value).map((x$1) => x$1 / 65535);
			default: return value;
		}
	}
	_normalizeValue(value, out, start) {
		const { defaultValue, size } = this.settings;
		if (Number.isFinite(value)) {
			out[start] = value;
			return out;
		}
		if (!value) {
			let i$1 = size;
			while (--i$1 >= 0) out[start + i$1] = defaultValue[i$1];
			return out;
		}
		switch (size) {
			case 4: out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];
			case 3: out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];
			case 2: out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];
			case 1:
				out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];
				break;
			default:
				let i$1 = size;
				while (--i$1 >= 0) out[start + i$1] = Number.isFinite(value[i$1]) ? value[i$1] : defaultValue[i$1];
		}
		return out;
	}
	_areValuesEqual(value1, value2) {
		if (!value1 || !value2) return false;
		const { size } = this;
		for (let i$1 = 0; i$1 < size; i$1++) if (value1[i$1] !== value2[i$1]) return false;
		return true;
	}
	_createBuffer(byteLength) {
		if (this._buffer) this._buffer.destroy();
		const { isIndexed, type } = this.settings;
		this._buffer = this.device.createBuffer({
			...this._buffer?.props,
			id: this.id,
			usage: (isIndexed ? Buffer.INDEX : Buffer.VERTEX) | Buffer.COPY_DST,
			indexType: isIndexed ? type : void 0,
			byteLength
		});
		return this._buffer;
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/iterable-utils.js
var EMPTY_ARRAY$1 = [];
var placeholderArray = [];
function createIterable(data, startRow = 0, endRow = Infinity) {
	let iterable = EMPTY_ARRAY$1;
	const objectInfo = {
		index: -1,
		data,
		target: []
	};
	if (!data) iterable = EMPTY_ARRAY$1;
	else if (typeof data[Symbol.iterator] === "function") iterable = data;
	else if (data.length > 0) {
		placeholderArray.length = data.length;
		iterable = placeholderArray;
	}
	if (startRow > 0 || Number.isFinite(endRow)) {
		iterable = (Array.isArray(iterable) ? iterable : Array.from(iterable)).slice(startRow, endRow);
		objectInfo.index = startRow - 1;
	}
	return {
		iterable,
		objectInfo
	};
}
function isAsyncIterable(data) {
	return data && data[Symbol.asyncIterator];
}
function getAccessorFromBuffer(typedArray, options) {
	const { size, stride, offset, startIndices, nested } = options;
	const bytesPerElement = typedArray.BYTES_PER_ELEMENT;
	const elementStride = stride ? stride / bytesPerElement : size;
	const elementOffset = offset ? offset / bytesPerElement : 0;
	const vertexCount = Math.floor((typedArray.length - elementOffset) / elementStride);
	return (_$1, { index, target }) => {
		if (!startIndices) {
			const sourceIndex = index * elementStride + elementOffset;
			for (let j$1 = 0; j$1 < size; j$1++) target[j$1] = typedArray[sourceIndex + j$1];
			return target;
		}
		const startIndex = startIndices[index];
		const endIndex = startIndices[index + 1] || vertexCount;
		let result;
		if (nested) {
			result = new Array(endIndex - startIndex);
			for (let i$1 = startIndex; i$1 < endIndex; i$1++) {
				const sourceIndex = i$1 * elementStride + elementOffset;
				target = new Array(size);
				for (let j$1 = 0; j$1 < size; j$1++) target[j$1] = typedArray[sourceIndex + j$1];
				result[i$1 - startIndex] = target;
			}
		} else if (elementStride === size) result = typedArray.subarray(startIndex * size + elementOffset, endIndex * size + elementOffset);
		else {
			result = new typedArray.constructor((endIndex - startIndex) * size);
			let targetIndex = 0;
			for (let i$1 = startIndex; i$1 < endIndex; i$1++) {
				const sourceIndex = i$1 * elementStride + elementOffset;
				for (let j$1 = 0; j$1 < size; j$1++) result[targetIndex++] = typedArray[sourceIndex + j$1];
			}
		}
		return result;
	};
}

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/range.js
const EMPTY = [];
const FULL = [[0, Infinity]];
function add(rangeList, range) {
	if (rangeList === FULL) return rangeList;
	if (range[0] < 0) range[0] = 0;
	if (range[0] >= range[1]) return rangeList;
	const newRangeList = [];
	const len$1 = rangeList.length;
	let insertPosition = 0;
	for (let i$1 = 0; i$1 < len$1; i$1++) {
		const range0 = rangeList[i$1];
		if (range0[1] < range[0]) {
			newRangeList.push(range0);
			insertPosition = i$1 + 1;
		} else if (range0[0] > range[1]) newRangeList.push(range0);
		else range = [Math.min(range0[0], range[0]), Math.max(range0[1], range[1])];
	}
	newRangeList.splice(insertPosition, 0, range);
	return newRangeList;
}

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/attribute/transition-settings.js
var DEFAULT_TRANSITION_SETTINGS = {
	interpolation: {
		duration: 0,
		easing: (t$1) => t$1
	},
	spring: {
		stiffness: .05,
		damping: .5
	}
};
function normalizeTransitionSettings(userSettings, layerSettings) {
	if (!userSettings) return null;
	if (Number.isFinite(userSettings)) userSettings = {
		type: "interpolation",
		duration: userSettings
	};
	const type = userSettings.type || "interpolation";
	return {
		...DEFAULT_TRANSITION_SETTINGS[type],
		...layerSettings,
		...userSettings,
		type
	};
}

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/attribute/attribute.js
var Attribute = class extends DataColumn {
	constructor(device, opts) {
		super(device, opts, {
			startIndices: null,
			lastExternalBuffer: null,
			binaryValue: null,
			binaryAccessor: null,
			needsUpdate: true,
			needsRedraw: false,
			layoutChanged: false,
			updateRanges: FULL
		});
		/** Legacy approach to set attribute value - read `isConstant` instead for attribute state */
		this.constant = false;
		this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : void 0);
		Object.seal(this.settings);
		Object.seal(this.state);
		this._validateAttributeUpdaters();
	}
	get startIndices() {
		return this.state.startIndices;
	}
	set startIndices(layout) {
		this.state.startIndices = layout;
	}
	needsUpdate() {
		return this.state.needsUpdate;
	}
	needsRedraw({ clearChangedFlags = false } = {}) {
		const needsRedraw = this.state.needsRedraw;
		this.state.needsRedraw = needsRedraw && !clearChangedFlags;
		return needsRedraw;
	}
	layoutChanged() {
		return this.state.layoutChanged;
	}
	setAccessor(accessor) {
		var _a;
		(_a = this.state).layoutChanged || (_a.layoutChanged = !bufferLayoutEqual(accessor, this.getAccessor()));
		super.setAccessor(accessor);
	}
	getUpdateTriggers() {
		const { accessor } = this.settings;
		return [this.id].concat(typeof accessor !== "function" && accessor || []);
	}
	supportsTransition() {
		return Boolean(this.settings.transition);
	}
	getTransitionSetting(opts) {
		if (!opts || !this.supportsTransition()) return null;
		const { accessor } = this.settings;
		const layerSettings = this.settings.transition;
		return normalizeTransitionSettings(Array.isArray(accessor) ? opts[accessor.find((a$1) => opts[a$1])] : opts[accessor], layerSettings);
	}
	setNeedsUpdate(reason = this.id, dataRange) {
		this.state.needsUpdate = this.state.needsUpdate || reason;
		this.setNeedsRedraw(reason);
		if (dataRange) {
			const { startRow = 0, endRow = Infinity } = dataRange;
			this.state.updateRanges = add(this.state.updateRanges, [startRow, endRow]);
		} else this.state.updateRanges = FULL;
	}
	clearNeedsUpdate() {
		this.state.needsUpdate = false;
		this.state.updateRanges = EMPTY;
	}
	setNeedsRedraw(reason = this.id) {
		this.state.needsRedraw = this.state.needsRedraw || reason;
	}
	allocate(numInstances) {
		const { state, settings } = this;
		if (settings.noAlloc) return false;
		if (settings.update) {
			super.allocate(numInstances, state.updateRanges !== FULL);
			return true;
		}
		return false;
	}
	updateBuffer({ numInstances, data, props, context }) {
		if (!this.needsUpdate()) return false;
		const { state: { updateRanges }, settings: { update, noAlloc } } = this;
		let updated = true;
		if (update) {
			for (const [startRow, endRow] of updateRanges) update.call(context, this, {
				data,
				startRow,
				endRow,
				props,
				numInstances
			});
			if (!this.value) {} else if (this.constant || !this.buffer || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {
				this.setData({
					value: this.value,
					constant: this.constant
				});
				this.constant = false;
			} else for (const [startRow, endRow] of updateRanges) {
				const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;
				const endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;
				super.updateSubBuffer({
					startOffset,
					endOffset
				});
			}
			this._checkAttributeArray();
		} else updated = false;
		this.clearNeedsUpdate();
		this.setNeedsRedraw();
		return updated;
	}
	setConstantValue(context, value) {
		const isWebGPU = this.device.type === "webgpu";
		if (isWebGPU || value === void 0 || typeof value === "function") {
			if (isWebGPU && typeof value !== "function") {
				const normalisedValue = this._normalizeValue(value, [], 0);
				if (!this._areValuesEqual(normalisedValue, this.value)) this.setNeedsUpdate("WebGPU constant updated");
			}
			return false;
		}
		const transformedValue = this.settings.transform && context ? this.settings.transform.call(context, value) : value;
		if (this.setData({
			constant: true,
			value: transformedValue
		})) this.setNeedsRedraw();
		this.clearNeedsUpdate();
		return true;
	}
	setExternalBuffer(buffer) {
		const { state } = this;
		if (!buffer) {
			state.lastExternalBuffer = null;
			return false;
		}
		this.clearNeedsUpdate();
		if (state.lastExternalBuffer === buffer) return true;
		state.lastExternalBuffer = buffer;
		this.setNeedsRedraw();
		this.setData(buffer);
		return true;
	}
	setBinaryValue(buffer, startIndices = null) {
		const { state, settings } = this;
		if (!buffer) {
			state.binaryValue = null;
			state.binaryAccessor = null;
			return false;
		}
		if (settings.noAlloc) return false;
		if (state.binaryValue === buffer) {
			this.clearNeedsUpdate();
			return true;
		}
		state.binaryValue = buffer;
		this.setNeedsRedraw();
		if (settings.transform || startIndices !== this.startIndices) {
			if (ArrayBuffer.isView(buffer)) buffer = { value: buffer };
			const binaryValue = buffer;
			assert(ArrayBuffer.isView(binaryValue.value), `invalid ${settings.accessor}`);
			const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;
			state.binaryAccessor = getAccessorFromBuffer(binaryValue.value, {
				size: binaryValue.size || this.size,
				stride: binaryValue.stride,
				offset: binaryValue.offset,
				startIndices,
				nested: needsNormalize
			});
			return false;
		}
		this.clearNeedsUpdate();
		this.setData(buffer);
		return true;
	}
	getVertexOffset(row) {
		const { startIndices } = this;
		return (startIndices ? row < startIndices.length ? startIndices[row] : this.numInstances : row) * this.size;
	}
	getValue() {
		const shaderAttributeDefs = this.settings.shaderAttributes;
		const result = super.getValue();
		if (!shaderAttributeDefs) return result;
		for (const shaderAttributeName in shaderAttributeDefs) Object.assign(result, super.getValue(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));
		return result;
	}
	/** Generate WebGPU-style buffer layout descriptor from this attribute */
	getBufferLayout(modelInfo) {
		this.state.layoutChanged = false;
		const shaderAttributeDefs = this.settings.shaderAttributes;
		const result = super._getBufferLayout();
		const { stepMode } = this.settings;
		if (stepMode === "dynamic") result.stepMode = modelInfo ? modelInfo.isInstanced ? "instance" : "vertex" : "instance";
		else result.stepMode = stepMode ?? "vertex";
		if (!shaderAttributeDefs) return result;
		for (const shaderAttributeName in shaderAttributeDefs) {
			const map$1 = super._getBufferLayout(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]);
			result.attributes.push(...map$1.attributes);
		}
		return result;
	}
	_autoUpdater(attribute, { data, startRow, endRow, props, numInstances }) {
		if (attribute.constant) {
			if (this.context.device.type !== "webgpu") return;
		}
		const { settings, state, value, size, startIndices } = attribute;
		const { accessor, transform } = settings;
		let accessorFunc = state.binaryAccessor || (typeof accessor === "function" ? accessor : props[accessor]);
		if (typeof accessorFunc !== "function" && typeof accessor === "string") accessorFunc = () => props[accessor];
		assert(typeof accessorFunc === "function", `accessor "${accessor}" is not a function`);
		let i$1 = attribute.getVertexOffset(startRow);
		const { iterable, objectInfo } = createIterable(data, startRow, endRow);
		for (const object of iterable) {
			objectInfo.index++;
			let objectValue = accessorFunc(object, objectInfo);
			if (transform) objectValue = transform.call(this, objectValue);
			if (startIndices) {
				const numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];
				if (objectValue && Array.isArray(objectValue[0])) {
					let startIndex = i$1;
					for (const item of objectValue) {
						attribute._normalizeValue(item, value, startIndex);
						startIndex += size;
					}
				} else if (objectValue && objectValue.length > size) value.set(objectValue, i$1);
				else {
					attribute._normalizeValue(objectValue, objectInfo.target, 0);
					fillArray({
						target: value,
						source: objectInfo.target,
						start: i$1,
						count: numVertices
					});
				}
				i$1 += numVertices * size;
			} else {
				attribute._normalizeValue(objectValue, value, i$1);
				i$1 += size;
			}
		}
	}
	_validateAttributeUpdaters() {
		const { settings } = this;
		if (!(settings.noAlloc || typeof settings.update === "function")) throw new Error(`Attribute ${this.id} missing update or accessor`);
	}
	_checkAttributeArray() {
		const { value } = this;
		const limit = Math.min(4, this.size);
		if (value && value.length >= limit) {
			let valid = true;
			switch (limit) {
				case 4: valid = valid && Number.isFinite(value[3]);
				case 3: valid = valid && Number.isFinite(value[2]);
				case 2: valid = valid && Number.isFinite(value[1]);
				case 1:
					valid = valid && Number.isFinite(value[0]);
					break;
				default: valid = false;
			}
			if (!valid) throw new Error(`Illegal attribute generated for ${this.id}`);
		}
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/array-utils.js
function padArrayChunk(options) {
	const { source: source$2, target, start = 0, size, getData } = options;
	const end = options.end || target.length;
	const sourceLength = source$2.length;
	const targetLength = end - start;
	if (sourceLength > targetLength) {
		target.set(source$2.subarray(0, targetLength), start);
		return;
	}
	target.set(source$2, start);
	if (!getData) return;
	let i$1 = sourceLength;
	while (i$1 < targetLength) {
		const datum = getData(i$1, source$2);
		for (let j$1 = 0; j$1 < size; j$1++) {
			target[start + i$1] = datum[j$1] || 0;
			i$1++;
		}
	}
}
function padArray({ source: source$2, target, size, getData, sourceStartIndices, targetStartIndices }) {
	if (!sourceStartIndices || !targetStartIndices) {
		padArrayChunk({
			source: source$2,
			target,
			size,
			getData
		});
		return target;
	}
	let sourceIndex = 0;
	let targetIndex = 0;
	const getChunkData = getData && ((i$1, chunk) => getData(i$1 + targetIndex, chunk));
	const n$1 = Math.min(sourceStartIndices.length, targetStartIndices.length);
	for (let i$1 = 1; i$1 < n$1; i$1++) {
		const nextSourceIndex = sourceStartIndices[i$1] * size;
		const nextTargetIndex = targetStartIndices[i$1] * size;
		padArrayChunk({
			source: source$2.subarray(sourceIndex, nextSourceIndex),
			target,
			start: targetIndex,
			end: nextTargetIndex,
			size,
			getData: getChunkData
		});
		sourceIndex = nextSourceIndex;
		targetIndex = nextTargetIndex;
	}
	if (targetIndex < target.length) padArrayChunk({
		source: [],
		target,
		start: targetIndex,
		size,
		getData: getChunkData
	});
	return target;
}

//#endregion
//#region node_modules/@deck.gl/core/dist/transitions/gpu-transition-utils.js
/** Create a new empty attribute with the same settings: type, shader layout etc. */
function cloneAttribute(attribute) {
	const { device, settings, value } = attribute;
	const newAttribute = new Attribute(device, settings);
	newAttribute.setData({
		value: value instanceof Float64Array ? new Float64Array(0) : new Float32Array(0),
		normalized: settings.normalized
	});
	return newAttribute;
}
/** Returns the GLSL attribute type for the given number of float32 components. */
function getAttributeTypeFromSize(size) {
	switch (size) {
		case 1: return "float";
		case 2: return "vec2";
		case 3: return "vec3";
		case 4: return "vec4";
		default: throw new Error(`No defined attribute type for size "${size}"`);
	}
}
/** Returns the {@link VertexFormat} for the given number of float32 components. */
function getFloat32VertexFormat(size) {
	switch (size) {
		case 1: return "float32";
		case 2: return "float32x2";
		case 3: return "float32x3";
		case 4: return "float32x4";
		default: throw new Error("invalid type size");
	}
}
function cycleBuffers(buffers) {
	buffers.push(buffers.shift());
}
function getAttributeBufferLength(attribute, numInstances) {
	const { doublePrecision, settings, value, size } = attribute;
	const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;
	let maxVertexOffset = 0;
	const { shaderAttributes } = attribute.settings;
	if (shaderAttributes) for (const shaderAttribute of Object.values(shaderAttributes)) maxVertexOffset = Math.max(maxVertexOffset, shaderAttribute.vertexOffset ?? 0);
	return (settings.noAlloc ? value.length : (numInstances + maxVertexOffset) * size) * multiplier;
}
function matchBuffer({ device, source: source$2, target }) {
	if (!target || target.byteLength < source$2.byteLength) {
		target?.destroy();
		target = device.createBuffer({
			byteLength: source$2.byteLength,
			usage: source$2.usage
		});
	}
	return target;
}
function padBuffer({ device, buffer, attribute, fromLength, toLength, fromStartIndices, getData = (x$1) => x$1 }) {
	const precisionMultiplier = attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;
	const size = attribute.size * precisionMultiplier;
	const byteOffset = attribute.byteOffset;
	const targetByteOffset = attribute.settings.bytesPerElement < 4 ? byteOffset / attribute.settings.bytesPerElement * 4 : byteOffset;
	const toStartIndices = attribute.startIndices;
	const hasStartIndices = fromStartIndices && toStartIndices;
	const isConstant = attribute.isConstant;
	if (!hasStartIndices && buffer && fromLength >= toLength) return buffer;
	const ArrayType = attribute.value instanceof Float64Array ? Float32Array : attribute.value.constructor;
	const toData = isConstant ? attribute.value : new ArrayType(attribute.getBuffer().readSyncWebGL(byteOffset, toLength * ArrayType.BYTES_PER_ELEMENT).buffer);
	if (attribute.settings.normalized && !isConstant) {
		const getter = getData;
		getData = (value, chunk) => attribute.normalizeConstant(getter(value, chunk));
	}
	const getMissingData = isConstant ? (i$1, chunk) => getData(toData, chunk) : (i$1, chunk) => getData(toData.subarray(i$1 + byteOffset, i$1 + byteOffset + size), chunk);
	const source$2 = buffer ? new Float32Array(buffer.readSyncWebGL(targetByteOffset, fromLength * 4).buffer) : new Float32Array(0);
	const target = new Float32Array(toLength);
	padArray({
		source: source$2,
		target,
		sourceStartIndices: fromStartIndices,
		targetStartIndices: toStartIndices,
		size,
		getData: getMissingData
	});
	if (!buffer || buffer.byteLength < target.byteLength + targetByteOffset) {
		buffer?.destroy();
		buffer = device.createBuffer({
			byteLength: target.byteLength + targetByteOffset,
			usage: 35050
		});
	}
	buffer.write(target, targetByteOffset);
	return buffer;
}

//#endregion
//#region node_modules/@deck.gl/core/dist/transitions/gpu-transition.js
var GPUTransitionBase = class {
	constructor({ device, attribute, timeline }) {
		this.buffers = [];
		/** The vertex count of the last buffer.
		* Buffer may be larger than the actual length we want to use
		* because we only reallocate buffers when they grow, not when they shrink,
		* due to performance costs */
		this.currentLength = 0;
		this.device = device;
		this.transition = new Transition(timeline);
		this.attribute = attribute;
		this.attributeInTransition = cloneAttribute(attribute);
		this.currentStartIndices = attribute.startIndices;
	}
	get inProgress() {
		return this.transition.inProgress;
	}
	start(transitionSettings, numInstances, duration = Infinity) {
		this.settings = transitionSettings;
		this.currentStartIndices = this.attribute.startIndices;
		this.currentLength = getAttributeBufferLength(this.attribute, numInstances);
		this.transition.start({
			...transitionSettings,
			duration
		});
	}
	update() {
		const updated = this.transition.update();
		if (updated) this.onUpdate();
		return updated;
	}
	setBuffer(buffer) {
		this.attributeInTransition.setData({
			buffer,
			normalized: this.attribute.settings.normalized,
			value: this.attributeInTransition.value
		});
	}
	cancel() {
		this.transition.cancel();
	}
	delete() {
		this.cancel();
		for (const buffer of this.buffers) buffer.destroy();
		this.buffers.length = 0;
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/transitions/gpu-interpolation-transition.js
var GPUInterpolationTransition = class extends GPUTransitionBase {
	constructor({ device, attribute, timeline }) {
		super({
			device,
			attribute,
			timeline
		});
		this.type = "interpolation";
		this.transform = getTransform$1(device, attribute);
	}
	start(transitionSettings, numInstances) {
		const prevLength = this.currentLength;
		const prevStartIndices = this.currentStartIndices;
		super.start(transitionSettings, numInstances, transitionSettings.duration);
		if (transitionSettings.duration <= 0) {
			this.transition.cancel();
			return;
		}
		const { buffers, attribute } = this;
		cycleBuffers(buffers);
		buffers[0] = padBuffer({
			device: this.device,
			buffer: buffers[0],
			attribute,
			fromLength: prevLength,
			toLength: this.currentLength,
			fromStartIndices: prevStartIndices,
			getData: transitionSettings.enter
		});
		buffers[1] = matchBuffer({
			device: this.device,
			source: buffers[0],
			target: buffers[1]
		});
		this.setBuffer(buffers[1]);
		const { transform } = this;
		const model = transform.model;
		let vertexCount = Math.floor(this.currentLength / attribute.size);
		if (useFp64(attribute)) vertexCount /= 2;
		model.setVertexCount(vertexCount);
		if (attribute.isConstant) {
			model.setAttributes({ aFrom: buffers[0] });
			model.setConstantAttributes({ aTo: attribute.value });
		} else model.setAttributes({
			aFrom: buffers[0],
			aTo: attribute.getBuffer()
		});
		transform.transformFeedback.setBuffers({ vCurrent: buffers[1] });
	}
	onUpdate() {
		const { duration, easing } = this.settings;
		const { time } = this.transition;
		let t$1 = time / duration;
		if (easing) t$1 = easing(t$1);
		const { model } = this.transform;
		const interpolationProps = { time: t$1 };
		model.shaderInputs.setProps({ interpolation: interpolationProps });
		this.transform.run({ discard: true });
	}
	delete() {
		super.delete();
		this.transform.destroy();
	}
};
var interpolationUniforms = {
	name: "interpolation",
	vs: `\
uniform interpolationUniforms {
  float time;
} interpolation;
`,
	uniformTypes: { time: "f32" }
};
var vs$1 = `\
#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vCurrent;

void main(void) {
  vCurrent = mix(aFrom, aTo, interpolation.time);
  gl_Position = vec4(0.0);
}
`;
var vs64 = `\
#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aFrom64Low;
in ATTRIBUTE_TYPE aTo;
in ATTRIBUTE_TYPE aTo64Low;
out ATTRIBUTE_TYPE vCurrent;
out ATTRIBUTE_TYPE vCurrent64Low;

vec2 mix_fp64(vec2 a, vec2 b, float x) {
  vec2 range = sub_fp64(b, a);
  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}

void main(void) {
  for (int i=0; i<ATTRIBUTE_SIZE; i++) {
    vec2 value = mix_fp64(vec2(aFrom[i], aFrom64Low[i]), vec2(aTo[i], aTo64Low[i]), interpolation.time);
    vCurrent[i] = value.x;
    vCurrent64Low[i] = value.y;
  }
  gl_Position = vec4(0.0);
}
`;
function useFp64(attribute) {
	return attribute.doublePrecision && attribute.value instanceof Float64Array;
}
function getTransform$1(device, attribute) {
	const attributeSize = attribute.size;
	const attributeType = getAttributeTypeFromSize(attributeSize);
	const inputFormat = getFloat32VertexFormat(attributeSize);
	const bufferLayout = attribute.getBufferLayout();
	if (useFp64(attribute)) return new BufferTransform(device, {
		vs: vs64,
		bufferLayout: [{
			name: "aFrom",
			byteStride: 8 * attributeSize,
			attributes: [{
				attribute: "aFrom",
				format: inputFormat,
				byteOffset: 0
			}, {
				attribute: "aFrom64Low",
				format: inputFormat,
				byteOffset: 4 * attributeSize
			}]
		}, {
			name: "aTo",
			byteStride: 8 * attributeSize,
			attributes: [{
				attribute: "aTo",
				format: inputFormat,
				byteOffset: 0
			}, {
				attribute: "aTo64Low",
				format: inputFormat,
				byteOffset: 4 * attributeSize
			}]
		}],
		modules: [fp64arithmetic, interpolationUniforms],
		defines: {
			ATTRIBUTE_TYPE: attributeType,
			ATTRIBUTE_SIZE: attributeSize
		},
		moduleSettings: {},
		varyings: ["vCurrent", "vCurrent64Low"],
		bufferMode: 35980,
		disableWarnings: true
	});
	return new BufferTransform(device, {
		vs: vs$1,
		bufferLayout: [{
			name: "aFrom",
			format: inputFormat
		}, {
			name: "aTo",
			format: bufferLayout.attributes[0].format
		}],
		modules: [interpolationUniforms],
		defines: { ATTRIBUTE_TYPE: attributeType },
		varyings: ["vCurrent"],
		disableWarnings: true
	});
}

//#endregion
//#region node_modules/@deck.gl/core/dist/transitions/gpu-spring-transition.js
var GPUSpringTransition = class extends GPUTransitionBase {
	constructor({ device, attribute, timeline }) {
		super({
			device,
			attribute,
			timeline
		});
		this.type = "spring";
		this.texture = getTexture(device);
		this.framebuffer = getFramebuffer(device, this.texture);
		this.transform = getTransform(device, attribute);
	}
	start(transitionSettings, numInstances) {
		const prevLength = this.currentLength;
		const prevStartIndices = this.currentStartIndices;
		super.start(transitionSettings, numInstances);
		const { buffers, attribute } = this;
		for (let i$1 = 0; i$1 < 2; i$1++) buffers[i$1] = padBuffer({
			device: this.device,
			buffer: buffers[i$1],
			attribute,
			fromLength: prevLength,
			toLength: this.currentLength,
			fromStartIndices: prevStartIndices,
			getData: transitionSettings.enter
		});
		buffers[2] = matchBuffer({
			device: this.device,
			source: buffers[0],
			target: buffers[2]
		});
		this.setBuffer(buffers[1]);
		const { model } = this.transform;
		model.setVertexCount(Math.floor(this.currentLength / attribute.size));
		if (attribute.isConstant) model.setConstantAttributes({ aTo: attribute.value });
		else model.setAttributes({ aTo: attribute.getBuffer() });
	}
	onUpdate() {
		const { buffers, transform, framebuffer, transition } = this;
		const settings = this.settings;
		transform.model.setAttributes({
			aPrev: buffers[0],
			aCur: buffers[1]
		});
		transform.transformFeedback.setBuffers({ vNext: buffers[2] });
		const springProps = {
			stiffness: settings.stiffness,
			damping: settings.damping
		};
		transform.model.shaderInputs.setProps({ spring: springProps });
		transform.run({
			framebuffer,
			discard: false,
			parameters: { viewport: [
				0,
				0,
				1,
				1
			] },
			clearColor: [
				0,
				0,
				0,
				0
			]
		});
		cycleBuffers(buffers);
		this.setBuffer(buffers[1]);
		if (!(this.device.readPixelsToArrayWebGL(framebuffer)[0] > 0)) transition.end();
	}
	delete() {
		super.delete();
		this.transform.destroy();
		this.texture.destroy();
		this.framebuffer.destroy();
	}
};
var springUniforms = {
	name: "spring",
	vs: `\
uniform springUniforms {
  float damping;
  float stiffness;
} spring;
`,
	uniformTypes: {
		damping: "f32",
		stiffness: "f32"
	}
};
var vs = `\
#version 300 es
#define SHADER_NAME spring-transition-vertex-shader

#define EPSILON 0.00001

in ATTRIBUTE_TYPE aPrev;
in ATTRIBUTE_TYPE aCur;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vNext;
out float vIsTransitioningFlag;

ATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {
  ATTRIBUTE_TYPE velocity = cur - prev;
  ATTRIBUTE_TYPE delta = dest - cur;
  ATTRIBUTE_TYPE force = delta * spring.stiffness;
  ATTRIBUTE_TYPE resistance = velocity * spring.damping;
  return force - resistance + velocity + cur;
}

void main(void) {
  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;
  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;

  vNext = getNextValue(aCur, aPrev, aTo);
  gl_Position = vec4(0, 0, 0, 1);
  gl_PointSize = 100.0;
}
`;
var fs = `\
#version 300 es
#define SHADER_NAME spring-transition-is-transitioning-fragment-shader

in float vIsTransitioningFlag;

out vec4 fragColor;

void main(void) {
  if (vIsTransitioningFlag == 0.0) {
    discard;
  }
  fragColor = vec4(1.0);
}`;
function getTransform(device, attribute) {
	const attributeType = getAttributeTypeFromSize(attribute.size);
	const format = getFloat32VertexFormat(attribute.size);
	return new BufferTransform(device, {
		vs,
		fs,
		bufferLayout: [
			{
				name: "aPrev",
				format
			},
			{
				name: "aCur",
				format
			},
			{
				name: "aTo",
				format: attribute.getBufferLayout().attributes[0].format
			}
		],
		varyings: ["vNext"],
		modules: [springUniforms],
		defines: { ATTRIBUTE_TYPE: attributeType },
		parameters: {
			depthCompare: "always",
			blendColorOperation: "max",
			blendColorSrcFactor: "one",
			blendColorDstFactor: "one",
			blendAlphaOperation: "max",
			blendAlphaSrcFactor: "one",
			blendAlphaDstFactor: "one"
		}
	});
}
function getTexture(device) {
	return device.createTexture({
		data: new Uint8Array(4),
		format: "rgba8unorm",
		width: 1,
		height: 1
	});
}
function getFramebuffer(device, texture) {
	return device.createFramebuffer({
		id: "spring-transition-is-transitioning-framebuffer",
		width: 1,
		height: 1,
		colorAttachments: [texture]
	});
}

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/attribute/attribute-transition-manager.js
var TRANSITION_TYPES$1 = {
	interpolation: GPUInterpolationTransition,
	spring: GPUSpringTransition
};
var AttributeTransitionManager = class {
	constructor(device, { id, timeline }) {
		if (!device) throw new Error("AttributeTransitionManager is constructed without device");
		this.id = id;
		this.device = device;
		this.timeline = timeline;
		this.transitions = {};
		this.needsRedraw = false;
		this.numInstances = 1;
	}
	finalize() {
		for (const attributeName in this.transitions) this._removeTransition(attributeName);
	}
	update({ attributes, transitions, numInstances }) {
		this.numInstances = numInstances || 1;
		for (const attributeName in attributes) {
			const attribute = attributes[attributeName];
			const settings = attribute.getTransitionSetting(transitions);
			if (!settings) continue;
			this._updateAttribute(attributeName, attribute, settings);
		}
		for (const attributeName in this.transitions) {
			const attribute = attributes[attributeName];
			if (!attribute || !attribute.getTransitionSetting(transitions)) this._removeTransition(attributeName);
		}
	}
	hasAttribute(attributeName) {
		const transition = this.transitions[attributeName];
		return transition && transition.inProgress;
	}
	getAttributes() {
		const animatedAttributes = {};
		for (const attributeName in this.transitions) {
			const transition = this.transitions[attributeName];
			if (transition.inProgress) animatedAttributes[attributeName] = transition.attributeInTransition;
		}
		return animatedAttributes;
	}
	run() {
		if (this.numInstances === 0) return false;
		for (const attributeName in this.transitions) if (this.transitions[attributeName].update()) this.needsRedraw = true;
		const needsRedraw = this.needsRedraw;
		this.needsRedraw = false;
		return needsRedraw;
	}
	_removeTransition(attributeName) {
		this.transitions[attributeName].delete();
		delete this.transitions[attributeName];
	}
	_updateAttribute(attributeName, attribute, settings) {
		const transition = this.transitions[attributeName];
		let isNew = !transition || transition.type !== settings.type;
		if (isNew) {
			if (transition) this._removeTransition(attributeName);
			const TransitionType = TRANSITION_TYPES$1[settings.type];
			if (TransitionType) this.transitions[attributeName] = new TransitionType({
				attribute,
				timeline: this.timeline,
				device: this.device
			});
			else {
				log_default.error(`unsupported transition type '${settings.type}'`)();
				isNew = false;
			}
		}
		if (isNew || attribute.needsRedraw()) {
			this.needsRedraw = true;
			this.transitions[attributeName].start(settings, this.numInstances);
		}
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/attribute/attribute-manager.js
var TRACE_INVALIDATE = "attributeManager.invalidate";
var TRACE_UPDATE_START = "attributeManager.updateStart";
var TRACE_UPDATE_END = "attributeManager.updateEnd";
var TRACE_ATTRIBUTE_UPDATE_START = "attribute.updateStart";
var TRACE_ATTRIBUTE_ALLOCATE = "attribute.allocate";
var TRACE_ATTRIBUTE_UPDATE_END = "attribute.updateEnd";
var AttributeManager = class {
	constructor(device, { id = "attribute-manager", stats, timeline } = {}) {
		this.mergeBoundsMemoized = memoize(mergeBounds);
		this.id = id;
		this.device = device;
		this.attributes = {};
		this.updateTriggers = {};
		this.needsRedraw = true;
		this.userData = {};
		this.stats = stats;
		this.attributeTransitionManager = new AttributeTransitionManager(device, {
			id: `${id}-transitions`,
			timeline
		});
		Object.seal(this);
	}
	finalize() {
		for (const attributeName in this.attributes) this.attributes[attributeName].delete();
		this.attributeTransitionManager.finalize();
	}
	getNeedsRedraw(opts = { clearRedrawFlags: false }) {
		const redraw = this.needsRedraw;
		this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;
		return redraw && this.id;
	}
	setNeedsRedraw() {
		this.needsRedraw = true;
	}
	add(attributes) {
		this._add(attributes);
	}
	addInstanced(attributes) {
		this._add(attributes, { stepMode: "instance" });
	}
	/**
	* Removes attributes
	* Takes an array of attribute names and delete them from
	* the attribute map if they exists
	*
	* @example
	* attributeManager.remove(['position']);
	*
	* @param {Object} attributeNameArray - attribute name array (see above)
	*/
	remove(attributeNameArray) {
		for (const name of attributeNameArray) if (this.attributes[name] !== void 0) {
			this.attributes[name].delete();
			delete this.attributes[name];
		}
	}
	invalidate(triggerName, dataRange) {
		const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);
		debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);
	}
	invalidateAll(dataRange) {
		for (const attributeName in this.attributes) this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);
		debug(TRACE_INVALIDATE, this, "all");
	}
	update({ data, numInstances, startIndices = null, transitions, props = {}, buffers = {}, context = {} }) {
		let updated = false;
		debug(TRACE_UPDATE_START, this);
		if (this.stats) this.stats.get("Update Attributes").timeStart();
		for (const attributeName in this.attributes) {
			const attribute = this.attributes[attributeName];
			const accessorName = attribute.settings.accessor;
			attribute.startIndices = startIndices;
			attribute.numInstances = numInstances;
			if (props[attributeName]) log_default.removed(`props.${attributeName}`, `data.attributes.${attributeName}`)();
			if (attribute.setExternalBuffer(buffers[attributeName])) {} else if (attribute.setBinaryValue(typeof accessorName === "string" ? buffers[accessorName] : void 0, data.startIndices)) {} else if (typeof accessorName === "string" && !buffers[accessorName] && attribute.setConstantValue(context, props[accessorName])) {} else if (attribute.needsUpdate()) {
				updated = true;
				this._updateAttribute({
					attribute,
					numInstances,
					data,
					props,
					context
				});
			}
			this.needsRedraw = this.needsRedraw || attribute.needsRedraw();
		}
		if (updated) debug(TRACE_UPDATE_END, this, numInstances);
		if (this.stats) this.stats.get("Update Attributes").timeEnd();
		this.attributeTransitionManager.update({
			attributes: this.attributes,
			numInstances,
			transitions
		});
	}
	updateTransition() {
		const { attributeTransitionManager } = this;
		const transitionUpdated = attributeTransitionManager.run();
		this.needsRedraw = this.needsRedraw || transitionUpdated;
		return transitionUpdated;
	}
	/**
	* Returns all attribute descriptors
	* Note: Format matches luma.gl Model/Program.setAttributes()
	* @return {Object} attributes - descriptors
	*/
	getAttributes() {
		return {
			...this.attributes,
			...this.attributeTransitionManager.getAttributes()
		};
	}
	/**
	* Computes the spatial bounds of a given set of attributes
	*/
	getBounds(attributeNames) {
		const bounds = attributeNames.map((attributeName) => this.attributes[attributeName]?.getBounds());
		return this.mergeBoundsMemoized(bounds);
	}
	/**
	* Returns changed attribute descriptors
	* This indicates which WebGLBuffers need to be updated
	* @return {Object} attributes - descriptors
	*/
	getChangedAttributes(opts = { clearChangedFlags: false }) {
		const { attributes, attributeTransitionManager } = this;
		const changedAttributes = { ...attributeTransitionManager.getAttributes() };
		for (const attributeName in attributes) {
			const attribute = attributes[attributeName];
			if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) changedAttributes[attributeName] = attribute;
		}
		return changedAttributes;
	}
	/** Generate WebGPU-style buffer layout descriptors from all attributes */
	getBufferLayouts(modelInfo) {
		return Object.values(this.getAttributes()).map((attribute) => attribute.getBufferLayout(modelInfo));
	}
	/** Register new attributes */
	_add(attributes, overrideOptions) {
		for (const attributeName in attributes) {
			const attribute = attributes[attributeName];
			const props = {
				...attribute,
				id: attributeName,
				size: attribute.isIndexed && 1 || attribute.size || 1,
				...overrideOptions
			};
			this.attributes[attributeName] = new Attribute(this.device, props);
		}
		this._mapUpdateTriggersToAttributes();
	}
	_mapUpdateTriggersToAttributes() {
		const triggers = {};
		for (const attributeName in this.attributes) this.attributes[attributeName].getUpdateTriggers().forEach((triggerName) => {
			if (!triggers[triggerName]) triggers[triggerName] = [];
			triggers[triggerName].push(attributeName);
		});
		this.updateTriggers = triggers;
	}
	_invalidateTrigger(triggerName, dataRange) {
		const { attributes, updateTriggers } = this;
		const invalidatedAttributes = updateTriggers[triggerName];
		if (invalidatedAttributes) invalidatedAttributes.forEach((name) => {
			const attribute = attributes[name];
			if (attribute) attribute.setNeedsUpdate(attribute.id, dataRange);
		});
		return invalidatedAttributes;
	}
	_updateAttribute(opts) {
		const { attribute, numInstances } = opts;
		debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);
		if (attribute.constant) {
			attribute.setConstantValue(opts.context, attribute.value);
			return;
		}
		if (attribute.allocate(numInstances)) debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);
		if (attribute.updateBuffer(opts)) {
			this.needsRedraw = true;
			debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);
		}
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/transitions/cpu-interpolation-transition.js
var CPUInterpolationTransition = class extends Transition {
	get value() {
		return this._value;
	}
	_onUpdate() {
		const { time, settings: { fromValue, toValue, duration, easing } } = this;
		this._value = lerp(fromValue, toValue, easing(time / duration));
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/transitions/cpu-spring-transition.js
var EPSILON = 1e-5;
function updateSpringElement(prev, cur, dest, damping, stiffness) {
	const velocity = cur - prev;
	return (dest - cur) * stiffness + -velocity * damping + velocity + cur;
}
function updateSpring(prev, cur, dest, damping, stiffness) {
	if (Array.isArray(dest)) {
		const next = [];
		for (let i$1 = 0; i$1 < dest.length; i$1++) next[i$1] = updateSpringElement(prev[i$1], cur[i$1], dest[i$1], damping, stiffness);
		return next;
	}
	return updateSpringElement(prev, cur, dest, damping, stiffness);
}
function distance(value1, value2) {
	if (Array.isArray(value1)) {
		let distanceSquare = 0;
		for (let i$1 = 0; i$1 < value1.length; i$1++) {
			const d$1 = value1[i$1] - value2[i$1];
			distanceSquare += d$1 * d$1;
		}
		return Math.sqrt(distanceSquare);
	}
	return Math.abs(value1 - value2);
}
var CPUSpringTransition = class extends Transition {
	get value() {
		return this._currValue;
	}
	_onUpdate() {
		const { fromValue, toValue, damping, stiffness } = this.settings;
		const { _prevValue = fromValue, _currValue = fromValue } = this;
		let nextValue = updateSpring(_prevValue, _currValue, toValue, damping, stiffness);
		const delta = distance(nextValue, toValue);
		const velocity = distance(nextValue, _currValue);
		if (delta < EPSILON && velocity < EPSILON) {
			nextValue = toValue;
			this.end();
		}
		this._prevValue = _currValue;
		this._currValue = nextValue;
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/uniform-transition-manager.js
var TRANSITION_TYPES = {
	interpolation: CPUInterpolationTransition,
	spring: CPUSpringTransition
};
var UniformTransitionManager = class {
	constructor(timeline) {
		this.transitions = /* @__PURE__ */ new Map();
		this.timeline = timeline;
	}
	get active() {
		return this.transitions.size > 0;
	}
	add(key, fromValue, toValue, settings) {
		const { transitions } = this;
		if (transitions.has(key)) {
			const transition$1 = transitions.get(key);
			const { value = transition$1.settings.fromValue } = transition$1;
			fromValue = value;
			this.remove(key);
		}
		settings = normalizeTransitionSettings(settings);
		if (!settings) return;
		const TransitionType = TRANSITION_TYPES[settings.type];
		if (!TransitionType) {
			log_default.error(`unsupported transition type '${settings.type}'`)();
			return;
		}
		const transition = new TransitionType(this.timeline);
		transition.start({
			...settings,
			fromValue,
			toValue
		});
		transitions.set(key, transition);
	}
	remove(key) {
		const { transitions } = this;
		if (transitions.has(key)) {
			transitions.get(key).cancel();
			transitions.delete(key);
		}
	}
	update() {
		const propsInTransition = {};
		for (const [key, transition] of this.transitions) {
			transition.update();
			propsInTransition[key] = transition.value;
			if (!transition.inProgress) this.remove(key);
		}
		return propsInTransition;
	}
	clear() {
		for (const key of this.transitions.keys()) this.remove(key);
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/lifecycle/props.js
function validateProps(props) {
	const propTypes = props[PROP_TYPES_SYMBOL];
	for (const propName in propTypes) {
		const propType = propTypes[propName];
		const { validate } = propType;
		if (validate && !validate(props[propName], propType)) throw new Error(`Invalid prop ${propName}: ${props[propName]}`);
	}
}
function diffProps(props, oldProps) {
	const propsChangedReason = compareProps({
		newProps: props,
		oldProps,
		propTypes: props[PROP_TYPES_SYMBOL],
		ignoreProps: {
			data: null,
			updateTriggers: null,
			extensions: null,
			transitions: null
		}
	});
	const dataChangedReason = diffDataProps(props, oldProps);
	let updateTriggersChangedReason = false;
	if (!dataChangedReason) updateTriggersChangedReason = diffUpdateTriggers(props, oldProps);
	return {
		dataChanged: dataChangedReason,
		propsChanged: propsChangedReason,
		updateTriggersChanged: updateTriggersChangedReason,
		extensionsChanged: diffExtensions(props, oldProps),
		transitionsChanged: diffTransitions(props, oldProps)
	};
}
function diffTransitions(props, oldProps) {
	if (!props.transitions) return false;
	const result = {};
	const propTypes = props[PROP_TYPES_SYMBOL];
	let changed = false;
	for (const key in props.transitions) {
		const propType = propTypes[key];
		const type = propType && propType.type;
		if ((type === "number" || type === "color" || type === "array") && comparePropValues(props[key], oldProps[key], propType)) {
			result[key] = true;
			changed = true;
		}
	}
	return changed ? result : false;
}
/**
* Performs equality by iterating through keys on an object and returning false
* when any key has values which are not strictly equal between the arguments.
* @param {Object} opt.oldProps - object with old key/value pairs
* @param {Object} opt.newProps - object with new key/value pairs
* @param {Object} opt.ignoreProps={} - object, keys that should not be compared
* @returns {null|String} - null when values of all keys are strictly equal.
*   if unequal, returns a string explaining what changed.
*/
function compareProps({ newProps, oldProps, ignoreProps = {}, propTypes = {}, triggerName = "props" }) {
	if (oldProps === newProps) return false;
	if (typeof newProps !== "object" || newProps === null) return `${triggerName} changed shallowly`;
	if (typeof oldProps !== "object" || oldProps === null) return `${triggerName} changed shallowly`;
	for (const key of Object.keys(newProps)) if (!(key in ignoreProps)) {
		if (!(key in oldProps)) return `${triggerName}.${key} added`;
		const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);
		if (changed) return `${triggerName}.${key} ${changed}`;
	}
	for (const key of Object.keys(oldProps)) if (!(key in ignoreProps)) {
		if (!(key in newProps)) return `${triggerName}.${key} dropped`;
		if (!Object.hasOwnProperty.call(newProps, key)) {
			const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);
			if (changed) return `${triggerName}.${key} ${changed}`;
		}
	}
	return false;
}
function comparePropValues(newProp, oldProp, propType) {
	let equal = propType && propType.equal;
	if (equal && !equal(newProp, oldProp, propType)) return "changed deeply";
	if (!equal) {
		equal = newProp && oldProp && newProp.equals;
		if (equal && !equal.call(newProp, oldProp)) return "changed deeply";
	}
	if (!equal && oldProp !== newProp) return "changed shallowly";
	return null;
}
function diffDataProps(props, oldProps) {
	if (oldProps === null) return "oldProps is null, initial diff";
	let dataChanged = false;
	const { dataComparator, _dataDiff } = props;
	if (dataComparator) {
		if (!dataComparator(props.data, oldProps.data)) dataChanged = "Data comparator detected a change";
	} else if (props.data !== oldProps.data) dataChanged = "A new data container was supplied";
	if (dataChanged && _dataDiff) dataChanged = _dataDiff(props.data, oldProps.data) || dataChanged;
	return dataChanged;
}
function diffUpdateTriggers(props, oldProps) {
	if (oldProps === null) return { all: true };
	if ("all" in props.updateTriggers) {
		if (diffUpdateTrigger(props, oldProps, "all")) return { all: true };
	}
	const reason = {};
	let changed = false;
	for (const triggerName in props.updateTriggers) if (triggerName !== "all") {
		if (diffUpdateTrigger(props, oldProps, triggerName)) {
			reason[triggerName] = true;
			changed = true;
		}
	}
	return changed ? reason : false;
}
function diffExtensions(props, oldProps) {
	if (oldProps === null) return true;
	const oldExtensions = oldProps.extensions;
	const { extensions } = props;
	if (extensions === oldExtensions) return false;
	if (!oldExtensions || !extensions) return true;
	if (extensions.length !== oldExtensions.length) return true;
	for (let i$1 = 0; i$1 < extensions.length; i$1++) if (!extensions[i$1].equals(oldExtensions[i$1])) return true;
	return false;
}
function diffUpdateTrigger(props, oldProps, triggerName) {
	let newTriggers = props.updateTriggers[triggerName];
	newTriggers = newTriggers === void 0 || newTriggers === null ? {} : newTriggers;
	let oldTriggers = oldProps.updateTriggers[triggerName];
	oldTriggers = oldTriggers === void 0 || oldTriggers === null ? {} : oldTriggers;
	return compareProps({
		oldProps: oldTriggers,
		newProps: newTriggers,
		triggerName
	});
}

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/count.js
var ERR_NOT_OBJECT = "count(): argument not an object";
var ERR_NOT_CONTAINER = "count(): argument not a container";
/**
* Deduces numer of elements in a JavaScript container.
* - Auto-deduction for ES6 containers that define a count() method
* - Auto-deduction for ES6 containers that define a size member
* - Auto-deduction for Classic Arrays via the built-in length attribute
* - Also handles objects, although note that this an O(N) operation
*/
function count(container) {
	if (!isObject(container)) throw new Error(ERR_NOT_OBJECT);
	if (typeof container.count === "function") return container.count();
	if (Number.isFinite(container.size)) return container.size;
	if (Number.isFinite(container.length)) return container.length;
	if (isPlainObject(container)) return Object.keys(container).length;
	throw new Error(ERR_NOT_CONTAINER);
}
/**
* Checks if argument is a plain object (not a class or array etc)
* @param {*} value - JavaScript value to be tested
* @return {Boolean} - true if argument is a plain JavaScript object
*/
function isPlainObject(value) {
	return value !== null && typeof value === "object" && value.constructor === Object;
}
/**
* Checks if argument is an indexable object (not a primitive value, nor null)
* @param {*} value - JavaScript value to be tested
* @return {Boolean} - true if argument is a JavaScript object
*/
function isObject(value) {
	return value !== null && typeof value === "object";
}

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/shader.js
function mergeShaders(target, source$2) {
	if (!source$2) return target;
	const result = {
		...target,
		...source$2
	};
	if ("defines" in source$2) result.defines = {
		...target.defines,
		...source$2.defines
	};
	if ("modules" in source$2) {
		result.modules = (target.modules || []).concat(source$2.modules);
		if (source$2.modules.some((module) => module.name === "project64")) {
			const index = result.modules.findIndex((module) => module.name === "project32");
			if (index >= 0) result.modules.splice(index, 1);
		}
	}
	if ("inject" in source$2) if (!target.inject) result.inject = source$2.inject;
	else {
		const mergedInjection = { ...target.inject };
		for (const key in source$2.inject) mergedInjection[key] = (mergedInjection[key] || "") + source$2.inject[key];
		result.inject = mergedInjection;
	}
	return result;
}

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/texture.js
var DEFAULT_TEXTURE_PARAMETERS = {
	minFilter: "linear",
	mipmapFilter: "linear",
	magFilter: "linear",
	addressModeU: "clamp-to-edge",
	addressModeV: "clamp-to-edge"
};
var internalTextures = {};
/**
*
* @param owner
* @param device
* @param image could be one of:
*   - Texture
*   - Browser object: Image, ImageData, ImageData, HTMLCanvasElement, HTMLVideoElement, ImageBitmap
*   - Plain object: {width: <number>, height: <number>, data: <Uint8Array>}
* @param parameters
* @returns
*/
function createTexture(owner, device, image, sampler) {
	if (image instanceof Texture) return image;
	else if (image.constructor && image.constructor.name !== "Object") image = { data: image };
	let samplerParameters = null;
	if (image.compressed) samplerParameters = {
		minFilter: "linear",
		mipmapFilter: image.data.length > 1 ? "nearest" : "linear"
	};
	const { width, height } = image.data;
	const texture = device.createTexture({
		...image,
		sampler: {
			...DEFAULT_TEXTURE_PARAMETERS,
			...samplerParameters,
			...sampler
		},
		mipLevels: device.getMipLevelCount(width, height)
	});
	texture.generateMipmapsWebGL();
	internalTextures[texture.id] = owner;
	return texture;
}
function destroyTexture(owner, texture) {
	if (!texture || !(texture instanceof Texture)) return;
	if (internalTextures[texture.id] === owner) {
		texture.delete();
		delete internalTextures[texture.id];
	}
}

//#endregion
//#region node_modules/@deck.gl/core/dist/lifecycle/prop-types.js
var TYPE_DEFINITIONS = {
	boolean: {
		validate(value, propType) {
			return true;
		},
		equal(value1, value2, propType) {
			return Boolean(value1) === Boolean(value2);
		}
	},
	number: { validate(value, propType) {
		return Number.isFinite(value) && (!("max" in propType) || value <= propType.max) && (!("min" in propType) || value >= propType.min);
	} },
	color: {
		validate(value, propType) {
			return propType.optional && !value || isArray(value) && (value.length === 3 || value.length === 4);
		},
		equal(value1, value2, propType) {
			return deepEqual(value1, value2, 1);
		}
	},
	accessor: {
		validate(value, propType) {
			const valueType = getTypeOf(value);
			return valueType === "function" || valueType === getTypeOf(propType.value);
		},
		equal(value1, value2, propType) {
			if (typeof value2 === "function") return true;
			return deepEqual(value1, value2, 1);
		}
	},
	array: {
		validate(value, propType) {
			return propType.optional && !value || isArray(value);
		},
		equal(value1, value2, propType) {
			const { compare } = propType;
			return compare ? deepEqual(value1, value2, Number.isInteger(compare) ? compare : compare ? 1 : 0) : value1 === value2;
		}
	},
	object: { equal(value1, value2, propType) {
		if (propType.ignore) return true;
		const { compare } = propType;
		return compare ? deepEqual(value1, value2, Number.isInteger(compare) ? compare : compare ? 1 : 0) : value1 === value2;
	} },
	function: {
		validate(value, propType) {
			return propType.optional && !value || typeof value === "function";
		},
		equal(value1, value2, propType) {
			return !propType.compare && propType.ignore !== false || value1 === value2;
		}
	},
	data: { transform: (value, propType, component) => {
		if (!value) return value;
		const { dataTransform } = component.props;
		if (dataTransform) return dataTransform(value);
		if (typeof value.shape === "string" && value.shape.endsWith("-table") && Array.isArray(value.data)) return value.data;
		return value;
	} },
	image: {
		transform: (value, propType, component) => {
			const context = component.context;
			if (!context || !context.device) return null;
			return createTexture(component.id, context.device, value, {
				...propType.parameters,
				...component.props.textureParameters
			});
		},
		release: (value, propType, component) => {
			destroyTexture(component.id, value);
		}
	}
};
function parsePropTypes(propDefs) {
	const propTypes = {};
	const defaultProps$2 = {};
	const deprecatedProps = {};
	for (const [propName, propDef] of Object.entries(propDefs)) {
		const deprecated = propDef?.deprecatedFor;
		if (deprecated) deprecatedProps[propName] = Array.isArray(deprecated) ? deprecated : [deprecated];
		else {
			const propType = parsePropType(propName, propDef);
			propTypes[propName] = propType;
			defaultProps$2[propName] = propType.value;
		}
	}
	return {
		propTypes,
		defaultProps: defaultProps$2,
		deprecatedProps
	};
}
function parsePropType(name, propDef) {
	switch (getTypeOf(propDef)) {
		case "object": return normalizePropDefinition(name, propDef);
		case "array": return normalizePropDefinition(name, {
			type: "array",
			value: propDef,
			compare: false
		});
		case "boolean": return normalizePropDefinition(name, {
			type: "boolean",
			value: propDef
		});
		case "number": return normalizePropDefinition(name, {
			type: "number",
			value: propDef
		});
		case "function": return normalizePropDefinition(name, {
			type: "function",
			value: propDef,
			compare: true
		});
		default: return {
			name,
			type: "unknown",
			value: propDef
		};
	}
}
function normalizePropDefinition(name, propDef) {
	if (!("type" in propDef)) {
		if (!("value" in propDef)) return {
			name,
			type: "object",
			value: propDef
		};
		return {
			name,
			type: getTypeOf(propDef.value),
			...propDef
		};
	}
	return {
		name,
		...TYPE_DEFINITIONS[propDef.type],
		...propDef
	};
}
function isArray(value) {
	return Array.isArray(value) || ArrayBuffer.isView(value);
}
function getTypeOf(value) {
	if (isArray(value)) return "array";
	if (value === null) return "null";
	return typeof value;
}

//#endregion
//#region node_modules/@deck.gl/core/dist/lifecycle/create-props.js
function createProps(component, propObjects) {
	let extensions;
	for (let i$1 = propObjects.length - 1; i$1 >= 0; i$1--) {
		const props = propObjects[i$1];
		if ("extensions" in props) extensions = props.extensions;
	}
	const propsPrototype = getPropsPrototype(component.constructor, extensions);
	const propsInstance = Object.create(propsPrototype);
	propsInstance[COMPONENT_SYMBOL] = component;
	propsInstance[ASYNC_ORIGINAL_SYMBOL] = {};
	propsInstance[ASYNC_RESOLVED_SYMBOL] = {};
	for (let i$1 = 0; i$1 < propObjects.length; ++i$1) {
		const props = propObjects[i$1];
		for (const key in props) propsInstance[key] = props[key];
	}
	Object.freeze(propsInstance);
	return propsInstance;
}
var MergedDefaultPropsCacheKey = "_mergedDefaultProps";
function getPropsPrototype(componentClass, extensions) {
	if (!(componentClass instanceof component_default.constructor)) return {};
	let cacheKey = MergedDefaultPropsCacheKey;
	if (extensions) for (const extension of extensions) {
		const ExtensionClass = extension.constructor;
		if (ExtensionClass) cacheKey += `:${ExtensionClass.extensionName || ExtensionClass.name}`;
	}
	const defaultProps$2 = getOwnProperty(componentClass, cacheKey);
	if (!defaultProps$2) return componentClass[cacheKey] = createPropsPrototypeAndTypes(componentClass, extensions || []);
	return defaultProps$2;
}
function createPropsPrototypeAndTypes(componentClass, extensions) {
	if (!componentClass.prototype) return null;
	const parentDefaultProps = getPropsPrototype(Object.getPrototypeOf(componentClass));
	const componentPropDefs = parsePropTypes(getOwnProperty(componentClass, "defaultProps") || {});
	const defaultProps$2 = Object.assign(Object.create(null), parentDefaultProps, componentPropDefs.defaultProps);
	const propTypes = Object.assign(Object.create(null), parentDefaultProps?.[PROP_TYPES_SYMBOL], componentPropDefs.propTypes);
	const deprecatedProps = Object.assign(Object.create(null), parentDefaultProps?.[DEPRECATED_PROPS_SYMBOL], componentPropDefs.deprecatedProps);
	for (const extension of extensions) {
		const extensionDefaultProps = getPropsPrototype(extension.constructor);
		if (extensionDefaultProps) {
			Object.assign(defaultProps$2, extensionDefaultProps);
			Object.assign(propTypes, extensionDefaultProps[PROP_TYPES_SYMBOL]);
			Object.assign(deprecatedProps, extensionDefaultProps[DEPRECATED_PROPS_SYMBOL]);
		}
	}
	createPropsPrototype(defaultProps$2, componentClass);
	addAsyncPropsToPropPrototype(defaultProps$2, propTypes);
	addDeprecatedPropsToPropPrototype(defaultProps$2, deprecatedProps);
	defaultProps$2[PROP_TYPES_SYMBOL] = propTypes;
	defaultProps$2[DEPRECATED_PROPS_SYMBOL] = deprecatedProps;
	if (extensions.length === 0 && !hasOwnProperty(componentClass, "_propTypes")) componentClass._propTypes = propTypes;
	return defaultProps$2;
}
function createPropsPrototype(defaultProps$2, componentClass) {
	const id = getComponentName(componentClass);
	Object.defineProperties(defaultProps$2, { id: {
		writable: true,
		value: id
	} });
}
function addDeprecatedPropsToPropPrototype(defaultProps$2, deprecatedProps) {
	for (const propName in deprecatedProps) Object.defineProperty(defaultProps$2, propName, {
		enumerable: false,
		set(newValue) {
			const nameStr = `${this.id}: ${propName}`;
			for (const newPropName of deprecatedProps[propName]) if (!hasOwnProperty(this, newPropName)) this[newPropName] = newValue;
			log_default.deprecated(nameStr, deprecatedProps[propName].join("/"))();
		}
	});
}
function addAsyncPropsToPropPrototype(defaultProps$2, propTypes) {
	const defaultValues = {};
	const descriptors = {};
	for (const propName in propTypes) {
		const propType = propTypes[propName];
		const { name, value } = propType;
		if (propType.async) {
			defaultValues[name] = value;
			descriptors[name] = getDescriptorForAsyncProp(name);
		}
	}
	defaultProps$2[ASYNC_DEFAULTS_SYMBOL] = defaultValues;
	defaultProps$2[ASYNC_ORIGINAL_SYMBOL] = {};
	Object.defineProperties(defaultProps$2, descriptors);
}
function getDescriptorForAsyncProp(name) {
	return {
		enumerable: true,
		set(newValue) {
			if (typeof newValue === "string" || newValue instanceof Promise || isAsyncIterable(newValue)) this[ASYNC_ORIGINAL_SYMBOL][name] = newValue;
			else this[ASYNC_RESOLVED_SYMBOL][name] = newValue;
		},
		get() {
			if (this[ASYNC_RESOLVED_SYMBOL]) {
				if (name in this[ASYNC_RESOLVED_SYMBOL]) return this[ASYNC_RESOLVED_SYMBOL][name] || this[ASYNC_DEFAULTS_SYMBOL][name];
				if (name in this[ASYNC_ORIGINAL_SYMBOL]) {
					const state = this[COMPONENT_SYMBOL] && this[COMPONENT_SYMBOL].internalState;
					if (state && state.hasAsyncProp(name)) return state.getAsyncProp(name) || this[ASYNC_DEFAULTS_SYMBOL][name];
				}
			}
			return this[ASYNC_DEFAULTS_SYMBOL][name];
		}
	};
}
function hasOwnProperty(object, prop) {
	return Object.prototype.hasOwnProperty.call(object, prop);
}
function getOwnProperty(object, prop) {
	return hasOwnProperty(object, prop) && object[prop];
}
function getComponentName(componentClass) {
	const componentName = componentClass.componentName;
	if (!componentName) log_default.warn(`${componentClass.name}.componentName not specified`)();
	return componentName || componentClass.name;
}

//#endregion
//#region node_modules/@deck.gl/core/dist/lifecycle/component.js
var counter = 0;
var Component = class {
	constructor(...propObjects) {
		this.props = createProps(this, propObjects);
		this.id = this.props.id;
		this.count = counter++;
	}
	clone(newProps) {
		const { props } = this;
		const asyncProps = {};
		for (const key in props[ASYNC_DEFAULTS_SYMBOL]) if (key in props[ASYNC_RESOLVED_SYMBOL]) asyncProps[key] = props[ASYNC_RESOLVED_SYMBOL][key];
		else if (key in props[ASYNC_ORIGINAL_SYMBOL]) asyncProps[key] = props[ASYNC_ORIGINAL_SYMBOL][key];
		return new this.constructor({
			...props,
			...asyncProps,
			...newProps
		});
	}
};
Component.componentName = "Component";
Component.defaultProps = {};
var component_default = Component;

//#endregion
//#region node_modules/@deck.gl/core/dist/lifecycle/component-state.js
var EMPTY_PROPS = Object.freeze({});
var ComponentState = class {
	constructor(component) {
		this.component = component;
		this.asyncProps = {};
		this.onAsyncPropUpdated = () => {};
		this.oldProps = null;
		this.oldAsyncProps = null;
	}
	finalize() {
		for (const propName in this.asyncProps) {
			const asyncProp = this.asyncProps[propName];
			if (asyncProp && asyncProp.type && asyncProp.type.release) asyncProp.type.release(asyncProp.resolvedValue, asyncProp.type, this.component);
		}
		this.asyncProps = {};
		this.component = null;
		this.resetOldProps();
	}
	getOldProps() {
		return this.oldAsyncProps || this.oldProps || EMPTY_PROPS;
	}
	resetOldProps() {
		this.oldAsyncProps = null;
		this.oldProps = this.component ? this.component.props : null;
	}
	hasAsyncProp(propName) {
		return propName in this.asyncProps;
	}
	getAsyncProp(propName) {
		const asyncProp = this.asyncProps[propName];
		return asyncProp && asyncProp.resolvedValue;
	}
	isAsyncPropLoading(propName) {
		if (propName) {
			const asyncProp = this.asyncProps[propName];
			return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);
		}
		for (const key in this.asyncProps) if (this.isAsyncPropLoading(key)) return true;
		return false;
	}
	reloadAsyncProp(propName, value) {
		this._watchPromise(propName, Promise.resolve(value));
	}
	setAsyncProps(props) {
		this.component = props[COMPONENT_SYMBOL] || this.component;
		const resolvedValues = props[ASYNC_RESOLVED_SYMBOL] || {};
		const originalValues = props[ASYNC_ORIGINAL_SYMBOL] || props;
		const defaultValues = props[ASYNC_DEFAULTS_SYMBOL] || {};
		for (const propName in resolvedValues) {
			const value = resolvedValues[propName];
			this._createAsyncPropData(propName, defaultValues[propName]);
			this._updateAsyncProp(propName, value);
			resolvedValues[propName] = this.getAsyncProp(propName);
		}
		for (const propName in originalValues) {
			const value = originalValues[propName];
			this._createAsyncPropData(propName, defaultValues[propName]);
			this._updateAsyncProp(propName, value);
		}
	}
	_fetch(propName, url) {
		return null;
	}
	_onResolve(propName, value) {}
	_onError(propName, error) {}
	_updateAsyncProp(propName, value) {
		if (!this._didAsyncInputValueChange(propName, value)) return;
		if (typeof value === "string") value = this._fetch(propName, value);
		if (value instanceof Promise) {
			this._watchPromise(propName, value);
			return;
		}
		if (isAsyncIterable(value)) {
			this._resolveAsyncIterable(propName, value);
			return;
		}
		this._setPropValue(propName, value);
	}
	_freezeAsyncOldProps() {
		if (!this.oldAsyncProps && this.oldProps) {
			this.oldAsyncProps = Object.create(this.oldProps);
			for (const propName in this.asyncProps) Object.defineProperty(this.oldAsyncProps, propName, {
				enumerable: true,
				value: this.oldProps[propName]
			});
		}
	}
	_didAsyncInputValueChange(propName, value) {
		const asyncProp = this.asyncProps[propName];
		if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) return false;
		asyncProp.lastValue = value;
		return true;
	}
	_setPropValue(propName, value) {
		this._freezeAsyncOldProps();
		const asyncProp = this.asyncProps[propName];
		if (asyncProp) {
			value = this._postProcessValue(asyncProp, value);
			asyncProp.resolvedValue = value;
			asyncProp.pendingLoadCount++;
			asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;
		}
	}
	_setAsyncPropValue(propName, value, loadCount) {
		const asyncProp = this.asyncProps[propName];
		if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== void 0) {
			this._freezeAsyncOldProps();
			asyncProp.resolvedValue = value;
			asyncProp.resolvedLoadCount = loadCount;
			this.onAsyncPropUpdated(propName, value);
		}
	}
	_watchPromise(propName, promise) {
		const asyncProp = this.asyncProps[propName];
		if (asyncProp) {
			asyncProp.pendingLoadCount++;
			const loadCount = asyncProp.pendingLoadCount;
			promise.then((data) => {
				if (!this.component) return;
				data = this._postProcessValue(asyncProp, data);
				this._setAsyncPropValue(propName, data, loadCount);
				this._onResolve(propName, data);
			}).catch((error) => {
				this._onError(propName, error);
			});
		}
	}
	async _resolveAsyncIterable(propName, iterable) {
		if (propName !== "data") {
			this._setPropValue(propName, iterable);
			return;
		}
		const asyncProp = this.asyncProps[propName];
		if (!asyncProp) return;
		asyncProp.pendingLoadCount++;
		const loadCount = asyncProp.pendingLoadCount;
		let data = [];
		let count$1 = 0;
		for await (const chunk of iterable) {
			if (!this.component) return;
			const { dataTransform } = this.component.props;
			if (dataTransform) data = dataTransform(chunk, data);
			else data = data.concat(chunk);
			Object.defineProperty(data, "__diff", {
				enumerable: false,
				value: [{
					startRow: count$1,
					endRow: data.length
				}]
			});
			count$1 = data.length;
			this._setAsyncPropValue(propName, data, loadCount);
		}
		this._onResolve(propName, data);
	}
	_postProcessValue(asyncProp, value) {
		const propType = asyncProp.type;
		if (propType && this.component) {
			if (propType.release) propType.release(asyncProp.resolvedValue, propType, this.component);
			if (propType.transform) return propType.transform(value, propType, this.component);
		}
		return value;
	}
	_createAsyncPropData(propName, defaultValue) {
		if (!this.asyncProps[propName]) {
			const propTypes = this.component && this.component.props[PROP_TYPES_SYMBOL];
			this.asyncProps[propName] = {
				type: propTypes && propTypes[propName],
				lastValue: null,
				resolvedValue: defaultValue,
				pendingLoadCount: 0,
				resolvedLoadCount: 0
			};
		}
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/layer-state.js
var LayerState = class extends ComponentState {
	constructor({ attributeManager, layer }) {
		super(layer);
		this.attributeManager = attributeManager;
		this.needsRedraw = true;
		this.needsUpdate = true;
		this.subLayers = null;
		this.usesPickingColorCache = false;
	}
	get layer() {
		return this.component;
	}
	_fetch(propName, url) {
		const layer = this.layer;
		const fetch$1 = layer?.props.fetch;
		if (fetch$1) return fetch$1(url, {
			propName,
			layer
		});
		return super._fetch(propName, url);
	}
	_onResolve(propName, value) {
		const layer = this.layer;
		if (layer) {
			const onDataLoad = layer.props.onDataLoad;
			if (propName === "data" && onDataLoad) onDataLoad(value, {
				propName,
				layer
			});
		}
	}
	_onError(propName, error) {
		const layer = this.layer;
		if (layer) layer.raiseError(error, `loading ${propName} of ${this.layer}`);
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/layer.js
var TRACE_CHANGE_FLAG = "layer.changeFlag";
var TRACE_INITIALIZE = "layer.initialize";
var TRACE_UPDATE = "layer.update";
var TRACE_FINALIZE = "layer.finalize";
var TRACE_MATCHED = "layer.matched";
var MAX_PICKING_COLOR_CACHE_SIZE = 2 ** 24 - 1;
var EMPTY_ARRAY = Object.freeze([]);
var areViewportsEqual = memoize(({ oldViewport, viewport }) => {
	return oldViewport.equals(viewport);
});
var pickingColorCache = new Uint8ClampedArray(0);
var defaultProps = {
	data: {
		type: "data",
		value: EMPTY_ARRAY,
		async: true
	},
	dataComparator: {
		type: "function",
		value: null,
		optional: true
	},
	_dataDiff: {
		type: "function",
		value: (data) => data && data.__diff,
		optional: true
	},
	dataTransform: {
		type: "function",
		value: null,
		optional: true
	},
	onDataLoad: {
		type: "function",
		value: null,
		optional: true
	},
	onError: {
		type: "function",
		value: null,
		optional: true
	},
	fetch: {
		type: "function",
		value: (url, { propName, layer, loaders, loadOptions, signal }) => {
			const { resourceManager } = layer.context;
			loadOptions = loadOptions || layer.getLoadOptions();
			loaders = loaders || layer.props.loaders;
			if (signal) loadOptions = {
				...loadOptions,
				fetch: {
					...loadOptions?.fetch,
					signal
				}
			};
			let inResourceManager = resourceManager.contains(url);
			if (!inResourceManager && !loadOptions) {
				resourceManager.add({
					resourceId: url,
					data: load(url, loaders),
					persistent: false
				});
				inResourceManager = true;
			}
			if (inResourceManager) return resourceManager.subscribe({
				resourceId: url,
				onChange: (data) => layer.internalState?.reloadAsyncProp(propName, data),
				consumerId: layer.id,
				requestId: propName
			});
			return load(url, loaders, loadOptions);
		}
	},
	updateTriggers: {},
	visible: true,
	pickable: false,
	opacity: {
		type: "number",
		min: 0,
		max: 1,
		value: 1
	},
	operation: "draw",
	onHover: {
		type: "function",
		value: null,
		optional: true
	},
	onClick: {
		type: "function",
		value: null,
		optional: true
	},
	onDragStart: {
		type: "function",
		value: null,
		optional: true
	},
	onDrag: {
		type: "function",
		value: null,
		optional: true
	},
	onDragEnd: {
		type: "function",
		value: null,
		optional: true
	},
	coordinateSystem: COORDINATE_SYSTEM.DEFAULT,
	coordinateOrigin: {
		type: "array",
		value: [
			0,
			0,
			0
		],
		compare: true
	},
	modelMatrix: {
		type: "array",
		value: null,
		compare: true,
		optional: true
	},
	wrapLongitude: false,
	positionFormat: "XYZ",
	colorFormat: "RGBA",
	parameters: {
		type: "object",
		value: {},
		optional: true,
		compare: 2
	},
	loadOptions: {
		type: "object",
		value: null,
		optional: true,
		ignore: true
	},
	transitions: null,
	extensions: [],
	loaders: {
		type: "array",
		value: [],
		optional: true,
		ignore: true
	},
	getPolygonOffset: {
		type: "function",
		value: ({ layerIndex }) => [0, -layerIndex * 100]
	},
	highlightedObjectIndex: null,
	autoHighlight: false,
	highlightColor: {
		type: "accessor",
		value: [
			0,
			0,
			128,
			128
		]
	}
};
var Layer = class extends component_default {
	constructor() {
		super(...arguments);
		this.internalState = null;
		this.lifecycle = LIFECYCLE.NO_STATE;
		this.parent = null;
	}
	static get componentName() {
		return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : "";
	}
	get root() {
		let layer = this;
		while (layer.parent) layer = layer.parent;
		return layer;
	}
	toString() {
		return `${this.constructor.layerName || this.constructor.name}({id: '${this.props.id}'})`;
	}
	/** Projects a point with current view state from the current layer's coordinate system to screen */
	project(xyz) {
		assert(this.internalState);
		const viewport = this.internalState.viewport || this.context.viewport;
		const [x$1, y$1, z$1] = worldToPixels(getWorldPosition(xyz, {
			viewport,
			modelMatrix: this.props.modelMatrix,
			coordinateOrigin: this.props.coordinateOrigin,
			coordinateSystem: this.props.coordinateSystem
		}), viewport.pixelProjectionMatrix);
		return xyz.length === 2 ? [x$1, y$1] : [
			x$1,
			y$1,
			z$1
		];
	}
	/** Unprojects a screen pixel to the current view's default coordinate system
	Note: this does not reverse `project`. */
	unproject(xy) {
		assert(this.internalState);
		return (this.internalState.viewport || this.context.viewport).unproject(xy);
	}
	/** Projects a point with current view state from the current layer's coordinate system to the world space */
	projectPosition(xyz, params) {
		assert(this.internalState);
		return projectPosition(xyz, {
			viewport: this.internalState.viewport || this.context.viewport,
			modelMatrix: this.props.modelMatrix,
			coordinateOrigin: this.props.coordinateOrigin,
			coordinateSystem: this.props.coordinateSystem,
			...params
		});
	}
	/** `true` if this layer renders other layers */
	get isComposite() {
		return false;
	}
	/** `true` if the layer renders to screen */
	get isDrawable() {
		return true;
	}
	/** Updates selected state members and marks the layer for redraw */
	setState(partialState) {
		this.setChangeFlags({ stateChanged: true });
		Object.assign(this.state, partialState);
		this.setNeedsRedraw();
	}
	/** Sets the redraw flag for this layer, will trigger a redraw next animation frame */
	setNeedsRedraw() {
		if (this.internalState) this.internalState.needsRedraw = true;
	}
	/** Mark this layer as needs a deep update */
	setNeedsUpdate() {
		if (this.internalState) {
			this.context.layerManager.setNeedsUpdate(String(this));
			this.internalState.needsUpdate = true;
		}
	}
	/** Returns true if all async resources are loaded */
	get isLoaded() {
		return this.internalState ? !this.internalState.isAsyncPropLoading() : false;
	}
	/** Returns true if using shader-based WGS84 longitude wrapping */
	get wrapLongitude() {
		return this.props.wrapLongitude;
	}
	/** @deprecated Returns true if the layer is visible in the picking pass */
	isPickable() {
		return this.props.pickable && this.props.visible;
	}
	/** Returns an array of models used by this layer, can be overriden by layer subclass */
	getModels() {
		const state = this.state;
		return state && (state.models || state.model && [state.model]) || [];
	}
	/** Update shader input parameters */
	setShaderModuleProps(...props) {
		for (const model of this.getModels()) model.shaderInputs.setProps(...props);
	}
	/** Returns the attribute manager of this layer */
	getAttributeManager() {
		return this.internalState && this.internalState.attributeManager;
	}
	/** Returns the most recent layer that matched to this state
	(When reacting to an async event, this layer may no longer be the latest) */
	getCurrentLayer() {
		return this.internalState && this.internalState.layer;
	}
	/** Returns the default parse options for async props */
	getLoadOptions() {
		return this.props.loadOptions;
	}
	use64bitPositions() {
		const { coordinateSystem } = this.props;
		return coordinateSystem === COORDINATE_SYSTEM.DEFAULT || coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN;
	}
	onHover(info, pickingEvent) {
		if (this.props.onHover) return this.props.onHover(info, pickingEvent) || false;
		return false;
	}
	onClick(info, pickingEvent) {
		if (this.props.onClick) return this.props.onClick(info, pickingEvent) || false;
		return false;
	}
	nullPickingColor() {
		return [
			0,
			0,
			0
		];
	}
	encodePickingColor(i$1, target = []) {
		target[0] = i$1 + 1 & 255;
		target[1] = i$1 + 1 >> 8 & 255;
		target[2] = i$1 + 1 >> 8 >> 8 & 255;
		return target;
	}
	decodePickingColor(color) {
		assert(color instanceof Uint8Array);
		const [i1, i2, i3] = color;
		return i1 + i2 * 256 + i3 * 65536 - 1;
	}
	/** Deduces number of instances. Intention is to support:
	- Explicit setting of numInstances
	- Auto-deduction for ES6 containers that define a size member
	- Auto-deduction for Classic Arrays via the built-in length attribute
	- Auto-deduction via arrays */
	getNumInstances() {
		if (Number.isFinite(this.props.numInstances)) return this.props.numInstances;
		if (this.state && this.state.numInstances !== void 0) return this.state.numInstances;
		return count(this.props.data);
	}
	/** Buffer layout describes how many attribute values are packed for each data object
	The default (null) is one value each object.
	Some data formats (e.g. paths, polygons) have various length. Their buffer layout
	is in the form of [L0, L1, L2, ...] */
	getStartIndices() {
		if (this.props.startIndices) return this.props.startIndices;
		if (this.state && this.state.startIndices) return this.state.startIndices;
		return null;
	}
	getBounds() {
		return this.getAttributeManager()?.getBounds(["positions", "instancePositions"]);
	}
	getShaders(shaders) {
		shaders = mergeShaders(shaders, {
			disableWarnings: true,
			modules: this.context.defaultShaderModules
		});
		for (const extension of this.props.extensions) shaders = mergeShaders(shaders, extension.getShaders.call(this, extension));
		return shaders;
	}
	/** Controls if updateState should be called. By default returns true if any prop has changed */
	shouldUpdateState(params) {
		return params.changeFlags.propsOrDataChanged;
	}
	/** Default implementation, all attributes will be invalidated and updated when data changes */
	updateState(params) {
		const attributeManager = this.getAttributeManager();
		const { dataChanged } = params.changeFlags;
		if (dataChanged && attributeManager) if (Array.isArray(dataChanged)) for (const dataRange of dataChanged) attributeManager.invalidateAll(dataRange);
		else attributeManager.invalidateAll();
		if (attributeManager) {
			const { props } = params;
			const hasPickingBuffer = this.internalState.hasPickingBuffer;
			const needsPickingBuffer = Number.isInteger(props.highlightedObjectIndex) || props.pickable || props.extensions.some((extension) => extension.getNeedsPickingBuffer.call(this, extension));
			if (hasPickingBuffer !== needsPickingBuffer) {
				this.internalState.hasPickingBuffer = needsPickingBuffer;
				const { pickingColors, instancePickingColors } = attributeManager.attributes;
				const pickingColorsAttribute = pickingColors || instancePickingColors;
				if (pickingColorsAttribute) {
					if (needsPickingBuffer && pickingColorsAttribute.constant) {
						pickingColorsAttribute.constant = false;
						attributeManager.invalidate(pickingColorsAttribute.id);
					}
					if (!pickingColorsAttribute.value && !needsPickingBuffer) {
						pickingColorsAttribute.constant = true;
						pickingColorsAttribute.value = [
							0,
							0,
							0
						];
					}
				}
			}
		}
	}
	/** Called once when layer is no longer matched and state will be discarded. Layers can destroy WebGL resources here. */
	finalizeState(context) {
		for (const model of this.getModels()) model.destroy();
		const attributeManager = this.getAttributeManager();
		if (attributeManager) attributeManager.finalize();
		if (this.context) this.context.resourceManager.unsubscribe({ consumerId: this.id });
		if (this.internalState) {
			this.internalState.uniformTransitions.clear();
			this.internalState.finalize();
		}
	}
	draw(opts) {
		for (const model of this.getModels()) model.draw(opts.renderPass);
	}
	getPickingInfo({ info, mode, sourceLayer }) {
		const { index } = info;
		if (index >= 0) {
			if (Array.isArray(this.props.data)) info.object = this.props.data[index];
		}
		return info;
	}
	/** (Internal) Propagate an error event through the system */
	raiseError(error, message) {
		if (message) error = new Error(`${message}: ${error.message}`, { cause: error });
		if (!this.props.onError?.(error)) this.context?.onError?.(error, this);
	}
	/** (Internal) Checks if this layer needs redraw */
	getNeedsRedraw(opts = { clearRedrawFlags: false }) {
		return this._getNeedsRedraw(opts);
	}
	/** (Internal) Checks if this layer needs a deep update */
	needsUpdate() {
		if (!this.internalState) return false;
		return this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams());
	}
	/** Checks if this layer has ongoing uniform transition */
	hasUniformTransition() {
		return this.internalState?.uniformTransitions.active || false;
	}
	/** Called when this layer is rendered into the given viewport */
	activateViewport(viewport) {
		if (!this.internalState) return;
		const oldViewport = this.internalState.viewport;
		this.internalState.viewport = viewport;
		if (!oldViewport || !areViewportsEqual({
			oldViewport,
			viewport
		})) {
			this.setChangeFlags({ viewportChanged: true });
			if (this.isComposite) {
				if (this.needsUpdate()) this.setNeedsUpdate();
			} else this._update();
		}
	}
	/** Default implementation of attribute invalidation, can be redefined */
	invalidateAttribute(name = "all") {
		const attributeManager = this.getAttributeManager();
		if (!attributeManager) return;
		if (name === "all") attributeManager.invalidateAll();
		else attributeManager.invalidate(name);
	}
	/** Send updated attributes to the WebGL model */
	updateAttributes(changedAttributes) {
		let bufferLayoutChanged = false;
		for (const id in changedAttributes) if (changedAttributes[id].layoutChanged()) bufferLayoutChanged = true;
		for (const model of this.getModels()) this._setModelAttributes(model, changedAttributes, bufferLayoutChanged);
	}
	/** Recalculate any attributes if needed */
	_updateAttributes() {
		const attributeManager = this.getAttributeManager();
		if (!attributeManager) return;
		const props = this.props;
		const numInstances = this.getNumInstances();
		const startIndices = this.getStartIndices();
		attributeManager.update({
			data: props.data,
			numInstances,
			startIndices,
			props,
			transitions: props.transitions,
			buffers: props.data.attributes,
			context: this
		});
		const changedAttributes = attributeManager.getChangedAttributes({ clearChangedFlags: true });
		this.updateAttributes(changedAttributes);
	}
	/** Update attribute transitions. This is called in drawLayer, no model updates required. */
	_updateAttributeTransition() {
		const attributeManager = this.getAttributeManager();
		if (attributeManager) attributeManager.updateTransition();
	}
	/** Update uniform (prop) transitions. This is called in updateState, may result in model updates. */
	_updateUniformTransition() {
		const { uniformTransitions } = this.internalState;
		if (uniformTransitions.active) {
			const propsInTransition = uniformTransitions.update();
			const props = Object.create(this.props);
			for (const key in propsInTransition) Object.defineProperty(props, key, { value: propsInTransition[key] });
			return props;
		}
		return this.props;
	}
	/** Updater for the automatically populated instancePickingColors attribute */
	calculateInstancePickingColors(attribute, { numInstances }) {
		if (attribute.constant) return;
		const cacheSize = Math.floor(pickingColorCache.length / 4);
		this.internalState.usesPickingColorCache = true;
		if (cacheSize < numInstances) {
			if (numInstances > MAX_PICKING_COLOR_CACHE_SIZE) log_default.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")();
			pickingColorCache = typed_array_manager_default.allocate(pickingColorCache, numInstances, {
				size: 4,
				copy: true,
				maxCount: Math.max(numInstances, MAX_PICKING_COLOR_CACHE_SIZE)
			});
			const newCacheSize = Math.floor(pickingColorCache.length / 4);
			const pickingColor = [
				0,
				0,
				0
			];
			for (let i$1 = cacheSize; i$1 < newCacheSize; i$1++) {
				this.encodePickingColor(i$1, pickingColor);
				pickingColorCache[i$1 * 4 + 0] = pickingColor[0];
				pickingColorCache[i$1 * 4 + 1] = pickingColor[1];
				pickingColorCache[i$1 * 4 + 2] = pickingColor[2];
				pickingColorCache[i$1 * 4 + 3] = 0;
			}
		}
		attribute.value = pickingColorCache.subarray(0, numInstances * 4);
	}
	/** Apply changed attributes to model */
	_setModelAttributes(model, changedAttributes, bufferLayoutChanged = false) {
		if (!Object.keys(changedAttributes).length) return;
		if (bufferLayoutChanged) {
			const attributeManager = this.getAttributeManager();
			model.setBufferLayout(attributeManager.getBufferLayouts(model));
			changedAttributes = attributeManager.getAttributes();
		}
		const excludeAttributes = model.userData?.excludeAttributes || {};
		const attributeBuffers = {};
		const constantAttributes = {};
		for (const name in changedAttributes) {
			if (excludeAttributes[name]) continue;
			const values = changedAttributes[name].getValue();
			for (const attributeName in values) {
				const value = values[attributeName];
				if (value instanceof Buffer) if (changedAttributes[name].settings.isIndexed) model.setIndexBuffer(value);
				else attributeBuffers[attributeName] = value;
				else if (value) constantAttributes[attributeName] = value;
			}
		}
		model.setAttributes(attributeBuffers);
		model.setConstantAttributes(constantAttributes);
	}
	/** (Internal) Sets the picking color at the specified index to null picking color. Used for multi-depth picking.
	This method may be overriden by layer implementations */
	disablePickingIndex(objectIndex) {
		const data = this.props.data;
		if (!("attributes" in data)) {
			this._disablePickingIndex(objectIndex);
			return;
		}
		const { pickingColors, instancePickingColors } = this.getAttributeManager().attributes;
		const colors = pickingColors || instancePickingColors;
		const externalColorAttribute = colors && data.attributes && data.attributes[colors.id];
		if (externalColorAttribute && externalColorAttribute.value) {
			const values = externalColorAttribute.value;
			const objectColor = this.encodePickingColor(objectIndex);
			for (let index = 0; index < data.length; index++) {
				const i$1 = colors.getVertexOffset(index);
				if (values[i$1] === objectColor[0] && values[i$1 + 1] === objectColor[1] && values[i$1 + 2] === objectColor[2]) this._disablePickingIndex(index);
			}
		} else this._disablePickingIndex(objectIndex);
	}
	_disablePickingIndex(objectIndex) {
		const { pickingColors, instancePickingColors } = this.getAttributeManager().attributes;
		const colors = pickingColors || instancePickingColors;
		if (!colors) return;
		const start = colors.getVertexOffset(objectIndex);
		const end = colors.getVertexOffset(objectIndex + 1);
		colors.buffer.write(new Uint8Array(end - start), start);
	}
	/** (Internal) Re-enable all picking indices after multi-depth picking */
	restorePickingColors() {
		const { pickingColors, instancePickingColors } = this.getAttributeManager().attributes;
		const colors = pickingColors || instancePickingColors;
		if (!colors) return;
		if (this.internalState.usesPickingColorCache && colors.value.buffer !== pickingColorCache.buffer) colors.value = pickingColorCache.subarray(0, colors.value.length);
		colors.updateSubBuffer({ startOffset: 0 });
	}
	_initialize() {
		assert(!this.internalState);
		assert(Number.isFinite(this.props.coordinateSystem));
		debug(TRACE_INITIALIZE, this);
		const attributeManager = this._getAttributeManager();
		if (attributeManager) attributeManager.addInstanced({ instancePickingColors: {
			type: "uint8",
			size: 4,
			noAlloc: true,
			update: this.calculateInstancePickingColors
		} });
		this.internalState = new LayerState({
			attributeManager,
			layer: this
		});
		this._clearChangeFlags();
		this.state = {};
		Object.defineProperty(this.state, "attributeManager", { get: () => {
			log_default.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")();
			return attributeManager;
		} });
		this.internalState.uniformTransitions = new UniformTransitionManager(this.context.timeline);
		this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);
		this.internalState.setAsyncProps(this.props);
		this.initializeState(this.context);
		for (const extension of this.props.extensions) extension.initializeState.call(this, this.context, extension);
		this.setChangeFlags({
			dataChanged: "init",
			propsChanged: "init",
			viewportChanged: true,
			extensionsChanged: true
		});
		this._update();
	}
	/** (Internal) Called by layer manager to transfer state from an old layer */
	_transferState(oldLayer) {
		debug(TRACE_MATCHED, this, this === oldLayer);
		const { state, internalState } = oldLayer;
		if (this === oldLayer) return;
		this.internalState = internalState;
		this.state = state;
		this.internalState.setAsyncProps(this.props);
		this._diffProps(this.props, this.internalState.getOldProps());
	}
	/** (Internal) Called by layer manager when a new layer is added or an existing layer is matched with a new instance */
	_update() {
		const stateNeedsUpdate = this.needsUpdate();
		debug(TRACE_UPDATE, this, stateNeedsUpdate);
		if (!stateNeedsUpdate) return;
		const currentProps = this.props;
		const context = this.context;
		const internalState = this.internalState;
		const currentViewport = context.viewport;
		const propsInTransition = this._updateUniformTransition();
		internalState.propsInTransition = propsInTransition;
		context.viewport = internalState.viewport || currentViewport;
		this.props = propsInTransition;
		try {
			const updateParams = this._getUpdateParams();
			const oldModels = this.getModels();
			if (context.device) this.updateState(updateParams);
			else try {
				this.updateState(updateParams);
			} catch (error) {}
			for (const extension of this.props.extensions) extension.updateState.call(this, updateParams, extension);
			this.setNeedsRedraw();
			this._updateAttributes();
			const modelChanged = this.getModels()[0] !== oldModels[0];
			this._postUpdate(updateParams, modelChanged);
		} finally {
			context.viewport = currentViewport;
			this.props = currentProps;
			this._clearChangeFlags();
			internalState.needsUpdate = false;
			internalState.resetOldProps();
		}
	}
	/** (Internal) Called by manager when layer is about to be disposed
	Note: not guaranteed to be called on application shutdown */
	_finalize() {
		debug(TRACE_FINALIZE, this);
		this.finalizeState(this.context);
		for (const extension of this.props.extensions) extension.finalizeState.call(this, this.context, extension);
	}
	_drawLayer({ renderPass, shaderModuleProps = null, uniforms = {}, parameters = {} }) {
		this._updateAttributeTransition();
		const currentProps = this.props;
		const context = this.context;
		this.props = this.internalState.propsInTransition || currentProps;
		try {
			if (shaderModuleProps) this.setShaderModuleProps(shaderModuleProps);
			const { getPolygonOffset } = this.props;
			const offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];
			if (context.device instanceof WebGLDevice) context.device.setParametersWebGL({ polygonOffset: offsets });
			for (const model of this.getModels()) if (model.device.type === "webgpu") model.setParameters({
				...model.parameters,
				...parameters
			});
			else model.setParameters(parameters);
			if (context.device instanceof WebGLDevice) context.device.withParametersWebGL(parameters, () => {
				const opts = {
					renderPass,
					shaderModuleProps,
					uniforms,
					parameters,
					context
				};
				for (const extension of this.props.extensions) extension.draw.call(this, opts, extension);
				this.draw(opts);
			});
			else {
				const opts = {
					renderPass,
					shaderModuleProps,
					uniforms,
					parameters,
					context
				};
				for (const extension of this.props.extensions) extension.draw.call(this, opts, extension);
				this.draw(opts);
			}
		} finally {
			this.props = currentProps;
		}
	}
	/** Returns the current change flags */
	getChangeFlags() {
		return this.internalState?.changeFlags;
	}
	/** Dirty some change flags, will be handled by updateLayer */
	setChangeFlags(flags) {
		if (!this.internalState) return;
		const { changeFlags } = this.internalState;
		for (const key in flags) if (flags[key]) {
			let flagChanged = false;
			switch (key) {
				case "dataChanged":
					const dataChangedReason = flags[key];
					const prevDataChangedReason = changeFlags[key];
					if (dataChangedReason && Array.isArray(prevDataChangedReason)) {
						changeFlags.dataChanged = Array.isArray(dataChangedReason) ? prevDataChangedReason.concat(dataChangedReason) : dataChangedReason;
						flagChanged = true;
					}
				default: if (!changeFlags[key]) {
					changeFlags[key] = flags[key];
					flagChanged = true;
				}
			}
			if (flagChanged) debug(TRACE_CHANGE_FLAG, this, key, flags);
		}
		const propsOrDataChanged = Boolean(changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.propsChanged || changeFlags.extensionsChanged);
		changeFlags.propsOrDataChanged = propsOrDataChanged;
		changeFlags.somethingChanged = propsOrDataChanged || changeFlags.viewportChanged || changeFlags.stateChanged;
	}
	/** Clear all changeFlags, typically after an update */
	_clearChangeFlags() {
		this.internalState.changeFlags = {
			dataChanged: false,
			propsChanged: false,
			updateTriggersChanged: false,
			viewportChanged: false,
			stateChanged: false,
			extensionsChanged: false,
			propsOrDataChanged: false,
			somethingChanged: false
		};
	}
	/** Compares the layers props with old props from a matched older layer
	and extracts change flags that describe what has change so that state
	can be update correctly with minimal effort */
	_diffProps(newProps, oldProps) {
		const changeFlags = diffProps(newProps, oldProps);
		if (changeFlags.updateTriggersChanged) {
			for (const key in changeFlags.updateTriggersChanged) if (changeFlags.updateTriggersChanged[key]) this.invalidateAttribute(key);
		}
		if (changeFlags.transitionsChanged) for (const key in changeFlags.transitionsChanged) this.internalState.uniformTransitions.add(key, oldProps[key], newProps[key], newProps.transitions?.[key]);
		return this.setChangeFlags(changeFlags);
	}
	/** (Internal) called by layer manager to perform extra props validation (in development only) */
	validateProps() {
		validateProps(this.props);
	}
	/** (Internal) Called by deck picker when the hovered object changes to update the auto highlight */
	updateAutoHighlight(info) {
		if (this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex)) this._updateAutoHighlight(info);
	}
	/** Update picking module parameters to highlight the hovered object */
	_updateAutoHighlight(info) {
		const picking$1 = { highlightedObjectColor: info.picked ? info.color : null };
		const { highlightColor } = this.props;
		if (info.picked && typeof highlightColor === "function") picking$1.highlightColor = highlightColor(info);
		this.setShaderModuleProps({ picking: picking$1 });
		this.setNeedsRedraw();
	}
	/** Create new attribute manager */
	_getAttributeManager() {
		const context = this.context;
		return new AttributeManager(context.device, {
			id: this.props.id,
			stats: context.stats,
			timeline: context.timeline
		});
	}
	/** Called after updateState to perform common tasks */
	_postUpdate(updateParams, forceUpdate) {
		const { props, oldProps } = updateParams;
		const model = this.state.model;
		if (model?.isInstanced) model.setInstanceCount(this.getNumInstances());
		const { autoHighlight, highlightedObjectIndex, highlightColor } = props;
		if (forceUpdate || oldProps.autoHighlight !== autoHighlight || oldProps.highlightedObjectIndex !== highlightedObjectIndex || oldProps.highlightColor !== highlightColor) {
			const picking$1 = {};
			if (Array.isArray(highlightColor)) picking$1.highlightColor = highlightColor;
			if (forceUpdate || oldProps.autoHighlight !== autoHighlight || highlightedObjectIndex !== oldProps.highlightedObjectIndex) picking$1.highlightedObjectColor = Number.isFinite(highlightedObjectIndex) && highlightedObjectIndex >= 0 ? this.encodePickingColor(highlightedObjectIndex) : null;
			this.setShaderModuleProps({ picking: picking$1 });
		}
	}
	_getUpdateParams() {
		return {
			props: this.props,
			oldProps: this.internalState.getOldProps(),
			context: this.context,
			changeFlags: this.internalState.changeFlags
		};
	}
	/** Checks state of attributes and model */
	_getNeedsRedraw(opts) {
		if (!this.internalState) return false;
		let redraw = false;
		redraw = redraw || this.internalState.needsRedraw && this.id;
		const attributeManager = this.getAttributeManager();
		const attributeManagerNeedsRedraw = attributeManager ? attributeManager.getNeedsRedraw(opts) : false;
		redraw = redraw || attributeManagerNeedsRedraw;
		if (redraw) for (const extension of this.props.extensions) extension.onNeedsRedraw.call(this, extension);
		this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;
		return redraw;
	}
	/** Callback when asyn prop is loaded */
	_onAsyncPropUpdated() {
		this._diffProps(this.props, this.internalState.getOldProps());
		this.setNeedsUpdate();
	}
};
Layer.defaultProps = defaultProps;
Layer.layerName = "Layer";
var layer_default = Layer;

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/composite-layer.js
var TRACE_RENDER_LAYERS = "compositeLayer.renderLayers";
var CompositeLayer = class extends layer_default {
	/** `true` if this layer renders other layers */
	get isComposite() {
		return true;
	}
	/** `true` if the layer renders to screen */
	get isDrawable() {
		return false;
	}
	/** Returns true if all async resources are loaded */
	get isLoaded() {
		return super.isLoaded && this.getSubLayers().every((layer) => layer.isLoaded);
	}
	/** Return last rendered sub layers */
	getSubLayers() {
		return this.internalState && this.internalState.subLayers || [];
	}
	initializeState(context) {}
	/** Updates selected state members and marks the composite layer to need rerender */
	setState(updateObject) {
		super.setState(updateObject);
		this.setNeedsUpdate();
	}
	/** called to augment the info object that is bubbled up from a sublayer
	override Layer.getPickingInfo() because decoding / setting uniform do
	not apply to a composite layer. */
	getPickingInfo({ info }) {
		const { object } = info;
		if (!(object && object.__source && object.__source.parent && object.__source.parent.id === this.id)) return info;
		info.object = object.__source.object;
		info.index = object.__source.index;
		return info;
	}
	/**
	* Filters sub layers at draw time. Return true if the sub layer should be drawn.
	*/
	filterSubLayer(context) {
		return true;
	}
	/** Returns true if sub layer needs to be rendered */
	shouldRenderSubLayer(subLayerId, data) {
		return data && data.length;
	}
	/** Returns sub layer class for a specific sublayer */
	getSubLayerClass(subLayerId, DefaultLayerClass) {
		const { _subLayerProps: overridingProps } = this.props;
		return overridingProps && overridingProps[subLayerId] && overridingProps[subLayerId].type || DefaultLayerClass;
	}
	/** When casting user data into another format to pass to sublayers,
	add reference to the original object and object index */
	getSubLayerRow(row, sourceObject, sourceObjectIndex) {
		row.__source = {
			parent: this,
			object: sourceObject,
			index: sourceObjectIndex
		};
		return row;
	}
	/** Some composite layers cast user data into another format before passing to sublayers
	We need to unwrap them before calling the accessor so that they see the original data
	objects */
	getSubLayerAccessor(accessor) {
		if (typeof accessor === "function") {
			const objectInfo = {
				index: -1,
				data: this.props.data,
				target: []
			};
			return (x$1, i$1) => {
				if (x$1 && x$1.__source) {
					objectInfo.index = x$1.__source.index;
					return accessor(x$1.__source.object, objectInfo);
				}
				return accessor(x$1, i$1);
			};
		}
		return accessor;
	}
	/** Returns sub layer props for a specific sublayer */
	getSubLayerProps(sublayerProps = {}) {
		const { opacity, pickable, visible, parameters, getPolygonOffset, highlightedObjectIndex, autoHighlight, highlightColor, coordinateSystem, coordinateOrigin, wrapLongitude, positionFormat, modelMatrix, extensions, fetch: fetch$1, operation, _subLayerProps: overridingProps } = this.props;
		const newProps = {
			id: "",
			updateTriggers: {},
			opacity,
			pickable,
			visible,
			parameters,
			getPolygonOffset,
			highlightedObjectIndex,
			autoHighlight,
			highlightColor,
			coordinateSystem,
			coordinateOrigin,
			wrapLongitude,
			positionFormat,
			modelMatrix,
			extensions,
			fetch: fetch$1,
			operation
		};
		const overridingSublayerProps = overridingProps && sublayerProps.id && overridingProps[sublayerProps.id];
		const overridingSublayerTriggers = overridingSublayerProps && overridingSublayerProps.updateTriggers;
		const sublayerId = sublayerProps.id || "sublayer";
		if (overridingSublayerProps) {
			const propTypes = this.props[PROP_TYPES_SYMBOL];
			const subLayerPropTypes = sublayerProps.type ? sublayerProps.type._propTypes : {};
			for (const key in overridingSublayerProps) {
				const propType = subLayerPropTypes[key] || propTypes[key];
				if (propType && propType.type === "accessor") overridingSublayerProps[key] = this.getSubLayerAccessor(overridingSublayerProps[key]);
			}
		}
		Object.assign(newProps, sublayerProps, overridingSublayerProps);
		newProps.id = `${this.props.id}-${sublayerId}`;
		newProps.updateTriggers = {
			all: this.props.updateTriggers?.all,
			...sublayerProps.updateTriggers,
			...overridingSublayerTriggers
		};
		for (const extension of extensions) {
			const passThroughProps = extension.getSubLayerProps.call(this, extension);
			if (passThroughProps) Object.assign(newProps, passThroughProps, { updateTriggers: Object.assign(newProps.updateTriggers, passThroughProps.updateTriggers) });
		}
		return newProps;
	}
	/** Update sub layers to highlight the hovered object */
	_updateAutoHighlight(info) {
		for (const layer of this.getSubLayers()) layer.updateAutoHighlight(info);
	}
	/** Override base Layer method */
	_getAttributeManager() {
		return null;
	}
	/** (Internal) Called after an update to rerender sub layers */
	_postUpdate(updateParams, forceUpdate) {
		let subLayers = this.internalState.subLayers;
		const shouldUpdate = !subLayers || this.needsUpdate();
		if (shouldUpdate) {
			subLayers = flatten(this.renderLayers(), Boolean);
			this.internalState.subLayers = subLayers;
		}
		debug(TRACE_RENDER_LAYERS, this, shouldUpdate, subLayers);
		for (const layer of subLayers) layer.parent = this;
	}
};
CompositeLayer.layerName = "CompositeLayer";
var composite_layer_default = CompositeLayer;

//#endregion
//#region node_modules/@deck.gl/core/dist/viewports/orbit-viewport.js
var DEGREES_TO_RADIANS = Math.PI / 180;
function getViewMatrix({ height, focalDistance, orbitAxis, rotationX, rotationOrbit, zoom }) {
	const up = orbitAxis === "Z" ? [
		0,
		0,
		1
	] : [
		0,
		1,
		0
	];
	const eye = orbitAxis === "Z" ? [
		0,
		-focalDistance,
		0
	] : [
		0,
		0,
		focalDistance
	];
	const viewMatrix$1 = new Matrix4().lookAt({
		eye,
		up
	});
	viewMatrix$1.rotateX(rotationX * DEGREES_TO_RADIANS);
	if (orbitAxis === "Z") viewMatrix$1.rotateZ(rotationOrbit * DEGREES_TO_RADIANS);
	else viewMatrix$1.rotateY(rotationOrbit * DEGREES_TO_RADIANS);
	const projectionScale = Math.pow(2, zoom) / height;
	viewMatrix$1.scale(projectionScale);
	return viewMatrix$1;
}
var OrbitViewport = class extends viewport_default {
	constructor(props) {
		const { height, projectionMatrix, fovy = 50, orbitAxis = "Z", target = [
			0,
			0,
			0
		], rotationX = 0, rotationOrbit = 0, zoom = 0 } = props;
		const focalDistance = projectionMatrix ? projectionMatrix[5] / 2 : fovyToAltitude(fovy);
		super({
			...props,
			longitude: void 0,
			viewMatrix: getViewMatrix({
				height: height || 1,
				focalDistance,
				orbitAxis,
				rotationX,
				rotationOrbit,
				zoom
			}),
			fovy,
			focalDistance,
			position: target,
			zoom
		});
		this.target = target;
		this.orbitAxis = orbitAxis;
		this.rotationX = rotationX;
		this.rotationOrbit = rotationOrbit;
		this.fovy = fovy;
		this.projectedCenter = this.project(this.center);
	}
	unproject(xyz, { topLeft = true } = {}) {
		const [x$1, y$1, z$1 = this.projectedCenter[2]] = xyz;
		const [X$1, Y$1, Z$1] = pixelsToWorld([
			x$1,
			topLeft ? y$1 : this.height - y$1,
			z$1
		], this.pixelUnprojectionMatrix);
		return [
			X$1,
			Y$1,
			Z$1
		];
	}
	panByPosition(coords, pixel, startPixel) {
		const p0 = this.project(coords);
		const nextCenter = [
			this.width / 2 + p0[0] - pixel[0],
			this.height / 2 + p0[1] - pixel[1],
			this.projectedCenter[2]
		];
		return { target: this.unproject(nextCenter) };
	}
};
OrbitViewport.displayName = "OrbitViewport";
var orbit_viewport_default = OrbitViewport;

//#endregion
//#region node_modules/@deck.gl/core/dist/viewports/orthographic-viewport.js
var viewMatrix = new Matrix4().lookAt({ eye: [
	0,
	0,
	1
] });
function getProjectionMatrix({ width, height, near, far, padding }) {
	let left = -width / 2;
	let right = width / 2;
	let bottom = -height / 2;
	let top = height / 2;
	if (padding) {
		const { left: l$1 = 0, right: r$1 = 0, top: t$1 = 0, bottom: b$1 = 0 } = padding;
		const offsetX = clamp((l$1 + width - r$1) / 2, 0, width) - width / 2;
		const offsetY = clamp((t$1 + height - b$1) / 2, 0, height) - height / 2;
		left -= offsetX;
		right -= offsetX;
		bottom += offsetY;
		top += offsetY;
	}
	return new Matrix4().ortho({
		left,
		right,
		bottom,
		top,
		near,
		far
	});
}
var OrthographicViewport = class extends viewport_default {
	constructor(props) {
		const { width, height, near = .1, far = 1e3, zoom = 0, target = [
			0,
			0,
			0
		], padding = null, flipY = true } = props;
		const zoomX = props.zoomX ?? (Array.isArray(zoom) ? zoom[0] : zoom);
		const zoomY = props.zoomY ?? (Array.isArray(zoom) ? zoom[1] : zoom);
		const zoom_ = Math.min(zoomX, zoomY);
		const scale$3 = Math.pow(2, zoom_);
		let distanceScales;
		if (zoomX !== zoomY) {
			const scaleX = Math.pow(2, zoomX);
			const scaleY = Math.pow(2, zoomY);
			distanceScales = {
				unitsPerMeter: [
					scaleX / scale$3,
					scaleY / scale$3,
					1
				],
				metersPerUnit: [
					scale$3 / scaleX,
					scale$3 / scaleY,
					1
				]
			};
		}
		super({
			...props,
			longitude: void 0,
			position: target,
			viewMatrix: viewMatrix.clone().scale([
				scale$3,
				scale$3 * (flipY ? -1 : 1),
				scale$3
			]),
			projectionMatrix: getProjectionMatrix({
				width: width || 1,
				height: height || 1,
				padding,
				near,
				far
			}),
			zoom: zoom_,
			distanceScales
		});
		this.target = target;
		this.zoomX = zoomX;
		this.zoomY = zoomY;
		this.flipY = flipY;
	}
	projectFlat([X$1, Y$1]) {
		const { unitsPerMeter: unitsPerMeter$1 } = this.distanceScales;
		return [X$1 * unitsPerMeter$1[0], Y$1 * unitsPerMeter$1[1]];
	}
	unprojectFlat([x$1, y$1]) {
		const { metersPerUnit } = this.distanceScales;
		return [x$1 * metersPerUnit[0], y$1 * metersPerUnit[1]];
	}
	panByPosition(coords, pixel, startPixel) {
		const fromLocation = pixelsToWorld(pixel, this.pixelUnprojectionMatrix);
		const toLocation = this.projectFlat(coords);
		const translate$1 = add$1([], toLocation, negate$1([], fromLocation));
		const newCenter = add$1([], this.center, translate$1);
		return { target: this.unprojectFlat(newCenter) };
	}
};
OrthographicViewport.displayName = "OrthographicViewport";
var orthographic_viewport_default = OrthographicViewport;

//#endregion
//#region node_modules/@deck.gl/core/dist/viewports/first-person-viewport.js
var FirstPersonViewport = class extends viewport_default {
	constructor(props) {
		const { longitude, latitude, modelMatrix, bearing = 0, pitch = 0, up = [
			0,
			0,
			1
		] } = props;
		const dir = new SphericalCoordinates({
			bearing,
			pitch: pitch === -90 ? 1e-4 : 90 + pitch
		}).toVector3().normalize();
		const center = modelMatrix ? new Matrix4(modelMatrix).transformAsVector(dir) : dir;
		const zoom = Number.isFinite(latitude) ? getMeterZoom({ latitude }) : 0;
		const scale$3 = Math.pow(2, zoom);
		const viewMatrix$1 = new Matrix4().lookAt({
			eye: [
				0,
				0,
				0
			],
			center,
			up
		}).scale(scale$3);
		super({
			...props,
			zoom,
			viewMatrix: viewMatrix$1
		});
		this.latitude = latitude;
		this.longitude = longitude;
		this.pitch = pitch;
		this.bearing = bearing;
		this.up = up;
	}
};
FirstPersonViewport.displayName = "FirstPersonViewport";
var first_person_viewport_default = FirstPersonViewport;

//#endregion
//#region node_modules/@deck.gl/core/dist/controllers/first-person-controller.js
var MOVEMENT_SPEED = 20;
var PAN_SPEED = 500;
var FirstPersonState = class FirstPersonState extends ViewState {
	constructor(options) {
		const { width, height, position = [
			0,
			0,
			0
		], bearing = 0, pitch = 0, longitude = null, latitude = null, maxPitch = 90, minPitch = -90, startRotatePos, startBearing, startPitch, startZoomPosition, startPanPos, startPanPosition } = options;
		super({
			width,
			height,
			position,
			bearing,
			pitch,
			longitude,
			latitude,
			maxPitch,
			minPitch
		}, {
			startRotatePos,
			startBearing,
			startPitch,
			startZoomPosition,
			startPanPos,
			startPanPosition
		});
		this.makeViewport = options.makeViewport;
	}
	/**
	* Start panning
	* @param {[Number, Number]} pos - position on screen where the pointer grabs
	*/
	panStart({ pos }) {
		const { position } = this.getViewportProps();
		return this._getUpdatedState({
			startPanPos: pos,
			startPanPosition: position
		});
	}
	/**
	* Pan
	* @param {[Number, Number]} pos - position on screen where the pointer is
	*/
	pan({ pos }) {
		if (!pos) return this;
		const { startPanPos = [0, 0], startPanPosition = [0, 0] } = this.getState();
		const { width, height, bearing, pitch } = this.getViewportProps();
		const deltaScaleX = PAN_SPEED * (pos[0] - startPanPos[0]) / width;
		const deltaScaleY = PAN_SPEED * (pos[1] - startPanPos[1]) / height;
		const up = new SphericalCoordinates({
			bearing,
			pitch
		});
		const forward = new SphericalCoordinates({
			bearing,
			pitch: -90
		});
		const yDirection = up.toVector3().normalize();
		const xDirection = forward.toVector3().cross(yDirection).normalize();
		return this._getUpdatedState({ position: new Vector3(startPanPosition).add(xDirection.scale(deltaScaleX)).add(yDirection.scale(deltaScaleY)) });
	}
	/**
	* End panning
	* Must call if `panStart()` was called
	*/
	panEnd() {
		return this._getUpdatedState({
			startPanPos: null,
			startPanPosition: null
		});
	}
	/**
	* Start rotating
	* @param {[Number, Number]} pos - position on screen where the pointer grabs
	*/
	rotateStart({ pos }) {
		return this._getUpdatedState({
			startRotatePos: pos,
			startBearing: this.getViewportProps().bearing,
			startPitch: this.getViewportProps().pitch
		});
	}
	/**
	* Rotate
	* @param {[Number, Number]} pos - position on screen where the pointer is
	*/
	rotate({ pos, deltaAngleX = 0, deltaAngleY = 0 }) {
		const { startRotatePos, startBearing, startPitch } = this.getState();
		const { width, height } = this.getViewportProps();
		if (!startRotatePos || startBearing === void 0 || startPitch === void 0) return this;
		let newRotation;
		if (pos) {
			const deltaScaleX = (pos[0] - startRotatePos[0]) / width;
			const deltaScaleY = (pos[1] - startRotatePos[1]) / height;
			newRotation = {
				bearing: startBearing - deltaScaleX * 180,
				pitch: startPitch - deltaScaleY * 90
			};
		} else newRotation = {
			bearing: startBearing - deltaAngleX,
			pitch: startPitch - deltaAngleY
		};
		return this._getUpdatedState(newRotation);
	}
	/**
	* End rotating
	* Must call if `rotateStart()` was called
	*/
	rotateEnd() {
		return this._getUpdatedState({
			startRotatePos: null,
			startBearing: null,
			startPitch: null
		});
	}
	/**
	* Start zooming
	* @param {[Number, Number]} pos - position on screen where the pointer grabs
	*/
	zoomStart() {
		return this._getUpdatedState({ startZoomPosition: this.getViewportProps().position });
	}
	/**
	* Zoom
	* @param {[Number, Number]} pos - position on screen where the current center is
	* @param {[Number, Number]} startPos - the center position at
	*   the start of the operation. Must be supplied of `zoomStart()` was not called
	* @param {Number} scale - a number between [0, 1] specifying the accumulated
	*   relative scale.
	*/
	zoom({ pos, scale: scale$3 }) {
		const viewportProps = this.getViewportProps();
		const startZoomPosition = this.getState().startZoomPosition || viewportProps.position;
		const { projectionMatrix, width } = this.makeViewport(viewportProps);
		const angle$1 = 2 * Math.atan(1 / projectionMatrix[0]) * (pos[0] / width - .5);
		const direction = this.getDirection(true);
		return this._move(direction.rotateZ({ radians: -angle$1 }), Math.log2(scale$3) * MOVEMENT_SPEED, startZoomPosition);
	}
	/**
	* End zooming
	* Must call if `zoomStart()` was called
	*/
	zoomEnd() {
		return this._getUpdatedState({ startZoomPosition: null });
	}
	moveLeft(speed = MOVEMENT_SPEED) {
		const direction = this.getDirection(true);
		return this._move(direction.rotateZ({ radians: Math.PI / 2 }), speed);
	}
	moveRight(speed = MOVEMENT_SPEED) {
		const direction = this.getDirection(true);
		return this._move(direction.rotateZ({ radians: -Math.PI / 2 }), speed);
	}
	moveUp(speed = MOVEMENT_SPEED) {
		const direction = this.getDirection(true);
		return this._move(direction, speed);
	}
	moveDown(speed = MOVEMENT_SPEED) {
		const direction = this.getDirection(true);
		return this._move(direction.negate(), speed);
	}
	rotateLeft(speed = 15) {
		return this._getUpdatedState({ bearing: this.getViewportProps().bearing - speed });
	}
	rotateRight(speed = 15) {
		return this._getUpdatedState({ bearing: this.getViewportProps().bearing + speed });
	}
	rotateUp(speed = 10) {
		return this._getUpdatedState({ pitch: this.getViewportProps().pitch + speed });
	}
	rotateDown(speed = 10) {
		return this._getUpdatedState({ pitch: this.getViewportProps().pitch - speed });
	}
	zoomIn(speed = MOVEMENT_SPEED) {
		return this._move(new Vector3(0, 0, 1), speed);
	}
	zoomOut(speed = MOVEMENT_SPEED) {
		return this._move(new Vector3(0, 0, -1), speed);
	}
	shortestPathFrom(viewState) {
		const fromProps = viewState.getViewportProps();
		const props = { ...this.getViewportProps() };
		const { bearing, longitude } = props;
		if (Math.abs(bearing - fromProps.bearing) > 180) props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
		if (longitude !== null && fromProps.longitude !== null && Math.abs(longitude - fromProps.longitude) > 180) props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
		return props;
	}
	_move(direction, speed, fromPosition = this.getViewportProps().position) {
		const delta = direction.scale(speed);
		return this._getUpdatedState({ position: new Vector3(fromPosition).add(delta) });
	}
	getDirection(use2D = false) {
		return new SphericalCoordinates({
			bearing: this.getViewportProps().bearing,
			pitch: use2D ? 90 : 90 + this.getViewportProps().pitch
		}).toVector3().normalize();
	}
	_getUpdatedState(newProps) {
		return new FirstPersonState({
			makeViewport: this.makeViewport,
			...this.getViewportProps(),
			...this.getState(),
			...newProps
		});
	}
	applyConstraints(props) {
		const { pitch, maxPitch, minPitch, longitude, bearing } = props;
		props.pitch = clamp(pitch, minPitch, maxPitch);
		if (longitude !== null && (longitude < -180 || longitude > 180)) props.longitude = mod(longitude + 180, 360) - 180;
		if (bearing < -180 || bearing > 180) props.bearing = mod(bearing + 180, 360) - 180;
		return props;
	}
};
var FirstPersonController = class extends Controller {
	constructor() {
		super(...arguments);
		this.ControllerState = FirstPersonState;
		this.transition = {
			transitionDuration: 300,
			transitionInterpolator: new LinearInterpolator([
				"position",
				"pitch",
				"bearing"
			])
		};
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/views/first-person-view.js
var FirstPersonView = class extends View {
	constructor(props = {}) {
		super(props);
	}
	getViewportType() {
		return first_person_viewport_default;
	}
	get ControllerType() {
		return FirstPersonController;
	}
};
FirstPersonView.displayName = "FirstPersonView";
var first_person_view_default = FirstPersonView;

//#endregion
//#region node_modules/@deck.gl/core/dist/controllers/orbit-controller.js
var OrbitState = class extends ViewState {
	constructor(options) {
		const { width, height, rotationX = 0, rotationOrbit = 0, target = [
			0,
			0,
			0
		], zoom = 0, minRotationX = -90, maxRotationX = 90, minZoom = -Infinity, maxZoom = Infinity, startPanPosition, startRotatePos, startRotationX, startRotationOrbit, startZoomPosition, startZoom } = options;
		super({
			width,
			height,
			rotationX,
			rotationOrbit,
			target,
			zoom,
			minRotationX,
			maxRotationX,
			minZoom,
			maxZoom
		}, {
			startPanPosition,
			startRotatePos,
			startRotationX,
			startRotationOrbit,
			startZoomPosition,
			startZoom
		});
		this.makeViewport = options.makeViewport;
	}
	/**
	* Start panning
	* @param {[Number, Number]} pos - position on screen where the pointer grabs
	*/
	panStart({ pos }) {
		return this._getUpdatedState({ startPanPosition: this._unproject(pos) });
	}
	/**
	* Pan
	* @param {[Number, Number]} pos - position on screen where the pointer is
	*/
	pan({ pos, startPosition }) {
		const startPanPosition = this.getState().startPanPosition || startPosition;
		if (!startPanPosition) return this;
		const newProps = this.makeViewport(this.getViewportProps()).panByPosition(startPanPosition, pos);
		return this._getUpdatedState(newProps);
	}
	/**
	* End panning
	* Must call if `panStart()` was called
	*/
	panEnd() {
		return this._getUpdatedState({ startPanPosition: null });
	}
	/**
	* Start rotating
	* @param {[Number, Number]} pos - position on screen where the pointer grabs
	*/
	rotateStart({ pos }) {
		return this._getUpdatedState({
			startRotatePos: pos,
			startRotationX: this.getViewportProps().rotationX,
			startRotationOrbit: this.getViewportProps().rotationOrbit
		});
	}
	/**
	* Rotate
	* @param {[Number, Number]} pos - position on screen where the pointer is
	*/
	rotate({ pos, deltaAngleX = 0, deltaAngleY = 0 }) {
		const { startRotatePos, startRotationX, startRotationOrbit } = this.getState();
		const { width, height } = this.getViewportProps();
		if (!startRotatePos || startRotationX === void 0 || startRotationOrbit === void 0) return this;
		let newRotation;
		if (pos) {
			let deltaScaleX = (pos[0] - startRotatePos[0]) / width;
			const deltaScaleY = (pos[1] - startRotatePos[1]) / height;
			if (startRotationX < -90 || startRotationX > 90) deltaScaleX *= -1;
			newRotation = {
				rotationX: startRotationX + deltaScaleY * 180,
				rotationOrbit: startRotationOrbit + deltaScaleX * 180
			};
		} else newRotation = {
			rotationX: startRotationX + deltaAngleY,
			rotationOrbit: startRotationOrbit + deltaAngleX
		};
		return this._getUpdatedState(newRotation);
	}
	/**
	* End rotating
	* Must call if `rotateStart()` was called
	*/
	rotateEnd() {
		return this._getUpdatedState({
			startRotationX: null,
			startRotationOrbit: null
		});
	}
	shortestPathFrom(viewState) {
		const fromProps = viewState.getViewportProps();
		const props = { ...this.getViewportProps() };
		const { rotationOrbit } = props;
		if (Math.abs(rotationOrbit - fromProps.rotationOrbit) > 180) props.rotationOrbit = rotationOrbit < 0 ? rotationOrbit + 360 : rotationOrbit - 360;
		return props;
	}
	/**
	* Start zooming
	* @param {[Number, Number]} pos - position on screen where the pointer grabs
	*/
	zoomStart({ pos }) {
		return this._getUpdatedState({
			startZoomPosition: this._unproject(pos),
			startZoom: this.getViewportProps().zoom
		});
	}
	/**
	* Zoom
	* @param {[Number, Number]} pos - position on screen where the current target is
	* @param {[Number, Number]} startPos - the target position at
	*   the start of the operation. Must be supplied of `zoomStart()` was not called
	* @param {Number} scale - a number between [0, 1] specifying the accumulated
	*   relative scale.
	*/
	zoom({ pos, startPos, scale: scale$3 }) {
		let { startZoom, startZoomPosition } = this.getState();
		if (!startZoomPosition) {
			startZoom = this.getViewportProps().zoom;
			startZoomPosition = this._unproject(startPos) || this._unproject(pos);
		}
		if (!startZoomPosition) return this;
		const newZoom = this._calculateNewZoom({
			scale: scale$3,
			startZoom
		});
		const zoomedViewport = this.makeViewport({
			...this.getViewportProps(),
			zoom: newZoom
		});
		return this._getUpdatedState({
			zoom: newZoom,
			...zoomedViewport.panByPosition(startZoomPosition, pos)
		});
	}
	/**
	* End zooming
	* Must call if `zoomStart()` was called
	*/
	zoomEnd() {
		return this._getUpdatedState({
			startZoomPosition: null,
			startZoom: null
		});
	}
	zoomIn(speed = 2) {
		return this._getUpdatedState({ zoom: this._calculateNewZoom({ scale: speed }) });
	}
	zoomOut(speed = 2) {
		return this._getUpdatedState({ zoom: this._calculateNewZoom({ scale: 1 / speed }) });
	}
	moveLeft(speed = 50) {
		return this._panFromCenter([-speed, 0]);
	}
	moveRight(speed = 50) {
		return this._panFromCenter([speed, 0]);
	}
	moveUp(speed = 50) {
		return this._panFromCenter([0, -speed]);
	}
	moveDown(speed = 50) {
		return this._panFromCenter([0, speed]);
	}
	rotateLeft(speed = 15) {
		return this._getUpdatedState({ rotationOrbit: this.getViewportProps().rotationOrbit - speed });
	}
	rotateRight(speed = 15) {
		return this._getUpdatedState({ rotationOrbit: this.getViewportProps().rotationOrbit + speed });
	}
	rotateUp(speed = 10) {
		return this._getUpdatedState({ rotationX: this.getViewportProps().rotationX - speed });
	}
	rotateDown(speed = 10) {
		return this._getUpdatedState({ rotationX: this.getViewportProps().rotationX + speed });
	}
	_unproject(pos) {
		const viewport = this.makeViewport(this.getViewportProps());
		return pos && viewport.unproject(pos);
	}
	_calculateNewZoom({ scale: scale$3, startZoom }) {
		const { maxZoom, minZoom } = this.getViewportProps();
		if (startZoom === void 0) startZoom = this.getViewportProps().zoom;
		return clamp(startZoom + Math.log2(scale$3), minZoom, maxZoom);
	}
	_panFromCenter(offset) {
		const { width, height, target } = this.getViewportProps();
		return this.pan({
			startPosition: target,
			pos: [width / 2 + offset[0], height / 2 + offset[1]]
		});
	}
	_getUpdatedState(newProps) {
		return new this.constructor({
			makeViewport: this.makeViewport,
			...this.getViewportProps(),
			...this.getState(),
			...newProps
		});
	}
	applyConstraints(props) {
		const { maxZoom, minZoom, zoom, maxRotationX, minRotationX, rotationOrbit } = props;
		props.zoom = Array.isArray(zoom) ? [clamp(zoom[0], minZoom, maxZoom), clamp(zoom[1], minZoom, maxZoom)] : clamp(zoom, minZoom, maxZoom);
		props.rotationX = clamp(props.rotationX, minRotationX, maxRotationX);
		if (rotationOrbit < -180 || rotationOrbit > 180) props.rotationOrbit = mod(rotationOrbit + 180, 360) - 180;
		return props;
	}
};
var OrbitController = class extends Controller {
	constructor() {
		super(...arguments);
		this.ControllerState = OrbitState;
		this.transition = {
			transitionDuration: 300,
			transitionInterpolator: new LinearInterpolator({ transitionProps: {
				compare: [
					"target",
					"zoom",
					"rotationX",
					"rotationOrbit"
				],
				required: ["target", "zoom"]
			} })
		};
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/views/orbit-view.js
var OrbitView = class extends View {
	constructor(props = {}) {
		super(props);
		this.props.orbitAxis = props.orbitAxis || "Z";
	}
	getViewportType() {
		return orbit_viewport_default;
	}
	get ControllerType() {
		return OrbitController;
	}
};
OrbitView.displayName = "OrbitView";
var orbit_view_default = OrbitView;

//#endregion
//#region node_modules/@deck.gl/core/dist/controllers/orthographic-controller.js
var OrthographicState = class extends OrbitState {
	constructor(props) {
		super(props);
		this.zoomAxis = props.zoomAxis || "all";
	}
	_calculateNewZoom({ scale: scale$3, startZoom }) {
		const { maxZoom, minZoom } = this.getViewportProps();
		if (startZoom === void 0) startZoom = this.getViewportProps().zoom;
		let deltaZoom = Math.log2(scale$3);
		if (Array.isArray(startZoom)) {
			let [newZoomX, newZoomY] = startZoom;
			switch (this.zoomAxis) {
				case "X":
					newZoomX = clamp(newZoomX + deltaZoom, minZoom, maxZoom);
					break;
				case "Y":
					newZoomY = clamp(newZoomY + deltaZoom, minZoom, maxZoom);
					break;
				default:
					let z$1 = Math.min(newZoomX + deltaZoom, newZoomY + deltaZoom);
					if (z$1 < minZoom) deltaZoom += minZoom - z$1;
					z$1 = Math.max(newZoomX + deltaZoom, newZoomY + deltaZoom);
					if (z$1 > maxZoom) deltaZoom += maxZoom - z$1;
					newZoomX += deltaZoom;
					newZoomY += deltaZoom;
			}
			return [newZoomX, newZoomY];
		}
		return clamp(startZoom + deltaZoom, minZoom, maxZoom);
	}
};
var OrthographicController = class extends Controller {
	constructor() {
		super(...arguments);
		this.ControllerState = OrthographicState;
		this.transition = {
			transitionDuration: 300,
			transitionInterpolator: new LinearInterpolator(["target", "zoom"])
		};
		this.dragMode = "pan";
	}
	_onPanRotate() {
		return false;
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/views/orthographic-view.js
var OrthographicView = class extends View {
	constructor(props = {}) {
		super(props);
	}
	getViewportType() {
		return orthographic_viewport_default;
	}
	get ControllerType() {
		return OrthographicController;
	}
};
OrthographicView.displayName = "OrthographicView";
var orthographic_view_default = OrthographicView;

//#endregion
//#region node_modules/@deck.gl/core/dist/controllers/globe-controller.js
var GlobeState = class extends MapState {
	constructor(options) {
		const { startPanPos, ...mapStateOptions } = options;
		super(mapStateOptions);
		if (startPanPos !== void 0) this._state.startPanPos = startPanPos;
	}
	panStart({ pos }) {
		const { latitude, longitude, zoom } = this.getViewportProps();
		return this._getUpdatedState({
			startPanLngLat: [longitude, latitude],
			startPanPos: pos,
			startZoom: zoom
		});
	}
	pan({ pos, startPos }) {
		const state = this.getState();
		const startPanLngLat = state.startPanLngLat || this._unproject(startPos);
		if (!startPanLngLat) return this;
		const startZoom = state.startZoom ?? this.getViewportProps().zoom;
		const startPanPos = state.startPanPos || startPos;
		const coords = [
			startPanLngLat[0],
			startPanLngLat[1],
			startZoom
		];
		const newProps = this.makeViewport(this.getViewportProps()).panByPosition(coords, pos, startPanPos);
		return this._getUpdatedState(newProps);
	}
	panEnd() {
		return this._getUpdatedState({
			startPanLngLat: null,
			startPanPos: null,
			startZoom: null
		});
	}
	zoom({ scale: scale$3 }) {
		const zoom = (this.getState().startZoom || this.getViewportProps().zoom) + Math.log2(scale$3);
		return this._getUpdatedState({ zoom });
	}
	applyConstraints(props) {
		const { longitude, latitude, maxZoom, minZoom, zoom } = props;
		const ZOOM0 = zoomAdjust(0);
		const zoomAdjustment = zoomAdjust(latitude) - ZOOM0;
		props.zoom = clamp(zoom, minZoom + zoomAdjustment, maxZoom + zoomAdjustment);
		if (longitude < -180 || longitude > 180) props.longitude = mod(longitude + 180, 360) - 180;
		props.latitude = clamp(latitude, -MAX_LATITUDE, MAX_LATITUDE);
		return props;
	}
};
var GlobeController = class extends Controller {
	constructor() {
		super(...arguments);
		this.ControllerState = GlobeState;
		this.transition = {
			transitionDuration: 300,
			transitionInterpolator: new LinearInterpolator([
				"longitude",
				"latitude",
				"zoom"
			])
		};
		this.dragMode = "pan";
	}
	setProps(props) {
		super.setProps(props);
		this.dragRotate = false;
		this.touchRotate = false;
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/views/globe-view.js
var GlobeView = class extends View {
	constructor(props = {}) {
		super(props);
	}
	getViewportType(viewState) {
		return viewState.zoom > 12 ? web_mercator_viewport_default : globe_viewport_default;
	}
	get ControllerType() {
		return GlobeController;
	}
};
GlobeView.displayName = "GlobeView";
var globe_view_default = GlobeView;

//#endregion
//#region node_modules/@deck.gl/core/dist/lib/layer-extension.js
var LayerExtension = class {
	static get componentName() {
		return Object.prototype.hasOwnProperty.call(this, "extensionName") ? this.extensionName : "";
	}
	constructor(opts) {
		if (opts) this.opts = opts;
	}
	/** Returns true if two extensions are equivalent */
	equals(extension) {
		if (this === extension) return true;
		return this.constructor === extension.constructor && deepEqual(this.opts, extension.opts, 1);
	}
	/** Only called if attached to a primitive layer */
	getShaders(extension) {
		return null;
	}
	/** Only called if attached to a CompositeLayer */
	getSubLayerProps(extension) {
		const { defaultProps: defaultProps$2 } = extension.constructor;
		const newProps = { updateTriggers: {} };
		for (const key in defaultProps$2) if (key in this.props) {
			const propDef = defaultProps$2[key];
			const propValue = this.props[key];
			newProps[key] = propValue;
			if (propDef && propDef.type === "accessor") {
				newProps.updateTriggers[key] = this.props.updateTriggers[key];
				if (typeof propValue === "function") newProps[key] = this.getSubLayerAccessor(propValue);
			}
		}
		return newProps;
	}
	initializeState(context, extension) {}
	updateState(params, extension) {}
	onNeedsRedraw(extension) {}
	getNeedsPickingBuffer(extension) {
		return false;
	}
	draw(params, extension) {}
	finalizeState(context, extension) {}
};
LayerExtension.defaultProps = {};
LayerExtension.extensionName = "LayerExtension";
var layer_extension_default = LayerExtension;

//#endregion
//#region node_modules/@deck.gl/core/dist/transitions/fly-to-interpolator.js
var LINEARLY_INTERPOLATED_PROPS = {
	bearing: 0,
	pitch: 0,
	position: [
		0,
		0,
		0
	]
};
var DEFAULT_OPTS = {
	speed: 1.2,
	curve: 1.414
};
/**
* This class adapts mapbox-gl-js Map#flyTo animation so it can be used in
* react/redux architecture.
* mapbox-gl-js flyTo : https://www.mapbox.com/mapbox-gl-js/api/#map#flyto.
* It implements Smooth and efficient zooming and panning. algorithm by
* "Jarke J. van Wijk and Wim A.A. Nuij"
*/
var FlyToInterpolator = class extends TransitionInterpolator {
	constructor(opts = {}) {
		super({
			compare: [
				"longitude",
				"latitude",
				"zoom",
				"bearing",
				"pitch",
				"position"
			],
			extract: [
				"width",
				"height",
				"longitude",
				"latitude",
				"zoom",
				"bearing",
				"pitch",
				"position"
			],
			required: [
				"width",
				"height",
				"latitude",
				"longitude",
				"zoom"
			]
		});
		this.opts = {
			...DEFAULT_OPTS,
			...opts
		};
	}
	interpolateProps(startProps, endProps, t$1) {
		const viewport = flyToViewport(startProps, endProps, t$1, this.opts);
		for (const key in LINEARLY_INTERPOLATED_PROPS) viewport[key] = lerp(startProps[key] || LINEARLY_INTERPOLATED_PROPS[key], endProps[key] || LINEARLY_INTERPOLATED_PROPS[key], t$1);
		return viewport;
	}
	getDuration(startProps, endProps) {
		let { transitionDuration } = endProps;
		if (transitionDuration === "auto") transitionDuration = getFlyToDuration(startProps, endProps, this.opts);
		return transitionDuration;
	}
};

//#endregion
//#region node_modules/@deck.gl/core/dist/utils/tesselator.js
var Tesselator = class {
	constructor(opts) {
		this.indexStarts = [0];
		this.vertexStarts = [0];
		this.vertexCount = 0;
		this.instanceCount = 0;
		const { attributes = {} } = opts;
		this.typedArrayManager = typed_array_manager_default;
		this.attributes = {};
		this._attributeDefs = attributes;
		this.opts = opts;
		this.updateGeometry(opts);
	}
	updateGeometry(opts) {
		Object.assign(this.opts, opts);
		const { data, buffers = {}, getGeometry, geometryBuffer, positionFormat, dataChanged, normalize = true } = this.opts;
		this.data = data;
		this.getGeometry = getGeometry;
		this.positionSize = geometryBuffer && geometryBuffer.size || (positionFormat === "XY" ? 2 : 3);
		this.buffers = buffers;
		this.normalize = normalize;
		if (geometryBuffer) {
			assert(data.startIndices);
			this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);
			if (!normalize) buffers.vertexPositions = geometryBuffer;
		}
		this.geometryBuffer = buffers.vertexPositions;
		if (Array.isArray(dataChanged)) for (const dataRange of dataChanged) this._rebuildGeometry(dataRange);
		else this._rebuildGeometry();
	}
	updatePartialGeometry({ startRow, endRow }) {
		this._rebuildGeometry({
			startRow,
			endRow
		});
	}
	getGeometryFromBuffer(geometryBuffer) {
		const value = geometryBuffer.value || geometryBuffer;
		if (!ArrayBuffer.isView(value)) return null;
		return getAccessorFromBuffer(value, {
			size: this.positionSize,
			offset: geometryBuffer.offset,
			stride: geometryBuffer.stride,
			startIndices: this.data.startIndices
		});
	}
	_allocate(instanceCount, copy) {
		const { attributes, buffers, _attributeDefs, typedArrayManager } = this;
		for (const name in _attributeDefs) if (name in buffers) {
			typedArrayManager.release(attributes[name]);
			attributes[name] = null;
		} else {
			const def = _attributeDefs[name];
			def.copy = copy;
			attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);
		}
	}
	/**
	* Visit all objects
	* `data` is expected to be an iterable consistent with the base Layer expectation
	*/
	_forEachGeometry(visitor, startRow, endRow) {
		const { data, getGeometry } = this;
		const { iterable, objectInfo } = createIterable(data, startRow, endRow);
		for (const object of iterable) {
			objectInfo.index++;
			visitor(getGeometry ? getGeometry(object, objectInfo) : null, objectInfo.index);
		}
	}
	_rebuildGeometry(dataRange) {
		if (!this.data) return;
		let { indexStarts, vertexStarts, instanceCount } = this;
		const { data, geometryBuffer } = this;
		const { startRow = 0, endRow = Infinity } = dataRange || {};
		const normalizedData = {};
		if (!dataRange) {
			indexStarts = [0];
			vertexStarts = [0];
		}
		if (this.normalize || !geometryBuffer) {
			this._forEachGeometry((geometry, dataIndex) => {
				const normalizedGeometry = geometry && this.normalizeGeometry(geometry);
				normalizedData[dataIndex] = normalizedGeometry;
				vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);
			}, startRow, endRow);
			instanceCount = vertexStarts[vertexStarts.length - 1];
		} else {
			vertexStarts = data.startIndices;
			instanceCount = vertexStarts[data.length] || 0;
			if (ArrayBuffer.isView(geometryBuffer)) instanceCount = instanceCount || geometryBuffer.length / this.positionSize;
			else if (geometryBuffer instanceof Buffer) {
				const byteStride = this.positionSize * 4;
				instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;
			} else if (geometryBuffer.buffer) {
				const byteStride = geometryBuffer.stride || this.positionSize * 4;
				instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;
			} else if (geometryBuffer.value) {
				const bufferValue = geometryBuffer.value;
				const elementStride = geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;
				instanceCount = instanceCount || bufferValue.length / elementStride;
			}
		}
		this._allocate(instanceCount, Boolean(dataRange));
		this.indexStarts = indexStarts;
		this.vertexStarts = vertexStarts;
		this.instanceCount = instanceCount;
		const context = {};
		this._forEachGeometry((geometry, dataIndex) => {
			const normalizedGeometry = normalizedData[dataIndex] || geometry;
			context.vertexStart = vertexStarts[dataIndex];
			context.indexStart = indexStarts[dataIndex];
			context.geometrySize = (dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount) - vertexStarts[dataIndex];
			context.geometryIndex = dataIndex;
			this.updateGeometryAttributes(normalizedGeometry, context);
		}, startRow, endRow);
		this.vertexCount = indexStarts[indexStarts.length - 1];
	}
};

//#endregion
export { viewport_default as $, map_view_default as A, LayerManager as B, Attribute as C, log_default as Ct, applyStyles as D, Widget as E, TransitionInterpolator as F, Geometry as G, flatten as H, assert as I, uid as J, BufferTransform as K, TRANSITION_EVENTS as L, Controller as M, LinearInterpolator as N, removeStyles as O, globe_viewport_default as P, web_mercator_viewport_default as Q, View as R, AttributeManager as S, VERSION as St, deck_default as T, PickLayersPass as U, fillArray as V, PostProcessEffect as W, CameraLight as X, SunLight as Y, PointLight as Z, ComponentState as _, phongMaterial as _t, GlobeController as a, getShaderAssembler as at, count as b, lerp as bt, orbit_view_default as c, lngLatToWorld as ct, FirstPersonController as d, project_default as dt, fp64LowPart as et, first_person_viewport_default as f, memoize as ft, layer_default as g, color_default as gt, composite_layer_default as h, UNIT as ht, globe_view_default as i, AmbientLight as it, MapController as j, DeckRenderer as k, OrbitController as l, unitsPerMeter as lt, orbit_viewport_default as m, OPERATION as mt, FlyToInterpolator as n, LayersPass as nt, orthographic_view_default as o, picking_default as ot, orthographic_viewport_default as p, COORDINATE_SYSTEM as pt, Model as q, layer_extension_default as r, DirectionalLight as rt, OrthographicController as s, shadow_default as st, Tesselator as t, LightingEffect as tt, first_person_view_default as u, project32_default as ut, component_default as v, gouraudMaterial as vt, createIterable as w, load as wt, compareProps as x, getPassthroughFS as xt, mergeShaders as y, Matrix4 as yt, deepEqual as z };
//# sourceMappingURL=dist-dvxpIib5.js.map