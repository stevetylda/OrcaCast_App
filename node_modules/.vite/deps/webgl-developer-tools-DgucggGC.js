//#region node_modules/@probe.gl/env/dist/lib/globals.js
var window_ = globalThis;
var document_ = globalThis.document || {};
var process_ = globalThis.process || {};
var console_ = globalThis.console;
var navigator_ = globalThis.navigator || {};

//#endregion
//#region node_modules/@probe.gl/env/dist/lib/is-electron.js
function isElectron(mockUserAgent) {
	if (typeof window !== "undefined" && window.process?.type === "renderer") return true;
	if (typeof process !== "undefined" && Boolean(process.versions?.["electron"])) return true;
	const realUserAgent = typeof navigator !== "undefined" && navigator.userAgent;
	const userAgent = mockUserAgent || realUserAgent;
	return Boolean(userAgent && userAgent.indexOf("Electron") >= 0);
}

//#endregion
//#region node_modules/@probe.gl/env/dist/lib/is-browser.js
/** Check if in browser by duck-typing Node context */
function isBrowser() {
	return !(typeof process === "object" && String(process) === "[object process]" && !process?.browser) || isElectron();
}

//#endregion
//#region node_modules/@probe.gl/env/dist/lib/get-browser.js
function getBrowser(mockUserAgent) {
	if (!mockUserAgent && !isBrowser()) return "Node";
	if (isElectron(mockUserAgent)) return "Electron";
	if ((mockUserAgent || navigator_.userAgent || "").indexOf("Edge") > -1) return "Edge";
	if (globalThis.chrome) return "Chrome";
	if (globalThis.safari) return "Safari";
	if (globalThis.mozInnerScreenX) return "Firefox";
	return "Unknown";
}

//#endregion
//#region node_modules/@probe.gl/env/dist/index.js
const VERSION = "4.1.0";

//#endregion
//#region node_modules/@probe.gl/log/dist/utils/local-storage.js
function getStorage(type) {
	try {
		const storage = window[type];
		const x = "__storage_test__";
		storage.setItem(x, x);
		storage.removeItem(x);
		return storage;
	} catch (e) {
		return null;
	}
}
var LocalStorage = class {
	constructor(id, defaultConfig, type = "sessionStorage") {
		this.storage = getStorage(type);
		this.id = id;
		this.config = defaultConfig;
		this._loadConfiguration();
	}
	getConfiguration() {
		return this.config;
	}
	setConfiguration(configuration) {
		Object.assign(this.config, configuration);
		if (this.storage) {
			const serialized = JSON.stringify(this.config);
			this.storage.setItem(this.id, serialized);
		}
	}
	_loadConfiguration() {
		let configuration = {};
		if (this.storage) {
			const serializedConfiguration = this.storage.getItem(this.id);
			configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
		}
		Object.assign(this.config, configuration);
		return this;
	}
};

//#endregion
//#region node_modules/@probe.gl/log/dist/utils/formatters.js
/**
* Format time
*/
function formatTime(ms) {
	let formatted;
	if (ms < 10) formatted = `${ms.toFixed(2)}ms`;
	else if (ms < 100) formatted = `${ms.toFixed(1)}ms`;
	else if (ms < 1e3) formatted = `${ms.toFixed(0)}ms`;
	else formatted = `${(ms / 1e3).toFixed(2)}s`;
	return formatted;
}
function leftPad(string, length = 8) {
	const padLength = Math.max(length - string.length, 0);
	return `${" ".repeat(padLength)}${string}`;
}

//#endregion
//#region node_modules/@probe.gl/log/dist/utils/color.js
var COLOR;
(function(COLOR$1) {
	COLOR$1[COLOR$1["BLACK"] = 30] = "BLACK";
	COLOR$1[COLOR$1["RED"] = 31] = "RED";
	COLOR$1[COLOR$1["GREEN"] = 32] = "GREEN";
	COLOR$1[COLOR$1["YELLOW"] = 33] = "YELLOW";
	COLOR$1[COLOR$1["BLUE"] = 34] = "BLUE";
	COLOR$1[COLOR$1["MAGENTA"] = 35] = "MAGENTA";
	COLOR$1[COLOR$1["CYAN"] = 36] = "CYAN";
	COLOR$1[COLOR$1["WHITE"] = 37] = "WHITE";
	COLOR$1[COLOR$1["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
	COLOR$1[COLOR$1["BRIGHT_RED"] = 91] = "BRIGHT_RED";
	COLOR$1[COLOR$1["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
	COLOR$1[COLOR$1["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
	COLOR$1[COLOR$1["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
	COLOR$1[COLOR$1["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
	COLOR$1[COLOR$1["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
	COLOR$1[COLOR$1["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
})(COLOR || (COLOR = {}));
var BACKGROUND_INCREMENT = 10;
function getColor(color) {
	if (typeof color !== "string") return color;
	color = color.toUpperCase();
	return COLOR[color] || COLOR.WHITE;
}
function addColor(string, color, background) {
	if (!isBrowser && typeof string === "string") {
		if (color) string = `\u001b[${getColor(color)}m${string}\u001b[39m`;
		if (background) string = `\u001b[${getColor(background) + BACKGROUND_INCREMENT}m${string}\u001b[49m`;
	}
	return string;
}

//#endregion
//#region node_modules/@probe.gl/log/dist/utils/autobind.js
/**
* Binds the "this" argument of all functions on a class instance to the instance
* @param obj - class instance (typically a react component)
*/
function autobind(obj, predefined = ["constructor"]) {
	const proto = Object.getPrototypeOf(obj);
	const propNames = Object.getOwnPropertyNames(proto);
	const object = obj;
	for (const key of propNames) {
		const value = object[key];
		if (typeof value === "function") {
			if (!predefined.find((name) => key === name)) object[key] = value.bind(obj);
		}
	}
}

//#endregion
//#region node_modules/@probe.gl/log/dist/utils/assert.js
function assert(condition, message) {
	if (!condition) throw new Error(message || "Assertion failed");
}

//#endregion
//#region node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js
/** Get best timer available. */
function getHiResTimestamp$1() {
	let timestamp;
	if (isBrowser() && window_.performance) timestamp = window_?.performance?.now?.();
	else if ("hrtime" in process_) {
		const timeParts = process_?.hrtime?.();
		timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
	} else timestamp = Date.now();
	return timestamp;
}

//#endregion
//#region node_modules/@probe.gl/log/dist/log.js
var originalConsole = {
	debug: isBrowser() ? console.debug || console.log : console.log,
	log: console.log,
	info: console.info,
	warn: console.warn,
	error: console.error
};
var DEFAULT_LOG_CONFIGURATION = {
	enabled: true,
	level: 0
};
function noop() {}
var cache = {};
var ONCE = { once: true };
/** A console wrapper */
var Log = class {
	constructor({ id } = { id: "" }) {
		this.VERSION = VERSION;
		this._startTs = getHiResTimestamp$1();
		this._deltaTs = getHiResTimestamp$1();
		this.userData = {};
		this.LOG_THROTTLE_TIMEOUT = 0;
		this.id = id;
		this.userData = {};
		this._storage = new LocalStorage(`__probe-${this.id}__`, DEFAULT_LOG_CONFIGURATION);
		this.timeStamp(`${this.id} started`);
		autobind(this);
		Object.seal(this);
	}
	set level(newLevel) {
		this.setLevel(newLevel);
	}
	get level() {
		return this.getLevel();
	}
	isEnabled() {
		return this._storage.config.enabled;
	}
	getLevel() {
		return this._storage.config.level;
	}
	/** @return milliseconds, with fractions */
	getTotal() {
		return Number((getHiResTimestamp$1() - this._startTs).toPrecision(10));
	}
	/** @return milliseconds, with fractions */
	getDelta() {
		return Number((getHiResTimestamp$1() - this._deltaTs).toPrecision(10));
	}
	/** @deprecated use logLevel */
	set priority(newPriority) {
		this.level = newPriority;
	}
	/** @deprecated use logLevel */
	get priority() {
		return this.level;
	}
	/** @deprecated use logLevel */
	getPriority() {
		return this.level;
	}
	enable(enabled = true) {
		this._storage.setConfiguration({ enabled });
		return this;
	}
	setLevel(level) {
		this._storage.setConfiguration({ level });
		return this;
	}
	/** return the current status of the setting */
	get(setting) {
		return this._storage.config[setting];
	}
	set(setting, value) {
		this._storage.setConfiguration({ [setting]: value });
	}
	/** Logs the current settings as a table */
	settings() {
		if (console.table) console.table(this._storage.config);
		else console.log(this._storage.config);
	}
	assert(condition, message) {
		if (!condition) throw new Error(message || "Assertion failed");
	}
	warn(message) {
		return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
	}
	error(message) {
		return this._getLogFunction(0, message, originalConsole.error, arguments);
	}
	/** Print a deprecation warning */
	deprecated(oldUsage, newUsage) {
		return this.warn(`\`${oldUsage}\` is deprecated and will be removed \
in a later version. Use \`${newUsage}\` instead`);
	}
	/** Print a removal warning */
	removed(oldUsage, newUsage) {
		return this.error(`\`${oldUsage}\` has been removed. Use \`${newUsage}\` instead`);
	}
	probe(logLevel, message) {
		return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
			time: true,
			once: true
		});
	}
	log(logLevel, message) {
		return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
	}
	info(logLevel, message) {
		return this._getLogFunction(logLevel, message, console.info, arguments);
	}
	once(logLevel, message) {
		return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
	}
	/** Logs an object as a table */
	table(logLevel, table, columns) {
		if (table) return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], { tag: getTableHeader(table) });
		return noop;
	}
	time(logLevel, message) {
		return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
	}
	timeEnd(logLevel, message) {
		return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
	}
	timeStamp(logLevel, message) {
		return this._getLogFunction(logLevel, message, console.timeStamp || noop);
	}
	group(logLevel, message, opts = { collapsed: false }) {
		const options = normalizeArguments({
			logLevel,
			message,
			opts
		});
		const { collapsed } = opts;
		options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
		return this._getLogFunction(options);
	}
	groupCollapsed(logLevel, message, opts = {}) {
		return this.group(logLevel, message, Object.assign({}, opts, { collapsed: true }));
	}
	groupEnd(logLevel) {
		return this._getLogFunction(logLevel, "", console.groupEnd || noop);
	}
	withGroup(logLevel, message, func) {
		this.group(logLevel, message)();
		try {
			func();
		} finally {
			this.groupEnd(logLevel)();
		}
	}
	trace() {
		if (console.trace) console.trace();
	}
	/** Deduces log level from a variety of arguments */
	_shouldLog(logLevel) {
		return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
	}
	_getLogFunction(logLevel, message, method, args, opts) {
		if (this._shouldLog(logLevel)) {
			opts = normalizeArguments({
				logLevel,
				message,
				args,
				opts
			});
			method = method || opts.method;
			assert(method);
			opts.total = this.getTotal();
			opts.delta = this.getDelta();
			this._deltaTs = getHiResTimestamp$1();
			const tag = opts.tag || opts.message;
			if (opts.once && tag) if (!cache[tag]) cache[tag] = getHiResTimestamp$1();
			else return noop;
			message = decorateMessage(this.id, opts.message, opts);
			return method.bind(console, message, ...opts.args);
		}
		return noop;
	}
};
Log.VERSION = VERSION;
/**
* Get logLevel from first argument:
* - log(logLevel, message, args) => logLevel
* - log(message, args) => 0
* - log({logLevel, ...}, message, args) => logLevel
* - log({logLevel, message, args}) => logLevel
*/
function normalizeLogLevel(logLevel) {
	if (!logLevel) return 0;
	let resolvedLevel;
	switch (typeof logLevel) {
		case "number":
			resolvedLevel = logLevel;
			break;
		case "object":
			resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
			break;
		default: return 0;
	}
	assert(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
	return resolvedLevel;
}
/**
* "Normalizes" the various argument patterns into an object with known types
* - log(logLevel, message, args) => {logLevel, message, args}
* - log(message, args) => {logLevel: 0, message, args}
* - log({logLevel, ...}, message, args) => {logLevel, message, args}
* - log({logLevel, message, args}) => {logLevel, message, args}
*/
function normalizeArguments(opts) {
	const { logLevel, message } = opts;
	opts.logLevel = normalizeLogLevel(logLevel);
	const args = opts.args ? Array.from(opts.args) : [];
	while (args.length && args.shift() !== message);
	switch (typeof logLevel) {
		case "string":
		case "function":
			if (message !== void 0) args.unshift(message);
			opts.message = logLevel;
			break;
		case "object":
			Object.assign(opts, logLevel);
			break;
		default:
	}
	if (typeof opts.message === "function") opts.message = opts.message();
	const messageType = typeof opts.message;
	assert(messageType === "string" || messageType === "object");
	return Object.assign(opts, { args }, opts.opts);
}
function decorateMessage(id, message, opts) {
	if (typeof message === "string") {
		const time = opts.time ? leftPad(formatTime(opts.total)) : "";
		message = opts.time ? `${id}: ${time}  ${message}` : `${id}: ${message}`;
		message = addColor(message, opts.color, opts.background);
	}
	return message;
}
function getTableHeader(table) {
	for (const key in table) for (const title in table[key]) return title || "untitled";
	return "empty";
}

//#endregion
//#region node_modules/@probe.gl/log/dist/init.js
globalThis.probe = {};

//#endregion
//#region node_modules/@probe.gl/log/dist/index.js
var dist_default = new Log({ id: "@probe.gl/log" });

//#endregion
//#region node_modules/@probe.gl/stats/dist/utils/hi-res-timestamp.js
function getHiResTimestamp() {
	let timestamp;
	if (typeof window !== "undefined" && window.performance) timestamp = window.performance.now();
	else if (typeof process !== "undefined" && process.hrtime) {
		const timeParts = process.hrtime();
		timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
	} else timestamp = Date.now();
	return timestamp;
}

//#endregion
//#region node_modules/@probe.gl/stats/dist/lib/stat.js
var Stat = class {
	constructor(name, type) {
		this.sampleSize = 1;
		this.time = 0;
		this.count = 0;
		this.samples = 0;
		this.lastTiming = 0;
		this.lastSampleTime = 0;
		this.lastSampleCount = 0;
		this._count = 0;
		this._time = 0;
		this._samples = 0;
		this._startTime = 0;
		this._timerPending = false;
		this.name = name;
		this.type = type;
		this.reset();
	}
	reset() {
		this.time = 0;
		this.count = 0;
		this.samples = 0;
		this.lastTiming = 0;
		this.lastSampleTime = 0;
		this.lastSampleCount = 0;
		this._count = 0;
		this._time = 0;
		this._samples = 0;
		this._startTime = 0;
		this._timerPending = false;
		return this;
	}
	setSampleSize(samples) {
		this.sampleSize = samples;
		return this;
	}
	/** Call to increment count (+1) */
	incrementCount() {
		this.addCount(1);
		return this;
	}
	/** Call to decrement count (-1) */
	decrementCount() {
		this.subtractCount(1);
		return this;
	}
	/** Increase count */
	addCount(value) {
		this._count += value;
		this._samples++;
		this._checkSampling();
		return this;
	}
	/** Decrease count */
	subtractCount(value) {
		this._count -= value;
		this._samples++;
		this._checkSampling();
		return this;
	}
	/** Add an arbitrary timing and bump the count */
	addTime(time) {
		this._time += time;
		this.lastTiming = time;
		this._samples++;
		this._checkSampling();
		return this;
	}
	/** Start a timer */
	timeStart() {
		this._startTime = getHiResTimestamp();
		this._timerPending = true;
		return this;
	}
	/** End a timer. Adds to time and bumps the timing count. */
	timeEnd() {
		if (!this._timerPending) return this;
		this.addTime(getHiResTimestamp() - this._startTime);
		this._timerPending = false;
		this._checkSampling();
		return this;
	}
	getSampleAverageCount() {
		return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
	}
	/** Calculate average time / count for the previous window */
	getSampleAverageTime() {
		return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
	}
	/** Calculate counts per second for the previous window */
	getSampleHz() {
		return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
	}
	getAverageCount() {
		return this.samples > 0 ? this.count / this.samples : 0;
	}
	/** Calculate average time / count */
	getAverageTime() {
		return this.samples > 0 ? this.time / this.samples : 0;
	}
	/** Calculate counts per second */
	getHz() {
		return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
	}
	_checkSampling() {
		if (this._samples === this.sampleSize) {
			this.lastSampleTime = this._time;
			this.lastSampleCount = this._count;
			this.count += this._count;
			this.time += this._time;
			this.samples += this._samples;
			this._time = 0;
			this._count = 0;
			this._samples = 0;
		}
	}
};

//#endregion
//#region node_modules/@probe.gl/stats/dist/lib/stats.js
/** A "bag" of `Stat` objects, can be visualized using `StatsWidget` */
var Stats = class {
	constructor(options) {
		this.stats = {};
		this.id = options.id;
		this.stats = {};
		this._initializeStats(options.stats);
		Object.seal(this);
	}
	/** Acquire a stat. Create if it doesn't exist. */
	get(name, type = "count") {
		return this._getOrCreate({
			name,
			type
		});
	}
	get size() {
		return Object.keys(this.stats).length;
	}
	/** Reset all stats */
	reset() {
		for (const stat of Object.values(this.stats)) stat.reset();
		return this;
	}
	forEach(fn) {
		for (const stat of Object.values(this.stats)) fn(stat);
	}
	getTable() {
		const table = {};
		this.forEach((stat) => {
			table[stat.name] = {
				time: stat.time || 0,
				count: stat.count || 0,
				average: stat.getAverageTime() || 0,
				hz: stat.getHz() || 0
			};
		});
		return table;
	}
	_initializeStats(stats = []) {
		stats.forEach((stat) => this._getOrCreate(stat));
	}
	_getOrCreate(stat) {
		const { name, type } = stat;
		let result = this.stats[name];
		if (!result) {
			if (stat instanceof Stat) result = stat;
			else result = new Stat(name, type);
			this.stats[name] = result;
		}
		return result;
	}
};

//#endregion
//#region node_modules/@luma.gl/core/dist/utils/stats-manager.js
/**
* Helper class managing a collection of probe.gl stats objects
*/
var StatsManager = class {
	stats = /* @__PURE__ */ new Map();
	getStats(name) {
		return this.get(name);
	}
	get(name) {
		if (!this.stats.has(name)) this.stats.set(name, new Stats({ id: name }));
		return this.stats.get(name);
	}
};
/** Global stats for all luma.gl devices */
const lumaStats = new StatsManager();

//#endregion
//#region node_modules/@luma.gl/core/dist/utils/log.js
/** Global log instance */
const log = new Log({ id: "luma.gl" });

//#endregion
//#region node_modules/@luma.gl/core/dist/utils/uid.js
var uidCounters = {};
/**
* Returns a UID.
* @param id= - Identifier base name
* @return uid
**/
function uid(id = "id") {
	uidCounters[id] = uidCounters[id] || 1;
	return `${id}-${uidCounters[id]++}`;
}

//#endregion
//#region node_modules/@luma.gl/core/dist/adapter/resources/resource.js
/**
* Base class for GPU (WebGPU/WebGL) Resources
*/
var Resource = class {
	/** Default properties for resource */
	static defaultProps = {
		id: "undefined",
		handle: void 0,
		userData: void 0
	};
	toString() {
		return `${this[Symbol.toStringTag] || this.constructor.name}:"${this.id}"`;
	}
	/** props.id, for debugging. */
	id;
	props;
	userData = {};
	_device;
	/** Whether this resource has been destroyed */
	destroyed = false;
	/** For resources that allocate GPU memory */
	allocatedBytes = 0;
	/** Attached resources will be destroyed when this resource is destroyed. Tracks auto-created "sub" resources. */
	_attachedResources = /* @__PURE__ */ new Set();
	/**
	* Create a new Resource. Called from Subclass
	*/
	constructor(device, props, defaultProps) {
		if (!device) throw new Error("no device");
		this._device = device;
		this.props = selectivelyMerge(props, defaultProps);
		const id = this.props.id !== "undefined" ? this.props.id : uid(this[Symbol.toStringTag]);
		this.props.id = id;
		this.id = id;
		this.userData = this.props.userData || {};
		this.addStats();
	}
	/**
	* destroy can be called on any resource to release it before it is garbage collected.
	*/
	destroy() {
		this.destroyResource();
	}
	/** @deprecated Use destroy() */
	delete() {
		this.destroy();
		return this;
	}
	/**
	* Combines a map of user props and default props, only including props from defaultProps
	* @returns returns a map of overridden default props
	*/
	getProps() {
		return this.props;
	}
	/**
	* Attaches a resource. Attached resources are auto destroyed when this resource is destroyed
	* Called automatically when sub resources are auto created but can be called by application
	*/
	attachResource(resource) {
		this._attachedResources.add(resource);
	}
	/**
	* Detach an attached resource. The resource will no longer be auto-destroyed when this resource is destroyed.
	*/
	detachResource(resource) {
		this._attachedResources.delete(resource);
	}
	/**
	* Destroys a resource (only if owned), and removes from the owned (auto-destroy) list for this resource.
	*/
	destroyAttachedResource(resource) {
		if (this._attachedResources.delete(resource)) resource.destroy();
	}
	/** Destroy all owned resources. Make sure the resources are no longer needed before calling. */
	destroyAttachedResources() {
		for (const resource of Object.values(this._attachedResources)) resource.destroy();
		this._attachedResources = /* @__PURE__ */ new Set();
	}
	/** Perform all destroy steps. Can be called by derived resources when overriding destroy() */
	destroyResource() {
		this.destroyAttachedResources();
		this.removeStats();
		this.destroyed = true;
	}
	/** Called by .destroy() to track object destruction. Subclass must call if overriding destroy() */
	removeStats() {
		const stats = this._device.statsManager.getStats("Resource Counts");
		const name = this[Symbol.toStringTag];
		stats.get(`${name}s Active`).decrementCount();
	}
	/** Called by subclass to track memory allocations */
	trackAllocatedMemory(bytes, name = this[Symbol.toStringTag]) {
		const stats = this._device.statsManager.getStats("Resource Counts");
		stats.get("GPU Memory").addCount(bytes);
		stats.get(`${name} Memory`).addCount(bytes);
		this.allocatedBytes = bytes;
	}
	/** Called by subclass to track memory deallocations */
	trackDeallocatedMemory(name = this[Symbol.toStringTag]) {
		const stats = this._device.statsManager.getStats("Resource Counts");
		stats.get("GPU Memory").subtractCount(this.allocatedBytes);
		stats.get(`${name} Memory`).subtractCount(this.allocatedBytes);
		this.allocatedBytes = 0;
	}
	/** Called by resource constructor to track object creation */
	addStats() {
		const stats = this._device.statsManager.getStats("Resource Counts");
		const name = this[Symbol.toStringTag];
		stats.get("Resources Created").incrementCount();
		stats.get(`${name}s Created`).incrementCount();
		stats.get(`${name}s Active`).incrementCount();
	}
};
/**
* Combines a map of user props and default props, only including props from defaultProps
* @param props
* @param defaultProps
* @returns returns a map of overridden default props
*/
function selectivelyMerge(props, defaultProps) {
	const mergedProps = { ...defaultProps };
	for (const key in props) if (props[key] !== void 0) mergedProps[key] = props[key];
	return mergedProps;
}

//#endregion
//#region node_modules/@luma.gl/core/dist/adapter/resources/buffer.js
/** Abstract GPU buffer */
var Buffer = class Buffer extends Resource {
	/** Index buffer */
	static INDEX = 16;
	/** Vertex buffer */
	static VERTEX = 32;
	/** Uniform buffer */
	static UNIFORM = 64;
	/** Storage buffer */
	static STORAGE = 128;
	static INDIRECT = 256;
	static QUERY_RESOLVE = 512;
	static MAP_READ = 1;
	static MAP_WRITE = 2;
	static COPY_SRC = 4;
	static COPY_DST = 8;
	get [Symbol.toStringTag]() {
		return "Buffer";
	}
	/** The usage with which this buffer was created */
	usage;
	/** For index buffers, whether indices are 8, 16 or 32 bit. Note: uint8 indices are automatically converted to uint16 for WebGPU compatibility */
	indexType;
	/** "Time" of last update, can be used to check if redraw is needed */
	updateTimestamp;
	constructor(device, props) {
		const deducedProps = { ...props };
		if ((props.usage || 0) & Buffer.INDEX && !props.indexType) {
			if (props.data instanceof Uint32Array) deducedProps.indexType = "uint32";
			else if (props.data instanceof Uint16Array) deducedProps.indexType = "uint16";
			else if (props.data instanceof Uint8Array) deducedProps.indexType = "uint8";
		}
		delete deducedProps.data;
		super(device, deducedProps, Buffer.defaultProps);
		this.usage = deducedProps.usage || 0;
		this.indexType = deducedProps.indexType;
		this.updateTimestamp = device.incrementTimestamp();
	}
	/**
	* Create a copy of this Buffer with new byteLength, with same props but of the specified size.
	* @note Does not copy contents of the cloned Buffer.
	*/
	clone(props) {
		return this.device.createBuffer({
			...this.props,
			...props
		});
	}
	/** Max amount of debug data saved. Two vec4's */
	static DEBUG_DATA_MAX_LENGTH = 32;
	/** A partial CPU-side copy of the data in this buffer, for debugging purposes */
	debugData = /* @__PURE__ */ new ArrayBuffer(0);
	/** This doesn't handle partial non-zero offset updates correctly */
	_setDebugData(data, byteOffset, byteLength) {
		const arrayBuffer = ArrayBuffer.isView(data) ? data.buffer : data;
		const debugDataLength = Math.min(data ? data.byteLength : byteLength, Buffer.DEBUG_DATA_MAX_LENGTH);
		if (arrayBuffer === null) this.debugData = new ArrayBuffer(debugDataLength);
		else if (byteOffset === 0 && byteLength === arrayBuffer.byteLength) this.debugData = arrayBuffer.slice(0, debugDataLength);
		else this.debugData = arrayBuffer.slice(byteOffset, byteOffset + debugDataLength);
	}
	static defaultProps = {
		...Resource.defaultProps,
		usage: 0,
		byteLength: 0,
		byteOffset: 0,
		data: null,
		indexType: "uint16",
		onMapped: void 0
	};
};

//#endregion
//#region node_modules/@luma.gl/core/dist/shadertypes/data-types/decode-data-types.js
/**
* Gets info about a data type constant (signed or normalized)
* @returns underlying primitive / signed types, byte length, normalization, integer, signed flags
*/
function getDataTypeInfo(type) {
	const [signedType, primitiveType, byteLength] = NORMALIZED_TYPE_MAP[type];
	const normalized = type.includes("norm");
	return {
		signedType,
		primitiveType,
		byteLength,
		normalized,
		integer: !normalized && !type.startsWith("float"),
		signed: type.startsWith("s")
	};
}
/** Build a vertex format from a signed data type and a component */
function getNormalizedDataType(signedDataType) {
	const dataType = signedDataType;
	switch (dataType) {
		case "uint8": return "unorm8";
		case "sint8": return "snorm8";
		case "uint16": return "unorm16";
		case "sint16": return "snorm16";
		default: return dataType;
	}
}
/** Align offset to 1, 2 or 4 elements (4, 8 or 16 bytes) */
function alignTo(size, count) {
	switch (count) {
		case 1: return size;
		case 2: return size + size % 2;
		default: return size + (4 - size % 4) % 4;
	}
}
/** Returns the VariableShaderType that corresponds to a typed array */
function getDataType(arrayOrType) {
	const Constructor = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
	if (Constructor === Uint8ClampedArray) return "uint8";
	const info = Object.values(NORMALIZED_TYPE_MAP).find((entry) => Constructor === entry[4]);
	if (!info) throw new Error(Constructor.name);
	return info[0];
}
/** Returns the TypedArray that corresponds to a shader data type */
function getTypedArrayConstructor(type) {
	const [, , , , Constructor] = NORMALIZED_TYPE_MAP[type];
	return Constructor;
}
var NORMALIZED_TYPE_MAP = {
	uint8: [
		"uint8",
		"u32",
		1,
		false,
		Uint8Array
	],
	sint8: [
		"sint8",
		"i32",
		1,
		false,
		Int8Array
	],
	unorm8: [
		"uint8",
		"f32",
		1,
		true,
		Uint8Array
	],
	snorm8: [
		"sint8",
		"f32",
		1,
		true,
		Int8Array
	],
	uint16: [
		"uint16",
		"u32",
		2,
		false,
		Uint16Array
	],
	sint16: [
		"sint16",
		"i32",
		2,
		false,
		Int16Array
	],
	unorm16: [
		"uint16",
		"u32",
		2,
		true,
		Uint16Array
	],
	snorm16: [
		"sint16",
		"i32",
		2,
		true,
		Int16Array
	],
	float16: [
		"float16",
		"f16",
		2,
		false,
		Uint16Array
	],
	float32: [
		"float32",
		"f32",
		4,
		false,
		Float32Array
	],
	uint32: [
		"uint32",
		"u32",
		4,
		false,
		Uint32Array
	],
	sint32: [
		"sint32",
		"i32",
		4,
		false,
		Int32Array
	]
};

//#endregion
//#region node_modules/@luma.gl/core/dist/shadertypes/vertex-arrays/decode-vertex-format.js
/**
* Decodes a vertex format, returning type, components, byte  length and flags (integer, signed, normalized)
*/
function getVertexFormatInfo(format) {
	let webglOnly;
	if (format.endsWith("-webgl")) {
		format.replace("-webgl", "");
		webglOnly = true;
	}
	const [type_, count] = format.split("x");
	const type = type_;
	const components = count ? parseInt(count) : 1;
	const decodedType = getDataTypeInfo(type);
	const result = {
		type,
		components,
		byteLength: decodedType.byteLength * components,
		integer: decodedType.integer,
		signed: decodedType.signed,
		normalized: decodedType.normalized
	};
	if (webglOnly) result.webglOnly = true;
	return result;
}
/** Build a vertex format from a signed data type and a component */
function makeVertexFormat(signedDataType, components, normalized) {
	const dataType = normalized ? getNormalizedDataType(signedDataType) : signedDataType;
	switch (dataType) {
		case "unorm8":
			if (components === 1) return "unorm8";
			if (components === 3) return "unorm8x3-webgl";
			return `${dataType}x${components}`;
		case "snorm8":
		case "uint8":
		case "sint8":
		case "uint16":
		case "sint16":
		case "unorm16":
		case "snorm16":
		case "float16":
			if (components === 1 || components === 3) throw new Error(`size: ${components}`);
			return `${dataType}x${components}`;
		default: return components === 1 ? dataType : `${dataType}x${components}`;
	}
}
/** Get the vertex format for an attribute with TypedArray and size */
function getVertexFormatFromAttribute(typedArray, size, normalized) {
	if (!size || size > 4) throw new Error(`size ${size}`);
	const components = size;
	return makeVertexFormat(getDataType(typedArray), components, normalized);
}
/** Return a "default" vertex format for a certain shader data type
The simplest vertex format that matches the shader attribute's data type */
function getCompatibleVertexFormat(opts) {
	let vertexType;
	switch (opts.primitiveType) {
		case "f32":
			vertexType = "float32";
			break;
		case "i32":
			vertexType = "sint32";
			break;
		case "u32":
			vertexType = "uint32";
			break;
		case "f16": return opts.components <= 2 ? "float16x2" : "float16x4";
	}
	if (opts.components === 1) return vertexType;
	return `${vertexType}x${opts.components}`;
}

//#endregion
//#region node_modules/@luma.gl/core/dist/shadertypes/textures/texture-format-table.js
var texture_compression_bc = "texture-compression-bc";
var texture_compression_astc = "texture-compression-astc";
var texture_compression_etc2 = "texture-compression-etc2";
var texture_compression_etc1_webgl = "texture-compression-etc1-webgl";
var texture_compression_pvrtc_webgl = "texture-compression-pvrtc-webgl";
var texture_compression_atc_webgl = "texture-compression-atc-webgl";
var float32_renderable = "float32-renderable-webgl";
var float16_renderable = "float16-renderable-webgl";
var rgb9e5ufloat_renderable = "rgb9e5ufloat-renderable-webgl";
var snorm8_renderable = "snorm8-renderable-webgl";
var norm16_renderable = "norm16-renderable-webgl";
var snorm16_renderable = "snorm16-renderable-webgl";
var float32_filterable = "float32-filterable";
var float16_filterable = "float16-filterable-webgl";
function getTextureFormatDefinition(format) {
	const info = TEXTURE_FORMAT_TABLE[format];
	if (!info) throw new Error(`Unsupported texture format ${format}`);
	return info;
}
var TEXTURE_FORMAT_COLOR_DEPTH_TABLE = {
	"r8unorm": {},
	"rg8unorm": {},
	"rgb8unorm-webgl": {},
	"rgba8unorm": {},
	"rgba8unorm-srgb": {},
	"r8snorm": { render: snorm8_renderable },
	"rg8snorm": { render: snorm8_renderable },
	"rgb8snorm-webgl": {},
	"rgba8snorm": { render: snorm8_renderable },
	"r8uint": {},
	"rg8uint": {},
	"rgba8uint": {},
	"r8sint": {},
	"rg8sint": {},
	"rgba8sint": {},
	"bgra8unorm": {},
	"bgra8unorm-srgb": {},
	"r16unorm": { f: norm16_renderable },
	"rg16unorm": { render: norm16_renderable },
	"rgb16unorm-webgl": { f: norm16_renderable },
	"rgba16unorm": { render: norm16_renderable },
	"r16snorm": { f: snorm16_renderable },
	"rg16snorm": { render: snorm16_renderable },
	"rgb16snorm-webgl": { f: norm16_renderable },
	"rgba16snorm": { render: snorm16_renderable },
	"r16uint": {},
	"rg16uint": {},
	"rgba16uint": {},
	"r16sint": {},
	"rg16sint": {},
	"rgba16sint": {},
	"r16float": {
		render: float16_renderable,
		filter: "float16-filterable-webgl"
	},
	"rg16float": {
		render: float16_renderable,
		filter: float16_filterable
	},
	"rgba16float": {
		render: float16_renderable,
		filter: float16_filterable
	},
	"r32uint": {},
	"rg32uint": {},
	"rgba32uint": {},
	"r32sint": {},
	"rg32sint": {},
	"rgba32sint": {},
	"r32float": {
		render: float32_renderable,
		filter: float32_filterable
	},
	"rg32float": {
		render: false,
		filter: float32_filterable
	},
	"rgb32float-webgl": {
		render: float32_renderable,
		filter: float32_filterable
	},
	"rgba32float": {
		render: float32_renderable,
		filter: float32_filterable
	},
	"rgba4unorm-webgl": {
		channels: "rgba",
		bitsPerChannel: [
			4,
			4,
			4,
			4
		],
		packed: true
	},
	"rgb565unorm-webgl": {
		channels: "rgb",
		bitsPerChannel: [
			5,
			6,
			5,
			0
		],
		packed: true
	},
	"rgb5a1unorm-webgl": {
		channels: "rgba",
		bitsPerChannel: [
			5,
			5,
			5,
			1
		],
		packed: true
	},
	"rgb9e5ufloat": {
		channels: "rgb",
		packed: true,
		render: rgb9e5ufloat_renderable
	},
	"rg11b10ufloat": {
		channels: "rgb",
		bitsPerChannel: [
			11,
			11,
			10,
			0
		],
		packed: true,
		p: 1,
		render: float32_renderable
	},
	"rgb10a2unorm": {
		channels: "rgba",
		bitsPerChannel: [
			10,
			10,
			10,
			2
		],
		packed: true,
		p: 1
	},
	"rgb10a2uint": {
		channels: "rgba",
		bitsPerChannel: [
			10,
			10,
			10,
			2
		],
		packed: true,
		p: 1
	},
	stencil8: {
		attachment: "stencil",
		bitsPerChannel: [
			8,
			0,
			0,
			0
		],
		dataType: "uint8"
	},
	"depth16unorm": {
		attachment: "depth",
		bitsPerChannel: [
			16,
			0,
			0,
			0
		],
		dataType: "uint16"
	},
	"depth24plus": {
		attachment: "depth",
		bitsPerChannel: [
			24,
			0,
			0,
			0
		],
		dataType: "uint32"
	},
	"depth32float": {
		attachment: "depth",
		bitsPerChannel: [
			32,
			0,
			0,
			0
		],
		dataType: "float32"
	},
	"depth24plus-stencil8": {
		attachment: "depth-stencil",
		bitsPerChannel: [
			24,
			8,
			0,
			0
		],
		packed: true
	},
	"depth32float-stencil8": {
		attachment: "depth-stencil",
		bitsPerChannel: [
			32,
			8,
			0,
			0
		],
		packed: true
	}
};
var TEXTURE_FORMAT_COMPRESSED_TABLE = {
	"bc1-rgb-unorm-webgl": { f: texture_compression_bc },
	"bc1-rgb-unorm-srgb-webgl": { f: texture_compression_bc },
	"bc1-rgba-unorm": { f: texture_compression_bc },
	"bc1-rgba-unorm-srgb": { f: texture_compression_bc },
	"bc2-rgba-unorm": { f: texture_compression_bc },
	"bc2-rgba-unorm-srgb": { f: texture_compression_bc },
	"bc3-rgba-unorm": { f: texture_compression_bc },
	"bc3-rgba-unorm-srgb": { f: texture_compression_bc },
	"bc4-r-unorm": { f: texture_compression_bc },
	"bc4-r-snorm": { f: texture_compression_bc },
	"bc5-rg-unorm": { f: texture_compression_bc },
	"bc5-rg-snorm": { f: texture_compression_bc },
	"bc6h-rgb-ufloat": { f: texture_compression_bc },
	"bc6h-rgb-float": { f: texture_compression_bc },
	"bc7-rgba-unorm": { f: texture_compression_bc },
	"bc7-rgba-unorm-srgb": { f: texture_compression_bc },
	"etc2-rgb8unorm": { f: texture_compression_etc2 },
	"etc2-rgb8unorm-srgb": { f: texture_compression_etc2 },
	"etc2-rgb8a1unorm": { f: texture_compression_etc2 },
	"etc2-rgb8a1unorm-srgb": { f: texture_compression_etc2 },
	"etc2-rgba8unorm": { f: texture_compression_etc2 },
	"etc2-rgba8unorm-srgb": { f: texture_compression_etc2 },
	"eac-r11unorm": { f: texture_compression_etc2 },
	"eac-r11snorm": { f: texture_compression_etc2 },
	"eac-rg11unorm": { f: texture_compression_etc2 },
	"eac-rg11snorm": { f: texture_compression_etc2 },
	"astc-4x4-unorm": { f: texture_compression_astc },
	"astc-4x4-unorm-srgb": { f: texture_compression_astc },
	"astc-5x4-unorm": { f: texture_compression_astc },
	"astc-5x4-unorm-srgb": { f: texture_compression_astc },
	"astc-5x5-unorm": { f: texture_compression_astc },
	"astc-5x5-unorm-srgb": { f: texture_compression_astc },
	"astc-6x5-unorm": { f: texture_compression_astc },
	"astc-6x5-unorm-srgb": { f: texture_compression_astc },
	"astc-6x6-unorm": { f: texture_compression_astc },
	"astc-6x6-unorm-srgb": { f: texture_compression_astc },
	"astc-8x5-unorm": { f: texture_compression_astc },
	"astc-8x5-unorm-srgb": { f: texture_compression_astc },
	"astc-8x6-unorm": { f: texture_compression_astc },
	"astc-8x6-unorm-srgb": { f: texture_compression_astc },
	"astc-8x8-unorm": { f: texture_compression_astc },
	"astc-8x8-unorm-srgb": { f: texture_compression_astc },
	"astc-10x5-unorm": { f: texture_compression_astc },
	"astc-10x5-unorm-srgb": { f: texture_compression_astc },
	"astc-10x6-unorm": { f: texture_compression_astc },
	"astc-10x6-unorm-srgb": { f: texture_compression_astc },
	"astc-10x8-unorm": { f: texture_compression_astc },
	"astc-10x8-unorm-srgb": { f: texture_compression_astc },
	"astc-10x10-unorm": { f: texture_compression_astc },
	"astc-10x10-unorm-srgb": { f: texture_compression_astc },
	"astc-12x10-unorm": { f: texture_compression_astc },
	"astc-12x10-unorm-srgb": { f: texture_compression_astc },
	"astc-12x12-unorm": { f: texture_compression_astc },
	"astc-12x12-unorm-srgb": { f: texture_compression_astc },
	"pvrtc-rgb4unorm-webgl": { f: texture_compression_pvrtc_webgl },
	"pvrtc-rgba4unorm-webgl": { f: texture_compression_pvrtc_webgl },
	"pvrtc-rbg2unorm-webgl": { f: texture_compression_pvrtc_webgl },
	"pvrtc-rgba2unorm-webgl": { f: texture_compression_pvrtc_webgl },
	"etc1-rbg-unorm-webgl": { f: texture_compression_etc1_webgl },
	"atc-rgb-unorm-webgl": { f: texture_compression_atc_webgl },
	"atc-rgba-unorm-webgl": { f: texture_compression_atc_webgl },
	"atc-rgbai-unorm-webgl": { f: texture_compression_atc_webgl }
};
const TEXTURE_FORMAT_TABLE = {
	...TEXTURE_FORMAT_COLOR_DEPTH_TABLE,
	...TEXTURE_FORMAT_COMPRESSED_TABLE
};

//#endregion
//#region node_modules/@luma.gl/core/dist/shadertypes/textures/texture-format-decoder.js
var COMPRESSED_TEXTURE_FORMAT_PREFIXES = [
	"bc1",
	"bc2",
	"bc3",
	"bc4",
	"bc5",
	"bc6",
	"bc7",
	"etc1",
	"etc2",
	"eac",
	"atc",
	"astc",
	"pvrtc"
];
var RGB_FORMAT_REGEX = /^(r|rg|rgb|rgba|bgra)([0-9]*)([a-z]*)(-srgb)?(-webgl)?$/;
var TextureFormatDecoder = class {
	/** Returns information about a texture format, e.g. attatchment type, components, byte length and flags (integer, signed, normalized) */
	getInfo(format) {
		return getTextureFormatInfo(format);
	}
	/** Checks if a texture format is color */
	isColor(format) {
		return format.startsWith("rgba") || format.startsWith("bgra") || format.startsWith("rgb");
	}
	/** Checks if a texture format is depth or stencil */
	isDepthStencil(format) {
		return format.startsWith("depth") || format.startsWith("stencil");
	}
	/** Checks if a texture format is compressed */
	isCompressed(format) {
		return COMPRESSED_TEXTURE_FORMAT_PREFIXES.some((prefix) => format.startsWith(prefix));
	}
	/**
	* Returns the "static" capabilities of a texture format.
	* @note Needs to be checked against current device
	*/
	getCapabilities(format) {
		const info = getTextureFormatDefinition(format);
		const formatCapabilities = {
			format,
			create: info.f ?? true,
			render: info.render ?? true,
			filter: info.filter ?? true,
			blend: info.blend ?? true,
			store: info.store ?? true
		};
		const formatInfo = getTextureFormatInfo(format);
		const isDepthStencil = format.startsWith("depth") || format.startsWith("stencil");
		const isSigned = formatInfo?.signed;
		const isInteger = formatInfo?.integer;
		const isWebGLSpecific = formatInfo?.webgl;
		formatCapabilities.render &&= !isSigned;
		formatCapabilities.filter &&= !isDepthStencil && !isSigned && !isInteger && !isWebGLSpecific;
		return formatCapabilities;
	}
};
const textureFormatDecoder = new TextureFormatDecoder();
/**
* Decodes a texture format, returning e.g. attatchment type, components, byte length and flags (integer, signed, normalized)
*/
function getTextureFormatInfo(format) {
	let formatInfo = getTextureFormatInfoUsingTable(format);
	if (textureFormatDecoder.isCompressed(format)) {
		formatInfo.channels = "rgb";
		formatInfo.components = 3;
		formatInfo.bytesPerPixel = 1;
		formatInfo.srgb = false;
		formatInfo.compressed = true;
		const blockSize = getCompressedTextureBlockSize(format);
		if (blockSize) {
			formatInfo.blockWidth = blockSize.blockWidth;
			formatInfo.blockHeight = blockSize.blockHeight;
		}
	}
	const matches = RGB_FORMAT_REGEX.exec(format);
	if (matches) {
		const [, channels, length, type, srgb, suffix] = matches;
		const decodedType = getDataTypeInfo(`${type}${length}`);
		const bits = decodedType.byteLength * 8;
		const components = channels.length;
		const bitsPerChannel = [
			bits,
			components >= 2 ? bits : 0,
			components >= 3 ? bits : 0,
			components >= 4 ? bits : 0
		];
		formatInfo = {
			format,
			attachment: formatInfo.attachment,
			dataType: decodedType.signedType,
			components,
			channels,
			integer: decodedType.integer,
			signed: decodedType.signed,
			normalized: decodedType.normalized,
			bitsPerChannel,
			bytesPerPixel: decodedType.byteLength * channels.length,
			packed: formatInfo.packed,
			srgb: formatInfo.srgb
		};
		if (suffix === "-webgl") formatInfo.webgl = true;
		if (srgb === "-srgb") formatInfo.srgb = true;
	}
	if (format.endsWith("-webgl")) formatInfo.webgl = true;
	if (format.endsWith("-srgb")) formatInfo.srgb = true;
	return formatInfo;
}
/** Decode texture format info from the table */
function getTextureFormatInfoUsingTable(format) {
	const info = getTextureFormatDefinition(format);
	const bytesPerPixel = info.bytesPerPixel || 1;
	const bitsPerChannel = info.bitsPerChannel || [
		8,
		8,
		8,
		8
	];
	delete info.bitsPerChannel;
	delete info.bytesPerPixel;
	delete info.f;
	delete info.render;
	delete info.filter;
	delete info.blend;
	delete info.store;
	return {
		...info,
		format,
		attachment: info.attachment || "color",
		channels: info.channels || "r",
		components: info.components || info.channels?.length || 1,
		bytesPerPixel,
		bitsPerChannel,
		dataType: info.dataType || "uint8",
		srgb: info.srgb ?? false,
		packed: info.packed ?? false,
		webgl: info.webgl ?? false,
		integer: info.integer ?? false,
		signed: info.signed ?? false,
		normalized: info.normalized ?? false,
		compressed: info.compressed ?? false
	};
}
/** Parses ASTC block widths from format string */
function getCompressedTextureBlockSize(format) {
	const matches = /.*-(\d+)x(\d+)-.*/.exec(format);
	if (matches) {
		const [, blockWidth, blockHeight] = matches;
		return {
			blockWidth: Number(blockWidth),
			blockHeight: Number(blockHeight)
		};
	}
	return null;
}

//#endregion
//#region node_modules/@luma.gl/core/dist/image-utils/image-types.js
/** Check if data is an external image */
function isExternalImage(data) {
	return typeof ImageData !== "undefined" && data instanceof ImageData || typeof ImageBitmap !== "undefined" && data instanceof ImageBitmap || typeof HTMLImageElement !== "undefined" && data instanceof HTMLImageElement || typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement || typeof VideoFrame !== "undefined" && data instanceof VideoFrame || typeof HTMLCanvasElement !== "undefined" && data instanceof HTMLCanvasElement || typeof OffscreenCanvas !== "undefined" && data instanceof OffscreenCanvas;
}
/** Determine size (width and height) of provided image data */
function getExternalImageSize(data) {
	if (typeof ImageData !== "undefined" && data instanceof ImageData || typeof ImageBitmap !== "undefined" && data instanceof ImageBitmap || typeof HTMLCanvasElement !== "undefined" && data instanceof HTMLCanvasElement || typeof OffscreenCanvas !== "undefined" && data instanceof OffscreenCanvas) return {
		width: data.width,
		height: data.height
	};
	if (typeof HTMLImageElement !== "undefined" && data instanceof HTMLImageElement) return {
		width: data.naturalWidth,
		height: data.naturalHeight
	};
	if (typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement) return {
		width: data.videoWidth,
		height: data.videoHeight
	};
	if (typeof VideoFrame !== "undefined" && data instanceof VideoFrame) return {
		width: data.displayWidth,
		height: data.displayHeight
	};
	throw new Error("Unknown image type");
}

//#endregion
//#region node_modules/@luma.gl/core/dist/adapter/device.js
/** Limits for a device (max supported sizes of resources, max number of bindings etc) */
var DeviceLimits = class {};
/** Set-like class for features (lets apps check for WebGL / WebGPU extensions) */
var DeviceFeatures = class {
	features;
	disabledFeatures;
	constructor(features = [], disabledFeatures) {
		this.features = new Set(features);
		this.disabledFeatures = disabledFeatures || {};
	}
	*[Symbol.iterator]() {
		yield* this.features;
	}
	has(feature) {
		return !this.disabledFeatures?.[feature] && this.features.has(feature);
	}
};
/**
* WebGPU Device/WebGL context abstraction
*/
var Device = class Device {
	static defaultProps = {
		id: null,
		powerPreference: "high-performance",
		failIfMajorPerformanceCaveat: false,
		createCanvasContext: void 0,
		webgl: {},
		onError: (error, context) => {},
		onResize: (context, info) => {
			const [width, height] = context.getDevicePixelSize();
			log.log(1, `${context} resized => ${width}x${height}px`)();
		},
		onPositionChange: (context, info) => {
			const [left, top] = context.getPosition();
			log.log(1, `${context} repositioned => ${left},${top}`)();
		},
		onVisibilityChange: (context) => log.log(1, `${context} Visibility changed ${context.isVisible}`)(),
		onDevicePixelRatioChange: (context, info) => log.log(1, `${context} DPR changed ${info.oldRatio} => ${context.devicePixelRatio}`)(),
		debug: log.get("debug") || void 0,
		debugShaders: log.get("debug-shaders") || void 0,
		debugFramebuffers: Boolean(log.get("debug-framebuffers")),
		debugFactories: Boolean(log.get("debug-factories")),
		debugWebGL: Boolean(log.get("debug-webgl")),
		debugSpectorJS: void 0,
		debugSpectorJSUrl: void 0,
		_reuseDevices: false,
		_requestMaxLimits: true,
		_cacheShaders: false,
		_cachePipelines: false,
		_cacheDestroyPolicy: "unused",
		_initializeFeatures: true,
		_disabledFeatures: { "compilation-status-async-webgl": true },
		_handle: void 0
	};
	get [Symbol.toStringTag]() {
		return "Device";
	}
	toString() {
		return `Device(${this.id})`;
	}
	/** id of this device, primarily for debugging */
	id;
	/** A copy of the device props  */
	props;
	/** Available for the application to store data on the device */
	userData = {};
	/** stats */
	statsManager = lumaStats;
	/** An abstract timestamp used for change tracking */
	timestamp = 0;
	/** True if this device has been reused during device creation (app has multiple references) */
	_reused = false;
	/** Used by other luma.gl modules to store data on the device */
	_lumaData = {};
	_textureCaps = {};
	constructor(props) {
		this.props = {
			...Device.defaultProps,
			...props
		};
		this.id = this.props.id || uid(this[Symbol.toStringTag].toLowerCase());
	}
	getVertexFormatInfo(format) {
		return getVertexFormatInfo(format);
	}
	isVertexFormatSupported(format) {
		return true;
	}
	/** Returns information about a texture format, such as data type, channels, bits per channel, compression etc */
	getTextureFormatInfo(format) {
		return textureFormatDecoder.getInfo(format);
	}
	/** Determines what operations are supported on a texture format on this particular device (checks against supported device features) */
	getTextureFormatCapabilities(format) {
		let textureCaps = this._textureCaps[format];
		if (!textureCaps) {
			const capabilities = this._getDeviceTextureFormatCapabilities(format);
			textureCaps = this._getDeviceSpecificTextureFormatCapabilities(capabilities);
			this._textureCaps[format] = textureCaps;
		}
		return textureCaps;
	}
	/** Calculates the number of mip levels for a texture of width, height and in case of 3d textures only, depth */
	getMipLevelCount(width, height, depth3d = 1) {
		const maxSize = Math.max(width, height, depth3d);
		return 1 + Math.floor(Math.log2(maxSize));
	}
	/** Check if data is an external image */
	isExternalImage(data) {
		return isExternalImage(data);
	}
	/** Get the size of an external image */
	getExternalImageSize(data) {
		return getExternalImageSize(data);
	}
	/** Check if device supports a specific texture format (creation and `nearest` sampling) */
	isTextureFormatSupported(format) {
		return this.getTextureFormatCapabilities(format).create;
	}
	/** Check if linear filtering (sampler interpolation) is supported for a specific texture format */
	isTextureFormatFilterable(format) {
		return this.getTextureFormatCapabilities(format).filter;
	}
	/** Check if device supports rendering to a framebuffer color attachment of a specific texture format */
	isTextureFormatRenderable(format) {
		return this.getTextureFormatCapabilities(format).render;
	}
	/** Check if a specific texture format is GPU compressed */
	isTextureFormatCompressed(format) {
		return textureFormatDecoder.isCompressed(format);
	}
	pushDebugGroup(groupLabel) {
		this.commandEncoder.pushDebugGroup(groupLabel);
	}
	popDebugGroup() {
		this.commandEncoder?.popDebugGroup();
	}
	insertDebugMarker(markerLabel) {
		this.commandEncoder?.insertDebugMarker(markerLabel);
	}
	/**
	* Trigger device loss.
	* @returns `true` if context loss could actually be triggered.
	* @note primarily intended for testing how application reacts to device loss
	*/
	loseDevice() {
		return false;
	}
	/** A monotonic counter for tracking buffer and texture updates */
	incrementTimestamp() {
		return this.timestamp++;
	}
	/**
	* Reports Device errors in a way that optimizes for developer experience / debugging.
	* - Logs so that the console error links directly to the source code that generated the error.
	* - Includes the object that reported the error in the log message, even if the error is asynchronous.
	*
	* Conventions when calling reportError():
	* - Always call the returned function - to ensure error is logged, at the error site
	* - Follow with a call to device.debug() - to ensure that the debugger breaks at the error site
	*
	* @param error - the error to report. If needed, just create a new Error object with the appropriate message.
	* @param context - pass `this` as context, otherwise it may not be available in the debugger for async errors.
	* @returns the logger function returned by device.props.onError() so that it can be called from the error site.
	*
	* @example
	*   device.reportError(new Error(...), this)();
	*   device.debug();
	*/
	reportError(error, context, ...args) {
		if (!this.props.onError(error, context)) return log.error(error.message, context, ...args);
		return () => {};
	}
	/** Break in the debugger - if device.props.debug is true */
	debug() {
		if (this.props.debug) debugger;
		else log.once(0, `\
'Type luma.log.set({debug: true}) in console to enable debug breakpoints',
or create a device with the 'debug: true' prop.`)();
	}
	/** Returns the default / primary canvas context. Throws an error if no canvas context is available (a WebGPU compute device) */
	getDefaultCanvasContext() {
		if (!this.canvasContext) throw new Error("Device has no default CanvasContext. See props.createCanvasContext");
		return this.canvasContext;
	}
	/** Create a RenderPass using the default CommandEncoder */
	beginRenderPass(props) {
		return this.commandEncoder.beginRenderPass(props);
	}
	/** Create a ComputePass using the default CommandEncoder*/
	beginComputePass(props) {
		return this.commandEncoder.beginComputePass(props);
	}
	/** @deprecated Use getDefaultCanvasContext() */
	getCanvasContext() {
		return this.getDefaultCanvasContext();
	}
	/** @deprecated - will be removed - should use command encoder */
	readPixelsToArrayWebGL(source, options) {
		throw new Error("not implemented");
	}
	/** @deprecated - will be removed - should use command encoder */
	readPixelsToBufferWebGL(source, options) {
		throw new Error("not implemented");
	}
	/** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
	setParametersWebGL(parameters) {
		throw new Error("not implemented");
	}
	/** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
	getParametersWebGL(parameters) {
		throw new Error("not implemented");
	}
	/** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
	withParametersWebGL(parameters, func) {
		throw new Error("not implemented");
	}
	/** @deprecated - will be removed - should use clear arguments in RenderPass */
	clearWebGL(options) {
		throw new Error("not implemented");
	}
	/** @deprecated - will be removed - should use for debugging only */
	resetWebGL() {
		throw new Error("not implemented");
	}
	/** Helper to get the canvas context props */
	static _getCanvasContextProps(props) {
		return props.createCanvasContext === true ? {} : props.createCanvasContext;
	}
	_getDeviceTextureFormatCapabilities(format) {
		const genericCapabilities = textureFormatDecoder.getCapabilities(format);
		const checkFeature = (feature) => (typeof feature === "string" ? this.features.has(feature) : feature) ?? true;
		const supported = checkFeature(genericCapabilities.create);
		return {
			format,
			create: supported,
			render: supported && checkFeature(genericCapabilities.render),
			filter: supported && checkFeature(genericCapabilities.filter),
			blend: supported && checkFeature(genericCapabilities.blend),
			store: supported && checkFeature(genericCapabilities.store)
		};
	}
	/** Subclasses use this to support .createBuffer() overloads */
	_normalizeBufferProps(props) {
		if (props instanceof ArrayBuffer || ArrayBuffer.isView(props)) props = { data: props };
		const newProps = { ...props };
		if ((props.usage || 0) & Buffer.INDEX) {
			if (!props.indexType) {
				if (props.data instanceof Uint32Array) newProps.indexType = "uint32";
				else if (props.data instanceof Uint16Array) newProps.indexType = "uint16";
				else if (props.data instanceof Uint8Array) {
					newProps.data = new Uint16Array(props.data);
					newProps.indexType = "uint16";
				}
			}
			if (!newProps.indexType) throw new Error("indices buffer content must be of type uint16 or uint32");
		}
		return newProps;
	}
};

//#endregion
//#region node_modules/@luma.gl/constants/dist/webgl-constants.js
/**
* Standard WebGL, WebGL2 and extension constants (OpenGL constants)
* @note (Most) of these constants are also defined on the WebGLRenderingContext interface.
* @see https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants
* @privateRemarks Locally called `GLEnum` instead of `GL`, because `babel-plugin-inline-webl-constants`
*  both depends on and processes this module, but shouldn't replace these declarations.
*/
var GLEnum;
(function(GLEnum$1) {
	/** Passed to clear to clear the current depth buffer. */
	GLEnum$1[GLEnum$1["DEPTH_BUFFER_BIT"] = 256] = "DEPTH_BUFFER_BIT";
	/** Passed to clear to clear the current stencil buffer. */
	GLEnum$1[GLEnum$1["STENCIL_BUFFER_BIT"] = 1024] = "STENCIL_BUFFER_BIT";
	/** Passed to clear to clear the current color buffer. */
	GLEnum$1[GLEnum$1["COLOR_BUFFER_BIT"] = 16384] = "COLOR_BUFFER_BIT";
	/** Passed to drawElements or drawArrays to draw single points. */
	GLEnum$1[GLEnum$1["POINTS"] = 0] = "POINTS";
	/** Passed to drawElements or drawArrays to draw lines. Each vertex connects to the one after it. */
	GLEnum$1[GLEnum$1["LINES"] = 1] = "LINES";
	/** Passed to drawElements or drawArrays to draw lines. Each set of two vertices is treated as a separate line segment. */
	GLEnum$1[GLEnum$1["LINE_LOOP"] = 2] = "LINE_LOOP";
	/** Passed to drawElements or drawArrays to draw a connected group of line segments from the first vertex to the last. */
	GLEnum$1[GLEnum$1["LINE_STRIP"] = 3] = "LINE_STRIP";
	/** Passed to drawElements or drawArrays to draw triangles. Each set of three vertices creates a separate triangle. */
	GLEnum$1[GLEnum$1["TRIANGLES"] = 4] = "TRIANGLES";
	/** Passed to drawElements or drawArrays to draw a connected group of triangles. */
	GLEnum$1[GLEnum$1["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
	/** Passed to drawElements or drawArrays to draw a connected group of triangles. Each vertex connects to the previous and the first vertex in the fan. */
	GLEnum$1[GLEnum$1["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
	/** Passed to blendFunc or blendFuncSeparate to turn off a component. */
	GLEnum$1[GLEnum$1["ZERO"] = 0] = "ZERO";
	/** Passed to blendFunc or blendFuncSeparate to turn on a component. */
	GLEnum$1[GLEnum$1["ONE"] = 1] = "ONE";
	/** Passed to blendFunc or blendFuncSeparate to multiply a component by the source elements color. */
	GLEnum$1[GLEnum$1["SRC_COLOR"] = 768] = "SRC_COLOR";
	/** Passed to blendFunc or blendFuncSeparate to multiply a component by one minus the source elements color. */
	GLEnum$1[GLEnum$1["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
	/** Passed to blendFunc or blendFuncSeparate to multiply a component by the source's alpha. */
	GLEnum$1[GLEnum$1["SRC_ALPHA"] = 770] = "SRC_ALPHA";
	/** Passed to blendFunc or blendFuncSeparate to multiply a component by one minus the source's alpha. */
	GLEnum$1[GLEnum$1["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
	/** Passed to blendFunc or blendFuncSeparate to multiply a component by the destination's alpha. */
	GLEnum$1[GLEnum$1["DST_ALPHA"] = 772] = "DST_ALPHA";
	/** Passed to blendFunc or blendFuncSeparate to multiply a component by one minus the destination's alpha. */
	GLEnum$1[GLEnum$1["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
	/** Passed to blendFunc or blendFuncSeparate to multiply a component by the destination's color. */
	GLEnum$1[GLEnum$1["DST_COLOR"] = 774] = "DST_COLOR";
	/** Passed to blendFunc or blendFuncSeparate to multiply a component by one minus the destination's color. */
	GLEnum$1[GLEnum$1["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
	/** Passed to blendFunc or blendFuncSeparate to multiply a component by the minimum of source's alpha or one minus the destination's alpha. */
	GLEnum$1[GLEnum$1["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
	/** Passed to blendFunc or blendFuncSeparate to specify a constant color blend function. */
	GLEnum$1[GLEnum$1["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
	/** Passed to blendFunc or blendFuncSeparate to specify one minus a constant color blend function. */
	GLEnum$1[GLEnum$1["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
	/** Passed to blendFunc or blendFuncSeparate to specify a constant alpha blend function. */
	GLEnum$1[GLEnum$1["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
	/** Passed to blendFunc or blendFuncSeparate to specify one minus a constant alpha blend function. */
	GLEnum$1[GLEnum$1["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
	/** Passed to blendEquation or blendEquationSeparate to set an addition blend function. */
	/** Passed to blendEquation or blendEquationSeparate to specify a subtraction blend function (source - destination). */
	/** Passed to blendEquation or blendEquationSeparate to specify a reverse subtraction blend function (destination - source). */
	GLEnum$1[GLEnum$1["FUNC_ADD"] = 32774] = "FUNC_ADD";
	GLEnum$1[GLEnum$1["FUNC_SUBTRACT"] = 32778] = "FUNC_SUBTRACT";
	GLEnum$1[GLEnum$1["FUNC_REVERSE_SUBTRACT"] = 32779] = "FUNC_REVERSE_SUBTRACT";
	/** Passed to getParameter to get the current RGB blend function. */
	GLEnum$1[GLEnum$1["BLEND_EQUATION"] = 32777] = "BLEND_EQUATION";
	/** Passed to getParameter to get the current RGB blend function. Same as BLEND_EQUATION */
	GLEnum$1[GLEnum$1["BLEND_EQUATION_RGB"] = 32777] = "BLEND_EQUATION_RGB";
	/** Passed to getParameter to get the current alpha blend function. Same as BLEND_EQUATION */
	GLEnum$1[GLEnum$1["BLEND_EQUATION_ALPHA"] = 34877] = "BLEND_EQUATION_ALPHA";
	/** Passed to getParameter to get the current destination RGB blend function. */
	GLEnum$1[GLEnum$1["BLEND_DST_RGB"] = 32968] = "BLEND_DST_RGB";
	/** Passed to getParameter to get the current destination RGB blend function. */
	GLEnum$1[GLEnum$1["BLEND_SRC_RGB"] = 32969] = "BLEND_SRC_RGB";
	/** Passed to getParameter to get the current destination alpha blend function. */
	GLEnum$1[GLEnum$1["BLEND_DST_ALPHA"] = 32970] = "BLEND_DST_ALPHA";
	/** Passed to getParameter to get the current source alpha blend function. */
	GLEnum$1[GLEnum$1["BLEND_SRC_ALPHA"] = 32971] = "BLEND_SRC_ALPHA";
	/** Passed to getParameter to return a the current blend color. */
	GLEnum$1[GLEnum$1["BLEND_COLOR"] = 32773] = "BLEND_COLOR";
	/** Passed to getParameter to get the array buffer binding. */
	GLEnum$1[GLEnum$1["ARRAY_BUFFER_BINDING"] = 34964] = "ARRAY_BUFFER_BINDING";
	/** Passed to getParameter to get the current element array buffer. */
	GLEnum$1[GLEnum$1["ELEMENT_ARRAY_BUFFER_BINDING"] = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING";
	/** Passed to getParameter to get the current lineWidth (set by the lineWidth method). */
	GLEnum$1[GLEnum$1["LINE_WIDTH"] = 2849] = "LINE_WIDTH";
	/** Passed to getParameter to get the current size of a point drawn with gl.POINTS */
	GLEnum$1[GLEnum$1["ALIASED_POINT_SIZE_RANGE"] = 33901] = "ALIASED_POINT_SIZE_RANGE";
	/** Passed to getParameter to get the range of available widths for a line. Returns a length-2 array with the lo value at 0, and hight at 1. */
	GLEnum$1[GLEnum$1["ALIASED_LINE_WIDTH_RANGE"] = 33902] = "ALIASED_LINE_WIDTH_RANGE";
	/** Passed to getParameter to get the current value of cullFace. Should return FRONT, BACK, or FRONT_AND_BACK */
	GLEnum$1[GLEnum$1["CULL_FACE_MODE"] = 2885] = "CULL_FACE_MODE";
	/** Passed to getParameter to determine the current value of frontFace. Should return CW or CCW. */
	GLEnum$1[GLEnum$1["FRONT_FACE"] = 2886] = "FRONT_FACE";
	/** Passed to getParameter to return a length-2 array of floats giving the current depth range. */
	GLEnum$1[GLEnum$1["DEPTH_RANGE"] = 2928] = "DEPTH_RANGE";
	/** Passed to getParameter to determine if the depth write mask is enabled. */
	GLEnum$1[GLEnum$1["DEPTH_WRITEMASK"] = 2930] = "DEPTH_WRITEMASK";
	/** Passed to getParameter to determine the current depth clear value. */
	GLEnum$1[GLEnum$1["DEPTH_CLEAR_VALUE"] = 2931] = "DEPTH_CLEAR_VALUE";
	/** Passed to getParameter to get the current depth function. Returns NEVER, ALWAYS, LESS, EQUAL, LEQUAL, GREATER, GEQUAL, or NOTEQUAL. */
	GLEnum$1[GLEnum$1["DEPTH_FUNC"] = 2932] = "DEPTH_FUNC";
	/** Passed to getParameter to get the value the stencil will be cleared to. */
	GLEnum$1[GLEnum$1["STENCIL_CLEAR_VALUE"] = 2961] = "STENCIL_CLEAR_VALUE";
	/** Passed to getParameter to get the current stencil function. Returns NEVER, ALWAYS, LESS, EQUAL, LEQUAL, GREATER, GEQUAL, or NOTEQUAL. */
	GLEnum$1[GLEnum$1["STENCIL_FUNC"] = 2962] = "STENCIL_FUNC";
	/** Passed to getParameter to get the current stencil fail function. Should return KEEP, REPLACE, INCR, DECR, INVERT, INCR_WRAP, or DECR_WRAP. */
	GLEnum$1[GLEnum$1["STENCIL_FAIL"] = 2964] = "STENCIL_FAIL";
	/** Passed to getParameter to get the current stencil fail function should the depth buffer test fail. Should return KEEP, REPLACE, INCR, DECR, INVERT, INCR_WRAP, or DECR_WRAP. */
	GLEnum$1[GLEnum$1["STENCIL_PASS_DEPTH_FAIL"] = 2965] = "STENCIL_PASS_DEPTH_FAIL";
	/** Passed to getParameter to get the current stencil fail function should the depth buffer test pass. Should return KEEP, REPLACE, INCR, DECR, INVERT, INCR_WRAP, or DECR_WRAP. */
	GLEnum$1[GLEnum$1["STENCIL_PASS_DEPTH_PASS"] = 2966] = "STENCIL_PASS_DEPTH_PASS";
	/** Passed to getParameter to get the reference value used for stencil tests. */
	GLEnum$1[GLEnum$1["STENCIL_REF"] = 2967] = "STENCIL_REF";
	GLEnum$1[GLEnum$1["STENCIL_VALUE_MASK"] = 2963] = "STENCIL_VALUE_MASK";
	GLEnum$1[GLEnum$1["STENCIL_WRITEMASK"] = 2968] = "STENCIL_WRITEMASK";
	GLEnum$1[GLEnum$1["STENCIL_BACK_FUNC"] = 34816] = "STENCIL_BACK_FUNC";
	GLEnum$1[GLEnum$1["STENCIL_BACK_FAIL"] = 34817] = "STENCIL_BACK_FAIL";
	GLEnum$1[GLEnum$1["STENCIL_BACK_PASS_DEPTH_FAIL"] = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL";
	GLEnum$1[GLEnum$1["STENCIL_BACK_PASS_DEPTH_PASS"] = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS";
	GLEnum$1[GLEnum$1["STENCIL_BACK_REF"] = 36003] = "STENCIL_BACK_REF";
	GLEnum$1[GLEnum$1["STENCIL_BACK_VALUE_MASK"] = 36004] = "STENCIL_BACK_VALUE_MASK";
	GLEnum$1[GLEnum$1["STENCIL_BACK_WRITEMASK"] = 36005] = "STENCIL_BACK_WRITEMASK";
	/** An Int32Array with four elements for the current viewport dimensions. */
	GLEnum$1[GLEnum$1["VIEWPORT"] = 2978] = "VIEWPORT";
	/** An Int32Array with four elements for the current scissor box dimensions. */
	GLEnum$1[GLEnum$1["SCISSOR_BOX"] = 3088] = "SCISSOR_BOX";
	GLEnum$1[GLEnum$1["COLOR_CLEAR_VALUE"] = 3106] = "COLOR_CLEAR_VALUE";
	GLEnum$1[GLEnum$1["COLOR_WRITEMASK"] = 3107] = "COLOR_WRITEMASK";
	GLEnum$1[GLEnum$1["UNPACK_ALIGNMENT"] = 3317] = "UNPACK_ALIGNMENT";
	GLEnum$1[GLEnum$1["PACK_ALIGNMENT"] = 3333] = "PACK_ALIGNMENT";
	GLEnum$1[GLEnum$1["MAX_TEXTURE_SIZE"] = 3379] = "MAX_TEXTURE_SIZE";
	GLEnum$1[GLEnum$1["MAX_VIEWPORT_DIMS"] = 3386] = "MAX_VIEWPORT_DIMS";
	GLEnum$1[GLEnum$1["SUBPIXEL_BITS"] = 3408] = "SUBPIXEL_BITS";
	GLEnum$1[GLEnum$1["RED_BITS"] = 3410] = "RED_BITS";
	GLEnum$1[GLEnum$1["GREEN_BITS"] = 3411] = "GREEN_BITS";
	GLEnum$1[GLEnum$1["BLUE_BITS"] = 3412] = "BLUE_BITS";
	GLEnum$1[GLEnum$1["ALPHA_BITS"] = 3413] = "ALPHA_BITS";
	GLEnum$1[GLEnum$1["DEPTH_BITS"] = 3414] = "DEPTH_BITS";
	GLEnum$1[GLEnum$1["STENCIL_BITS"] = 3415] = "STENCIL_BITS";
	GLEnum$1[GLEnum$1["POLYGON_OFFSET_UNITS"] = 10752] = "POLYGON_OFFSET_UNITS";
	GLEnum$1[GLEnum$1["POLYGON_OFFSET_FACTOR"] = 32824] = "POLYGON_OFFSET_FACTOR";
	GLEnum$1[GLEnum$1["TEXTURE_BINDING_2D"] = 32873] = "TEXTURE_BINDING_2D";
	GLEnum$1[GLEnum$1["SAMPLE_BUFFERS"] = 32936] = "SAMPLE_BUFFERS";
	GLEnum$1[GLEnum$1["SAMPLES"] = 32937] = "SAMPLES";
	GLEnum$1[GLEnum$1["SAMPLE_COVERAGE_VALUE"] = 32938] = "SAMPLE_COVERAGE_VALUE";
	GLEnum$1[GLEnum$1["SAMPLE_COVERAGE_INVERT"] = 32939] = "SAMPLE_COVERAGE_INVERT";
	GLEnum$1[GLEnum$1["COMPRESSED_TEXTURE_FORMATS"] = 34467] = "COMPRESSED_TEXTURE_FORMATS";
	GLEnum$1[GLEnum$1["VENDOR"] = 7936] = "VENDOR";
	GLEnum$1[GLEnum$1["RENDERER"] = 7937] = "RENDERER";
	GLEnum$1[GLEnum$1["VERSION"] = 7938] = "VERSION";
	GLEnum$1[GLEnum$1["IMPLEMENTATION_COLOR_READ_TYPE"] = 35738] = "IMPLEMENTATION_COLOR_READ_TYPE";
	GLEnum$1[GLEnum$1["IMPLEMENTATION_COLOR_READ_FORMAT"] = 35739] = "IMPLEMENTATION_COLOR_READ_FORMAT";
	GLEnum$1[GLEnum$1["BROWSER_DEFAULT_WEBGL"] = 37444] = "BROWSER_DEFAULT_WEBGL";
	/** Passed to bufferData as a hint about whether the contents of the buffer are likely to be used often and not change often. */
	GLEnum$1[GLEnum$1["STATIC_DRAW"] = 35044] = "STATIC_DRAW";
	/** Passed to bufferData as a hint about whether the contents of the buffer are likely to not be used often. */
	GLEnum$1[GLEnum$1["STREAM_DRAW"] = 35040] = "STREAM_DRAW";
	/** Passed to bufferData as a hint about whether the contents of the buffer are likely to be used often and change often. */
	GLEnum$1[GLEnum$1["DYNAMIC_DRAW"] = 35048] = "DYNAMIC_DRAW";
	/** Passed to bindBuffer or bufferData to specify the type of buffer being used. */
	GLEnum$1[GLEnum$1["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
	/** Passed to bindBuffer or bufferData to specify the type of buffer being used. */
	GLEnum$1[GLEnum$1["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
	/** Passed to getBufferParameter to get a buffer's size. */
	GLEnum$1[GLEnum$1["BUFFER_SIZE"] = 34660] = "BUFFER_SIZE";
	/** Passed to getBufferParameter to get the hint for the buffer passed in when it was created. */
	GLEnum$1[GLEnum$1["BUFFER_USAGE"] = 34661] = "BUFFER_USAGE";
	/** Passed to getVertexAttrib to read back the current vertex attribute. */
	GLEnum$1[GLEnum$1["CURRENT_VERTEX_ATTRIB"] = 34342] = "CURRENT_VERTEX_ATTRIB";
	GLEnum$1[GLEnum$1["VERTEX_ATTRIB_ARRAY_ENABLED"] = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED";
	GLEnum$1[GLEnum$1["VERTEX_ATTRIB_ARRAY_SIZE"] = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE";
	GLEnum$1[GLEnum$1["VERTEX_ATTRIB_ARRAY_STRIDE"] = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE";
	GLEnum$1[GLEnum$1["VERTEX_ATTRIB_ARRAY_TYPE"] = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE";
	GLEnum$1[GLEnum$1["VERTEX_ATTRIB_ARRAY_NORMALIZED"] = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED";
	GLEnum$1[GLEnum$1["VERTEX_ATTRIB_ARRAY_POINTER"] = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER";
	GLEnum$1[GLEnum$1["VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"] = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING";
	/** Passed to enable/disable to turn on/off culling. Can also be used with getParameter to find the current culling method. */
	GLEnum$1[GLEnum$1["CULL_FACE"] = 2884] = "CULL_FACE";
	/** Passed to cullFace to specify that only front faces should be culled. */
	GLEnum$1[GLEnum$1["FRONT"] = 1028] = "FRONT";
	/** Passed to cullFace to specify that only back faces should be culled. */
	GLEnum$1[GLEnum$1["BACK"] = 1029] = "BACK";
	/** Passed to cullFace to specify that front and back faces should be culled. */
	GLEnum$1[GLEnum$1["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
	/** Passed to enable/disable to turn on/off blending. Can also be used with getParameter to find the current blending method. */
	GLEnum$1[GLEnum$1["BLEND"] = 3042] = "BLEND";
	/** Passed to enable/disable to turn on/off the depth test. Can also be used with getParameter to query the depth test. */
	GLEnum$1[GLEnum$1["DEPTH_TEST"] = 2929] = "DEPTH_TEST";
	/** Passed to enable/disable to turn on/off dithering. Can also be used with getParameter to find the current dithering method. */
	GLEnum$1[GLEnum$1["DITHER"] = 3024] = "DITHER";
	/** Passed to enable/disable to turn on/off the polygon offset. Useful for rendering hidden-line images, decals, and or solids with highlighted edges. Can also be used with getParameter to query the scissor test. */
	GLEnum$1[GLEnum$1["POLYGON_OFFSET_FILL"] = 32823] = "POLYGON_OFFSET_FILL";
	/** Passed to enable/disable to turn on/off the alpha to coverage. Used in multi-sampling alpha channels. */
	GLEnum$1[GLEnum$1["SAMPLE_ALPHA_TO_COVERAGE"] = 32926] = "SAMPLE_ALPHA_TO_COVERAGE";
	/** Passed to enable/disable to turn on/off the sample coverage. Used in multi-sampling. */
	GLEnum$1[GLEnum$1["SAMPLE_COVERAGE"] = 32928] = "SAMPLE_COVERAGE";
	/** Passed to enable/disable to turn on/off the scissor test. Can also be used with getParameter to query the scissor test. */
	GLEnum$1[GLEnum$1["SCISSOR_TEST"] = 3089] = "SCISSOR_TEST";
	/** Passed to enable/disable to turn on/off the stencil test. Can also be used with getParameter to query the stencil test. */
	GLEnum$1[GLEnum$1["STENCIL_TEST"] = 2960] = "STENCIL_TEST";
	/** Returned from getError(). */
	GLEnum$1[GLEnum$1["NO_ERROR"] = 0] = "NO_ERROR";
	/** Returned from getError(). */
	GLEnum$1[GLEnum$1["INVALID_ENUM"] = 1280] = "INVALID_ENUM";
	/** Returned from getError(). */
	GLEnum$1[GLEnum$1["INVALID_VALUE"] = 1281] = "INVALID_VALUE";
	/** Returned from getError(). */
	GLEnum$1[GLEnum$1["INVALID_OPERATION"] = 1282] = "INVALID_OPERATION";
	/** Returned from getError(). */
	GLEnum$1[GLEnum$1["OUT_OF_MEMORY"] = 1285] = "OUT_OF_MEMORY";
	/** Returned from getError(). */
	GLEnum$1[GLEnum$1["CONTEXT_LOST_WEBGL"] = 37442] = "CONTEXT_LOST_WEBGL";
	/** Passed to frontFace to specify the front face of a polygon is drawn in the clockwise direction */
	GLEnum$1[GLEnum$1["CW"] = 2304] = "CW";
	/** Passed to frontFace to specify the front face of a polygon is drawn in the counter clockwise direction */
	GLEnum$1[GLEnum$1["CCW"] = 2305] = "CCW";
	/** There is no preference for this behavior. */
	GLEnum$1[GLEnum$1["DONT_CARE"] = 4352] = "DONT_CARE";
	/** The most efficient behavior should be used. */
	GLEnum$1[GLEnum$1["FASTEST"] = 4353] = "FASTEST";
	/** The most correct or the highest quality option should be used. */
	GLEnum$1[GLEnum$1["NICEST"] = 4354] = "NICEST";
	/** Hint for the quality of filtering when generating mipmap images with WebGLRenderingContext.generateMipmap(). */
	GLEnum$1[GLEnum$1["GENERATE_MIPMAP_HINT"] = 33170] = "GENERATE_MIPMAP_HINT";
	GLEnum$1[GLEnum$1["BYTE"] = 5120] = "BYTE";
	GLEnum$1[GLEnum$1["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
	GLEnum$1[GLEnum$1["SHORT"] = 5122] = "SHORT";
	GLEnum$1[GLEnum$1["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
	GLEnum$1[GLEnum$1["INT"] = 5124] = "INT";
	GLEnum$1[GLEnum$1["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
	GLEnum$1[GLEnum$1["FLOAT"] = 5126] = "FLOAT";
	GLEnum$1[GLEnum$1["DOUBLE"] = 5130] = "DOUBLE";
	GLEnum$1[GLEnum$1["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
	GLEnum$1[GLEnum$1["ALPHA"] = 6406] = "ALPHA";
	GLEnum$1[GLEnum$1["RGB"] = 6407] = "RGB";
	GLEnum$1[GLEnum$1["RGBA"] = 6408] = "RGBA";
	GLEnum$1[GLEnum$1["LUMINANCE"] = 6409] = "LUMINANCE";
	GLEnum$1[GLEnum$1["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
	GLEnum$1[GLEnum$1["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
	GLEnum$1[GLEnum$1["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
	GLEnum$1[GLEnum$1["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
	/** Passed to createShader to define a fragment shader. */
	GLEnum$1[GLEnum$1["FRAGMENT_SHADER"] = 35632] = "FRAGMENT_SHADER";
	/** Passed to createShader to define a vertex shader */
	GLEnum$1[GLEnum$1["VERTEX_SHADER"] = 35633] = "VERTEX_SHADER";
	/** Passed to getShaderParameter to get the status of the compilation. Returns false if the shader was not compiled. You can then query getShaderInfoLog to find the exact error */
	GLEnum$1[GLEnum$1["COMPILE_STATUS"] = 35713] = "COMPILE_STATUS";
	/** Passed to getShaderParameter to determine if a shader was deleted via deleteShader. Returns true if it was, false otherwise. */
	GLEnum$1[GLEnum$1["DELETE_STATUS"] = 35712] = "DELETE_STATUS";
	/** Passed to getProgramParameter after calling linkProgram to determine if a program was linked correctly. Returns false if there were errors. Use getProgramInfoLog to find the exact error. */
	GLEnum$1[GLEnum$1["LINK_STATUS"] = 35714] = "LINK_STATUS";
	/** Passed to getProgramParameter after calling validateProgram to determine if it is valid. Returns false if errors were found. */
	GLEnum$1[GLEnum$1["VALIDATE_STATUS"] = 35715] = "VALIDATE_STATUS";
	/** Passed to getProgramParameter after calling attachShader to determine if the shader was attached correctly. Returns false if errors occurred. */
	GLEnum$1[GLEnum$1["ATTACHED_SHADERS"] = 35717] = "ATTACHED_SHADERS";
	/** Passed to getProgramParameter to get the number of attributes active in a program. */
	GLEnum$1[GLEnum$1["ACTIVE_ATTRIBUTES"] = 35721] = "ACTIVE_ATTRIBUTES";
	/** Passed to getProgramParameter to get the number of uniforms active in a program. */
	GLEnum$1[GLEnum$1["ACTIVE_UNIFORMS"] = 35718] = "ACTIVE_UNIFORMS";
	/** The maximum number of entries possible in the vertex attribute list. */
	GLEnum$1[GLEnum$1["MAX_VERTEX_ATTRIBS"] = 34921] = "MAX_VERTEX_ATTRIBS";
	GLEnum$1[GLEnum$1["MAX_VERTEX_UNIFORM_VECTORS"] = 36347] = "MAX_VERTEX_UNIFORM_VECTORS";
	GLEnum$1[GLEnum$1["MAX_VARYING_VECTORS"] = 36348] = "MAX_VARYING_VECTORS";
	GLEnum$1[GLEnum$1["MAX_COMBINED_TEXTURE_IMAGE_UNITS"] = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS";
	GLEnum$1[GLEnum$1["MAX_VERTEX_TEXTURE_IMAGE_UNITS"] = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS";
	/** Implementation dependent number of maximum texture units. At least 8. */
	GLEnum$1[GLEnum$1["MAX_TEXTURE_IMAGE_UNITS"] = 34930] = "MAX_TEXTURE_IMAGE_UNITS";
	GLEnum$1[GLEnum$1["MAX_FRAGMENT_UNIFORM_VECTORS"] = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS";
	GLEnum$1[GLEnum$1["SHADER_TYPE"] = 35663] = "SHADER_TYPE";
	GLEnum$1[GLEnum$1["SHADING_LANGUAGE_VERSION"] = 35724] = "SHADING_LANGUAGE_VERSION";
	GLEnum$1[GLEnum$1["CURRENT_PROGRAM"] = 35725] = "CURRENT_PROGRAM";
	/** Passed to depthFunction or stencilFunction to specify depth or stencil tests will never pass, i.e., nothing will be drawn. */
	GLEnum$1[GLEnum$1["NEVER"] = 512] = "NEVER";
	/** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than the stored value. */
	GLEnum$1[GLEnum$1["LESS"] = 513] = "LESS";
	/** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is equals to the stored value. */
	GLEnum$1[GLEnum$1["EQUAL"] = 514] = "EQUAL";
	/** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than or equal to the stored value. */
	GLEnum$1[GLEnum$1["LEQUAL"] = 515] = "LEQUAL";
	/** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than the stored value. */
	GLEnum$1[GLEnum$1["GREATER"] = 516] = "GREATER";
	/** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is not equal to the stored value. */
	GLEnum$1[GLEnum$1["NOTEQUAL"] = 517] = "NOTEQUAL";
	/** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than or equal to the stored value. */
	GLEnum$1[GLEnum$1["GEQUAL"] = 518] = "GEQUAL";
	/** Passed to depthFunction or stencilFunction to specify depth or stencil tests will always pass, i.e., pixels will be drawn in the order they are drawn. */
	GLEnum$1[GLEnum$1["ALWAYS"] = 519] = "ALWAYS";
	GLEnum$1[GLEnum$1["KEEP"] = 7680] = "KEEP";
	GLEnum$1[GLEnum$1["REPLACE"] = 7681] = "REPLACE";
	GLEnum$1[GLEnum$1["INCR"] = 7682] = "INCR";
	GLEnum$1[GLEnum$1["DECR"] = 7683] = "DECR";
	GLEnum$1[GLEnum$1["INVERT"] = 5386] = "INVERT";
	GLEnum$1[GLEnum$1["INCR_WRAP"] = 34055] = "INCR_WRAP";
	GLEnum$1[GLEnum$1["DECR_WRAP"] = 34056] = "DECR_WRAP";
	GLEnum$1[GLEnum$1["NEAREST"] = 9728] = "NEAREST";
	GLEnum$1[GLEnum$1["LINEAR"] = 9729] = "LINEAR";
	GLEnum$1[GLEnum$1["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
	GLEnum$1[GLEnum$1["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
	GLEnum$1[GLEnum$1["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
	GLEnum$1[GLEnum$1["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
	/** The texture magnification function is used when the pixel being textured maps to an area less than or equal to one texture element. It sets the texture magnification function to either GL_NEAREST or GL_LINEAR (see below). GL_NEAREST is generally faster than GL_LINEAR, but it can produce textured images with sharper edges because the transition between texture elements is not as smooth. Default: GL_LINEAR.  */
	GLEnum$1[GLEnum$1["TEXTURE_MAG_FILTER"] = 10240] = "TEXTURE_MAG_FILTER";
	/** The texture minifying function is used whenever the pixel being textured maps to an area greater than one texture element. There are six defined minifying functions. Two of them use the nearest one or nearest four texture elements to compute the texture value. The other four use mipmaps. Default: GL_NEAREST_MIPMAP_LINEAR */
	GLEnum$1[GLEnum$1["TEXTURE_MIN_FILTER"] = 10241] = "TEXTURE_MIN_FILTER";
	/** Sets the wrap parameter for texture coordinate  to either GL_CLAMP_TO_EDGE, GL_MIRRORED_REPEAT, or GL_REPEAT. G */
	GLEnum$1[GLEnum$1["TEXTURE_WRAP_S"] = 10242] = "TEXTURE_WRAP_S";
	/** Sets the wrap parameter for texture coordinate  to either GL_CLAMP_TO_EDGE, GL_MIRRORED_REPEAT, or GL_REPEAT. G */
	GLEnum$1[GLEnum$1["TEXTURE_WRAP_T"] = 10243] = "TEXTURE_WRAP_T";
	GLEnum$1[GLEnum$1["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
	GLEnum$1[GLEnum$1["TEXTURE"] = 5890] = "TEXTURE";
	GLEnum$1[GLEnum$1["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
	GLEnum$1[GLEnum$1["TEXTURE_BINDING_CUBE_MAP"] = 34068] = "TEXTURE_BINDING_CUBE_MAP";
	GLEnum$1[GLEnum$1["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
	GLEnum$1[GLEnum$1["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
	GLEnum$1[GLEnum$1["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
	GLEnum$1[GLEnum$1["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
	GLEnum$1[GLEnum$1["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
	GLEnum$1[GLEnum$1["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
	GLEnum$1[GLEnum$1["MAX_CUBE_MAP_TEXTURE_SIZE"] = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE";
	GLEnum$1[GLEnum$1["TEXTURE0"] = 33984] = "TEXTURE0";
	GLEnum$1[GLEnum$1["ACTIVE_TEXTURE"] = 34016] = "ACTIVE_TEXTURE";
	GLEnum$1[GLEnum$1["REPEAT"] = 10497] = "REPEAT";
	GLEnum$1[GLEnum$1["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
	GLEnum$1[GLEnum$1["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
	GLEnum$1[GLEnum$1["TEXTURE_WIDTH"] = 4096] = "TEXTURE_WIDTH";
	GLEnum$1[GLEnum$1["TEXTURE_HEIGHT"] = 4097] = "TEXTURE_HEIGHT";
	GLEnum$1[GLEnum$1["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
	GLEnum$1[GLEnum$1["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
	GLEnum$1[GLEnum$1["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
	GLEnum$1[GLEnum$1["INT_VEC2"] = 35667] = "INT_VEC2";
	GLEnum$1[GLEnum$1["INT_VEC3"] = 35668] = "INT_VEC3";
	GLEnum$1[GLEnum$1["INT_VEC4"] = 35669] = "INT_VEC4";
	GLEnum$1[GLEnum$1["BOOL"] = 35670] = "BOOL";
	GLEnum$1[GLEnum$1["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
	GLEnum$1[GLEnum$1["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
	GLEnum$1[GLEnum$1["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
	GLEnum$1[GLEnum$1["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
	GLEnum$1[GLEnum$1["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
	GLEnum$1[GLEnum$1["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
	GLEnum$1[GLEnum$1["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
	GLEnum$1[GLEnum$1["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
	GLEnum$1[GLEnum$1["LOW_FLOAT"] = 36336] = "LOW_FLOAT";
	GLEnum$1[GLEnum$1["MEDIUM_FLOAT"] = 36337] = "MEDIUM_FLOAT";
	GLEnum$1[GLEnum$1["HIGH_FLOAT"] = 36338] = "HIGH_FLOAT";
	GLEnum$1[GLEnum$1["LOW_INT"] = 36339] = "LOW_INT";
	GLEnum$1[GLEnum$1["MEDIUM_INT"] = 36340] = "MEDIUM_INT";
	GLEnum$1[GLEnum$1["HIGH_INT"] = 36341] = "HIGH_INT";
	GLEnum$1[GLEnum$1["FRAMEBUFFER"] = 36160] = "FRAMEBUFFER";
	GLEnum$1[GLEnum$1["RENDERBUFFER"] = 36161] = "RENDERBUFFER";
	GLEnum$1[GLEnum$1["RGBA4"] = 32854] = "RGBA4";
	GLEnum$1[GLEnum$1["RGB5_A1"] = 32855] = "RGB5_A1";
	GLEnum$1[GLEnum$1["RGB565"] = 36194] = "RGB565";
	GLEnum$1[GLEnum$1["DEPTH_COMPONENT16"] = 33189] = "DEPTH_COMPONENT16";
	GLEnum$1[GLEnum$1["STENCIL_INDEX"] = 6401] = "STENCIL_INDEX";
	GLEnum$1[GLEnum$1["STENCIL_INDEX8"] = 36168] = "STENCIL_INDEX8";
	GLEnum$1[GLEnum$1["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
	GLEnum$1[GLEnum$1["RENDERBUFFER_WIDTH"] = 36162] = "RENDERBUFFER_WIDTH";
	GLEnum$1[GLEnum$1["RENDERBUFFER_HEIGHT"] = 36163] = "RENDERBUFFER_HEIGHT";
	GLEnum$1[GLEnum$1["RENDERBUFFER_INTERNAL_FORMAT"] = 36164] = "RENDERBUFFER_INTERNAL_FORMAT";
	GLEnum$1[GLEnum$1["RENDERBUFFER_RED_SIZE"] = 36176] = "RENDERBUFFER_RED_SIZE";
	GLEnum$1[GLEnum$1["RENDERBUFFER_GREEN_SIZE"] = 36177] = "RENDERBUFFER_GREEN_SIZE";
	GLEnum$1[GLEnum$1["RENDERBUFFER_BLUE_SIZE"] = 36178] = "RENDERBUFFER_BLUE_SIZE";
	GLEnum$1[GLEnum$1["RENDERBUFFER_ALPHA_SIZE"] = 36179] = "RENDERBUFFER_ALPHA_SIZE";
	GLEnum$1[GLEnum$1["RENDERBUFFER_DEPTH_SIZE"] = 36180] = "RENDERBUFFER_DEPTH_SIZE";
	GLEnum$1[GLEnum$1["RENDERBUFFER_STENCIL_SIZE"] = 36181] = "RENDERBUFFER_STENCIL_SIZE";
	GLEnum$1[GLEnum$1["FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"] = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE";
	GLEnum$1[GLEnum$1["FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"] = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME";
	GLEnum$1[GLEnum$1["FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"] = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL";
	GLEnum$1[GLEnum$1["FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"] = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE";
	GLEnum$1[GLEnum$1["COLOR_ATTACHMENT0"] = 36064] = "COLOR_ATTACHMENT0";
	GLEnum$1[GLEnum$1["DEPTH_ATTACHMENT"] = 36096] = "DEPTH_ATTACHMENT";
	GLEnum$1[GLEnum$1["STENCIL_ATTACHMENT"] = 36128] = "STENCIL_ATTACHMENT";
	GLEnum$1[GLEnum$1["DEPTH_STENCIL_ATTACHMENT"] = 33306] = "DEPTH_STENCIL_ATTACHMENT";
	GLEnum$1[GLEnum$1["NONE"] = 0] = "NONE";
	GLEnum$1[GLEnum$1["FRAMEBUFFER_COMPLETE"] = 36053] = "FRAMEBUFFER_COMPLETE";
	GLEnum$1[GLEnum$1["FRAMEBUFFER_INCOMPLETE_ATTACHMENT"] = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
	GLEnum$1[GLEnum$1["FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"] = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
	GLEnum$1[GLEnum$1["FRAMEBUFFER_INCOMPLETE_DIMENSIONS"] = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
	GLEnum$1[GLEnum$1["FRAMEBUFFER_UNSUPPORTED"] = 36061] = "FRAMEBUFFER_UNSUPPORTED";
	GLEnum$1[GLEnum$1["FRAMEBUFFER_BINDING"] = 36006] = "FRAMEBUFFER_BINDING";
	GLEnum$1[GLEnum$1["RENDERBUFFER_BINDING"] = 36007] = "RENDERBUFFER_BINDING";
	GLEnum$1[GLEnum$1["READ_FRAMEBUFFER"] = 36008] = "READ_FRAMEBUFFER";
	GLEnum$1[GLEnum$1["DRAW_FRAMEBUFFER"] = 36009] = "DRAW_FRAMEBUFFER";
	GLEnum$1[GLEnum$1["MAX_RENDERBUFFER_SIZE"] = 34024] = "MAX_RENDERBUFFER_SIZE";
	GLEnum$1[GLEnum$1["INVALID_FRAMEBUFFER_OPERATION"] = 1286] = "INVALID_FRAMEBUFFER_OPERATION";
	GLEnum$1[GLEnum$1["UNPACK_FLIP_Y_WEBGL"] = 37440] = "UNPACK_FLIP_Y_WEBGL";
	GLEnum$1[GLEnum$1["UNPACK_PREMULTIPLY_ALPHA_WEBGL"] = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL";
	GLEnum$1[GLEnum$1["UNPACK_COLORSPACE_CONVERSION_WEBGL"] = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL";
	GLEnum$1[GLEnum$1["READ_BUFFER"] = 3074] = "READ_BUFFER";
	GLEnum$1[GLEnum$1["UNPACK_ROW_LENGTH"] = 3314] = "UNPACK_ROW_LENGTH";
	GLEnum$1[GLEnum$1["UNPACK_SKIP_ROWS"] = 3315] = "UNPACK_SKIP_ROWS";
	GLEnum$1[GLEnum$1["UNPACK_SKIP_PIXELS"] = 3316] = "UNPACK_SKIP_PIXELS";
	GLEnum$1[GLEnum$1["PACK_ROW_LENGTH"] = 3330] = "PACK_ROW_LENGTH";
	GLEnum$1[GLEnum$1["PACK_SKIP_ROWS"] = 3331] = "PACK_SKIP_ROWS";
	GLEnum$1[GLEnum$1["PACK_SKIP_PIXELS"] = 3332] = "PACK_SKIP_PIXELS";
	GLEnum$1[GLEnum$1["TEXTURE_BINDING_3D"] = 32874] = "TEXTURE_BINDING_3D";
	GLEnum$1[GLEnum$1["UNPACK_SKIP_IMAGES"] = 32877] = "UNPACK_SKIP_IMAGES";
	GLEnum$1[GLEnum$1["UNPACK_IMAGE_HEIGHT"] = 32878] = "UNPACK_IMAGE_HEIGHT";
	GLEnum$1[GLEnum$1["MAX_3D_TEXTURE_SIZE"] = 32883] = "MAX_3D_TEXTURE_SIZE";
	GLEnum$1[GLEnum$1["MAX_ELEMENTS_VERTICES"] = 33e3] = "MAX_ELEMENTS_VERTICES";
	GLEnum$1[GLEnum$1["MAX_ELEMENTS_INDICES"] = 33001] = "MAX_ELEMENTS_INDICES";
	GLEnum$1[GLEnum$1["MAX_TEXTURE_LOD_BIAS"] = 34045] = "MAX_TEXTURE_LOD_BIAS";
	GLEnum$1[GLEnum$1["MAX_FRAGMENT_UNIFORM_COMPONENTS"] = 35657] = "MAX_FRAGMENT_UNIFORM_COMPONENTS";
	GLEnum$1[GLEnum$1["MAX_VERTEX_UNIFORM_COMPONENTS"] = 35658] = "MAX_VERTEX_UNIFORM_COMPONENTS";
	GLEnum$1[GLEnum$1["MAX_ARRAY_TEXTURE_LAYERS"] = 35071] = "MAX_ARRAY_TEXTURE_LAYERS";
	GLEnum$1[GLEnum$1["MIN_PROGRAM_TEXEL_OFFSET"] = 35076] = "MIN_PROGRAM_TEXEL_OFFSET";
	GLEnum$1[GLEnum$1["MAX_PROGRAM_TEXEL_OFFSET"] = 35077] = "MAX_PROGRAM_TEXEL_OFFSET";
	GLEnum$1[GLEnum$1["MAX_VARYING_COMPONENTS"] = 35659] = "MAX_VARYING_COMPONENTS";
	GLEnum$1[GLEnum$1["FRAGMENT_SHADER_DERIVATIVE_HINT"] = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT";
	GLEnum$1[GLEnum$1["RASTERIZER_DISCARD"] = 35977] = "RASTERIZER_DISCARD";
	GLEnum$1[GLEnum$1["VERTEX_ARRAY_BINDING"] = 34229] = "VERTEX_ARRAY_BINDING";
	GLEnum$1[GLEnum$1["MAX_VERTEX_OUTPUT_COMPONENTS"] = 37154] = "MAX_VERTEX_OUTPUT_COMPONENTS";
	GLEnum$1[GLEnum$1["MAX_FRAGMENT_INPUT_COMPONENTS"] = 37157] = "MAX_FRAGMENT_INPUT_COMPONENTS";
	GLEnum$1[GLEnum$1["MAX_SERVER_WAIT_TIMEOUT"] = 37137] = "MAX_SERVER_WAIT_TIMEOUT";
	GLEnum$1[GLEnum$1["MAX_ELEMENT_INDEX"] = 36203] = "MAX_ELEMENT_INDEX";
	GLEnum$1[GLEnum$1["RED"] = 6403] = "RED";
	GLEnum$1[GLEnum$1["RGB8"] = 32849] = "RGB8";
	GLEnum$1[GLEnum$1["RGBA8"] = 32856] = "RGBA8";
	GLEnum$1[GLEnum$1["RGB10_A2"] = 32857] = "RGB10_A2";
	GLEnum$1[GLEnum$1["TEXTURE_3D"] = 32879] = "TEXTURE_3D";
	/** Sets the wrap parameter for texture coordinate  to either GL_CLAMP_TO_EDGE, GL_MIRRORED_REPEAT, or GL_REPEAT. G */
	GLEnum$1[GLEnum$1["TEXTURE_WRAP_R"] = 32882] = "TEXTURE_WRAP_R";
	GLEnum$1[GLEnum$1["TEXTURE_MIN_LOD"] = 33082] = "TEXTURE_MIN_LOD";
	GLEnum$1[GLEnum$1["TEXTURE_MAX_LOD"] = 33083] = "TEXTURE_MAX_LOD";
	GLEnum$1[GLEnum$1["TEXTURE_BASE_LEVEL"] = 33084] = "TEXTURE_BASE_LEVEL";
	GLEnum$1[GLEnum$1["TEXTURE_MAX_LEVEL"] = 33085] = "TEXTURE_MAX_LEVEL";
	GLEnum$1[GLEnum$1["TEXTURE_COMPARE_MODE"] = 34892] = "TEXTURE_COMPARE_MODE";
	GLEnum$1[GLEnum$1["TEXTURE_COMPARE_FUNC"] = 34893] = "TEXTURE_COMPARE_FUNC";
	GLEnum$1[GLEnum$1["SRGB"] = 35904] = "SRGB";
	GLEnum$1[GLEnum$1["SRGB8"] = 35905] = "SRGB8";
	GLEnum$1[GLEnum$1["SRGB8_ALPHA8"] = 35907] = "SRGB8_ALPHA8";
	GLEnum$1[GLEnum$1["COMPARE_REF_TO_TEXTURE"] = 34894] = "COMPARE_REF_TO_TEXTURE";
	GLEnum$1[GLEnum$1["RGBA32F"] = 34836] = "RGBA32F";
	GLEnum$1[GLEnum$1["RGB32F"] = 34837] = "RGB32F";
	GLEnum$1[GLEnum$1["RGBA16F"] = 34842] = "RGBA16F";
	GLEnum$1[GLEnum$1["RGB16F"] = 34843] = "RGB16F";
	GLEnum$1[GLEnum$1["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
	GLEnum$1[GLEnum$1["TEXTURE_BINDING_2D_ARRAY"] = 35869] = "TEXTURE_BINDING_2D_ARRAY";
	GLEnum$1[GLEnum$1["R11F_G11F_B10F"] = 35898] = "R11F_G11F_B10F";
	GLEnum$1[GLEnum$1["RGB9_E5"] = 35901] = "RGB9_E5";
	GLEnum$1[GLEnum$1["RGBA32UI"] = 36208] = "RGBA32UI";
	GLEnum$1[GLEnum$1["RGB32UI"] = 36209] = "RGB32UI";
	GLEnum$1[GLEnum$1["RGBA16UI"] = 36214] = "RGBA16UI";
	GLEnum$1[GLEnum$1["RGB16UI"] = 36215] = "RGB16UI";
	GLEnum$1[GLEnum$1["RGBA8UI"] = 36220] = "RGBA8UI";
	GLEnum$1[GLEnum$1["RGB8UI"] = 36221] = "RGB8UI";
	GLEnum$1[GLEnum$1["RGBA32I"] = 36226] = "RGBA32I";
	GLEnum$1[GLEnum$1["RGB32I"] = 36227] = "RGB32I";
	GLEnum$1[GLEnum$1["RGBA16I"] = 36232] = "RGBA16I";
	GLEnum$1[GLEnum$1["RGB16I"] = 36233] = "RGB16I";
	GLEnum$1[GLEnum$1["RGBA8I"] = 36238] = "RGBA8I";
	GLEnum$1[GLEnum$1["RGB8I"] = 36239] = "RGB8I";
	GLEnum$1[GLEnum$1["RED_INTEGER"] = 36244] = "RED_INTEGER";
	GLEnum$1[GLEnum$1["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
	GLEnum$1[GLEnum$1["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
	GLEnum$1[GLEnum$1["R8"] = 33321] = "R8";
	GLEnum$1[GLEnum$1["RG8"] = 33323] = "RG8";
	GLEnum$1[GLEnum$1["R16F"] = 33325] = "R16F";
	GLEnum$1[GLEnum$1["R32F"] = 33326] = "R32F";
	GLEnum$1[GLEnum$1["RG16F"] = 33327] = "RG16F";
	GLEnum$1[GLEnum$1["RG32F"] = 33328] = "RG32F";
	GLEnum$1[GLEnum$1["R8I"] = 33329] = "R8I";
	GLEnum$1[GLEnum$1["R8UI"] = 33330] = "R8UI";
	GLEnum$1[GLEnum$1["R16I"] = 33331] = "R16I";
	GLEnum$1[GLEnum$1["R16UI"] = 33332] = "R16UI";
	GLEnum$1[GLEnum$1["R32I"] = 33333] = "R32I";
	GLEnum$1[GLEnum$1["R32UI"] = 33334] = "R32UI";
	GLEnum$1[GLEnum$1["RG8I"] = 33335] = "RG8I";
	GLEnum$1[GLEnum$1["RG8UI"] = 33336] = "RG8UI";
	GLEnum$1[GLEnum$1["RG16I"] = 33337] = "RG16I";
	GLEnum$1[GLEnum$1["RG16UI"] = 33338] = "RG16UI";
	GLEnum$1[GLEnum$1["RG32I"] = 33339] = "RG32I";
	GLEnum$1[GLEnum$1["RG32UI"] = 33340] = "RG32UI";
	GLEnum$1[GLEnum$1["R8_SNORM"] = 36756] = "R8_SNORM";
	GLEnum$1[GLEnum$1["RG8_SNORM"] = 36757] = "RG8_SNORM";
	GLEnum$1[GLEnum$1["RGB8_SNORM"] = 36758] = "RGB8_SNORM";
	GLEnum$1[GLEnum$1["RGBA8_SNORM"] = 36759] = "RGBA8_SNORM";
	GLEnum$1[GLEnum$1["RGB10_A2UI"] = 36975] = "RGB10_A2UI";
	GLEnum$1[GLEnum$1["TEXTURE_IMMUTABLE_FORMAT"] = 37167] = "TEXTURE_IMMUTABLE_FORMAT";
	GLEnum$1[GLEnum$1["TEXTURE_IMMUTABLE_LEVELS"] = 33503] = "TEXTURE_IMMUTABLE_LEVELS";
	GLEnum$1[GLEnum$1["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
	GLEnum$1[GLEnum$1["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
	GLEnum$1[GLEnum$1["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
	GLEnum$1[GLEnum$1["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
	GLEnum$1[GLEnum$1["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
	GLEnum$1[GLEnum$1["HALF_FLOAT"] = 5131] = "HALF_FLOAT";
	GLEnum$1[GLEnum$1["RG"] = 33319] = "RG";
	GLEnum$1[GLEnum$1["RG_INTEGER"] = 33320] = "RG_INTEGER";
	GLEnum$1[GLEnum$1["INT_2_10_10_10_REV"] = 36255] = "INT_2_10_10_10_REV";
	GLEnum$1[GLEnum$1["CURRENT_QUERY"] = 34917] = "CURRENT_QUERY";
	/** Returns a GLuint containing the query result. */
	GLEnum$1[GLEnum$1["QUERY_RESULT"] = 34918] = "QUERY_RESULT";
	/** Whether query result is available. */
	GLEnum$1[GLEnum$1["QUERY_RESULT_AVAILABLE"] = 34919] = "QUERY_RESULT_AVAILABLE";
	/** Occlusion query (if drawing passed depth test)  */
	GLEnum$1[GLEnum$1["ANY_SAMPLES_PASSED"] = 35887] = "ANY_SAMPLES_PASSED";
	/** Occlusion query less accurate/faster version */
	GLEnum$1[GLEnum$1["ANY_SAMPLES_PASSED_CONSERVATIVE"] = 36202] = "ANY_SAMPLES_PASSED_CONSERVATIVE";
	GLEnum$1[GLEnum$1["MAX_DRAW_BUFFERS"] = 34852] = "MAX_DRAW_BUFFERS";
	GLEnum$1[GLEnum$1["DRAW_BUFFER0"] = 34853] = "DRAW_BUFFER0";
	GLEnum$1[GLEnum$1["DRAW_BUFFER1"] = 34854] = "DRAW_BUFFER1";
	GLEnum$1[GLEnum$1["DRAW_BUFFER2"] = 34855] = "DRAW_BUFFER2";
	GLEnum$1[GLEnum$1["DRAW_BUFFER3"] = 34856] = "DRAW_BUFFER3";
	GLEnum$1[GLEnum$1["DRAW_BUFFER4"] = 34857] = "DRAW_BUFFER4";
	GLEnum$1[GLEnum$1["DRAW_BUFFER5"] = 34858] = "DRAW_BUFFER5";
	GLEnum$1[GLEnum$1["DRAW_BUFFER6"] = 34859] = "DRAW_BUFFER6";
	GLEnum$1[GLEnum$1["DRAW_BUFFER7"] = 34860] = "DRAW_BUFFER7";
	GLEnum$1[GLEnum$1["DRAW_BUFFER8"] = 34861] = "DRAW_BUFFER8";
	GLEnum$1[GLEnum$1["DRAW_BUFFER9"] = 34862] = "DRAW_BUFFER9";
	GLEnum$1[GLEnum$1["DRAW_BUFFER10"] = 34863] = "DRAW_BUFFER10";
	GLEnum$1[GLEnum$1["DRAW_BUFFER11"] = 34864] = "DRAW_BUFFER11";
	GLEnum$1[GLEnum$1["DRAW_BUFFER12"] = 34865] = "DRAW_BUFFER12";
	GLEnum$1[GLEnum$1["DRAW_BUFFER13"] = 34866] = "DRAW_BUFFER13";
	GLEnum$1[GLEnum$1["DRAW_BUFFER14"] = 34867] = "DRAW_BUFFER14";
	GLEnum$1[GLEnum$1["DRAW_BUFFER15"] = 34868] = "DRAW_BUFFER15";
	GLEnum$1[GLEnum$1["MAX_COLOR_ATTACHMENTS"] = 36063] = "MAX_COLOR_ATTACHMENTS";
	GLEnum$1[GLEnum$1["COLOR_ATTACHMENT1"] = 36065] = "COLOR_ATTACHMENT1";
	GLEnum$1[GLEnum$1["COLOR_ATTACHMENT2"] = 36066] = "COLOR_ATTACHMENT2";
	GLEnum$1[GLEnum$1["COLOR_ATTACHMENT3"] = 36067] = "COLOR_ATTACHMENT3";
	GLEnum$1[GLEnum$1["COLOR_ATTACHMENT4"] = 36068] = "COLOR_ATTACHMENT4";
	GLEnum$1[GLEnum$1["COLOR_ATTACHMENT5"] = 36069] = "COLOR_ATTACHMENT5";
	GLEnum$1[GLEnum$1["COLOR_ATTACHMENT6"] = 36070] = "COLOR_ATTACHMENT6";
	GLEnum$1[GLEnum$1["COLOR_ATTACHMENT7"] = 36071] = "COLOR_ATTACHMENT7";
	GLEnum$1[GLEnum$1["COLOR_ATTACHMENT8"] = 36072] = "COLOR_ATTACHMENT8";
	GLEnum$1[GLEnum$1["COLOR_ATTACHMENT9"] = 36073] = "COLOR_ATTACHMENT9";
	GLEnum$1[GLEnum$1["COLOR_ATTACHMENT10"] = 36074] = "COLOR_ATTACHMENT10";
	GLEnum$1[GLEnum$1["COLOR_ATTACHMENT11"] = 36075] = "COLOR_ATTACHMENT11";
	GLEnum$1[GLEnum$1["COLOR_ATTACHMENT12"] = 36076] = "COLOR_ATTACHMENT12";
	GLEnum$1[GLEnum$1["COLOR_ATTACHMENT13"] = 36077] = "COLOR_ATTACHMENT13";
	GLEnum$1[GLEnum$1["COLOR_ATTACHMENT14"] = 36078] = "COLOR_ATTACHMENT14";
	GLEnum$1[GLEnum$1["COLOR_ATTACHMENT15"] = 36079] = "COLOR_ATTACHMENT15";
	GLEnum$1[GLEnum$1["SAMPLER_3D"] = 35679] = "SAMPLER_3D";
	GLEnum$1[GLEnum$1["SAMPLER_2D_SHADOW"] = 35682] = "SAMPLER_2D_SHADOW";
	GLEnum$1[GLEnum$1["SAMPLER_2D_ARRAY"] = 36289] = "SAMPLER_2D_ARRAY";
	GLEnum$1[GLEnum$1["SAMPLER_2D_ARRAY_SHADOW"] = 36292] = "SAMPLER_2D_ARRAY_SHADOW";
	GLEnum$1[GLEnum$1["SAMPLER_CUBE_SHADOW"] = 36293] = "SAMPLER_CUBE_SHADOW";
	GLEnum$1[GLEnum$1["INT_SAMPLER_2D"] = 36298] = "INT_SAMPLER_2D";
	GLEnum$1[GLEnum$1["INT_SAMPLER_3D"] = 36299] = "INT_SAMPLER_3D";
	GLEnum$1[GLEnum$1["INT_SAMPLER_CUBE"] = 36300] = "INT_SAMPLER_CUBE";
	GLEnum$1[GLEnum$1["INT_SAMPLER_2D_ARRAY"] = 36303] = "INT_SAMPLER_2D_ARRAY";
	GLEnum$1[GLEnum$1["UNSIGNED_INT_SAMPLER_2D"] = 36306] = "UNSIGNED_INT_SAMPLER_2D";
	GLEnum$1[GLEnum$1["UNSIGNED_INT_SAMPLER_3D"] = 36307] = "UNSIGNED_INT_SAMPLER_3D";
	GLEnum$1[GLEnum$1["UNSIGNED_INT_SAMPLER_CUBE"] = 36308] = "UNSIGNED_INT_SAMPLER_CUBE";
	GLEnum$1[GLEnum$1["UNSIGNED_INT_SAMPLER_2D_ARRAY"] = 36311] = "UNSIGNED_INT_SAMPLER_2D_ARRAY";
	GLEnum$1[GLEnum$1["MAX_SAMPLES"] = 36183] = "MAX_SAMPLES";
	GLEnum$1[GLEnum$1["SAMPLER_BINDING"] = 35097] = "SAMPLER_BINDING";
	GLEnum$1[GLEnum$1["PIXEL_PACK_BUFFER"] = 35051] = "PIXEL_PACK_BUFFER";
	GLEnum$1[GLEnum$1["PIXEL_UNPACK_BUFFER"] = 35052] = "PIXEL_UNPACK_BUFFER";
	GLEnum$1[GLEnum$1["PIXEL_PACK_BUFFER_BINDING"] = 35053] = "PIXEL_PACK_BUFFER_BINDING";
	GLEnum$1[GLEnum$1["PIXEL_UNPACK_BUFFER_BINDING"] = 35055] = "PIXEL_UNPACK_BUFFER_BINDING";
	GLEnum$1[GLEnum$1["COPY_READ_BUFFER"] = 36662] = "COPY_READ_BUFFER";
	GLEnum$1[GLEnum$1["COPY_WRITE_BUFFER"] = 36663] = "COPY_WRITE_BUFFER";
	GLEnum$1[GLEnum$1["COPY_READ_BUFFER_BINDING"] = 36662] = "COPY_READ_BUFFER_BINDING";
	GLEnum$1[GLEnum$1["COPY_WRITE_BUFFER_BINDING"] = 36663] = "COPY_WRITE_BUFFER_BINDING";
	GLEnum$1[GLEnum$1["FLOAT_MAT2x3"] = 35685] = "FLOAT_MAT2x3";
	GLEnum$1[GLEnum$1["FLOAT_MAT2x4"] = 35686] = "FLOAT_MAT2x4";
	GLEnum$1[GLEnum$1["FLOAT_MAT3x2"] = 35687] = "FLOAT_MAT3x2";
	GLEnum$1[GLEnum$1["FLOAT_MAT3x4"] = 35688] = "FLOAT_MAT3x4";
	GLEnum$1[GLEnum$1["FLOAT_MAT4x2"] = 35689] = "FLOAT_MAT4x2";
	GLEnum$1[GLEnum$1["FLOAT_MAT4x3"] = 35690] = "FLOAT_MAT4x3";
	GLEnum$1[GLEnum$1["UNSIGNED_INT_VEC2"] = 36294] = "UNSIGNED_INT_VEC2";
	GLEnum$1[GLEnum$1["UNSIGNED_INT_VEC3"] = 36295] = "UNSIGNED_INT_VEC3";
	GLEnum$1[GLEnum$1["UNSIGNED_INT_VEC4"] = 36296] = "UNSIGNED_INT_VEC4";
	GLEnum$1[GLEnum$1["UNSIGNED_NORMALIZED"] = 35863] = "UNSIGNED_NORMALIZED";
	GLEnum$1[GLEnum$1["SIGNED_NORMALIZED"] = 36764] = "SIGNED_NORMALIZED";
	GLEnum$1[GLEnum$1["VERTEX_ATTRIB_ARRAY_INTEGER"] = 35069] = "VERTEX_ATTRIB_ARRAY_INTEGER";
	GLEnum$1[GLEnum$1["VERTEX_ATTRIB_ARRAY_DIVISOR"] = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR";
	GLEnum$1[GLEnum$1["TRANSFORM_FEEDBACK_BUFFER_MODE"] = 35967] = "TRANSFORM_FEEDBACK_BUFFER_MODE";
	GLEnum$1[GLEnum$1["MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS"] = 35968] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS";
	GLEnum$1[GLEnum$1["TRANSFORM_FEEDBACK_VARYINGS"] = 35971] = "TRANSFORM_FEEDBACK_VARYINGS";
	GLEnum$1[GLEnum$1["TRANSFORM_FEEDBACK_BUFFER_START"] = 35972] = "TRANSFORM_FEEDBACK_BUFFER_START";
	GLEnum$1[GLEnum$1["TRANSFORM_FEEDBACK_BUFFER_SIZE"] = 35973] = "TRANSFORM_FEEDBACK_BUFFER_SIZE";
	GLEnum$1[GLEnum$1["TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN"] = 35976] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN";
	GLEnum$1[GLEnum$1["MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS"] = 35978] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS";
	GLEnum$1[GLEnum$1["MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS"] = 35979] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS";
	GLEnum$1[GLEnum$1["INTERLEAVED_ATTRIBS"] = 35980] = "INTERLEAVED_ATTRIBS";
	GLEnum$1[GLEnum$1["SEPARATE_ATTRIBS"] = 35981] = "SEPARATE_ATTRIBS";
	GLEnum$1[GLEnum$1["TRANSFORM_FEEDBACK_BUFFER"] = 35982] = "TRANSFORM_FEEDBACK_BUFFER";
	GLEnum$1[GLEnum$1["TRANSFORM_FEEDBACK_BUFFER_BINDING"] = 35983] = "TRANSFORM_FEEDBACK_BUFFER_BINDING";
	GLEnum$1[GLEnum$1["TRANSFORM_FEEDBACK"] = 36386] = "TRANSFORM_FEEDBACK";
	GLEnum$1[GLEnum$1["TRANSFORM_FEEDBACK_PAUSED"] = 36387] = "TRANSFORM_FEEDBACK_PAUSED";
	GLEnum$1[GLEnum$1["TRANSFORM_FEEDBACK_ACTIVE"] = 36388] = "TRANSFORM_FEEDBACK_ACTIVE";
	GLEnum$1[GLEnum$1["TRANSFORM_FEEDBACK_BINDING"] = 36389] = "TRANSFORM_FEEDBACK_BINDING";
	GLEnum$1[GLEnum$1["FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING"] = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING";
	GLEnum$1[GLEnum$1["FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE"] = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE";
	GLEnum$1[GLEnum$1["FRAMEBUFFER_ATTACHMENT_RED_SIZE"] = 33298] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE";
	GLEnum$1[GLEnum$1["FRAMEBUFFER_ATTACHMENT_GREEN_SIZE"] = 33299] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE";
	GLEnum$1[GLEnum$1["FRAMEBUFFER_ATTACHMENT_BLUE_SIZE"] = 33300] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE";
	GLEnum$1[GLEnum$1["FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE"] = 33301] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE";
	GLEnum$1[GLEnum$1["FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE"] = 33302] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE";
	GLEnum$1[GLEnum$1["FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE"] = 33303] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE";
	GLEnum$1[GLEnum$1["FRAMEBUFFER_DEFAULT"] = 33304] = "FRAMEBUFFER_DEFAULT";
	GLEnum$1[GLEnum$1["DEPTH24_STENCIL8"] = 35056] = "DEPTH24_STENCIL8";
	GLEnum$1[GLEnum$1["DRAW_FRAMEBUFFER_BINDING"] = 36006] = "DRAW_FRAMEBUFFER_BINDING";
	GLEnum$1[GLEnum$1["READ_FRAMEBUFFER_BINDING"] = 36010] = "READ_FRAMEBUFFER_BINDING";
	GLEnum$1[GLEnum$1["RENDERBUFFER_SAMPLES"] = 36011] = "RENDERBUFFER_SAMPLES";
	GLEnum$1[GLEnum$1["FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER"] = 36052] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER";
	GLEnum$1[GLEnum$1["FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"] = 36182] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE";
	GLEnum$1[GLEnum$1["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
	GLEnum$1[GLEnum$1["UNIFORM_BUFFER_BINDING"] = 35368] = "UNIFORM_BUFFER_BINDING";
	GLEnum$1[GLEnum$1["UNIFORM_BUFFER_START"] = 35369] = "UNIFORM_BUFFER_START";
	GLEnum$1[GLEnum$1["UNIFORM_BUFFER_SIZE"] = 35370] = "UNIFORM_BUFFER_SIZE";
	GLEnum$1[GLEnum$1["MAX_VERTEX_UNIFORM_BLOCKS"] = 35371] = "MAX_VERTEX_UNIFORM_BLOCKS";
	GLEnum$1[GLEnum$1["MAX_FRAGMENT_UNIFORM_BLOCKS"] = 35373] = "MAX_FRAGMENT_UNIFORM_BLOCKS";
	GLEnum$1[GLEnum$1["MAX_COMBINED_UNIFORM_BLOCKS"] = 35374] = "MAX_COMBINED_UNIFORM_BLOCKS";
	GLEnum$1[GLEnum$1["MAX_UNIFORM_BUFFER_BINDINGS"] = 35375] = "MAX_UNIFORM_BUFFER_BINDINGS";
	GLEnum$1[GLEnum$1["MAX_UNIFORM_BLOCK_SIZE"] = 35376] = "MAX_UNIFORM_BLOCK_SIZE";
	GLEnum$1[GLEnum$1["MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS"] = 35377] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS";
	GLEnum$1[GLEnum$1["MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS"] = 35379] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS";
	GLEnum$1[GLEnum$1["UNIFORM_BUFFER_OFFSET_ALIGNMENT"] = 35380] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT";
	GLEnum$1[GLEnum$1["ACTIVE_UNIFORM_BLOCKS"] = 35382] = "ACTIVE_UNIFORM_BLOCKS";
	GLEnum$1[GLEnum$1["UNIFORM_TYPE"] = 35383] = "UNIFORM_TYPE";
	GLEnum$1[GLEnum$1["UNIFORM_SIZE"] = 35384] = "UNIFORM_SIZE";
	GLEnum$1[GLEnum$1["UNIFORM_BLOCK_INDEX"] = 35386] = "UNIFORM_BLOCK_INDEX";
	GLEnum$1[GLEnum$1["UNIFORM_OFFSET"] = 35387] = "UNIFORM_OFFSET";
	GLEnum$1[GLEnum$1["UNIFORM_ARRAY_STRIDE"] = 35388] = "UNIFORM_ARRAY_STRIDE";
	GLEnum$1[GLEnum$1["UNIFORM_MATRIX_STRIDE"] = 35389] = "UNIFORM_MATRIX_STRIDE";
	GLEnum$1[GLEnum$1["UNIFORM_IS_ROW_MAJOR"] = 35390] = "UNIFORM_IS_ROW_MAJOR";
	GLEnum$1[GLEnum$1["UNIFORM_BLOCK_BINDING"] = 35391] = "UNIFORM_BLOCK_BINDING";
	GLEnum$1[GLEnum$1["UNIFORM_BLOCK_DATA_SIZE"] = 35392] = "UNIFORM_BLOCK_DATA_SIZE";
	GLEnum$1[GLEnum$1["UNIFORM_BLOCK_ACTIVE_UNIFORMS"] = 35394] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS";
	GLEnum$1[GLEnum$1["UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES"] = 35395] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES";
	GLEnum$1[GLEnum$1["UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER"] = 35396] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER";
	GLEnum$1[GLEnum$1["UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER"] = 35398] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER";
	GLEnum$1[GLEnum$1["OBJECT_TYPE"] = 37138] = "OBJECT_TYPE";
	GLEnum$1[GLEnum$1["SYNC_CONDITION"] = 37139] = "SYNC_CONDITION";
	GLEnum$1[GLEnum$1["SYNC_STATUS"] = 37140] = "SYNC_STATUS";
	GLEnum$1[GLEnum$1["SYNC_FLAGS"] = 37141] = "SYNC_FLAGS";
	GLEnum$1[GLEnum$1["SYNC_FENCE"] = 37142] = "SYNC_FENCE";
	GLEnum$1[GLEnum$1["SYNC_GPU_COMMANDS_COMPLETE"] = 37143] = "SYNC_GPU_COMMANDS_COMPLETE";
	GLEnum$1[GLEnum$1["UNSIGNALED"] = 37144] = "UNSIGNALED";
	GLEnum$1[GLEnum$1["SIGNALED"] = 37145] = "SIGNALED";
	GLEnum$1[GLEnum$1["ALREADY_SIGNALED"] = 37146] = "ALREADY_SIGNALED";
	GLEnum$1[GLEnum$1["TIMEOUT_EXPIRED"] = 37147] = "TIMEOUT_EXPIRED";
	GLEnum$1[GLEnum$1["CONDITION_SATISFIED"] = 37148] = "CONDITION_SATISFIED";
	GLEnum$1[GLEnum$1["WAIT_FAILED"] = 37149] = "WAIT_FAILED";
	GLEnum$1[GLEnum$1["SYNC_FLUSH_COMMANDS_BIT"] = 1] = "SYNC_FLUSH_COMMANDS_BIT";
	GLEnum$1[GLEnum$1["COLOR"] = 6144] = "COLOR";
	GLEnum$1[GLEnum$1["DEPTH"] = 6145] = "DEPTH";
	GLEnum$1[GLEnum$1["STENCIL"] = 6146] = "STENCIL";
	GLEnum$1[GLEnum$1["MIN"] = 32775] = "MIN";
	GLEnum$1[GLEnum$1["MAX"] = 32776] = "MAX";
	GLEnum$1[GLEnum$1["DEPTH_COMPONENT24"] = 33190] = "DEPTH_COMPONENT24";
	GLEnum$1[GLEnum$1["STREAM_READ"] = 35041] = "STREAM_READ";
	GLEnum$1[GLEnum$1["STREAM_COPY"] = 35042] = "STREAM_COPY";
	GLEnum$1[GLEnum$1["STATIC_READ"] = 35045] = "STATIC_READ";
	GLEnum$1[GLEnum$1["STATIC_COPY"] = 35046] = "STATIC_COPY";
	GLEnum$1[GLEnum$1["DYNAMIC_READ"] = 35049] = "DYNAMIC_READ";
	GLEnum$1[GLEnum$1["DYNAMIC_COPY"] = 35050] = "DYNAMIC_COPY";
	GLEnum$1[GLEnum$1["DEPTH_COMPONENT32F"] = 36012] = "DEPTH_COMPONENT32F";
	GLEnum$1[GLEnum$1["DEPTH32F_STENCIL8"] = 36013] = "DEPTH32F_STENCIL8";
	GLEnum$1[GLEnum$1["INVALID_INDEX"] = 4294967295] = "INVALID_INDEX";
	GLEnum$1[GLEnum$1["TIMEOUT_IGNORED"] = -1] = "TIMEOUT_IGNORED";
	GLEnum$1[GLEnum$1["MAX_CLIENT_WAIT_TIMEOUT_WEBGL"] = 37447] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL";
	/** Passed to getParameter to get the vendor string of the graphics driver. */
	GLEnum$1[GLEnum$1["UNMASKED_VENDOR_WEBGL"] = 37445] = "UNMASKED_VENDOR_WEBGL";
	/** Passed to getParameter to get the renderer string of the graphics driver. */
	GLEnum$1[GLEnum$1["UNMASKED_RENDERER_WEBGL"] = 37446] = "UNMASKED_RENDERER_WEBGL";
	/** Returns the maximum available anisotropy. */
	GLEnum$1[GLEnum$1["MAX_TEXTURE_MAX_ANISOTROPY_EXT"] = 34047] = "MAX_TEXTURE_MAX_ANISOTROPY_EXT";
	/** Passed to texParameter to set the desired maximum anisotropy for a texture. */
	GLEnum$1[GLEnum$1["TEXTURE_MAX_ANISOTROPY_EXT"] = 34046] = "TEXTURE_MAX_ANISOTROPY_EXT";
	GLEnum$1[GLEnum$1["R16_EXT"] = 33322] = "R16_EXT";
	GLEnum$1[GLEnum$1["RG16_EXT"] = 33324] = "RG16_EXT";
	GLEnum$1[GLEnum$1["RGB16_EXT"] = 32852] = "RGB16_EXT";
	GLEnum$1[GLEnum$1["RGBA16_EXT"] = 32859] = "RGBA16_EXT";
	GLEnum$1[GLEnum$1["R16_SNORM_EXT"] = 36760] = "R16_SNORM_EXT";
	GLEnum$1[GLEnum$1["RG16_SNORM_EXT"] = 36761] = "RG16_SNORM_EXT";
	GLEnum$1[GLEnum$1["RGB16_SNORM_EXT"] = 36762] = "RGB16_SNORM_EXT";
	GLEnum$1[GLEnum$1["RGBA16_SNORM_EXT"] = 36763] = "RGBA16_SNORM_EXT";
	/** A DXT1-compressed image in an RGB image format. */
	GLEnum$1[GLEnum$1["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
	/** A DXT1-compressed image in an RGB image format with a simple on/off alpha value. */
	GLEnum$1[GLEnum$1["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
	/** A DXT3-compressed image in an RGBA image format. Compared to a 32-bit RGBA texture, it offers 4:1 compression. */
	GLEnum$1[GLEnum$1["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
	/** A DXT5-compressed image in an RGBA image format. It also provides a 4:1 compression, but differs to the DXT3 compression in how the alpha compression is done. */
	GLEnum$1[GLEnum$1["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
	GLEnum$1[GLEnum$1["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
	GLEnum$1[GLEnum$1["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
	GLEnum$1[GLEnum$1["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
	GLEnum$1[GLEnum$1["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
	GLEnum$1[GLEnum$1["COMPRESSED_RED_RGTC1_EXT"] = 36283] = "COMPRESSED_RED_RGTC1_EXT";
	GLEnum$1[GLEnum$1["COMPRESSED_SIGNED_RED_RGTC1_EXT"] = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT";
	GLEnum$1[GLEnum$1["COMPRESSED_RED_GREEN_RGTC2_EXT"] = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT";
	GLEnum$1[GLEnum$1["COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT"] = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT";
	GLEnum$1[GLEnum$1["COMPRESSED_RGBA_BPTC_UNORM_EXT"] = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT";
	GLEnum$1[GLEnum$1["COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT"] = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT";
	GLEnum$1[GLEnum$1["COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT"] = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT";
	GLEnum$1[GLEnum$1["COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT"] = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT";
	/** One-channel (red) unsigned format compression. */
	GLEnum$1[GLEnum$1["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
	/** One-channel (red) signed format compression. */
	GLEnum$1[GLEnum$1["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
	/** Two-channel (red and green) unsigned format compression. */
	GLEnum$1[GLEnum$1["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
	/** Two-channel (red and green) signed format compression. */
	GLEnum$1[GLEnum$1["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
	/** Compresses RGB8 data with no alpha channel. */
	GLEnum$1[GLEnum$1["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
	/** Compresses RGBA8 data. The RGB part is encoded the same as RGB_ETC2, but the alpha part is encoded separately. */
	GLEnum$1[GLEnum$1["COMPRESSED_RGBA8_ETC2_EAC"] = 37493] = "COMPRESSED_RGBA8_ETC2_EAC";
	/** Compresses sRGB8 data with no alpha channel. */
	GLEnum$1[GLEnum$1["COMPRESSED_SRGB8_ETC2"] = 37494] = "COMPRESSED_SRGB8_ETC2";
	/** Compresses sRGBA8 data. The sRGB part is encoded the same as SRGB_ETC2, but the alpha part is encoded separately. */
	GLEnum$1[GLEnum$1["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37495] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
	/** Similar to RGB8_ETC, but with ability to punch through the alpha channel, which means to make it completely opaque or transparent. */
	GLEnum$1[GLEnum$1["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37496] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
	/** Similar to SRGB8_ETC, but with ability to punch through the alpha channel, which means to make it completely opaque or transparent. */
	GLEnum$1[GLEnum$1["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37497] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
	/** RGB compression in 4-bit mode. One block for each 44 pixels. */
	GLEnum$1[GLEnum$1["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
	/** RGBA compression in 4-bit mode. One block for each 44 pixels. */
	GLEnum$1[GLEnum$1["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
	/** RGB compression in 2-bit mode. One block for each 84 pixels. */
	GLEnum$1[GLEnum$1["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
	/** RGBA compression in 2-bit mode. One block for each 84 pixels. */
	GLEnum$1[GLEnum$1["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
	/** Compresses 24-bit RGB data with no alpha channel. */
	GLEnum$1[GLEnum$1["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
	GLEnum$1[GLEnum$1["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
	GLEnum$1[GLEnum$1["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
	GLEnum$1[GLEnum$1["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
	GLEnum$1[GLEnum$1["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
	GLEnum$1[GLEnum$1["COMPRESSED_RGBA_ASTC_5x4_KHR"] = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR";
	GLEnum$1[GLEnum$1["COMPRESSED_RGBA_ASTC_5x5_KHR"] = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR";
	GLEnum$1[GLEnum$1["COMPRESSED_RGBA_ASTC_6x5_KHR"] = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR";
	GLEnum$1[GLEnum$1["COMPRESSED_RGBA_ASTC_6x6_KHR"] = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR";
	GLEnum$1[GLEnum$1["COMPRESSED_RGBA_ASTC_8x5_KHR"] = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR";
	GLEnum$1[GLEnum$1["COMPRESSED_RGBA_ASTC_8x6_KHR"] = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR";
	GLEnum$1[GLEnum$1["COMPRESSED_RGBA_ASTC_8x8_KHR"] = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR";
	GLEnum$1[GLEnum$1["COMPRESSED_RGBA_ASTC_10x5_KHR"] = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR";
	GLEnum$1[GLEnum$1["COMPRESSED_RGBA_ASTC_10x6_KHR"] = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR";
	GLEnum$1[GLEnum$1["COMPRESSED_RGBA_ASTC_10x8_KHR"] = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR";
	GLEnum$1[GLEnum$1["COMPRESSED_RGBA_ASTC_10x10_KHR"] = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR";
	GLEnum$1[GLEnum$1["COMPRESSED_RGBA_ASTC_12x10_KHR"] = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR";
	GLEnum$1[GLEnum$1["COMPRESSED_RGBA_ASTC_12x12_KHR"] = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR";
	GLEnum$1[GLEnum$1["COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"] = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR";
	GLEnum$1[GLEnum$1["COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"] = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR";
	GLEnum$1[GLEnum$1["COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"] = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR";
	GLEnum$1[GLEnum$1["COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"] = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR";
	GLEnum$1[GLEnum$1["COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"] = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR";
	GLEnum$1[GLEnum$1["COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"] = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR";
	GLEnum$1[GLEnum$1["COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"] = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR";
	GLEnum$1[GLEnum$1["COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"] = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR";
	GLEnum$1[GLEnum$1["COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"] = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR";
	GLEnum$1[GLEnum$1["COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"] = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR";
	GLEnum$1[GLEnum$1["COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"] = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR";
	GLEnum$1[GLEnum$1["COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"] = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR";
	GLEnum$1[GLEnum$1["COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"] = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR";
	GLEnum$1[GLEnum$1["COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"] = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
	/** The number of bits used to hold the query result for the given target. */
	GLEnum$1[GLEnum$1["QUERY_COUNTER_BITS_EXT"] = 34916] = "QUERY_COUNTER_BITS_EXT";
	/** The currently active query. */
	GLEnum$1[GLEnum$1["CURRENT_QUERY_EXT"] = 34917] = "CURRENT_QUERY_EXT";
	/** The query result. */
	GLEnum$1[GLEnum$1["QUERY_RESULT_EXT"] = 34918] = "QUERY_RESULT_EXT";
	/** A Boolean indicating whether or not a query result is available. */
	GLEnum$1[GLEnum$1["QUERY_RESULT_AVAILABLE_EXT"] = 34919] = "QUERY_RESULT_AVAILABLE_EXT";
	/** Elapsed time (in nanoseconds). */
	GLEnum$1[GLEnum$1["TIME_ELAPSED_EXT"] = 35007] = "TIME_ELAPSED_EXT";
	/** The current time. */
	GLEnum$1[GLEnum$1["TIMESTAMP_EXT"] = 36392] = "TIMESTAMP_EXT";
	/** A Boolean indicating whether or not the GPU performed any disjoint operation (lost context) */
	GLEnum$1[GLEnum$1["GPU_DISJOINT_EXT"] = 36795] = "GPU_DISJOINT_EXT";
	/** a non-blocking poll operation, so that compile/link status availability can be queried without potentially incurring stalls */
	GLEnum$1[GLEnum$1["COMPLETION_STATUS_KHR"] = 37297] = "COMPLETION_STATUS_KHR";
	/** Disables depth clipping */
	GLEnum$1[GLEnum$1["DEPTH_CLAMP_EXT"] = 34383] = "DEPTH_CLAMP_EXT";
	/** Values of first vertex in primitive are used for flat shading */
	GLEnum$1[GLEnum$1["FIRST_VERTEX_CONVENTION_WEBGL"] = 36429] = "FIRST_VERTEX_CONVENTION_WEBGL";
	/** Values of first vertex in primitive are used for flat shading */
	GLEnum$1[GLEnum$1["LAST_VERTEX_CONVENTION_WEBGL"] = 36430] = "LAST_VERTEX_CONVENTION_WEBGL";
	/** Controls which vertex in primitive is used for flat shading */
	GLEnum$1[GLEnum$1["PROVOKING_VERTEX_WEBL"] = 36431] = "PROVOKING_VERTEX_WEBL";
	GLEnum$1[GLEnum$1["POLYGON_MODE_WEBGL"] = 2880] = "POLYGON_MODE_WEBGL";
	GLEnum$1[GLEnum$1["POLYGON_OFFSET_LINE_WEBGL"] = 10754] = "POLYGON_OFFSET_LINE_WEBGL";
	GLEnum$1[GLEnum$1["LINE_WEBGL"] = 6913] = "LINE_WEBGL";
	GLEnum$1[GLEnum$1["FILL_WEBGL"] = 6914] = "FILL_WEBGL";
	/** Max clip distances */
	GLEnum$1[GLEnum$1["MAX_CLIP_DISTANCES_WEBGL"] = 3378] = "MAX_CLIP_DISTANCES_WEBGL";
	/** Max cull distances */
	GLEnum$1[GLEnum$1["MAX_CULL_DISTANCES_WEBGL"] = 33529] = "MAX_CULL_DISTANCES_WEBGL";
	/** Max clip and cull distances */
	GLEnum$1[GLEnum$1["MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL"] = 33530] = "MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL";
	/** Enable gl_ClipDistance[0] and gl_CullDistance[0] */
	GLEnum$1[GLEnum$1["CLIP_DISTANCE0_WEBGL"] = 12288] = "CLIP_DISTANCE0_WEBGL";
	/** Enable gl_ClipDistance[1] and gl_CullDistance[1] */
	GLEnum$1[GLEnum$1["CLIP_DISTANCE1_WEBGL"] = 12289] = "CLIP_DISTANCE1_WEBGL";
	/** Enable gl_ClipDistance[2] and gl_CullDistance[2] */
	GLEnum$1[GLEnum$1["CLIP_DISTANCE2_WEBGL"] = 12290] = "CLIP_DISTANCE2_WEBGL";
	/** Enable gl_ClipDistance[3] and gl_CullDistance[3] */
	GLEnum$1[GLEnum$1["CLIP_DISTANCE3_WEBGL"] = 12291] = "CLIP_DISTANCE3_WEBGL";
	/** Enable gl_ClipDistance[4] and gl_CullDistance[4] */
	GLEnum$1[GLEnum$1["CLIP_DISTANCE4_WEBGL"] = 12292] = "CLIP_DISTANCE4_WEBGL";
	/** Enable gl_ClipDistance[5] and gl_CullDistance[5] */
	GLEnum$1[GLEnum$1["CLIP_DISTANCE5_WEBGL"] = 12293] = "CLIP_DISTANCE5_WEBGL";
	/** Enable gl_ClipDistance[6] and gl_CullDistance[6] */
	GLEnum$1[GLEnum$1["CLIP_DISTANCE6_WEBGL"] = 12294] = "CLIP_DISTANCE6_WEBGL";
	/** Enable gl_ClipDistance[7] and gl_CullDistance[7] */
	GLEnum$1[GLEnum$1["CLIP_DISTANCE7_WEBGL"] = 12295] = "CLIP_DISTANCE7_WEBGL";
	/** EXT_polygon_offset_clamp https://registry.khronos.org/webgl/extensions/EXT_polygon_offset_clamp/ */
	GLEnum$1[GLEnum$1["POLYGON_OFFSET_CLAMP_EXT"] = 36379] = "POLYGON_OFFSET_CLAMP_EXT";
	/** EXT_clip_control https://registry.khronos.org/webgl/extensions/EXT_clip_control/ */
	GLEnum$1[GLEnum$1["LOWER_LEFT_EXT"] = 36001] = "LOWER_LEFT_EXT";
	GLEnum$1[GLEnum$1["UPPER_LEFT_EXT"] = 36002] = "UPPER_LEFT_EXT";
	GLEnum$1[GLEnum$1["NEGATIVE_ONE_TO_ONE_EXT"] = 37726] = "NEGATIVE_ONE_TO_ONE_EXT";
	GLEnum$1[GLEnum$1["ZERO_TO_ONE_EXT"] = 37727] = "ZERO_TO_ONE_EXT";
	GLEnum$1[GLEnum$1["CLIP_ORIGIN_EXT"] = 37724] = "CLIP_ORIGIN_EXT";
	GLEnum$1[GLEnum$1["CLIP_DEPTH_MODE_EXT"] = 37725] = "CLIP_DEPTH_MODE_EXT";
	/** WEBGL_blend_func_extended https://registry.khronos.org/webgl/extensions/WEBGL_blend_func_extended/ */
	GLEnum$1[GLEnum$1["SRC1_COLOR_WEBGL"] = 35065] = "SRC1_COLOR_WEBGL";
	GLEnum$1[GLEnum$1["SRC1_ALPHA_WEBGL"] = 34185] = "SRC1_ALPHA_WEBGL";
	GLEnum$1[GLEnum$1["ONE_MINUS_SRC1_COLOR_WEBGL"] = 35066] = "ONE_MINUS_SRC1_COLOR_WEBGL";
	GLEnum$1[GLEnum$1["ONE_MINUS_SRC1_ALPHA_WEBGL"] = 35067] = "ONE_MINUS_SRC1_ALPHA_WEBGL";
	GLEnum$1[GLEnum$1["MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL"] = 35068] = "MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL";
	/** EXT_texture_mirror_clamp_to_edge https://registry.khronos.org/webgl/extensions/EXT_texture_mirror_clamp_to_edge/ */
	GLEnum$1[GLEnum$1["MIRROR_CLAMP_TO_EDGE_EXT"] = 34627] = "MIRROR_CLAMP_TO_EDGE_EXT";
})(GLEnum || (GLEnum = {}));

//#endregion
//#region node_modules/@luma.gl/webgl/dist/utils/load-script.js
/**
* Load a script (identified by an url). When the url returns, the
* content of this file is added into a new script element, attached to the DOM (body element)
* @param scriptUrl defines the url of the script to laod
* @param scriptId defines the id of the script element
*/
async function loadScript(scriptUrl, scriptId) {
	const head = document.getElementsByTagName("head")[0];
	if (!head) throw new Error("loadScript");
	const script = document.createElement("script");
	script.setAttribute("type", "text/javascript");
	script.setAttribute("src", scriptUrl);
	if (scriptId) script.id = scriptId;
	return new Promise((resolve, reject) => {
		script.onload = resolve;
		script.onerror = (error) => reject(/* @__PURE__ */ new Error(`Unable to load script '${scriptUrl}': ${error}`));
		head.appendChild(script);
	});
}

//#endregion
//#region node_modules/@luma.gl/webgl/dist/context/debug/spector.js
var LOG_LEVEL = 1;
var spector = null;
var initialized = false;
const DEFAULT_SPECTOR_PROPS = {
	debugSpectorJS: log.get("debug-spectorjs"),
	debugSpectorJSUrl: "https://cdn.jsdelivr.net/npm/spectorjs@0.9.30/dist/spector.bundle.js",
	gl: void 0
};
/** Loads spector from CDN if not already installed */
async function loadSpectorJS(props) {
	if (!globalThis.SPECTOR) try {
		await loadScript(props.debugSpectorJSUrl || DEFAULT_SPECTOR_PROPS.debugSpectorJSUrl);
	} catch (error) {
		log.warn(String(error));
	}
}
function initializeSpectorJS(props) {
	props = {
		...DEFAULT_SPECTOR_PROPS,
		...props
	};
	if (!props.debugSpectorJS) return null;
	if (!spector && globalThis.SPECTOR && !globalThis.luma?.spector) {
		log.probe(LOG_LEVEL, "SPECTOR found and initialized. Start with `luma.spector.displayUI()`")();
		const { Spector: SpectorJS } = globalThis.SPECTOR;
		spector = new SpectorJS();
		if (globalThis.luma) globalThis.luma.spector = spector;
	}
	if (!spector) return null;
	if (!initialized) {
		initialized = true;
		spector.spyCanvases();
		spector?.onCaptureStarted.add((capture) => log.info("Spector capture started:", capture)());
		spector?.onCapture.add((capture) => {
			log.info("Spector capture complete:", capture)();
			spector?.getResultUI();
			spector?.resultView.display();
			spector?.resultView.addCapture(capture);
		});
	}
	if (props.gl) {
		const gl = props.gl;
		const device = gl.device;
		spector?.startCapture(props.gl, 500);
		gl.device = device;
		new Promise((resolve) => setTimeout(resolve, 2e3)).then((_) => {
			log.info("Spector capture stopped after 2 seconds")();
			spector?.stopCapture();
		});
	}
	return spector;
}

//#endregion
//#region node_modules/@luma.gl/webgl/dist/context/debug/webgl-developer-tools.js
var WEBGL_DEBUG_CDN_URL = "https://unpkg.com/webgl-debug@2.0.1/index.js";
function getWebGLContextData(gl) {
	gl.luma = gl.luma || {};
	return gl.luma;
}
/**
* Loads Khronos WebGLDeveloperTools from CDN if not already installed
* const WebGLDebugUtils = require('webgl-debug');
* @see https://github.com/KhronosGroup/WebGLDeveloperTools
* @see https://github.com/vorg/webgl-debug
*/
async function loadWebGLDeveloperTools() {
	if (isBrowser() && !globalThis.WebGLDebugUtils) {
		globalThis.global = globalThis.global || globalThis;
		globalThis.global.module = {};
		await loadScript(WEBGL_DEBUG_CDN_URL);
	}
}
function makeDebugContext(gl, props = {}) {
	return props.debugWebGL || props.traceWebGL ? getDebugContext(gl, props) : getRealContext(gl);
}
function getRealContext(gl) {
	const data = getWebGLContextData(gl);
	return data.realContext ? data.realContext : gl;
}
function getDebugContext(gl, props) {
	if (!globalThis.WebGLDebugUtils) {
		log.warn("webgl-debug not loaded")();
		return gl;
	}
	const data = getWebGLContextData(gl);
	if (data.debugContext) return data.debugContext;
	globalThis.WebGLDebugUtils.init({
		...GLEnum,
		...gl
	});
	const glDebug = globalThis.WebGLDebugUtils.makeDebugContext(gl, onGLError.bind(null, props), onValidateGLFunc.bind(null, props));
	for (const key in GLEnum) if (!(key in glDebug) && typeof GLEnum[key] === "number") glDebug[key] = GLEnum[key];
	class WebGLDebugContext {}
	Object.setPrototypeOf(glDebug, Object.getPrototypeOf(gl));
	Object.setPrototypeOf(WebGLDebugContext, glDebug);
	const debugContext = Object.create(WebGLDebugContext);
	data.realContext = gl;
	data.debugContext = debugContext;
	debugContext.debug = true;
	return debugContext;
}
function getFunctionString(functionName, functionArgs) {
	functionArgs = Array.from(functionArgs).map((arg) => arg === void 0 ? "undefined" : arg);
	let args = globalThis.WebGLDebugUtils.glFunctionArgsToString(functionName, functionArgs);
	args = `${args.slice(0, 100)}${args.length > 100 ? "..." : ""}`;
	return `gl.${functionName}(${args})`;
}
function onGLError(props, err, functionName, args) {
	args = Array.from(args).map((arg) => arg === void 0 ? "undefined" : arg);
	const message = `${globalThis.WebGLDebugUtils.glEnumToString(err)} in gl.${functionName}(${globalThis.WebGLDebugUtils.glFunctionArgsToString(functionName, args)})`;
	log.error(message)();
	debugger;
}
function onValidateGLFunc(props, functionName, functionArgs) {
	let functionString = "";
	if (log.level >= 1) {
		functionString = getFunctionString(functionName, functionArgs);
		if (props.traceWebGL) log.log(1, functionString)();
	}
	for (const arg of functionArgs) if (arg === void 0) {
		functionString = functionString || getFunctionString(functionName, functionArgs);
		debugger;
	}
}

//#endregion
export { getBrowser as C, Log as S, Resource as _, loadSpectorJS as a, lumaStats as b, DeviceLimits as c, getVertexFormatFromAttribute as d, getVertexFormatInfo as f, Buffer as g, getTypedArrayConstructor as h, initializeSpectorJS as i, textureFormatDecoder as l, getDataType as m, makeDebugContext as n, Device as o, alignTo as p, DEFAULT_SPECTOR_PROPS as r, DeviceFeatures as s, loadWebGLDeveloperTools as t, getCompatibleVertexFormat as u, uid as v, isBrowser as w, Stats as x, log as y };
//# sourceMappingURL=webgl-developer-tools-DgucggGC.js.map