!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).geojsonvt=e()}(this,(function(){"use strict";function t(o,n,i,s){let r=s;const l=n+(i-n>>1);let a,c=i-n;const u=o[n],m=o[n+1],f=o[i],d=o[i+1];for(let t=n+3;t<i;t+=3){const n=e(o[t],o[t+1],u,m,f,d);if(n>r)a=t,r=n;else if(n===r){const e=Math.abs(t-l);e<c&&(a=t,c=e)}}r>s&&(a-n>3&&t(o,n,a,s),o[a+2]=r,i-a>3&&t(o,a,i,s))}function e(t,e,o,n,i,s){let r=i-o,l=s-n;if(0!==r||0!==l){const a=((t-o)*r+(e-n)*l)/(r*r+l*l);a>1?(o=i,n=s):a>0&&(o+=r*a,n+=l*a)}return r=t-o,l=e-n,r*r+l*l}function o(t,e,o,i){const s={type:e,geom:o},r={id:null==t?null:t,type:s.type,geometry:s.geom,tags:i,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0};switch(s.type){case"Point":case"MultiPoint":case"LineString":n(r,s.geom);break;case"Polygon":n(r,s.geom[0]);break;case"MultiLineString":for(const t of s.geom)n(r,t);break;case"MultiPolygon":for(const t of s.geom)n(r,t[0])}return r}function n(t,e){for(let o=0;o<e.length;o+=3)t.minX=Math.min(t.minX,e[o]),t.minY=Math.min(t.minY,e[o+1]),t.maxX=Math.max(t.maxX,e[o]),t.maxY=Math.max(t.maxY,e[o+1])}function i(t,e){const o=[];switch(t.type){case"FeatureCollection":for(let n=0;n<t.features.length;n++)s(o,t.features[n],e,n);break;case"Feature":s(o,t,e);break;default:s(o,{geometry:t,properties:void 0},e)}return o}function s(t,e,n,i){if(!e.geometry)return;if("GeometryCollection"===e.geometry.type){for(const o of e.geometry.geometries)s(t,{id:e.id,geometry:o,properties:e.properties},n,i);return}const c=e.geometry.coordinates;if(!c?.length)return;const u=Math.pow(n.tolerance/((1<<n.maxZoom)*n.extent),2);let m=e.id;switch(n.promoteId?m=e.properties?.[n.promoteId]:n.generateId&&(m=i||0),e.geometry.type){case"Point":{const n=[];return r(e.geometry.coordinates,n),void t.push(o(m,e.geometry.type,n,e.properties))}case"MultiPoint":{const n=[];for(const t of e.geometry.coordinates)r(t,n);return void t.push(o(m,e.geometry.type,n,e.properties))}case"LineString":{const n=[];return l(e.geometry.coordinates,n,u,!1),void t.push(o(m,e.geometry.type,n,e.properties))}case"MultiLineString":{if(n.lineMetrics){for(const n of e.geometry.coordinates){const i=[];l(n,i,u,!1),t.push(o(m,"LineString",i,e.properties))}return}const i=[];return a(e.geometry.coordinates,i,u,!1),void t.push(o(m,e.geometry.type,i,e.properties))}case"Polygon":{const n=[];return a(e.geometry.coordinates,n,u,!0),void t.push(o(m,e.geometry.type,n,e.properties))}case"MultiPolygon":{const n=[];for(const t of e.geometry.coordinates){const e=[];a(t,e,u,!0),n.push(e)}return void t.push(o(m,e.geometry.type,n,e.properties))}default:throw new Error("Input data is not a valid GeoJSON object.")}}function r(t,e){e.push(c(t[0]),u(t[1]),0)}function l(e,o,n,i){let s,r,l=0;for(let t=0;t<e.length;t++){const n=c(e[t][0]),a=u(e[t][1]);o.push(n,a,0),t>0&&(l+=i?(s*a-n*r)/2:Math.sqrt(Math.pow(n-s,2)+Math.pow(a-r,2))),s=n,r=a}const a=o.length-3;o[2]=1,n>0&&t(o,0,a,n),o[a+2]=1,o.size=Math.abs(l),o.start=0,o.end=o.size}function a(t,e,o,n){for(let i=0;i<t.length;i++){const s=[];l(t[i],s,o,n),e.push(s)}}function c(t){return t/360+.5}function u(t){const e=Math.sin(t*Math.PI/180),o=.5-.25*Math.log((1+e)/(1-e))/Math.PI;return o<0?0:o>1?1:o}function m(t,e,n,i,s,r,l,a){if(i/=e,r>=(n/=e)&&l<i)return t;if(l<n||r>=i)return null;const c=[];for(const e of t){const t=0===s?e.minX:e.minY,r=0===s?e.maxX:e.maxY;if(t>=n&&r<i)c.push(e);else if(!(r<n||t>=i))switch(e.type){case"Point":case"MultiPoint":{const t=[];if(f(e.geometry,t,n,i,s),!t.length)continue;const r=3===t.length?"Point":"MultiPoint";c.push(o(e.id,r,t,e.tags));continue}case"LineString":{const t=[];if(d(e.geometry,t,n,i,s,!1,a.lineMetrics),!t.length)continue;if(a.lineMetrics){for(const n of t)c.push(o(e.id,e.type,n,e.tags));continue}if(t.length>1){c.push(o(e.id,"MultiLineString",t,e.tags));continue}c.push(o(e.id,e.type,t[0],e.tags));continue}case"MultiLineString":{const t=[];if(g(e.geometry,t,n,i,s,!1),!t.length)continue;if(1===t.length){c.push(o(e.id,"LineString",t[0],e.tags));continue}c.push(o(e.id,e.type,t,e.tags));continue}case"Polygon":{const t=[];if(g(e.geometry,t,n,i,s,!0),!t.length)continue;c.push(o(e.id,e.type,t,e.tags));continue}case"MultiPolygon":{const t=[];for(const o of e.geometry){const e=[];g(o,e,n,i,s,!0),e.length&&t.push(e)}if(!t.length)continue;c.push(o(e.id,e.type,t,e.tags));continue}}}return c.length?c:null}function f(t,e,o,n,i){for(let s=0;s<t.length;s+=3){const r=t[s+i];r>=o&&r<=n&&h(e,t[s],t[s+1],t[s+2])}}function d(t,e,o,n,i,s,r){let l=p(t);const a=0===i?y:x;let c,u,m=t.start;for(let f=0;f<t.length-3;f+=3){const d=t[f],g=t[f+1],y=t[f+2],x=t[f+3],M=t[f+4],P=0===i?d:g,b=0===i?x:M;let w=!1;r&&(c=Math.sqrt(Math.pow(d-x,2)+Math.pow(g-M,2))),P<o?b>o&&(u=a(l,d,g,x,M,o),r&&(l.start=m+c*u)):P>n?b<n&&(u=a(l,d,g,x,M,n),r&&(l.start=m+c*u)):h(l,d,g,y),b<o&&P>=o&&(u=a(l,d,g,x,M,o),w=!0),b>n&&P<=n&&(u=a(l,d,g,x,M,n),w=!0),!s&&w&&(r&&(l.end=m+c*u),e.push(l),l=p(t)),r&&(m+=c)}let f=t.length-3;const d=t[f],g=t[f+1],M=t[f+2],P=0===i?d:g;P>=o&&P<=n&&h(l,d,g,M),f=l.length-3,s&&f>=3&&(l[f]!==l[0]||l[f+1]!==l[1])&&h(l,l[0],l[1],l[2]),l.length&&e.push(l)}function p(t){const e=[];return e.size=t.size,e.start=t.start,e.end=t.end,e}function g(t,e,o,n,i,s){for(const r of t)d(r,e,o,n,i,s,!1)}function h(t,e,o,n){t.push(e,o,n)}function y(t,e,o,n,i,s){const r=(s-e)/(n-e);return h(t,s,o+(i-o)*r,1),r}function x(t,e,o,n,i,s){const r=(s-o)/(i-o);return h(t,e+(n-e)*r,s,1),r}function M(t,e){const o=e.buffer/e.extent;let n=t;const i=m(t,1,-1-o,o,0,-1,2,e),s=m(t,1,1-o,2+o,0,-1,2,e);return i||s?(n=m(t,1,-o,1+o,0,-1,2,e)||[],i&&(n=P(i,1).concat(n)),s&&(n=n.concat(P(s,-1))),n):n}function P(t,e){const n=[];for(const i of t)switch(i.type){case"Point":case"MultiPoint":case"LineString":{const t=b(i.geometry,e);n.push(o(i.id,i.type,t,i.tags));continue}case"MultiLineString":case"Polygon":{const t=[];for(const o of i.geometry)t.push(b(o,e));n.push(o(i.id,i.type,t,i.tags));continue}case"MultiPolygon":{const t=[];for(const o of i.geometry){const n=[];for(const t of o)n.push(b(t,e));t.push(n)}n.push(o(i.id,i.type,t,i.tags));continue}}return n}function b(t,e){const o=[];o.size=t.size,void 0!==t.start&&(o.start=t.start,o.end=t.end);for(let n=0;n<t.length;n+=3)o.push(t[n]+e,t[n+1],t[n+2]);return o}function w(t,e){if(t.transformed)return t;const o=1<<t.z,n=t.x,i=t.y;for(const s of t.features){if(1===s.type){const t=[];for(let r=0;r<s.geometry.length;r+=2)t.push(v(s.geometry[r],s.geometry[r+1],e,o,n,i));s.geometry=t;continue}const t=[];for(const r of s.geometry){const s=[];for(let t=0;t<r.length;t+=2)s.push(v(r[t],r[t+1],e,o,n,i));t.push(s)}s.geometry=t}return t.transformed=!0,t}function v(t,e,o,n,i,s){return[Math.round(o*(t*n-i)),Math.round(o*(e*n-s))]}function z(t,e,o,n,i){const s=e===i.maxZoom?0:i.tolerance/((1<<e)*i.extent),r={features:[],numPoints:0,numSimplified:0,numFeatures:t.length,source:null,x:o,y:n,z:e,transformed:!1,minX:2,minY:1,maxX:-1,maxY:0};for(const e of t)Y(r,e,s,i);return r}function Y(t,e,o,n){t.minX=Math.min(t.minX,e.minX),t.minY=Math.min(t.minY,e.minY),t.maxX=Math.max(t.maxX,e.maxX),t.maxY=Math.max(t.maxY,e.maxY);let i,s=e.tags||null;switch(e.type){case"Point":case"MultiPoint":{const o=[];for(let n=0;n<e.geometry.length;n+=3)o.push(e.geometry[n],e.geometry[n+1]),t.numPoints++,t.numSimplified++;if(!o.length)return;i={type:1,tags:s,geometry:o};break}case"LineString":{const r=[];if(S(r,e.geometry,t,o,!1,!1),!r.length)return;if(n.lineMetrics){s={};for(const t in e.tags)s[t]=e.tags[t];s.mapbox_clip_start=e.geometry.start/e.geometry.size,s.mapbox_clip_end=e.geometry.end/e.geometry.size}i={type:2,tags:s,geometry:r};break}case"MultiLineString":case"Polygon":{const n=[];for(let i=0;i<e.geometry.length;i++)S(n,e.geometry[i],t,o,"Polygon"===e.type,0===i);if(!n.length)return;i={type:"Polygon"===e.type?3:2,tags:s,geometry:n};break}case"MultiPolygon":{const n=[];for(let i=0;i<e.geometry.length;i++){const s=e.geometry[i];for(let e=0;e<s.length;e++)S(n,s[e],t,o,!0,0===e)}if(!n.length)return;i={type:3,tags:s,geometry:n};break}}null!==e.id&&(i.id=e.id),t.features.push(i)}function S(t,e,o,n,i,s){const r=n*n;if(n>0&&e.size<(i?r:n))return void(o.numPoints+=e.length/3);const l=[];for(let t=0;t<e.length;t+=3)(0===n||e[t+2]>r)&&(o.numSimplified++,l.push(e[t],e[t+1])),o.numPoints++;i&&function(t,e){let o=0;for(let e=0,n=t.length,i=n-2;e<n;i=e,e+=2)o+=(t[e]-t[i])*(t[e+1]+t[i+1]);if(o>0!==e)return;for(let e=0,o=t.length;e<o/2;e+=2){const n=t[e],i=t[e+1];t[e]=t[o-2-e],t[e+1]=t[o-1-e],t[o-2-e]=n,t[o-1-e]=i}}(l,s),t.push(l)}function X(t,e,o){const n=function(t){if(!t)return{remove:new Set,add:new Map,update:new Map};const e={removeAll:t.removeAll,remove:new Set(t.remove||[]),add:new Map(t.add?.map((t=>[t.id,t]))),update:new Map(t.update?.map((t=>[t.id,t])))};return e}(e);let s=[];if(n.removeAll&&(s=t,t=[]),n.remove.size||n.add.size){const e=[];for(const o of t){const{id:t}=o;(n.remove.has(t)||n.add.has(t))&&e.push(o)}if(e.length){s.push(...e);const o=new Set(e.map((t=>t.id)));t=t.filter((t=>!o.has(t.id)))}if(n.add.size){let e=i({type:"FeatureCollection",features:Array.from(n.add.values())},o);e=M(e,o),s.push(...e),t.push(...e)}}if(n.update.size)for(const[e,i]of n.update){const n=t.findIndex((t=>t.id===e));if(-1===n)continue;const r=t[n],l=I(r,i,o);l&&(s.push(r,l),t[n]=l)}return{affected:s,source:t}}function I(t,e,o){const n=!!e.newGeometry,s=e.removeAllProperties||e.removeProperties?.length>0||e.addOrUpdateProperties?.length>0;if(n){let n=i({type:"FeatureCollection",features:[{type:"Feature",id:t.id,geometry:e.newGeometry,properties:s?L(t.tags,e):t.tags}]},o);return n=M(n,o),n[0]}if(s){const o={...t};return o.tags=L(o.tags,e),o}return null}function L(t,e){if(e.removeAllProperties)return{};const o={...t||{}};if(e.removeProperties)for(const t of e.removeProperties)delete o[t];if(e.addOrUpdateProperties)for(const{key:t,value:n}of e.addOrUpdateProperties)o[t]=n;return o}const k={maxZoom:14,indexMaxZoom:5,indexMaxPoints:1e5,tolerance:3,extent:4096,buffer:64,lineMetrics:!1,promoteId:null,generateId:!1,updateable:!1,debug:0};class Z{options;tiles;tileCoords;stats={};total=0;source;constructor(t,e){const o=(e=this.options=Object.assign({},k,e)).debug;if(o&&console.time("preprocess data"),e.maxZoom<0||e.maxZoom>24)throw new Error("maxZoom should be in the 0-24 range");if(e.promoteId&&e.generateId)throw new Error("promoteId and generateId cannot be used together.");let n=i(t,e);this.tiles={},this.tileCoords=[],o&&(console.timeEnd("preprocess data"),console.log("index: maxZoom: %d, maxPoints: %d",e.indexMaxZoom,e.indexMaxPoints),console.time("generate tiles"),this.stats={},this.total=0),n=M(n,e),n.length&&this.splitTile(n,0,0,0),e.updateable&&(this.source=n),o&&(n.length&&console.log("features: %d, points: %d",this.tiles[0].numFeatures,this.tiles[0].numPoints),console.timeEnd("generate tiles"),console.log("tiles generated:",this.total,JSON.stringify(this.stats)))}splitTile(t,e,o,n,i,s,r){const l=[t,e,o,n],a=this.options,c=a.debug;for(;l.length;){n=l.pop(),o=l.pop(),e=l.pop(),t=l.pop();const u=1<<e,f=C(e,o,n);let d=this.tiles[f];if(!d&&(c>1&&console.time("creation"),d=this.tiles[f]=z(t,e,o,n,a),this.tileCoords.push({z:e,x:o,y:n,id:f}),c)){c>1&&(console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",e,o,n,d.numFeatures,d.numPoints,d.numSimplified),console.timeEnd("creation"));const t=`z${e}`;this.stats[t]=(this.stats[t]||0)+1,this.total++}if(d.source=t,null==i){if(e===a.indexMaxZoom||d.numPoints<=a.indexMaxPoints)continue}else{if(e===a.maxZoom||e===i)continue;if(null!=i){const t=i-e;if(o!==s>>t||n!==r>>t)continue}}if(d.source=null,!t.length)continue;c>1&&console.time("clipping");const p=.5*a.buffer/a.extent,g=.5-p,h=.5+p,y=1+p;let x=null,M=null,P=null,b=null;const w=m(t,u,o-p,o+h,0,d.minX,d.maxX,a),v=m(t,u,o+g,o+y,0,d.minX,d.maxX,a);w&&(x=m(w,u,n-p,n+h,1,d.minY,d.maxY,a),M=m(w,u,n+g,n+y,1,d.minY,d.maxY,a)),v&&(P=m(v,u,n-p,n+h,1,d.minY,d.maxY,a),b=m(v,u,n+g,n+y,1,d.minY,d.maxY,a)),c>1&&console.timeEnd("clipping"),l.push(x||[],e+1,2*o,2*n),l.push(M||[],e+1,2*o,2*n+1),l.push(P||[],e+1,2*o+1,2*n),l.push(b||[],e+1,2*o+1,2*n+1)}}getTile(t,e,o){t=+t,e=+e,o=+o;const n=this.options,{extent:i,debug:s}=n;if(t<0||t>24)return null;const r=1<<t,l=C(t,e=e+r&r-1,o);if(this.tiles[l])return w(this.tiles[l],i);s>1&&console.log("drilling down to z%d-%d-%d",t,e,o);let a,c=t,u=e,m=o;for(;!a&&c>0;)c--,u>>=1,m>>=1,a=this.tiles[C(c,u,m)];return a?.source?(s>1&&(console.log("found parent tile z%d-%d-%d",c,u,m),console.time("drilling down")),this.splitTile(a.source,c,u,m,t,e,o),s>1&&console.timeEnd("drilling down"),this.tiles[l]?w(this.tiles[l],i):null):null}invalidateTiles(t){const e=this.options,{debug:o}=e;let n=1/0,i=-1/0,s=1/0,r=-1/0;for(const e of t)n=Math.min(n,e.minX),i=Math.max(i,e.maxX),s=Math.min(s,e.minY),r=Math.max(r,e.maxY);const l=e.buffer/e.extent,a=new Set;for(const e in this.tiles){const c=this.tiles[e],u=1<<c.z,m=(c.x-l)/u,f=(c.x+1+l)/u,d=(c.y-l)/u,p=(c.y+1+l)/u;if(i<m||n>=f||r<d||s>=p)continue;let g=!1;for(const e of t)if(e.maxX>=m&&e.minX<f&&e.maxY>=d&&e.minY<p){g=!0;break}if(g){if(o){o>1&&console.log("invalidate tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",c.z,c.x,c.y,c.numFeatures,c.numPoints,c.numSimplified);const t=`z${c.z}`;this.stats[t]=(this.stats[t]||0)-1,this.total--}delete this.tiles[e],a.add(e)}}a.size&&(this.tileCoords=this.tileCoords.filter((t=>!a.has(t.id))))}updateData(t){const e=this.options,o=e.debug;if(!e.updateable)throw new Error("to update tile geojson `updateable` option must be set to true");const{affected:n,source:i}=X(this.source,t,e);if(!n.length)return;this.source=i,o>1&&(console.log("invalidating tiles"),console.time("invalidating")),this.invalidateTiles(n),o>1&&console.timeEnd("invalidating");const[s,r,l]=[0,0,0],a=z(this.source,s,r,l,this.options);a.source=this.source;const c=C(s,r,l);if(this.tiles[c]=a,this.tileCoords.push({z:s,x:r,y:l,id:c}),o){const t=`z${s}`;this.stats[t]=(this.stats[t]||0)+1,this.total++}}}function C(t,e,o){return 32*((1<<t)*o+e)+t}return function(t,e){return new Z(t,e)}}));
