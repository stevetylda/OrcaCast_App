{"version":3,"file":"mltDecoder.spec.js","sourceRoot":"","sources":["../src/mltDecoder.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import { expect, describe, it } from \"vitest\";\nimport { readdirSync, readFileSync } from \"fs\";\nimport { parse, join } from \"path\";\nimport { VectorTile, type VectorTileFeature } from \"@mapbox/vector-tile\";\nimport Pbf from \"pbf\";\n\nimport { type FeatureTable, type Feature, decodeTile } from \".\";\nimport path from \"node:path\";\nimport fs from \"node:fs\";\n\nconst ITERATOR_TILE = path.resolve(__dirname, \"../../test/expected/tag0x01/simple/multiline-boolean.mlt\");\n\ndescribe(\"MLT Decoder - MVT comparison for SIMPLE tiles\", () => {\n    const simpleMltTileDir = \"../test/expected/tag0x01/simple\";\n    const simpleMvtTileDir = \"../test/fixtures/simple\";\n    testTiles(simpleMltTileDir, simpleMvtTileDir);\n});\n\ndescribe(\"MLT Decoder - MVT comparison for Amazon tiles\", () => {\n    const amazonMltTileDir = \"../test/expected/tag0x01/amazon\";\n    const amazonMvtTileDir = \"../test/fixtures/amazon\";\n    testTiles(amazonMltTileDir, amazonMvtTileDir);\n});\n\ndescribe(\"MLT Decoder - MVT comparison for OMT tiles\", () => {\n    const omtMltTileDir = \"../test/expected/tag0x01/omt\";\n    const omtMvtTileDir = \"../test/fixtures/omt\";\n    testTiles(omtMltTileDir, omtMvtTileDir);\n}, 150000);\n\ndescribe(\"FeatureTable\", () => {\n    it(\"should iterate through features correctly\", () => {\n        const bytes = new Uint8Array(fs.readFileSync(ITERATOR_TILE));\n        const featureTables = decodeTile(bytes);\n\n        const table = featureTables[0];\n\n        expect(table.name).toBe(\"layer\");\n        expect(table.extent).toBe(4096);\n\n        let featureCount = 0;\n        for (const feature of table) {\n            expect(feature.geometry).toBeTruthy();\n            expect(feature.geometry.coordinates).toBeInstanceOf(Array);\n            expect(feature.geometry.coordinates.length).toBeGreaterThan(0);\n            expect(typeof feature.geometry.type).toBe(\"number\");\n\n            featureCount++;\n        }\n        expect(featureCount).toBe(table.numFeatures);\n    });\n});\n\nfunction testTiles(mltSearchDir: string, mvtSearchDir: string) {\n    const mltFileNames = readdirSync(mltSearchDir)\n        .filter((file) => parse(file).ext === \".mlt\")\n        .map((file) => parse(file).name);\n    for (const fileName of mltFileNames) {\n        it(`should compare ${fileName} tile`, () => {\n            const mltFileName = `${fileName}.mlt`;\n            const mltPath = join(mltSearchDir, mltFileName);\n            const mvtPath = join(mvtSearchDir, `${fileName}.mvt`);\n\n            const encodedMvt = readFileSync(mvtPath);\n            const encodedMlt = readFileSync(mltPath);\n            const buf = new Pbf(encodedMvt);\n            const decodedMvt = new VectorTile(buf);\n\n            const decodedMlt = decodeTile(encodedMlt, undefined, true);\n            comparePlainGeometryEncodedTile(decodedMlt, decodedMvt);\n        });\n    }\n}\n\nfunction removeEmptyStrings(mvtProperties: Record<string, any>) {\n    for (const key of Object.keys(mvtProperties)) {\n        const value = mvtProperties[key];\n        if (typeof value === \"string\" && !value.length) {\n            delete mvtProperties[key];\n        }\n    }\n}\n\nfunction comparePlainGeometryEncodedTile(mlt: FeatureTable[], mvt: VectorTile) {\n    for (const featureTable of mlt) {\n        const layer = mvt.layers[featureTable.name];\n\n        // Use getFeatures() instead of iterator (like C++ and Java implementations)\n        const mltFeatures = featureTable.getFeatures();\n\n        expect(mltFeatures.length).toBe(layer.length);\n\n        for (let j = 0; j < layer.length; j++) {\n            const mvtFeature = layer.feature(j);\n            const mltFeature = mltFeatures[j];\n\n            compareId(mltFeature, mvtFeature, true);\n\n            const mltGeometry = mltFeature.geometry?.coordinates;\n            const mvtGeometry = mvtFeature.loadGeometry();\n            expect(mltGeometry).toEqual(mvtGeometry);\n\n            const mltProperties = mltFeature.properties;\n            const mvtProperties = mvtFeature.properties;\n            transformPropertyNames(mltProperties);\n            transformPropertyNames(mvtProperties);\n            convertBigIntPropertyValues(mltProperties);\n            //TODO: fix -> since a change in the java converter shared dictionary encoding empty strings are not\n            //encoded anymore\n            removeEmptyStrings(mvtProperties);\n            removeEmptyStrings(mltProperties);\n\n            expect(Object.keys(mltProperties).length).toEqual(Object.keys(mvtProperties).length);\n            expect(mltProperties).toEqual(mvtProperties);\n        }\n    }\n}\n\nfunction compareId(mltFeature: Feature, mvtFeature: VectorTileFeature, idWithinMaxSafeInteger: boolean) {\n    if (!mvtFeature.id) {\n        /* Java MVT library in the MVT converter decodes zero for undefined ids */\n        expect([0, null, 0n]).toContain(mltFeature.id);\n    } else {\n        const mltFeatureId = mltFeature.id;\n        /* For const and sequence vectors the decoder can return bigint compared to the vector-tile-js library */\n        const actualId =\n            idWithinMaxSafeInteger && typeof mltFeatureId !== \"bigint\" ? mltFeatureId : Number(mltFeatureId);\n        /*\n         * The id check can fail for two known reasons:\n         * - The java-vector-tile library used in the Java converter returns negative integers for the\n         *   unoptimized tileset in some tiles\n         * - The vector-tile-js library is using number types for the id so there can only be stored\n         *   values up to 53 bits without loss of precision\n         **/\n        if (mltFeatureId < 0 || mltFeatureId > Number.MAX_SAFE_INTEGER) {\n            /* Expected to fail in some/most cases */\n            try {\n                expect(actualId).toEqual(mvtFeature.id);\n            } catch (e) {\n                //console.info(\"id mismatch\", featureTableName, mltFeatureId, mvtFeature.id);\n            }\n            return;\n        }\n\n        expect(actualId).toEqual(mvtFeature.id);\n    }\n}\n\n/* Change bigint to number for comparison with MVT */\nfunction convertBigIntPropertyValues(mltProperties: Record<string, any>) {\n    for (const key of Object.keys(mltProperties)) {\n        if (typeof mltProperties[key] === \"bigint\") {\n            mltProperties[key] = Number(mltProperties[key]);\n        }\n    }\n}\n\nfunction transformPropertyNames(properties: Record<string, any>) {\n    const propertyNames = Object.keys(properties);\n    for (let k = 0; k < propertyNames.length; k++) {\n        const key = propertyNames[k];\n\n        let newKey = key;\n        /* rename the property names which are separated with : in mlt to match _ in omt mvts */\n        if (key.startsWith(\"name\") && key.includes(\":\")) {\n            newKey = (key as any).replaceAll(\":\", \"_\");\n            properties[newKey] = properties[key];\n            delete properties[key];\n        }\n\n        /* Currently id is not supported as a property name in a FeatureTable,\n         *  so this quick workaround is implemented */\n        if (newKey === \"_id\") {\n            properties[\"id\"] = properties[newKey];\n            delete properties[newKey];\n        }\n    }\n}\n"]}