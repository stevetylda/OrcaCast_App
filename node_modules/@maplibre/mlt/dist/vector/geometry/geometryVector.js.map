{"version":3,"file":"geometryVector.js","sourceRoot":"","sources":["../../../src/vector/geometry/geometryVector.ts"],"names":[],"mappings":"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","sourcesContent":["import type TopologyVector from \"../../vector/geometry/topologyVector\";\nimport { convertGeometryVector } from \"./geometryVectorConverter\";\nimport { decodeZOrderCurve } from \"./zOrderCurve\";\nimport { type GEOMETRY_TYPE } from \"./geometryType\";\nimport { type VertexBufferType } from \"./vertexBufferType\";\nimport type Point from \"@mapbox/point-geometry\";\n\nexport type CoordinatesArray = Array<Array<Point>>;\n\nexport type Geometry = {\n    coordinates: CoordinatesArray;\n    type: GEOMETRY_TYPE;\n};\n\nexport interface MortonSettings {\n    numBits: number;\n    coordinateShift: number;\n}\n\nexport abstract class GeometryVector implements Iterable<Geometry> {\n    protected constructor(\n        private readonly _vertexBufferType: VertexBufferType,\n        private readonly _topologyVector: TopologyVector,\n        private readonly _vertexOffsets: Int32Array,\n        private readonly _vertexBuffer: Int32Array,\n        private readonly _mortonSettings?: MortonSettings,\n    ) {}\n\n    get vertexBufferType(): VertexBufferType {\n        return this._vertexBufferType;\n    }\n\n    get topologyVector(): TopologyVector {\n        return this._topologyVector;\n    }\n\n    get vertexOffsets(): Int32Array {\n        return this._vertexOffsets;\n    }\n\n    get vertexBuffer(): Int32Array {\n        return this._vertexBuffer;\n    }\n    *[Symbol.iterator](): Iterator<Geometry> {\n        const geometries = convertGeometryVector(this);\n        let index = 0;\n\n        while (index < this.numGeometries) {\n            yield { coordinates: geometries[index], type: this.geometryType(index) };\n            index++;\n        }\n    }\n\n    /* Allows faster access to the vertices since morton encoding is currently not used in the POC. Morton encoding\n       will be used after adapting the shader to decode the morton codes on the GPU. */\n    getSimpleEncodedVertex(index: number): [number, number] {\n        const offset = this.vertexOffsets ? this.vertexOffsets[index] * 2 : index * 2;\n        const x = this.vertexBuffer[offset];\n        const y = this.vertexBuffer[offset + 1];\n        return [x, y];\n    }\n\n    //TODO: add scaling information to the constructor\n    getVertex(index: number): [number, number] {\n        if (this.vertexOffsets && this.mortonSettings) {\n            //TODO: move decoding of the morton codes on the GPU in the vertex shader\n            const vertexOffset = this.vertexOffsets[index];\n            const mortonEncodedVertex = this.vertexBuffer[vertexOffset];\n            //TODO: improve performance -> inline calculation and move to decoding of VertexBuffer\n            const vertex = decodeZOrderCurve(\n                mortonEncodedVertex,\n                this.mortonSettings.numBits,\n                this.mortonSettings.coordinateShift,\n            );\n            return [vertex.x, vertex.y];\n        }\n\n        const offset = this.vertexOffsets ? this.vertexOffsets[index] * 2 : index * 2;\n        const x = this.vertexBuffer[offset];\n        const y = this.vertexBuffer[offset + 1];\n        return [x, y];\n    }\n\n    getGeometries(): CoordinatesArray[] {\n        return convertGeometryVector(this);\n    }\n\n    get mortonSettings(): MortonSettings | undefined {\n        return this._mortonSettings;\n    }\n\n    abstract containsPolygonGeometry(): boolean;\n\n    abstract geometryType(index: number): number;\n\n    abstract get numGeometries(): number;\n\n    abstract containsSingleGeometryType(): boolean;\n}\n"]}