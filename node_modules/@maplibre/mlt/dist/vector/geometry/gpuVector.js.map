{"version":3,"file":"gpuVector.js","sourceRoot":"","sources":["../../../src/vector/geometry/gpuVector.ts"],"names":[],"mappings":"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","sourcesContent":["import Point from \"@mapbox/point-geometry\";\nimport { GEOMETRY_TYPE } from \"./geometryType\";\nimport { type CoordinatesArray } from \"./geometryVector\";\nimport type TopologyVector from \"./topologyVector\";\n\nexport abstract class GpuVector implements Iterable<CoordinatesArray> {\n    protected constructor(\n        private readonly _triangleOffsets: Int32Array,\n        private readonly _indexBuffer: Int32Array,\n        private readonly _vertexBuffer: Int32Array,\n        private readonly _topologyVector?: TopologyVector | null,\n    ) {}\n\n    abstract geometryType(index: number): number;\n\n    abstract get numGeometries(): number;\n\n    abstract containsSingleGeometryType(): boolean;\n\n    get triangleOffsets(): Int32Array {\n        return this._triangleOffsets;\n    }\n\n    get indexBuffer(): Int32Array {\n        return this._indexBuffer;\n    }\n\n    get vertexBuffer(): Int32Array {\n        return this._vertexBuffer;\n    }\n\n    get topologyVector(): TopologyVector | null {\n        return this._topologyVector;\n    }\n\n    /**\n     * Returns geometries as coordinate arrays by extracting polygon outlines from topology.\n     * The vertexBuffer contains the outline vertices, separate from the tessellated triangles.\n     */\n    getGeometries(): CoordinatesArray[] {\n        if (!this._topologyVector) {\n            throw new Error(\"Cannot convert GpuVector to coordinates without topology information\");\n        }\n\n        const geometries: CoordinatesArray[] = new Array(this.numGeometries);\n        const topology = this._topologyVector;\n        const partOffsets = topology.partOffsets;\n        const ringOffsets = topology.ringOffsets;\n        const geometryOffsets = topology.geometryOffsets;\n\n        // Use counters to track position in offset arrays (like Java implementation)\n        let vertexBufferOffset = 0;\n        let partOffsetCounter = 1;\n        let ringOffsetsCounter = 1;\n        let geometryOffsetsCounter = 1;\n\n        for (let i = 0; i < this.numGeometries; i++) {\n            const geometryType = this.geometryType(i);\n\n            switch (geometryType) {\n                case GEOMETRY_TYPE.POLYGON:\n                    {\n                        // Get number of rings for this polygon\n                        const numRings = partOffsets[partOffsetCounter] - partOffsets[partOffsetCounter - 1];\n                        partOffsetCounter++;\n                        const rings: Point[][] = [];\n\n                        for (let j = 0; j < numRings; j++) {\n                            // Get number of vertices in this ring\n                            const numVertices = ringOffsets[ringOffsetsCounter] - ringOffsets[ringOffsetsCounter - 1];\n                            ringOffsetsCounter++;\n                            const ring: Point[] = [];\n\n                            for (let k = 0; k < numVertices; k++) {\n                                const x = this._vertexBuffer[vertexBufferOffset++];\n                                const y = this._vertexBuffer[vertexBufferOffset++];\n                                ring.push(new Point(x, y));\n                            }\n                            // Close the ring by duplicating the first vertex (MVT format requirement)\n                            if (ring.length > 0) {\n                                ring.push(ring[0]);\n                            }\n                            rings.push(ring);\n                        }\n\n                        geometries[i] = rings;\n                        if (geometryOffsets) geometryOffsetsCounter++;\n                    }\n                    break;\n                case GEOMETRY_TYPE.MULTIPOLYGON:\n                    {\n                        // Get number of polygons in this multipolygon\n                        const numPolygons =\n                            geometryOffsets[geometryOffsetsCounter] - geometryOffsets[geometryOffsetsCounter - 1];\n                        geometryOffsetsCounter++;\n                        const allRings: Point[][] = [];\n\n                        for (let p = 0; p < numPolygons; p++) {\n                            // Get number of rings in this polygon\n                            const numRings = partOffsets[partOffsetCounter] - partOffsets[partOffsetCounter - 1];\n                            partOffsetCounter++;\n\n                            for (let j = 0; j < numRings; j++) {\n                                // Get number of vertices in this ring\n                                const numVertices =\n                                    ringOffsets[ringOffsetsCounter] - ringOffsets[ringOffsetsCounter - 1];\n                                ringOffsetsCounter++;\n                                const ring: Point[] = [];\n\n                                for (let k = 0; k < numVertices; k++) {\n                                    const x = this._vertexBuffer[vertexBufferOffset++];\n                                    const y = this._vertexBuffer[vertexBufferOffset++];\n                                    ring.push(new Point(x, y));\n                                }\n                                // Close the ring by duplicating the first vertex (MVT format requirement)\n                                if (ring.length > 0) {\n                                    ring.push(ring[0]);\n                                }\n                                allRings.push(ring);\n                            }\n                        }\n\n                        geometries[i] = allRings;\n                    }\n                    break;\n            }\n        }\n        return geometries;\n    }\n\n    [Symbol.iterator](): Iterator<CoordinatesArray> {\n        /*for(let i = 1; i < this.triangleOffsets.length; i++) {\n           const numTriangles = this.triangleOffsets[i] - this.triangleOffsets[i-1];\n           const startIndex = this.triangleOffsets[i-1] * 3;\n           const endIndex = this.triangleOffsets[i] * 3;\n       }\n\n        while (index < this.numGeometries) {\n            yield geometries[index++];\n        }*/\n\n        //throw new Error(\"Iterator on a GpuVector is not implemented yet.\");\n        return null;\n    }\n}\n"]}