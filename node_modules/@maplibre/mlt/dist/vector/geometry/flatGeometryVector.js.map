{"version":3,"file":"flatGeometryVector.js","sourceRoot":"","sources":["../../../src/vector/geometry/flatGeometryVector.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAuB,MAAM,kBAAkB,CAAC;AAEvE,OAAO,EAAE,aAAa,EAAE,MAAM,gBAAgB,CAAC;AAC/C,OAAO,EAAE,gBAAgB,EAAE,MAAM,oBAAoB,CAAC;AAEtD,MAAM,UAAU,wBAAwB,CACpC,aAAyB,EACzB,cAA8B,EAC9B,aAAyB,EACzB,YAAwB;IAExB,OAAO,IAAI,kBAAkB,CAAC,gBAAgB,CAAC,KAAK,EAAE,aAAa,EAAE,cAAc,EAAE,aAAa,EAAE,YAAY,CAAC,CAAC;AACtH,CAAC;AAED,MAAM,UAAU,qCAAqC,CACjD,aAAyB,EACzB,cAA8B,EAC9B,aAAyB,EACzB,YAAwB,EACxB,UAA0B;IAE1B,yCAAyC;IACzC,OAAO,IAAI,kBAAkB,CACzB,gBAAgB,CAAC,MAAM,EACvB,aAAa,EACb,cAAc,EACd,aAAa,EACb,YAAY,EACZ,UAAU,CACb,CAAC;AACN,CAAC;AAED,MAAM,OAAO,kBAAmB,SAAQ,cAAc;IAI7B;IAHrB,YACI,gBAAkC;IAClC,kCAAkC;IACjB,cAA0B,EAC3C,cAA8B,EAC9B,aAAyB,EACzB,YAAwB,EACxB,cAA+B;QAE/B,KAAK,CAAC,gBAAgB,EAAE,cAAc,EAAE,aAAa,EAAE,YAAY,EAAE,cAAc,CAAC,CAAC;QANpE,mBAAc,GAAd,cAAc,CAAY;IAO/C,CAAC;IAED,YAAY,CAAC,KAAa;QACtB,OAAO,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;IACtC,CAAC;IAED,IAAI,aAAa;QACb,OAAO,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC;IACtC,CAAC;IAED,uBAAuB;QACnB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC,EAAE,EAAE,CAAC;YAC1C,IAAI,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,KAAK,aAAa,CAAC,OAAO,IAAI,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,KAAK,aAAa,CAAC,YAAY,EAAE,CAAC;gBACxG,OAAO,IAAI,CAAC;YAChB,CAAC;QACL,CAAC;QACD,OAAO,KAAK,CAAC;IACjB,CAAC;IAED,0BAA0B;QACtB,OAAO,KAAK,CAAC;IACjB,CAAC;CACJ","sourcesContent":["import { GeometryVector, type MortonSettings } from \"./geometryVector\";\nimport type TopologyVector from \"../../vector/geometry/topologyVector\";\nimport { GEOMETRY_TYPE } from \"./geometryType\";\nimport { VertexBufferType } from \"./vertexBufferType\";\n\nexport function createFlatGeometryVector(\n    geometryTypes: Int32Array,\n    topologyVector: TopologyVector,\n    vertexOffsets: Int32Array,\n    vertexBuffer: Int32Array,\n): FlatGeometryVector {\n    return new FlatGeometryVector(VertexBufferType.VEC_2, geometryTypes, topologyVector, vertexOffsets, vertexBuffer);\n}\n\nexport function createFlatGeometryVectorMortonEncoded(\n    geometryTypes: Int32Array,\n    topologyVector: TopologyVector,\n    vertexOffsets: Int32Array,\n    vertexBuffer: Int32Array,\n    mortonInfo: MortonSettings,\n): FlatGeometryVector {\n    //TODO: refactor to use unsigned integers\n    return new FlatGeometryVector(\n        VertexBufferType.MORTON,\n        geometryTypes,\n        topologyVector,\n        vertexOffsets,\n        vertexBuffer,\n        mortonInfo,\n    );\n}\n\nexport class FlatGeometryVector extends GeometryVector {\n    constructor(\n        vertexBufferType: VertexBufferType,\n        //TODO: refactor -> use UInt8Array\n        private readonly _geometryTypes: Int32Array,\n        topologyVector: TopologyVector,\n        vertexOffsets: Int32Array,\n        vertexBuffer: Int32Array,\n        mortonSettings?: MortonSettings,\n    ) {\n        super(vertexBufferType, topologyVector, vertexOffsets, vertexBuffer, mortonSettings);\n    }\n\n    geometryType(index: number): number {\n        return this._geometryTypes[index];\n    }\n\n    get numGeometries(): number {\n        return this._geometryTypes.length;\n    }\n\n    containsPolygonGeometry(): boolean {\n        for (let i = 0; i < this.numGeometries; i++) {\n            if (this.geometryType(i) === GEOMETRY_TYPE.POLYGON || this.geometryType(i) === GEOMETRY_TYPE.MULTIPOLYGON) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    containsSingleGeometryType(): boolean {\n        return false;\n    }\n}\n"]}