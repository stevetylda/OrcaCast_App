{"version":3,"file":"mltDecoder.js","sourceRoot":"","sources":["../src/mltDecoder.ts"],"names":[],"mappings":"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","sourcesContent":["import FeatureTable from \"./vector/featureTable\";\nimport { type Column, ScalarType } from \"./metadata/tileset/tilesetMetadata\";\nimport IntWrapper from \"./decoding/intWrapper\";\nimport { decodeStreamMetadata, type RleEncodedStreamMetadata } from \"./metadata/tile/streamMetadataDecoder\";\nimport { VectorType } from \"./vector/vectorType\";\nimport { IntFlatVector } from \"./vector/flat/intFlatVector\";\nimport BitVector from \"./vector/flat/bitVector\";\nimport {\n    decodeConstIntStream,\n    decodeConstLongStream,\n    decodeIntStream,\n    decodeLongFloat64Stream,\n    decodeLongStream,\n    decodeSequenceIntStream,\n    decodeSequenceLongStream,\n    getVectorType,\n} from \"./decoding/integerStreamDecoder\";\nimport { IntSequenceVector } from \"./vector/sequence/intSequenceVector\";\nimport { LongFlatVector } from \"./vector/flat/longFlatVector\";\nimport { LongSequenceVector } from \"./vector/sequence/longSequenceVector\";\nimport { type IntVector } from \"./vector/intVector\";\nimport { decodeVarintInt32 } from \"./decoding/integerDecodingUtils\";\nimport { decodeGeometryColumn } from \"./decoding/geometryDecoder\";\nimport { decodePropertyColumn } from \"./decoding/propertyDecoder\";\nimport { IntConstVector } from \"./vector/constant/intConstVector\";\nimport { LongConstVector } from \"./vector/constant/longConstVector\";\nimport type GeometryScaling from \"./decoding/geometryScaling\";\nimport { decodeBooleanRle } from \"./decoding/decodingUtils\";\nimport { DoubleFlatVector } from \"./vector/flat/doubleFlatVector\";\nimport { decodeEmbeddedTileSetMetadata } from \"./metadata/tileset/embeddedTilesetMetadataDecoder\";\nimport { hasStreamCount } from \"./metadata/tileset/typeMap\";\nimport { type StreamMetadata } from \"./metadata/tile/streamMetadataDecoder\";\nimport { type GeometryVector } from \"./vector/geometry/geometryVector\";\nimport type Vector from \"./vector/vector\";\nimport { type GpuVector } from \"./vector/geometry/gpuVector\";\n\nconst ID_COLUMN_NAME = \"id\";\nconst GEOMETRY_COLUMN_NAME = \"geometry\";\n\n/**\n * Decodes a tile with embedded metadata (Tag 0x01 format).\n * This is the primary decoder function for MLT tiles.\n *\n * @param tile The tile data to decode (will be decompressed if gzip-compressed)\n * @param geometryScaling Optional geometry scaling parameters\n * @param idWithinMaxSafeInteger If true, limits ID values to JavaScript safe integer range (53 bits)\n */\nexport default function decodeTile(\n    tile: Uint8Array,\n    geometryScaling?: GeometryScaling,\n    idWithinMaxSafeInteger = true,\n): FeatureTable[] {\n    const offset = new IntWrapper(0);\n    const featureTables: FeatureTable[] = [];\n\n    while (offset.get() < tile.length) {\n        const blockLength = decodeVarintInt32(tile, offset, 1)[0] >>> 0;\n        const blockStart = offset.get();\n        const blockEnd = blockStart + blockLength;\n        if (blockEnd > tile.length) {\n            throw new Error(`Block overruns tile: ${blockEnd} > ${tile.length}`);\n        }\n\n        const tag = decodeVarintInt32(tile, offset, 1)[0] >>> 0;\n        if (tag !== 1) {\n            // Skip unknown block types\n            offset.set(blockEnd);\n            continue;\n        }\n\n        // Decode embedded metadata and extent (one of each per block)\n        const decode = decodeEmbeddedTileSetMetadata(tile, offset);\n        const metadata = decode[0];\n        const extent = decode[1];\n        const featureTableMetadata = metadata.featureTables[0];\n\n        // Decode columns from streams\n        let idVector: IntVector | null = null;\n        let geometryVector: GeometryVector | GpuVector | null = null;\n        const propertyVectors: Vector[] = [];\n        let numFeatures = 0;\n\n        for (const columnMetadata of featureTableMetadata.columns) {\n            const columnName = columnMetadata.name;\n\n            if (columnName === ID_COLUMN_NAME) {\n                let nullabilityBuffer = null;\n                // Check column metadata nullable flag, not numStreams (ID columns don't have stream count)\n                if (columnMetadata.nullable) {\n                    const presentStreamMetadata = decodeStreamMetadata(tile, offset);\n                    const streamDataStart = offset.get();\n                    const values = decodeBooleanRle(tile, presentStreamMetadata.numValues, offset);\n                    // Fix offset: decodeBooleanRle doesn't consume all compressed bytes\n                    offset.set(streamDataStart + presentStreamMetadata.byteLength);\n                    nullabilityBuffer = new BitVector(values, presentStreamMetadata.numValues);\n                }\n\n                const idDataStreamMetadata = decodeStreamMetadata(tile, offset);\n                numFeatures = idDataStreamMetadata.decompressedCount;\n\n                idVector = decodeIdColumn(\n                    tile,\n                    columnMetadata,\n                    offset,\n                    columnName,\n                    idDataStreamMetadata,\n                    nullabilityBuffer ?? numFeatures,\n                    idWithinMaxSafeInteger,\n                );\n            } else if (columnName === GEOMETRY_COLUMN_NAME) {\n                const numStreams = decodeVarintInt32(tile, offset, 1)[0];\n\n                // If no ID column, get numFeatures from geometry type stream metadata\n                if (numFeatures === 0) {\n                    const savedOffset = offset.get();\n                    const geometryTypeMetadata = decodeStreamMetadata(tile, offset);\n                    numFeatures = geometryTypeMetadata.decompressedCount;\n                    offset.set(savedOffset); // Reset to re-read in decodeGeometryColumn\n                }\n\n                if (geometryScaling) {\n                    geometryScaling.scale = geometryScaling.extent / extent;\n                }\n\n                geometryVector = decodeGeometryColumn(tile, numStreams, offset, numFeatures, geometryScaling);\n            } else {\n                // Property columns: STRING and STRUCT have stream count, others don't\n                const hasStreamCnt = hasStreamCount(columnMetadata);\n                const numStreams = hasStreamCnt ? decodeVarintInt32(tile, offset, 1)[0] : 1;\n\n                if (numStreams === 0 && columnMetadata.type === \"scalarType\") {\n                    continue;\n                }\n\n                const propertyVector = decodePropertyColumn(\n                    tile,\n                    offset,\n                    columnMetadata,\n                    numStreams,\n                    numFeatures,\n                    undefined,\n                );\n                if (propertyVector) {\n                    if (Array.isArray(propertyVector)) {\n                        for (const property of propertyVector) {\n                            propertyVectors.push(property);\n                        }\n                    } else {\n                        propertyVectors.push(propertyVector);\n                    }\n                }\n            }\n        }\n\n        const featureTable = new FeatureTable(\n            featureTableMetadata.name,\n            geometryVector,\n            idVector,\n            propertyVectors,\n            extent,\n        );\n        featureTables.push(featureTable);\n        offset.set(blockEnd);\n    }\n\n    return featureTables;\n}\n\nfunction decodeIdColumn(\n    tile: Uint8Array,\n    columnMetadata: Column,\n    offset: IntWrapper,\n    columnName: string,\n    idDataStreamMetadata: StreamMetadata,\n    sizeOrNullabilityBuffer: number | BitVector,\n    idWithinMaxSafeInteger: boolean = false,\n): IntVector {\n    const idDataType = columnMetadata.scalarType.physicalType;\n    const vectorType = getVectorType(idDataStreamMetadata, sizeOrNullabilityBuffer, tile, offset);\n    if (idDataType === ScalarType.UINT_32) {\n        switch (vectorType) {\n            case VectorType.FLAT: {\n                const id = decodeIntStream(tile, offset, idDataStreamMetadata, false);\n                return new IntFlatVector(columnName, id, sizeOrNullabilityBuffer);\n            }\n            case VectorType.SEQUENCE: {\n                const id = decodeSequenceIntStream(tile, offset, idDataStreamMetadata);\n                return new IntSequenceVector(\n                    columnName,\n                    id[0],\n                    id[1],\n                    (idDataStreamMetadata as RleEncodedStreamMetadata).numRleValues,\n                );\n            }\n            case VectorType.CONST: {\n                const id = decodeConstIntStream(tile, offset, idDataStreamMetadata, false);\n                return new IntConstVector(columnName, id, sizeOrNullabilityBuffer);\n            }\n        }\n    } else {\n        switch (vectorType) {\n            case VectorType.FLAT: {\n                if (idWithinMaxSafeInteger) {\n                    const id = decodeLongFloat64Stream(tile, offset, idDataStreamMetadata, false);\n                    return new DoubleFlatVector(columnName, id, sizeOrNullabilityBuffer);\n                }\n\n                const id = decodeLongStream(tile, offset, idDataStreamMetadata, false);\n                return new LongFlatVector(columnName, id, sizeOrNullabilityBuffer);\n            }\n            case VectorType.SEQUENCE: {\n                const id = decodeSequenceLongStream(tile, offset, idDataStreamMetadata);\n                return new LongSequenceVector(\n                    columnName,\n                    id[0],\n                    id[1],\n                    (idDataStreamMetadata as RleEncodedStreamMetadata).numRleValues,\n                );\n            }\n            case VectorType.CONST: {\n                const id = decodeConstLongStream(tile, offset, idDataStreamMetadata, false);\n                return new LongConstVector(columnName, id, sizeOrNullabilityBuffer);\n            }\n        }\n    }\n\n    throw new Error(\"Vector type not supported for id column.\");\n}\n"]}