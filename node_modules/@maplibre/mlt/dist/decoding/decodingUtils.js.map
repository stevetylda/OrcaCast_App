{"version":3,"file":"decodingUtils.js","sourceRoot":"","sources":["../../src/decoding/decodingUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import type IntWrapper from \"./intWrapper\";\nimport { VectorType } from \"../vector/vectorType\";\nimport BitVector from \"../vector/flat/bitVector\";\nimport { decodeStreamMetadata } from \"../metadata/tile/streamMetadataDecoder\";\n\nexport function skipColumn(numStreams: number, tile: Uint8Array, offset: IntWrapper) {\n    //TODO: add size of column in Mlt for fast skipping\n    for (let i = 0; i < numStreams; i++) {\n        const streamMetadata = decodeStreamMetadata(tile, offset);\n        offset.add(streamMetadata.byteLength);\n    }\n}\n\nexport function decodeBooleanRle(buffer: Uint8Array, numBooleans: number, pos: IntWrapper): Uint8Array {\n    const numBytes = Math.ceil(numBooleans / 8.0);\n    return decodeByteRle(buffer, numBytes, pos);\n}\n\nexport function decodeNullableBooleanRle(\n    buffer: Uint8Array,\n    numBooleans: number,\n    pos: IntWrapper,\n    nullabilityBuffer: BitVector,\n): Uint8Array {\n    // TODO: refactor quick and dirty solution -> use solution in one pass\n    const numBytes = Math.ceil(numBooleans / 8);\n    const values = decodeByteRle(buffer, numBytes, pos);\n    const bitVector = new BitVector(values, numBooleans);\n\n    const size = nullabilityBuffer.size();\n    const nullableBitvector = new BitVector(new Uint8Array(size), size);\n    let valueCounter = 0;\n    for (let i = 0; i < nullabilityBuffer.size(); i++) {\n        const value = nullabilityBuffer.get(i) ? bitVector.get(valueCounter++) : false;\n        nullableBitvector.set(i, value);\n    }\n\n    return nullableBitvector.getBuffer();\n}\n\nexport function decodeByteRle(buffer: Uint8Array, numBytes: number, pos: IntWrapper): Uint8Array {\n    const values = new Uint8Array(numBytes);\n\n    let valueOffset = 0;\n    while (valueOffset < numBytes) {\n        const header = buffer[pos.increment()];\n\n        /* Runs */\n        if (header <= 0x7f) {\n            const numRuns = header + 3;\n            const value = buffer[pos.increment()];\n            const endValueOffset = valueOffset + numRuns;\n            values.fill(value, valueOffset, endValueOffset);\n            valueOffset = endValueOffset;\n        } else {\n            /* Literals */\n            const numLiterals = 256 - header;\n            for (let i = 0; i < numLiterals; i++) {\n                values[valueOffset++] = buffer[pos.increment()];\n            }\n        }\n    }\n    return values;\n}\n\nexport function decodeFloatsLE(encodedValues: Uint8Array, pos: IntWrapper, numValues: number): Float32Array {\n    const currentPos = pos.get();\n    const newOffset = currentPos + numValues * Float32Array.BYTES_PER_ELEMENT;\n    const newBuf = new Uint8Array(encodedValues.subarray(currentPos, newOffset)).buffer;\n    const fb = new Float32Array(newBuf);\n    pos.set(newOffset);\n    return fb;\n}\n\nexport function decodeDoublesLE(encodedValues: Uint8Array, pos: IntWrapper, numValues: number): Float64Array {\n    const currentPos = pos.get();\n    const newOffset = currentPos + numValues * Float64Array.BYTES_PER_ELEMENT;\n    const newBuf = new Uint8Array(encodedValues.subarray(currentPos, newOffset)).buffer;\n    const fb = new Float64Array(newBuf);\n    pos.set(newOffset);\n    return fb;\n}\n\nexport function decodeNullableFloatsLE(\n    encodedValues: Uint8Array,\n    pos: IntWrapper,\n    nullabilityBuffer: BitVector,\n    numValues: number,\n): Float32Array {\n    const currentPos = pos.get();\n    const newOffset = currentPos + numValues * Float32Array.BYTES_PER_ELEMENT;\n    const newBuf = new Uint8Array(encodedValues.subarray(currentPos, newOffset)).buffer;\n    const fb = new Float32Array(newBuf);\n    pos.set(newOffset);\n\n    const numTotalValues = nullabilityBuffer.size();\n    const nullableFloatsBuffer = new Float32Array(numTotalValues);\n    let offset = 0;\n    for (let i = 0; i < numTotalValues; i++) {\n        nullableFloatsBuffer[i] = nullabilityBuffer.get(i) ? fb[offset++] : 0;\n    }\n\n    return nullableFloatsBuffer;\n}\n\nexport function decodeNullableDoublesLE(\n    encodedValues: Uint8Array,\n    pos: IntWrapper,\n    nullabilityBuffer: BitVector,\n    numValues: number,\n): Float64Array {\n    const currentPos = pos.get();\n    const newOffset = currentPos + numValues * Float64Array.BYTES_PER_ELEMENT;\n    const newBuf = new Uint8Array(encodedValues.subarray(currentPos, newOffset)).buffer;\n    const fb = new Float64Array(newBuf);\n    pos.set(newOffset);\n\n    const numTotalValues = nullabilityBuffer.size();\n    const nullableDoubleBuffer = new Float64Array(numTotalValues);\n    let offset = 0;\n    for (let i = 0; i < numTotalValues; i++) {\n        nullableDoubleBuffer[i] = nullabilityBuffer.get(i) ? fb[offset++] : 0;\n    }\n\n    return nullableDoubleBuffer;\n}\n\nconst TEXT_DECODER_MIN_LENGTH = 12;\nconst utf8TextDecoder = new TextDecoder();\n\n// Source: https://github.com/mapbox/pbf/issues/106\nexport function decodeString(buf: Uint8Array, pos: number, end: number): string {\n    if (end - pos >= TEXT_DECODER_MIN_LENGTH) {\n        // longer strings are fast with the built-in browser TextDecoder API\n        return utf8TextDecoder.decode(buf.subarray(pos, end));\n    }\n    // short strings are fast with custom implementation\n    return readUtf8(buf, pos, end);\n}\n\nfunction readUtf8(buf, pos, end): string {\n    let str = \"\";\n    let i = pos;\n\n    while (i < end) {\n        const b0 = buf[i];\n        let c = null; // codepoint\n        let bytesPerSequence = b0 > 0xef ? 4 : b0 > 0xdf ? 3 : b0 > 0xbf ? 2 : 1;\n\n        if (i + bytesPerSequence > end) break;\n\n        let b1, b2, b3;\n\n        if (bytesPerSequence === 1) {\n            if (b0 < 0x80) {\n                c = b0;\n            }\n        } else if (bytesPerSequence === 2) {\n            b1 = buf[i + 1];\n            if ((b1 & 0xc0) === 0x80) {\n                c = ((b0 & 0x1f) << 0x6) | (b1 & 0x3f);\n                if (c <= 0x7f) {\n                    c = null;\n                }\n            }\n        } else if (bytesPerSequence === 3) {\n            b1 = buf[i + 1];\n            b2 = buf[i + 2];\n            if ((b1 & 0xc0) === 0x80 && (b2 & 0xc0) === 0x80) {\n                c = ((b0 & 0xf) << 0xc) | ((b1 & 0x3f) << 0x6) | (b2 & 0x3f);\n                if (c <= 0x7ff || (c >= 0xd800 && c <= 0xdfff)) {\n                    c = null;\n                }\n            }\n        } else if (bytesPerSequence === 4) {\n            b1 = buf[i + 1];\n            b2 = buf[i + 2];\n            b3 = buf[i + 3];\n            if ((b1 & 0xc0) === 0x80 && (b2 & 0xc0) === 0x80 && (b3 & 0xc0) === 0x80) {\n                c = ((b0 & 0xf) << 0x12) | ((b1 & 0x3f) << 0xc) | ((b2 & 0x3f) << 0x6) | (b3 & 0x3f);\n                if (c <= 0xffff || c >= 0x110000) {\n                    c = null;\n                }\n            }\n        }\n\n        if (c === null) {\n            c = 0xfffd;\n            bytesPerSequence = 1;\n        } else if (c > 0xffff) {\n            c -= 0x10000;\n            str += String.fromCharCode(((c >>> 10) & 0x3ff) | 0xd800);\n            c = 0xdc00 | (c & 0x3ff);\n        }\n\n        str += String.fromCharCode(c);\n        i += bytesPerSequence;\n    }\n\n    return str;\n}\n\nexport function getVectorTypeBooleanStream(\n    numFeatures: number,\n    byteLength: number,\n    data: Uint8Array,\n    offset: IntWrapper,\n): VectorType {\n    const valuesPerRun = 0x83;\n    // TODO: use VectorType metadata field for to test which VectorType is used\n    return Math.ceil(numFeatures / valuesPerRun) * 2 == byteLength &&\n        /* Test the first value byte if all bits are set to true */\n        (data[offset.get() + 1] & 0xff) === (bitCount(numFeatures) << 2) - 1\n        ? VectorType.CONST\n        : VectorType.FLAT;\n}\n\nfunction bitCount(number): number {\n    //TODO: refactor to get rid of special case handling\n    return number === 0 ? 1 : Math.floor(Math.log2(number) + 1);\n}\n"]}