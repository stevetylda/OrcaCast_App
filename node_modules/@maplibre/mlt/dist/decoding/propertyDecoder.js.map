{"version":3,"file":"propertyDecoder.js","sourceRoot":"","sources":["../../src/decoding/propertyDecoder.ts"],"names":[],"mappings":"AACA,OAAO,EAAkC,UAAU,EAAE,MAAM,qCAAqC,CAAC;AAEjG,OAAO,SAAS,MAAM,0BAA0B,CAAC;AACjD,OAAO,EAAE,oBAAoB,EAAiC,MAAM,wCAAwC,CAAC;AAC7G,OAAO,EAAE,UAAU,EAAE,MAAM,sBAAsB,CAAC;AAClD,OAAO,EAAE,iBAAiB,EAAE,MAAM,kCAAkC,CAAC;AACrE,OAAO,EAAE,gBAAgB,EAAE,MAAM,iCAAiC,CAAC;AACnE,OAAO,EAAE,eAAe,EAAE,MAAM,gCAAgC,CAAC;AACjE,OAAO,EAAE,eAAe,EAAE,MAAM,oCAAoC,CAAC;AACrE,OAAO,EAAE,cAAc,EAAE,MAAM,+BAA+B,CAAC;AAC/D,OAAO,EAAE,aAAa,EAAE,MAAM,8BAA8B,CAAC;AAC7D,OAAO,EAAE,cAAc,EAAE,MAAM,mCAAmC,CAAC;AACnE,OAAO,EACH,gBAAgB,EAChB,eAAe,EACf,cAAc,EACd,wBAAwB,EACxB,uBAAuB,EACvB,sBAAsB,EACtB,UAAU,GACb,MAAM,iBAAiB,CAAC;AACzB,OAAO,EACH,oBAAoB,EACpB,qBAAqB,EACrB,eAAe,EACf,gBAAgB,EAChB,uBAAuB,EACvB,wBAAwB,EACxB,uBAAuB,EACvB,wBAAwB,EACxB,aAAa,GAChB,MAAM,wBAAwB,CAAC;AAChC,OAAO,EAAE,iBAAiB,EAAE,MAAM,sCAAsC,CAAC;AACzE,OAAO,EAAE,kBAAkB,EAAE,MAAM,uCAAuC,CAAC;AAC3E,OAAO,EAAE,sBAAsB,EAAE,YAAY,EAAE,MAAM,iBAAiB,CAAC;AAEvE,MAAM,UAAU,oBAAoB,CAChC,IAAgB,EAChB,MAAkB,EAClB,cAAsB,EACtB,UAAkB,EAClB,WAAmB,EACnB,mBAAiC;IAEjC,IAAI,cAAc,CAAC,IAAI,KAAK,YAAY,EAAE,CAAC;QACvC,IAAI,mBAAmB,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE,CAAC;YACvE,UAAU,CAAC,UAAU,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;YACrC,OAAO,IAAI,CAAC;QAChB,CAAC;QAED,OAAO,0BAA0B,CAC7B,UAAU,EACV,IAAI,EACJ,MAAM,EACN,WAAW,EACX,cAAc,CAAC,UAAU,EACzB,cAAc,CACjB,CAAC;IACN,CAAC;IAED,IAAI,UAAU,IAAI,CAAC,EAAE,CAAC;QAClB,OAAO,IAAI,CAAC;IAChB,CAAC;IAED,OAAO,sBAAsB,CAAC,IAAI,EAAE,MAAM,EAAE,cAAc,EAAE,WAAW,EAAE,mBAAmB,CAAC,CAAC;AAClG,CAAC;AAED,SAAS,0BAA0B,CAC/B,UAAkB,EAClB,IAAgB,EAChB,MAAkB,EAClB,WAAmB,EACnB,MAAoB,EACpB,cAAsB;IAEtB,IAAI,iBAAiB,GAAc,IAAI,CAAC;IACxC,IAAI,SAAS,GAAG,CAAC,CAAC;IAClB,IAAI,UAAU,KAAK,CAAC,EAAE,CAAC;QACnB,0CAA0C;QAC1C,OAAO,IAAI,CAAC;IAChB,CAAC;IAED,gDAAgD;IAChD,IAAI,cAAc,CAAC,QAAQ,EAAE,CAAC;QAC1B,MAAM,qBAAqB,GAAG,oBAAoB,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;QACjE,SAAS,GAAG,qBAAqB,CAAC,SAAS,CAAC;QAC5C,MAAM,eAAe,GAAG,MAAM,CAAC,GAAG,EAAE,CAAC;QACrC,8BAA8B;QAC9B,MAAM,aAAa,GAAG,gBAAgB,CAAC,IAAI,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;QAChE,mDAAmD;QACnD,0EAA0E;QAC1E,MAAM,CAAC,GAAG,CAAC,eAAe,GAAG,qBAAqB,CAAC,UAAU,CAAC,CAAC;QAC/D,iBAAiB,GAAG,IAAI,SAAS,CAAC,aAAa,EAAE,qBAAqB,CAAC,SAAS,CAAC,CAAC;IACtF,CAAC;IAED,MAAM,uBAAuB,GAAG,iBAAiB,IAAI,WAAW,CAAC;IACjE,MAAM,UAAU,GAAG,MAAM,CAAC,YAAY,CAAC;IACvC,QAAQ,UAAU,EAAE,CAAC;QACjB,KAAK,UAAU,CAAC,OAAO,CAAC;QACxB,KAAK,UAAU,CAAC,MAAM;YAClB,OAAO,eAAe,CAAC,IAAI,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,EAAE,uBAAuB,CAAC,CAAC;QAC1F,KAAK,UAAU,CAAC,MAAM;YAClB,mFAAmF;YACnF,MAAM,iBAAiB,GAAG,cAAc,CAAC,QAAQ,CAAC,CAAC,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC;YAChF,OAAO,YAAY,CAAC,cAAc,CAAC,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,iBAAiB,EAAE,iBAAiB,CAAC,CAAC;QACjG,KAAK,UAAU,CAAC,OAAO;YACnB,OAAO,mBAAmB,CAAC,IAAI,EAAE,MAAM,EAAE,cAAc,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;QACnG,KAAK,UAAU,CAAC,OAAO,CAAC;QACxB,KAAK,UAAU,CAAC,MAAM;YAClB,OAAO,gBAAgB,CAAC,IAAI,EAAE,MAAM,EAAE,cAAc,EAAE,uBAAuB,EAAE,MAAM,CAAC,CAAC;QAC3F,KAAK,UAAU,CAAC,KAAK;YACjB,OAAO,iBAAiB,CAAC,IAAI,EAAE,MAAM,EAAE,cAAc,EAAE,uBAAuB,CAAC,CAAC;QACpF,KAAK,UAAU,CAAC,MAAM;YAClB,OAAO,kBAAkB,CAAC,IAAI,EAAE,MAAM,EAAE,cAAc,EAAE,uBAAuB,CAAC,CAAC;QACrF;YACI,MAAM,IAAI,KAAK,CAAC,qEAAqE,MAAM,EAAE,CAAC,CAAC;IACvG,CAAC;AACL,CAAC;AAED,SAAS,mBAAmB,CACxB,IAAgB,EAChB,MAAkB,EAClB,MAAc,EACd,WAAmB,EACnB,uBAA2C;IAE3C,MAAM,kBAAkB,GAAG,oBAAoB,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;IAC9D,MAAM,SAAS,GAAG,kBAAkB,CAAC,SAAS,CAAC;IAC/C,MAAM,eAAe,GAAG,MAAM,CAAC,GAAG,EAAE,CAAC;IACrC,MAAM,UAAU,GAAG,mBAAmB,CAAC,uBAAuB,CAAC;QAC3D,CAAC,CAAC,wBAAwB,CAAC,IAAI,EAAE,SAAS,EAAE,MAAM,EAAE,uBAAuB,CAAC;QAC5E,CAAC,CAAC,gBAAgB,CAAC,IAAI,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;IAChD,0CAA0C;IAC1C,8DAA8D;IAC9D,MAAM,CAAC,GAAG,CAAC,eAAe,GAAG,kBAAkB,CAAC,UAAU,CAAC,CAAC;IAC5D,MAAM,UAAU,GAAG,IAAI,SAAS,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;IACxD,OAAO,IAAI,iBAAiB,CAAC,MAAM,CAAC,IAAI,EAAE,UAAU,EAAE,uBAAuB,CAAC,CAAC;AACnF,CAAC;AAED,SAAS,iBAAiB,CACtB,IAAgB,EAChB,MAAkB,EAClB,MAAc,EACd,uBAA2C;IAE3C,MAAM,kBAAkB,GAAG,oBAAoB,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;IAC9D,MAAM,UAAU,GAAG,mBAAmB,CAAC,uBAAuB,CAAC;QAC3D,CAAC,CAAC,sBAAsB,CAAC,IAAI,EAAE,MAAM,EAAE,uBAAuB,EAAE,kBAAkB,CAAC,SAAS,CAAC;QAC7F,CAAC,CAAC,cAAc,CAAC,IAAI,EAAE,MAAM,EAAE,kBAAkB,CAAC,SAAS,CAAC,CAAC;IACjE,OAAO,IAAI,eAAe,CAAC,MAAM,CAAC,IAAI,EAAE,UAAU,EAAE,uBAAuB,CAAC,CAAC;AACjF,CAAC;AAED,SAAS,kBAAkB,CACvB,IAAgB,EAChB,MAAkB,EAClB,MAAc,EACd,uBAA2C;IAE3C,MAAM,kBAAkB,GAAG,oBAAoB,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;IAC9D,MAAM,UAAU,GAAG,mBAAmB,CAAC,uBAAuB,CAAC;QAC3D,CAAC,CAAC,uBAAuB,CAAC,IAAI,EAAE,MAAM,EAAE,uBAAuB,EAAE,kBAAkB,CAAC,SAAS,CAAC;QAC9F,CAAC,CAAC,eAAe,CAAC,IAAI,EAAE,MAAM,EAAE,kBAAkB,CAAC,SAAS,CAAC,CAAC;IAClE,OAAO,IAAI,gBAAgB,CAAC,MAAM,CAAC,IAAI,EAAE,UAAU,EAAE,uBAAuB,CAAC,CAAC;AAClF,CAAC;AAED,SAAS,gBAAgB,CACrB,IAAgB,EAChB,MAAkB,EAClB,MAAc,EACd,uBAA2C,EAC3C,YAA0B;IAE1B,MAAM,kBAAkB,GAAG,oBAAoB,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;IAC9D,MAAM,UAAU,GAAG,aAAa,CAAC,kBAAkB,EAAE,uBAAuB,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;IAC5F,MAAM,QAAQ,GAAG,YAAY,CAAC,YAAY,KAAK,UAAU,CAAC,MAAM,CAAC;IACjE,IAAI,UAAU,KAAK,UAAU,CAAC,IAAI,EAAE,CAAC;QACjC,MAAM,UAAU,GAAG,mBAAmB,CAAC,uBAAuB,CAAC;YAC3D,CAAC,CAAC,wBAAwB,CAAC,IAAI,EAAE,MAAM,EAAE,kBAAkB,EAAE,QAAQ,EAAE,uBAAuB,CAAC;YAC/F,CAAC,CAAC,gBAAgB,CAAC,IAAI,EAAE,MAAM,EAAE,kBAAkB,EAAE,QAAQ,CAAC,CAAC;QACnE,OAAO,IAAI,cAAc,CAAC,MAAM,CAAC,IAAI,EAAE,UAAU,EAAE,uBAAuB,CAAC,CAAC;IAChF,CAAC;SAAM,IAAI,UAAU,KAAK,UAAU,CAAC,QAAQ,EAAE,CAAC;QAC5C,MAAM,EAAE,GAAG,wBAAwB,CAAC,IAAI,EAAE,MAAM,EAAE,kBAAkB,CAAC,CAAC;QACtE,OAAO,IAAI,kBAAkB,CACzB,MAAM,CAAC,IAAI,EACX,EAAE,CAAC,CAAC,CAAC,EACL,EAAE,CAAC,CAAC,CAAC,EACJ,kBAA+C,CAAC,YAAY,CAChE,CAAC;IACN,CAAC;SAAM,CAAC;QACJ,MAAM,UAAU,GAAG,qBAAqB,CAAC,IAAI,EAAE,MAAM,EAAE,kBAAkB,EAAE,QAAQ,CAAC,CAAC;QACrF,OAAO,IAAI,eAAe,CAAC,MAAM,CAAC,IAAI,EAAE,UAAU,EAAE,uBAAuB,CAAC,CAAC;IACjF,CAAC;AACL,CAAC;AAED,SAAS,eAAe,CACpB,IAAgB,EAChB,MAAkB,EAClB,MAAc,EACd,YAA0B,EAC1B,uBAA2C;IAE3C,MAAM,kBAAkB,GAAG,oBAAoB,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;IAC9D,MAAM,UAAU,GAAG,aAAa,CAAC,kBAAkB,EAAE,uBAAuB,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;IAC5F,MAAM,QAAQ,GAAG,YAAY,CAAC,YAAY,KAAK,UAAU,CAAC,MAAM,CAAC;IAEjE,IAAI,UAAU,KAAK,UAAU,CAAC,IAAI,EAAE,CAAC;QACjC,MAAM,UAAU,GAAG,mBAAmB,CAAC,uBAAuB,CAAC;YAC3D,CAAC,CAAC,uBAAuB,CAAC,IAAI,EAAE,MAAM,EAAE,kBAAkB,EAAE,QAAQ,EAAE,uBAAuB,CAAC;YAC9F,CAAC,CAAC,eAAe,CAAC,IAAI,EAAE,MAAM,EAAE,kBAAkB,EAAE,QAAQ,CAAC,CAAC;QAClE,OAAO,IAAI,aAAa,CAAC,MAAM,CAAC,IAAI,EAAE,UAAU,EAAE,uBAAuB,CAAC,CAAC;IAC/E,CAAC;SAAM,IAAI,UAAU,KAAK,UAAU,CAAC,QAAQ,EAAE,CAAC;QAC5C,MAAM,EAAE,GAAG,uBAAuB,CAAC,IAAI,EAAE,MAAM,EAAE,kBAAkB,CAAC,CAAC;QACrE,OAAO,IAAI,iBAAiB,CACxB,MAAM,CAAC,IAAI,EACX,EAAE,CAAC,CAAC,CAAC,EACL,EAAE,CAAC,CAAC,CAAC,EACJ,kBAA+C,CAAC,YAAY,CAChE,CAAC;IACN,CAAC;SAAM,CAAC;QACJ,MAAM,UAAU,GAAG,oBAAoB,CAAC,IAAI,EAAE,MAAM,EAAE,kBAAkB,EAAE,QAAQ,CAAC,CAAC;QACpF,OAAO,IAAI,cAAc,CAAC,MAAM,CAAC,IAAI,EAAE,UAAU,EAAE,uBAAuB,CAAC,CAAC;IAChF,CAAC;AACL,CAAC;AAED,SAAS,mBAAmB,CAAC,uBAA2C;IACpE,OAAO,uBAAuB,YAAY,SAAS,CAAC;AACxD,CAAC","sourcesContent":["import type IntWrapper from \"./intWrapper\";\nimport { type Column, type ScalarColumn, ScalarType } from \"../metadata/tileset/tilesetMetadata\";\nimport type Vector from \"../vector/vector\";\nimport BitVector from \"../vector/flat/bitVector\";\nimport { decodeStreamMetadata, type RleEncodedStreamMetadata } from \"../metadata/tile/streamMetadataDecoder\";\nimport { VectorType } from \"../vector/vectorType\";\nimport { BooleanFlatVector } from \"../vector/flat/booleanFlatVector\";\nimport { DoubleFlatVector } from \"../vector/flat/doubleFlatVector\";\nimport { FloatFlatVector } from \"../vector/flat/floatFlatVector\";\nimport { LongConstVector } from \"../vector/constant/longConstVector\";\nimport { LongFlatVector } from \"../vector/flat/longFlatVector\";\nimport { IntFlatVector } from \"../vector/flat/intFlatVector\";\nimport { IntConstVector } from \"../vector/constant/intConstVector\";\nimport {\n    decodeBooleanRle,\n    decodeDoublesLE,\n    decodeFloatsLE,\n    decodeNullableBooleanRle,\n    decodeNullableDoublesLE,\n    decodeNullableFloatsLE,\n    skipColumn,\n} from \"./decodingUtils\";\nimport {\n    decodeConstIntStream,\n    decodeConstLongStream,\n    decodeIntStream,\n    decodeLongStream,\n    decodeNullableIntStream,\n    decodeNullableLongStream,\n    decodeSequenceIntStream,\n    decodeSequenceLongStream,\n    getVectorType,\n} from \"./integerStreamDecoder\";\nimport { IntSequenceVector } from \"../vector/sequence/intSequenceVector\";\nimport { LongSequenceVector } from \"../vector/sequence/longSequenceVector\";\nimport { decodeSharedDictionary, decodeString } from \"./stringDecoder\";\n\nexport function decodePropertyColumn(\n    data: Uint8Array,\n    offset: IntWrapper,\n    columnMetadata: Column,\n    numStreams: number,\n    numFeatures: number,\n    propertyColumnNames?: Set<string>,\n): Vector | Vector[] {\n    if (columnMetadata.type === \"scalarType\") {\n        if (propertyColumnNames && !propertyColumnNames.has(columnMetadata.name)) {\n            skipColumn(numStreams, data, offset);\n            return null;\n        }\n\n        return decodeScalarPropertyColumn(\n            numStreams,\n            data,\n            offset,\n            numFeatures,\n            columnMetadata.scalarType,\n            columnMetadata,\n        );\n    }\n\n    if (numStreams != 1) {\n        return null;\n    }\n\n    return decodeSharedDictionary(data, offset, columnMetadata, numFeatures, propertyColumnNames);\n}\n\nfunction decodeScalarPropertyColumn(\n    numStreams: number,\n    data: Uint8Array,\n    offset: IntWrapper,\n    numFeatures: number,\n    column: ScalarColumn,\n    columnMetadata: Column,\n) {\n    let nullabilityBuffer: BitVector = null;\n    let numValues = 0;\n    if (numStreams === 0) {\n        /* Skip since this column has no values */\n        return null;\n    }\n\n    // Read nullability stream if column is nullable\n    if (columnMetadata.nullable) {\n        const presentStreamMetadata = decodeStreamMetadata(data, offset);\n        numValues = presentStreamMetadata.numValues;\n        const streamDataStart = offset.get();\n        // Decode the RLE boolean data\n        const presentVector = decodeBooleanRle(data, numValues, offset);\n        // FIX: decodeBooleanRle doesn't consume all bytes!\n        // We must advance to the end of the stream using byteLength from metadata\n        offset.set(streamDataStart + presentStreamMetadata.byteLength);\n        nullabilityBuffer = new BitVector(presentVector, presentStreamMetadata.numValues);\n    }\n\n    const sizeOrNullabilityBuffer = nullabilityBuffer ?? numFeatures;\n    const scalarType = column.physicalType;\n    switch (scalarType) {\n        case ScalarType.UINT_32:\n        case ScalarType.INT_32:\n            return decodeIntColumn(data, offset, columnMetadata, column, sizeOrNullabilityBuffer);\n        case ScalarType.STRING:\n            // In embedded format: numStreams includes nullability stream if column is nullable\n            const stringDataStreams = columnMetadata.nullable ? numStreams - 1 : numStreams;\n            return decodeString(columnMetadata.name, data, offset, stringDataStreams, nullabilityBuffer);\n        case ScalarType.BOOLEAN:\n            return decodeBooleanColumn(data, offset, columnMetadata, numFeatures, sizeOrNullabilityBuffer);\n        case ScalarType.UINT_64:\n        case ScalarType.INT_64:\n            return decodeLongColumn(data, offset, columnMetadata, sizeOrNullabilityBuffer, column);\n        case ScalarType.FLOAT:\n            return decodeFloatColumn(data, offset, columnMetadata, sizeOrNullabilityBuffer);\n        case ScalarType.DOUBLE:\n            return decodeDoubleColumn(data, offset, columnMetadata, sizeOrNullabilityBuffer);\n        default:\n            throw new Error(`The specified data type for the field is currently not supported: ${column}`);\n    }\n}\n\nfunction decodeBooleanColumn(\n    data: Uint8Array,\n    offset: IntWrapper,\n    column: Column,\n    numFeatures: number,\n    sizeOrNullabilityBuffer: number | BitVector,\n): BooleanFlatVector {\n    const dataStreamMetadata = decodeStreamMetadata(data, offset);\n    const numValues = dataStreamMetadata.numValues;\n    const streamDataStart = offset.get();\n    const dataStream = isNullabilityBuffer(sizeOrNullabilityBuffer)\n        ? decodeNullableBooleanRle(data, numValues, offset, sizeOrNullabilityBuffer)\n        : decodeBooleanRle(data, numValues, offset);\n    // TODO: refactor decodeNullableBooleanRle\n    // Fix offset: RLE decoders don't consume all compressed bytes\n    offset.set(streamDataStart + dataStreamMetadata.byteLength);\n    const dataVector = new BitVector(dataStream, numValues);\n    return new BooleanFlatVector(column.name, dataVector, sizeOrNullabilityBuffer);\n}\n\nfunction decodeFloatColumn(\n    data: Uint8Array,\n    offset: IntWrapper,\n    column: Column,\n    sizeOrNullabilityBuffer: number | BitVector,\n): FloatFlatVector {\n    const dataStreamMetadata = decodeStreamMetadata(data, offset);\n    const dataStream = isNullabilityBuffer(sizeOrNullabilityBuffer)\n        ? decodeNullableFloatsLE(data, offset, sizeOrNullabilityBuffer, dataStreamMetadata.numValues)\n        : decodeFloatsLE(data, offset, dataStreamMetadata.numValues);\n    return new FloatFlatVector(column.name, dataStream, sizeOrNullabilityBuffer);\n}\n\nfunction decodeDoubleColumn(\n    data: Uint8Array,\n    offset: IntWrapper,\n    column: Column,\n    sizeOrNullabilityBuffer: number | BitVector,\n): DoubleFlatVector {\n    const dataStreamMetadata = decodeStreamMetadata(data, offset);\n    const dataStream = isNullabilityBuffer(sizeOrNullabilityBuffer)\n        ? decodeNullableDoublesLE(data, offset, sizeOrNullabilityBuffer, dataStreamMetadata.numValues)\n        : decodeDoublesLE(data, offset, dataStreamMetadata.numValues);\n    return new DoubleFlatVector(column.name, dataStream, sizeOrNullabilityBuffer);\n}\n\nfunction decodeLongColumn(\n    data: Uint8Array,\n    offset: IntWrapper,\n    column: Column,\n    sizeOrNullabilityBuffer: number | BitVector,\n    scalarColumn: ScalarColumn,\n): Vector<BigInt64Array, bigint> {\n    const dataStreamMetadata = decodeStreamMetadata(data, offset);\n    const vectorType = getVectorType(dataStreamMetadata, sizeOrNullabilityBuffer, data, offset);\n    const isSigned = scalarColumn.physicalType === ScalarType.INT_64;\n    if (vectorType === VectorType.FLAT) {\n        const dataStream = isNullabilityBuffer(sizeOrNullabilityBuffer)\n            ? decodeNullableLongStream(data, offset, dataStreamMetadata, isSigned, sizeOrNullabilityBuffer)\n            : decodeLongStream(data, offset, dataStreamMetadata, isSigned);\n        return new LongFlatVector(column.name, dataStream, sizeOrNullabilityBuffer);\n    } else if (vectorType === VectorType.SEQUENCE) {\n        const id = decodeSequenceLongStream(data, offset, dataStreamMetadata);\n        return new LongSequenceVector(\n            column.name,\n            id[0],\n            id[1],\n            (dataStreamMetadata as RleEncodedStreamMetadata).numRleValues,\n        );\n    } else {\n        const constValue = decodeConstLongStream(data, offset, dataStreamMetadata, isSigned);\n        return new LongConstVector(column.name, constValue, sizeOrNullabilityBuffer);\n    }\n}\n\nfunction decodeIntColumn(\n    data: Uint8Array,\n    offset: IntWrapper,\n    column: Column,\n    scalarColumn: ScalarColumn,\n    sizeOrNullabilityBuffer: number | BitVector,\n): Vector<Int32Array, number> {\n    const dataStreamMetadata = decodeStreamMetadata(data, offset);\n    const vectorType = getVectorType(dataStreamMetadata, sizeOrNullabilityBuffer, data, offset);\n    const isSigned = scalarColumn.physicalType === ScalarType.INT_32;\n\n    if (vectorType === VectorType.FLAT) {\n        const dataStream = isNullabilityBuffer(sizeOrNullabilityBuffer)\n            ? decodeNullableIntStream(data, offset, dataStreamMetadata, isSigned, sizeOrNullabilityBuffer)\n            : decodeIntStream(data, offset, dataStreamMetadata, isSigned);\n        return new IntFlatVector(column.name, dataStream, sizeOrNullabilityBuffer);\n    } else if (vectorType === VectorType.SEQUENCE) {\n        const id = decodeSequenceIntStream(data, offset, dataStreamMetadata);\n        return new IntSequenceVector(\n            column.name,\n            id[0],\n            id[1],\n            (dataStreamMetadata as RleEncodedStreamMetadata).numRleValues,\n        );\n    } else {\n        const constValue = decodeConstIntStream(data, offset, dataStreamMetadata, isSigned);\n        return new IntConstVector(column.name, constValue, sizeOrNullabilityBuffer);\n    }\n}\n\nfunction isNullabilityBuffer(sizeOrNullabilityBuffer: number | BitVector): sizeOrNullabilityBuffer is BitVector {\n    return sizeOrNullabilityBuffer instanceof BitVector;\n}\n"]}