{"version":3,"file":"geometryDecoder.js","sourceRoot":"","sources":["../../src/decoding/geometryDecoder.ts"],"names":[],"mappings":"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","sourcesContent":["import { type GeometryVector, type MortonSettings } from \"../vector/geometry/geometryVector\";\nimport { decodeStreamMetadata, type MortonEncodedStreamMetadata } from \"../metadata/tile/streamMetadataDecoder\";\nimport type IntWrapper from \"./intWrapper\";\nimport {\n    decodeConstIntStream,\n    decodeIntStream,\n    decodeLengthStreamToOffsetBuffer,\n    getVectorType,\n} from \"./integerStreamDecoder\";\nimport { VectorType } from \"../vector/vectorType\";\nimport { PhysicalStreamType } from \"../metadata/tile/physicalStreamType\";\nimport { LengthType } from \"../metadata/tile/lengthType\";\nimport { DictionaryType } from \"../metadata/tile/dictionaryType\";\nimport TopologyVector from \"../vector/geometry/topologyVector\";\nimport {\n    ConstGeometryVector,\n    createConstGeometryVector,\n    createMortonEncodedConstGeometryVector,\n} from \"../vector/geometry/constGeometryVector\";\nimport {\n    createFlatGeometryVector,\n    createFlatGeometryVectorMortonEncoded,\n    FlatGeometryVector,\n} from \"../vector/geometry/flatGeometryVector\";\nimport { OffsetType } from \"../metadata/tile/offsetType\";\nimport { ConstGpuVector, createConstGpuVector } from \"../vector/geometry/constGpuVector\";\nimport { type GpuVector } from \"../vector/geometry/gpuVector\";\nimport { createFlatGpuVector, FlatGpuVector } from \"../vector/geometry/flatGpuVector\";\nimport type GeometryScaling from \"./geometryScaling\";\n\n// TODO: get rid of numFeatures parameter\nexport function decodeGeometryColumn(\n    tile: Uint8Array,\n    numStreams: number,\n    offset: IntWrapper,\n    numFeatures: number,\n    scalingData?: GeometryScaling,\n): GeometryVector | GpuVector {\n    const geometryTypeMetadata = decodeStreamMetadata(tile, offset);\n    const geometryTypesVectorType = getVectorType(geometryTypeMetadata, numFeatures, tile, offset);\n\n    let geometryOffsets: Int32Array = null;\n    let partOffsets: Int32Array = null;\n    let ringOffsets: Int32Array = null;\n    let vertexOffsets: Int32Array = null;\n    let vertexBuffer: Int32Array = null;\n    let mortonSettings: MortonSettings = null;\n    //TODO: use geometryOffsets for that? -> but then tessellated polygons can't be used with normal polygons\n    // in one FeatureTable?\n    let triangleOffsets: Int32Array = null;\n    let indexBuffer: Int32Array = null;\n\n    if (geometryTypesVectorType === VectorType.CONST) {\n        /* All geometries in the colum have the same geometry type */\n        const geometryType = decodeConstIntStream(tile, offset, geometryTypeMetadata, false);\n\n        for (let i = 0; i < numStreams - 1; i++) {\n            const geometryStreamMetadata = decodeStreamMetadata(tile, offset);\n            switch (geometryStreamMetadata.physicalStreamType) {\n                case PhysicalStreamType.LENGTH:\n                    switch (geometryStreamMetadata.logicalStreamType.lengthType) {\n                        case LengthType.GEOMETRIES:\n                            geometryOffsets = decodeLengthStreamToOffsetBuffer(tile, offset, geometryStreamMetadata);\n                            break;\n                        case LengthType.PARTS:\n                            partOffsets = decodeLengthStreamToOffsetBuffer(tile, offset, geometryStreamMetadata);\n                            break;\n                        case LengthType.RINGS:\n                            ringOffsets = decodeLengthStreamToOffsetBuffer(tile, offset, geometryStreamMetadata);\n                            break;\n                        case LengthType.TRIANGLES:\n                            triangleOffsets = decodeLengthStreamToOffsetBuffer(tile, offset, geometryStreamMetadata);\n                    }\n                    break;\n                case PhysicalStreamType.OFFSET: {\n                    switch (geometryStreamMetadata.logicalStreamType.offsetType) {\n                        case OffsetType.VERTEX:\n                            vertexOffsets = decodeIntStream(tile, offset, geometryStreamMetadata, false);\n                            break;\n                        case OffsetType.INDEX:\n                            indexBuffer = decodeIntStream(tile, offset, geometryStreamMetadata, false);\n                            break;\n                    }\n                    break;\n                }\n                case PhysicalStreamType.DATA: {\n                    if (DictionaryType.VERTEX === geometryStreamMetadata.logicalStreamType.dictionaryType) {\n                        vertexBuffer = decodeIntStream(tile, offset, geometryStreamMetadata, true, scalingData);\n                    } else {\n                        const mortonMetadata = geometryStreamMetadata as MortonEncodedStreamMetadata;\n                        mortonSettings = {\n                            numBits: mortonMetadata.numBits,\n                            coordinateShift: mortonMetadata.coordinateShift,\n                        };\n                        vertexBuffer = decodeIntStream(tile, offset, geometryStreamMetadata, false, scalingData);\n                    }\n                    break;\n                }\n            }\n        }\n\n        if (indexBuffer !== null) {\n            if (geometryOffsets != null || partOffsets != null) {\n                /* Case when the indices of a Polygon outline are encoded in the tile */\n                const topologyVector = new TopologyVector(geometryOffsets, partOffsets, ringOffsets);\n                return createConstGpuVector(\n                    numFeatures,\n                    geometryType,\n                    triangleOffsets,\n                    indexBuffer,\n                    vertexBuffer,\n                    topologyVector,\n                );\n            }\n\n            /* Case when the no Polygon outlines are encoded in the tile */\n            return createConstGpuVector(numFeatures, geometryType, triangleOffsets, indexBuffer, vertexBuffer);\n        }\n\n        return mortonSettings === null\n            ? /* Currently only 2D coordinates (Vec2) are implemented in the encoder  */\n              createConstGeometryVector(\n                  numFeatures,\n                  geometryType,\n                  new TopologyVector(geometryOffsets, partOffsets, ringOffsets),\n                  vertexOffsets,\n                  vertexBuffer,\n              )\n            : createMortonEncodedConstGeometryVector(\n                  numFeatures,\n                  geometryType,\n                  new TopologyVector(geometryOffsets, partOffsets, ringOffsets),\n                  vertexOffsets,\n                  vertexBuffer,\n                  mortonSettings,\n              );\n    }\n\n    /* Different geometry types are mixed in the geometry column */\n    const geometryTypeVector = decodeIntStream(tile, offset, geometryTypeMetadata, false);\n\n    for (let i = 0; i < numStreams - 1; i++) {\n        const geometryStreamMetadata = decodeStreamMetadata(tile, offset);\n        switch (geometryStreamMetadata.physicalStreamType) {\n            case PhysicalStreamType.LENGTH:\n                switch (geometryStreamMetadata.logicalStreamType.lengthType) {\n                    case LengthType.GEOMETRIES:\n                        geometryOffsets = decodeIntStream(tile, offset, geometryStreamMetadata, false);\n                        break;\n                    case LengthType.PARTS:\n                        partOffsets = decodeIntStream(tile, offset, geometryStreamMetadata, false);\n                        break;\n                    case LengthType.RINGS:\n                        ringOffsets = decodeIntStream(tile, offset, geometryStreamMetadata, false);\n                        break;\n                    case LengthType.TRIANGLES:\n                        triangleOffsets = decodeLengthStreamToOffsetBuffer(tile, offset, geometryStreamMetadata);\n                }\n                break;\n            case PhysicalStreamType.OFFSET:\n                switch (geometryStreamMetadata.logicalStreamType.offsetType) {\n                    case OffsetType.VERTEX:\n                        vertexOffsets = decodeIntStream(tile, offset, geometryStreamMetadata, false);\n                        break;\n                    case OffsetType.INDEX:\n                        indexBuffer = decodeIntStream(tile, offset, geometryStreamMetadata, false);\n                        break;\n                }\n                break;\n            case PhysicalStreamType.DATA:\n                if (DictionaryType.VERTEX === geometryStreamMetadata.logicalStreamType.dictionaryType) {\n                    vertexBuffer = decodeIntStream(tile, offset, geometryStreamMetadata, true, scalingData);\n                } else {\n                    const mortonMetadata = geometryStreamMetadata as MortonEncodedStreamMetadata;\n                    mortonSettings = {\n                        numBits: mortonMetadata.numBits,\n                        coordinateShift: mortonMetadata.coordinateShift,\n                    };\n                    vertexBuffer = decodeIntStream(tile, offset, geometryStreamMetadata, false, scalingData);\n                }\n                break;\n        }\n    }\n\n    if (indexBuffer !== null && partOffsets === null) {\n        /* Case when the indices of a Polygon outline are not encoded in the data so no\n         *  topology data are present in the tile */\n        return createFlatGpuVector(geometryTypeVector, triangleOffsets, indexBuffer, vertexBuffer);\n    }\n\n    // TODO: refactor the following instructions -> decode in one pass for performance reasons\n    /* Calculate the offsets from the length buffer for util access */\n    if (geometryOffsets !== null) {\n        geometryOffsets = decodeRootLengthStream(geometryTypeVector, geometryOffsets, 2);\n        if (partOffsets !== null && ringOffsets !== null) {\n            partOffsets = decodeLevel1LengthStream(geometryTypeVector, geometryOffsets, partOffsets, false);\n            ringOffsets = decodeLevel2LengthStream(geometryTypeVector, geometryOffsets, partOffsets, ringOffsets);\n        } else if (partOffsets !== null) {\n            partOffsets = decodeLevel1WithoutRingBufferLengthStream(geometryTypeVector, geometryOffsets, partOffsets);\n        }\n    } else if (partOffsets !== null && ringOffsets !== null) {\n        partOffsets = decodeRootLengthStream(geometryTypeVector, partOffsets, 1);\n        ringOffsets = decodeLevel1LengthStream(geometryTypeVector, partOffsets, ringOffsets, true);\n    } else if (partOffsets !== null) {\n        partOffsets = decodeRootLengthStream(geometryTypeVector, partOffsets, 0);\n    }\n\n    if (indexBuffer !== null) {\n        /* Case when the indices of a Polygon outline are encoded in the tile */\n        return createFlatGpuVector(\n            geometryTypeVector,\n            triangleOffsets,\n            indexBuffer,\n            vertexBuffer,\n            new TopologyVector(geometryOffsets, partOffsets, ringOffsets),\n        );\n    }\n\n    return mortonSettings === null /* Currently only 2D coordinates (Vec2) are implemented in the encoder  */\n        ? createFlatGeometryVector(\n              geometryTypeVector,\n              new TopologyVector(geometryOffsets, partOffsets, ringOffsets),\n              vertexOffsets,\n              vertexBuffer,\n          )\n        : createFlatGeometryVectorMortonEncoded(\n              geometryTypeVector,\n              new TopologyVector(geometryOffsets, partOffsets, ringOffsets),\n              vertexOffsets,\n              vertexBuffer,\n              mortonSettings,\n          );\n}\n\n/*\n * Handle the parsing of the different topology length buffers separate not generic to reduce the\n * branching and improve the performance\n */\nfunction decodeRootLengthStream(geometryTypes: Int32Array, rootLengthStream: Int32Array, bufferId: number): Int32Array {\n    const rootBufferOffsets = new Int32Array(geometryTypes.length + 1);\n    let previousOffset = 0;\n    rootBufferOffsets[0] = previousOffset;\n    let rootLengthCounter = 0;\n    for (let i = 0; i < geometryTypes.length; i++) {\n        /* Test if the geometry has and entry in the root buffer\n         * BufferId: 2 GeometryOffsets -> MultiPolygon, MultiLineString, MultiPoint\n         * BufferId: 1 PartOffsets -> Polygon\n         * BufferId: 0 PartOffsets, RingOffsets -> LineString\n         * */\n        previousOffset = rootBufferOffsets[i + 1] =\n            previousOffset + (geometryTypes[i] > bufferId ? rootLengthStream[rootLengthCounter++] : 1);\n    }\n\n    return rootBufferOffsets;\n}\n\nfunction decodeLevel1LengthStream(\n    geometryTypes: Int32Array,\n    rootOffsetBuffer: Int32Array,\n    level1LengthBuffer: Int32Array,\n    isLineStringPresent: boolean,\n): Int32Array {\n    const level1BufferOffsets = new Int32Array(rootOffsetBuffer[rootOffsetBuffer.length - 1] + 1);\n    let previousOffset = 0;\n    level1BufferOffsets[0] = previousOffset;\n    let level1BufferCounter = 1;\n    let level1LengthBufferCounter = 0;\n    for (let i = 0; i < geometryTypes.length; i++) {\n        const geometryType = geometryTypes[i];\n        const numGeometries = rootOffsetBuffer[i + 1] - rootOffsetBuffer[i];\n        if (\n            geometryType === 5 ||\n            geometryType === 2 ||\n            (isLineStringPresent && (geometryType === 4 || geometryType === 1))\n        ) {\n            /* For MultiPolygon, Polygon and in some cases for MultiLineString and LineString\n             * a value in the level1LengthBuffer exists */\n            for (let j = 0; j < numGeometries; j++) {\n                previousOffset = level1BufferOffsets[level1BufferCounter++] =\n                    previousOffset + level1LengthBuffer[level1LengthBufferCounter++];\n            }\n        } else {\n            /* For MultiPoint and Point and in some cases for MultiLineString and LineString no value in the\n             * level1LengthBuffer exists */\n            for (let j = 0; j < numGeometries; j++) {\n                level1BufferOffsets[level1BufferCounter++] = ++previousOffset;\n            }\n        }\n    }\n\n    return level1BufferOffsets;\n}\n\n/*\n * Case where no ring buffer exists so no MultiPolygon or Polygon geometry is part of the buffer\n */\nfunction decodeLevel1WithoutRingBufferLengthStream(\n    geometryTypes: Int32Array,\n    rootOffsetBuffer: Int32Array,\n    level1LengthBuffer: Int32Array,\n): Int32Array {\n    const level1BufferOffsets = new Int32Array(rootOffsetBuffer[rootOffsetBuffer.length - 1] + 1);\n    let previousOffset = 0;\n    level1BufferOffsets[0] = previousOffset;\n    let level1OffsetBufferCounter = 1;\n    let level1LengthCounter = 0;\n    for (let i = 0; i < geometryTypes.length; i++) {\n        const geometryType = geometryTypes[i];\n        const numGeometries = rootOffsetBuffer[i + 1] - rootOffsetBuffer[i];\n        if (geometryType === 4 || geometryType === 1) {\n            /* For MultiLineString and LineString a value in the level1LengthBuffer exists */\n            for (let j = 0; j < numGeometries; j++) {\n                previousOffset = level1BufferOffsets[level1OffsetBufferCounter++] =\n                    previousOffset + level1LengthBuffer[level1LengthCounter++];\n            }\n        } else {\n            /* For MultiPoint and Point no value in level1LengthBuffer exists */\n            for (let j = 0; j < numGeometries; j++) {\n                level1BufferOffsets[level1OffsetBufferCounter++] = ++previousOffset;\n            }\n        }\n    }\n\n    return level1BufferOffsets;\n}\n\nfunction decodeLevel2LengthStream(\n    geometryTypes: Int32Array,\n    rootOffsetBuffer: Int32Array,\n    level1OffsetBuffer: Int32Array,\n    level2LengthBuffer: Int32Array,\n): Int32Array {\n    const level2BufferOffsets = new Int32Array(level1OffsetBuffer[level1OffsetBuffer.length - 1] + 1);\n    let previousOffset = 0;\n    level2BufferOffsets[0] = previousOffset;\n    let level1OffsetBufferCounter = 1;\n    let level2OffsetBufferCounter = 1;\n    let level2LengthBufferCounter = 0;\n    for (let i = 0; i < geometryTypes.length; i++) {\n        const geometryType = geometryTypes[i];\n        const numGeometries = rootOffsetBuffer[i + 1] - rootOffsetBuffer[i];\n        if (geometryType !== 0 && geometryType !== 3) {\n            /* For MultiPolygon, MultiLineString, Polygon and LineString a value in level2LengthBuffer\n             * exists */\n            for (let j = 0; j < numGeometries; j++) {\n                const numParts =\n                    level1OffsetBuffer[level1OffsetBufferCounter] - level1OffsetBuffer[level1OffsetBufferCounter - 1];\n                level1OffsetBufferCounter++;\n                for (let k = 0; k < numParts; k++) {\n                    previousOffset = level2BufferOffsets[level2OffsetBufferCounter++] =\n                        previousOffset + level2LengthBuffer[level2LengthBufferCounter++];\n                }\n            }\n        } else {\n            /* For MultiPoint and Point no value in level2LengthBuffer exists */\n            for (let j = 0; j < numGeometries; j++) {\n                level2BufferOffsets[level2OffsetBufferCounter++] = ++previousOffset;\n                level1OffsetBufferCounter++;\n            }\n        }\n    }\n\n    return level2BufferOffsets;\n}\n"]}