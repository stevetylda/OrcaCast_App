{"version":3,"file":"stringDecoder.js","sourceRoot":"","sources":["../../src/decoding/stringDecoder.ts"],"names":[],"mappings":"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","sourcesContent":["import { decodeStreamMetadata } from \"../metadata/tile/streamMetadataDecoder\";\nimport { StringFlatVector } from \"../vector/flat/stringFlatVector\";\nimport { StringDictionaryVector } from \"../vector/dictionary/stringDictionaryVector\";\nimport type IntWrapper from \"./intWrapper\";\nimport BitVector from \"../vector/flat/bitVector\";\nimport type Vector from \"../vector/vector\";\nimport { PhysicalStreamType } from \"../metadata/tile/physicalStreamType\";\nimport { DictionaryType } from \"../metadata/tile/dictionaryType\";\nimport { LengthType } from \"../metadata/tile/lengthType\";\nimport { decodeIntStream, decodeLengthStreamToOffsetBuffer, decodeNullableIntStream } from \"./integerStreamDecoder\";\nimport { type Column, ScalarType } from \"../metadata/tileset/tilesetMetadata\";\nimport { decodeVarintInt32 } from \"./integerDecodingUtils\";\nimport { decodeBooleanRle, skipColumn } from \"./decodingUtils\";\nimport { StringFsstDictionaryVector } from \"../vector/fsst-dictionary/stringFsstDictionaryVector\";\n\nconst ROOT_COLUMN_NAME = \"default\";\nconst NESTED_COLUMN_SEPARATOR = \":\";\n\nexport function decodeString(\n    name: string,\n    data: Uint8Array,\n    offset: IntWrapper,\n    numStreams: number,\n    bitVector?: BitVector,\n): Vector {\n    let dictionaryLengthStream: Int32Array = null;\n    let offsetStream: Int32Array = null;\n    let dictionaryStream: Uint8Array = null;\n    let symbolLengthStream: Int32Array = null;\n    let symbolTableStream: Uint8Array = null;\n    let presentStream: BitVector = null;\n    let plainLengthStream: Int32Array = null;\n    let plainDataStream: Uint8Array = null;\n\n    for (let i = 0; i < numStreams; i++) {\n        const streamMetadata = decodeStreamMetadata(data, offset);\n        if (streamMetadata.byteLength === 0) {\n            continue;\n        }\n\n        switch (streamMetadata.physicalStreamType) {\n            case PhysicalStreamType.PRESENT: {\n                const presentData = decodeBooleanRle(data, streamMetadata.numValues, offset);\n                presentStream = new BitVector(presentData, streamMetadata.numValues);\n                break;\n            }\n            case PhysicalStreamType.OFFSET: {\n                const isNullable = bitVector != null || presentStream != null;\n                const nullabilityBuffer = bitVector ?? presentStream;\n                offsetStream = isNullable\n                    ? decodeNullableIntStream(data, offset, streamMetadata, false, nullabilityBuffer)\n                    : decodeIntStream(data, offset, streamMetadata, false);\n                break;\n            }\n            case PhysicalStreamType.LENGTH: {\n                const ls = decodeLengthStreamToOffsetBuffer(data, offset, streamMetadata);\n                if (LengthType.DICTIONARY === streamMetadata.logicalStreamType.lengthType) {\n                    dictionaryLengthStream = ls;\n                } else if (LengthType.SYMBOL === streamMetadata.logicalStreamType.lengthType) {\n                    symbolLengthStream = ls;\n                } else {\n                    // Plain string encoding uses VAR_BINARY length type\n                    plainLengthStream = ls;\n                }\n                break;\n            }\n            case PhysicalStreamType.DATA: {\n                const ds = data.subarray(offset.get(), offset.get() + streamMetadata.byteLength);\n                offset.add(streamMetadata.byteLength);\n                const dictType = streamMetadata.logicalStreamType.dictionaryType;\n                if (DictionaryType.FSST === dictType) {\n                    symbolTableStream = ds;\n                } else if (DictionaryType.SINGLE === dictType || DictionaryType.SHARED === dictType) {\n                    dictionaryStream = ds;\n                } else if (DictionaryType.NONE === dictType) {\n                    plainDataStream = ds;\n                }\n                break;\n            }\n        }\n    }\n\n    return (\n        decodeFsstDictionaryVector(\n            name,\n            symbolTableStream,\n            offsetStream,\n            dictionaryLengthStream,\n            dictionaryStream,\n            symbolLengthStream,\n            bitVector ?? presentStream,\n        ) ??\n        decodeDictionaryVector(\n            name,\n            dictionaryStream,\n            offsetStream,\n            dictionaryLengthStream,\n            bitVector ?? presentStream,\n        ) ??\n        decodePlainStringVector(name, plainLengthStream, plainDataStream, offsetStream, bitVector ?? presentStream)\n    );\n}\n\nfunction decodeFsstDictionaryVector(\n    name: string,\n    symbolTableStream: Uint8Array | null,\n    offsetStream: Int32Array | null,\n    dictionaryLengthStream: Int32Array | null,\n    dictionaryStream: Uint8Array | null,\n    symbolLengthStream: Int32Array | null,\n    nullabilityBuffer: BitVector | null,\n): Vector | null {\n    if (!symbolTableStream) {\n        return null;\n    }\n    return new StringFsstDictionaryVector(\n        name,\n        offsetStream,\n        dictionaryLengthStream,\n        dictionaryStream,\n        symbolLengthStream,\n        symbolTableStream,\n        nullabilityBuffer,\n    );\n}\n\nfunction decodeDictionaryVector(\n    name: string,\n    dictionaryStream: Uint8Array | null,\n    offsetStream: Int32Array | null,\n    dictionaryLengthStream: Int32Array | null,\n    nullabilityBuffer: BitVector | null,\n): Vector | null {\n    if (!dictionaryStream) {\n        return null;\n    }\n    return nullabilityBuffer\n        ? new StringDictionaryVector(name, offsetStream, dictionaryLengthStream, dictionaryStream, nullabilityBuffer)\n        : new StringDictionaryVector(name, offsetStream, dictionaryLengthStream, dictionaryStream);\n}\n\nfunction decodePlainStringVector(\n    name: string,\n    plainLengthStream: Int32Array | null,\n    plainDataStream: Uint8Array | null,\n    offsetStream: Int32Array | null,\n    nullabilityBuffer: BitVector | null,\n): Vector | null {\n    if (!plainLengthStream || !plainDataStream) {\n        return null;\n    }\n\n    if (offsetStream) {\n        return nullabilityBuffer\n            ? new StringDictionaryVector(name, offsetStream, plainLengthStream, plainDataStream, nullabilityBuffer)\n            : new StringDictionaryVector(name, offsetStream, plainLengthStream, plainDataStream);\n    }\n\n    if (nullabilityBuffer && nullabilityBuffer.size() !== plainLengthStream.length - 1) {\n        const sparseOffsetStream = new Int32Array(nullabilityBuffer.size());\n        let valueIndex = 0;\n        for (let i = 0; i < nullabilityBuffer.size(); i++) {\n            if (nullabilityBuffer.get(i)) {\n                sparseOffsetStream[i] = valueIndex++;\n            } else {\n                sparseOffsetStream[i] = 0;\n            }\n        }\n        return new StringDictionaryVector(\n            name,\n            sparseOffsetStream,\n            plainLengthStream,\n            plainDataStream,\n            nullabilityBuffer,\n        );\n    }\n\n    return nullabilityBuffer\n        ? new StringFlatVector(name, plainLengthStream, plainDataStream, nullabilityBuffer)\n        : new StringFlatVector(name, plainLengthStream, plainDataStream);\n}\n\nexport function decodeSharedDictionary(\n    data: Uint8Array,\n    offset: IntWrapper,\n    column: Column,\n    numFeatures: number,\n    propertyColumnNames?: Set<string>,\n): Vector[] {\n    let dictionaryOffsetBuffer: Int32Array = null;\n    let dictionaryBuffer: Uint8Array = null;\n    let symbolOffsetBuffer: Int32Array = null;\n    let symbolTableBuffer: Uint8Array = null;\n\n    let dictionaryStreamDecoded = false;\n    while (!dictionaryStreamDecoded) {\n        const streamMetadata = decodeStreamMetadata(data, offset);\n        switch (streamMetadata.physicalStreamType) {\n            case PhysicalStreamType.LENGTH:\n                if (LengthType.DICTIONARY === streamMetadata.logicalStreamType.lengthType) {\n                    dictionaryOffsetBuffer = decodeLengthStreamToOffsetBuffer(data, offset, streamMetadata);\n                } else {\n                    symbolOffsetBuffer = decodeLengthStreamToOffsetBuffer(data, offset, streamMetadata);\n                }\n                break;\n            case PhysicalStreamType.DATA:\n                if (\n                    DictionaryType.SINGLE === streamMetadata.logicalStreamType.dictionaryType ||\n                    DictionaryType.SHARED === streamMetadata.logicalStreamType.dictionaryType\n                ) {\n                    dictionaryBuffer = data.subarray(offset.get(), offset.get() + streamMetadata.byteLength);\n                    dictionaryStreamDecoded = true;\n                } else {\n                    symbolTableBuffer = data.subarray(offset.get(), offset.get() + streamMetadata.byteLength);\n                }\n                offset.add(streamMetadata.byteLength);\n                break;\n        }\n    }\n\n    const childFields = column.complexType.children;\n    const stringDictionaryVectors = [];\n    let i = 0;\n    for (const childField of childFields) {\n        const numStreams = decodeVarintInt32(data, offset, 1)[0];\n        if (numStreams == 0) {\n            /* Column is not present in the tile */\n            continue;\n        }\n\n        const columnName = `${column.name}${\n            childField.name === ROOT_COLUMN_NAME ? \"\" : NESTED_COLUMN_SEPARATOR + childField.name\n        }`;\n        if (propertyColumnNames) {\n            if (!propertyColumnNames.has(columnName)) {\n                //TODO: add size of sub column to Mlt for faster skipping\n                skipColumn(numStreams, data, offset);\n                continue;\n            }\n        }\n\n        if (\n            numStreams !== 2 ||\n            childField.type !== \"scalarField\" ||\n            childField.scalarField.physicalType !== ScalarType.STRING\n        ) {\n            throw new Error(\"Currently only optional string fields are implemented for a struct.\");\n        }\n\n        const presentStreamMetadata = decodeStreamMetadata(data, offset);\n        const presentStream = decodeBooleanRle(data, presentStreamMetadata.numValues, offset);\n        const offsetStreamMetadata = decodeStreamMetadata(data, offset);\n        const offsetCount = offsetStreamMetadata.decompressedCount;\n        const isNullable = offsetCount !== numFeatures;\n        const offsetStream = isNullable\n            ? decodeNullableIntStream(\n                  data,\n                  offset,\n                  offsetStreamMetadata,\n                  false,\n                  new BitVector(presentStream, presentStreamMetadata.numValues),\n              )\n            : decodeIntStream(data, offset, offsetStreamMetadata, false);\n\n        stringDictionaryVectors[i++] = symbolTableBuffer\n            ? new StringFsstDictionaryVector(\n                  columnName,\n                  offsetStream,\n                  dictionaryOffsetBuffer,\n                  dictionaryBuffer,\n                  symbolOffsetBuffer,\n                  symbolTableBuffer,\n                  new BitVector(presentStream, presentStreamMetadata.numValues),\n              )\n            : new StringDictionaryVector(\n                  columnName,\n                  offsetStream,\n                  dictionaryOffsetBuffer,\n                  dictionaryBuffer,\n                  new BitVector(presentStream, presentStreamMetadata.numValues),\n              );\n    }\n\n    return stringDictionaryVectors;\n}\n"]}