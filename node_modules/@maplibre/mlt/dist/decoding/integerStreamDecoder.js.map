{"version":3,"file":"integerStreamDecoder.js","sourceRoot":"","sources":["../../src/decoding/integerStreamDecoder.ts"],"names":[],"mappings":"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","sourcesContent":["import { PhysicalLevelTechnique } from \"../metadata/tile/physicalLevelTechnique\";\nimport type IntWrapper from \"./intWrapper\";\nimport {\n    decodeComponentwiseDeltaVec2,\n    decodeComponentwiseDeltaVec2Scaled,\n    decodeDeltaRle,\n    decodeDeltaRleInt64,\n    decodeFastPfor,\n    decodeNullableRle,\n    decodeNullableRleInt64,\n    decodeNullableZigZagDelta,\n    decodeNullableZigZagDeltaInt64,\n    decodeRle,\n    decodeRleFloat64,\n    decodeRleInt64,\n    decodeUnsignedConstRle,\n    decodeUnsignedConstRleInt64,\n    decodeUnsignedRle,\n    decodeUnsignedRleFloat64,\n    decodeUnsignedRleInt64,\n    decodeVarintInt32,\n    decodeVarintInt64,\n    decodeVarintFloat64,\n    decodeZigZag,\n    decodeZigZagConstRle,\n    decodeZigZagConstRleInt64,\n    decodeZigZagDelta,\n    decodeZigZagDeltaFloat64,\n    decodeZigZagDeltaInt64,\n    decodeZigZagFloat64,\n    decodeZigZagInt64,\n    decodeZigZagSequenceRle,\n    decodeZigZagSequenceRleInt64,\n    decodeZigZagValue,\n    decodeZigZagValueInt64,\n    fastInverseDelta,\n    inverseDelta,\n    padWithZeros,\n    padWithZerosInt64,\n    padZigZagWithZeros,\n    padZigZagWithZerosInt64,\n    rleDeltaDecoding,\n    zigZagDeltaOfDeltaDecoding,\n    zigZagRleDeltaDecoding,\n} from \"./integerDecodingUtils\";\nimport { LogicalLevelTechnique } from \"../metadata/tile/logicalLevelTechnique\";\nimport { type StreamMetadata, type RleEncodedStreamMetadata } from \"../metadata/tile/streamMetadataDecoder\";\nimport BitVector from \"../vector/flat/bitVector\";\nimport { VectorType } from \"../vector/vectorType\";\nimport type GeometryScaling from \"./geometryScaling\";\n\nexport function decodeIntStream(\n    data: Uint8Array,\n    offset: IntWrapper,\n    streamMetadata: StreamMetadata,\n    isSigned: boolean,\n    scalingData?: GeometryScaling,\n): Int32Array {\n    const values = decodePhysicalLevelTechnique(data, offset, streamMetadata);\n    return decodeIntBuffer(values, streamMetadata, isSigned, scalingData);\n}\n\nexport function decodeLengthStreamToOffsetBuffer(\n    data: Uint8Array,\n    offset: IntWrapper,\n    streamMetadata: StreamMetadata,\n): Int32Array {\n    const values = decodePhysicalLevelTechnique(data, offset, streamMetadata);\n    return decodeLengthToOffsetBuffer(values, streamMetadata);\n}\n\nfunction decodePhysicalLevelTechnique(data: Uint8Array, offset: IntWrapper, streamMetadata: StreamMetadata) {\n    const physicalLevelTechnique = streamMetadata.physicalLevelTechnique;\n    if (physicalLevelTechnique === PhysicalLevelTechnique.FAST_PFOR) {\n        return decodeFastPfor(data, streamMetadata.numValues, streamMetadata.byteLength, offset);\n    }\n    if (physicalLevelTechnique === PhysicalLevelTechnique.VARINT) {\n        return decodeVarintInt32(data, offset, streamMetadata.numValues);\n    }\n\n    if (physicalLevelTechnique === PhysicalLevelTechnique.NONE) {\n        const dataOffset = offset.get();\n        const byteLength = streamMetadata.byteLength;\n        offset.add(byteLength);\n        //TODO: use Byte Rle for geometry type encoding\n        const slice = data.subarray(dataOffset, offset.get());\n        return new Int32Array(slice);\n    }\n\n    throw new Error(\"Specified physicalLevelTechnique is not supported (yet).\");\n}\n\nexport function decodeConstIntStream(\n    data: Uint8Array,\n    offset: IntWrapper,\n    streamMetadata: StreamMetadata,\n    isSigned: boolean,\n): number {\n    const values = decodePhysicalLevelTechnique(data, offset, streamMetadata);\n\n    if (values.length === 1) {\n        const value = values[0];\n        return isSigned ? decodeZigZagValue(value) : value;\n    }\n\n    return isSigned ? decodeZigZagConstRle(values) : decodeUnsignedConstRle(values);\n}\n\nexport function decodeSequenceIntStream(\n    data: Uint8Array,\n    offset: IntWrapper,\n    streamMetadata: StreamMetadata,\n): [baseValue: number, delta: number] {\n    const values = decodePhysicalLevelTechnique(data, offset, streamMetadata);\n    return decodeZigZagSequenceRle(values);\n}\n\nexport function decodeSequenceLongStream(\n    data: Uint8Array,\n    offset: IntWrapper,\n    streamMetadata: StreamMetadata,\n): [baseValue: bigint, delta: bigint] {\n    const values = decodeVarintInt64(data, offset, streamMetadata.numValues);\n    return decodeZigZagSequenceRleInt64(values);\n}\n\nexport function decodeLongStream(\n    data: Uint8Array,\n    offset: IntWrapper,\n    streamMetadata: StreamMetadata,\n    isSigned: boolean,\n): BigInt64Array {\n    const values = decodeVarintInt64(data, offset, streamMetadata.numValues);\n    return decodeLongBuffer(values, streamMetadata, isSigned);\n}\n\nexport function decodeLongFloat64Stream(\n    data: Uint8Array,\n    offset: IntWrapper,\n    streamMetadata: StreamMetadata,\n    isSigned: boolean,\n): Float64Array {\n    const values = decodeVarintFloat64(data, streamMetadata.numValues, offset);\n    return decodeFloat64Buffer(values, streamMetadata, isSigned);\n}\n\nexport function decodeConstLongStream(\n    data: Uint8Array,\n    offset: IntWrapper,\n    streamMetadata: StreamMetadata,\n    isSigned: boolean,\n): bigint {\n    const values = decodeVarintInt64(data, offset, streamMetadata.numValues);\n\n    if (values.length === 1) {\n        const value = values[0];\n        return isSigned ? decodeZigZagValueInt64(value) : value;\n    }\n\n    return isSigned ? decodeZigZagConstRleInt64(values) : decodeUnsignedConstRleInt64(values);\n}\n\nfunction decodeIntBuffer(\n    values: Int32Array,\n    streamMetadata: StreamMetadata,\n    isSigned: boolean,\n    scalingData?: GeometryScaling,\n): Int32Array {\n    /*\n     * Currently the encoder uses only fixed combinations of encodings.\n     * For performance reasons it is also used a fixed combination of the encodings on the decoding side.\n     * The following encodings and combinations are used:\n     *   - Morton Delta -> always sorted so not ZigZag encoding needed\n     *   - Delta -> currently always in combination with ZigZag encoding\n     *   - Rle -> in combination with ZigZag encoding if data type is signed\n     *   - Delta Rle\n     *   - Componentwise Delta -> always ZigZag encoding is used\n     * */\n    switch (streamMetadata.logicalLevelTechnique1) {\n        case LogicalLevelTechnique.DELTA:\n            if (streamMetadata.logicalLevelTechnique2 === LogicalLevelTechnique.RLE) {\n                const rleMetadata = streamMetadata as RleEncodedStreamMetadata;\n                return decodeDeltaRle(values, rleMetadata.runs, rleMetadata.numRleValues);\n            }\n            decodeZigZagDelta(values);\n            return values;\n        case LogicalLevelTechnique.RLE:\n            return decodeRle(values, streamMetadata as RleEncodedStreamMetadata, isSigned);\n        case LogicalLevelTechnique.MORTON:\n            fastInverseDelta(values);\n            return values;\n        case LogicalLevelTechnique.COMPONENTWISE_DELTA:\n            if (scalingData) {\n                decodeComponentwiseDeltaVec2Scaled(values, scalingData.scale, scalingData.min, scalingData.max);\n                return values;\n            }\n\n            decodeComponentwiseDeltaVec2(values);\n            return values;\n        case LogicalLevelTechnique.NONE:\n            if (isSigned) {\n                decodeZigZag(values);\n            }\n            return values;\n        default:\n            throw new Error(\n                `The specified Logical level technique is not supported: ${streamMetadata.logicalLevelTechnique1}`,\n            );\n    }\n}\n\nfunction decodeLongBuffer(values: BigInt64Array, streamMetadata: StreamMetadata, isSigned: boolean): BigInt64Array {\n    switch (streamMetadata.logicalLevelTechnique1) {\n        case LogicalLevelTechnique.DELTA:\n            if (streamMetadata.logicalLevelTechnique2 === LogicalLevelTechnique.RLE) {\n                const rleMetadata = streamMetadata as RleEncodedStreamMetadata;\n                return decodeDeltaRleInt64(values, rleMetadata.runs, rleMetadata.numRleValues);\n            }\n            decodeZigZagDeltaInt64(values);\n            return values;\n        case LogicalLevelTechnique.RLE:\n            return decodeRleInt64(values, streamMetadata as RleEncodedStreamMetadata, isSigned);\n        case LogicalLevelTechnique.NONE:\n            if (isSigned) {\n                decodeZigZagInt64(values);\n            }\n            return values;\n        default:\n            throw new Error(\n                `The specified Logical level technique is not supported: ${streamMetadata.logicalLevelTechnique1}`,\n            );\n    }\n}\n\nexport function decodeFloat64Buffer(\n    values: Float64Array,\n    streamMetadata: StreamMetadata,\n    isSigned: boolean,\n): Float64Array {\n    switch (streamMetadata.logicalLevelTechnique1) {\n        case LogicalLevelTechnique.DELTA:\n            if (streamMetadata.logicalLevelTechnique2 === LogicalLevelTechnique.RLE) {\n                const rleMetadata = streamMetadata as RleEncodedStreamMetadata;\n                values = decodeUnsignedRleFloat64(values, rleMetadata.runs, rleMetadata.numRleValues);\n            }\n            decodeZigZagDeltaFloat64(values);\n            return values;\n        case LogicalLevelTechnique.RLE:\n            return decodeRleFloat64(values, streamMetadata as RleEncodedStreamMetadata, isSigned);\n        case LogicalLevelTechnique.NONE:\n            if (isSigned) {\n                decodeZigZagFloat64(values);\n            }\n            return values;\n        default:\n            throw new Error(\n                `The specified Logical level technique is not supported: ${streamMetadata.logicalLevelTechnique1}`,\n            );\n    }\n}\n\nfunction decodeLengthToOffsetBuffer(values: Int32Array, streamMetadata: StreamMetadata): Int32Array {\n    if (\n        streamMetadata.logicalLevelTechnique1 === LogicalLevelTechnique.DELTA &&\n        streamMetadata.logicalLevelTechnique2 === LogicalLevelTechnique.NONE\n    ) {\n        const decodedValues = zigZagDeltaOfDeltaDecoding(values);\n        return decodedValues;\n    }\n\n    if (\n        streamMetadata.logicalLevelTechnique1 === LogicalLevelTechnique.RLE &&\n        streamMetadata.logicalLevelTechnique2 === LogicalLevelTechnique.NONE\n    ) {\n        const rleMetadata = streamMetadata as RleEncodedStreamMetadata;\n        const decodedValues = rleDeltaDecoding(values, rleMetadata.runs, rleMetadata.numRleValues);\n        return decodedValues;\n    }\n\n    if (\n        streamMetadata.logicalLevelTechnique1 === LogicalLevelTechnique.NONE &&\n        streamMetadata.logicalLevelTechnique2 === LogicalLevelTechnique.NONE\n    ) {\n        //TODO: use fastInverseDelta again and check what are the performance problems in zoom 14\n        //fastInverseDelta(values);\n        inverseDelta(values);\n        const offsets = new Int32Array(streamMetadata.numValues + 1);\n        offsets[0] = 0;\n        offsets.set(values, 1);\n        return offsets;\n    }\n\n    if (\n        streamMetadata.logicalLevelTechnique1 === LogicalLevelTechnique.DELTA &&\n        streamMetadata.logicalLevelTechnique2 === LogicalLevelTechnique.RLE\n    ) {\n        const rleMetadata = streamMetadata as RleEncodedStreamMetadata;\n        const decodedValues = zigZagRleDeltaDecoding(values, rleMetadata.runs, rleMetadata.numRleValues);\n        fastInverseDelta(decodedValues);\n        return decodedValues;\n    }\n\n    throw new Error(\"Only delta encoding is supported for transforming length to offset streams yet.\");\n}\n\nexport function decodeNullableIntStream(\n    data: Uint8Array,\n    offset: IntWrapper,\n    streamMetadata: StreamMetadata,\n    isSigned: boolean,\n    bitVector: BitVector,\n): Int32Array {\n    const values =\n        streamMetadata.physicalLevelTechnique === PhysicalLevelTechnique.FAST_PFOR\n            ? decodeFastPfor(data, streamMetadata.numValues, streamMetadata.byteLength, offset)\n            : decodeVarintInt32(data, offset, streamMetadata.numValues);\n\n    return decodeNullableIntBuffer(values, streamMetadata, isSigned, bitVector);\n}\n\nexport function decodeNullableLongStream(\n    data: Uint8Array,\n    offset: IntWrapper,\n    streamMetadata: StreamMetadata,\n    isSigned: boolean,\n    bitVector: BitVector,\n): BigInt64Array {\n    const values = decodeVarintInt64(data, offset, streamMetadata.numValues);\n    return decodeNullableLongBuffer(values, streamMetadata, isSigned, bitVector);\n}\n\nfunction decodeNullableIntBuffer(\n    values: Int32Array,\n    streamMetadata: StreamMetadata,\n    isSigned: boolean,\n    bitVector: BitVector,\n): Int32Array {\n    switch (streamMetadata.logicalLevelTechnique1) {\n        case LogicalLevelTechnique.DELTA:\n            if (streamMetadata.logicalLevelTechnique2 === LogicalLevelTechnique.RLE) {\n                const rleMetadata = streamMetadata as RleEncodedStreamMetadata;\n                values = decodeUnsignedRle(values, rleMetadata.runs, rleMetadata.numRleValues);\n            }\n            return decodeNullableZigZagDelta(bitVector, values);\n        case LogicalLevelTechnique.RLE:\n            return decodeNullableRle(values, streamMetadata, isSigned, bitVector);\n        case LogicalLevelTechnique.MORTON:\n            fastInverseDelta(values);\n            return values;\n        case LogicalLevelTechnique.COMPONENTWISE_DELTA:\n            decodeComponentwiseDeltaVec2(values);\n            return values;\n        case LogicalLevelTechnique.NONE:\n            values = isSigned ? padZigZagWithZeros(bitVector, values) : padWithZeros(bitVector, values);\n            return values;\n        default:\n            throw new Error(\"The specified Logical level technique is not supported\");\n    }\n}\n\nfunction decodeNullableLongBuffer(\n    values: BigInt64Array,\n    streamMetadata: StreamMetadata,\n    isSigned: boolean,\n    bitVector: BitVector,\n): BigInt64Array {\n    switch (streamMetadata.logicalLevelTechnique1) {\n        case LogicalLevelTechnique.DELTA:\n            if (streamMetadata.logicalLevelTechnique2 === LogicalLevelTechnique.RLE) {\n                const rleMetadata = streamMetadata as RleEncodedStreamMetadata;\n                values = decodeUnsignedRleInt64(values, rleMetadata.runs, rleMetadata.numRleValues);\n            }\n            return decodeNullableZigZagDeltaInt64(bitVector, values);\n        case LogicalLevelTechnique.RLE:\n            return decodeNullableRleInt64(values, streamMetadata, isSigned, bitVector);\n        case LogicalLevelTechnique.NONE:\n            values = isSigned ? padZigZagWithZerosInt64(bitVector, values) : padWithZerosInt64(bitVector, values);\n            return values;\n        default:\n            throw new Error(\"The specified Logical level technique is not supported\");\n    }\n}\n\nexport function getVectorType(\n    streamMetadata: StreamMetadata,\n    sizeOrNullabilityBuffer: number | BitVector,\n    data: Uint8Array,\n    offset: IntWrapper,\n): VectorType {\n    const logicalLevelTechnique1 = streamMetadata.logicalLevelTechnique1;\n    if (logicalLevelTechnique1 === LogicalLevelTechnique.RLE) {\n        return (streamMetadata as RleEncodedStreamMetadata).runs === 1 ? VectorType.CONST : VectorType.FLAT;\n    }\n\n    const numFeatures =\n        sizeOrNullabilityBuffer instanceof BitVector ? sizeOrNullabilityBuffer.size() : sizeOrNullabilityBuffer;\n\n    if (\n        logicalLevelTechnique1 === LogicalLevelTechnique.DELTA &&\n        streamMetadata.logicalLevelTechnique2 === LogicalLevelTechnique.RLE\n    ) {\n        const rleMetadata = streamMetadata as RleEncodedStreamMetadata;\n        const runs = rleMetadata.runs;\n        const zigZagOne = 2;\n\n        if (rleMetadata.numRleValues !== numFeatures) {\n            return VectorType.FLAT;\n        }\n        // Single run is always a sequence\n        if (runs === 1) {\n            return VectorType.SEQUENCE;\n        }\n        // Two runs can be a sequence if both deltas are equal to 1\n        if (runs === 2) {\n            const savedOffset = offset.get();\n\n            let values: Int32Array;\n            if (streamMetadata.physicalLevelTechnique === PhysicalLevelTechnique.VARINT) {\n                values = decodeVarintInt32(data, offset, 4);\n            } else {\n                const byteOffset = offset.get();\n                values = new Int32Array(data.buffer, data.byteOffset + byteOffset, 4);\n            }\n            offset.set(savedOffset);\n            // Check if both deltas are encoded 1\n            if (values[2] === zigZagOne && values[3] === zigZagOne) {\n                return VectorType.SEQUENCE;\n            }\n        }\n    }\n\n    return streamMetadata.numValues === 1 ? VectorType.CONST : VectorType.FLAT;\n}\n"]}