{"version":3,"file":"decodingUtils.spec.js","sourceRoot":"","sources":["../../src/decoding/decodingUtils.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import { describe, it, expect } from \"vitest\";\nimport {\n    decodeFloatsLE,\n    decodeDoublesLE,\n    decodeBooleanRle,\n    decodeString,\n    decodeByteRle,\n    decodeNullableFloatsLE,\n    decodeNullableDoublesLE,\n} from \"./decodingUtils\";\nimport IntWrapper from \"./intWrapper\";\nimport BitVector from \"../vector/flat/bitVector\";\n\ndescribe(\"decodingUtils\", () => {\n    describe(\"decodeFloatsLE\", () => {\n        it(\"should decode float values from little-endian bytes\", () => {\n            const buffer = new ArrayBuffer(8);\n            const view = new Float32Array(buffer);\n            view[0] = 1.5;\n            view[1] = 2.5;\n\n            const data = new Uint8Array(buffer);\n            const offset = new IntWrapper(0);\n            const result = decodeFloatsLE(data, offset, 2);\n\n            expect(result[0]).toBeCloseTo(1.5);\n            expect(result[1]).toBeCloseTo(2.5);\n            expect(offset.get()).toBe(8);\n        });\n    });\n\n    describe(\"decodeDoublesLE\", () => {\n        it(\"should decode double values from little-endian bytes\", () => {\n            const buffer = new ArrayBuffer(16);\n            const view = new Float64Array(buffer);\n            view[0] = 3.14159;\n            view[1] = 2.71828;\n\n            const data = new Uint8Array(buffer);\n            const offset = new IntWrapper(0);\n            const result = decodeDoublesLE(data, offset, 2);\n\n            expect(result[0]).toBeCloseTo(3.14159);\n            expect(result[1]).toBeCloseTo(2.71828);\n            expect(offset.get()).toBe(16);\n        });\n    });\n\n    describe(\"decodeNullableFloatsLE\", () => {\n        it(\"should decode nullable float values with nullability buffer\", () => {\n            const buffer = new ArrayBuffer(8);\n            const view = new Float32Array(buffer);\n            view[0] = 1.5;\n            view[1] = 2.5;\n\n            const data = new Uint8Array(buffer);\n            const offset = new IntWrapper(0);\n            const bitVectorData = new Uint8Array([0b00000101]); // bits 0 and 2 are set\n            const nullabilityBuffer = new BitVector(bitVectorData, 3);\n\n            const result = decodeNullableFloatsLE(data, offset, nullabilityBuffer, 2);\n\n            expect(result.length).toBe(3);\n            expect(result[0]).toBeCloseTo(1.5); // bit 0 is set\n            expect(result[1]).toBe(0); // bit 1 is not set (null)\n            expect(result[2]).toBeCloseTo(2.5); // bit 2 is set\n        });\n    });\n\n    describe(\"decodeNullableDoublesLE\", () => {\n        it(\"should decode nullable double values with nullability buffer\", () => {\n            const buffer = new ArrayBuffer(16);\n            const view = new Float64Array(buffer);\n            view[0] = 3.14159;\n            view[1] = 2.71828;\n\n            const data = new Uint8Array(buffer);\n            const offset = new IntWrapper(0);\n            const bitVectorData = new Uint8Array([0b00000011]); // bits 0 and 1 are set\n            const nullabilityBuffer = new BitVector(bitVectorData, 2);\n\n            const result = decodeNullableDoublesLE(data, offset, nullabilityBuffer, 2);\n\n            expect(result.length).toBe(2);\n            expect(result[0]).toBeCloseTo(3.14159); // bit 0 is set\n            expect(result[1]).toBeCloseTo(2.71828); // bit 1 is set\n        });\n    });\n\n    describe(\"decodeBooleanRle\", () => {\n        it(\"should decode boolean RLE\", () => {\n            const buffer = new Uint8Array([254, 0xff]);\n            const offset = new IntWrapper(0);\n            const result = decodeBooleanRle(buffer, 8, offset);\n\n            expect(result[0]).toBe(0xff);\n        });\n    });\n\n    describe(\"decodeByteRle\", () => {\n        it(\"should decode byte RLE with runs\", () => {\n            // header=2 means numRuns=2+3=5, followed by value byte\n            const data = new Uint8Array([2, 42]);\n            const offset = new IntWrapper(0);\n            const result = decodeByteRle(data, 5, offset);\n\n            expect(result.length).toBe(5);\n            expect(result[0]).toBe(42);\n            expect(result[1]).toBe(42);\n            expect(result[2]).toBe(42);\n            expect(result[3]).toBe(42);\n            expect(result[4]).toBe(42);\n        });\n\n        it(\"should decode byte RLE with literals\", () => {\n            // header=253 means numLiterals=256-253=3, followed by 3 literal bytes\n            const data = new Uint8Array([253, 1, 2, 3]);\n            const offset = new IntWrapper(0);\n            const result = decodeByteRle(data, 3, offset);\n\n            expect(result.length).toBe(3);\n            expect(result[0]).toBe(1);\n            expect(result[1]).toBe(2);\n            expect(result[2]).toBe(3);\n        });\n    });\n\n    describe(\"decodeString\", () => {\n        it(\"should decode short string\", () => {\n            const text = \"Hello\";\n            const buffer = new TextEncoder().encode(text);\n            const result = decodeString(buffer, 0, buffer.length);\n\n            expect(result).toBe(text);\n        });\n\n        it(\"should decode long string\", () => {\n            const text = \"This is a longer string for testing TextDecoder path\";\n            const buffer = new TextEncoder().encode(text);\n            const result = decodeString(buffer, 0, buffer.length);\n\n            expect(result).toBe(text);\n        });\n\n        it(\"should handle string with offset\", () => {\n            const text = \"World\";\n            const prefix = new TextEncoder().encode(\"Hello\");\n            const textBytes = new TextEncoder().encode(text);\n            const combined = new Uint8Array(prefix.length + textBytes.length);\n            combined.set(prefix, 0);\n            combined.set(textBytes, prefix.length);\n\n            // decodeString takes (buffer, start, end) where end is the position after the last byte\n            const result = decodeString(combined, prefix.length, prefix.length + textBytes.length);\n\n            expect(result).toBe(text);\n        });\n    });\n});\n"]}