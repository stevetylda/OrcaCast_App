{"version":3,"file":"propertyDecoder.spec.js","sourceRoot":"","sources":["../../src/decoding/propertyDecoder.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import { afterEach, describe, expect, it, vi } from \"vitest\";\nimport * as StreamMetadataDecoder from \"../metadata/tile/streamMetadataDecoder\";\nimport * as IntegerStreamDecoder from \"./integerStreamDecoder\";\nimport { decodePropertyColumn } from \"./propertyDecoder\";\nimport { type Column } from \"../metadata/tileset/tilesetMetadata\";\nimport { ScalarType } from \"../metadata/tile/scalarType\";\nimport IntWrapper from \"./intWrapper\";\nimport { IntFlatVector } from \"../vector/flat/intFlatVector\";\nimport { LongFlatVector } from \"../vector/flat/longFlatVector\";\nimport { IntSequenceVector } from \"../vector/sequence/intSequenceVector\";\nimport { LongSequenceVector } from \"../vector/sequence/longSequenceVector\";\nimport { IntConstVector } from \"../vector/constant/intConstVector\";\nimport { LongConstVector } from \"../vector/constant/longConstVector\";\nimport { VectorType } from \"../vector/vectorType\";\nimport * as StringDecoder from \"./stringDecoder\";\nimport * as decodingUtils from \"./decodingUtils\";\nimport { BooleanFlatVector } from \"../vector/flat/booleanFlatVector\";\nimport { FloatFlatVector } from \"../vector/flat/floatFlatVector\";\nimport { DoubleFlatVector } from \"../vector/flat/doubleFlatVector\";\nimport { type StringFlatVector } from \"../vector/flat/stringFlatVector\";\n\n// Constants for test data\nconst TEST_DATA = {\n    BYTE_LENGTH: 12,\n    NUM_VALUES: 3,\n    NULLABILITY_BYTE_LENGTH: 1,\n    BUFFER_SIZE: 100,\n};\n\n// Helper: Create column with specific configuration\nfunction createColumn(scalarType: ScalarType, nullable: boolean = false): Column {\n    return {\n        name: \"age\",\n        nullable,\n        columnScope: null,\n        type: \"scalarType\",\n        scalarType: {\n            longID: false,\n            physicalType: scalarType,\n            logicalType: null,\n            type: \"physicalType\",\n        },\n        complexType: null,\n    };\n}\n\n// Helper: Setup stream metadata mock\nfunction mockStreamMetadata(byteLength: number = TEST_DATA.BYTE_LENGTH, numValues: number = TEST_DATA.NUM_VALUES) {\n    return {\n        byteLength,\n        numValues,\n        logicalLevelTechnique1: 0,\n        logicalLevelTechnique2: 0,\n        physicalLevelTechnique: 0,\n    } as any;\n}\n\n// Helper: Setup RLE stream metadata for sequence encoding\nfunction mockRleStreamMetadata(\n    byteLength: number = TEST_DATA.BYTE_LENGTH,\n    numValues: number = TEST_DATA.NUM_VALUES,\n    numRleValues: number = 2,\n) {\n    return {\n        byteLength,\n        numValues,\n        numRleValues,\n        logicalLevelTechnique1: 0,\n        logicalLevelTechnique2: 0,\n        physicalLevelTechnique: 0,\n    } as any;\n}\n\n// Helper: Mock integer decoders (INT_32 or INT_64)\nfunction mockIntegerDecoder(scalarType: ScalarType) {\n    vi.spyOn(IntegerStreamDecoder, \"getVectorType\").mockReturnValue(VectorType.FLAT);\n\n    if (scalarType === ScalarType.INT_64 || scalarType === ScalarType.UINT_64) {\n        vi.spyOn(IntegerStreamDecoder, \"decodeLongStream\").mockReturnValue(new BigInt64Array([100n, 200n, 300n]));\n    } else {\n        vi.spyOn(IntegerStreamDecoder, \"decodeIntStream\").mockReturnValue(new Int32Array([100, 200, 300]));\n    }\n}\n\n// Helper: Mock integer sequence decoders\nfunction mockIntegerSequenceDecoder(scalarType: ScalarType) {\n    vi.spyOn(IntegerStreamDecoder, \"getVectorType\").mockReturnValue(VectorType.SEQUENCE);\n\n    if (scalarType === ScalarType.INT_64 || scalarType === ScalarType.UINT_64) {\n        vi.spyOn(IntegerStreamDecoder, \"decodeSequenceLongStream\").mockReturnValue([10n, 20n]);\n    } else {\n        vi.spyOn(IntegerStreamDecoder, \"decodeSequenceIntStream\").mockReturnValue([10, 20]);\n    }\n}\n\n// Helper: Mock integer const decoders\nfunction mockIntegerConstDecoder(scalarType: ScalarType) {\n    vi.spyOn(IntegerStreamDecoder, \"getVectorType\").mockReturnValue(VectorType.CONST);\n\n    if (scalarType === ScalarType.INT_64 || scalarType === ScalarType.UINT_64) {\n        vi.spyOn(IntegerStreamDecoder, \"decodeConstLongStream\").mockReturnValue(42n);\n    } else {\n        vi.spyOn(IntegerStreamDecoder, \"decodeConstIntStream\").mockReturnValue(42);\n    }\n}\n\n// Helper: Mock float decoders (FLOAT or DOUBLE)\nfunction mockFloatDecoder(scalarType: ScalarType) {\n    if (scalarType === ScalarType.FLOAT) {\n        vi.spyOn(decodingUtils, \"decodeFloatsLE\").mockReturnValue(new Float32Array([100.5, 200.5, 300.5]));\n    } else if (scalarType === ScalarType.DOUBLE) {\n        vi.spyOn(decodingUtils, \"decodeDoublesLE\").mockReturnValue(new Float64Array([100.5, 200.5, 300.5]));\n    }\n}\n\n// Helper: Mock nullable float decoders\nfunction mockNullableFloatDecoder(scalarType: ScalarType) {\n    if (scalarType === ScalarType.FLOAT) {\n        vi.spyOn(decodingUtils, \"decodeNullableFloatsLE\").mockReturnValue(new Float32Array([100.5, 200.5, 300.5]));\n    } else if (scalarType === ScalarType.DOUBLE) {\n        vi.spyOn(decodingUtils, \"decodeNullableDoublesLE\").mockReturnValue(new Float64Array([100.5, 200.5, 300.5]));\n    }\n}\n\n// Helper: Mock nullable integer decoders\nfunction mockNullableIntegerDecoder(scalarType: ScalarType) {\n    vi.spyOn(IntegerStreamDecoder, \"getVectorType\").mockReturnValue(VectorType.FLAT);\n\n    if (scalarType === ScalarType.INT_64 || scalarType === ScalarType.UINT_64) {\n        vi.spyOn(IntegerStreamDecoder, \"decodeNullableLongStream\").mockReturnValue(\n            new BigInt64Array([100n, 200n, 300n]),\n        );\n    } else {\n        vi.spyOn(IntegerStreamDecoder, \"decodeNullableIntStream\").mockReturnValue(new Int32Array([100, 200, 300]));\n    }\n}\n\n// Helper: Setup nullable column with separate nullability stream\nfunction setupNullableStreamMocks() {\n    const metadataSpy = vi.spyOn(StreamMetadataDecoder, \"decodeStreamMetadata\");\n\n    // First call: nullability stream\n    metadataSpy.mockReturnValueOnce({\n        byteLength: TEST_DATA.NULLABILITY_BYTE_LENGTH,\n        numValues: TEST_DATA.NUM_VALUES,\n        logicalLevelTechnique1: 0,\n        logicalLevelTechnique2: 0,\n        physicalLevelTechnique: 0,\n    } as any);\n\n    // Subsequent calls: data stream\n    metadataSpy.mockReturnValue(mockStreamMetadata());\n\n    // Mock the nullability bitmap decoding\n    vi.spyOn(decodingUtils, \"decodeBooleanRle\").mockReturnValue(new Uint8Array([0b00000111]));\n}\n\ndescribe(\"decodePropertyColumn\", () => {\n    afterEach(() => vi.restoreAllMocks());\n\n    describe(\"Number Columns - Non-Nullable - Signed Types\", () => {\n        const numberTypes = [\n            {\n                scalarType: ScalarType.INT_32,\n                vectorClass: IntFlatVector,\n                mockFn: mockIntegerDecoder,\n                testName: \"INT_32\",\n            },\n            {\n                scalarType: ScalarType.INT_64,\n                vectorClass: LongFlatVector,\n                mockFn: mockIntegerDecoder,\n                testName: \"INT_64\",\n            },\n        ];\n\n        it.each(numberTypes)(\"should decode $testName column\", ({ scalarType, vectorClass, mockFn }) => {\n            // Arrange\n            vi.spyOn(StreamMetadataDecoder, \"decodeStreamMetadata\").mockReturnValue(mockStreamMetadata());\n            mockFn(scalarType);\n            const column = createColumn(scalarType, false);\n            const data = new Uint8Array(TEST_DATA.BUFFER_SIZE);\n            const offset = new IntWrapper(0);\n\n            // Act\n            const result = decodePropertyColumn(data, offset, column, 1, TEST_DATA.NUM_VALUES);\n\n            // Assert\n            expect(result).toBeInstanceOf(vectorClass);\n            expect((result as any)._name).toBe(\"age\");\n            expect((result as any).dataBuffer).toHaveLength(TEST_DATA.NUM_VALUES);\n        });\n    });\n\n    describe(\"Number Columns - Non-Nullable - Unsigned Types\", () => {\n        const numberTypes = [\n            {\n                scalarType: ScalarType.UINT_32,\n                vectorClass: IntFlatVector,\n                mockFn: mockIntegerDecoder,\n                testName: \"UINT_32\",\n            },\n            {\n                scalarType: ScalarType.UINT_64,\n                vectorClass: LongFlatVector,\n                mockFn: mockIntegerDecoder,\n                testName: \"UINT_64\",\n            },\n        ];\n\n        it.each(numberTypes)(\"should decode $testName column\", ({ scalarType, vectorClass, mockFn }) => {\n            // Arrange\n            vi.spyOn(StreamMetadataDecoder, \"decodeStreamMetadata\").mockReturnValue(mockStreamMetadata());\n            mockFn(scalarType);\n            const column = createColumn(scalarType, false);\n            const data = new Uint8Array(TEST_DATA.BUFFER_SIZE);\n            const offset = new IntWrapper(0);\n\n            // Act\n            const result = decodePropertyColumn(data, offset, column, 1, TEST_DATA.NUM_VALUES);\n\n            // Assert\n            expect(result).toBeInstanceOf(vectorClass);\n            expect((result as any)._name).toBe(\"age\");\n            expect((result as any).dataBuffer).toHaveLength(TEST_DATA.NUM_VALUES);\n        });\n    });\n\n    describe(\"Number Columns - Nullable - Signed Types\", () => {\n        const numberTypes = [\n            { scalarType: ScalarType.INT_32, mockFn: mockNullableIntegerDecoder, testName: \"INT_32\" },\n            { scalarType: ScalarType.INT_64, mockFn: mockNullableIntegerDecoder, testName: \"INT_64\" },\n        ];\n\n        it.each(numberTypes)(\"should decode nullable $testName column with null mask\", ({ scalarType, mockFn }) => {\n            // Arrange\n            setupNullableStreamMocks();\n            mockFn(scalarType);\n            const column = createColumn(scalarType, true);\n            const data = new Uint8Array(TEST_DATA.BUFFER_SIZE);\n            const offset = new IntWrapper(0);\n\n            // Act\n            const result = decodePropertyColumn(data, offset, column, 2, TEST_DATA.NUM_VALUES);\n\n            // Assert\n            expect(result).toBeDefined();\n            expect((result as any)._name).toBe(\"age\");\n        });\n    });\n\n    describe(\"Number Columns - Nullable - Unsigned Types\", () => {\n        const numberTypes = [\n            { scalarType: ScalarType.UINT_32, mockFn: mockNullableIntegerDecoder, testName: \"UINT_32\" },\n            { scalarType: ScalarType.UINT_64, mockFn: mockNullableIntegerDecoder, testName: \"UINT_64\" },\n        ];\n\n        it.each(numberTypes)(\"should decode nullable $testName column with null mask\", ({ scalarType, mockFn }) => {\n            // Arrange\n            setupNullableStreamMocks();\n            mockFn(scalarType);\n            const column = createColumn(scalarType, true);\n            const data = new Uint8Array(TEST_DATA.BUFFER_SIZE);\n            const offset = new IntWrapper(0);\n\n            // Act\n            const result = decodePropertyColumn(data, offset, column, 2, TEST_DATA.NUM_VALUES);\n\n            // Assert\n            expect(result).toBeDefined();\n            expect((result as any)._name).toBe(\"age\");\n        });\n    });\n\n    describe(\"Integer Vector Encoding Types - SEQUENCE\", () => {\n        const numberTypes = [\n            {\n                scalarType: ScalarType.INT_32,\n                vectorClass: IntSequenceVector,\n                mockFn: mockIntegerSequenceDecoder,\n                testName: \"INT_32\",\n            },\n            {\n                scalarType: ScalarType.INT_64,\n                vectorClass: LongSequenceVector,\n                mockFn: mockIntegerSequenceDecoder,\n                testName: \"INT_64\",\n            },\n        ];\n\n        it.each(numberTypes)(\n            \"should decode $testName with SEQUENCE encoding\",\n            ({ scalarType, vectorClass, mockFn }) => {\n                // Arrange\n                vi.spyOn(StreamMetadataDecoder, \"decodeStreamMetadata\").mockReturnValue(mockRleStreamMetadata());\n                mockFn(scalarType);\n                const column = createColumn(scalarType, false);\n                const data = new Uint8Array(TEST_DATA.BUFFER_SIZE);\n                const offset = new IntWrapper(0);\n\n                // Act\n                const result = decodePropertyColumn(data, offset, column, 1, TEST_DATA.NUM_VALUES);\n\n                // Assert\n                expect(result).toBeInstanceOf(vectorClass);\n                expect((result as any)._name).toBe(\"age\");\n            },\n        );\n    });\n\n    describe(\"Integer Vector Encoding Types - CONST\", () => {\n        const numberTypes = [\n            {\n                scalarType: ScalarType.INT_32,\n                vectorClass: IntConstVector,\n                mockFn: mockIntegerConstDecoder,\n                testName: \"INT_32\",\n            },\n            {\n                scalarType: ScalarType.INT_64,\n                vectorClass: LongConstVector,\n                mockFn: mockIntegerConstDecoder,\n                testName: \"INT_64\",\n            },\n        ];\n\n        it.each(numberTypes)(\"should decode $testName with CONST encoding\", ({ scalarType, vectorClass, mockFn }) => {\n            // Arrange\n            vi.spyOn(StreamMetadataDecoder, \"decodeStreamMetadata\").mockReturnValue(mockStreamMetadata());\n            mockFn(scalarType);\n            const column = createColumn(scalarType, false);\n            const data = new Uint8Array(TEST_DATA.BUFFER_SIZE);\n            const offset = new IntWrapper(0);\n\n            // Act\n            const result = decodePropertyColumn(data, offset, column, 1, TEST_DATA.NUM_VALUES);\n\n            // Assert\n            expect(result).toBeInstanceOf(vectorClass);\n            expect((result as any)._name).toBe(\"age\");\n        });\n    });\n\n    describe(\"Float Columns - Non-Nullable\", () => {\n        const numberTypes = [\n            {\n                scalarType: ScalarType.FLOAT,\n                vectorClass: FloatFlatVector,\n                mockFn: mockFloatDecoder,\n                testName: \"FLOAT\",\n            },\n            {\n                scalarType: ScalarType.DOUBLE,\n                vectorClass: DoubleFlatVector,\n                mockFn: mockFloatDecoder,\n                testName: \"DOUBLE\",\n            },\n        ];\n\n        it.each(numberTypes)(\"should decode $testName column\", ({ scalarType, vectorClass, mockFn }) => {\n            // Arrange\n            vi.spyOn(StreamMetadataDecoder, \"decodeStreamMetadata\").mockReturnValue(mockStreamMetadata());\n            mockFn(scalarType);\n            const column = createColumn(scalarType, false);\n            const data = new Uint8Array(TEST_DATA.BUFFER_SIZE);\n            const offset = new IntWrapper(0);\n\n            // Act\n            const result = decodePropertyColumn(data, offset, column, 1, TEST_DATA.NUM_VALUES);\n\n            // Assert\n            expect(result).toBeInstanceOf(vectorClass);\n            expect((result as any)._name).toBe(\"age\");\n            expect((result as any).dataBuffer).toHaveLength(TEST_DATA.NUM_VALUES);\n        });\n    });\n\n    describe(\"Float Columns - Nullable\", () => {\n        const numberTypes = [\n            {\n                scalarType: ScalarType.FLOAT,\n                vectorClass: FloatFlatVector,\n                mockFn: mockNullableFloatDecoder,\n                testName: \"FLOAT\",\n            },\n            {\n                scalarType: ScalarType.DOUBLE,\n                vectorClass: DoubleFlatVector,\n                mockFn: mockNullableFloatDecoder,\n                testName: \"DOUBLE\",\n            },\n        ];\n\n        it.each(numberTypes)(\n            \"should decode nullable $testName column with null mask\",\n            ({ scalarType, vectorClass, mockFn }) => {\n                // Arrange\n                setupNullableStreamMocks();\n                mockFn(scalarType);\n                const column = createColumn(scalarType, true);\n                const data = new Uint8Array(TEST_DATA.BUFFER_SIZE);\n                const offset = new IntWrapper(0);\n\n                // Act\n                const result = decodePropertyColumn(data, offset, column, 2, TEST_DATA.NUM_VALUES);\n\n                // Assert\n                expect(result).toBeInstanceOf(vectorClass);\n                expect((result as any)._name).toBe(\"age\");\n            },\n        );\n    });\n\n    describe(\"Boolean Columns\", () => {\n        it(\"should decode non-nullable BOOLEAN column\", () => {\n            // Arrange\n            vi.spyOn(StreamMetadataDecoder, \"decodeStreamMetadata\").mockReturnValue(mockStreamMetadata());\n            vi.spyOn(decodingUtils, \"decodeBooleanRle\").mockReturnValue(new Uint8Array([0b00000111]));\n            const column = createColumn(ScalarType.BOOLEAN, false);\n            const data = new Uint8Array(TEST_DATA.BUFFER_SIZE);\n            const offset = new IntWrapper(0);\n\n            // Act\n            const result = decodePropertyColumn(data, offset, column, 1, TEST_DATA.NUM_VALUES);\n\n            // Assert\n            expect(result).toBeInstanceOf(BooleanFlatVector);\n            expect((result as any)._name).toBe(\"age\");\n        });\n\n        it(\"should decode nullable BOOLEAN column with null mask\", () => {\n            // Arrange\n            setupNullableStreamMocks();\n            vi.spyOn(decodingUtils, \"decodeNullableBooleanRle\").mockReturnValue(new Uint8Array([0b00000111]));\n            const column = createColumn(ScalarType.BOOLEAN, true);\n            const data = new Uint8Array(TEST_DATA.BUFFER_SIZE);\n            const offset = new IntWrapper(0);\n\n            // Act\n            const result = decodePropertyColumn(data, offset, column, 2, TEST_DATA.NUM_VALUES);\n\n            // Assert\n            expect(result).toBeInstanceOf(BooleanFlatVector);\n            expect((result as any)._name).toBe(\"age\");\n        });\n    });\n\n    describe(\"String Columns - Nullable\", () => {\n        const streamConfigs = [\n            { totalStreams: 2, description: \"single data stream\" },\n            { totalStreams: 4, description: \"multiple data streams\" },\n        ];\n\n        it.each(streamConfigs)(\"should decode nullable STRING with $description\", ({ totalStreams }) => {\n            // Arrange\n            setupNullableStreamMocks();\n            const mockStringVector = { name: \"age\" };\n            const stringDecodeSpy = vi.spyOn(StringDecoder, \"decodeString\").mockReturnValue(mockStringVector as any);\n            const column = createColumn(ScalarType.STRING, true);\n            const data = new Uint8Array(TEST_DATA.BUFFER_SIZE);\n            const offset = new IntWrapper(0);\n\n            // Act\n            const result = decodePropertyColumn(data, offset, column, totalStreams, TEST_DATA.NUM_VALUES);\n\n            // Assert\n            expect((result as StringFlatVector).name).toBe(mockStringVector.name);\n        });\n    });\n\n    describe(\"Column Filtering\", () => {\n        it(\"should return null when column NOT in propertyColumnNames filter\", () => {\n            // Arrange\n            vi.spyOn(StreamMetadataDecoder, \"decodeStreamMetadata\").mockReturnValue(mockStreamMetadata());\n            const skipColumnSpy = vi.spyOn(decodingUtils, \"skipColumn\");\n            const column = createColumn(ScalarType.STRING);\n            const filterList = new Set([\"name\", \"value\"]);\n            const data = new Uint8Array(TEST_DATA.BUFFER_SIZE);\n            const offset = new IntWrapper(0);\n\n            // Act\n            const result = decodePropertyColumn(data, offset, column, 1, TEST_DATA.NUM_VALUES, filterList);\n\n            // Assert\n            expect(result).toBeNull();\n            expect(skipColumnSpy).toHaveBeenCalledWith(1, data, offset);\n        });\n\n        it(\"should decode column when it IS in propertyColumnNames filter\", () => {\n            // Arrange\n            vi.spyOn(StreamMetadataDecoder, \"decodeStreamMetadata\").mockReturnValue(mockStreamMetadata());\n            vi.spyOn(decodingUtils, \"decodeBooleanRle\").mockReturnValue(new Uint8Array([0b00000111]));\n            const column = createColumn(ScalarType.BOOLEAN);\n            const filterList = new Set([\"age\", \"name\"]);\n            const data = new Uint8Array(TEST_DATA.BUFFER_SIZE);\n            const offset = new IntWrapper(0);\n\n            // Act\n            const result = decodePropertyColumn(data, offset, column, 1, TEST_DATA.NUM_VALUES, filterList);\n\n            // Assert\n            expect(result).toBeInstanceOf(BooleanFlatVector);\n        });\n\n        it(\"should ignore filter when propertyColumnNames is undefined\", () => {\n            // Arrange\n            vi.spyOn(StreamMetadataDecoder, \"decodeStreamMetadata\").mockReturnValue(mockStreamMetadata());\n            vi.spyOn(decodingUtils, \"decodeBooleanRle\").mockReturnValue(new Uint8Array([0b00000111]));\n            const column = createColumn(ScalarType.BOOLEAN);\n            const data = new Uint8Array(TEST_DATA.BUFFER_SIZE);\n            const offset = new IntWrapper(0);\n\n            // Act\n            const result = decodePropertyColumn(data, offset, column, 1, TEST_DATA.NUM_VALUES, undefined);\n\n            // Assert\n            expect(result).toBeInstanceOf(BooleanFlatVector);\n        });\n\n        it(\"should handle empty filter set\", () => {\n            // Arrange\n            vi.spyOn(StreamMetadataDecoder, \"decodeStreamMetadata\").mockReturnValue(mockStreamMetadata());\n            const skipColumnSpy = vi.spyOn(decodingUtils, \"skipColumn\");\n            const column = createColumn(ScalarType.BOOLEAN);\n            const filterList = new Set<string>();\n            const data = new Uint8Array(TEST_DATA.BUFFER_SIZE);\n            const offset = new IntWrapper(0);\n\n            // Act\n            const result = decodePropertyColumn(data, offset, column, 1, TEST_DATA.NUM_VALUES, filterList);\n\n            // Assert\n            expect(result).toBeNull();\n            expect(skipColumnSpy).toHaveBeenCalled();\n        });\n    });\n\n    describe(\"Edge Cases\", () => {\n        it(\"should handle single value column\", () => {\n            // Arrange\n            vi.spyOn(StreamMetadataDecoder, \"decodeStreamMetadata\").mockReturnValue(mockStreamMetadata(12, 1));\n            vi.spyOn(IntegerStreamDecoder, \"getVectorType\").mockReturnValue(VectorType.FLAT);\n            vi.spyOn(IntegerStreamDecoder, \"decodeIntStream\").mockReturnValue(new Int32Array([42]));\n            const column = createColumn(ScalarType.INT_32);\n            const data = new Uint8Array(TEST_DATA.BUFFER_SIZE);\n            const offset = new IntWrapper(0);\n\n            // Act\n            const result = decodePropertyColumn(data, offset, column, 1, 1);\n\n            // Assert\n            expect(result).toBeInstanceOf(IntFlatVector);\n            expect((result as any).dataBuffer).toHaveLength(1);\n        });\n\n        it(\"should handle large column with many values\", () => {\n            // Arrange\n            const largeNumValues = 100000;\n            vi.spyOn(StreamMetadataDecoder, \"decodeStreamMetadata\").mockReturnValue(\n                mockStreamMetadata(400000, largeNumValues),\n            );\n            vi.spyOn(IntegerStreamDecoder, \"getVectorType\").mockReturnValue(VectorType.FLAT);\n            const largeArray = new Int32Array(largeNumValues);\n            for (let i = 0; i < largeNumValues; i++) {\n                largeArray[i] = i;\n            }\n            vi.spyOn(IntegerStreamDecoder, \"decodeIntStream\").mockReturnValue(largeArray);\n            const column = createColumn(ScalarType.INT_32);\n            const data = new Uint8Array(TEST_DATA.BUFFER_SIZE);\n            const offset = new IntWrapper(0);\n\n            // Act\n            const result = decodePropertyColumn(data, offset, column, 1, largeNumValues);\n\n            // Assert\n            expect(result).toBeInstanceOf(IntFlatVector);\n            expect((result as any).dataBuffer).toHaveLength(largeNumValues);\n        });\n\n        it(\"should handle zero numValues gracefully\", () => {\n            // Arrange\n            vi.spyOn(StreamMetadataDecoder, \"decodeStreamMetadata\").mockReturnValue({\n                ...mockStreamMetadata(),\n                numValues: 0,\n            });\n            vi.spyOn(IntegerStreamDecoder, \"getVectorType\").mockReturnValue(VectorType.FLAT);\n            vi.spyOn(IntegerStreamDecoder, \"decodeIntStream\").mockReturnValue(new Int32Array(0));\n            const column = createColumn(ScalarType.INT_32);\n            const data = new Uint8Array(TEST_DATA.BUFFER_SIZE);\n            const offset = new IntWrapper(0);\n\n            // Act\n            const result = decodePropertyColumn(data, offset, column, 1, 0);\n\n            // Assert\n            expect(result).toBeInstanceOf(IntFlatVector);\n            expect((result as any).dataBuffer).toHaveLength(0);\n        });\n\n        it(\"should handle multiple sequential columns with offset advancement\", () => {\n            // Arrange\n            vi.spyOn(StreamMetadataDecoder, \"decodeStreamMetadata\").mockReturnValue(mockStreamMetadata(12, 3));\n            vi.spyOn(IntegerStreamDecoder, \"getVectorType\").mockReturnValue(VectorType.FLAT);\n            vi.spyOn(IntegerStreamDecoder, \"decodeIntStream\").mockReturnValue(new Int32Array([100, 200, 300]));\n            const column1 = createColumn(ScalarType.INT_32);\n            const column2 = createColumn(ScalarType.INT_32);\n            const data = new Uint8Array(TEST_DATA.BUFFER_SIZE);\n            const offset = new IntWrapper(0);\n\n            // Act\n            const result1 = decodePropertyColumn(data, offset, column1, 1, TEST_DATA.NUM_VALUES);\n            const offsetAfterFirst = offset.get();\n            const result2 = decodePropertyColumn(data, offset, column2, 1, TEST_DATA.NUM_VALUES);\n            const offsetAfterSecond = offset.get();\n\n            // Assert\n            expect(result1).toBeInstanceOf(IntFlatVector);\n            expect(result2).toBeInstanceOf(IntFlatVector);\n            expect(offsetAfterSecond).toEqual(offsetAfterFirst);\n        });\n\n        it(\"should handle non-scalar column type returning null\", () => {\n            // Arrange\n            const column: Column = {\n                name: \"complex\",\n                nullable: false,\n                columnScope: null,\n                type: \"complexType\",\n                complexType: { type: \"arrayType\" },\n                scalarType: null,\n            } as any;\n            const data = new Uint8Array(TEST_DATA.BUFFER_SIZE);\n            const offset = new IntWrapper(0);\n\n            // Act\n            const result = decodePropertyColumn(data, offset, column, 2, TEST_DATA.NUM_VALUES);\n\n            // Assert\n            expect(result).toBeNull();\n        });\n    });\n\n    describe(\"Offset Management\", () => {\n        it(\"should handle offset at non-zero starting position\", () => {\n            // Arrange\n            vi.spyOn(StreamMetadataDecoder, \"decodeStreamMetadata\").mockReturnValue(mockStreamMetadata());\n            vi.spyOn(IntegerStreamDecoder, \"getVectorType\").mockReturnValue(VectorType.FLAT);\n            vi.spyOn(IntegerStreamDecoder, \"decodeIntStream\").mockReturnValue(new Int32Array([100, 200, 300]));\n\n            const column = createColumn(ScalarType.INT_32);\n            const data = new Uint8Array(TEST_DATA.BUFFER_SIZE);\n            const startOffset = 50;\n            const offset = new IntWrapper(startOffset);\n\n            // Act\n            const result = decodePropertyColumn(data, offset, column, 1, TEST_DATA.NUM_VALUES);\n\n            // Assert\n            expect(result).toBeInstanceOf(IntFlatVector);\n            expect(offset.get()).toEqual(startOffset);\n        });\n\n        it(\"should correctly skip columns with filterList and advance offset\", () => {\n            // Arrange\n            vi.spyOn(StreamMetadataDecoder, \"decodeStreamMetadata\").mockReturnValue(mockStreamMetadata());\n            const skipColumnSpy = vi\n                .spyOn(decodingUtils, \"skipColumn\")\n                .mockImplementation((numStreams, data, offset) => {\n                    offset.add(12 * numStreams); // Simulate skipping\n                });\n\n            const column = createColumn(ScalarType.INT_32);\n            const filterList = new Set([\"other_column\"]);\n            const data = new Uint8Array(TEST_DATA.BUFFER_SIZE);\n            const offset = new IntWrapper(0);\n            const startOffset = offset.get();\n\n            // Act\n            const result = decodePropertyColumn(data, offset, column, 3, TEST_DATA.NUM_VALUES, filterList);\n\n            // Assert\n            expect(result).toBeNull();\n            expect(offset.get()).toBeGreaterThan(startOffset);\n            expect(skipColumnSpy).toHaveBeenCalledWith(3, data, offset);\n        });\n    });\n\n    describe(\"Type Consistency Checks\", () => {\n        it(\"should preserve column metadata in returned vector\", () => {\n            // Arrange\n            vi.spyOn(StreamMetadataDecoder, \"decodeStreamMetadata\").mockReturnValue(mockStreamMetadata());\n            vi.spyOn(IntegerStreamDecoder, \"getVectorType\").mockReturnValue(VectorType.FLAT);\n            vi.spyOn(IntegerStreamDecoder, \"decodeIntStream\").mockReturnValue(new Int32Array([10, 20, 30]));\n\n            const column = createColumn(ScalarType.INT_32);\n            const data = new Uint8Array(TEST_DATA.BUFFER_SIZE);\n            const offset = new IntWrapper(0);\n\n            // Act\n            const result = decodePropertyColumn(data, offset, column, 1, TEST_DATA.NUM_VALUES);\n\n            // Assert\n            expect((result as any)._name).toBe(column.name);\n        });\n\n        it(\"should handle all signed and unsigned type combinations\", () => {\n            // Arrange\n            const types = [ScalarType.INT_32, ScalarType.UINT_32, ScalarType.INT_64, ScalarType.UINT_64];\n\n            types.forEach((scalarType) => {\n                vi.spyOn(StreamMetadataDecoder, \"decodeStreamMetadata\").mockReturnValue(mockStreamMetadata());\n                mockIntegerDecoder(scalarType);\n\n                const column = createColumn(scalarType, false);\n                const data = new Uint8Array(TEST_DATA.BUFFER_SIZE);\n                const offset = new IntWrapper(0);\n\n                // Act\n                const result = decodePropertyColumn(data, offset, column, 1, TEST_DATA.NUM_VALUES);\n\n                // Assert\n                expect(result).toBeDefined();\n                expect((result as any)._name).toBe(\"age\");\n\n                vi.restoreAllMocks();\n            });\n        });\n    });\n\n    describe(\"Error Scenarios\", () => {\n        it(\"should handle invalid scalar type gracefully\", () => {\n            // Arrange\n            vi.spyOn(StreamMetadataDecoder, \"decodeStreamMetadata\").mockReturnValue(mockStreamMetadata());\n            const column = createColumn(999 as any); // Invalid type\n            const data = new Uint8Array(TEST_DATA.BUFFER_SIZE);\n            const offset = new IntWrapper(0);\n\n            // Act & Assert\n            expect(() => {\n                decodePropertyColumn(data, offset, column, 1, TEST_DATA.NUM_VALUES);\n            }).toThrow();\n        });\n\n        it(\"should handle mismatched numStreams for string type\", () => {\n            // Arrange\n            vi.spyOn(StreamMetadataDecoder, \"decodeStreamMetadata\").mockReturnValue(mockStreamMetadata());\n            const column: Column = {\n                name: \"stringCol\",\n                nullable: false,\n                columnScope: null,\n                type: \"stringType\",\n                scalarType: null,\n                complexType: null,\n            } as any;\n            const data = new Uint8Array(TEST_DATA.BUFFER_SIZE);\n            const offset = new IntWrapper(0);\n\n            // Act\n            const result = decodePropertyColumn(data, offset, column, 2, TEST_DATA.NUM_VALUES);\n\n            // Assert\n            expect(result).toBeNull();\n        });\n    });\n});\n"]}