{"version":3,"file":"streamMetadataDecoder.js","sourceRoot":"","sources":["../../../src/metadata/tile/streamMetadataDecoder.ts"],"names":[],"mappings":"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","sourcesContent":["import { LogicalLevelTechnique } from \"./logicalLevelTechnique\";\nimport { PhysicalLevelTechnique } from \"./physicalLevelTechnique\";\nimport { decodeVarintInt32 } from \"../../decoding/integerDecodingUtils\";\nimport { PhysicalStreamType } from \"./physicalStreamType\";\nimport { LogicalStreamType } from \"./logicalStreamType\";\nimport { DictionaryType } from \"./dictionaryType\";\nimport { OffsetType } from \"./offsetType\";\nimport { LengthType } from \"./lengthType\";\nimport type IntWrapper from \"../../decoding/intWrapper\";\n\nexport type StreamMetadata = {\n    readonly physicalStreamType: PhysicalStreamType;\n    readonly logicalStreamType: LogicalStreamType;\n    readonly logicalLevelTechnique1: LogicalLevelTechnique;\n    readonly logicalLevelTechnique2: LogicalLevelTechnique;\n    readonly physicalLevelTechnique: PhysicalLevelTechnique;\n    readonly numValues: number;\n    readonly byteLength: number;\n    /**\n     * Returns the number of decompressed values.\n     * For non-RLE streams, this is the same as numValues.\n     * For RLE streams, this is overridden to return numRleValues.\n     */\n    readonly decompressedCount: number;\n};\n\nexport type MortonEncodedStreamMetadata = StreamMetadata & {\n    readonly numBits: number;\n    readonly coordinateShift: number;\n};\n\nexport type RleEncodedStreamMetadata = StreamMetadata & {\n    readonly runs: number;\n    readonly numRleValues: number;\n};\n\nexport function decodeStreamMetadata(tile: Uint8Array, offset: IntWrapper): StreamMetadata {\n    const streamMetadata = decodeStreamMetadataInternal(tile, offset);\n    if (streamMetadata.logicalLevelTechnique1 === LogicalLevelTechnique.MORTON) {\n        return decodePartialMortonEncodedStreamMetadata(streamMetadata, tile, offset);\n    }\n\n    if (\n        (LogicalLevelTechnique.RLE === streamMetadata.logicalLevelTechnique1 ||\n            LogicalLevelTechnique.RLE === streamMetadata.logicalLevelTechnique2) &&\n        PhysicalLevelTechnique.NONE !== streamMetadata.physicalLevelTechnique\n    ) {\n        return decodePartialRleEncodedStreamMetadata(streamMetadata, tile, offset);\n    }\n\n    return streamMetadata;\n}\n\nfunction decodePartialMortonEncodedStreamMetadata(\n    streamMetadata: StreamMetadata,\n    tile: Uint8Array,\n    offset: IntWrapper,\n): MortonEncodedStreamMetadata {\n    const mortonInfo = decodeVarintInt32(tile, offset, 2);\n    return {\n        physicalStreamType: streamMetadata.physicalStreamType,\n        logicalStreamType: streamMetadata.logicalStreamType,\n        logicalLevelTechnique1: streamMetadata.logicalLevelTechnique1,\n        logicalLevelTechnique2: streamMetadata.logicalLevelTechnique2,\n        physicalLevelTechnique: streamMetadata.physicalLevelTechnique,\n        numValues: streamMetadata.numValues,\n        byteLength: streamMetadata.byteLength,\n        decompressedCount: streamMetadata.decompressedCount,\n        numBits: mortonInfo[0],\n        coordinateShift: mortonInfo[1],\n    };\n}\n\nfunction decodePartialRleEncodedStreamMetadata(\n    streamMetadata: StreamMetadata,\n    tile: Uint8Array,\n    offset: IntWrapper,\n): RleEncodedStreamMetadata {\n    const rleInfo = decodeVarintInt32(tile, offset, 2);\n    return {\n        physicalStreamType: streamMetadata.physicalStreamType,\n        logicalStreamType: streamMetadata.logicalStreamType,\n        logicalLevelTechnique1: streamMetadata.logicalLevelTechnique1,\n        logicalLevelTechnique2: streamMetadata.logicalLevelTechnique2,\n        physicalLevelTechnique: streamMetadata.physicalLevelTechnique,\n        numValues: streamMetadata.numValues,\n        byteLength: streamMetadata.byteLength,\n        decompressedCount: rleInfo[1],\n        runs: rleInfo[0],\n        numRleValues: rleInfo[1],\n    };\n}\n\nfunction decodeStreamMetadataInternal(tile: Uint8Array, offset: IntWrapper): StreamMetadata {\n    const stream_type = tile[offset.get()];\n    const physicalStreamType = Object.values(PhysicalStreamType)[stream_type >> 4] as PhysicalStreamType;\n    let logicalStreamType: LogicalStreamType | null = null;\n\n    switch (physicalStreamType) {\n        case PhysicalStreamType.DATA:\n            logicalStreamType = new LogicalStreamType(\n                Object.values(DictionaryType)[stream_type & 0xf] as DictionaryType,\n            );\n            break;\n        case PhysicalStreamType.OFFSET:\n            logicalStreamType = new LogicalStreamType(null, Object.values(OffsetType)[stream_type & 0xf] as OffsetType);\n            break;\n        case PhysicalStreamType.LENGTH:\n            logicalStreamType = new LogicalStreamType(\n                null,\n                null,\n                Object.values(LengthType)[stream_type & 0xf] as LengthType,\n            );\n            break;\n    }\n    offset.increment();\n\n    const encodings_header = tile[offset.get()];\n    const llt1 = Object.values(LogicalLevelTechnique)[encodings_header >> 5] as LogicalLevelTechnique;\n    const llt2 = Object.values(LogicalLevelTechnique)[(encodings_header >> 2) & 0x7] as LogicalLevelTechnique;\n    const plt = Object.values(PhysicalLevelTechnique)[encodings_header & 0x3] as PhysicalLevelTechnique;\n    offset.increment();\n\n    const sizeInfo = decodeVarintInt32(tile, offset, 2);\n    const numValues = sizeInfo[0];\n    const byteLength = sizeInfo[1];\n\n    return {\n        physicalStreamType,\n        logicalStreamType,\n        logicalLevelTechnique1: llt1,\n        logicalLevelTechnique2: llt2,\n        physicalLevelTechnique: plt,\n        numValues,\n        byteLength,\n        decompressedCount: numValues,\n    };\n}\n"]}